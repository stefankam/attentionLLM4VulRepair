{"https://github.com/SovereignCloudStack/sonic-buildimage": {"5b0c4ec1e64f0bc604a3fd3e828b46d8974544d8": {"url": "https://api.github.com/repos/SovereignCloudStack/sonic-buildimage/commits/5b0c4ec1e64f0bc604a3fd3e828b46d8974544d8", "html_url": "https://github.com/SovereignCloudStack/sonic-buildimage/commit/5b0c4ec1e64f0bc604a3fd3e828b46d8974544d8", "sha": "5b0c4ec1e64f0bc604a3fd3e828b46d8974544d8", "keyword": "function injection malicious", "diff": "diff --git a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py\nindex 310d0433d..c1192b3a2 100644\n--- a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py\n@@ -6,8 +6,8 @@\n #\n #############################################################################\n \n-import os\n import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -27,7 +27,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n@@ -97,7 +97,7 @@ def __initialize_watchdog(self):\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py\nindex 53a01c1f1..c942a2fed 100644\n--- a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py\n@@ -6,9 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -38,22 +35,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py\nindex b124ca29f..b19fab85d 100644\n--- a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py\nindex c42176102..4205b17ef 100644\n--- a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py\n@@ -6,10 +6,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -30,7 +29,7 @@ class Sfp(SfpOptoeBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as4630_54pe-r0\"\n     HWSKU = \"Accton-AS4630-54PE\"\n@@ -60,7 +59,7 @@ def get_eeprom_path(self):\n         return self.port_to_eeprom_mapping[self.port_num]\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py\nindex 7a54eee6f..9f39c903c 100644\n--- a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py\n@@ -6,7 +6,7 @@\n #\n #############################################################################\n \n-import os\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -26,7 +26,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n SYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n@@ -95,7 +95,7 @@ def __initialize_watchdog(self):\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py\nindex c34da7044..8137d0f3a 100644\n--- a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py\n@@ -6,9 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -38,22 +35,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()        \n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py\nindex b124ca29f..b19fab85d 100644\n--- a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py\nindex 4529c2f0a..adab3d294 100644\n--- a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py\n@@ -8,10 +8,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -127,7 +126,7 @@ class Sfp(SfpBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-accton_as4630_54te-r0\"\n     HWSKU = \"Accton-AS4630-54TE\"\n@@ -193,7 +192,7 @@ def __write_txt_file(self, file_path, value):\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py\nindex dce9f3c15..c4a062f49 100644\n--- a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py\n@@ -6,8 +6,8 @@\n #\n #############################################################################\n \n-import os\n import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -28,7 +28,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE= \"/sys/class/leds/as5835_54x_led::diag/brightness\"\n \n SYSLED_MODES = {\n@@ -98,7 +98,7 @@ def __initialize_watchdog(self):\n     \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py\nindex f3c9b3cee..ef47a154e 100644\n--- a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py\n@@ -6,10 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n-\n try:\n     from sonic_platform_base.component_base import ComponentBase\n     from .helper import APIHelper\n@@ -44,23 +40,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()\n \n-\n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py\nindex b124ca29f..b19fab85d 100644\n--- a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py\nindex ec16e8056..39813a877 100644\n--- a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py\n@@ -6,10 +6,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -31,7 +30,7 @@ class Sfp(SfpOptoeBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as5835_54x-r0\"\n     HWSKU = \"Accton-AS5835-54X\"\n@@ -121,7 +120,7 @@ def __get_cpld_num(self, port_num):\n \n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess(self.HOST_CHK_CMD).returncode == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py\nindex 86ae121c6..178f3c562 100644\n--- a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py\n@@ -5,12 +5,7 @@\n #\n #############################################################################\n try:\n-    import sys\n-    import re\n-    import os\n     import subprocess\n-    import json\n-    import syslog\n     from sonic_platform_base.chassis_base import ChassisBase\n     from sonic_py_common.logger import Logger\n     from sonic_platform.fan import Fan\n@@ -36,7 +31,7 @@\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n COMPONENT_NAME_LIST = [\"BIOS\"]\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n@@ -71,7 +66,7 @@ def __init__(self):\n         logger.log_info(\"Chassis loaded successfully\")\n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py\nindex 15d8e9e15..5e1e800d5 100644\n--- a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py\n@@ -3,10 +3,7 @@\n # provides the components firmware management function\n #############################################################################\n \n-import json\n import os.path\n-import shutil\n-import shlex\n import subprocess\n \n try:\n@@ -29,8 +26,7 @@ def __init__(self, component_name):\n     def __run_command(self, command):\n         # Run bash command and print output to stdout\n         try:\n-            process = subprocess.Popen(\n-                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n+            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n             while True:\n                 output = process.stdout.readline()\n                 if output == '' and process.poll() is not None:\ndiff --git a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py\nindex 6aabc1441..39c21c0d1 100644\n--- a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py\n@@ -3,10 +3,8 @@\n # provides the sfp device status which are available in the platform\n #############################################################################\n try:\n-    import os\n     import time\n     import subprocess\n-    import syslog\n     from ctypes import create_string_buffer\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom\n@@ -173,7 +171,7 @@ class Sfp(SfpBase):\n \n     PLATFORM_ROOT_PATH = '/usr/share/sonic/device'\n     PMON_HWSKU_PATH = '/usr/share/sonic/hwsku'\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-accton_as7116_54x-r0\"\n     HWSKU = \"Accton-AS7116-54X-R0\"\n@@ -233,7 +231,7 @@ def __read_txt_file(self, file_path):\n         return \"\"\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py\nindex ceece0f9d..a1143b112 100644\n--- a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py\n@@ -6,7 +6,7 @@\n #\n #############################################################################\n \n-import os\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -24,7 +24,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n@@ -87,7 +87,7 @@ def __initialize_watchdog(self):\n     \n     \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py\nindex 5300e1e73..2ba405f9f 100644\n--- a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py\n@@ -6,8 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -43,22 +41,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py\nindex 4cd60ac90..2c644ecbf 100644\n--- a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py\nindex 445b39edc..fd6d0f852 100644\n--- a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py\n@@ -6,10 +6,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -125,7 +124,7 @@ class Sfp(SfpBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n         \n     PLATFORM = \"x86_64-accton_as7312_54x-r0\"\n     HWSKU = \"Accton-AS7312-54X\"\n@@ -256,7 +255,7 @@ def __write_txt_file(self, file_path, value):\n         return True\n     \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py\nindex f32f381b7..1c97d0e87 100644\n--- a/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py\n@@ -6,8 +6,8 @@\n #\n #############################################################################\n \n-import os\n import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -27,7 +27,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE= \"/sys/class/leds/accton_as7326_56x_led::diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n@@ -93,7 +93,7 @@ def __initialize_watchdog(self):\n         self._watchdog = Watchdog()\n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py\nindex 95a54e554..16fe60bfb 100644\n--- a/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py\n@@ -6,10 +6,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -40,7 +39,7 @@ class Sfp(SfpOptoeBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n \n     PLATFORM = \"x86_64-accton_as7326_56x-r0\"\n     HWSKU = \"Accton-AS7326-56X\"\n@@ -144,7 +143,7 @@ def __write_txt_file(self, file_path, value):\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py\nindex 44a759045..164da5fd6 100644\n--- a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py\n@@ -6,8 +6,8 @@\n #\n #############################################################################\n \n-import os\n import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -26,7 +26,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE = \"/sys/class/leds/as7816_64x_led::diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n@@ -96,7 +96,7 @@ def __initialize_watchdog(self):\n     \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py\nindex 6af2f6008..d024e43e1 100644\n--- a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py\n@@ -6,8 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -43,22 +41,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py\nindex b124ca29f..b19fab85d 100644\n--- a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py\nindex 01e568ef3..d8ff303b3 100644\n--- a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py\n@@ -6,10 +6,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -31,7 +30,7 @@ class Sfp(SfpOptoeBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as7816_64x-r0\"\n     HWSKU = \"Accton-AS7816-64X\"\n@@ -119,7 +118,7 @@ def get_eeprom_path(self):\n         return self.port_to_eeprom_mapping[self.port_num]\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py\nindex 7eb9601d8..b0a573432 100644\n--- a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py\n@@ -6,7 +6,7 @@\n #\n #############################################################################\n \n-import os\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -28,7 +28,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n@@ -96,7 +96,7 @@ def __initialize_watchdog(self):\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py\nindex c34da7044..8137d0f3a 100644\n--- a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py\n@@ -6,9 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -38,22 +35,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()        \n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py\nindex 4cd60ac90..2c644ecbf 100644\n--- a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py\nindex 6cefc2a29..5d7c03d00 100644\n--- a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py\n@@ -6,11 +6,10 @@\n #\n #############################################################################\n \n-import os\n import sys\n import time\n import struct\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -272,7 +271,7 @@\n \n class Sfp(SfpBase):\n     \"\"\"Platform-specific Sfp class\"\"\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n     PLATFORM = \"x86_64-accton_as9726_32d-r0\"\n     HWSKU = \"Accton-AS9726-32D\"\n \n@@ -310,7 +309,7 @@ def __write_txt_file(self, file_path, value):\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py\nindex 226963415..2659d16f1 100644\n--- a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py\n@@ -8,8 +8,8 @@\n #############################################################################\n \n try:\n-    import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -67,8 +67,8 @@ def get_firmware_version(self):\n         if self.name == \"BIOS\":\n             fw_version = self.__get_bios_version()\n         elif \"CPLD\" in self.name:\n-            cmd = \"i2cget -f -y {0} {1} 0x1\".format(self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1])\n-            status, value = subprocess.getstatusoutput(cmd)\n+            cmd = [\"i2cget\", \"-f\", \"-y\", self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1], \"0x1\"]\n+            status, value = getstatusoutput_noshell(cmd)\n             if not status:\n                 fw_version = value.rstrip()\n \ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py\nindex b07417713..e79137785 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py\n@@ -26,9 +26,9 @@\n     import logging.config\n     import logging.handlers\n     import time\n-    import subprocess\n     from as4630_54pe.fanutil import FanUtil\n     from as4630_54pe.thermalutil import ThermalUtil\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n@@ -198,9 +198,9 @@ def manage_fans(self):\n         if temp[0] >= 70000: #LM75-48    \n             #critical case*/\n             logging.critical('Alarm-Critical for temperature critical is detected, reset DUT')\n-            cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2);\n-            status, output = subprocess.getstatusoutput(cmd_str)\n+            status, output = getstatusoutput_noshell(cmd_str)\n                 \n         #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_state, fan_policy_state, temp_val)\n         \ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py\nindex d9299b96a..6bbaeaa06 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py\n@@ -28,6 +28,7 @@\n     import logging.handlers\n     import time\n     from sonic_platform import platform\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n@@ -209,10 +210,12 @@ def manage_fans(self):\n             # Critical: Either all the fans are faulty or they are removed, shutdown the system\n             logging.critical('Alarm for all fan faulty/absent is detected')\n             logging.critical(\"Alarm for all fan faulty/absent is detected, reset DUT\")\n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2)\n-            subprocess.getstatusoutput('sync; sync; sync')\n-            subprocess.getstatusoutput(cmd_str)\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell(cmd_str)\n         elif sum(fan_fail_list) != 0:\n             # Set the 100% speed only for first fan failure detection\n             logging.warning('Fan_{} failed, set remaining fan speed to 100%'.format(\n@@ -235,7 +238,7 @@ def manage_fans(self):\n             as4630_54pe_set_fan_speed(new_duty_cycle)\n             if test_temp == 1:\n                 time.sleep(3)\n-                status, output = subprocess.getstatusoutput('pddf_fanutil getspeed')\n+                status, output = getstatusoutput_noshell(['pddf_fanutil', 'getspeed'])\n                 logging.debug('\\n%s\\n', output)\n \n         if temp[0] >= 70000:  # LM77-48\n@@ -252,10 +255,12 @@ def manage_fans(self):\n             if status:\n                 logging.warning('Reboot cause file not updated. {}'.format(output))\n \n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n-            subprocess.getstatusoutput('sync; sync; sync')\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n             time.sleep(3)\n-            subprocess.getstatusoutput(cmd_str)\n+            getstatusoutput_noshell(cmd_str)\n \n         logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n', ori_state, fan_policy_state, temp_val)\n \ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py\nindex 5a505e19f..5c00f338b 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py\n@@ -2,111 +2,111 @@\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import commands\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"clean\"])\n     if status:\n-        print \"accton_as4630_54pe_util.py clean command failed %d\"%status\n+        print(\"accton_as4630_54pe_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Stop pddf-platform-init.service along with other platform serives failed %d\"%status\n+        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status\n+        print(\"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status)\n         return False\n \n     return True\n     \n def start_platform_svc():\n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"install\"])\n     if status:\n-        print \"accton_as4630_54pe_util.py install  command failed %d\"%status\n+        print(\"accton_as4630_54pe_util.py install  command failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n \n     return True\n \n def start_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Start pddf-platform-init.service failed %d\"%status\n+        print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n+        print(\"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status)\n         return False\n     \n     return True\n \n def stop_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Stop pddf-platform-init.service failed %d\"%status\n+        print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n+        print(\"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status)\n         return False\n \n     return True\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py\nindex d3c2b2c86..aa5076c2c 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py\n@@ -20,7 +20,6 @@\n # ------------------------------------------------------------------\n \n try:\n-    import os\n     import sys\n     import getopt\n     import logging\n@@ -194,9 +193,9 @@ def manage_fans(self):\n             # critical case*/\n             logging.critical(\n                 'Alarm-Critical for temperature critical is detected, reset DUT')\n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2)\n-            return_value = os.system(cmd_str)\n+            return_value = subprocess.call(cmd_str)\n             logging.warning('Fan set: i2cset -y -f 3 0x60 0x4 0xE4, status is %d', return_value)\n \n         #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_state, fan_policy_state, temp_val)\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py b/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py\nindex 31697f7c6..9dc8d94ef 100644\n--- a/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py\n@@ -24,10 +24,8 @@\n # ------------------------------------------------------------------\n \n try:\n-    import time\n     import logging\n-    from collections import namedtuple\n-    import subprocess\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n@@ -65,10 +63,11 @@ def _get_fan_to_device_node(self, fan_num, node_num):\n         return \"fan{0}_{1}\".format(fan_num, self.node_postfix[node_num-1])\n     \n     def _get_fan_i2c_bus_addr(self):\n-        cmd_template = 'i2cget -f -y {} 0x{} 0'\n+        cmd_template = ['i2cget', '-f', '-y', '', '', '0']\n         for bus_no, dev_addr in self.I2CADDR_CANDIDATES:\n-            cmd = cmd_template.format(bus_no, dev_addr)\n-            if subprocess.getstatusoutput(cmd)[0] == 0:\n+            cmd_template[3] = str(bus_no)\n+            cmd_template[4] = '0x' + str(dev_addr)\n+            if getstatusoutput_noshell(cmd_template)[0] == 0:\n                 return bus_no, dev_addr\n         raise IOError('Unable to reach fan CPLD via I2C')\n \ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py\nindex ec3a4c133..da046335c 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py\n@@ -23,10 +23,10 @@\n # ------------------------------------------------------------------\n \n try:\n-    import os\n     import getopt\n     import sys\n     import logging\n+    import subprocess\n     import logging.config\n     import logging.handlers\n     import time  # this is only being used as part of the example\n@@ -233,7 +233,7 @@ def manage_fans(self):\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -242,7 +242,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -251,7 +251,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n@@ -260,7 +260,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is cleared')\n                 alarm_state=0\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py\nindex faa4f7d48..7f3add4e4 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py\n@@ -22,10 +22,10 @@\n # ------------------------------------------------------------------\n \n try:\n-    import os\n     import sys\n     import getopt\n     import logging\n+    import subprocess\n     import logging.config\n     import logging.handlers\n     import time\n@@ -218,7 +218,7 @@ def manage_fans(self):\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n         if ori_state == LEVEL_FAN_MID:\n             if new_state == LEVEL_TEMP_HIGH:\n                 if alarm_state == 0:\n@@ -227,7 +227,7 @@ def manage_fans(self):\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n         if ori_state == LEVEL_FAN_MAX:\n             if new_state == LEVEL_TEMP_HIGH:\n                 if alarm_state == 0:\n@@ -236,7 +236,7 @@ def manage_fans(self):\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if alarm_state == 1:\n                 if temp_get < (fan_policy[3][0] - 5000):  # below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n@@ -245,7 +245,7 @@ def manage_fans(self):\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is cleared')\n                 alarm_state = 0\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py\nindex c3e1c5036..f4335bd44 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py\n@@ -33,7 +33,7 @@\n import re\n import time\n import os\n-\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n PROJECT_NAME = 'as7326_56x'\n@@ -100,16 +100,16 @@ def show_help():\n \n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\n@@ -257,8 +257,8 @@ def i2c_order_check():\n     return 0\n \n def eeprom_check():\n-    cmd = \"i2cget -y -f 0 0x56\"\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cget\", \"-y\", \"-f\", \"0\", \"0x56\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def device_install():\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py\nindex 1b5f46ef0..f02202b21 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py\n@@ -2,39 +2,39 @@\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as7326-platform-fan.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as7326-platform-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Stop as7326-platform-init.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Disable as7326-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as7326_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n@@ -42,21 +42,21 @@ def stop_platform_svc():\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"install\"])\n     if status:\n         print(\"accton_as7326_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Enable as7326-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as7326-platform-monitor-fan.service failed %d\"%status)\n         return False\n         \n-    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as7326-platform-monitor-psu.service failed %d\"%status)\n         return False\n@@ -64,7 +64,7 @@ def start_platform_svc():\n     return True\n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n@@ -72,7 +72,7 @@ def start_platform_pddf():\n     return True\n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py\nindex 3ed3f7604..0f6c82893 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py\n@@ -1,28 +1,28 @@\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import commands\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = commands.getstatusoutput(\"systemctl stop as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Stop as7712-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl disable as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Disable as7712-platform-init.service failed %d\"%status)\n         return False\n     \n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"clean\"])\n     if status:\n-        print(\"accton_as7712_util.py clean command failed %d\"%status)\n+        print(\"accton_as7712_util.py clean failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n@@ -30,16 +30,16 @@ def stop_platform_svc():\n     return True\n     \n def start_platform_svc():\n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"install\"])\n     if status:\n-        print(\"accton_as7712_util.py install command failed %d\"%status)\n+        print(\"accton_as7712_util.py install failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Enable as7712-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Start as7712-platform-init.service failed %d\"%status)\n         return False\n@@ -47,7 +47,7 @@ def start_platform_svc():\n     return True\n \n def start_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n@@ -55,7 +55,7 @@ def start_platform_pddf():\n     return True\n \n def stop_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py b/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py\nindex 6322aac6b..f312d2261 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py\n@@ -36,6 +36,7 @@\n import logging\n import re\n import time\n+from sonic_py_common.general import getstatusoutput_noshell\n \n PROJECT_NAME = 'as7716_32x'\n version = '0.0.1'\n@@ -220,16 +221,16 @@ def  show_set_help():\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py\nindex f506b72f8..b889dcf71 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py\n@@ -23,10 +23,10 @@\n # ------------------------------------------------------------------\n \n try:\n-    import os\n     import getopt\n     import sys\n     import logging\n+    import subprocess\n     import logging.config\n     import logging.handlers\n     import time  # this is only being used as part of the example\n@@ -242,7 +242,7 @@ def manage_fans(self):\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -251,7 +251,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -260,7 +260,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n@@ -269,7 +269,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is cleared')\n                 alarm_state=0\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py\nindex fd283cd6c..2b18ac646 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py\n@@ -24,10 +24,10 @@\n # ------------------------------------------------------------------\n \n try:\n-    import os\n     import sys\n     import getopt\n     import logging\n+    import subprocess\n     import logging.config\n     import logging.handlers\n     import time\n@@ -230,7 +230,7 @@ def manage_fans(self):\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -239,7 +239,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -248,7 +248,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n@@ -257,7 +257,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is cleared')\n                 alarm_state=0\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py\nindex bee413fe0..949f1230d 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py\n@@ -32,6 +32,7 @@\n import logging\n import re\n import time\n+from sonic_py_common.general import getstatusoutput_noshell\n \n PROJECT_NAME = 'as7726_32x'\n version = '0.0.1'\n@@ -147,16 +148,16 @@ def show_help():\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py\nindex 9664d21b6..e8b42aaa1 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py\n@@ -2,44 +2,44 @@\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as7726_32x_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n@@ -47,32 +47,32 @@ def stop_platform_svc():\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py install\"])\n     if status:\n         print(\"accton_as7726_32x_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n@@ -80,7 +80,7 @@ def start_platform_svc():\n     return True\n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n@@ -88,7 +88,7 @@ def start_platform_pddf():\n     return True\n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py b/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py\nindex 1e9314fb8..5ab3d8f20 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py\n@@ -32,7 +32,7 @@\n import re\n import time\n import os\n-\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n PROJECT_NAME = 'as7816_64x'\n@@ -99,18 +99,17 @@ def show_help():\n     print( __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]})\n     sys.exit(0)\n \n-   \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py\nindex 98bf05eca..166b9c12f 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py\n@@ -1,7 +1,7 @@\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services.\n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n def check_pddf_support():\n@@ -10,22 +10,22 @@ def check_pddf_support():\n \n def stop_platform_svc():\n \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Stop as7816-platform-init.service failed %d\" % status))\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Disable as7816-platform-init.service failed %d\" % status))\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"clean\"])\n     if status:\n         print((\"accton_as7816_util.py clean command failed %d\" % status))\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Stop pddf-platform-init.service along with other platform serives failed %d\" % status))\n         return False\n@@ -34,12 +34,12 @@ def stop_platform_svc():\n \n \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"install\"])\n     if status:\n         print((\"accton_as7816_util.py install command failed %d\" % status))\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Enable as7816-platform-init.service failed %d\" % status))\n         return False\n@@ -48,7 +48,7 @@ def start_platform_svc():\n \n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Start pddf-platform-init.service failed %d\" % status))\n         return False\n@@ -57,7 +57,7 @@ def start_platform_pddf():\n \n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Stop pddf-platform-init.service failed %d\" % status))\n         return False\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py b/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py\nindex 647e26e07..53126109f 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py\n@@ -32,6 +32,7 @@\n import logging\n import re\n import time\n+from sonic_py_common.general import getstatusoutput_noshell\n \n PROJECT_NAME = 'as9716_32d'\n version = '0.0.1'\n@@ -153,16 +154,16 @@ def show_help():\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py\nindex 95e42b5c8..1d672015d 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py\n@@ -1,39 +1,39 @@\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-fan.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-init.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Disable as9716-32d-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as9716_32d_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n@@ -41,21 +41,21 @@ def stop_platform_svc():\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"install\"])\n     if status:\n         print(\"accton_as9716_32d_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Enable as9716-32d-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as9716-32d-platform-monitor-fan.service failed %d\"%status)\n         return False\n         \n-    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as9716-32d-platform-monitor-psu.service failed %d\"%status)\n         return False\n@@ -64,7 +64,7 @@ def start_platform_svc():\n \n def start_platform_pddf():   \n \n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n@@ -73,7 +73,7 @@ def start_platform_pddf():\n \n def stop_platform_pddf():   \n \n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\n", "message": "", "files": {"/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os import sys try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper from.event import SfpEvent except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=3 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=3 PORT_START=49 PORT_END=54 NUM_COMPONENT=2 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" SYSLED_FNODE=\"/sys/class/leds/diag/brightness\" SYSLED_MODES={ \"0\": \"STATUS_LED_COLOR_OFF\", \"1\": \"STATUS_LED_COLOR_GREEN\", \"2\": \"STATUS_LED_COLOR_AMBER\", \"5\": \"STATUS_LED_COLOR_GREEN_BLINK\" } class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(0, PORT_END): sfp=Sfp(index) self._sfp_list.append(sfp) self._sfpevent=SfpEvent(self._sfp_list) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for fant_index in range(NUM_FAN_TRAY): fandrawer=FanDrawer(fant_index) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._eeprom.get_product_name() def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_change_event(self, timeout=0): if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfpevent.get_sfp_event(timeout) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def initizalize_system_led(self): return True def get_status_led(self): val=self._api_helper.read_txt_file(SYSLED_FNODE) return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\" def set_status_led(self, color): mode=None for key, val in SYSLED_MODES.items(): if val==color: mode=key break if mode is None: return False else: return self._api_helper.write_txt_file(SYSLED_FNODE, mode) ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\nimport sys\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\n    from .event import SfpEvent\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 3\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 3\nPORT_START = 49\nPORT_END = 54\nNUM_COMPONENT = 2\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\nSYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\nSYSLED_MODES = {\n    \"0\" : \"STATUS_LED_COLOR_OFF\",\n    \"1\" : \"STATUS_LED_COLOR_GREEN\",\n    \"2\" : \"STATUS_LED_COLOR_AMBER\",\n    \"5\" : \"STATUS_LED_COLOR_GREEN_BLINK\"\n}\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n        \n        self.config_data = {}\n        \n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n    \n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(0, PORT_END):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self._sfpevent = SfpEvent(self._sfp_list)\n        self.sfp_module_initialized = True\n\n    def __initialize_fan(self):\n       from sonic_platform.fan_drawer import FanDrawer\n       for fant_index in range(NUM_FAN_TRAY):\n           fandrawer = FanDrawer(fant_index)\n           self._fan_drawer_list.append(fandrawer)\n           self._fan_list.extend(fandrawer._fan_list)\n               \n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n    \n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n    \n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n\n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        \n        return self._eeprom.get_product_name()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n\n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_change_event(self, timeout=0):\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return self._sfpevent.get_sfp_event(timeout)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n\n    def initizalize_system_led(self):\n        return True\n\n    def get_status_led(self):\n        val = self._api_helper.read_txt_file(SYSLED_FNODE)\n        return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\"\n\n    def set_status_led(self, color):\n        mode = None\n        for key, val in SYSLED_MODES.items():\n            if val == color:\n                mode = key\n                break\n        if mode is None:\n            return False\n        else:\n            return self._api_helper.write_txt_file(SYSLED_FNODE, mode)\n\n"}, "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 3, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try", "add": 0, "remove": 16, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"3-0060\" } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"BIOS\", \"Basic Input/Output System\") ] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return 'N/A' def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return 'N/A' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is'0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"3-0060\"\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n   \n]\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)\n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n        \n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n        \n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of\n        entPhysicalContainedIn is'0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device\n            or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, resu", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, resu"], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r', errors='replace') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r', errors='replace') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as4630_54pe-r0\"\n     HWSKU = \"Accton-AS4630-54PE\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n         return self.port_to_eeprom_mapping[self.port_num]\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFOR", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}], "source": "\n import os import time import sys from ctypes import create_string_buffer try: from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_I2C_PATH=\"/sys/bus/i2c/devices/3-0060/\" class Sfp(SfpOptoeBase): \"\"\"Platform-specific Sfp class\"\"\" PORT_START=49 PORT_END=54 PLATFORM_ROOT_PATH=\"/usr/share/sonic/device\" PMON_HWSKU_PATH=\"/usr/share/sonic/hwsku\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" PLATFORM=\"x86_64-accton_as4630_54pe-r0\" HWSKU=\"Accton-AS4630-54PE\" _port_to_i2c_mapping={ 49: 18, 50: 19, 51: 20, 52: 21, 53: 22, 54: 23, } def __init__(self, sfp_index=0): SfpOptoeBase.__init__(self) self._api_helper=APIHelper() self.index=sfp_index self.port_num=self.index +1 eeprom_path='/sys/bus/i2c/devices/{0}-0050/eeprom' self.port_to_eeprom_mapping={} for x in range(self.PORT_START, self.PORT_END +1): self.port_to_eeprom_mapping[x]=eeprom_path.format(self._port_to_i2c_mapping[x]) def get_eeprom_path(self): return self.port_to_eeprom_mapping[self.port_num] def __is_host(self): return os.system(self.HOST_CHK_CMD)==0 def __get_path_to_port_config_file(self): platform_path=\"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM]) hwsku_path=\"/\".join([platform_path, self.HWSKU] ) if self.__is_host() else self.PMON_HWSKU_PATH return \"/\".join([hwsku_path, \"port_config.ini\"]) def __read_eeprom_specific_bytes(self, offset, num_bytes): sysfsfile_eeprom=None eeprom_raw=[] for i in range(0, num_bytes): eeprom_raw.append(\"0x00\") sysfs_sfp_i2c_client_eeprom_path=self.port_to_eeprom_mapping[self.port_num] try: sysfsfile_eeprom=open( sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0) sysfsfile_eeprom.seek(offset) raw=sysfsfile_eeprom.read(num_bytes) if sys.version_info[0] >=3: for n in range(0, num_bytes): eeprom_raw[n]=hex(raw[n])[2:].zfill(2) else: for n in range(0, num_bytes): eeprom_raw[n]=hex(ord(raw[n]))[2:].zfill(2) except Exception: pass finally: if sysfsfile_eeprom: sysfsfile_eeprom.close() return eeprom_raw def get_reset_status(self): \"\"\" Retrieves the reset status of SFP Returns: A Boolean, True if reset enabled, False if disabled \"\"\" if self.port_num < 53: return False reset_path=\"{}{}{}\".format(CPLD_I2C_PATH, \"module_reset_\", str(self.port_num)) val=self._api_helper.read_txt_file(reset_path) if val is not None: return int(val, 10)==1 else: return False def get_rx_los(self): \"\"\" Retrieves the RX LOS(lost-of-signal) status of SFP Returns: A Boolean, True if SFP has RX LOS, False if not. Note: RX LOS status is latched until a call to get_rx_los or a reset. \"\"\" rx_los=False if self.port_num < 49: return False if self.port_num < 53: rx_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_rx_los_', self.port_num) rx_los=self._api_helper.read_txt_file(rx_path) if rx_los is None: return False else: rx_los_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: rx_los_data=int(dom_channel_monitor_raw[0], 16) rx_los_list.append(rx_los_data & 0x01 !=0) rx_los_list.append(rx_los_data & 0x02 !=0) rx_los_list.append(rx_los_data & 0x04 !=0) rx_los_list.append(rx_los_data & 0x08 !=0) rx_los=rx_los_list[0] and rx_los_list[1] and rx_los_list[2] and rx_los_list[3] return rx_los def get_tx_fault(self): \"\"\" Retrieves the TX fault status of SFP Returns: A Boolean, True if SFP has TX fault, False if not Note: TX fault status is lached until a call to get_tx_fault or a reset. \"\"\" tx_fault=False if self.port_num < 49: return False if self.port_num < 53: tx_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_fault_', self.port_num) tx_fault=self._api_helper.read_txt_file(tx_path) if tx_fault is None: return False else: tx_fault_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: tx_fault_data=int(dom_channel_monitor_raw[0], 16) tx_fault_list.append(tx_fault_data & 0x01 !=0) tx_fault_list.append(tx_fault_data & 0x02 !=0) tx_fault_list.append(tx_fault_data & 0x04 !=0) tx_fault_list.append(tx_fault_data & 0x08 !=0) tx_fault=tx_fault_list[0] and tx_fault_list[1] and tx_fault_list[2] and tx_fault_list[3] return tx_fault def get_tx_disable(self): \"\"\" Retrieves the tx_disable status of this SFP Returns: A Boolean, True if tx_disable is enabled, False if disabled \"\"\" if self.port_num < 49: return False if self.port_num < 53: tx_disable=False tx_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_disable_', self.port_num) tx_disable=self._api_helper.read_txt_file(tx_path) if tx_disable is not None: return tx_disable else: return False else: tx_disable_list=[] sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) tx_disable_list.append( 'On'==dom_control_data['data']['TX1Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX2Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX3Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX4Disable']['value']) return tx_disable_list def get_tx_disable_channel(self): \"\"\" Retrieves the TX disabled channels in this SFP Returns: A hex of 4 bits(bit 0 to bit 3 as channel 0 to channel 3) to represent TX channels which have been disabled in this SFP. As an example, a returned value of 0x5 indicates that channel 0 and channel 2 have been disabled. \"\"\" if self.port_num < 53: return False else: tx_disable_list=self.get_tx_disable() if tx_disable_list is None: return 0 tx_disabled=0 for i in range(len(tx_disable_list)): if tx_disable_list[i]: tx_disabled |=1 << i return tx_disabled def get_lpmode(self): \"\"\" Retrieves the lpmode(low power mode) status of this SFP Returns: A Boolean, True if lpmode is enabled, False if disabled \"\"\" if self.port_num < 53: return False else: power_set=self.get_power_set() power_override=self.get_power_override() return power_set and power_override def reset(self): \"\"\" Reset SFP and return all user module settings to their default srate. Returns: A boolean, True if successful, False if not \"\"\" if self.port_num < 53: return False reset_path=\"{}{}{}\".format(CPLD_I2C_PATH, 'module_reset_', self.port_num) ret=self._api_helper.write_txt_file(reset_path, 1) if ret is not True: return ret time.sleep(0.01) ret=self._api_helper.write_txt_file(reset_path, 0) time.sleep(0.2) return ret def tx_disable(self, tx_disable): \"\"\" Disable SFP TX for all channels Args: tx_disable: A Boolean, True to enable tx_disable mode, False to disable tx_disable mode. Returns: A boolean, True if tx_disable is set successfully, False if not \"\"\" if self.port_num < 49: return False if self.port_num < 53: tx_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_disable_', self.port_num) ret=self._api_helper.write_txt_file(tx_path, 1 if tx_disable else 0) if ret is not None: time.sleep(0.01) return ret else: return False else: if not self.get_presence(): return False sysfsfile_eeprom=None try: tx_disable_ctl=0xf if tx_disable else 0x0 buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=tx_disable_ctl else: buffer[0]=chr(tx_disable_ctl) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ',str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def tx_disable_channel(self, channel, disable): \"\"\" Sets the tx_disable for specified SFP channels Args: channel: A hex of 4 bits(bit 0 to bit 3) which represent channel 0 to 3, e.g. 0x5 for channel 0 and channel 2. disable: A boolean, True to disable TX channels specified in channel, False to enable Returns: A boolean, True if successful, False if not \"\"\" if self.port_num < 53: return False else: if not self.get_presence(): return False sysfsfile_eeprom=None try: channel_state=self.get_tx_disable_channel() for i in range(4): channel_mask=(1 << i) if not(channel & channel_mask): continue if disable: channel_state |=channel_mask else: channel_state &=~channel_mask buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=channel_state else: buffer[0]=chr(channel_state) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ', str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def set_lpmode(self, lpmode): \"\"\" Sets the lpmode(low power mode) of SFP Args: lpmode: A Boolean, True to enable lpmode, False to disable it Note : lpmode can be overridden by set_power_override Returns: A boolean, True if lpmode is set successfully, False if not \"\"\" if self.port_num < 53: return False else: if lpmode is True: self.set_power_override(True, True) else: self.set_power_override(False, False) return True def set_power_override(self, power_override, power_set): \"\"\" Sets SFP power level using power_override and power_set Args: power_override: A Boolean, True to override set_lpmode and use power_set to control SFP power, False to disable SFP power control through power_override/power_set and use set_lpmode to control SFP power. power_set: Only valid when power_override is True. A Boolean, True to set SFP to low power mode, False to set SFP to high power mode. Returns: A boolean, True if power-override and power_set are set successfully, False if not \"\"\" if self.port_num < 53: return False else: if not self.get_presence(): return False try: power_override_bit=(1 << 0) if power_override else 0 power_set_bit =(1 << 1) if power_set else(1 << 3) buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=(power_override_bit | power_set_bit) else: buffer[0]=chr(power_override_bit | power_set_bit) with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd: fd.seek(QSFP_POWEROVERRIDE_OFFSET) fd.write(buffer[0]) time.sleep(0.01) except IOError as e: print('Error: unable to open file: ', str(e)) return False return True def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" name=None sfputil_helper=SfpUtilHelper() sfputil_helper.read_porttab_mappings( self.__get_path_to_port_config_file()) name=sfputil_helper.logical[self.index] or \"Unknown\" return name def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" if self.port_num < 49: return False present_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_present_', self.port_num) val=self._api_helper.read_txt_file(present_path) if val is not None: return int(val, 10)==1 else: return False def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return self.get_presence() def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return self.port_num def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return True ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Sfp contains an implementation of SONiC Platform Base API and\n# provides the sfp device status which are available in the platform\n#\n#############################################################################\n\nimport os\nimport time\nimport sys\n\nfrom ctypes import create_string_buffer\n\ntry:\n    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_I2C_PATH = \"/sys/bus/i2c/devices/3-0060/\"\n\nclass Sfp(SfpOptoeBase):\n    \"\"\"Platform-specific Sfp class\"\"\"\n\n    # Port number\n    PORT_START = 49\n    PORT_END = 54\n\n    # Path to sysfs\n    PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n    PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n        \n    PLATFORM = \"x86_64-accton_as4630_54pe-r0\"\n    HWSKU = \"Accton-AS4630-54PE\"\n\n    _port_to_i2c_mapping = {\n           49: 18,\n           50: 19,\n           51: 20,\n           52: 21,\n           53: 22,\n           54: 23,\n    }\n\n    def __init__(self, sfp_index=0):\n        SfpOptoeBase.__init__(self)\n        self._api_helper=APIHelper()\n        # Init index\n        self.index = sfp_index\n        self.port_num = self.index + 1\n        # Init eeprom path\n        eeprom_path = '/sys/bus/i2c/devices/{0}-0050/eeprom'\n        self.port_to_eeprom_mapping = {}\n        for x in range(self.PORT_START, self.PORT_END + 1):\n            self.port_to_eeprom_mapping[x] = eeprom_path.format(self._port_to_i2c_mapping[x])\n\n    def get_eeprom_path(self):\n        return self.port_to_eeprom_mapping[self.port_num]\n\n    def __is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def __get_path_to_port_config_file(self):\n        platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n        hwsku_path = \"/\".join([platform_path, self.HWSKU]\n                              ) if self.__is_host() else self.PMON_HWSKU_PATH\n        return \"/\".join([hwsku_path, \"port_config.ini\"])\n\n    def __read_eeprom_specific_bytes(self, offset, num_bytes):\n        sysfsfile_eeprom = None\n        eeprom_raw = []\n        for i in range(0, num_bytes):\n            eeprom_raw.append(\"0x00\")\n\n        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]\n        try:\n            sysfsfile_eeprom = open(\n                sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0)\n            sysfsfile_eeprom.seek(offset)\n            raw = sysfsfile_eeprom.read(num_bytes)\n            if sys.version_info[0] >= 3:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(raw[n])[2:].zfill(2)\n            else:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(ord(raw[n]))[2:].zfill(2)\n        except Exception:\n            pass\n        finally:\n            if sysfsfile_eeprom:\n                sysfsfile_eeprom.close()\n\n        return eeprom_raw\n\n    def get_reset_status(self):\n        \"\"\"\n        Retrieves the reset status of SFP\n        Returns:\n            A Boolean, True if reset enabled, False if disabled\n        \"\"\"\n        if self.port_num < 53: #Copper port and sfp ports are suported.\n            return False\n\n        reset_path=\"{}{}{}\".format(CPLD_I2C_PATH , \"module_reset_\" , str(self.port_num))\n        val = self._api_helper.read_txt_file(reset_path)\n        \n        if val is not None:\n            return int(val, 10) == 1\n        else:        \n            return False\n\n    def get_rx_los(self):\n        \"\"\"\n        Retrieves the RX LOS (lost-of-signal) status of SFP\n        Returns:\n            A Boolean, True if SFP has RX LOS, False if not.\n            Note : RX LOS status is latched until a call to get_rx_los or a reset.\n        \"\"\"\n        rx_los = False\n        \n        if self.port_num < 49: #Copper port, no sysfs\n            return False\n            \n        if self.port_num < 53:\n            rx_path = \"{}{}{}\".format(CPLD_I2C_PATH, '/module_rx_los_', self.port_num)\n            rx_los=self._api_helper.read_txt_file(rx_path)\n            if rx_los is None:\n                return False\n        else:\n            rx_los_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None\n            if dom_channel_monitor_raw is not None:\n                rx_los_data = int(dom_channel_monitor_raw[0], 16)\n                rx_los_list.append(rx_los_data & 0x01 != 0)\n                rx_los_list.append(rx_los_data & 0x02 != 0)\n                rx_los_list.append(rx_los_data & 0x04 != 0)\n                rx_los_list.append(rx_los_data & 0x08 != 0)\n                rx_los = rx_los_list[0] and rx_los_list[1] and rx_los_list[2] and rx_los_list[3]\n        return rx_los\n\n    def get_tx_fault(self):\n        \"\"\"\n        Retrieves the TX fault status of SFP\n        Returns:\n            A Boolean, True if SFP has TX fault, False if not\n            Note : TX fault status is lached until a call to get_tx_fault or a reset.\n        \"\"\"\n        tx_fault = False\n        if self.port_num < 49: #Copper port, no sysfs\n            return False\n        \n        if self.port_num < 53:\n            tx_path = \"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_fault_', self.port_num)\n            tx_fault=self._api_helper.read_txt_file(tx_path)\n            if tx_fault is None:\n                return False\n        else:\n            tx_fault_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None\n            if dom_channel_monitor_raw is not None:\n                tx_fault_data = int(dom_channel_monitor_raw[0], 16)\n                tx_fault_list.append(tx_fault_data & 0x01 != 0)\n                tx_fault_list.append(tx_fault_data & 0x02 != 0)\n                tx_fault_list.append(tx_fault_data & 0x04 != 0)\n                tx_fault_list.append(tx_fault_data & 0x08 != 0)\n                tx_fault = tx_fault_list[0] and tx_fault_list[1] and tx_fault_list[2] and tx_fault_list[3]\n\n        return tx_fault\n\n    def get_tx_disable(self):\n        \"\"\"\n        Retrieves the tx_disable status of this SFP\n        Returns:\n            A Boolean, True if tx_disable is enabled, False if disabled\n        \"\"\"\n        if self.port_num < 49: #Copper port, no sysfs\n            return False\n        \n        if self.port_num < 53: \n            tx_disable = False            \n                \n            tx_path = \"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_disable_', self.port_num)\n            tx_disable=self._api_helper.read_txt_file(tx_path)\n            \n            if tx_disable is not None:\n                return tx_disable \n            else:\n                return False\n                   \n        else:\n            tx_disable_list = []\n    \n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n    \n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX1Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX2Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX3Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX4Disable']['value'])\n    \n            return tx_disable_list\n\n    def get_tx_disable_channel(self):\n        \"\"\"\n        Retrieves the TX disabled channels in this SFP\n        Returns:\n            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent\n            TX channels which have been disabled in this SFP.\n            As an example, a returned value of 0x5 indicates that channel 0\n            and channel 2 have been disabled.\n        \"\"\"\n        if self.port_num < 53: \n            # SFP doesn't support this feature\n            return False\n        else:\n            tx_disable_list = self.get_tx_disable()\n            if tx_disable_list is None:\n                return 0\n            tx_disabled = 0\n            for i in range(len(tx_disable_list)):\n                if tx_disable_list[i]:\n                    tx_disabled |= 1 << i\n            return tx_disabled\n\n    def get_lpmode(self):\n        \"\"\"\n        Retrieves the lpmode (low power mode) status of this SFP\n        Returns:\n            A Boolean, True if lpmode is enabled, False if disabled\n        \"\"\"\n        if self.port_num < 53: \n            # SFP doesn't support this feature\n            return False\n        else:\n            power_set=self.get_power_set()\n            power_override = self.get_power_override()\n            return power_set and power_override\n      \n    \n    def reset(self):\n        \"\"\"\n        Reset SFP and return all user module settings to their default srate.\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        # Check for invalid port_num\n        if self.port_num < 53: #Copper port and  sfp ports are not supported.\n            return False\n\n        reset_path = \"{}{}{}\".format(CPLD_I2C_PATH, 'module_reset_', self.port_num)\n        ret = self._api_helper.write_txt_file(reset_path, 1)\n        if ret is not True:\n            return ret\n        \n        time.sleep(0.01)\n        ret = self._api_helper.write_txt_file(reset_path, 0)\n        time.sleep(0.2)\n        \n        return ret\n        \n    def tx_disable(self, tx_disable):\n        \"\"\"\n        Disable SFP TX for all channels\n        Args:\n            tx_disable : A Boolean, True to enable tx_disable mode, False to disable\n                         tx_disable mode.\n        Returns:\n            A boolean, True if tx_disable is set successfully, False if not\n        \"\"\"\n        if self.port_num < 49: #Copper port, no sysfs\n            return False\n        \n        if self.port_num < 53:\n            tx_path = \"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_disable_', self.port_num)      \n            ret = self._api_helper.write_txt_file(tx_path,  1 if tx_disable else 0)\n            if ret is not None:\n                time.sleep(0.01)\n                return ret\n            else:\n                return False\n        \n        else:\n            if not self.get_presence():\n                return False\n            sysfsfile_eeprom = None\n            try:\n                tx_disable_ctl = 0xf if tx_disable else 0x0\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = tx_disable_ctl\n                else:\n                    buffer[0] = chr(tx_disable_ctl)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print ('Error: unable to open file: ',str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n        return True\n\n    def tx_disable_channel(self, channel, disable):\n        \"\"\"\n        Sets the tx_disable for specified SFP channels\n        Args:\n            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,\n                      e.g. 0x5 for channel 0 and channel 2.\n            disable : A boolean, True to disable TX channels specified in channel,\n                      False to enable\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        \n        if self.port_num < 53:\n            return False # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n\n            sysfsfile_eeprom = None\n            try:\n                channel_state = self.get_tx_disable_channel()\n\n                for i in range(4):\n                    channel_mask = (1 << i)\n                    if not (channel & channel_mask):\n                        continue\n\n                    if disable:\n                        channel_state |= channel_mask\n                    else:\n                        channel_state &= ~channel_mask\n\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = channel_state\n                else:\n                    buffer[0] = chr(channel_state)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print ('Error: unable to open file: ', str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n            return True\n\n    def set_lpmode(self, lpmode):\n        \"\"\"\n        Sets the lpmode (low power mode) of SFP\n        Args:\n            lpmode: A Boolean, True to enable lpmode, False to disable it\n            Note  : lpmode can be overridden by set_power_override\n        Returns:\n            A boolean, True if lpmode is set successfully, False if not\n        \"\"\"\n        if self.port_num < 53:\n            return False # SFP doesn't support this feature\n        else:\n            if lpmode is True:\n                self.set_power_override(True, True)\n            else:\n                self.set_power_override(False, False)\n    \n            return True\n       \n    def set_power_override(self, power_override, power_set):\n        \"\"\"\n        Sets SFP power level using power_override and power_set\n        Args:\n            power_override :\n                    A Boolean, True to override set_lpmode and use power_set\n                    to control SFP power, False to disable SFP power control\n                    through power_override/power_set and use set_lpmode\n                    to control SFP power.\n            power_set :\n                    Only valid when power_override is True.\n                    A Boolean, True to set SFP to low power mode, False to set\n                    SFP to high power mode.\n        Returns:\n            A boolean, True if power-override and power_set are set successfully,\n            False if not\n        \"\"\"\n        if self.port_num < 53:\n            return False # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n            try:\n                power_override_bit = (1 << 0) if power_override else 0\n                power_set_bit      = (1 << 1) if power_set else (1 << 3)\n    \n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = (power_override_bit | power_set_bit)\n                else:\n                    buffer[0] = chr(power_override_bit | power_set_bit)\n                # Write to eeprom\n                with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd:\n                    fd.seek(QSFP_POWEROVERRIDE_OFFSET)\n                    fd.write(buffer[0])\n                    time.sleep(0.01)\n            except IOError as e:\n                print ('Error: unable to open file: ', str(e))\n                return False\n            return True\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        name = None\n        sfputil_helper = SfpUtilHelper()\n        sfputil_helper.read_porttab_mappings(\n            self.__get_path_to_port_config_file())\n        name = sfputil_helper.logical[self.index] or \"Unknown\"\n        return name\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        if self.port_num < 49: #Copper port, no sysfs\n            return False\n            \n        present_path = \"{}{}{}\".format(CPLD_I2C_PATH, '/module_present_', self.port_num)\n        val=self._api_helper.read_txt_file(present_path)\n        if val is not None:\n            return int(val, 10)==1\n        else:\n            return False\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return self.get_presence()\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return self.port_num\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return True\n"}, "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n SYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         ", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=3 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=3 NUM_QSFP=6 PORT_START=49 PORT_END=54 NUM_COMPONENT=2 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"docker > /dev/null 2>&1\" SYSLED_FNODE=\"/sys/class/leds/diag/brightness\" SYSLED_MODES={ \"0\": \"STATUS_LED_COLOR_OFF\", \"1\": \"STATUS_LED_COLOR_GREEN\", \"2\": \"STATUS_LED_COLOR_AMBER\", \"5\": \"STATUS_LED_COLOR_GREEN_BLINK\" } class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(0, PORT_END): sfp=Sfp(index) self._sfp_list.append(sfp) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for fant_index in range(NUM_FAN_TRAY): fandrawer=FanDrawer(fant_index) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._api_helper.hwsku def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_serial_number(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def initizalize_system_led(self): return True def get_status_led(self): val=self._api_helper.read_txt_file(SYSLED_FNODE) return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\" def set_status_led(self, color): mode=None for key, val in SYSLED_MODES.items(): if val==color: mode=key break if mode is None: return False else: return self._api_helper.write_txt_file(SYSLED_FNODE, mode) ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 3\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 3\nNUM_QSFP = 6\nPORT_START = 49\nPORT_END = 54\nNUM_COMPONENT = 2\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nSYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\nSYSLED_MODES = {\n    \"0\" : \"STATUS_LED_COLOR_OFF\",\n    \"1\" : \"STATUS_LED_COLOR_GREEN\",\n    \"2\" : \"STATUS_LED_COLOR_AMBER\",\n    \"5\" : \"STATUS_LED_COLOR_GREEN_BLINK\"\n}\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n\n        self.config_data = {}\n\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n\n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(0, PORT_END):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self.sfp_module_initialized = True\n\n    def __initialize_fan(self):\n        from sonic_platform.fan_drawer import FanDrawer\n        for fant_index in range(NUM_FAN_TRAY):\n            fandrawer = FanDrawer(fant_index)\n            self._fan_drawer_list.append(fandrawer)\n            self._fan_list.extend(fandrawer._fan_list)\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n\n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n\n        return self._api_helper.hwsku\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_serial_number(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n\n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n\n    def initizalize_system_led(self):\n        return True\n\n    def get_status_led(self):\n        val = self._api_helper.read_txt_file(SYSLED_FNODE)\n        return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\"\n\n    def set_status_led(self, color):\n        mode = None\n        for key, val in SYSLED_MODES.items():\n            if val == color:\n                mode = key\n                break\n        if mode is None:\n            return False\n        else:\n            return self._api_helper.write_txt_file(SYSLED_FNODE, mode)\n"}, "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 3, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()        \n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n        ", "add": 0, "remove": 16, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"3-0060\" } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"BIOS\", \"Basic Input/Output System\") ] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError ", "sourceWithComments": "#############################################################################\n# Accton\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"3-0060\"\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n\n]\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()        \n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)               \n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n\n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()           \n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n"}, "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, ", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, "], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r', errors='replace') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r', errors='replace') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-accton_as4630_54te-r0\"\n     HWSKU = \"Accton-AS4630-54TE\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLA", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}]}, "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE= \"/sys/class/leds/as5835_54x_led::diag/brightness\"\n \n SYSLED_MODES = {\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n     \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n     ", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os import sys try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper from.event import SfpEvent except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=5 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=4 NUM_QSFP=54 PORT_START=1 PORT_END=54 NUM_COMPONENT=4 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" SYSLED_FNODE=\"/sys/class/leds/as5835_54x_led::diag/brightness\" SYSLED_MODES={ \"0\": \"STATUS_LED_COLOR_OFF\", \"1\": \"STATUS_LED_COLOR_GREEN\", \"3\": \"STATUS_LED_COLOR_AMBER\" } class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(0, PORT_END): sfp=Sfp(index) self._sfp_list.append(sfp) self._sfpevent=SfpEvent(self._sfp_list) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for fant_index in range(NUM_FAN_TRAY): fandrawer=FanDrawer(fant_index) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._eeprom.get_product_name() def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_change_event(self, timeout=0): if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfpevent.get_sfp_event(timeout) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def initizalize_system_led(self): return True def get_status_led(self): val=self._api_helper.read_txt_file(SYSLED_FNODE) return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\" def set_status_led(self, color): mode=None for key, val in SYSLED_MODES.items(): if val==color: mode=key break if mode is None: return False else: return self._api_helper.write_txt_file(SYSLED_FNODE, mode) ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\nimport sys\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\n    from .event import SfpEvent\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 5\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 4\nNUM_QSFP = 54\nPORT_START = 1\nPORT_END = 54\nNUM_COMPONENT = 4\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\nSYSLED_FNODE= \"/sys/class/leds/as5835_54x_led::diag/brightness\"\n\nSYSLED_MODES = {\n    \"0\" : \"STATUS_LED_COLOR_OFF\",\n    \"1\" : \"STATUS_LED_COLOR_GREEN\",\n    \"3\" : \"STATUS_LED_COLOR_AMBER\"\n}\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n        \n        self.config_data = {}\n        \n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n    \n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(0, PORT_END):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self._sfpevent = SfpEvent(self._sfp_list)\n        self.sfp_module_initialized = True\n        \n    def __initialize_fan(self):\n       from sonic_platform.fan_drawer import FanDrawer\n       for fant_index in range(NUM_FAN_TRAY):\n           fandrawer = FanDrawer(fant_index)\n           self._fan_drawer_list.append(fandrawer)\n           self._fan_list.extend(fandrawer._fan_list)\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n    \n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n    \n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n    \n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return self._eeprom.get_product_name()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n    \n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n    \n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n        \n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n\n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_change_event(self, timeout=0):\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n        return self._sfpevent.get_sfp_event(timeout)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n        \n    def initizalize_system_led(self):\n        return True\n\n    def get_status_led(self):\n        val = self._api_helper.read_txt_file(SYSLED_FNODE)\n        return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\"\n\n    def set_status_led(self, color):\n        mode = None\n        for key, val in SYSLED_MODES.items():\n            if val == color:\n                mode = key\n                break\n        if mode is None:\n            return False\n        else:\n            return self._api_helper.write_txt_file(SYSLED_FNODE, mode)\n            \n"}, "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n-\n try:\n     from sonic_platform_base.component_base import ComponentBase\n     from .helper import APIHelper\n", "add": 0, "remove": 4, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()\n \n-\n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n    ", "add": 0, "remove": 17, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"3-0060\", \"CPLD2\": \"3-0061\", \"CPLD3\": \"3-0062\", } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"CPLD2\", \"CPLD 2\"), (\"CPLD3\", \"CPLD 3\"), (\"BIOS\", \"Basic Input/Output System\") ] COMPONENT_DES_LIST=[\"CPLD\",\"Basic Input/Output System\"] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: print('Get exception when read bios') return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return 'N/A' def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return 'N/A' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is'0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"3-0060\",\n    \"CPLD2\": \"3-0061\",\n    \"CPLD3\": \"3-0062\",\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"CPLD2\", \"CPLD 2\"),\n   (\"CPLD3\", \"CPLD 3\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n   \n]\nCOMPONENT_DES_LIST = [\"CPLD\",\"Basic Input/Output System\"]\n\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            print('Get exception when read bios')\n        return None\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)\n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n        \n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n        #return \"testhwsku\"\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of\n        entPhysicalContainedIn is'0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device\n            or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return stat", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return stat"], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r', errors='replace') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r', errors='replace') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as5835_54x-r0\"\n     HWSKU = \"Accton-AS5835-54X\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n \n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess(self.HOST_CHK_CMD).returncode == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess(self.HOST_CHK_CMD).returncode == 0"]}], "source": "\n import os import time import sys from ctypes import create_string_buffer try: from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_I2C_PATH=\"/sys/bus/i2c/devices/\" class Sfp(SfpOptoeBase): \"\"\"Platform-specific Sfp class\"\"\" PORT_START=1 PORT_END=54 QSFP_PORT_START=49 PLATFORM_ROOT_PATH=\"/usr/share/sonic/device\" PMON_HWSKU_PATH=\"/usr/share/sonic/hwsku\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" PLATFORM=\"x86_64-accton_as5835_54x-r0\" HWSKU=\"Accton-AS5835-54X\" _cpld_mapping={ 0: \"3-0060\", 1: \"3-0061\", 2: \"3-0062\", } _port_to_i2c_mapping={ 1: 42, 2: 43, 3: 44, 4: 45, 5: 46, 6: 47, 7: 48, 8: 49, 9: 50, 10: 51, 11: 52, 12: 53, 13: 54, 14: 55, 15: 56, 16: 57, 17: 58, 18: 59, 19: 60, 20: 61, 21: 62, 22: 63, 23: 64, 24: 65, 25: 66, 26: 67, 27: 68, 28: 69, 29: 70, 30: 71, 31: 72, 32: 73, 33: 74, 34: 75, 35: 76, 36: 77, 37: 78, 38: 79, 39: 80, 40: 81, 41: 82, 42: 83, 43: 84, 44: 85, 45: 86, 46: 87, 47: 88, 48: 89, 49: 28, 50: 29, 51: 26, 52: 30, 53: 31, 54: 27, } def __init__(self, sfp_index=0): SfpOptoeBase.__init__(self) self._api_helper=APIHelper() self.index=sfp_index self.port_num=self.index +1 eeprom_path='/sys/bus/i2c/devices/{0}-0050/eeprom' self.port_to_eeprom_mapping={} for x in range(self.PORT_START, self.PORT_END +1): self.port_to_eeprom_mapping[x]=eeprom_path.format(self._port_to_i2c_mapping[x]) def get_eeprom_path(self): return self.port_to_eeprom_mapping[self.port_num] def __get_cpld_num(self, port_num): return 1 if(port_num < 39) else 2 def __is_host(self): return os.system(self.HOST_CHK_CMD)==0 def __get_path_to_port_config_file(self): platform_path=\"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM]) hwsku_path=\"/\".join([platform_path, self.HWSKU] ) if self.__is_host() else self.PMON_HWSKU_PATH return \"/\".join([hwsku_path, \"port_config.ini\"]) def __read_eeprom_specific_bytes(self, offset, num_bytes): sysfsfile_eeprom=None eeprom_raw=[] for i in range(0, num_bytes): eeprom_raw.append(\"0x00\") sysfs_sfp_i2c_client_eeprom_path=self.port_to_eeprom_mapping[self.port_num] try: sysfsfile_eeprom=open( sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0) sysfsfile_eeprom.seek(offset) raw=sysfsfile_eeprom.read(num_bytes) if sys.version_info[0] >=3: for n in range(0, num_bytes): eeprom_raw[n]=hex(raw[n])[2:].zfill(2) else: for n in range(0, num_bytes): eeprom_raw[n]=hex(ord(raw[n]))[2:].zfill(2) except Exception: pass finally: if sysfsfile_eeprom: sysfsfile_eeprom.close() return eeprom_raw def get_reset_status(self): \"\"\" Retrieves the reset status of SFP Returns: A Boolean, True if reset enabled, False if disabled \"\"\" if self.port_num <49: return False cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] reset_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_reset_', self.port_num) val=self._api_helper.read_txt_file(reset_path) if val is not None: return int(val, 10)==1 else: return False def get_rx_los(self): \"\"\" Retrieves the RX LOS(lost-of-signal) status of SFP Returns: A Boolean, True if SFP has RX LOS, False if not. Note: RX LOS status is latched until a call to get_rx_los or a reset. \"\"\" rx_los=False if self.port_num < 49: cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] rx_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_rx_los_', self.port_num) rx_los=self._api_helper.read_txt_file(rx_path) if int(rx_los, 10)==1: return[True] else: return[False] else: rx_los_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: rx_los_data=int(dom_channel_monitor_raw[0], 16) rx_los_list.append(rx_los_data & 0x01 !=0) rx_los_list.append(rx_los_data & 0x02 !=0) rx_los_list.append(rx_los_data & 0x04 !=0) rx_los_list.append(rx_los_data & 0x08 !=0) return rx_los_list else: return[False]*4 def get_tx_fault(self): \"\"\" Retrieves the TX fault status of SFP Returns: A list of boolean values, representing the TX fault status of each available channel, value is True if SFP channel has TX fault, False if not. E.g., for a tranceiver with four channels:[False, False, True, False] Note: TX fault status is lached until a call to get_tx_fault or a reset. \"\"\" tx_fault=False if self.port_num < 49: cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] tx_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_fault_', self.port_num) tx_fault=self._api_helper.read_txt_file(tx_path) if int(tx_fault, 10)==1: return[True] else: return[False] else: tx_fault_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: tx_fault_data=int(dom_channel_monitor_raw[0], 16) tx_fault_list.append(tx_fault_data & 0x01 !=0) tx_fault_list.append(tx_fault_data & 0x02 !=0) tx_fault_list.append(tx_fault_data & 0x04 !=0) tx_fault_list.append(tx_fault_data & 0x08 !=0) return tx_fault_list else: return[False]*4 def get_tx_disable(self): \"\"\" Retrieves the tx_disable status of this SFP Returns: A list of boolean values, representing the TX disable status of each available channel, value is True if SFP channel is TX disabled, False if not. E.g., for a tranceiver with four channels:[False, False, True, False] \"\"\" if self.port_num < 49: tx_disable=False cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] tx_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_disable_', self.port_num) tx_disable=self._api_helper.read_txt_file(tx_path) if int(tx_disable, 10)==0: return[False] else: return[True] else: tx_disable_list=[] sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) tx_disable_list.append( 'On'==dom_control_data['data']['TX1Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX2Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX3Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX4Disable']['value']) return tx_disable_list else: return[False]*4 def get_tx_disable_channel(self): \"\"\" Retrieves the TX disabled channels in this SFP Returns: A hex of 4 bits(bit 0 to bit 3 as channel 0 to channel 3) to represent TX channels which have been disabled in this SFP. As an example, a returned value of 0x5 indicates that channel 0 and channel 2 have been disabled. \"\"\" tx_disable_list=self.get_tx_disable() if tx_disable_list is None: return 0 tx_disabled=0 for i in range(len(tx_disable_list)): if tx_disable_list[i]: tx_disabled |=1 << i return tx_disabled def get_lpmode(self): \"\"\" Retrieves the lpmode(low power mode) status of this SFP Returns: A Boolean, True if lpmode is enabled, False if disabled \"\"\" if self.port_num < 49: return False else: power_set=self.get_power_set() power_override=self.get_power_override() return power_set and power_override def get_power_set(self): if self.port_num < 49: return False else: power_set=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) power_set=( 'On'==dom_control_data['data']['PowerSet']['value']) return power_set def get_power_override(self): \"\"\" Retrieves the power-override status of this SFP Returns: A Boolean, True if power-override is enabled, False if disabled \"\"\" if self.port_num < 49: return False else: power_override=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) power_override=( 'On'==dom_control_data['data']['PowerOverride']['value']) return power_override def reset(self): \"\"\" Reset SFP and return all user module settings to their default srate. Returns: A boolean, True if successful, False if not \"\"\" if self.port_num <49: return False cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] reset_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_reset_', self.port_num) ret=self._api_helper.write_txt_file(reset_path, 1) if ret is not True: return ret time.sleep(0.01) ret=self._api_helper.write_txt_file(reset_path, 0) time.sleep(0.2) return ret def tx_disable(self, tx_disable): \"\"\" Disable SFP TX for all channels Args: tx_disable: A Boolean, True to enable tx_disable mode, False to disable tx_disable mode. Returns: A boolean, True if tx_disable is set successfully, False if not \"\"\" if self.port_num < 49: cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] tx_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_disable_', self.port_num) ret=self._api_helper.write_txt_file(tx_path, 1 if tx_disable else 0) if ret is not None: time.sleep(0.01) return ret else: return False else: if not self.get_presence(): return False sysfsfile_eeprom=None try: tx_disable_ctl=0xf if tx_disable else 0x0 buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=tx_disable_ctl else: buffer[0]=chr(tx_disable_ctl) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ',str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def tx_disable_channel(self, channel, disable): \"\"\" Sets the tx_disable for specified SFP channels Args: channel: A hex of 4 bits(bit 0 to bit 3) which represent channel 0 to 3, e.g. 0x5 for channel 0 and channel 2. disable: A boolean, True to disable TX channels specified in channel, False to enable Returns: A boolean, True if successful, False if not \"\"\" if self.port_num < 49: return False else: if not self.get_presence(): return False sysfsfile_eeprom=None try: channel_state=self.get_tx_disable_channel() for i in range(4): channel_mask=(1 << i) if not(channel & channel_mask): continue if disable: channel_state |=channel_mask else: channel_state &=~channel_mask buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=channel_state else: buffer[0]=chr(channel_state) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ', str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def set_lpmode(self, lpmode): \"\"\" Sets the lpmode(low power mode) of SFP Args: lpmode: A Boolean, True to enable lpmode, False to disable it Note : lpmode can be overridden by set_power_override Returns: A boolean, True if lpmode is set successfully, False if not \"\"\" if self.port_num < 49: return False else: if lpmode: self.set_power_override(True, True) else: self.set_power_override(False, False) return True def set_power_override(self, power_override, power_set): \"\"\" Sets SFP power level using power_override and power_set Args: power_override: A Boolean, True to override set_lpmode and use power_set to control SFP power, False to disable SFP power control through power_override/power_set and use set_lpmode to control SFP power. power_set: Only valid when power_override is True. A Boolean, True to set SFP to low power mode, False to set SFP to high power mode. Returns: A boolean, True if power-override and power_set are set successfully, False if not \"\"\" if self.port_num < 49: return False else: if not self.get_presence(): return False try: power_override_bit=(1 << 0) if power_override else 0 power_set_bit =(1 << 1) if power_set else(1 << 3) buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=(power_override_bit | power_set_bit) else: buffer[0]=chr(power_override_bit | power_set_bit) with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd: fd.seek(QSFP_POWEROVERRIDE_OFFSET) fd.write(buffer[0]) time.sleep(0.01) except Exception: print('Error: unable to open file: ', str(e)) return False return True def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" sfputil_helper=SfpUtilHelper() sfputil_helper.read_porttab_mappings( self.__get_path_to_port_config_file()) name=sfputil_helper.logical[self.index] or \"Unknown\" return name def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] present_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_present_', self.port_num) val=self._api_helper.read_txt_file(present_path) if val is not None: return int(val, 10)==1 else: return False def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return self.get_presence() def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return self.port_num def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return True ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Sfp contains an implementation of SONiC Platform Base API and\n# provides the sfp device status which are available in the platform\n#\n#############################################################################\n\nimport os\nimport time\nimport sys\n\nfrom ctypes import create_string_buffer\n\ntry:\n    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_I2C_PATH = \"/sys/bus/i2c/devices/\"\n\nclass Sfp(SfpOptoeBase):\n    \"\"\"Platform-specific Sfp class\"\"\"\n\n    # Port number\n    PORT_START = 1\n    PORT_END = 54\n    QSFP_PORT_START = 49\n\n    # Path to sysfs\n    PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n    PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n        \n    PLATFORM = \"x86_64-accton_as5835_54x-r0\"\n    HWSKU = \"Accton-AS5835-54X\"\n\n    _cpld_mapping = {\n        0:  \"3-0060\",\n        1:  \"3-0061\",\n        2:  \"3-0062\",\n    }\n    _port_to_i2c_mapping = {\n        1:  42,\n        2:  43,\n        3:  44,\n        4:  45,\n        5:  46,\n        6:  47,\n        7:  48,\n        8:  49,\n        9:  50,\n        10: 51,\n        11: 52,\n        12: 53,\n        13: 54,\n        14: 55,\n        15: 56,\n        16: 57,\n        17: 58,\n        18: 59,\n        19: 60,\n        20: 61,\n        21: 62,\n        22: 63,\n        23: 64,\n        24: 65,\n        25: 66,\n        26: 67,\n        27: 68,\n        28: 69,\n        29: 70,\n        30: 71,\n        31: 72,\n        32: 73,\n        33: 74,\n        34: 75,\n        35: 76,\n        36: 77,\n        37: 78,\n        38: 79,\n        39: 80,\n        40: 81,\n        41: 82,\n        42: 83,\n        43: 84,\n        44: 85,\n        45: 86,\n        46: 87,\n        47: 88,\n        48: 89,\n        49: 28,  # QSFP49\n        50: 29,  # QSFP50\n        51: 26,  # QSFP51\n        52: 30,  # QSFP52\n        53: 31,  # QSFP53\n        54: 27,  # QSFP54\n        \n    }\n\n    def __init__(self, sfp_index=0):\n        SfpOptoeBase.__init__(self)\n        self._api_helper=APIHelper()\n        # Init index\n        self.index = sfp_index\n        self.port_num = self.index + 1\n\n        # Init eeprom path\n        eeprom_path = '/sys/bus/i2c/devices/{0}-0050/eeprom'\n        self.port_to_eeprom_mapping = {}\n        for x in range(self.PORT_START, self.PORT_END + 1):\n            self.port_to_eeprom_mapping[x] = eeprom_path.format(self._port_to_i2c_mapping[x])\n\n    def get_eeprom_path(self):\n        return self.port_to_eeprom_mapping[self.port_num]\n        \n    # For cage 1~38 are at cpld2, others are at cpld3.\n    def __get_cpld_num(self, port_num):\n        return 1 if (port_num < 39) else 2\n\n\n    def __is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def __get_path_to_port_config_file(self):\n        platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n        hwsku_path = \"/\".join([platform_path, self.HWSKU]\n                              ) if self.__is_host() else self.PMON_HWSKU_PATH\n        return \"/\".join([hwsku_path, \"port_config.ini\"])\n\n    def __read_eeprom_specific_bytes(self, offset, num_bytes):\n        sysfsfile_eeprom = None\n        eeprom_raw = []\n        for i in range(0, num_bytes):\n            eeprom_raw.append(\"0x00\")\n\n        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]\n        try:\n            sysfsfile_eeprom = open(\n                sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0)\n            sysfsfile_eeprom.seek(offset)\n            raw = sysfsfile_eeprom.read(num_bytes)\n            if sys.version_info[0] >= 3:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(raw[n])[2:].zfill(2)\n            else:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(ord(raw[n]))[2:].zfill(2)\n        except Exception:\n            pass\n        finally:\n            if sysfsfile_eeprom:\n                sysfsfile_eeprom.close()\n\n        return eeprom_raw\n\n    def get_reset_status(self):\n        \"\"\"\n        Retrieves the reset status of SFP\n        Returns:\n            A Boolean, True if reset enabled, False if disabled\n        \"\"\"\n        if self.port_num <49:\n            return False # SPF port doesn't support this feature\n          \n        cpld_i = self.__get_cpld_num(self.port_num)\n        cpld_path = self._cpld_mapping[cpld_i]        \n        reset_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_reset_', self.port_num)\n        val=self._api_helper.read_txt_file(reset_path)\n        if val is not None:\n            return int(val, 10)==1\n        else:\n            return False\n\n    def get_rx_los(self):\n        \"\"\"\n        Retrieves the RX LOS (lost-of-signal) status of SFP\n        Returns:\n            A Boolean, True if SFP has RX LOS, False if not.\n            Note : RX LOS status is latched until a call to get_rx_los or a reset.\n        \"\"\"\n        rx_los = False\n        if self.port_num < 49:\n            cpld_i = self.__get_cpld_num(self.port_num)\n            cpld_path = self._cpld_mapping[cpld_i]        \n            rx_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_rx_los_', self.port_num)\n\n            rx_los=self._api_helper.read_txt_file(rx_path)\n            if int(rx_los, 10) == 1:\n                return [True]\n            else:\n                return [False]\n            #status_control_raw = self.__read_eeprom_specific_bytes(\n            #    SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            #if status_control_raw:\n            #    data = int(status_control_raw[0], 16)\n            #    rx_los = (sffbase().test_bit(data, 1) != 0)\n            \n        else:\n            rx_los_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None\n            if dom_channel_monitor_raw is not None:\n                rx_los_data = int(dom_channel_monitor_raw[0], 16)\n                rx_los_list.append(rx_los_data & 0x01 != 0)\n                rx_los_list.append(rx_los_data & 0x02 != 0)\n                rx_los_list.append(rx_los_data & 0x04 != 0)\n                rx_los_list.append(rx_los_data & 0x08 != 0)\n                return rx_los_list\n            else:\n                return [False]*4\n\n    def get_tx_fault(self):\n        \"\"\"\n        Retrieves the TX fault status of SFP\n        Returns:\n            A list of boolean values, representing the TX fault status\n            of each available channel, value is True if SFP channel\n            has TX fault, False if not.\n            E.g., for a tranceiver with four channels: [False, False, True, False]\n            Note : TX fault status is lached until a call to get_tx_fault or a reset.\n        \"\"\"\n        tx_fault = False\n        if self.port_num < 49:\n            cpld_i = self.__get_cpld_num(self.port_num)\n            cpld_path = self._cpld_mapping[cpld_i]        \n            tx_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_fault_', self.port_num)\n\n            tx_fault=self._api_helper.read_txt_file(tx_path)\n            if int(tx_fault, 10) == 1:\n                return [True]\n            else:\n                return [False]\n            #status_control_raw = self.__read_eeprom_specific_bytes(\n            #    SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            #if status_control_raw:\n            #    data = int(status_control_raw[0], 16)\n            #    tx_fault = (sffbase().test_bit(data, 2) != 0)\n        else:\n            tx_fault_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None\n            if dom_channel_monitor_raw is not None:\n                tx_fault_data = int(dom_channel_monitor_raw[0], 16)\n                tx_fault_list.append(tx_fault_data & 0x01 != 0)\n                tx_fault_list.append(tx_fault_data & 0x02 != 0)\n                tx_fault_list.append(tx_fault_data & 0x04 != 0)\n                tx_fault_list.append(tx_fault_data & 0x08 != 0)\n                return tx_fault_list\n            else:\n                return [False]*4\n\n\n    def get_tx_disable(self):\n        \"\"\"\n        Retrieves the tx_disable status of this SFP\n        Returns:\n            A list of boolean values, representing the TX disable status\n            of each available channel, value is True if SFP channel\n            is TX disabled, False if not.\n            E.g., for a tranceiver with four channels: [False, False, True, False]\n        \"\"\"\n        if self.port_num < 49: \n            tx_disable = False\n            \n            cpld_i = self.__get_cpld_num(self.port_num)\n            cpld_path = self._cpld_mapping[cpld_i]        \n            tx_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_disable_', self.port_num)\n\n            tx_disable=self._api_helper.read_txt_file(tx_path)\n            \n            #status_control_raw = self.__read_eeprom_specific_bytes(\n            #    SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            #if status_control_raw:\n            #    data = int(status_control_raw[0], 16)\n            #    tx_disable_hard = (sffbase().test_bit(\n            #        data, SFP_TX_DISABLE_HARD_BIT) != 0)\n            #    tx_disable_soft = (sffbase().test_bit(\n            #        data, SFP_TX_DISABLE_SOFT_BIT) != 0)\n            #    tx_disable = tx_disable_hard | tx_disable_soft\n            if int(tx_disable, 10)==0:\n                return [False]\n            else:\n                return [True]\n\n        else:\n            tx_disable_list = []\n    \n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n    \n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX1Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX2Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX3Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX4Disable']['value'])\n                return tx_disable_list\n            else:\n                return [False]*4\n\n    def get_tx_disable_channel(self):\n        \"\"\"\n        Retrieves the TX disabled channels in this SFP\n        Returns:\n            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent\n            TX channels which have been disabled in this SFP.\n            As an example, a returned value of 0x5 indicates that channel 0\n            and channel 2 have been disabled.\n        \"\"\"\n        tx_disable_list = self.get_tx_disable()\n        if tx_disable_list is None:\n            return 0\n        tx_disabled = 0\n        for i in range(len(tx_disable_list)):\n            if tx_disable_list[i]:\n                tx_disabled |= 1 << i\n        return tx_disabled\n\n    def get_lpmode(self):\n        \"\"\"\n        Retrieves the lpmode (low power mode) status of this SFP\n        Returns:\n            A Boolean, True if lpmode is enabled, False if disabled\n        \"\"\"\n        if self.port_num < 49: \n            # SFP doesn't support this feature\n            return False\n        else:\n            power_set=self.get_power_set()\n            power_override = self.get_power_override()\n            return power_set and power_override\n       \n    \n    def get_power_set(self):\n        \n        if self.port_num < 49: \n            # SFP doesn't support this feature\n            return False\n        else:\n            power_set = False\n            \n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n    \n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n                power_set = (\n                    'On' == dom_control_data['data']['PowerSet']['value'])\n    \n            return power_set\n\n    def get_power_override(self):\n        \"\"\"\n        Retrieves the power-override status of this SFP\n        Returns:\n            A Boolean, True if power-override is enabled, False if disabled\n        \"\"\"\n        if self.port_num < 49:\n            return False # SFP doesn't support this feature\n        else:\n            power_override = False\n    \n            \n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n    \n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n                power_override = (\n                    'On' == dom_control_data['data']['PowerOverride']['value'])\n    \n            return power_override\n\n    def reset(self):\n        \"\"\"\n        Reset SFP and return all user module settings to their default srate.\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        if self.port_num <49:\n            return False # SFP doesn't support this feature\n          \n        cpld_i = self.__get_cpld_num(self.port_num)\n        cpld_path = self._cpld_mapping[cpld_i]        \n        reset_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_reset_', self.port_num)      \n        ret = self._api_helper.write_txt_file(reset_path, 1)\n\n        if ret is not True:\n            return ret\n\n        time.sleep(0.01)\n        ret = self._api_helper.write_txt_file(reset_path, 0)\n        time.sleep(0.2)\n        \n        return ret\n      \n    def tx_disable(self, tx_disable):\n        \"\"\"\n        Disable SFP TX for all channels\n        Args:\n            tx_disable : A Boolean, True to enable tx_disable mode, False to disable\n                         tx_disable mode.\n        Returns:\n            A boolean, True if tx_disable is set successfully, False if not\n        \"\"\"\n        if self.port_num < 49:\n            cpld_i = self.__get_cpld_num(self.port_num)\n            cpld_path = self._cpld_mapping[cpld_i]        \n            tx_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_disable_', self.port_num)      \n            ret = self._api_helper.write_txt_file(tx_path,  1 if tx_disable else 0)\n\n            if ret is not None:\n                time.sleep(0.01)\n                return ret\n            else:\n                return False\n        \n        else:\n            if not self.get_presence():\n                return False\n            sysfsfile_eeprom = None\n            try:\n                tx_disable_ctl = 0xf if tx_disable else 0x0\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = tx_disable_ctl\n                else:\n                    buffer[0] = chr(tx_disable_ctl)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print ('Error: unable to open file: ',str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n        return True\n\n    def tx_disable_channel(self, channel, disable):\n        \"\"\"\n        Sets the tx_disable for specified SFP channels\n        Args:\n            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,\n                      e.g. 0x5 for channel 0 and channel 2.\n            disable : A boolean, True to disable TX channels specified in channel,\n                      False to enable\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        \n        if self.port_num < 49:\n            return False # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n\n            sysfsfile_eeprom = None\n            try:\n                channel_state = self.get_tx_disable_channel()\n\n                for i in range(4):\n                    channel_mask = (1 << i)\n                    if not (channel & channel_mask):\n                        continue\n\n                    if disable:\n                        channel_state |= channel_mask\n                    else:\n                        channel_state &= ~channel_mask\n\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = channel_state\n                else:\n                    buffer[0] = chr(channel_state)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print ('Error: unable to open file: ', str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n            return True\n\n    def set_lpmode(self, lpmode):\n        \"\"\"\n        Sets the lpmode (low power mode) of SFP\n        Args:\n            lpmode: A Boolean, True to enable lpmode, False to disable it\n            Note  : lpmode can be overridden by set_power_override\n        Returns:\n            A boolean, True if lpmode is set successfully, False if not\n        \"\"\"\n        if self.port_num < 49:\n            return False # SFP doesn't support this feature\n        else:\n            if lpmode:\n                self.set_power_override(True, True)\n            else:\n                self.set_power_override(False, False)\n    \n            return True\n       \n    def set_power_override(self, power_override, power_set):\n        \"\"\"\n        Sets SFP power level using power_override and power_set\n        Args:\n            power_override :\n                    A Boolean, True to override set_lpmode and use power_set\n                    to control SFP power, False to disable SFP power control\n                    through power_override/power_set and use set_lpmode\n                    to control SFP power.\n            power_set :\n                    Only valid when power_override is True.\n                    A Boolean, True to set SFP to low power mode, False to set\n                    SFP to high power mode.\n        Returns:\n            A boolean, True if power-override and power_set are set successfully,\n            False if not\n        \"\"\"\n        if self.port_num < 49:\n            return False # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n            try:\n                power_override_bit = (1 << 0) if power_override else 0\n                power_set_bit      = (1 << 1) if power_set else (1 << 3)\n    \n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = (power_override_bit | power_set_bit)\n                else:\n                    buffer[0] = chr(power_override_bit | power_set_bit)\n                # Write to eeprom\n                with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd:\n                    fd.seek(QSFP_POWEROVERRIDE_OFFSET)\n                    fd.write(buffer[0])\n                    time.sleep(0.01)\n            except Exception:\n                print ('Error: unable to open file: ', str(e))\n                return False\n            return True\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        sfputil_helper = SfpUtilHelper()\n        sfputil_helper.read_porttab_mappings(\n            self.__get_path_to_port_config_file())\n        name = sfputil_helper.logical[self.index] or \"Unknown\"\n        return name\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        cpld_i = self.__get_cpld_num(self.port_num)\n        cpld_path = self._cpld_mapping[cpld_i]          \n        present_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_present_', self.port_num)\n        val=self._api_helper.read_txt_file(present_path)\n        if val is not None:\n            return int(val, 10)==1\n        else:\n            return False\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return self.get_presence()\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return self.port_num\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return True\n"}, "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n #\n #############################################################################\n try:\n-    import sys\n-    import re\n-    import os\n     import subprocess\n-    import json\n-    import syslog\n     from sonic_platform_base.chassis_base import ChassisBase\n     from sonic_py_common.logger import Logger\n     from sonic_platform.fan import Fan\n", "add": 0, "remove": 5, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py", "badparts": ["    import sys", "    import re", "    import json", "    import syslog"], "goodparts": []}, {"diff": "\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n COMPONENT_NAME_LIST = [\"BIOS\"]\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         logger.log_info(\"Chassis loaded successfully\")\n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n ", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n try: import sys import re import os import subprocess import json import syslog from sonic_platform_base.chassis_base import ChassisBase from sonic_py_common.logger import Logger from sonic_platform.fan import Fan from sonic_platform.psu import Psu from sonic_platform.component import Component from sonic_platform.thermal import Thermal from sonic_platform.sfp import Sfp from sonic_platform.eeprom import Tlv except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=5 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=4 NUM_SFP=54 SFP_PORT_START=0 QSFP_PORT_START=48 SFP_PORT_END=47 QSFP_PORT_END=53 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" COMPONENT_NAME_LIST=[\"BIOS\"] HOST_CHK_CMD=\"docker > /dev/null 2>&1\" class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): super(Chassis, self).__init__() for fantray_index in range(0, NUM_FAN_TRAY): for fan_index in range(0, NUM_FAN): fan=Fan(fantray_index, fan_index) self._fan_list.append(fan) for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) self.PORT_START=SFP_PORT_START self.QSFP_PORT_START=QSFP_PORT_START self.PORT_END=QSFP_PORT_END for index in range(0, NUM_SFP): if index in range(self.QSFP_PORT_START, self.QSPORT_END +1): sfp_module=Sfp(index, 'QSFP') else: sfp_module=Sfp(index, 'SFP') self._sfp_list.append(sfp_module) self._component_name_list=COMPONENT_NAME_LIST self._watchdog=Watchdog() self._eeprom=Tlv() logger.log_info(\"Chassis loaded successfully\") def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_firmware_version(self, component_name): \"\"\" Retrieves platform-specific hardware/firmware versions for chassis componenets such as BIOS, CPLD, FPGA, etc. Args: type: A string, component name Returns: A string containing platform-specific component versions \"\"\" self.component=Component(component_name) if component_name not in self._component_name_list: return None return self.component.get_firmware_version() def install_component_firmware(self, component_name, image_path): \"\"\" Install firmware to module Args: type: A string, component name. image_path: A string, path to firmware image. Returns: A boolean, True if install successfully, False if not \"\"\" self.component=Component(component_name) if component_name not in self._component_name_list: return False return self.component.upgrade_firmware(image_path) def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" description='None' reboot_cause=self.REBOOT_CAUSE_HARDWARE_OTHER reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) if self.__is_host( ) else PMON_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE prev_reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +PREV_REBOOT_CAUSE_FILE) if self.__is_host( ) else PMON_REBOOT_CAUSE_PATH +PREV_REBOOT_CAUSE_FILE sw_reboot_cause=self.__read_txt_file( reboot_cause_path) or \"Unknown\" prev_sw_reboot_cause=self.__read_txt_file( prev_reboot_cause_path) or \"Unknown\" if sw_reboot_cause !=\"Unknown\": reboot_cause=self.REBOOT_CAUSE_NON_HARDWARE description=sw_reboot_cause else: reboot_cause=self.REBOOT_CAUSE_HARDWARE_OTHER description='Unknown reason' return(reboot_cause, description) ", "sourceWithComments": "#############################################################################\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\ntry:\n    import sys\n    import re\n    import os\n    import subprocess\n    import json\n    import syslog\n    from sonic_platform_base.chassis_base import ChassisBase\n    from sonic_py_common.logger import Logger\n    from sonic_platform.fan import Fan\n    from sonic_platform.psu import Psu\n    from sonic_platform.component import Component\n    from sonic_platform.thermal import Thermal\n    from sonic_platform.sfp import Sfp\n    from sonic_platform.eeprom import Tlv\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 5\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 4\nNUM_SFP = 54\nSFP_PORT_START = 0\nQSFP_PORT_START = 48\nSFP_PORT_END = 47\nQSFP_PORT_END = 53\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nCOMPONENT_NAME_LIST = [\"BIOS\"]\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        super(Chassis, self).__init__()\n\n        for fantray_index in range(0, NUM_FAN_TRAY):\n            for fan_index in range(0, NUM_FAN):\n                fan = Fan(fantray_index, fan_index)\n                self._fan_list.append(fan)\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n\n        self.PORT_START = SFP_PORT_START\n        self.QSFP_PORT_START = QSFP_PORT_START\n        self.PORT_END = QSFP_PORT_END\n        for index in range(0, NUM_SFP):\n            if index in range(self.QSFP_PORT_START, self.QSPORT_END + 1):\n                sfp_module = Sfp(index, 'QSFP')\n            else:\n                sfp_module = Sfp(index, 'SFP')\n            self._sfp_list.append(sfp_module)\n        self._component_name_list = COMPONENT_NAME_LIST\n        self._watchdog = Watchdog()\n        self._eeprom = Tlv()\n        logger.log_info(\"Chassis loaded successfully\")\n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_firmware_version(self, component_name):\n        \"\"\"\n        Retrieves platform-specific hardware/firmware versions for chassis\n        componenets such as BIOS, CPLD, FPGA, etc.\n        Args:\n            type: A string, component name\n\n        Returns:\n            A string containing platform-specific component versions\n        \"\"\"\n        self.component = Component(component_name)\n        if component_name not in self._component_name_list:\n            return None\n        return self.component.get_firmware_version()\n\n    def install_component_firmware(self, component_name, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            type: A string, component name.\n            image_path: A string, path to firmware image.\n\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        self.component = Component(component_name)\n        if component_name not in self._component_name_list:\n            return False\n        return self.component.upgrade_firmware(image_path)\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        description = 'None'\n        reboot_cause = self.REBOOT_CAUSE_HARDWARE_OTHER\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE) if self.__is_host(\n        ) else PMON_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE\n        prev_reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + PREV_REBOOT_CAUSE_FILE) if self.__is_host(\n        ) else PMON_REBOOT_CAUSE_PATH + PREV_REBOOT_CAUSE_FILE\n        sw_reboot_cause = self.__read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n        prev_sw_reboot_cause = self.__read_txt_file(\n            prev_reboot_cause_path) or \"Unknown\"\n\n        if sw_reboot_cause != \"Unknown\":\n            reboot_cause = self.REBOOT_CAUSE_NON_HARDWARE\n            description = sw_reboot_cause\n        else:\n            reboot_cause = self.REBOOT_CAUSE_HARDWARE_OTHER\n            description = 'Unknown reason'\n\n        return (reboot_cause, description)\n"}, "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py": {"changes": [{"diff": "\n # provides the components firmware management function\n #############################################################################\n \n-import json\n import os.path\n-import shutil\n-import shlex\n import subprocess\n \n try:\n", "add": 0, "remove": 3, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py", "badparts": ["import json", "import shutil", "import shlex"], "goodparts": []}, {"diff": "\n     def __run_command(self, command):\n         # Run bash command and print output to stdout\n         try:\n-            process = subprocess.Popen(\n-                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n+            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n             while True:\n                 output = process.stdout.readline()\n                 if output == '' and process.poll()", "add": 1, "remove": 2, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py", "badparts": ["            process = subprocess.Popen(", "                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)"], "goodparts": ["            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)"]}], "source": "\n import json import os.path import shutil import shlex import subprocess try: from sonic_platform_base.device_base import DeviceBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" class Component(DeviceBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_name): DeviceBase.__init__(self) self.name=component_name.upper() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() return fw_version def upgrade_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" if not os.path.isfile(image_path): return False if self.name==\"BIOS\": print(\"Not supported\") return False return self.__run_command(install_command) ", "sourceWithComments": "#############################################################################\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#############################################################################\n\nimport json\nimport os.path\nimport shutil\nimport shlex\nimport subprocess\n\ntry:\n    from sonic_platform_base.device_base import DeviceBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\n\n\nclass Component(DeviceBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_name):\n        DeviceBase.__init__(self)\n        self.name = component_name.upper()\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n\n        return fw_version\n\n    def upgrade_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        if not os.path.isfile(image_path):\n            return False\n\n        if self.name == \"BIOS\":\n            print(\"Not supported\")\n            return False\n\n        return self.__run_command(install_command)\n"}, "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n # provides the sfp device status which are available in the platform\n #############################################################################\n try:\n-    import os\n     import time\n     import subprocess\n-    import syslog\n     from ctypes import create_string_buffer\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom\n", "add": 0, "remove": 2, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py", "badparts": ["    import syslog"], "goodparts": []}, {"diff": "\n \n     PLATFORM_ROOT_PATH = '/usr/share/sonic/device'\n     PMON_HWSKU_PATH = '/usr/share/sonic/hwsku'\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-accton_as7116_54x-r0\"\n     HWSKU = \"Accton-AS7116-54X-R0\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         return \"\"\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, s", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}]}, "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n     \n     \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path)", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=6 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=4 PORT_END=54 NUM_COMPONENT=4 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"docker > /dev/null 2>&1\" class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(0, PORT_END): sfp=Sfp(index) self._sfp_list.append(sfp) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan import Fan for fant_index in range(0, NUM_FAN_TRAY): for fan_index in range(0, NUM_FAN): fan=Fan(fant_index, fan_index) self._fan_list.append(fan) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._api_helper.hwsku def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_serial_number(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 6\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 4\nPORT_END = 54\nNUM_COMPONENT = 4\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n        \n        self.config_data = {}\n        \n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n    \n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(0, PORT_END):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self.sfp_module_initialized = True\n        \n    def __initialize_fan(self):\n        from sonic_platform.fan import Fan\n        for fant_index in range(0, NUM_FAN_TRAY):\n            for fan_index in range(0, NUM_FAN):\n                fan = Fan(fant_index, fan_index)\n                self._fan_list.append(fan)\n                \n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n    \n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n    \n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n    \n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n    \n    \n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        \n        return self._api_helper.hwsku\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n    \n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n    \n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_serial_number(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()   \n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        \n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n         \n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n"}, "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 2, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware versi", "add": 0, "remove": 16, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"4-0060\", \"CPLD2\": \"5-0062\", \"CPLD3\": \"6-0064\", } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"CPLD2\", \"CPLD 2\"), (\"CPLD3\", \"CPLD 3\"), (\"BIOS\", \"Basic Input/Output System\") ] COMPONENT_DES_LIST=[\"CPLD\",\"Basic Input/Output System\"] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"4-0060\",\n    \"CPLD2\": \"5-0062\",\n    \"CPLD3\": \"6-0064\",\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"CPLD2\", \"CPLD 2\"),\n   (\"CPLD3\", \"CPLD 3\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n   \n]\nCOMPONENT_DES_LIST = [\"CPLD\",\"Basic Input/Output System\"]\n\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n   \n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)\n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n        \n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n        #return \"testhwsku\"\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n"}, "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        retu", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        retu"], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n         \n     PLATFORM = \"x86_64-accton_as7312_54x-r0\"\n     HWSKU = \"Accton-AS7312-54X\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         return True\n     \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PAT", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}]}, "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE= \"/sys/class/leds/accton_as7326_56x_led::diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n         self._watchdog = Watchdog()\n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_p", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os import sys try: from sonic_platform_base.chassis_base import ChassisBase from.event import SfpEvent from sonic_py_common import device_info except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=6 NUM_PSU=2 NUM_THERMAL=4 NUM_PORT=58 NUM_COMPONENT=4 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" SYSLED_FNODE=\"/sys/class/leds/accton_as7326_56x_led::diag/brightness\" SYSLED_MODES={ \"0\": \"STATUS_LED_COLOR_OFF\", \"1\": \"STATUS_LED_COLOR_GREEN\", \"3\": \"STATUS_LED_COLOR_RED\", \"5\": \"STATUS_LED_COLOR_GREEN_BLINK\" } class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self.config_data={} (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(NUM_PORT): sfp=Sfp(index) self._sfp_list.append(sfp) self._sfpevent=SfpEvent(self._sfp_list) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for fant_index in range(NUM_FAN_TRAY): fandrawer=FanDrawer(fant_index) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: return fd.read().strip() except IOError: pass return None def __write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except Exception: return False return True def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._eeprom.get_product_name() def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" description='None' reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) if self.__is_host( ) else(PMON_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) prev_reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +PREV_REBOOT_CAUSE_FILE) if self.__is_host( ) else(PMON_REBOOT_CAUSE_PATH +PREV_REBOOT_CAUSE_FILE) sw_reboot_cause =self.__read_txt_file(reboot_cause_path) or \"Unknown\" prev_sw_reboot_cause=self.__read_txt_file(prev_reboot_cause_path) or \"Unknown\" if sw_reboot_cause !=\"Unknown\": reboot_cause=self.REBOOT_CAUSE_NON_HARDWARE description=sw_reboot_cause elif prev_reboot_cause_path !=\"Unknown\": reboot_cause=self.REBOOT_CAUSE_NON_HARDWARE description=prev_sw_reboot_cause return(reboot_cause, description) def get_change_event(self, timeout=0): if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfpevent.get_sfp_event(timeout) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def initizalize_system_led(self): return True def get_status_led(self): val=self.__read_txt_file(SYSLED_FNODE) return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\" def set_status_led(self, color): mode=None for key, val in SYSLED_MODES.items(): if val==color: mode=key break if mode is None: return False else: return self.__write_txt_file(SYSLED_FNODE, mode) ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\nimport sys\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .event import SfpEvent\n    from sonic_py_common import device_info\n\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 6\nNUM_PSU = 2\nNUM_THERMAL = 4\nNUM_PORT = 58\nNUM_COMPONENT = 4\n\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\nSYSLED_FNODE= \"/sys/class/leds/accton_as7326_56x_led::diag/brightness\"\nSYSLED_MODES = {\n    \"0\" : \"STATUS_LED_COLOR_OFF\",\n    \"1\" : \"STATUS_LED_COLOR_GREEN\",\n    \"3\" : \"STATUS_LED_COLOR_RED\",\n    \"5\" : \"STATUS_LED_COLOR_GREEN_BLINK\"\n}\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self.config_data = {}\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n\n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(NUM_PORT):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self._sfpevent = SfpEvent(self._sfp_list)\n        self.sfp_module_initialized = True\n\n    def __initialize_fan(self):\n        from sonic_platform.fan_drawer import FanDrawer\n        for fant_index in range(NUM_FAN_TRAY):\n            fandrawer = FanDrawer(fant_index)\n            self._fan_drawer_list.append(fandrawer)\n            self._fan_list.extend(fandrawer._fan_list)\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        self._watchdog = Watchdog()\n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                return fd.read().strip()\n        except IOError:\n            pass\n        return None\n\n    def __write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except Exception:\n            return False\n        return True\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return self._eeprom.get_product_name()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        description = 'None'\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE) if self.__is_host(\n        ) else (PMON_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        prev_reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + PREV_REBOOT_CAUSE_FILE) if self.__is_host(\n        ) else (PMON_REBOOT_CAUSE_PATH + PREV_REBOOT_CAUSE_FILE)\n\n        sw_reboot_cause      = self.__read_txt_file(reboot_cause_path) or \"Unknown\"\n        prev_sw_reboot_cause = self.__read_txt_file(prev_reboot_cause_path) or \"Unknown\"\n\n        if sw_reboot_cause != \"Unknown\":\n            reboot_cause = self.REBOOT_CAUSE_NON_HARDWARE\n            description = sw_reboot_cause\n        elif prev_reboot_cause_path != \"Unknown\":\n            reboot_cause = self.REBOOT_CAUSE_NON_HARDWARE\n            description = prev_sw_reboot_cause\n\n        return (reboot_cause, description)\n\n    def get_change_event(self, timeout=0):\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n        return self._sfpevent.get_sfp_event(timeout)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n\n    def initizalize_system_led(self):\n        return True\n\n    def get_status_led(self):\n        val = self.__read_txt_file(SYSLED_FNODE)\n        return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\"\n\n    def set_status_led(self, color):\n        mode = None\n        for key, val in SYSLED_MODES.items():\n            if val == color:\n                mode = key\n                break\n        if mode is None:\n            return False\n        else:\n            return self.__write_txt_file(SYSLED_FNODE, mode)\n"}, "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n \n     PLATFORM = \"x86_64-accton_as7326_56x-r0\"\n     HWSKU = \"Accton-AS7326-56X\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_P", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}], "source": "\n import os import time import sys from ctypes import create_string_buffer try: from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ 0:{ \"bus\": 18, \"addr\": \"60\" }, 1:{ \"bus\": 12, \"addr\": \"62\" }, } CPLD_I2C_PATH=\"/sys/bus/i2c/devices/{}-00{}/\" class Sfp(SfpOptoeBase): \"\"\"Platform-specific Sfp class\"\"\" PORT_START=1 PORT_END=58 PLATFORM_ROOT_PATH=\"/usr/share/sonic/device\" PMON_HWSKU_PATH=\"/usr/share/sonic/hwsku\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" PLATFORM=\"x86_64-accton_as7326_56x-r0\" HWSKU=\"Accton-AS7326-56X\" _port_to_i2c_mapping={ 1:[42], 2:[41], 3:[44], 4:[43], 5:[47], 6:[45], 7:[46], 8:[50], 9:[48], 10:[49], 11:[52], 12:[51], 13:[53], 14:[56], 15:[55], 16:[54], 17:[58], 18:[57], 19:[60], 20:[59], 21:[61], 22:[63], 23:[62], 24:[64], 25:[66], 26:[68], 27:[65], 28:[67], 29:[69], 30:[71], 31:[72], 32:[70], 33:[74], 34:[73], 35:[76], 36:[75], 37:[77], 38:[79], 39:[78], 40:[80], 41:[81], 42:[82], 43:[84], 44:[85], 45:[83], 46:[87], 47:[88], 48:[86], 49:[25], 50:[26], 51:[27], 52:[28], 53:[29], 54:[30], 55:[31], 56:[32], 57:[22], 58:[23] } def __init__(self, sfp_index=0): SfpOptoeBase.__init__(self) self.index=sfp_index self.port_num=self.index +1 cpld_idx=0 if self.port_num > 30 else 1 bus=CPLD_ADDR_MAPPING[cpld_idx][\"bus\"] addr=CPLD_ADDR_MAPPING[cpld_idx][\"addr\"] self.cpld_path=CPLD_I2C_PATH.format(bus, addr) eeprom_path='/sys/bus/i2c/devices/{0}-0050/eeprom' self.port_to_eeprom_mapping={} for x in range(self.PORT_START, self.PORT_END +1): self.port_to_eeprom_mapping[x]=eeprom_path.format( self._port_to_i2c_mapping[x][0]) def get_eeprom_path(self): return self.port_to_eeprom_mapping[self.port_num] def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: return fd.read().strip() except IOError: pass return \"\" def __write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except Exception: return False return True def __is_host(self): return os.system(self.HOST_CHK_CMD)==0 def __get_path_to_port_config_file(self): platform_path=\"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM]) hwsku_path=\"/\".join( [platform_path, self.HWSKU]) if self.__is_host() else self.PMON_HWSKU_PATH return \"/\".join([hwsku_path, \"port_config.ini\"]) def __read_eeprom_specific_bytes(self, offset, num_bytes): sysfsfile_eeprom=None eeprom_raw=[] for i in range(0, num_bytes): eeprom_raw.append(\"0x00\") sysfs_sfp_i2c_client_eeprom_path=self.port_to_eeprom_mapping[ self.port_num] try: sysfsfile_eeprom=open( sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0) sysfsfile_eeprom.seek(offset) raw=sysfsfile_eeprom.read(num_bytes) for n in range(0, num_bytes): if sys.version_info[0] >=3: eeprom_raw[n]=hex(raw[n])[2:].zfill(2) else: eeprom_raw[n]=hex(ord(raw[n]))[2:].zfill(2) except Exception: pass finally: if sysfsfile_eeprom: sysfsfile_eeprom.close() return eeprom_raw def get_reset_status(self): \"\"\" Retrieves the reset status of SFP Returns: A Boolean, True if reset enabled, False if disabled \"\"\" if self.port_num <=48 or self.port_num >=57: return False val=self.__read_txt_file( self.cpld_path +\"module_reset_\" +str(self.port_num)) return int(val, 10)==1 def get_rx_los(self): \"\"\" Retrieves the RX LOS(lost-of-signal) status of SFP Returns: A Boolean, True if SFP has RX LOS, False if not. Note: RX LOS status is latched until a call to get_rx_los or a reset. \"\"\" if self.port_num <=48 or self.port_num >=57: rx_los=self.__read_txt_file( self.cpld_path +\"module_rx_los_\" +str(self.port_num)) if int(rx_los, 10)==1: return[True] else: return[False] else: rx_los_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence( ) else None if dom_channel_monitor_raw is not None: rx_los_data=int(dom_channel_monitor_raw[0], 16) rx_los_list.append(rx_los_data & 0x01 !=0) rx_los_list.append(rx_los_data & 0x02 !=0) rx_los_list.append(rx_los_data & 0x04 !=0) rx_los_list.append(rx_los_data & 0x08 !=0) return rx_los_list else: return[False]*4 def get_tx_fault(self): \"\"\" Retrieves the TX fault status of SFP Returns: A list of boolean values, representing the TX fault status of each available channel, value is True if SFP channel has TX fault, False if not. E.g., for a tranceiver with four channels:[False, False, True, False] Note: TX fault status is lached until a call to get_tx_fault or a reset. \"\"\" tx_fault=False if self.port_num <=48 or self.port_num >=57: tx_fault=self.__read_txt_file( self.cpld_path +\"module_tx_fault_\" +str(self.port_num)) if int(tx_fault, 10)==1: return[True] else: return[False] else: tx_fault_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence( ) else None if dom_channel_monitor_raw is not None: tx_fault_data=int(dom_channel_monitor_raw[0], 16) tx_fault_list.append(tx_fault_data & 0x01 !=0) tx_fault_list.append(tx_fault_data & 0x02 !=0) tx_fault_list.append(tx_fault_data & 0x04 !=0) tx_fault_list.append(tx_fault_data & 0x08 !=0) return tx_fault_list else: return[False]*4 def get_tx_disable(self): \"\"\" Retrieves the tx_disable status of this SFP Returns: A list of boolean values, representing the TX disable status of each available channel, value is True if SFP channel is TX disabled, False if not. E.g., for a tranceiver with four channels:[False, False, True, False] \"\"\" if self.port_num <=48 or self.port_num >=57: tx_disable=False status_control_raw=self.__read_eeprom_specific_bytes( SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH) if status_control_raw: cpld_val=self.__read_txt_file( self.cpld_path +\"module_tx_disable_\" +str(self.port_num)) tx_disable_hard=(int(cpld_val, 10)==1) data=int(status_control_raw[0], 16) tx_disable_soft=(sffbase().test_bit( data, SFP_TX_DISABLE_SOFT_BIT) !=0) tx_disable=tx_disable_hard | tx_disable_soft if tx_disable==0: return[False] else: return[True] else: return[False] else: tx_disable_list=[] sfpd_obj=sff8436Dom() if sfpd_obj is None: return[False] dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes( dom_control_raw, 0) tx_disable_list.append( 'On'==dom_control_data['data']['TX1Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX2Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX3Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX4Disable']['value']) return tx_disable_list else: return[False]*4 def get_tx_disable_channel(self): \"\"\" Retrieves the TX disabled channels in this SFP Returns: A hex of 4 bits(bit 0 to bit 3 as channel 0 to channel 3) to represent TX channels which have been disabled in this SFP. As an example, a returned value of 0x5 indicates that channel 0 and channel 2 have been disabled. \"\"\" tx_disable_list=self.get_tx_disable() if tx_disable_list is None: return 0 tx_disabled=0 for i in range(len(tx_disable_list)): if tx_disable_list[i]: tx_disabled |=1 << i return tx_disabled def get_lpmode(self): \"\"\" Retrieves the lpmode(low power mode) status of this SFP Returns: A Boolean, True if lpmode is enabled, False if disabled \"\"\" if self.port_num <=48 or self.port_num >=57: return False power_set=self.get_power_set() power_override=self.get_power_override() return power_set and power_override def get_power_set(self): if self.port_num <=48 or self.port_num >=57: return False else: power_set=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes( dom_control_raw, 0) power_set=( 'On'==dom_control_data['data']['PowerSet']['value']) return power_set def get_power_override(self): \"\"\" Retrieves the power-override status of this SFP Returns: A Boolean, True if power-override is enabled, False if disabled \"\"\" if self.port_num <=48 or self.port_num >=57: return False else: power_override=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes( dom_control_raw, 0) power_override=( 'On'==dom_control_data['data']['PowerOverride']['value']) return power_override def reset(self): \"\"\" Reset SFP and return all user module settings to their default srate. Returns: A boolean, True if successful, False if not \"\"\" if self.port_num <=48 or self.port_num >=57: return False ret=self.__write_txt_file( self.cpld_path +\"module_reset_\" +str(self.port_num), 1) if ret is not True: return ret time.sleep(0.01) ret=self.__write_txt_file( self.cpld_path +\"module_reset_\" +str(self.port_num), 0) time.sleep(0.2) return ret def tx_disable(self, tx_disable): \"\"\" Disable SFP TX for all channels Args: tx_disable: A Boolean, True to enable tx_disable mode, False to disable tx_disable mode. Returns: A boolean, True if tx_disable is set successfully, False if not \"\"\" if self.port_num <=48 or self.port_num >=57: ret=self.__write_txt_file( self.cpld_path +\"module_tx_disable_\" +str(self.port_num), 1 if tx_disable else 0) time.sleep(0.01) return ret else: if not self.get_presence(): return False sysfsfile_eeprom=None try: tx_disable_ctl=0xf if tx_disable else 0x0 buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=tx_disable_ctl else: buffer[0]=chr(tx_disable_ctl) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def tx_disable_channel(self, channel, disable): \"\"\" Sets the tx_disable for specified SFP channels Args: channel: A hex of 4 bits(bit 0 to bit 3) which represent channel 0 to 3, e.g. 0x5 for channel 0 and channel 2. disable: A boolean, True to disable TX channels specified in channel, False to enable Returns: A boolean, True if successful, False if not \"\"\" if self.port_num <=48 or self.port_num >=57: return False else: if not self.get_presence(): return False sysfsfile_eeprom=None try: channel_state=self.get_tx_disable_channel() for i in range(4): channel_mask=(1 << i) if not(channel & channel_mask): continue if disable: channel_state |=channel_mask else: channel_state &=~channel_mask buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=channel_state else: buffer[0]=chr(channel_state) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def set_lpmode(self, lpmode): \"\"\" Sets the lpmode(low power mode) of SFP Args: lpmode: A Boolean, True to enable lpmode, False to disable it Note : lpmode can be overridden by set_power_override Returns: A boolean, True if lpmode is set successfully, False if not \"\"\" if self.port_num <=48 or self.port_num >=57: return False if lpmode: return self.set_power_override(True, True) else: return self.set_power_override(True, False) def set_power_override(self, power_override, power_set): \"\"\" Sets SFP power level using power_override and power_set Args: power_override: A Boolean, True to override set_lpmode and use power_set to control SFP power, False to disable SFP power control through power_override/power_set and use set_lpmode to control SFP power. power_set: Only valid when power_override is True. A Boolean, True to set SFP to low power mode, False to set SFP to high power mode. Returns: A boolean, True if power-override and power_set are set successfully, False if not \"\"\" if self.port_num <=48 or self.port_num >=57: return False else: if not self.get_presence(): return False try: power_override_bit=(1 << 0) if power_override else 0 power_set_bit=(1 << 1) if power_set else(1 << 3) buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=(power_override_bit | power_set_bit) else: buffer[0]=chr(power_override_bit | power_set_bit) with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd: fd.seek(QSFP_POWEROVERRIDE_OFFSET) fd.write(buffer[0]) time.sleep(0.01) except Exception: print(\"Error: unable to open file: %s\" % str(e)) return False return True def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" sfputil_helper=SfpUtilHelper() sfputil_helper.read_porttab_mappings( self.__get_path_to_port_config_file()) name=sfputil_helper.logical[self.index] or \"Unknown\" return name def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" val=self.__read_txt_file( self.cpld_path +\"module_present_\" +str(self.port_num)) return val=='1' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return self.get_presence() def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return self.port_num def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return True ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Sfp contains an implementation of SONiC Platform Base API and\n# provides the sfp device status which are available in the platform\n#\n#############################################################################\n\nimport os\nimport time\nimport sys\n\nfrom ctypes import create_string_buffer\n\ntry:\n    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase\n    from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    0: {\n        \"bus\": 18,\n        \"addr\": \"60\"\n    },  # port 31-56\n    1: {\n        \"bus\": 12,\n        \"addr\": \"62\"\n    },  # port  1-30\n}\nCPLD_I2C_PATH = \"/sys/bus/i2c/devices/{}-00{}/\"\n\nclass Sfp(SfpOptoeBase):\n    \"\"\"Platform-specific Sfp class\"\"\"\n\n    # Port number\n    PORT_START = 1\n    PORT_END = 58\n\n    # Path to sysfs\n    PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n    PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n\n    PLATFORM = \"x86_64-accton_as7326_56x-r0\"\n    HWSKU = \"Accton-AS7326-56X\"\n\n    _port_to_i2c_mapping = {\n        1: [42],\n        2: [41],\n        3: [44],\n        4: [43],\n        5: [47],\n        6: [45],\n        7: [46],\n        8: [50],\n        9: [48],\n        10: [49],\n        11: [52],\n        12: [51],\n        13: [53],\n        14: [56],\n        15: [55],\n        16: [54],\n        17: [58],\n        18: [57],\n        19: [60],\n        20: [59],\n        21: [61],\n        22: [63],\n        23: [62],\n        24: [64],\n        25: [66],\n        26: [68],\n        27: [65],\n        28: [67],\n        29: [69],\n        30: [71],\n        31: [72],\n        32: [70],\n        33: [74],\n        34: [73],\n        35: [76],\n        36: [75],\n        37: [77],\n        38: [79],\n        39: [78],\n        40: [80],\n        41: [81],\n        42: [82],\n        43: [84],\n        44: [85],\n        45: [83],\n        46: [87],\n        47: [88],\n        48: [86],\n        49: [25],\n        50: [26],\n        51: [27],\n        52: [28],\n        53: [29],\n        54: [30],\n        55: [31],\n        56: [32],\n        57: [22],\n        58: [23]\n    }\n\n    def __init__(self, sfp_index=0):\n        SfpOptoeBase.__init__(self)\n        # Init index\n        self.index = sfp_index\n        self.port_num = self.index + 1\n\n        cpld_idx = 0 if self.port_num > 30 else 1\n        bus = CPLD_ADDR_MAPPING[cpld_idx][\"bus\"]\n        addr = CPLD_ADDR_MAPPING[cpld_idx][\"addr\"]\n        self.cpld_path = CPLD_I2C_PATH.format(bus, addr)\n\n        # Init eeprom path\n        eeprom_path = '/sys/bus/i2c/devices/{0}-0050/eeprom'\n        self.port_to_eeprom_mapping = {}\n        for x in range(self.PORT_START, self.PORT_END + 1):\n            self.port_to_eeprom_mapping[x] = eeprom_path.format(\n                self._port_to_i2c_mapping[x][0])\n\n    def get_eeprom_path(self):\n        return self.port_to_eeprom_mapping[self.port_num]\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                return fd.read().strip()\n        except IOError:\n            pass\n        return \"\"\n\n    def __write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except Exception:\n            return False\n        return True\n\n    def __is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def __get_path_to_port_config_file(self):\n        platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n        hwsku_path = \"/\".join(\n            [platform_path,\n             self.HWSKU]) if self.__is_host() else self.PMON_HWSKU_PATH\n        return \"/\".join([hwsku_path, \"port_config.ini\"])\n\n    def __read_eeprom_specific_bytes(self, offset, num_bytes):\n        sysfsfile_eeprom = None\n        eeprom_raw = []\n        for i in range(0, num_bytes):\n            eeprom_raw.append(\"0x00\")\n\n        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[\n            self.port_num]\n        try:\n            sysfsfile_eeprom = open(\n                sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0)\n            sysfsfile_eeprom.seek(offset)\n            raw = sysfsfile_eeprom.read(num_bytes)\n            for n in range(0, num_bytes):\n                if sys.version_info[0] >= 3:\n                    eeprom_raw[n] = hex(raw[n])[2:].zfill(2)\n                else:\n                    eeprom_raw[n] = hex(ord(raw[n]))[2:].zfill(2)\n        except Exception:\n            pass\n        finally:\n            if sysfsfile_eeprom:\n                sysfsfile_eeprom.close()\n\n        return eeprom_raw\n\n    def get_reset_status(self):\n        \"\"\"\n        Retrieves the reset status of SFP\n        Returns:\n            A Boolean, True if reset enabled, False if disabled\n        \"\"\"\n        if self.port_num <= 48  or self.port_num >=57:\n            return False  # SPF port doesn't support this feature\n\n        val = self.__read_txt_file(\n            self.cpld_path + \"module_reset_\" + str(self.port_num))\n        return int(val, 10) == 1\n\n    def get_rx_los(self):\n        \"\"\"\n        Retrieves the RX LOS (lost-of-signal) status of SFP\n        Returns:\n            A Boolean, True if SFP has RX LOS, False if not.\n            Note : RX LOS status is latched until a call to get_rx_los or a reset.\n        \"\"\"\n        if self.port_num <= 48  or self.port_num >=57:\n            rx_los = self.__read_txt_file(\n                self.cpld_path + \"module_rx_los_\" + str(self.port_num))\n            if int(rx_los, 10) == 1:\n                return [True]\n            else:\n                return [False]\n            #status_control_raw = self.__read_eeprom_specific_bytes(\n            #    SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            #if status_control_raw:\n            #    data = int(status_control_raw[0], 16)\n            #    rx_los = (sffbase().test_bit(data, 1) != 0)\n        else:\n            rx_los_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_RX_LOS_STATUS_OFFSET,\n                QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence(\n                ) else None\n            if dom_channel_monitor_raw is not None:\n                rx_los_data = int(dom_channel_monitor_raw[0], 16)\n                rx_los_list.append(rx_los_data & 0x01 != 0)\n                rx_los_list.append(rx_los_data & 0x02 != 0)\n                rx_los_list.append(rx_los_data & 0x04 != 0)\n                rx_los_list.append(rx_los_data & 0x08 != 0)\n                return rx_los_list\n            else:\n                return [False]*4\n\n    def get_tx_fault(self):\n        \"\"\"\n        Retrieves the TX fault status of SFP\n        \n        Returns:\n            A list of boolean values, representing the TX fault status\n            of each available channel, value is True if SFP channel\n            has TX fault, False if not.\n            E.g., for a tranceiver with four channels: [False, False, True, False]\n            Note : TX fault status is lached until a call to get_tx_fault or a reset.\n        \"\"\"\n        tx_fault = False\n        if self.port_num <= 48  or self.port_num >=57:\n            tx_fault = self.__read_txt_file(\n                self.cpld_path + \"module_tx_fault_\" + str(self.port_num))\n            if int(tx_fault, 10) == 1:\n                return [True]\n            else:\n                return [False]\n            #status_control_raw = self.__read_eeprom_specific_bytes(\n            #    SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            #if status_control_raw:\n            #    data = int(status_control_raw[0], 16)\n            #    tx_fault = (sffbase().test_bit(data, 2) != 0)\n        else:\n            tx_fault_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_TX_FAULT_STATUS_OFFSET,\n                QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence(\n                ) else None\n            if dom_channel_monitor_raw is not None:\n                tx_fault_data = int(dom_channel_monitor_raw[0], 16)\n                tx_fault_list.append(tx_fault_data & 0x01 != 0)\n                tx_fault_list.append(tx_fault_data & 0x02 != 0)\n                tx_fault_list.append(tx_fault_data & 0x04 != 0)\n                tx_fault_list.append(tx_fault_data & 0x08 != 0)\n                return tx_fault_list\n            else:\n                return [False]*4\n\n\n    def get_tx_disable(self):\n        \"\"\"\n        Retrieves the tx_disable status of this SFP\n        Returns:\n            A list of boolean values, representing the TX disable status\n            of each available channel, value is True if SFP channel\n            is TX disabled, False if not.\n            E.g., for a tranceiver with four channels: [False, False, True, False]\n        \"\"\"\n        if self.port_num <= 48 or self.port_num >=57:\n            tx_disable = False\n\n            status_control_raw = self.__read_eeprom_specific_bytes(\n                SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            if status_control_raw:\n                cpld_val = self.__read_txt_file(\n                    self.cpld_path + \"module_tx_disable_\" + str(self.port_num))\n                tx_disable_hard = (int(cpld_val, 10) == 1)\n                data = int(status_control_raw[0], 16)\n                #tx_disable_hard = (sffbase().test_bit(\n                #    data, SFP_TX_DISABLE_HARD_BIT) != 0)\n                tx_disable_soft = (sffbase().test_bit(\n                    data, SFP_TX_DISABLE_SOFT_BIT) != 0)\n                tx_disable = tx_disable_hard | tx_disable_soft\n                if tx_disable==0:\n                    return [False]\n                else:\n                    return [True]\n                \n            else:\n                return [False]\n\n        else:\n            tx_disable_list = []\n\n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return [False]\n\n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET,\n                QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(\n                    dom_control_raw, 0)\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX1Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX2Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX3Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX4Disable']['value'])\n                return tx_disable_list\n            else:\n                return [False]*4\n\n    def get_tx_disable_channel(self):\n        \"\"\"\n        Retrieves the TX disabled channels in this SFP\n        Returns:\n            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent\n            TX channels which have been disabled in this SFP.\n            As an example, a returned value of 0x5 indicates that channel 0\n            and channel 2 have been disabled.\n        \"\"\"\n        tx_disable_list = self.get_tx_disable()\n        if tx_disable_list is None:\n            return 0\n        tx_disabled = 0\n        for i in range(len(tx_disable_list)):\n            if tx_disable_list[i]:\n                tx_disabled |= 1 << i\n        return tx_disabled\n\n    def get_lpmode(self):\n        \"\"\"\n        Retrieves the lpmode (low power mode) status of this SFP\n        Returns:\n            A Boolean, True if lpmode is enabled, False if disabled\n        \"\"\"\n        if self.port_num <= 48 or self.port_num >= 57:\n            # SFP doesn't support this feature\n            return False\n\n        power_set = self.get_power_set()\n        power_override = self.get_power_override()\n        return power_set and power_override\n\n    def get_power_set(self):\n\n        if self.port_num <= 48 or self.port_num >= 57:\n            # SFP doesn't support this feature\n            return False\n        else:\n            power_set = False\n\n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n\n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET,\n                QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(\n                    dom_control_raw, 0)\n                power_set = (\n                    'On' == dom_control_data['data']['PowerSet']['value'])\n\n            return power_set\n\n    def get_power_override(self):\n        \"\"\"\n        Retrieves the power-override status of this SFP\n        Returns:\n            A Boolean, True if power-override is enabled, False if disabled\n        \"\"\"\n        if self.port_num <= 48 or self.port_num >= 57:\n            return False  # SFP doesn't support this feature\n        else:\n            power_override = False\n\n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n\n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET,\n                QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(\n                    dom_control_raw, 0)\n                power_override = (\n                    'On' == dom_control_data['data']['PowerOverride']['value'])\n\n            return power_override\n\n    def reset(self):\n        \"\"\"\n        Reset SFP and return all user module settings to their default srate.\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        # Check for invalid port_num\n        if self.port_num <= 48  or self.port_num >=57:\n            return False  # SFP doesn't support this feature\n\n        ret = self.__write_txt_file(\n            self.cpld_path + \"module_reset_\" + str(self.port_num), 1)\n        if ret is not True:\n            return ret\n\n        time.sleep(0.01)\n        ret = self.__write_txt_file(\n            self.cpld_path + \"module_reset_\" + str(self.port_num), 0)\n        time.sleep(0.2)\n        return ret\n\n    def tx_disable(self, tx_disable):\n        \"\"\"\n        Disable SFP TX for all channels\n        Args:\n            tx_disable : A Boolean, True to enable tx_disable mode, False to disable\n                         tx_disable mode.\n        Returns:\n            A boolean, True if tx_disable is set successfully, False if not\n        \"\"\"\n        if self.port_num <= 48  or self.port_num >=57:\n            ret = self.__write_txt_file(\n                self.cpld_path + \"module_tx_disable_\" + str(self.port_num), 1\n                if tx_disable else 0)\n            time.sleep(0.01)\n            return ret\n        else:\n            if not self.get_presence():\n                return False\n\n            sysfsfile_eeprom = None\n            try:\n                tx_disable_ctl = 0xf if tx_disable else 0x0\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = tx_disable_ctl\n                else:\n                    buffer[0] = chr(tx_disable_ctl)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print(\"Error: unable to open file: %s\" % str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n        return True\n\n    def tx_disable_channel(self, channel, disable):\n        \"\"\"\n        Sets the tx_disable for specified SFP channels\n        Args:\n            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,\n                      e.g. 0x5 for channel 0 and channel 2.\n            disable : A boolean, True to disable TX channels specified in channel,\n                      False to enable\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n\n        if self.port_num <= 48  or self.port_num >=57:\n            return False  # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n\n            sysfsfile_eeprom = None\n            try:\n                channel_state = self.get_tx_disable_channel()\n\n                for i in range(4):\n                    channel_mask = (1 << i)\n                    if not (channel & channel_mask):\n                        continue\n\n                    if disable:\n                        channel_state |= channel_mask\n                    else:\n                        channel_state &= ~channel_mask\n\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = channel_state\n                else:\n                    buffer[0] = chr(channel_state)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print(\"Error: unable to open file: %s\" % str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n            return True\n\n    def set_lpmode(self, lpmode):\n        \"\"\"\n        Sets the lpmode (low power mode) of SFP\n        Args:\n            lpmode: A Boolean, True to enable lpmode, False to disable it\n            Note  : lpmode can be overridden by set_power_override\n        Returns:\n            A boolean, True if lpmode is set successfully, False if not\n        \"\"\"\n        if self.port_num <= 48  or self.port_num >=57:\n            return False  # SFP doesn't support this feature\n\n        if lpmode:\n            return self.set_power_override(True, True)\n        else:\n            return self.set_power_override(True, False)\n\n    def set_power_override(self, power_override, power_set):\n        \"\"\"\n        Sets SFP power level using power_override and power_set\n        Args:\n            power_override :\n                    A Boolean, True to override set_lpmode and use power_set\n                    to control SFP power, False to disable SFP power control\n                    through power_override/power_set and use set_lpmode\n                    to control SFP power.\n            power_set :\n                    Only valid when power_override is True.\n                    A Boolean, True to set SFP to low power mode, False to set\n                    SFP to high power mode.\n        Returns:\n            A boolean, True if power-override and power_set are set successfully,\n            False if not\n        \"\"\"\n        if self.port_num <= 48  or self.port_num >=57:\n            return False  # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n            try:\n                power_override_bit = (1 << 0) if power_override else 0\n                power_set_bit = (1 << 1) if power_set else (1 << 3)\n\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = (power_override_bit | power_set_bit)\n                else:\n                    buffer[0] = chr(power_override_bit | power_set_bit)\n                # Write to eeprom\n                with open(self.port_to_eeprom_mapping[self.port_num],\n                          \"r+b\") as fd:\n                    fd.seek(QSFP_POWEROVERRIDE_OFFSET)\n                    fd.write(buffer[0])\n                    time.sleep(0.01)\n            except Exception:\n                print(\"Error: unable to open file: %s\" % str(e))\n                return False\n            return True\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        sfputil_helper = SfpUtilHelper()\n        sfputil_helper.read_porttab_mappings(\n            self.__get_path_to_port_config_file())\n        name = sfputil_helper.logical[self.index] or \"Unknown\"\n        return name\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        val = self.__read_txt_file(\n            self.cpld_path + \"module_present_\" + str(self.port_num))\n        return val == '1'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return self.get_presence()\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return self.port_num\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return True\n"}, "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE = \"/sys/class/leds/as7816_64x_led::diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n     \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os import sys try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper from.event import SfpEvent except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=4 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=6 NUM_PORT=64 NUM_COMPONENT=5 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" SYSLED_FNODE=\"/sys/class/leds/as7816_64x_led::diag/brightness\" SYSLED_MODES={ \"0\": \"STATUS_LED_COLOR_OFF\", \"16\": \"STATUS_LED_COLOR_GREEN\", \"10\": \"STATUS_LED_COLOR_RED\" } class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(0, NUM_PORT): sfp=Sfp(index) self._sfp_list.append(sfp) self._sfpevent=SfpEvent(self._sfp_list) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for fant_index in range(NUM_FAN_TRAY): fandrawer=FanDrawer(fant_index) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._eeprom.get_product_name() def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_change_event(self, timeout=0): if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfpevent.get_sfp_event(timeout) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def initizalize_system_led(self): return True def get_status_led(self): val=self._api_helper.read_txt_file(SYSLED_FNODE) return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\" def set_status_led(self, color): mode=None for key, val in SYSLED_MODES.items(): if val==color: mode=key break if mode is None: return False else: return self._api_helper.write_txt_file(SYSLED_FNODE, mode) ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\nimport sys\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\n    from .event import SfpEvent\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 4\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 6\nNUM_PORT = 64\nNUM_COMPONENT = 5\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\nSYSLED_FNODE = \"/sys/class/leds/as7816_64x_led::diag/brightness\"\nSYSLED_MODES = {\n    \"0\" : \"STATUS_LED_COLOR_OFF\",\n    \"16\" : \"STATUS_LED_COLOR_GREEN\",\n    \"10\" : \"STATUS_LED_COLOR_RED\"\n\n}\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n        \n        self.config_data = {}\n\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n\n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(0, NUM_PORT):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self._sfpevent = SfpEvent(self._sfp_list)\n        self.sfp_module_initialized = True\n\n    def __initialize_fan(self):\n        from sonic_platform.fan_drawer import FanDrawer\n        for fant_index in range(NUM_FAN_TRAY):\n            fandrawer = FanDrawer(fant_index)\n            self._fan_drawer_list.append(fandrawer)\n            self._fan_list.extend(fandrawer._fan_list)\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n    \n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return self._eeprom.get_product_name()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n    \n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n    \n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n        \n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n      \n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n\n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_change_event(self, timeout=0):\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n        return self._sfpevent.get_sfp_event(timeout)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n        \n    def initizalize_system_led(self):\n        return True\n\n    def get_status_led(self):\n        val = self._api_helper.read_txt_file(SYSLED_FNODE)\n        return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\"\n\n    def set_status_led(self, color):\n        mode = None\n        for key, val in SYSLED_MODES.items():\n            if val == color:\n                mode = key\n                break\n        if mode is None:\n            return False\n        else:\n            return self._api_helper.write_txt_file(SYSLED_FNODE, mode)\n"}, "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 2, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware", "add": 0, "remove": 16, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"19-0060\", \"CPLD2\": \"20-0062\", \"CPLD3\": \"21-0064\", \"CPLD4\": \"22-0066\", } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"CPLD2\", \"CPLD 2\"), (\"CPLD3\", \"CPLD 3\"), (\"CPLD4\", \"CPLD 4\"), (\"BIOS\", \"Basic Input/Output System\") ] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return 'N/A' def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return 'N/A' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is'0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"19-0060\",\n    \"CPLD2\": \"20-0062\",\n    \"CPLD3\": \"21-0064\",\n    \"CPLD4\": \"22-0066\",\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"CPLD2\", \"CPLD 2\"),\n   (\"CPLD3\", \"CPLD 3\"),\n   (\"CPLD4\", \"CPLD 4\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n   \n]\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)\n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n        \n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of\n        entPhysicalContainedIn is'0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device\n            or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-      ", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False"], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r', errors='replace') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r', errors='replace') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as7816_64x-r0\"\n     HWSKU = \"Accton-AS7816-64X\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n         return self.port_to_eeprom_mapping[self.port_num]\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_RO", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}], "source": "\n import os import time import sys from ctypes import create_string_buffer try: from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_I2C_PATH=\"/sys/bus/i2c/devices/19-0060/\" class Sfp(SfpOptoeBase): \"\"\"Platform-specific Sfp class\"\"\" PORT_START=1 PORT_END=64 PLATFORM_ROOT_PATH=\"/usr/share/sonic/device\" PMON_HWSKU_PATH=\"/usr/share/sonic/hwsku\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" PLATFORM=\"x86_64-accton_as7816_64x-r0\" HWSKU=\"Accton-AS7816-64X\" _port_to_i2c_mapping={ 61: 25, 62: 26, 63: 27, 64: 28, 55: 29, 56: 30, 53: 31, 54: 32, 9: 33, 10: 34, 11: 35, 12: 36, 1: 37, 2: 38, 3: 39, 4: 40, 6: 41, 5: 42, 8: 43, 7: 44, 13: 45, 14: 46, 15: 47, 16: 48, 17: 49, 18: 50, 19: 51, 20: 52, 25: 53, 26: 54, 27: 55, 28: 56, 29: 57, 30: 58, 31: 59, 32: 60, 21: 61, 22: 62, 23: 63, 24: 64, 41: 65, 42: 66, 43: 67, 44: 68, 33: 69, 34: 70, 35: 71, 36: 72, 45: 73, 46: 74, 47: 75, 48: 76, 37: 77, 38: 78, 39: 79, 40: 80, 57: 81, 58: 82, 59: 83, 60: 84, 49: 85, 50: 86, 51: 87, 52: 88 } def __init__(self, sfp_index=0): SfpOptoeBase.__init__(self) self._api_helper=APIHelper() self.index=sfp_index self.port_num=self.index +1 eeprom_path='/sys/bus/i2c/devices/{0}-0050/eeprom' self.port_to_eeprom_mapping={} for x in range(self.PORT_START, self.PORT_END +1): self.port_to_eeprom_mapping[x]=eeprom_path.format(self._port_to_i2c_mapping[x]) def get_eeprom_path(self): return self.port_to_eeprom_mapping[self.port_num] def __is_host(self): return os.system(self.HOST_CHK_CMD)==0 def __get_path_to_port_config_file(self): platform_path=\"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM]) hwsku_path=\"/\".join([platform_path, self.HWSKU] ) if self.__is_host() else self.PMON_HWSKU_PATH return \"/\".join([hwsku_path, \"port_config.ini\"]) def __read_eeprom_specific_bytes(self, offset, num_bytes): sysfsfile_eeprom=None eeprom_raw=[] for i in range(0, num_bytes): eeprom_raw.append(\"0x00\") sysfs_sfp_i2c_client_eeprom_path=self.port_to_eeprom_mapping[self.port_num] try: sysfsfile_eeprom=open( sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0) sysfsfile_eeprom.seek(offset) raw=sysfsfile_eeprom.read(num_bytes) if sys.version_info[0] >=3: for n in range(0, num_bytes): eeprom_raw[n]=hex(raw[n])[2:].zfill(2) else: for n in range(0, num_bytes): eeprom_raw[n]=hex(ord(raw[n]))[2:].zfill(2) except Exception: pass finally: if sysfsfile_eeprom: sysfsfile_eeprom.close() return eeprom_raw def get_reset_status(self): \"\"\" Retrieves the reset status of SFP Returns: A Boolean, True if reset enabled, False if disabled \"\"\" reset_path=\"{}{}{}\".format(CPLD_I2C_PATH, \"module_reset_\", str(self.port_num)) val=self._api_helper.read_txt_file(reset_path) if val is not None: return int(val, 10)==1 else: return False def get_rx_los(self): \"\"\" Retrieves the RX LOS(lost-of-signal) status of SFP Returns: A Boolean, True if SFP has RX LOS, False if not. Note: RX LOS status is latched until a call to get_rx_los or a reset. \"\"\" rx_los_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: rx_los_data=int(dom_channel_monitor_raw[0], 16) rx_los_list.append(rx_los_data & 0x01 !=0) rx_los_list.append(rx_los_data & 0x02 !=0) rx_los_list.append(rx_los_data & 0x04 !=0) rx_los_list.append(rx_los_data & 0x08 !=0) return rx_los_list else: return[False]*4 def get_tx_fault(self): \"\"\" Retrieves the TX fault status of SFP Returns: A Boolean, True if SFP has TX fault, False if not Note: TX fault status is lached until a call to get_tx_fault or a reset. \"\"\" tx_fault_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: tx_fault_data=int(dom_channel_monitor_raw[0], 16) tx_fault_list.append(tx_fault_data & 0x01 !=0) tx_fault_list.append(tx_fault_data & 0x02 !=0) tx_fault_list.append(tx_fault_data & 0x04 !=0) tx_fault_list.append(tx_fault_data & 0x08 !=0) return tx_fault_list else: return[False]*4 def get_tx_disable(self): \"\"\" Retrieves the tx_disable status of this SFP Returns: A Boolean, True if tx_disable is enabled, False if disabled \"\"\" tx_disable_list=[] sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) tx_disable_list.append( 'On'==dom_control_data['data']['TX1Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX2Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX3Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX4Disable']['value']) return tx_disable_list else: return[False]*4 def get_tx_disable_channel(self): \"\"\" Retrieves the TX disabled channels in this SFP Returns: A hex of 4 bits(bit 0 to bit 3 as channel 0 to channel 3) to represent TX channels which have been disabled in this SFP. As an example, a returned value of 0x5 indicates that channel 0 and channel 2 have been disabled. \"\"\" tx_disable_list=self.get_tx_disable() if tx_disable_list is None: return 0 tx_disabled=0 for i in range(len(tx_disable_list)): if tx_disable_list[i]: tx_disabled |=1 << i return tx_disabled def get_lpmode(self): \"\"\" Retrieves the lpmode(low power mode) status of this SFP Returns: A Boolean, True if lpmode is enabled, False if disabled \"\"\" power_set=self.get_power_set() power_override=self.get_power_override() return power_set and power_override def get_power_set(self): power_set=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) power_set=( 'On'==dom_control_data['data']['PowerSet']['value']) return power_set def get_power_override(self): \"\"\" Retrieves the power-override status of this SFP Returns: A Boolean, True if power-override is enabled, False if disabled \"\"\" power_override=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) power_override=( 'On'==dom_control_data['data']['PowerOverride']['value']) return power_override def reset(self): \"\"\" Reset SFP and return all user module settings to their default srate. Returns: A boolean, True if successful, False if not \"\"\" reset_path=\"{}{}{}\".format(CPLD_I2C_PATH, 'module_reset_', self.port_num) ret=self._api_helper.write_txt_file(reset_path, 1) if ret is not True: return ret time.sleep(0.01) ret=self._api_helper.write_txt_file(reset_path, 0) time.sleep(0.2) return ret def tx_disable(self, tx_disable): \"\"\" Disable SFP TX for all channels Args: tx_disable: A Boolean, True to enable tx_disable mode, False to disable tx_disable mode. Returns: A boolean, True if tx_disable is set successfully, False if not \"\"\" if not self.get_presence(): return False sysfsfile_eeprom=None try: tx_disable_ctl=0xf if tx_disable else 0x0 buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=tx_disable_ctl else: buffer[0]=chr(tx_disable_ctl) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ',str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def tx_disable_channel(self, channel, disable): \"\"\" Sets the tx_disable for specified SFP channels Args: channel: A hex of 4 bits(bit 0 to bit 3) which represent channel 0 to 3, e.g. 0x5 for channel 0 and channel 2. disable: A boolean, True to disable TX channels specified in channel, False to enable Returns: A boolean, True if successful, False if not \"\"\" if not self.get_presence(): return False sysfsfile_eeprom=None try: channel_state=self.get_tx_disable_channel() for i in range(4): channel_mask=(1 << i) if not(channel & channel_mask): continue if disable: channel_state |=channel_mask else: channel_state &=~channel_mask buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=channel_state else: buffer[0]=chr(channel_state) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ', str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def set_lpmode(self, lpmode): \"\"\" Sets the lpmode(low power mode) of SFP Args: lpmode: A Boolean, True to enable lpmode, False to disable it Note : lpmode can be overridden by set_power_override Returns: A boolean, True if lpmode is set successfully, False if not \"\"\" if lpmode: self.set_power_override(True, True) else: self.set_power_override(False, False) return True def set_power_override(self, power_override, power_set): \"\"\" Sets SFP power level using power_override and power_set Args: power_override: A Boolean, True to override set_lpmode and use power_set to control SFP power, False to disable SFP power control through power_override/power_set and use set_lpmode to control SFP power. power_set: Only valid when power_override is True. A Boolean, True to set SFP to low power mode, False to set SFP to high power mode. Returns: A boolean, True if power-override and power_set are set successfully, False if not \"\"\" if not self.get_presence(): return False try: power_override_bit=(1 << 0) if power_override else 0 power_set_bit =(1 << 1) if power_set else(1 << 3) buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=(power_override_bit | power_set_bit) else: buffer[0]=chr(power_override_bit | power_set_bit) with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd: fd.seek(QSFP_POWEROVERRIDE_OFFSET) fd.write(buffer[0]) time.sleep(0.01) except Exception: print('Error: unable to open file: ', str(e)) return False return True def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" sfputil_helper=SfpUtilHelper() sfputil_helper.read_porttab_mappings( self.__get_path_to_port_config_file()) name=sfputil_helper.logical[self.index] or \"Unknown\" return name def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" present_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_present_', self.port_num) val=self._api_helper.read_txt_file(present_path) if val is not None: return int(val, 10)==1 else: return False def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return self.get_presence() def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return self.port_num def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return True ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Sfp contains an implementation of SONiC Platform Base API and\n# provides the sfp device status which are available in the platform\n#\n#############################################################################\n\nimport os\nimport time\nimport sys\n\nfrom ctypes import create_string_buffer\n\ntry:\n    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_I2C_PATH = \"/sys/bus/i2c/devices/19-0060/\"\n\n\nclass Sfp(SfpOptoeBase):\n    \"\"\"Platform-specific Sfp class\"\"\"\n\n    # Port number\n    PORT_START = 1\n    PORT_END = 64\n\n    # Path to sysfs\n    PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n    PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n        \n    PLATFORM = \"x86_64-accton_as7816_64x-r0\"\n    HWSKU = \"Accton-AS7816-64X\"\n\n    _port_to_i2c_mapping = {\n        61: 25,\n        62: 26,\n        63: 27,\n        64: 28,\n        55: 29,\n        56: 30,\n        53: 31,\n        54: 32,\n        9:  33,\n        10: 34,\n        11: 35,\n        12: 36,\n        1:  37,\n        2:  38,\n        3:  39,\n        4:  40,\n        6:  41,\n        5:  42,\n        8:  43,\n        7:  44,\n        13: 45,\n        14: 46,\n        15: 47,\n        16: 48,\n        17: 49,\n        18: 50,\n        19: 51,\n        20: 52,\n        25: 53,\n        26: 54,\n        27: 55,\n        28: 56,\n        29: 57,\n        30: 58,\n        31: 59,\n        32: 60,\n        21: 61,\n        22: 62,\n        23: 63,\n        24: 64,\n        41: 65,\n        42: 66,\n        43: 67,\n        44: 68,\n        33: 69,\n        34: 70,\n        35: 71,\n        36: 72,\n        45: 73,\n        46: 74,\n        47: 75,\n        48: 76,\n        37: 77,\n        38: 78,\n        39: 79,\n        40: 80,\n        57: 81,\n        58: 82,\n        59: 83,\n        60: 84,\n        49: 85,\n        50: 86,\n        51: 87,\n        52: 88 \n    }\n\n    def __init__(self, sfp_index=0):\n        SfpOptoeBase.__init__(self)\n        self._api_helper=APIHelper()\n        # Init index\n        self.index = sfp_index\n        self.port_num = self.index + 1\n        # Init eeprom path\n        eeprom_path = '/sys/bus/i2c/devices/{0}-0050/eeprom'\n        self.port_to_eeprom_mapping = {}\n        for x in range(self.PORT_START, self.PORT_END + 1):\n            self.port_to_eeprom_mapping[x] = eeprom_path.format(self._port_to_i2c_mapping[x])\n        \n    def get_eeprom_path(self):\n        return self.port_to_eeprom_mapping[self.port_num]\n\n    def __is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def __get_path_to_port_config_file(self):\n        platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n        hwsku_path = \"/\".join([platform_path, self.HWSKU]\n                              ) if self.__is_host() else self.PMON_HWSKU_PATH\n        return \"/\".join([hwsku_path, \"port_config.ini\"])\n\n    def __read_eeprom_specific_bytes(self, offset, num_bytes):\n        sysfsfile_eeprom = None\n        eeprom_raw = []\n        for i in range(0, num_bytes):\n            eeprom_raw.append(\"0x00\")\n\n        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]\n        try:\n            sysfsfile_eeprom = open(\n                sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0)\n            sysfsfile_eeprom.seek(offset)\n            raw = sysfsfile_eeprom.read(num_bytes)\n            if sys.version_info[0] >= 3:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(raw[n])[2:].zfill(2)\n            else:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(ord(raw[n]))[2:].zfill(2)\n        except Exception:\n            pass\n        finally:\n            if sysfsfile_eeprom:\n                sysfsfile_eeprom.close()\n\n        return eeprom_raw\n\n    def get_reset_status(self):\n        \"\"\"\n        Retrieves the reset status of SFP\n        Returns:\n            A Boolean, True if reset enabled, False if disabled\n        \"\"\"\n        reset_path=\"{}{}{}\".format(CPLD_I2C_PATH , \"module_reset_\" , str(self.port_num))\n        val = self._api_helper.read_txt_file(reset_path)\n        \n        if val is not None:\n            return int(val, 10) == 1\n        else:\n            return False\n\n    def get_rx_los(self):\n        \"\"\"\n        Retrieves the RX LOS (lost-of-signal) status of SFP\n        Returns:\n            A Boolean, True if SFP has RX LOS, False if not.\n            Note : RX LOS status is latched until a call to get_rx_los or a reset.\n        \"\"\"\n\n        rx_los_list = []\n        dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None\n        if dom_channel_monitor_raw is not None:\n                rx_los_data = int(dom_channel_monitor_raw[0], 16)\n                rx_los_list.append(rx_los_data & 0x01 != 0)\n                rx_los_list.append(rx_los_data & 0x02 != 0)\n                rx_los_list.append(rx_los_data & 0x04 != 0)\n                rx_los_list.append(rx_los_data & 0x08 != 0)\n                return rx_los_list\n        else:\n            return [False]*4\n\n\n    def get_tx_fault(self):\n        \"\"\"\n        Retrieves the TX fault status of SFP\n        Returns:\n            A Boolean, True if SFP has TX fault, False if not\n            Note : TX fault status is lached until a call to get_tx_fault or a reset.\n        \"\"\"\n        tx_fault_list = []\n        dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None\n        if dom_channel_monitor_raw is not None:\n            tx_fault_data = int(dom_channel_monitor_raw[0], 16)\n            tx_fault_list.append(tx_fault_data & 0x01 != 0)\n            tx_fault_list.append(tx_fault_data & 0x02 != 0)\n            tx_fault_list.append(tx_fault_data & 0x04 != 0)\n            tx_fault_list.append(tx_fault_data & 0x08 != 0)\n            return tx_fault_list\n        else:\n            return [False]*4\n\n    def get_tx_disable(self):\n        \"\"\"\n        Retrieves the tx_disable status of this SFP\n        Returns:\n            A Boolean, True if tx_disable is enabled, False if disabled\n        \"\"\"\n        \n        tx_disable_list = []\n    \n        sfpd_obj = sff8436Dom()\n        if sfpd_obj is None:\n            return False\n    \n        dom_control_raw = self.__read_eeprom_specific_bytes(\n            QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n        if dom_control_raw is not None:\n            dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n            tx_disable_list.append(\n                'On' == dom_control_data['data']['TX1Disable']['value'])\n            tx_disable_list.append(\n                'On' == dom_control_data['data']['TX2Disable']['value'])\n            tx_disable_list.append(\n                'On' == dom_control_data['data']['TX3Disable']['value'])\n            tx_disable_list.append(\n                'On' == dom_control_data['data']['TX4Disable']['value'])\n            return tx_disable_list\n        else:\n            return [False]*4\n\n    def get_tx_disable_channel(self):\n        \"\"\"\n        Retrieves the TX disabled channels in this SFP\n        Returns:\n            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent\n            TX channels which have been disabled in this SFP.\n            As an example, a returned value of 0x5 indicates that channel 0\n            and channel 2 have been disabled.\n        \"\"\"\n        tx_disable_list = self.get_tx_disable()\n        if tx_disable_list is None:\n            return 0\n        tx_disabled = 0\n        for i in range(len(tx_disable_list)):\n            if tx_disable_list[i]:\n                tx_disabled |= 1 << i\n        return tx_disabled\n\n    def get_lpmode(self):\n        \"\"\"\n        Retrieves the lpmode (low power mode) status of this SFP\n        Returns:\n            A Boolean, True if lpmode is enabled, False if disabled\n        \"\"\"\n\n        power_set=self.get_power_set()\n        power_override = self.get_power_override()\n        return power_set and power_override\n\n    def get_power_set(self):\n        power_set = False\n        sfpd_obj = sff8436Dom()\n        if sfpd_obj is None:\n            return False\n        dom_control_raw = self.__read_eeprom_specific_bytes(\n            QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n        if dom_control_raw is not None:\n            dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n            power_set = (\n                'On' == dom_control_data['data']['PowerSet']['value'])\n    \n        return power_set\n\n    def get_power_override(self):\n        \"\"\"\n        Retrieves the power-override status of this SFP\n        Returns:\n            A Boolean, True if power-override is enabled, False if disabled\n        \"\"\"\n        power_override = False\n        sfpd_obj = sff8436Dom()\n        if sfpd_obj is None:\n            return False\n\n        dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n        if dom_control_raw is not None:\n            dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n            power_override = (\n                'On' == dom_control_data['data']['PowerOverride']['value'])\n\n        return power_override\n\n    def reset(self):\n        \"\"\"\n        Reset SFP and return all user module settings to their default srate.\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        reset_path = \"{}{}{}\".format(CPLD_I2C_PATH , 'module_reset_' , self.port_num)\n        ret = self._api_helper.write_txt_file(reset_path, 1)\n        if ret is not True:\n            return ret\n\n        time.sleep(0.01)\n        ret = self._api_helper.write_txt_file(reset_path, 0)\n        time.sleep(0.2)\n\n        return ret\n\n    def tx_disable(self, tx_disable):\n        \"\"\"\n        Disable SFP TX for all channels\n        Args:\n            tx_disable : A Boolean, True to enable tx_disable mode, False to disable\n                         tx_disable mode.\n        Returns:\n            A boolean, True if tx_disable is set successfully, False if not\n        \"\"\"\n        if not self.get_presence():\n            return False\n        sysfsfile_eeprom = None\n        try:\n            tx_disable_ctl = 0xf if tx_disable else 0x0\n            buffer = create_string_buffer(1)\n            if sys.version_info[0] >= 3:\n                buffer[0] = tx_disable_ctl\n            else:\n                buffer[0] = chr(tx_disable_ctl)\n            # Write to eeprom\n            sysfsfile_eeprom = open(\n                self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n            sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n            sysfsfile_eeprom.write(buffer[0])\n        except IOError as e:\n            print ('Error: unable to open file: ',str(e))\n            return False\n        finally:\n            if sysfsfile_eeprom is not None:\n                sysfsfile_eeprom.close()\n                time.sleep(0.01)\n        \n        return True\n\n    def tx_disable_channel(self, channel, disable):\n        \"\"\"\n        Sets the tx_disable for specified SFP channels\n        Args:\n            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,\n                      e.g. 0x5 for channel 0 and channel 2.\n            disable : A boolean, True to disable TX channels specified in channel,\n                      False to enable\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"        \n        if not self.get_presence():\n            return False\n\n        sysfsfile_eeprom = None\n        try:\n            channel_state = self.get_tx_disable_channel()\n            for i in range(4):\n                channel_mask = (1 << i)\n                if not (channel & channel_mask):\n                    continue\n\n                if disable:\n                    channel_state |= channel_mask\n                else:\n                    channel_state &= ~channel_mask\n\n            buffer = create_string_buffer(1)\n            if sys.version_info[0] >= 3:\n                buffer[0] = channel_state\n            else:\n                buffer[0] = chr(channel_state)\n            # Write to eeprom\n            sysfsfile_eeprom = open(\n                self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n            sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n            sysfsfile_eeprom.write(buffer[0])\n        except IOError as e:\n            print ('Error: unable to open file: ', str(e))\n            return False\n        finally:\n            if sysfsfile_eeprom is not None:\n                sysfsfile_eeprom.close()\n                time.sleep(0.01)\n\n        return True\n\n    def set_lpmode(self, lpmode):\n        \"\"\"\n        Sets the lpmode (low power mode) of SFP\n        Args:\n            lpmode: A Boolean, True to enable lpmode, False to disable it\n            Note  : lpmode can be overridden by set_power_override\n        Returns:\n            A boolean, True if lpmode is set successfully, False if not\n        \"\"\"        \n        if lpmode:\n            self.set_power_override(True, True)\n        else:\n            self.set_power_override(False, False)\n    \n        return True\n       \n    def set_power_override(self, power_override, power_set):\n        \"\"\"\n        Sets SFP power level using power_override and power_set\n        Args:\n            power_override :\n                    A Boolean, True to override set_lpmode and use power_set\n                    to control SFP power, False to disable SFP power control\n                    through power_override/power_set and use set_lpmode\n                    to control SFP power.\n            power_set :\n                    Only valid when power_override is True.\n                    A Boolean, True to set SFP to low power mode, False to set\n                    SFP to high power mode.\n        Returns:\n            A boolean, True if power-override and power_set are set successfully,\n            False if not\n        \"\"\"\n       \n        if not self.get_presence():\n            return False\n        try:\n            power_override_bit = (1 << 0) if power_override else 0\n            power_set_bit      = (1 << 1) if power_set else (1 << 3)\n    \n            buffer = create_string_buffer(1)\n            if sys.version_info[0] >= 3:\n                buffer[0] = (power_override_bit | power_set_bit)\n            else:\n                buffer[0] = chr(power_override_bit | power_set_bit)\n            # Write to eeprom\n            with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd:\n                fd.seek(QSFP_POWEROVERRIDE_OFFSET)\n                fd.write(buffer[0])\n                time.sleep(0.01)\n        except Exception:\n            print ('Error: unable to open file: ', str(e))\n            return False\n\n        return True\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        sfputil_helper = SfpUtilHelper()\n        sfputil_helper.read_porttab_mappings(\n            self.__get_path_to_port_config_file())\n        name = sfputil_helper.logical[self.index] or \"Unknown\"\n        return name\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        present_path = \"{}{}{}\".format(CPLD_I2C_PATH , '/module_present_' , self.port_num)\n        val=self._api_helper.read_txt_file(present_path)\n        if val is not None:\n            return int(val, 10)==1\n        else:\n            return False\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return self.get_presence()\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return self.port_num\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return True\n"}, "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, ", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=6 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=3 NUM_QSFP=32 PORT_START=1 PORT_END=34 QSFP_PORT_START=0 QSFP_PORT_END=31 NUM_COMPONENT=2 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"docker > /dev/null 2>&1\" class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp self.QSFP_PORT_START=QSFP_PORT_START self.QSFP_PORT_END=QSFP_PORT_END for index in range(0, PORT_END): if index in range(self.QSFP_PORT_START, self.QSFP_PORT_END +1): sfp_module=Sfp(index, 'QSFP') else: sfp_module=Sfp(index, 'SFP') self._sfp_list.append(sfp_module) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan import Fan for fant_index in range(0, NUM_FAN_TRAY): for fan_index in range(0, NUM_FAN): fan=Fan(fant_index, fan_index) self._fan_list.append(fan) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._api_helper.hwsku def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_serial_number(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp ", "sourceWithComments": "#############################################################################\n# Accton\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 6\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 3\nNUM_QSFP = 32\nPORT_START = 1\nPORT_END = 34\nQSFP_PORT_START = 0\nQSFP_PORT_END = 31\nNUM_COMPONENT = 2\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n\n        self.config_data = {}\n\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n\n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n\n        self.QSFP_PORT_START = QSFP_PORT_START\n        self.QSFP_PORT_END = QSFP_PORT_END\n        for index in range(0, PORT_END):\n            if index in range(self.QSFP_PORT_START, self.QSFP_PORT_END + 1):\n                sfp_module = Sfp(index, 'QSFP')\n            else:\n                sfp_module = Sfp(index, 'SFP')\n            self._sfp_list.append(sfp_module)\n        self.sfp_module_initialized = True\n\n    def __initialize_fan(self):\n        from sonic_platform.fan import Fan\n        for fant_index in range(0, NUM_FAN_TRAY):\n            for fan_index in range(0, NUM_FAN):\n                fan = Fan(fant_index, fan_index)\n                self._fan_list.append(fan)\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n\n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n\n        return self._api_helper.hwsku\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_serial_number(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n\n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n"}, "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 3, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()        \n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firm", "add": 0, "remove": 16, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"3-0060\" } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"BIOS\", \"Basic Input/Output System\") ] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError ", "sourceWithComments": "#############################################################################\n# Accton\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"3-0060\"\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n\n]\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()        \n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)               \n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n\n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()           \n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n"}, "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-  ", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False"], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n class Sfp(SfpBase):\n     \"\"\"Platform-specific Sfp class\"\"\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n     PLATFORM = \"x86_64-accton_as9726_32d-r0\"\n     HWSKU = \"Accton-AS9726-32D\"\n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFOR", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}]}, "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py": {"changes": [{"diff": "\n #############################################################################\n \n try:\n-    import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py", "badparts": ["    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         if self.name == \"BIOS\":\n             fw_version = self.__get_bios_version()\n         elif \"CPLD\" in self.name:\n-            cmd = \"i2cget -f -y {0} {1} 0x1\".format(self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1])\n-            status, value = subprocess.getstatusoutput(cmd)\n+            cmd = [\"i2cget\", \"-f\", \"-y\", self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1], \"0x1\"]\n+            status, value = getstatusoutput_noshell(cmd)\n             if not status:\n                 ", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py", "badparts": ["            cmd = \"i2cget -f -y {0} {1} 0x1\".format(self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1])", "            status, value = subprocess.getstatusoutput(cmd)"], "goodparts": ["            cmd = [\"i2cget\", \"-f\", \"-y\", self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1], \"0x1\"]", "            status, value = getstatusoutput_noshell(cmd)"]}], "source": "\n try: import subprocess from sonic_platform_base.component_base import ComponentBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"BIOS\", \"Basic Input/Output System\") ] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" def __init__(self, component_index): self.index=component_index self.name=self.get_name() self.cpld_mapping={ 0:['3', '0x60'] } def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cmd=\"i2cget -f -y{0}{1} 0x1\".format(self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1]) status, value=subprocess.getstatusoutput(cmd) if not status: fw_version=value.rstrip() return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError ", "sourceWithComments": "#!/usr/bin/env python\n\n#############################################################################\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the component information (such as CPLD, FPGA, BIOS etc) which are available in the platform\n#\n#############################################################################\n\ntry:\n    import subprocess\n    from sonic_platform_base.component_base import ComponentBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\n#COMPONENT_NAME_LIST = [\"CPLD1\"]\nCOMPONENT_LIST =  [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n]\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n\n    def __init__(self, component_index):\n        self.index = component_index\n        self.name = self.get_name()\n        self.cpld_mapping = {\n                0: ['3', '0x60']                \n            }\n\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n    \n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n    \n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cmd = \"i2cget -f -y {0} {1} 0x1\".format(self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1])\n            status, value = subprocess.getstatusoutput(cmd)\n            if not status:\n                fw_version = value.rstrip()\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n"}, "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py": {"changes": [{"diff": "\n     import logging.config\n     import logging.handlers\n     import time\n-    import subprocess\n     from as4630_54pe.fanutil import FanUtil\n     from as4630_54pe.thermalutil import ThermalUtil\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py", "badparts": ["    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         if temp[0] >= 70000: #LM75-48    \n             #critical case*/\n             logging.critical('Alarm-Critical for temperature critical is detected, reset DUT')\n-            cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2);\n-            status, output = subprocess.getstatusoutput(cmd_str)\n+            status, output = getstatusoutput_noshell(cmd_str)\n                 \n         #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_state, fan_pol", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py", "badparts": ["            cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\"", "            status, output = subprocess.getstatusoutput(cmd_str)"], "goodparts": ["            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]", "            status, output = getstatusoutput_noshell(cmd_str)"]}], "source": "\n try: import getopt import sys import logging import logging.config import logging.handlers import time import subprocess from as4630_54pe.fanutil import FanUtil from as4630_54pe.thermalutil import ThermalUtil except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as4630_54pe_monitor' global log_file global log_level class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False fan_policy_state=0 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0, 0] temp_test_data=0 test_temp_revert=0 class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 for i in range(0, len(policy)): if(temp > policy[i][2]): if temp <=policy[i][3]: state=i return state def manage_fans(self): global fan_policy_state global fan_fail global test_temp global test_temp_list global alarm_state global temp_test_data global test_temp_revert LEVEL_FAN_MIN=0 LEVEL_FAN_NORMAL=1 LEVEL_FAN_MID=2 LEVEL_FAN_HIGH=3 LEVEL_TEMP_CRITICAL=4 fan_policy={ LEVEL_FAN_MIN: [50, 8, 0, 140000], LEVEL_FAN_NORMAL: [62, 10, 140000, 150000], LEVEL_FAN_MID: [75, 12, 150000, 160000], LEVEL_FAN_HIGH: [88, 14, 160000, 240000], LEVEL_TEMP_CRITICAL:[100, 16, 240000, 300000], } temp=[0, 0, 0] temp_fail=0 thermal=ThermalUtil() fan=FanUtil() ori_duty_cycle=fan.get_fan_duty_cycle() new_duty_cycle=0 if test_temp==0: for i in range(0,3): temp[i]=thermal._get_thermal_val(i+1) if temp[i]==0 or temp[i]==None: temp_fail=1 logging.warning(\"Get temp-%d fail\", i); return False else: if test_temp_revert==0: temp_test_data=temp_test_data+2000 else: temp_test_data=temp_test_data-2000 for i in range(0,3): temp[i]=test_temp_list[i]+temp_test_data fan_fail=0 temp_val=0 for i in range(0,3): if temp[i]==None: break temp_val+=temp[i] for i in range(fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1): if fan.get_fan_status(i)==0: new_pwm=100 logging.warning('Fan_%d fail, set pwm to 100',i) if test_temp==0: fan_fail=1 fan.set_fan_duty_cycle(new_pwm) break else: fan_fail=0 ori_state=fan_policy_state fan_policy_state=self.get_state_from_fan_policy(temp_val, fan_policy) if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN: logging.error(\"Get error fan current_state\\n\"); return 0 if fan_fail==0 and ori_duty_cycle!=fan_policy[fan_policy_state][0]: new_duty_cycle=fan_policy[fan_policy_state][0]; fan.set_fan_duty_cycle(new_duty_cycle) if temp[0] >=70000: logging.critical('Alarm-Critical for temperature critical is detected, reset DUT') cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\" time.sleep(2); status, output=subprocess.getstatusoutput(cmd_str) if ori_state < LEVEL_FAN_HIGH: if fan_policy_state >=LEVEL_FAN_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if fan_policy_state < LEVEL_FAN_MID: if alarm_state==1: logging.info('Alarm for temperature high is cleared') alarm_state=0 return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv,'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv)!=5: print(\"temp test, need input three temp\") return 0 i=0 for x in range(2, 5): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) fan=FanUtil() fan.set_fan_duty_cycle(50) print(\"set default fan speed to 50%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(10) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python\n# -*- coding: utf-8 -*\n# Copyright (c) 2019 Edgecore Networks Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n# THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR\n# CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT\n# LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS\n# FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.\n#\n# See the Apache Version 2.0 License for specific language governing\n# permissions and limitations under the License.\n# \n# HISTORY:\n#    mm/dd/yyyy (A.D.)#   \n#    10/24/2019:Jostar create for as4630_54pe thermal plan\n# ------------------------------------------------------------------\n\ntry:\n    import getopt\n    import sys\n    import logging\n    import logging.config\n    import logging.handlers\n    import time\n    import subprocess\n    from as4630_54pe.fanutil import FanUtil\n    from as4630_54pe.thermalutil import ThermalUtil\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as4630_54pe_monitor'\n\nglobal log_file\nglobal log_level\n\n \n\n\n\n# Temperature Policy\n# If any fan fail , please set fan speed register to 16\n# The max value of fan speed register is 14\n#  LM77(48)+LM75(4B)+LM75(4A)  >  140, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  >  150, Set 12\n#  LM77(48)+LM75(4B)+LM75(4A)  >  160, Set 14\n#  LM77(48)+LM75(4B)+LM75(4A)  <  140, Set 8\n#  LM77(48)+LM75(4B)+LM75(4A)  <  150, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  <  160, Set 12\n#  Reset DUT:LM77(48)>=70C\n#\nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n \n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n     \n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args: # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\nfan_policy_state=0\nfan_fail=0\nalarm_state = 0 #0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0, 0]\ntemp_test_data=0\ntest_temp_revert=0\n# Make a class we can use to capture stdout and sterr in the log\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm=0\n    ori_pwm = 0\n    default_pwm=0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format= '[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = handler = logging.handlers.SysLogHandler(address = '/dev/log')\n        sys_handler.setLevel(logging.WARNING)       \n        logging.getLogger('').addHandler(sys_handler)\n          \n    def get_state_from_fan_policy(self, temp, policy):\n        state=0\n        for i in range(0, len(policy)):\n            if (temp > policy[i][2]): #temp_down\n                if temp <= policy[i][3]: #temp_up\n                    state =i\n                            \n        return state\n\n    def manage_fans(self):\n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list        \n        global alarm_state\n        global temp_test_data  \n        global test_temp_revert      \n        LEVEL_FAN_MIN=0\n        LEVEL_FAN_NORMAL=1   \n        LEVEL_FAN_MID=2\n        LEVEL_FAN_HIGH=3\n        LEVEL_TEMP_CRITICAL=4\n        fan_policy = {\n           LEVEL_FAN_MIN:       [50,   8, 0,      140000],\n           LEVEL_FAN_NORMAL:    [62,  10, 140000, 150000],\n           LEVEL_FAN_MID:       [75,  12, 150000, 160000],\n           LEVEL_FAN_HIGH:      [88,  14, 160000, 240000],\n           LEVEL_TEMP_CRITICAL: [100, 16, 240000, 300000],\n        }\n        temp = [0, 0 , 0]\n        temp_fail=0\n        thermal = ThermalUtil()\n        fan = FanUtil()\n        ori_duty_cycle=fan.get_fan_duty_cycle()\n        new_duty_cycle=0\n        \n        if test_temp==0:\n            for i in range(0,3):\n                temp[i]=thermal._get_thermal_val(i+1)\n                if temp[i]==0 or temp[i]==None:\n                    temp_fail=1\n                    logging.warning(\"Get temp-%d fail\", i);\n                    return False\n        else:\n            if test_temp_revert==0:\n                temp_test_data=temp_test_data+2000\n            else:            \n                temp_test_data=temp_test_data-2000\n                \n            for i in range(0,3):\n                temp[i]=test_temp_list[i]+temp_test_data\n            fan_fail=0\n\n        temp_val=0 \n        for i in range(0,3):\n            if temp[i]==None:\n                break\n            temp_val+=temp[i]\n        \n        #Check Fan status\n        for i in range (fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1):\n            if fan.get_fan_status(i)==0:\n                new_pwm=100\n                logging.warning('Fan_%d fail, set pwm to 100',i)                \n                if test_temp==0:\n                    fan_fail=1\n                    fan.set_fan_duty_cycle(new_pwm)\n                    break\n            else:\n                fan_fail=0\n        \n        ori_state=fan_policy_state        \n        fan_policy_state=self.get_state_from_fan_policy(temp_val, fan_policy)\n        \n        if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN:\n            logging.error(\"Get error fan current_state\\n\");\n            return 0\n    \n        #Decision : Decide new fan pwm percent.\n        if fan_fail==0 and ori_duty_cycle!=fan_policy[fan_policy_state][0]:\n            new_duty_cycle = fan_policy[fan_policy_state][0];\n            fan.set_fan_duty_cycle(new_duty_cycle)\n\n        if temp[0] >= 70000: #LM75-48    \n            #critical case*/\n            logging.critical('Alarm-Critical for temperature critical is detected, reset DUT')\n            cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\"\n            time.sleep(2);\n            status, output = subprocess.getstatusoutput(cmd_str)\n                \n        #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_state, fan_policy_state, temp_val)\n        \n        if ori_state < LEVEL_FAN_HIGH:            \n           if fan_policy_state >= LEVEL_FAN_HIGH:\n               if alarm_state==0:\n                   logging.warning('Alarm for temperature high is detected')\n                   alarm_state=1\n                  \n        if fan_policy_state < LEVEL_FAN_MID:\n            if alarm_state==1:\n                logging.info('Alarm for temperature high is cleared')\n                alarm_state=0\n                \n        return True\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv,'hdlt:',['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg            \n        \n        if sys.argv[1]== '-t':\n            if len(sys.argv)!=5:\n                print(\"temp test, need input three temp\")\n                return 0\n            \n            i=0\n            for x in range(2, 5):\n               test_temp_list[i]= int(sys.argv[x])*1000\n               i=i+1\n            test_temp = 1   \n            log_level = logging.DEBUG\n            print(test_temp_list)                       \n    \n    fan = FanUtil()\n    fan.set_fan_duty_cycle(50)\n    print(\"set default fan speed to 50%\")\n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(10) #10sec\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n\n"}, "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py": {"changes": [{"diff": "\n             # Critical: Either all the fans are faulty or they are removed, shutdown the system\n             logging.critical('Alarm for all fan faulty/absent is detected')\n             logging.critical(\"Alarm for all fan faulty/absent is detected, reset DUT\")\n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2)\n-            subprocess.getstatusoutput('sync; sync; sync')\n-            subprocess.getstatusoutput(cmd_str)\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell(cmd_str)\n         elif sum(fan_fail_list) != 0:\n             # Set the 100% speed only for first fan failure detection\n             logging.warning('Fan_{} failed, set remaining fan speed to 100%'.format(\n", "add": 5, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py", "badparts": ["            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"", "            subprocess.getstatusoutput('sync; sync; sync')", "            subprocess.getstatusoutput(cmd_str)"], "goodparts": ["            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell(cmd_str)"]}, {"diff": "\n             as4630_54pe_set_fan_speed(new_duty_cycle)\n             if test_temp == 1:\n                 time.sleep(3)\n-                status, output = subprocess.getstatusoutput('pddf_fanutil getspeed')\n+                status, output = getstatusoutput_noshell(['pddf_fanutil', 'getspeed'])\n                 logging.debug('\\n%s\\n', output)\n \n         if temp[0] >= 70000:  # LM77-48\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py", "badparts": ["                status, output = subprocess.getstatusoutput('pddf_fanutil getspeed')"], "goodparts": ["                status, output = getstatusoutput_noshell(['pddf_fanutil', 'getspeed'])"]}, {"diff": "\n             if status:\n                 logging.warning('Reboot cause file not updated. {}'.format(output))\n \n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n-            subprocess.getstatusoutput('sync; sync; sync')\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n             time.sleep(3)\n-            subprocess.getstatusoutput(cmd_str)\n+            getstatusoutput_noshell(cmd_str)\n \n         logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n', ori_state", "add": 5, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py", "badparts": ["            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"", "            subprocess.getstatusoutput('sync; sync; sync')", "            subprocess.getstatusoutput(cmd_str)"], "goodparts": ["            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell(cmd_str)"]}], "source": "\n try: import os import sys import getopt import subprocess import logging import logging.handlers import time from sonic_platform import platform except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as4630_54pe_pddf_monitor' class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False def as4630_54pe_set_fan_speed(pwm): if pwm < 0 or pwm > 100: print(\"Error: Wrong duty cycle value %d\" %(pwm)) platform_chassis.get_fan(0).set_speed(pwm) platform_chassis.get_fan(2).set_speed(pwm) return 0 fan_policy_state=0 fan_fail=0 fan_fail_list=[0, 0, 0] alarm_state=0 test_temp=0 simulate_temp_decline=0 test_temp_list=[0, 0, 0] temp_test_data=0 test_temp_revert=0 platform_chassis=None class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(asctime)-15s %(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 for i in range(0, len(policy)): if(temp > policy[i][2]): if temp <=policy[i][3]: state=i return state def manage_fans(self): global fan_policy_state global fan_fail global fan_fail_list global test_temp global simulate_temp_decline global test_temp_list global alarm_state global temp_test_data global test_temp_revert global platform_chassis NUM_FANS=3 LEVEL_FAN_MIN=0 LEVEL_FAN_NORMAL=1 LEVEL_FAN_MID=2 LEVEL_FAN_HIGH=3 LEVEL_TEMP_CRITICAL=4 fan_policy={ LEVEL_FAN_MIN: [50, 8, 0, 140000], LEVEL_FAN_NORMAL: [62, 10, 140000, 150000], LEVEL_FAN_MID: [75, 12, 150000, 160000], LEVEL_FAN_HIGH: [88, 14, 160000, 240000], LEVEL_TEMP_CRITICAL:[100, 16, 240000, 300000], } temp=[0, 0, 0] ori_duty_cycle=platform_chassis.get_fan(0).get_speed() new_duty_cycle=0 if test_temp==0: for i in range(0, 3): temp[i]=platform_chassis.get_thermal(i).get_temperature() if temp[i]==0.0 or temp[i] is None: logging.warning(\"Get temp-%d fail\", i) return False temp[i]=int(temp[i]*1000) else: if test_temp_revert==0: temp_test_data=temp_test_data+2000 else: if temp_test_data > 0: temp_test_data=temp_test_data-2000 else: sys.exit('Simulation Ends !') for i in range(0, 3): temp[i]=test_temp_list[i]+temp_test_data fan_fail=0 temp_val=0 for i in range(0, 3): if temp[i] is None: break temp_val +=temp[i] for i in range(NUM_FANS): if not platform_chassis.get_fan(i).get_status(): if test_temp==0: fan_fail=1 if fan_fail_list[i]==0: fan_fail_list[i]=1 else: if fan_fail_list[i]==1: fan_fail_list[i]=0 if sum(fan_fail_list)==NUM_FANS: logging.critical('Alarm for all fan faulty/absent is detected') logging.critical(\"Alarm for all fan faulty/absent is detected, reset DUT\") cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\" time.sleep(2) subprocess.getstatusoutput('sync; sync; sync') subprocess.getstatusoutput(cmd_str) elif sum(fan_fail_list) !=0: logging.warning('Fan_{} failed, set remaining fan speed to 100%'.format( ' Fan_'.join(str(item+1) for item, val in enumerate(fan_fail_list) if val==1))) new_pwm=100 as4630_54pe_set_fan_speed(new_pwm) else: fan_fail=0 ori_state=fan_policy_state fan_policy_state=self.get_state_from_fan_policy(temp_val, fan_policy) if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN: logging.error(\"Get error fan current_state\\n\") return 0 if fan_fail==0 and ori_duty_cycle !=fan_policy[fan_policy_state][0]: new_duty_cycle=fan_policy[fan_policy_state][0] as4630_54pe_set_fan_speed(new_duty_cycle) if test_temp==1: time.sleep(3) status, output=subprocess.getstatusoutput('pddf_fanutil getspeed') logging.debug('\\n%s\\n', output) if temp[0] >=70000: logging.critical('Alarm for temperature critical is detected') logging.critical(\"Alarm-Critical for temperature critical is detected, reset DUT\") status, output=subprocess.getstatusoutput( 'echo \"Thermal Overload: Other\" > /host/reboot-cause/reboot-cause.txt') status, output=subprocess.getstatusoutput( 'echo \"System rebooted because alarm for critical temperature(70 C) is detected[Time: $(eval date)]\" >> /host/reboot-cause/reboot-cause.txt') if status: logging.warning('Reboot cause file not updated.{}'.format(output)) cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\" subprocess.getstatusoutput('sync; sync; sync') time.sleep(3) subprocess.getstatusoutput(cmd_str) logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n', ori_state, fan_policy_state, temp_val) if ori_state < LEVEL_FAN_HIGH: if fan_policy_state >=LEVEL_FAN_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if simulate_temp_decline==1: logging.info('Temperature decline simulation is ON. Testing temperature will decrease now') test_temp_revert=1 if fan_policy_state < LEVEL_FAN_MID: if alarm_state==1: logging.warning('Alarm for temperature high is cleared') alarm_state=0 return True def main(argv): if not os.path.exists('/usr/share/sonic/platform/pddf_support'): print(\"PDDF mode is not enabled\") return 0 log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp global simulate_temp_decline if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv, 'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv) !=6: print(\"temp test, need input temp decline option and three temp values\") return 0 i=0 simulate_temp_decline=int(sys.argv[2]) for x in range(3, 6): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) global platform_chassis platform_chassis=platform.Platform().get_chassis() as4630_54pe_set_fan_speed(50) monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(10) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*\n# Copyright (c) 2019 Edgecore Networks Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n# THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR\n# CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT\n# LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS\n# FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.\n#\n# See the Apache Version 2.0 License for specific language governing\n# permissions and limitations under the License.\n#\n# HISTORY:\n#    mm/dd/yyyy (A.D.)#\n#    10/24/2019:Jostar create for as4630_54pe thermal plan\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import sys\n    import getopt\n    import subprocess\n    import logging\n    import logging.handlers\n    import time\n    from sonic_platform import platform\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as4630_54pe_pddf_monitor'\n\n\n\n\n\n# Temperature Policy\n# If any fan fail , please set fan speed register to 16\n# The max value of fan speed register is 14\n#  LM77(48)+LM75(4B)+LM75(4A)  >  140, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  >  150, Set 12\n#  LM77(48)+LM75(4B)+LM75(4A)  >  160, Set 14\n#  LM77(48)+LM75(4B)+LM75(4A)  <  140, Set 8\n#  LM77(48)+LM75(4B)+LM75(4A)  <  150, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  <  160, Set 12\n#  Reset DUT:LM77(48)>=70C\n#\nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n\n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n\n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args:  # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\n\ndef as4630_54pe_set_fan_speed(pwm):\n    # This platform has 2 fans controlled by one register on CPLD and 3rd fan by another register\n    # Hence, we need to change the speed for all\n    if pwm < 0 or pwm > 100:\n        print(\"Error: Wrong duty cycle value %d\" % (pwm))\n    platform_chassis.get_fan(0).set_speed(pwm)\n    platform_chassis.get_fan(2).set_speed(pwm)\n   \n    return 0\n\n\nfan_policy_state = 0\nfan_fail = 0\nfan_fail_list = [0, 0, 0]\nalarm_state = 0  # 0->default or clear, 1-->alarm detect\ntest_temp = 0\nsimulate_temp_decline = 0\ntest_temp_list = [0, 0, 0]\ntemp_test_data = 0\ntest_temp_revert = 0\nplatform_chassis = None\n# Make a class we can use to capture stdout and sterr in the log\n\n\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm = 0\n    ori_pwm = 0\n    default_pwm = 0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format='[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(asctime)-15s %(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = logging.handlers.SysLogHandler(address='/dev/log')\n        sys_handler.setLevel(logging.WARNING)\n        logging.getLogger('').addHandler(sys_handler)\n\n    def get_state_from_fan_policy(self, temp, policy):\n        state = 0\n        for i in range(0, len(policy)):\n            if (temp > policy[i][2]):  # temp_down\n                if temp <= policy[i][3]:  # temp_up\n                    state = i\n\n        return state\n\n    def manage_fans(self):\n        global fan_policy_state\n        global fan_fail\n        global fan_fail_list\n        global test_temp\n        global simulate_temp_decline\n        global test_temp_list\n        global alarm_state\n        global temp_test_data\n        global test_temp_revert\n        global platform_chassis\n        NUM_FANS = 3\n        LEVEL_FAN_MIN = 0\n        LEVEL_FAN_NORMAL = 1\n        LEVEL_FAN_MID = 2\n        LEVEL_FAN_HIGH = 3\n        LEVEL_TEMP_CRITICAL = 4\n        fan_policy = {\n            LEVEL_FAN_MIN:       [50,   8, 0,      140000],\n            LEVEL_FAN_NORMAL:    [62,  10, 140000, 150000],\n            LEVEL_FAN_MID:       [75,  12, 150000, 160000],\n            LEVEL_FAN_HIGH:      [88,  14, 160000, 240000],\n            LEVEL_TEMP_CRITICAL: [100, 16, 240000, 300000],\n        }\n        temp = [0, 0, 0]\n        \n        #thermal = ThermalUtil()\n        #fan = FanUtil()\n        # Supposedly all the fans are set with same duty cycle\n        ori_duty_cycle = platform_chassis.get_fan(0).get_speed()\n        new_duty_cycle = 0\n\n        if test_temp == 0:\n            for i in range(0, 3):\n                temp[i] = platform_chassis.get_thermal(i).get_temperature()\n                if temp[i] == 0.0 or temp[i] is None:\n                    \n                    logging.warning(\"Get temp-%d fail\", i)\n                    return False\n                temp[i] = int(temp[i]*1000)\n        else:\n            if test_temp_revert == 0:\n                temp_test_data = temp_test_data+2000\n            else:\n                if temp_test_data > 0:\n                    temp_test_data = temp_test_data-2000\n                else:\n                    # Stop the simulation\n                    sys.exit('Simulation Ends !')\n\n            for i in range(0, 3):\n                temp[i] = test_temp_list[i]+temp_test_data\n            fan_fail = 0\n\n        temp_val = 0\n        for i in range(0, 3):\n            if temp[i] is None:\n                break\n            temp_val += temp[i]\n\n        # Check Fan status\n        for i in range(NUM_FANS):\n            if not platform_chassis.get_fan(i).get_status():\n                if test_temp == 0:\n                    fan_fail = 1\n                    if fan_fail_list[i] == 0:\n                        fan_fail_list[i] = 1\n            else:\n                if fan_fail_list[i] == 1:\n                    fan_fail_list[i] = 0\n\n        if sum(fan_fail_list) == NUM_FANS:\n            # Critical: Either all the fans are faulty or they are removed, shutdown the system\n            logging.critical('Alarm for all fan faulty/absent is detected')\n            logging.critical(\"Alarm for all fan faulty/absent is detected, reset DUT\")\n            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n            time.sleep(2)\n            subprocess.getstatusoutput('sync; sync; sync')\n            subprocess.getstatusoutput(cmd_str)\n        elif sum(fan_fail_list) != 0:\n            # Set the 100% speed only for first fan failure detection\n            logging.warning('Fan_{} failed, set remaining fan speed to 100%'.format(\n                ' Fan_'.join(str(item+1) for item, val in enumerate(fan_fail_list) if val == 1)))\n            new_pwm = 100\n            as4630_54pe_set_fan_speed(new_pwm)\n        else:\n            fan_fail = 0\n\n        ori_state = fan_policy_state\n        fan_policy_state = self.get_state_from_fan_policy(temp_val, fan_policy)\n\n        if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN:\n            logging.error(\"Get error fan current_state\\n\")\n            return 0\n\n        # Decision : Decide new fan pwm percent.\n        if fan_fail == 0 and ori_duty_cycle != fan_policy[fan_policy_state][0]:\n            new_duty_cycle = fan_policy[fan_policy_state][0]\n            as4630_54pe_set_fan_speed(new_duty_cycle)\n            if test_temp == 1:\n                time.sleep(3)\n                status, output = subprocess.getstatusoutput('pddf_fanutil getspeed')\n                logging.debug('\\n%s\\n', output)\n\n        if temp[0] >= 70000:  # LM77-48\n            # critical case*/\n            logging.critical('Alarm for temperature critical is detected')\n            logging.critical(\"Alarm-Critical for temperature critical is detected, reset DUT\")\n            # Update the reboot cause file to reflect that critical temperature\n            # has been crossed. Upon next boot, the contents of this file will\n            # be used to determine the cause of the previous reboot\n            status, output = subprocess.getstatusoutput(\n                'echo \"Thermal Overload: Other\" > /host/reboot-cause/reboot-cause.txt')\n            status, output = subprocess.getstatusoutput(\n                'echo \"System rebooted because alarm for critical temperature (70 C) is detected [Time: $(eval date)]\" >> /host/reboot-cause/reboot-cause.txt')\n            if status:\n                logging.warning('Reboot cause file not updated. {}'.format(output))\n\n            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n            subprocess.getstatusoutput('sync; sync; sync')\n            time.sleep(3)\n            subprocess.getstatusoutput(cmd_str)\n\n        logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n', ori_state, fan_policy_state, temp_val)\n\n        if ori_state < LEVEL_FAN_HIGH:\n            if fan_policy_state >= LEVEL_FAN_HIGH:\n                if alarm_state == 0:\n                    logging.warning('Alarm for temperature high is detected')\n                    alarm_state = 1\n                    # Add a mechanism to decrease the test_temp values\n                    if simulate_temp_decline == 1:\n                        logging.info('Temperature decline simulation is ON. Testing temperature will decrease now')\n                        test_temp_revert = 1\n\n        if fan_policy_state < LEVEL_FAN_MID:\n            if alarm_state == 1:\n                logging.warning('Alarm for temperature high is cleared')\n                alarm_state = 0\n\n        return True\n\n\ndef main(argv):\n    # Check if PDDF mode is enabled\n    if not os.path.exists('/usr/share/sonic/platform/pddf_support'):\n        print(\"PDDF mode is not enabled\")\n        return 0\n\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    global simulate_temp_decline\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv, 'hdlt:', ['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg\n\n        if sys.argv[1] == '-t':\n            if len(sys.argv) != 6:\n                print(\"temp test, need input temp decline option and three temp values\")\n                return 0\n\n            i = 0\n            simulate_temp_decline = int(sys.argv[2])\n            for x in range(3, 6):\n                test_temp_list[i] = int(sys.argv[x])*1000\n                i = i+1\n            test_temp = 1\n            log_level = logging.DEBUG\n            print(test_temp_list)\n\n    global platform_chassis\n    platform_chassis = platform.Platform().get_chassis()\n\n    as4630_54pe_set_fan_speed(50)\n    \n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(10)  # 10sec\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n"}, "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import commands\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"clean\"])\n     if status:\n-        print \"accton_as4630_54pe_util.py clean command failed %d\"%status\n+        print(\"accton_as4630_54pe_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Stop pddf-platform-init.service along with other platform serives failed %d\"%status\n+        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status\n+        print(\"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status)\n         return False\n \n     return True\n     \n def start_platform_svc():\n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"install\"])\n     if status:\n-        print \"accton_as4630_54pe_util.py install  command failed %d\"%status\n+        print(\"accton_as4630_54pe_util.py install  command failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n \n     return True\n \n def start_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Start pddf-platform-init.service failed %d\"%status\n+        print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n+        print(\"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status)\n         return False\n     \n     return True\n \n def stop_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Stop pddf-platform-init.service failed %d\"%status\n+        print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n+        print(\"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status)\n        ", "add": 41, "remove": 41, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py", "badparts": ["import commands", "    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-fan.service\")", "        print \"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-fan.service\")", "        print \"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-psu.service\")", "        print \"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-psu.service\")", "        print \"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor.service\")", "        print \"Disable as4630-54pe-platform-monitor.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor.service\")", "        print \"Stop as4630-54pe-platform-monitor.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py clean\")", "        print \"accton_as4630_54pe_util.py clean command failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")", "        print \"Stop pddf-platform-init.service along with other platform serives failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")", "        print \"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status", "    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py install\")", "        print \"accton_as4630_54pe_util.py install  command failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-fan.service\")", "        print \"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-fan.service\")", "        print \"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-psu.service\")", "        print \"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-psu.service\")", "        print \"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor.service\")", "        print \"Enable as4630-54pe-platform-monitor.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor.service\")", "        print \"Start as4630-54pe-platform-monitor.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")", "        print \"Start pddf-platform-init.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-pddf-platform-monitor.service\")", "        print \"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")", "        print \"Stop pddf-platform-init.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")", "        print \"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-fan.service\"])", "        print(\"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-fan.service\"])", "        print(\"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-psu.service\"])", "        print(\"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-psu.service\"])", "        print(\"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor.service\"])", "        print(\"Disable as4630-54pe-platform-monitor.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor.service\"])", "        print(\"Stop as4630-54pe-platform-monitor.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"clean\"])", "        print(\"accton_as4630_54pe_util.py clean command failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])", "        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])", "        print(\"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"install\"])", "        print(\"accton_as4630_54pe_util.py install  command failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-fan.service\"])", "        print(\"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-fan.service\"])", "        print(\"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-psu.service\"])", "        print(\"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-psu.service\"])", "        print(\"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor.service\"])", "        print(\"Enable as4630-54pe-platform-monitor.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor.service\"])", "        print(\"Start as4630-54pe-platform-monitor.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])", "        print(\"Start pddf-platform-init.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-pddf-platform-monitor.service\"])", "        print(\"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])", "        print(\"Stop pddf-platform-init.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])", "        print(\"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status)"]}], "source": "\n import commands def check_pddf_support(): return True def stop_platform_svc(): status, output=commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-fan.service\") if status: print \"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-fan.service\") if status: print \"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-psu.service\") if status: print \"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-psu.service\") if status: print \"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor.service\") if status: print \"Disable as4630-54pe-platform-monitor.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor.service\") if status: print \"Stop as4630-54pe-platform-monitor.service failed %d\"%status return False status, output=commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py clean\") if status: print \"accton_as4630_54pe_util.py clean command failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print \"Stop pddf-platform-init.service along with other platform serives failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\") if status: print \"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status return False return True def start_platform_svc(): status, output=commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py install\") if status: print \"accton_as4630_54pe_util.py install command failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-fan.service\") if status: print \"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-fan.service\") if status: print \"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-psu.service\") if status: print \"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-psu.service\") if status: print \"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor.service\") if status: print \"Enable as4630-54pe-platform-monitor.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor.service\") if status: print \"Start as4630-54pe-platform-monitor.service failed %d\"%status return False return True def start_platform_pddf(): status, output=commands.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print \"Start pddf-platform-init.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl start as4630-54pe-pddf-platform-monitor.service\") if status: print \"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status return False return True def stop_platform_pddf(): status, output=commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print \"Stop pddf-platform-init.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\") if status: print \"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status return False return True def main(): pass if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services. \n# This will be used while switching the pddf->non-pddf mode and vice versa\n\nimport commands\n\ndef check_pddf_support():\n    return True\n\ndef stop_platform_svc():\n    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-fan.service\")\n    if status:\n        print \"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-fan.service\")\n    if status:\n        print \"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status\n        return False\n\n    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-psu.service\")\n    if status:\n        print \"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-psu.service\")\n    if status:\n        print \"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status\n        return False\n    \n    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor.service\")\n    if status:\n        print \"Disable as4630-54pe-platform-monitor.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor.service\")\n    if status:\n        print \"Stop as4630-54pe-platform-monitor.service failed %d\"%status\n        return False\n\n    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py clean\")\n    if status:\n        print \"accton_as4630_54pe_util.py clean command failed %d\"%status\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print \"Stop pddf-platform-init.service along with other platform serives failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n    if status:\n        print \"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status\n        return False\n\n    return True\n    \ndef start_platform_svc():\n    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py install\")\n    if status:\n        print \"accton_as4630_54pe_util.py install  command failed %d\"%status\n        return False\n\n    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-fan.service\")\n    if status:\n        print \"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-fan.service\")\n    if status:\n        print \"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status\n        return False\n\n    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-psu.service\")\n    if status:\n        print \"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-psu.service\")\n    if status:\n        print \"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status\n        return False\n\n    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor.service\")\n    if status:\n        print \"Enable as4630-54pe-platform-monitor.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor.service\")\n    if status:\n        print \"Start as4630-54pe-platform-monitor.service failed %d\"%status\n        return False\n\n    return True\n\ndef start_platform_pddf():\n    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print \"Start pddf-platform-init.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-pddf-platform-monitor.service\")\n    if status:\n        print \"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n        return False\n    \n    return True\n\ndef stop_platform_pddf():\n    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print \"Stop pddf-platform-init.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n    if status:\n        print \"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n        return False\n\n    return True\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py": {"changes": [{"diff": "\n             # critical case*/\n             logging.critical(\n                 'Alarm-Critical for temperature critical is detected, reset DUT')\n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2)\n-            return_value = os.system(cmd_str)\n+            return_value = subprocess.call(cmd_str)\n             logging.warning('Fan set: i2cset -y -f 3 0x60 0x4 0xE4, status is %d', return_value)\n \n         #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_s", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py", "badparts": ["            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"", "            return_value = os.system(cmd_str)"], "goodparts": ["            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]", "            return_value = subprocess.call(cmd_str)"]}], "source": "\n try: import os import sys import getopt import logging import logging.config import logging.handlers import time from as4630_54te.fanutil import FanUtil from as4630_54te.thermalutil import ThermalUtil except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as4630_54te_monitor' class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False fan_policy_state=0 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0, 0] temp_test_data=0 test_temp_revert=0 class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S') if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter( '%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=logging.handlers.SysLogHandler( address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 for i in range(0, len(policy)): if(temp > policy[i][2]): if temp <=policy[i][3]: state=i return state def manage_fans(self): global fan_policy_state global fan_fail global test_temp global test_temp_list global alarm_state global temp_test_data global test_temp_revert LEVEL_FAN_MIN=0 LEVEL_FAN_NORMAL=1 LEVEL_FAN_MID=2 LEVEL_FAN_HIGH=3 LEVEL_TEMP_CRITICAL=4 fan_policy={ LEVEL_FAN_MIN:[50, 8, 0, 140000], LEVEL_FAN_NORMAL:[62, 10, 140000, 150000], LEVEL_FAN_MID:[75, 12, 150000, 160000], LEVEL_FAN_HIGH:[88, 14, 160000, 240000], LEVEL_TEMP_CRITICAL:[100, 16, 240000, 300000], } temp=[0, 0, 0] thermal=ThermalUtil() fan=FanUtil() ori_duty_cycle=fan.get_fan_duty_cycle() new_duty_cycle=0 if test_temp==0: for i in range(0, 3): temp[i]=thermal._get_thermal_val(i +1) if temp[i]==0 or temp[i] is None: logging.warning(\"Get temp-%d fail\", i) return False else: if test_temp_revert==0: temp_test_data=temp_test_data +2000 else: temp_test_data=temp_test_data -2000 for i in range(0, 3): temp[i]=test_temp_list[i] +temp_test_data fan_fail=0 temp_val=0 for i in range(0, 3): if temp[i] is None: break temp_val +=temp[i] for i in range(fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD +1): if fan.get_fan_status(i)==0: new_pwm=100 logging.warning('Fan_%d fail, set pwm to 100', i) if test_temp==0: fan_fail=1 fan.set_fan_duty_cycle(new_pwm) break else: fan_fail=0 ori_state=fan_policy_state fan_policy_state=self.get_state_from_fan_policy(temp_val, fan_policy) if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN: logging.error(\"Get error fan current_state\\n\") return 0 if fan_fail==0 and ori_duty_cycle !=fan_policy[fan_policy_state][0]: new_duty_cycle=fan_policy[fan_policy_state][0] fan.set_fan_duty_cycle(new_duty_cycle) if temp[0] >=70000: logging.critical( 'Alarm-Critical for temperature critical is detected, reset DUT') cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\" time.sleep(2) return_value=os.system(cmd_str) logging.warning('Fan set: i2cset -y -f 3 0x60 0x4 0xE4, status is %d', return_value) if ori_state < LEVEL_FAN_HIGH: if fan_policy_state >=LEVEL_FAN_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if fan_policy_state < LEVEL_FAN_MID: if alarm_state==1: logging.info('Alarm for temperature high is cleared') alarm_state=0 return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv, 'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv) !=5: print(\"temp test, need input three temp\") return 0 i=0 for x in range(2, 5): test_temp_list[i]=int(sys.argv[x]) * 1000 i=i +1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) fan=FanUtil() fan.set_fan_duty_cycle(50) print(\"set default fan speed to 50%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(10) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python\n# -*- coding: utf-8 -*\n# Copyright (c) 2019 Edgecore Networks Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n# THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR\n# CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT\n# LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS\n# FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.\n#\n# See the Apache Version 2.0 License for specific language governing\n# permissions and limitations under the License.\n#\n# HISTORY:\n#    mm/dd/yyyy (A.D.)#\n#    10/24/2019:Jostar create for as4630_54te thermal plan\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import sys\n    import getopt\n    import logging\n    import logging.config\n    import logging.handlers\n    import time\n    from as4630_54te.fanutil import FanUtil\n    from as4630_54te.thermalutil import ThermalUtil\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as4630_54te_monitor'\n\n# Temperature Policy\n# If any fan fail , please set fan speed register to 16\n# The max value of fan speed register is 14\n#  LM77(48)+LM75(4B)+LM75(4A)  >  140, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  >  150, Set 12\n#  LM77(48)+LM75(4B)+LM75(4A)  >  160, Set 14\n#  LM77(48)+LM75(4B)+LM75(4A)  <  140, Set 8\n#  LM77(48)+LM75(4B)+LM75(4A)  <  150, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  <  160, Set 12\n#  Reset DUT:LM77(48)>=70C\n#\nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n\n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n\n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args:  # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\n\nfan_policy_state = 0\nfan_fail = 0\nalarm_state = 0  # 0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0, 0]\ntemp_test_data = 0\ntest_temp_revert = 0\n# Make a class we can use to capture stdout and sterr in the log\n\n\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm = 0\n    ori_pwm = 0\n    default_pwm = 0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format='[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S')\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter(\n                '%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = logging.handlers.SysLogHandler(\n            address='/dev/log')\n        sys_handler.setLevel(logging.WARNING)\n        logging.getLogger('').addHandler(sys_handler)\n\n    def get_state_from_fan_policy(self, temp, policy):\n        state = 0\n        for i in range(0, len(policy)):\n            if (temp > policy[i][2]):  # temp_down\n                if temp <= policy[i][3]:  # temp_up\n                    state = i\n\n        return state\n\n    def manage_fans(self):\n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list\n        global alarm_state\n        global temp_test_data\n        global test_temp_revert\n        LEVEL_FAN_MIN = 0\n        LEVEL_FAN_NORMAL = 1\n        LEVEL_FAN_MID = 2\n        LEVEL_FAN_HIGH = 3\n        LEVEL_TEMP_CRITICAL = 4\n        fan_policy = {\n            LEVEL_FAN_MIN: [50, 8, 0, 140000],\n            LEVEL_FAN_NORMAL: [62, 10, 140000, 150000],\n            LEVEL_FAN_MID: [75, 12, 150000, 160000],\n            LEVEL_FAN_HIGH: [88, 14, 160000, 240000],\n            LEVEL_TEMP_CRITICAL: [100, 16, 240000, 300000],\n        }\n        temp = [0, 0, 0]\n        thermal = ThermalUtil()\n        fan = FanUtil()\n        ori_duty_cycle = fan.get_fan_duty_cycle()\n        new_duty_cycle = 0\n\n        if test_temp == 0:\n            for i in range(0, 3):\n                temp[i] = thermal._get_thermal_val(i + 1)\n                if temp[i] == 0 or temp[i] is None:\n                    logging.warning(\"Get temp-%d fail\", i)\n                    return False\n        else:\n            if test_temp_revert == 0:\n                temp_test_data = temp_test_data + 2000\n            else:\n                temp_test_data = temp_test_data - 2000\n\n            for i in range(0, 3):\n                temp[i] = test_temp_list[i] + temp_test_data\n            fan_fail = 0\n\n        temp_val = 0\n        for i in range(0, 3):\n            if temp[i] is None:\n                break\n            temp_val += temp[i]\n\n        # Check Fan status\n        for i in range(fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD + 1):\n            if fan.get_fan_status(i) == 0:\n                new_pwm = 100\n                logging.warning('Fan_%d fail, set pwm to 100', i)\n                if test_temp == 0:\n                    fan_fail = 1\n                    fan.set_fan_duty_cycle(new_pwm)\n                    break\n            else:\n                fan_fail = 0\n\n        ori_state = fan_policy_state\n        fan_policy_state = self.get_state_from_fan_policy(temp_val, fan_policy)\n\n        if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN:\n            logging.error(\"Get error fan current_state\\n\")\n            return 0\n\n        # Decision : Decide new fan pwm percent.\n        if fan_fail == 0 and ori_duty_cycle != fan_policy[fan_policy_state][0]:\n            new_duty_cycle = fan_policy[fan_policy_state][0]\n            fan.set_fan_duty_cycle(new_duty_cycle)\n\n        if temp[0] >= 70000:  # LM75-48\n            # critical case*/\n            logging.critical(\n                'Alarm-Critical for temperature critical is detected, reset DUT')\n            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n            time.sleep(2)\n            return_value = os.system(cmd_str)\n            logging.warning('Fan set: i2cset -y -f 3 0x60 0x4 0xE4, status is %d', return_value)\n\n        #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_state, fan_policy_state, temp_val)\n\n        if ori_state < LEVEL_FAN_HIGH:\n            if fan_policy_state >= LEVEL_FAN_HIGH:\n                if alarm_state == 0:\n                    logging.warning('Alarm for temperature high is detected')\n                    alarm_state = 1\n\n        if fan_policy_state < LEVEL_FAN_MID:\n            if alarm_state == 1:\n                logging.info('Alarm for temperature high is cleared')\n                alarm_state = 0\n\n        return True\n\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv, 'hdlt:', ['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg\n\n        if sys.argv[1] == '-t':\n            if len(sys.argv) != 5:\n                print(\"temp test, need input three temp\")\n                return 0\n\n            i = 0\n            for x in range(2, 5):\n                test_temp_list[i] = int(sys.argv[x]) * 1000\n                i = i + 1\n            test_temp = 1\n            log_level = logging.DEBUG\n            print(test_temp_list)\n\n    fan = FanUtil()\n    fan.set_fan_duty_cycle(50)\n    print(\"set default fan speed to 50%\")\n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(10)  # 10sec\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py": {"changes": [{"diff": "\n # ------------------------------------------------------------------\n \n try:\n-    import time\n     import logging\n-    from collections import namedtuple\n-    import subprocess\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n", "add": 1, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py", "badparts": ["    import time", "    from collections import namedtuple", "    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         return \"fan{0}_{1}\".format(fan_num, self.node_postfix[node_num-1])\n     \n     def _get_fan_i2c_bus_addr(self):\n-        cmd_template = 'i2cget -f -y {} 0x{} 0'\n+        cmd_template = ['i2cget', '-f', '-y', '', '', '0']\n         for bus_no, dev_addr in self.I2CADDR_CANDIDATES:\n-            cmd = cmd_template.format(bus_no, dev_addr)\n-            if subprocess.getstatusoutput(cmd)[0] == 0:\n+            cmd_template[3] = str(bus_no)\n+            cmd_template[4] = '0x' + str(dev_addr)\n+            if getstatusoutput_noshell(cmd_template)[0] == 0:\n                 return bus_no, dev_addr\n         raise IOError('Un", "add": 4, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py", "badparts": ["        cmd_template = 'i2cget -f -y {} 0x{} 0'", "            cmd = cmd_template.format(bus_no, dev_addr)", "            if subprocess.getstatusoutput(cmd)[0] == 0:"], "goodparts": ["        cmd_template = ['i2cget', '-f', '-y', '', '', '0']", "            cmd_template[3] = str(bus_no)", "            cmd_template[4] = '0x' + str(dev_addr)", "            if getstatusoutput_noshell(cmd_template)[0] == 0:"]}], "source": "\n try: import time import logging from collections import namedtuple import subprocess except ImportError as e: raise ImportError('%s -required module not found' % str(e)) class FanUtil(object): \"\"\"Platform-specific FanUtil class\"\"\" FAN_TOTAL_NUM=5 FAN_NUM_1_IDX=1 FAN_NODE_NUM=2 FAN_FAULT_IDX=1 FAN_DIR_IDX=2 I2CADDR_CANDIDATES=((9, 66), (50, 66)) PATH_PREFIX='/sys/bus/i2c/devices/{}-00{}/' BASE_VAL_PATH='{0}' FAN_DUTY_PATH='fan{0}_pwm' \"\"\" Dictionary where key1=fan id index(integer) starting from 1 key2=fan node index(interger) starting from 1 value=path to fan device file(string) \"\"\" dev_paths={} node_postfix=[\"fault\", \"direction\"] def _get_fan_to_device_node(self, fan_num, node_num): return \"fan{0}_{1}\".format(fan_num, self.node_postfix[node_num-1]) def _get_fan_i2c_bus_addr(self): cmd_template='i2cget -f -y{} 0x{} 0' for bus_no, dev_addr in self.I2CADDR_CANDIDATES: cmd=cmd_template.format(bus_no, dev_addr) if subprocess.getstatusoutput(cmd)[0]==0: return bus_no, dev_addr raise IOError('Unable to reach fan CPLD via I2C') def _init_fnode_basepath(self): '''format BASE_VAL_PATH and FAN_DUTY_PATH ''' bus, addr=self._get_fan_i2c_bus_addr() self.PATH_PREFIX=self.PATH_PREFIX.format(bus, addr) self.BASE_VAL_PATH=self.PATH_PREFIX +self.BASE_VAL_PATH self.FAN_DUTY_PATH=self.PATH_PREFIX +self.FAN_DUTY_PATH def _get_fan_node_val(self, fan_num, node_num): if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM: self.logger.debug('GET. Parameter error. fan_num:%d', fan_num) return None if node_num < self.FAN_FAULT_IDX or node_num > self.FAN_NODE_NUM: self.logger.debug('GET. Parameter error. node_num:%d', node_num) return None device_path=self.get_fan_to_device_path(fan_num, node_num) try: val_file=open(device_path, 'r') except IOError as e: self.logger.error('GET. unable to open file: %s', str(e)) return None content=val_file.readline().rstrip() if content=='': self.logger.debug('GET. content is NULL. device_path:%s', device_path) return None try: val_file.close() except: self.logger.debug('GET. unable to close file. device_path:%s', device_path) return None return int(content) def _set_fan_node_val(self, fan_num, node_num, val): if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM: self.logger.debug('GET. Parameter error. fan_num:%d', fan_num) return None if node_num < self.FAN_FAULT_IDX or node_num > self.FAN_NODE_NUM: self.logger.debug('GET. Parameter error. node_num:%d', node_num) return None content=str(val) if content=='': self.logger.debug('GET. content is NULL. device_path:%s', device_path) return None device_path=self.get_fan_to_device_path(fan_num, node_num) try: val_file=open(device_path, 'w') except IOError as e: self.logger.error('GET. unable to open file: %s', str(e)) return None val_file.write(content) try: val_file.close() except: self.logger.debug('GET. unable to close file. device_path:%s', device_path) return None return True logger=logging.getLogger(__name__) def __init__(self, log_level=logging.DEBUG): ch=logging.StreamHandler() ch.setLevel(log_level) self.logger.addHandler(ch) self._init_fnode_basepath() fan_path=self.BASE_VAL_PATH for fan_num in range(self.FAN_NUM_1_IDX, self.FAN_TOTAL_NUM+1): for node_num in range(1, self.FAN_NODE_NUM+1): node=self._get_fan_to_device_node(fan_num, node_num) self.dev_paths[(fan_num, node_num)]=fan_path.format(node) def get_num_fans(self): return self.FAN_TOTAL_NUM def get_idx_fan_start(self): return self.FAN_NUM_1_IDX def get_num_nodes(self): return self.FAN_NODE_NUM def get_idx_node_start(self): return self.FAN_FAULT_IDX def get_size_node_map(self): return len(self.dev_paths) def get_size_path_map(self): return len(self.dev_paths) def get_fan_to_device_path(self, fan_num, node_num): return self.dev_paths[(fan_num, node_num)] def get_fan_fault(self, fan_num): return self._get_fan_node_val(fan_num, self.FAN_FAULT_IDX) def get_fan_dir(self, fan_num): return self._get_fan_node_val(fan_num, self.FAN_DIR_IDX) def get_fan_duty_cycle(self): try: val_file=open(self.FAN_DUTY_PATH.format(1)) except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False content=val_file.readline().rstrip() val_file.close() return int(content) def set_fan_duty_cycle(self, val): for fan_num in range(1, self.FAN_TOTAL_NUM+1): try: fan_file=open(self.FAN_DUTY_PATH.format(fan_num), 'r+') except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False fan_file.write(str(val)) fan_file.close() return True def get_fan_status(self, fan_num): if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM: self.logger.debug('GET. Parameter error. fan_num, %d', fan_num) return None if self.get_fan_fault(fan_num) is not None and self.get_fan_fault(fan_num) > 0: self.logger.debug('GET. FAN fault. fan_num, %d', fan_num) return False return True ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2017 Accton Technology Corporation\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    mm/dd/yyyy (A.D.)\n#    11/13/2017: Polly Hsu, Create\n#    1/10/2018: Jostar modify for as7716_32\n#    5/02/2019: Roy Lee modify for as7816_64x\n# ------------------------------------------------------------------\n\ntry:\n    import time\n    import logging\n    from collections import namedtuple\n    import subprocess\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n\nclass FanUtil(object):\n    \"\"\"Platform-specific FanUtil class\"\"\"\n\n    FAN_TOTAL_NUM = 5\n    FAN_NUM_1_IDX = 1\n\n    FAN_NODE_NUM = 2\n    FAN_FAULT_IDX = 1\n    #FAN_SPEED_IDX = 2\n    FAN_DIR_IDX = 2\n    #FAN_NODE_DUTY_IDX_OF_MAP = 4\n    #FANR_NODE_FAULT_IDX_OF_MAP = 5\n\n    I2CADDR_CANDIDATES = ((9, 66), # for R0C HW and later\n                         (50, 66)) # for R0A, R0B HW\n    PATH_PREFIX = '/sys/bus/i2c/devices/{}-00{}/'\n    BASE_VAL_PATH = '{0}'\n    FAN_DUTY_PATH = 'fan{0}_pwm'\n\n    #logfile = ''\n    #loglevel = self.logger.INFO\n\n    \"\"\" Dictionary where\n        key1 = fan id index (integer) starting from 1\n        key2 = fan node index (interger) starting from 1\n        value = path to fan device file (string) \"\"\"\n    dev_paths = {}\n    \n    node_postfix = [\"fault\", \"direction\"]\n    def _get_fan_to_device_node(self, fan_num, node_num):\n        return \"fan{0}_{1}\".format(fan_num, self.node_postfix[node_num-1])\n    \n    def _get_fan_i2c_bus_addr(self):\n        cmd_template = 'i2cget -f -y {} 0x{} 0'\n        for bus_no, dev_addr in self.I2CADDR_CANDIDATES:\n            cmd = cmd_template.format(bus_no, dev_addr)\n            if subprocess.getstatusoutput(cmd)[0] == 0:\n                return bus_no, dev_addr\n        raise IOError('Unable to reach fan CPLD via I2C')\n\n    def _init_fnode_basepath(self):\n        '''format BASE_VAL_PATH and FAN_DUTY_PATH '''\n        bus, addr = self._get_fan_i2c_bus_addr()\n        self.PATH_PREFIX = self.PATH_PREFIX.format(bus, addr)\n        self.BASE_VAL_PATH = self.PATH_PREFIX + self.BASE_VAL_PATH\n        self.FAN_DUTY_PATH = self.PATH_PREFIX + self.FAN_DUTY_PATH\n\n    def _get_fan_node_val(self, fan_num, node_num):\n        if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM:\n            self.logger.debug('GET. Parameter error. fan_num:%d', fan_num)\n            return None\n\n        if node_num < self.FAN_FAULT_IDX or node_num > self.FAN_NODE_NUM:\n            self.logger.debug('GET. Parameter error. node_num:%d', node_num)\n            return None\n\n        device_path = self.get_fan_to_device_path(fan_num, node_num)\n       \n        try:\n            val_file = open(device_path, 'r')\n        except IOError as e:\n            self.logger.error('GET. unable to open file: %s', str(e))\n            return None\n\n        content = val_file.readline().rstrip()\n        \n        if content == '':\n            self.logger.debug('GET. content is NULL. device_path:%s', device_path)\n            return None\n\n        try:\n            val_file.close()\n        except:\n            self.logger.debug('GET. unable to close file. device_path:%s', device_path)\n            return None\n\n        return int(content)\n\n    def _set_fan_node_val(self, fan_num, node_num, val):\n        if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM:\n            self.logger.debug('GET. Parameter error. fan_num:%d', fan_num)\n            return None\n\n        if node_num < self.FAN_FAULT_IDX or node_num > self.FAN_NODE_NUM:\n            self.logger.debug('GET. Parameter error. node_num:%d', node_num)\n            return None\n\n        content = str(val)\n        if content == '':\n            self.logger.debug('GET. content is NULL. device_path:%s', device_path)\n            return None\n\n        device_path = self.get_fan_to_device_path(fan_num, node_num)\n        try:\n            val_file = open(device_path, 'w')\n        except IOError as e:\n            self.logger.error('GET. unable to open file: %s', str(e))\n            return None\n\n        val_file.write(content)\n\n        try:\n            val_file.close()\n        except:\n            self.logger.debug('GET. unable to close file. device_path:%s', device_path)\n            return None\n\n        return True\n\n    logger = logging.getLogger(__name__)\n    def __init__(self, log_level=logging.DEBUG):\n        ch = logging.StreamHandler()\n        ch.setLevel(log_level)\n        self.logger.addHandler(ch)\n\n        self._init_fnode_basepath()\n        fan_path = self.BASE_VAL_PATH \n        for fan_num in range(self.FAN_NUM_1_IDX, self.FAN_TOTAL_NUM+1):\n            for node_num in range(1, self.FAN_NODE_NUM+1):\n                node = self._get_fan_to_device_node(fan_num, node_num)\n                self.dev_paths[(fan_num, node_num)] = fan_path.format(node)\n               \n    def get_num_fans(self):\n        return self.FAN_TOTAL_NUM\n\n    def get_idx_fan_start(self):\n        return self.FAN_NUM_1_IDX\n\n    def get_num_nodes(self):\n        return self.FAN_NODE_NUM\n\n    def get_idx_node_start(self):\n        return self.FAN_FAULT_IDX\n\n    def get_size_node_map(self):\n        return len(self.dev_paths)\n\n    def get_size_path_map(self):\n        return len(self.dev_paths)\n\n    def get_fan_to_device_path(self, fan_num, node_num):\n        return self.dev_paths[(fan_num, node_num)]\n\n    def get_fan_fault(self, fan_num):\n        return self._get_fan_node_val(fan_num, self.FAN_FAULT_IDX)\n\n    #def get_fan_speed(self, fan_num):\n    #    return self._get_fan_node_val(fan_num, self.FAN_SPEED_IDX)\n\n    def get_fan_dir(self, fan_num):\n        return self._get_fan_node_val(fan_num, self.FAN_DIR_IDX)\n\n    def get_fan_duty_cycle(self):\n        try:\n            val_file = open(self.FAN_DUTY_PATH.format(1))\n        except IOError as e:\n            print(\"Error: unable to open file: %s\" % str(e))          \n            return False\n\n        content = val_file.readline().rstrip()\n        val_file.close()\n        return int(content)\n\n    def set_fan_duty_cycle(self, val):\n        for fan_num in range(1, self.FAN_TOTAL_NUM+1):\n            try:\n                fan_file = open(self.FAN_DUTY_PATH.format(fan_num), 'r+')\n            except IOError as e:\n                print(\"Error: unable to open file: %s\" % str(e))          \n                return False\n            fan_file.write(str(val))\n            fan_file.close()\n        return True\n\n    def get_fan_status(self, fan_num):\n        if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM:\n            self.logger.debug('GET. Parameter error. fan_num, %d', fan_num)\n            return None\n\n        if self.get_fan_fault(fan_num) is not None and self.get_fan_fault(fan_num) > 0:\n            self.logger.debug('GET. FAN fault. fan_num, %d', fan_num)\n            return False\n\n        #if self.get_fanr_fault(fan_num) is not None and self.get_fanr_fault(fan_num) > 0:\n        #    self.logger.debug('GET. FANR fault. fan_num, %d', fan_num)\n        #   return False\n\n        return True\n\n#def main():\n#    fan = FanUtil()\n#\n#    print 'get_size_node_map : %d' % fan.get_size_node_map()\n#    print 'get_size_path_map : %d' % fan.get_size_path_map()\n#    for x in range(fan.get_idx_fan_start(), fan.get_num_fans()+1):\n#        for y in range(fan.get_idx_node_start(), fan.get_num_nodes()+1):\n#            print fan.get_fan_to_device_path(x, y)\n#\n#if __name__ == '__main__':\n#    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py": {"changes": [{"diff": "\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py", "badparts": ["               os.system('reboot')           "], "goodparts": ["               subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is clear", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}], "source": "\n try: import os import getopt import sys import logging import logging.config import logging.handlers import time from as7326_56x.fanutil import FanUtil from as7326_56x.thermalutil import ThermalUtil except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as7326_monitor' global log_file global log_level class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False fan_policy_state=1 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0, 0, 0, 0, 0] class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 logging.debug('temp=%d', temp) for i in range(0, len(policy)): if temp > policy[i][0]: if temp <=policy[i][1]: state=policy[i][2] logging.debug('temp=%d >=policy[%d][0]=%d, temp=%d < policy[%d][1]=%d', temp, i, policy[i][0], temp, i, policy[i][1]) logging.debug('fan_state=%d', state) if state==0: state=policy[0][2] logging.debug('set default state') return state def manage_fans(self): thermal_pwm_list={} LEVEL_FAN_DEF=1 LEVEL_FAN_MID=2 LEVEL_FAN_MAX=3 LEVEL_TEMP_HIGH=4 LEVEL_TEMP_CRITICAL=5 fan_policy_state_pwm_tlb={ LEVEL_FAN_DEF: [38, 0x4], LEVEL_FAN_MID: [75, 0xB], LEVEL_FAN_MAX: [100, 0xE], LEVEL_TEMP_HIGH: [100, 0xE], LEVEL_TEMP_CRITICAL: [100, 0xE], } global fan_policy_state global fan_fail global test_temp global test_temp_list global alarm_state fan_policy={ 0:[0, 39000, LEVEL_FAN_DEF], 1:[39000, 45000, LEVEL_FAN_MID], 2:[45000, 61000, LEVEL_FAN_MAX], 3:[61000, 66000, LEVEL_TEMP_HIGH], 4:[66000, 200000, LEVEL_TEMP_CRITICAL], } thermal=ThermalUtil() fan=FanUtil() ori_pwm=fan.get_fan_duty_cycle() new_pwm=0 logging.debug('test_temp=%d', test_temp) if test_temp==0: temp1=thermal._get_thermal_val(1) temp2=thermal._get_thermal_val(2) temp3=thermal._get_thermal_val(3) temp4=thermal._get_thermal_val(4) temp5=thermal._get_thermal_val(5) temp6=0 else: temp1=test_temp_list[0] temp2=test_temp_list[1] temp3=test_temp_list[2] temp4=test_temp_list[3] temp5=test_temp_list[4] temp6=0 fan_fail=0 if temp2==0: temp_get=50000 logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%') elif temp2==0: temp_get=50000 logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%') else: temp_get=(temp2 +temp4)/2 ori_state=fan_policy_state fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy) logging.debug('lm75_48=%d, lm75_49=%d, lm75_4a=%d, lm_4b=%d, cpu=%d, bcm=%d', temp1,temp2,temp3,temp4,temp5,temp6) logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state) new_pwm=fan_policy_state_pwm_tlb[fan_policy_state][0] if fan_fail==0: logging.debug('new_pwm=%d', new_pwm) if fan_fail==0: if new_pwm!=ori_pwm: fan.set_fan_duty_cycle(new_pwm) logging.info('Set fan speed from %d to %d', ori_pwm, new_pwm) for i in range(fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1): if fan.get_fan_status(i)==0: new_pwm=100 logging.debug('fan_%d fail, set pwm to 100',i) if test_temp==0: fan_fail=1 fan.set_fan_duty_cycle(new_pwm) break else: fan_fail=0 new_state=fan_policy_state if ori_state==LEVEL_FAN_DEF: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected, reboot DUT') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MID: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MAX: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if alarm_state==1: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_HIGH: if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if new_state <=LEVEL_FAN_MID: logging.warning('Alarm for temperature high is cleared') alarm_state=0 if new_state <=LEVEL_FAN_MAX: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_CRITICAL: if new_state <=LEVEL_FAN_MAX: logging.warning('Alarm for temperature critical is cleared') return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv,'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv)!=8: print(\"temp test, need input six temp\") return 0 i=0 for x in range(2, 8): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) fan=FanUtil() fan.set_fan_duty_cycle(38) print(\"set default fan speed to 37.5%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(5) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2017 Accton Technology Corporation\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    mm/dd/yyyy (A.D.)\n#    3/23/2018: Roy Lee modify for as7326_56x\n#    6/26/2018: Jostar implement by new thermal policy from HW RD\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import getopt\n    import sys\n    import logging\n    import logging.config\n    import logging.handlers\n    import time  # this is only being used as part of the example\n    from as7326_56x.fanutil import FanUtil\n    from as7326_56x.thermalutil import ThermalUtil\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as7326_monitor'\n\nglobal log_file\nglobal log_level\n\n\n#Default FAN speed: 37.5%(0x05)\n#Ori is that detect: (U45_BCM56873 + Thermal sensor_LM75_CPU:0x4B) /2 \n#New Detect: (sensor_LM75_49 + Thermal sensor_LM75_CPU_4B) /2 \n#Thermal policy: Both F2B and B2F\n#1.\t(sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 =< 39C   , Keep 37.5%(0x05) Fan speed\n#2.\t(sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 39C   , Change Fan speed from 37.5%(0x05) to % 75%(0x0B)\n#3.\t(sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 45C   , Change Fan speed from 75%(0x0B) to 100%(0x0F)\n#4.\t(sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 61C   , Send alarm message\n#5.\t(sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 66C   , Shutdown system\n#6.\tOne Fan fail      , Change Fan speed to 100%(0x0F)\n\n#fan-dev 0-11 speed 0x05     Setup fan speed 37.50%\t\t\n#fan-dev 0-11 speed 0xB      Setup fan speed 75%\t\t\n#fan-dev 0-11 speed 0xF      Setup fan speed 100.00%\t\t\n\n\nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n \n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n     \n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args: # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\n\nfan_policy_state=1\nfan_fail=0\nalarm_state = 0 #0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0, 0, 0, 0, 0]\n\n# Make a class we can use to capture stdout and sterr in the log\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm=0\n    ori_pwm = 0\n    default_pwm=0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format= '[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = handler = logging.handlers.SysLogHandler(address = '/dev/log')\n        sys_handler.setLevel(logging.WARNING)       \n        logging.getLogger('').addHandler(sys_handler)\n\n        #logging.debug('SET. logfile:%s / loglevel:%d', log_file, log_level)\n          \n    def get_state_from_fan_policy(self, temp, policy):\n        state=0\n        logging.debug('temp=%d', temp)\n        for i in range(0, len(policy)):\n            #logging.debug('policy[%d][0]=%d, policy[%d][1]=%d', i,policy[i][0],i, policy[i][1])\n            if temp > policy[i][0]:\n                if temp <= policy[i][1]:\n                    state =policy[i][2]\n                    logging.debug ('temp=%d >= policy[%d][0]=%d,  temp=%d < policy[%d][1]=%d' , temp, i, policy[i][0], temp, i, policy[i][1])\n                    logging.debug ('fan_state=%d', state)\n        if state==0:\n            state=policy[0][2] #below fan_min, set to default pwm\n            logging.debug('set default state')\n        return state\n    \n    def manage_fans(self):\n        \n        thermal_pwm_list = {} #Ori sort is lm75_48, 49, 4a, 4b, cpu, bcm\n                              # After get pwm, do sort to get max pwm.\n        LEVEL_FAN_DEF=1\n        LEVEL_FAN_MID=2       \n        LEVEL_FAN_MAX=3\n        LEVEL_TEMP_HIGH=4\n        LEVEL_TEMP_CRITICAL=5         \n        \n        fan_policy_state_pwm_tlb = {\n        LEVEL_FAN_DEF:          [38,  0x4],\n        LEVEL_FAN_MID:          [75,  0xB],     \n        LEVEL_FAN_MAX:          [100, 0xE],\n        LEVEL_TEMP_HIGH:        [100, 0xE],\n        LEVEL_TEMP_CRITICAL:    [100, 0xE],\n        }\n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list        \n        global alarm_state\n        fan_policy ={\n        0: [0,     39000,   LEVEL_FAN_DEF],  #F2B_policy, B2F_plicy, PWM, reg_val\n        1: [39000, 45000,   LEVEL_FAN_MID],  \n        2: [45000, 61000,   LEVEL_FAN_MAX],\n        3: [61000, 66000,   LEVEL_TEMP_HIGH],        \n        4: [66000, 200000,  LEVEL_TEMP_CRITICAL],        \n        }\n              \n        thermal = ThermalUtil()\n        fan = FanUtil()\n        #fan_dir=fan.get_fan_dir(1)            \n        #if fan_dir > 1:\n        #    fan_dri=1 #something wrong, set fan_dir to default val\n        #if fan_dir < 0:\n        #    fan_dri=1 #something wrong, set fan_dir to default val\n        ori_pwm=fan.get_fan_duty_cycle()\n        new_pwm=0  \n        #logging.debug('fan_dir=%d, ori_pwm=%d', fan_dir, ori_pwm)\n        logging.debug('test_temp=%d', test_temp)\n        if test_temp==0: \n            temp1 = thermal._get_thermal_val(1)\n            temp2 = thermal._get_thermal_val(2)\n            temp3 = thermal._get_thermal_val(3)\n            temp4 = thermal._get_thermal_val(4)\n            temp5 = thermal._get_thermal_val(5)\n            temp6=0\n        else:\n            temp1 = test_temp_list[0]\n            temp2 = test_temp_list[1]\n            temp3 = test_temp_list[2]\n            temp4 = test_temp_list[3]\n            temp5 = test_temp_list[4]\n            temp6=0\n            fan_fail=0\n       \n        if temp2==0:\n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%')\n        elif temp2==0:        \n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%')\n        else:    \n            temp_get= (temp2 + temp4)/2  # Use (sensor_LM75_49 + Thermal sensor_LM75_CPU_4B) /2 \n        ori_state=fan_policy_state\n        fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy)    \n        logging.debug('lm75_48=%d, lm75_49=%d, lm75_4a=%d, lm_4b=%d, cpu=%d, bcm=%d', temp1,temp2,temp3,temp4,temp5,temp6)\n        logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state)\n        new_pwm = fan_policy_state_pwm_tlb[fan_policy_state][0]\n        if fan_fail==0:\n            logging.debug('new_pwm=%d', new_pwm)\n        \n        if fan_fail==0:\n            if new_pwm!=ori_pwm:\n                fan.set_fan_duty_cycle(new_pwm)\n                logging.info('Set fan speed from %d to %d', ori_pwm, new_pwm)\n        \n        for i in range (fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1):\n            if fan.get_fan_status(i)==0:\n                new_pwm=100\n                logging.debug('fan_%d fail, set pwm to 100',i)\n                if test_temp==0:\n                    fan_fail=1\n                    fan.set_fan_duty_cycle(new_pwm)\n                    break\n            else:\n                fan_fail=0        \n       \n        new_state = fan_policy_state       \n        \n        if ori_state==LEVEL_FAN_DEF:            \n           if new_state==LEVEL_TEMP_HIGH:\n               if alarm_state==0:\n                   logging.warning('Alarm for temperature high is detected')\n               alarm_state=1\n           if new_state==LEVEL_TEMP_CRITICAL:\n               logging.critical('Alarm for temperature critical is detected, reboot DUT')\n               time.sleep(2)\n               os.system('reboot')           \n        if ori_state==LEVEL_FAN_MID:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state=1 \n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n        if ori_state==LEVEL_FAN_MAX:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected') \n                alarm_state=1\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n            if alarm_state==1:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_HIGH:\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n            if new_state <= LEVEL_FAN_MID:\n                logging.warning('Alarm for temperature high is cleared')\n                alarm_state=0\n            if new_state <= LEVEL_FAN_MAX:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_CRITICAL:            \n            if new_state <= LEVEL_FAN_MAX:\n                logging.warning('Alarm for temperature critical is cleared')\n      \n        return True\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv,'hdlt:',['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg            \n        \n        if sys.argv[1]== '-t':\n            if len(sys.argv)!=8:\n                print(\"temp test, need input six temp\")\n                return 0\n            \n            i=0\n            for x in range(2, 8):\n               test_temp_list[i]= int(sys.argv[x])*1000\n               i=i+1\n            test_temp = 1   \n            log_level = logging.DEBUG\n            print(test_temp_list)                       \n    \n    fan = FanUtil()\n    fan.set_fan_duty_cycle(38)\n    print(\"set default fan speed to 37.5%\")\n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(5)\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    \n"}, "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py": {"changes": [{"diff": "\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n         if ori_state == LEVEL_FAN_MID:\n             if new_state == LEVEL_TEMP_HIGH:\n                 if alarm_state == 0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n         if ori_state == LEVEL_FAN_MAX:\n             if new_state == LEVEL_TEMP_HIGH:\n                 if alarm_state == 0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if alarm_state == 1:\n                 if temp_get < (fan_policy[3][0] - 5000):  # below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is cleare", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}], "source": "\n try: import os import sys import getopt import logging import logging.config import logging.handlers import time from sonic_platform import platform except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='accton_as7326_56x_monitor' platform_chassis=None fan_policy_state=1 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0] temp_test_data=0 test_temp_revert=0 class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 logging.debug('temp=%d', temp) for i in range(0, len(policy)): if temp > policy[i][0]: if temp <=policy[i][1]: state=policy[i][2] logging.debug('temp=%d >=policy[%d][0]=%d, temp=%d < policy[%d][1]=%d', temp, i, policy[i][0], temp, i, policy[i][1]) logging.debug('fan_state=%d', state) if state==0: state=policy[0][2] logging.debug('set default state') return state def manage_fans(self): LEVEL_FAN_DEF=1 LEVEL_FAN_MID=2 LEVEL_FAN_MAX=3 LEVEL_TEMP_HIGH=4 LEVEL_TEMP_CRITICAL=5 FAN_NUM=2 FAN_TRAY_NUM=6 fan_policy_state_pwm_tlb={ LEVEL_FAN_DEF: [38, 0x4], LEVEL_FAN_MID: [75, 0xB], LEVEL_FAN_MAX: [100, 0xE], LEVEL_TEMP_HIGH: [100, 0xE], LEVEL_TEMP_CRITICAL: [100, 0xE], } global platform_chassis global fan_policy_state global fan_fail global test_temp global test_temp_list global temp_test_data global test_temp_revert global alarm_state fan_policy={ 0:[0, 39000, LEVEL_FAN_DEF], 1:[39000, 45000, LEVEL_FAN_MID], 2:[45000, 61000, LEVEL_FAN_MAX], 3:[61000, 66000, LEVEL_TEMP_HIGH], 4:[66000, 200000, LEVEL_TEMP_CRITICAL], } ori_perc=platform_chassis.get_fan(0).get_speed() if test_temp==0: temp2=platform_chassis.get_thermal(1).get_temperature()*1000 temp4=platform_chassis.get_thermal(3).get_temperature()*1000 else: temp2=test_temp_list[0] temp4=test_temp_list[1] if test_temp_revert==0: temp_test_data=temp_test_data+2000 else: temp_test_data=temp_test_data-2000 if temp2==0: temp_get=50000 logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%') elif temp4==0: temp_get=50000 logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%') else: temp_get=(temp2 +temp4)/2 logging.debug('Begeinning,fan_policy_state=%d', fan_policy_state) if test_temp==1: temp_get=temp_get+temp_test_data ori_state=fan_policy_state fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy) logging.debug('temp2=lm75_49=%d,temp4=lm_4b=%d, temp_get=%d, ori_state=%d', temp2, temp4, temp_get, ori_state) if fan_policy_state > ori_state: logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state) new_perc=fan_policy_state_pwm_tlb[fan_policy_state][0] if fan_fail==0: if new_perc !=ori_perc: platform_chassis.get_fan(0).set_speed(new_perc) logging.info('Set fan speed from %d to %d', ori_perc, new_perc) for i in range(FAN_TRAY_NUM * FAN_NUM): if not platform_chassis.get_fan(i).get_status() or not platform_chassis.get_fan(i).get_speed_rpm(): new_perc=100 logging.debug('fan_%d fail, set new_perc to 100', i+1) fan_fail=1 if ori_state < LEVEL_FAN_MAX: fan_policy_state=new_state=LEVEL_FAN_MAX logging.debug('fan_policy_state=%d', fan_policy_state) logging.warning('fan_policy_state is LEVEL_FAN_MAX') platform_chassis.get_fan(0).set_speed(new_perc) break else: fan_fail=0 if fan_fail==0: new_state=fan_policy_state else: if fan_policy_state > ori_state: new_state=fan_policy_state else: fan_policy_state=new_state=LEVEL_FAN_MAX if ori_state==LEVEL_FAN_DEF: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected, reboot DUT') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MID: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MAX: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if alarm_state==1: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_HIGH: if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if new_state <=LEVEL_FAN_MID: logging.warning('Alarm for temperature high is cleared') alarm_state=0 if new_state <=LEVEL_FAN_MAX: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_CRITICAL: if new_state <=LEVEL_FAN_MAX: logging.warning('Alarm for temperature critical is cleared') return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv, 'hdlt:',['lfile=']) except getopt.GetoptError: print(('Usage: %s[-d][-l <log_file>]' % sys.argv[0])) return 0 for opt, arg in opts: if opt=='-h': print(('Usage: %s[-d][-l <log_file>]' % sys.argv[0])) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv) !=4: print(\"temp test, need input four temp\") return 0 i=0 for x in range(2, 4): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) global platform_chassis platform_chassis=platform.Platform().get_chassis() platform_chassis.get_fan(0).set_speed(38) print(\"set default fan speed to 37.5%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(5) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    mm/dd/yyyy (A.D.)\n#    3/23/2018: Roy Lee modify for as7326_56x\n#    6/26/2018: Jostar implement by new thermal policy from HW RD\n#    09/18/2020: Jostar Yang, change to call PDDF API .\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import sys\n    import getopt\n    import logging\n    import logging.config\n    import logging.handlers\n    import time\n    from sonic_platform import platform\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = 'accton_as7326_56x_monitor'\n\nplatform_chassis = None\n\n# Default FAN speed: 37.5%(0x05)\n# Ori is that detect: (U45_BCM56873 + Thermal sensor_LM75_CPU:0x4B) /2\n# New Detect: (sensor_LM75_49 + Thermal sensor_LM75_CPU_4B) /2\n# Thermal policy: Both F2B and B2F\n# 1.    (sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 =< 39C   , Keep 37.5%(0x05) Fan speed\n# 2.    (sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 39C   , Change Fan speed from 37.5%(0x05) to % 75%(0x0B)\n# 3.    (sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 45C   , Change Fan speed from 75%(0x0B) to 100%(0x0F)\n# 4.    (sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 61C   , Send alarm message\n# 5.    (sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 66C   , Shutdown system\n# 6.    One Fan fail      , Change Fan speed to 100%(0x0F)\n\n# fan-dev 0-11 speed 0x05     Setup fan speed 37.50%\n# fan-dev 0-11 speed 0xB      Setup fan speed 75%\n# fan-dev 0-11 speed 0xF      Setup fan speed 100.00%\n\nfan_policy_state = 1\nfan_fail = 0\nalarm_state = 0  # 0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0]\ntemp_test_data = 0\ntest_temp_revert = 0\n\n# Make a class we can use to capture stdout and sterr in the log\n\n\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm = 0\n    ori_pwm = 0\n    default_pwm = 0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format='[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = logging.handlers.SysLogHandler(address='/dev/log')\n        sys_handler.setLevel(logging.WARNING)\n        logging.getLogger('').addHandler(sys_handler)\n\n    def get_state_from_fan_policy(self, temp, policy):\n        state = 0\n        logging.debug('temp=%d', temp)\n        for i in range(0, len(policy)):\n            #logging.debug('policy[%d][0]=%d, policy[%d][1]=%d', i,policy[i][0],i, policy[i][1])\n            if temp > policy[i][0]:\n                if temp <= policy[i][1]:\n                    state = policy[i][2]\n                    logging.debug('temp=%d >= policy[%d][0]=%d,  temp=%d < policy[%d][1]=%d',\n                                  temp, i, policy[i][0], temp, i, policy[i][1])\n                    logging.debug('fan_state=%d', state)\n        if state == 0:\n            state = policy[0][2]  # below fan_min, set to default pwm\n            logging.debug('set default state')\n        return state\n\n    def manage_fans(self):\n        LEVEL_FAN_DEF = 1\n        LEVEL_FAN_MID = 2\n        LEVEL_FAN_MAX = 3\n        LEVEL_TEMP_HIGH = 4\n        LEVEL_TEMP_CRITICAL = 5\n\n        FAN_NUM = 2\n        FAN_TRAY_NUM = 6\n\n        fan_policy_state_pwm_tlb = {\n            LEVEL_FAN_DEF:          [38,  0x4],\n            LEVEL_FAN_MID:          [75,  0xB],\n            LEVEL_FAN_MAX:          [100, 0xE],\n            LEVEL_TEMP_HIGH:        [100, 0xE],\n            LEVEL_TEMP_CRITICAL:    [100, 0xE],\n        }\n        global platform_chassis\n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list\n        global temp_test_data\n        global test_temp_revert\n        global alarm_state\n        fan_policy = {\n            0: [0,     39000,   LEVEL_FAN_DEF],  # F2B_policy, B2F_plicy, PWM, reg_val\n            1: [39000, 45000,   LEVEL_FAN_MID],\n            2: [45000, 61000,   LEVEL_FAN_MAX],\n            3: [61000, 66000,   LEVEL_TEMP_HIGH],\n            4: [66000, 200000,  LEVEL_TEMP_CRITICAL],\n        }\n        \n        ori_perc = platform_chassis.get_fan(0).get_speed()\n        #logging.debug('test_temp=%d', test_temp)\n        if test_temp == 0:\n            temp2 = platform_chassis.get_thermal(1).get_temperature()*1000\n            temp4 = platform_chassis.get_thermal(3).get_temperature()*1000\n        else:\n            temp2 = test_temp_list[0]\n            temp4 = test_temp_list[1]\n            # fan_fail=0 # When test no-fan DUT. Need to use this.\n            if test_temp_revert == 0:\n                temp_test_data = temp_test_data+2000\n            else:\n                temp_test_data = temp_test_data-2000\n\n        if temp2 == 0:\n            temp_get = 50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75%\n            logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%')\n        elif temp4 == 0:\n            temp_get = 50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75%\n            logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%')\n        else:\n            temp_get = (temp2 + temp4)/2  # Use (sensor_LM75_49 + Thermal sensor_LM75_CPU_4B) /2\n        logging.debug('Begeinning ,fan_policy_state=%d', fan_policy_state)\n        if test_temp == 1:\n            temp_get = temp_get+temp_test_data\n\n        ori_state = fan_policy_state\n        fan_policy_state = self.get_state_from_fan_policy(temp_get, fan_policy)\n        #logging.debug(\"temp2=\" + str(temp2))\n        #logging.debug(\"temp4=\" + str(temp4))\n        #logging.debug(\"temp_get=\" + str(temp_get))\n        logging.debug('temp2=lm75_49=%d,temp4=lm_4b=%d, temp_get=%d, ori_state=%d', temp2, temp4, temp_get, ori_state)\n        if fan_policy_state > ori_state:\n            logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state)\n        new_perc = fan_policy_state_pwm_tlb[fan_policy_state][0]\n\n        if fan_fail == 0:\n            if new_perc != ori_perc:\n                # fan.set_fan_duty_cycle(new_perc)\n                platform_chassis.get_fan(0).set_speed(new_perc)\n                logging.info('Set fan speed from %d to %d', ori_perc, new_perc)\n\n        # for i in range (fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1):\n        for i in range(FAN_TRAY_NUM * FAN_NUM):\n            if not platform_chassis.get_fan(i).get_status() or not platform_chassis.get_fan(i).get_speed_rpm():\n                new_perc = 100\n                logging.debug('fan_%d fail, set new_perc to 100', i+1)\n                # if test_temp==0:# When test no-fan DUT. Need to use this.\n                fan_fail = 1\n                if ori_state < LEVEL_FAN_MAX:\n                    fan_policy_state = new_state = LEVEL_FAN_MAX\n                    logging.debug('fan_policy_state=%d', fan_policy_state)\n                    logging.warning('fan_policy_state is LEVEL_FAN_MAX')\n                platform_chassis.get_fan(0).set_speed(new_perc)\n                break\n            else:\n                fan_fail = 0\n\n        if fan_fail == 0:\n            new_state = fan_policy_state\n        else:\n            if fan_policy_state > ori_state:\n                new_state = fan_policy_state\n            else:\n                fan_policy_state = new_state = LEVEL_FAN_MAX\n\n        if ori_state == LEVEL_FAN_DEF:\n            if new_state == LEVEL_TEMP_HIGH:\n                if alarm_state == 0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state = 1\n            if new_state == LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n                os.system('reboot')\n        if ori_state == LEVEL_FAN_MID:\n            if new_state == LEVEL_TEMP_HIGH:\n                if alarm_state == 0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state = 1\n            if new_state == LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n        if ori_state == LEVEL_FAN_MAX:\n            if new_state == LEVEL_TEMP_HIGH:\n                if alarm_state == 0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state = 1\n            if new_state == LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n            if alarm_state == 1:\n                if temp_get < (fan_policy[3][0] - 5000):  # below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state = 0\n        if ori_state == LEVEL_TEMP_HIGH:\n            if new_state == LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n            if new_state <= LEVEL_FAN_MID:\n                logging.warning('Alarm for temperature high is cleared')\n                alarm_state = 0\n            if new_state <= LEVEL_FAN_MAX:\n                if temp_get < (fan_policy[3][0] - 5000):  # below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state = 0\n        if ori_state == LEVEL_TEMP_CRITICAL:\n            if new_state <= LEVEL_FAN_MAX:\n                logging.warning('Alarm for temperature critical is cleared')\n\n        return True\n\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv, 'hdlt:', ['lfile='])\n        except getopt.GetoptError:\n            print(('Usage: %s [-d] [-l <log_file>]' % sys.argv[0]))\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print(('Usage: %s [-d] [-l <log_file>]' % sys.argv[0]))\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg\n\n        if sys.argv[1] == '-t':\n            if len(sys.argv) != 4:\n                print(\"temp test, need input four temp\")\n                return 0\n\n            i = 0\n            for x in range(2, 4):\n                test_temp_list[i] = int(sys.argv[x])*1000\n                i = i+1\n            test_temp = 1\n            log_level = logging.DEBUG\n            print(test_temp_list)\n\n    global platform_chassis\n    platform_chassis = platform.Platform().get_chassis()\n\n    platform_chassis.get_fan(0).set_speed(38)\n\n    print(\"set default fan speed to 37.5%\")\n    monitor = device_monitor(log_file, log_level)\n\n    while True:\n        monitor.manage_fans()\n        time.sleep(5)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py": {"changes": [{"diff": "\n \n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\n", "add": 6, "remove": 6, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py", "badparts": ["    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cdump -y 0 0x42 s 0x9a\"", "        status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]", "        status, output = getstatusoutput_noshell(cmd)"]}, {"diff": "\n     return 0\n \n def eeprom_check():\n-    cmd = \"i2cget -y -f 0 0x56\"\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cget\", \"-y\", \"-f\", \"0\", \"0x56\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     r", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py", "badparts": ["    cmd = \"i2cget -y -f 0 0x56\"", "    status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cget\", \"-y\", \"-f\", \"0\", \"0x56\"]", "    status, output = getstatusoutput_noshell(cmd)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes \"\"\" import subprocess import getopt import sys import logging import re import time import os PROJECT_NAME='as7326_56x' version='0.1.0' verbose=False DEBUG=False args=[] ALL_DEVICE={} DEVICE_NO={'led':5, 'fan':6,'thermal':4, 'psu':2, 'sfp':58} FORCE=0 if DEBUG==True: print(sys.argv[0]) print('ARGV :', sys.argv[1:]) def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print(options) print(args) print(len(sys.argv)) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': do_install() elif arg=='api': do_sonic_platform_install() elif arg=='api_clean': do_sonic_platform_clean() elif arg=='clean': do_uninstall() else: show_help() return 0 def show_help(): print(__doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]}) sys.exit(0) def dis_i2c_ir3570a(addr): cmd=\"i2cset -y 0 0x%x 0xE5 0x01\" % addr status, output=subprocess.getstatusoutput(cmd) cmd=\"i2cset -y 0 0x%x 0x12 0x02\" % addr status, output=subprocess.getstatusoutput(cmd) return status def ir3570_check(): cmd=\"i2cdump -y 0 0x42 s 0x9a\" try: status, output=subprocess.getstatusoutput(cmd) lines=output.split('\\n') hn=re.findall(r'\\w+', lines[-1]) version=int(hn[1], 16) if version==0x24: ret=dis_i2c_ir3570a(4) else: ret=0 except Exception as e: print(\"Error on ir3570_check() e:\" +str(e)) return -1 return ret def my_log(txt): if DEBUG==True: print(\"[ROY]\"+txt) return def log_os_system(cmd, show): logging.info('Run:'+cmd) status, output=subprocess.getstatusoutput(cmd) my_log(cmd +\"with result:\" +str(status)) my_log(\" output:\"+output) if status: logging.info('Failed:'+cmd) if show: print('Failed:'+cmd) return status, output def driver_check(): ret, lsmod=log_os_system(\"ls /sys/module/*accton*\", 0) logging.info('mods:'+lsmod) if ret: return False else: return True kos=[ 'modprobe i2c_dev', 'modprobe i2c_mux_pca954x', 'modprobe accton_i2c_cpld' , 'modprobe ym2651y' , 'modprobe accton_as7326_56x_fan' , 'modprobe optoe' , 'modprobe accton_as7326_56x_leds' , 'modprobe accton_as7326_56x_psu'] def driver_install(): global FORCE status, output=log_os_system('modprobe i2c_dev', 1) status, output=log_os_system(\"depmod\", 1) for i in range(0,len(kos)): status, output=log_os_system(kos[i], 1) if status: if FORCE==0: return status print(\"Done driver_install\") return 0 def driver_uninstall(): global FORCE for i in range(0,len(kos)): rm=kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\") rm=rm.replace(\"insmod\", \"rmmod\") lst=rm.split(\" \") if len(lst) > 3: del(lst[3]) rm=\" \".join(lst) status, output=log_os_system(rm, 1) if status: if FORCE==0: return status return 0 i2c_prefix='/sys/bus/i2c/devices/' ''' i2c_bus={'fan':['11-0066'] , 'thermal':['15-0048','15-0049', '15-004a', '15-004b'], 'psu':['17-0051','13-0053'], 'sfp':['-0050']} i2c_nodes={'fan':['present', 'front_speed_rpm', 'rear_speed_rpm'], 'thermal':['hwmon/hwmon*/temp1_input'], 'psu':['psu_present ', 'psu_power_good'] , 'sfp':['module_present_', 'module_tx_disable_']} ''' sfp_map=[ 42,41,44,43,47,45,46,50, 48,49,52,51,53,56,55,54, 58,57,60,59,61,63,62,64, 66,68,65,67,69,71,72,70, 74,73,76,75,77,79,78,80, 81,82,84,85,83,87,88,86, 25,26,27,28,29,30,31,32, 22,23] qsfp_start=48 qsfp_end =56 cpld_of_module={'12-0062': list(range(0,30)), \t\t '18-0060': list(range(30,58))} mknod=[ 'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-24/new_device', 'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-33/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-34/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-35/new_device', 'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-36/new_device', 'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-37/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-38/new_device', 'echo as7326_56x_fan 0x66 > /sys/bus/i2c/devices/i2c-11/new_device ', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-15/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-15/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-15/new_device', 'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-15/new_device', 'echo as7326_56x_psu1 0x51 > /sys/bus/i2c/devices/i2c-17/new_device', 'echo ym2651 0x59 > /sys/bus/i2c/devices/i2c-17/new_device', 'echo as7326_56x_psu2 0x53 > /sys/bus/i2c/devices/i2c-13/new_device', 'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-13/new_device', 'echo as7326_56x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo as7326_56x_cpld2 0x62 > /sys/bus/i2c/devices/i2c-12/new_device', 'echo as7326_56x_cpld3 0x64 > /sys/bus/i2c/devices/i2c-19/new_device'] mknod2=[ ] eeprom_mknod=[ 'echo 24c04 0x56 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-0/new_device' ] def i2c_order_check(): return 0 def eeprom_check(): cmd=\"i2cget -y -f 0 0x56\" status, output=subprocess.getstatusoutput(cmd) return status def device_install(): global FORCE order=i2c_order_check() if order: for i in range(0,len(mknod2)): if mknod2[i].find('pca954') !=-1: time.sleep(1) status, output=log_os_system(mknod2[i], 1) if status: print(output) if FORCE==0: return status else: for i in range(0,len(mknod)): if mknod[i].find('pca954') !=-1: time.sleep(1) status, output=log_os_system(mknod[i], 1) if status: print(output) if FORCE==0: return status cmd='echo -2 | tee /sys/bus/i2c/drivers/pca954x/*-00*/idle_state' status, output=log_os_system(cmd, 1) if status: print(output) if FORCE==0: return status log_os_system(\"i2cset -f -y 0 0x77 0 \", 1) ret=eeprom_check() if ret==0: log_os_system(eeprom_mknod[0], 1) time.sleep(0.2) exists=os.path.isfile('/sys/bus/i2c/devices/0-0056/eeprom') if(exists is False): subprocess.call('echo 0x56 > /sys/bus/i2c/devices/i2c-0/delete_device', shell=True) log_os_system(eeprom_mknod[1], 1) else: log_os_system(eeprom_mknod[1], 1) for i in range(0,len(sfp_map)): if i < qsfp_start or i >=qsfp_end: status, output=log_os_system(\"echo optoe2 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1) else: status, output=log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1) if status: print(output) if FORCE==0: return status print(\"Done device_install\") return def device_uninstall(): global FORCE status, output=log_os_system(\"ls /sys/bus/i2c/devices/1-0076\", 0) if status==0: I2C_ORDER=1 else: I2C_ORDER=0 for i in range(0,len(sfp_map)): target=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\" status, output=log_os_system(\"echo 0x50 > \"+target, 1) if status: print(output) if FORCE==0: return status if I2C_ORDER==0: nodelist=mknod else: nodelist=mknod2 for i in range(len(nodelist)): target=nodelist[-(i+1)] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status exists=os.path.isfile('/sys/bus/i2c/devices/0-0056/eeprom') if(exists is True): target=eeprom_mknod[0] else: target=eeprom_mknod[1] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status return def system_ready(): if driver_check()==False: return False if not device_exist(): return False return True PLATFORM_ROOT_PATH='/usr/share/sonic/device' PLATFORM_API2_WHL_FILE_PY3='sonic_platform-1.0-py3-none-any.whl' def do_sonic_platform_install(): device_path=\"{}{}{}{}\".format(PLATFORM_ROOT_PATH, '/x86_64-accton_', PROJECT_NAME, '-r0') SONIC_PLATFORM_BSP_WHL_PKG_PY3=\"/\".join([device_path, PLATFORM_API2_WHL_FILE_PY3]) status, output=log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0) if status: if os.path.exists(SONIC_PLATFORM_BSP_WHL_PKG_PY3): status, output=log_os_system(\"pip3 install \"+SONIC_PLATFORM_BSP_WHL_PKG_PY3, 1) if status: print(\"Error: Failed to install{}\".format(PLATFORM_API2_WHL_FILE_PY3)) return status else: print(\"Successfully installed{} package\".format(PLATFORM_API2_WHL_FILE_PY3)) else: print('{} is not found'.format(PLATFORM_API2_WHL_FILE_PY3)) else: print('{} has installed'.format(PLATFORM_API2_WHL_FILE_PY3)) return def do_sonic_platform_clean(): status, output=log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0) if status: print('{} does not install, not need to uninstall'.format(PLATFORM_API2_WHL_FILE_PY3)) else: status, output=log_os_system(\"pip3 uninstall sonic-platform -y\", 0) if status: print('Error: Failed to uninstall{}'.format(PLATFORM_API2_WHL_FILE_PY3)) return status else: print('{} is uninstalled'.format(PLATFORM_API2_WHL_FILE_PY3)) return def do_install(): print(\"Checking system....\") if driver_check()==False: print(\"No driver, installing....\") status=driver_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" drivers detected....\") ir3570_check() if not device_exist(): print(\"No device, installing....\") status=device_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" devices detected....\") do_sonic_platform_install() return def do_uninstall(): print(\"Checking system....\") if not device_exist(): print(PROJECT_NAME.upper() +\" has no device installed....\") else: print(\"Removing device....\") status=device_uninstall() if status: if FORCE==0: return status if driver_check()==False: print(PROJECT_NAME.upper() +\" has no driver installed....\") else: print(\"Removing installed driver....\") status=driver_uninstall() if status: if FORCE==0: return status do_sonic_platform_clean() return def device_exist(): ret1, log=log_os_system(\"ls \"+i2c_prefix+\"*0070\", 0) ret2, log=log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# Copyright (C) 2016 Accton Networks, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean\ncommand:\n    install     : install drivers and generate related sysfs nodes\n    clean       : uninstall drivers and remove related sysfs nodes\n\"\"\"\nimport subprocess\nimport getopt\nimport sys\nimport logging\nimport re\nimport time\nimport os\n\n\n\nPROJECT_NAME = 'as7326_56x'\nversion = '0.1.0'\nverbose = False\nDEBUG = False\nargs = []\nALL_DEVICE = {}\nDEVICE_NO = {'led':5, 'fan':6,'thermal':4, 'psu':2, 'sfp':58}\nFORCE = 0\n#logging.basicConfig(filename= PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG)\n#logging.basicConfig(level=logging.INFO)\n\n\nif DEBUG == True:\n    print(sys.argv[0])\n    print('ARGV      :', sys.argv[1:])\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n\n    if len(sys.argv)<2:\n        show_help()\n\n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:                \n        print(options)\n        print(args)\n        print(len(sys.argv))\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n           do_install()\n        elif arg == 'api':\n           do_sonic_platform_install()\n        elif arg == 'api_clean':\n           do_sonic_platform_clean()\n        elif arg == 'clean':\n           do_uninstall()\n        else:\n            show_help()\n    return 0\n\ndef show_help():\n    print(__doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]})\n    sys.exit(0)\n\n\n\ndef dis_i2c_ir3570a(addr):\n    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef ir3570_check():\n    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n    try:\n        status, output = subprocess.getstatusoutput(cmd)\n        lines = output.split('\\n')\n        hn = re.findall(r'\\w+', lines[-1])\n        version = int(hn[1], 16)\n        if version == 0x24:  #only for ir3570a\n            ret = dis_i2c_ir3570a(4)\n        else:\n            ret = 0\n    except Exception as e:\n        print(\"Error on ir3570_check() e:\" + str(e))\n        return -1\n    return ret\n\n\ndef my_log(txt):\n    if DEBUG == True:\n        print(\"[ROY]\"+txt)\n    return\n\ndef log_os_system(cmd, show):\n    logging.info('Run :'+cmd)\n    status, output = subprocess.getstatusoutput(cmd)\n    my_log (cmd +\"with result:\" + str(status))\n    my_log (\"      output:\"+output)\n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print('Failed :'+cmd)\n    return  status, output\n\ndef driver_check():\n    ret, lsmod = log_os_system(\"ls /sys/module/*accton*\", 0)\n    logging.info('mods:'+lsmod)\n    if ret :\n        return False\n    else :\n        return True\n\n\n\nkos = [\n'modprobe i2c_dev',\n'modprobe i2c_mux_pca954x',\n'modprobe accton_i2c_cpld'  ,\n'modprobe ym2651y'                  ,\n'modprobe accton_as7326_56x_fan'     ,\n'modprobe optoe'      ,\n'modprobe accton_as7326_56x_leds'      ,\n'modprobe accton_as7326_56x_psu' ]\n\ndef driver_install():\n    global FORCE\n    \n    status, output = log_os_system('modprobe i2c_dev', 1)\n    status, output = log_os_system(\"depmod\", 1)\n    for i in range(0,len(kos)):\n        status, output = log_os_system(kos[i], 1)\n        if status:\n            if FORCE == 0:\n                return status\n    print(\"Done driver_install\")\n    \n    return 0\n\ndef driver_uninstall():\n    global FORCE\n    for i in range(0,len(kos)):\n        rm = kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\")\n        rm = rm.replace(\"insmod\", \"rmmod\")\n        lst = rm.split(\" \")\n        if len(lst) > 3:\n            del(lst[3])\n        rm = \" \".join(lst)\n        status, output = log_os_system(rm, 1)\n        if status:\n            if FORCE == 0:\n                return status\n    return 0\n\ni2c_prefix = '/sys/bus/i2c/devices/'\n'''\ni2c_bus = {'fan': ['11-0066']                 ,\n           'thermal': ['15-0048','15-0049', '15-004a', '15-004b'] ,\n           'psu': ['17-0051','13-0053'],\n           'sfp': ['-0050']}\ni2c_nodes = {'fan': ['present', 'front_speed_rpm', 'rear_speed_rpm'] ,\n           'thermal': ['hwmon/hwmon*/temp1_input'] ,\n           'psu': ['psu_present ', 'psu_power_good']    ,\n           'sfp': ['module_present_', 'module_tx_disable_']}\n'''\nsfp_map =  [\n        42,41,44,43,47,45,46,50,\n        48,49,52,51,53,56,55,54,\n        58,57,60,59,61,63,62,64,\n        66,68,65,67,69,71,72,70,\n        74,73,76,75,77,79,78,80,\n        81,82,84,85,83,87,88,86,    #port 41~48\n        25,26,27,28,29,30,31,32,    #port 49~56 QSFP\n        22,23]                      #port 57~58 SFP+ from CPU NIF.\nqsfp_start = 48\nqsfp_end   = 56\n\n#For sideband signals of SFP/QSFP modules.\ncpld_of_module = {'12-0062': list(range(0,30)),\n\t\t  '18-0060': list(range(30,58)) }\n\n\nmknod =[\n'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-1/new_device' ,\n'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-1/new_device' ,\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-24/new_device' ,\n'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-2/new_device' ,\n'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-33/new_device',\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-34/new_device',\n'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-35/new_device',\n'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-36/new_device',\n'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-37/new_device',\n'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-38/new_device',\n\n'echo as7326_56x_fan 0x66 > /sys/bus/i2c/devices/i2c-11/new_device ',\n'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-15/new_device',\n'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-15/new_device',\n'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-15/new_device',\n'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-15/new_device',\n'echo as7326_56x_psu1 0x51 > /sys/bus/i2c/devices/i2c-17/new_device',\n'echo ym2651 0x59 > /sys/bus/i2c/devices/i2c-17/new_device',\n'echo as7326_56x_psu2 0x53 > /sys/bus/i2c/devices/i2c-13/new_device',\n'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-13/new_device',\n'echo as7326_56x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo as7326_56x_cpld2 0x62 > /sys/bus/i2c/devices/i2c-12/new_device',\n'echo as7326_56x_cpld3 0x64 > /sys/bus/i2c/devices/i2c-19/new_device']\n\nmknod2 =[\n]\n\n#EERPOM\neeprom_mknod =[\n'echo 24c04 0x56 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-0/new_device'\n]\n\n\ndef i2c_order_check():\n    # This project has only 1 i2c bus.\n    return 0\n\ndef eeprom_check():\n    cmd = \"i2cget -y -f 0 0x56\"\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef device_install():\n    global FORCE\n\n    order = i2c_order_check()\n\n    # if 0x70 is not exist @i2c-1, use reversed bus order\n    if order:\n        for i in range(0,len(mknod2)):\n            #for pca954x need times to built new i2c buses\n            if mknod2[i].find('pca954') != -1:\n               time.sleep(1)\n\n            status, output = log_os_system(mknod2[i], 1)\n            if status:\n                print(output)\n                if FORCE == 0:\n                    return status\n    else:\n        for i in range(0,len(mknod)):\n            #for pca954x need times to built new i2c buses\n            if mknod[i].find('pca954') != -1:\n               time.sleep(1)\n\n            status, output = log_os_system(mknod[i], 1)\n            if status:\n                print(output)\n                if FORCE == 0:\n                    return status\n\n    # set all pca954x idle_disconnect\n    cmd = 'echo -2 | tee /sys/bus/i2c/drivers/pca954x/*-00*/idle_state'\n    status, output = log_os_system(cmd, 1)\n    if status:\n        print(output)\n        if FORCE == 0:\n            return status\n    \n    # initiate IDPROM\n    # Close 0x77 mux to make sure if the I2C address of IDPROM is 0x56 or 0x57\n    log_os_system(\"i2cset -f -y 0 0x77 0 \", 1)\n    ret=eeprom_check()\n    if ret==0:\n        log_os_system(eeprom_mknod[0], 1) #old board, 0x56 eeprom\n        time.sleep(0.2)\n        exists = os.path.isfile('/sys/bus/i2c/devices/0-0056/eeprom')\n        if (exists is False):\n            subprocess.call('echo 0x56 > /sys/bus/i2c/devices/i2c-0/delete_device', shell=True)\n            log_os_system(eeprom_mknod[1], 1)\n    else:\n        log_os_system(eeprom_mknod[1], 1) #new board, 0x57 eeprom                \n                    \n                    \n    for i in range(0,len(sfp_map)):\n        if i < qsfp_start or i >= qsfp_end:\n            status, output =log_os_system(\"echo optoe2 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1)\n        else:\n            status, output =log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n    print(\"Done device_install\")\n    return\n\ndef device_uninstall():\n    global FORCE\n\n    status, output =log_os_system(\"ls /sys/bus/i2c/devices/1-0076\", 0)\n    if status==0:\n        I2C_ORDER=1\n    else:\n        I2C_ORDER=0\n\n    for i in range(0,len(sfp_map)):\n        target = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\"\n        status, output =log_os_system(\"echo 0x50 > \"+ target, 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    if I2C_ORDER==0:\n        nodelist = mknod\n    else:\n        nodelist = mknod2\n\n    for i in range(len(nodelist)):\n        target = nodelist[-(i+1)]\n        temp = target.split()\n        del temp[1]\n        temp[-1] = temp[-1].replace('new_device', 'delete_device')\n        status, output = log_os_system(\" \".join(temp), 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    #Deal with for del 0x56 or 0x57 sysfs device    \n    exists = os.path.isfile('/sys/bus/i2c/devices/0-0056/eeprom')\n        \n    if (exists is True):\n        target = eeprom_mknod[0] #0x56\n    else:\n        target = eeprom_mknod[1] #0x57\n    \n    temp = target.split()\n    del temp[1]\n    temp[-1] = temp[-1].replace('new_device', 'delete_device')\n    status, output = log_os_system(\" \".join(temp), 1)\n    if status:\n        print(output)\n        if FORCE == 0:\n           return status\n\n    return\n\ndef system_ready():\n    if driver_check() == False:\n        return False\n    if not device_exist():\n        return False\n    return True\nPLATFORM_ROOT_PATH = '/usr/share/sonic/device'\nPLATFORM_API2_WHL_FILE_PY3 ='sonic_platform-1.0-py3-none-any.whl'\ndef do_sonic_platform_install():\n    device_path = \"{}{}{}{}\".format(PLATFORM_ROOT_PATH, '/x86_64-accton_', PROJECT_NAME, '-r0')\n    SONIC_PLATFORM_BSP_WHL_PKG_PY3 = \"/\".join([device_path, PLATFORM_API2_WHL_FILE_PY3])\n\n    #Check API2.0 on py whl file\n    status, output = log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0)\n    if status:\n        if os.path.exists(SONIC_PLATFORM_BSP_WHL_PKG_PY3): \n            status, output = log_os_system(\"pip3 install \"+ SONIC_PLATFORM_BSP_WHL_PKG_PY3, 1)\n            if status:\n                print(\"Error: Failed to install {}\".format(PLATFORM_API2_WHL_FILE_PY3))\n                return status\n            else:\n                print(\"Successfully installed {} package\".format(PLATFORM_API2_WHL_FILE_PY3))\n        else:\n            print('{} is not found'.format(PLATFORM_API2_WHL_FILE_PY3))\n    else:        \n        print('{} has installed'.format(PLATFORM_API2_WHL_FILE_PY3))\n     \n    return \n     \ndef do_sonic_platform_clean():\n    status, output = log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0)   \n    if status:\n        print('{} does not install, not need to uninstall'.format(PLATFORM_API2_WHL_FILE_PY3))\n        \n    else:        \n        status, output = log_os_system(\"pip3 uninstall sonic-platform -y\", 0)\n        if status:\n            print('Error: Failed to uninstall {}'.format(PLATFORM_API2_WHL_FILE_PY3))\n            return status\n        else:\n            print('{} is uninstalled'.format(PLATFORM_API2_WHL_FILE_PY3))\n    \n    \n    return\n\ndef do_install():\n    print(\"Checking system....\")\n    if driver_check() == False:\n        print(\"No driver, installing....\")\n        status = driver_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print(PROJECT_NAME.upper()+\" drivers detected....\")\n\n    ir3570_check()\n\n    if not device_exist():\n        print(\"No device, installing....\")\n        status = device_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print(PROJECT_NAME.upper()+\" devices detected....\")\n\n    do_sonic_platform_install()\n        \n    return\n\ndef do_uninstall():\n    print(\"Checking system....\")\n    if not device_exist():\n        print(PROJECT_NAME.upper() +\" has no device installed....\")\n    else:\n        print(\"Removing device....\")\n        status = device_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    if driver_check()== False :\n        print(PROJECT_NAME.upper() +\" has no driver installed....\")\n    else:\n        print(\"Removing installed driver....\")\n        status = driver_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    do_sonic_platform_clean()\n\n    return\n\ndef device_exist():\n    ret1, log = log_os_system(\"ls \"+i2c_prefix+\"*0070\", 0)\n    ret2, log = log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as7326-platform-fan.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as7326-platform-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Stop as7326-platform-init.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Disable as7326-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as7326_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n", "add": 7, "remove": 7, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py", "badparts": ["import subprocess", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as7326-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py clean\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7326-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"clean\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"install\"])\n     if status:\n         print(\"accton_as7326_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Enable as7326-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as7326-platform-monitor-fan.service failed %d\"%status)\n         return False\n         \n-    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as7326-platform-monitor-psu.service failed %d\"%status)\n         return False\n", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py install\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as7326-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-psu.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"install\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7326-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-psu.service\"])"]}, {"diff": "\n     return True\n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service fa", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}], "source": "\n import subprocess def check_pddf_support(): return True def stop_platform_svc(): status, output=subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-fan.service\") if status: print(\"Stop as7326-platform-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-psu.service\") if status: print(\"Stop as7326-platform-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor.service\") if status: print(\"Stop as7326-platform-init.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl disable as7326-platform-monitor.service\") if status: print(\"Disable as7326-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py clean\") if status: print(\"accton_as7326_util.py clean command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status) return False return True def start_platform_svc(): status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py install\") if status: print(\"accton_as7326_util.py install command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl enable as7326-platform-monitor.service\") if status: print(\"Enable as7326-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-fan.service\") if status: print(\"Start as7326-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-psu.service\") if status: print(\"Start as7326-platform-monitor-psu.service failed %d\"%status) return False return True def start_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print(\"Start pddf-platform-init.service failed %d\"%status) return False return True def stop_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service failed %d\"%status) return False return True def main(): print(\"stop_platform_svc\") stop_platform_svc() print(\"stop_platform_pddf\") stop_platform_pddf() if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services. \n# This will be used while switching the pddf->non-pddf mode and vice versa\n\nimport subprocess\n\ndef check_pddf_support():\n    return True\n\ndef stop_platform_svc():\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-fan.service\")\n    if status:\n        print(\"Stop as7326-platform-fan.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-psu.service\")\n    if status:\n        print(\"Stop as7326-platform-psu.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor.service\")\n    if status:\n        print(\"Stop as7326-platform-init.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as7326-platform-monitor.service\")\n    if status:\n        print(\"Disable as7326-platform-monitor.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py clean\")\n    if status:\n        print(\"accton_as7326_util.py clean command failed %d\"%status)\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n        return False\n\n    return True\n    \ndef start_platform_svc():\n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py install\")\n    if status:\n        print(\"accton_as7326_util.py install command failed %d\"%status)\n        return False\n\n    status, output = subprocess.getstatusoutput(\"systemctl enable as7326-platform-monitor.service\")\n    if status:\n        print(\"Enable as7326-platform-monitor.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-fan.service\")\n    if status:\n        print(\"Start as7326-platform-monitor-fan.service failed %d\"%status)\n        return False\n        \n    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-psu.service\")\n    if status:\n        print(\"Start as7326-platform-monitor-psu.service failed %d\"%status)\n        return False\n\n    return True\n\ndef start_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print(\"Start pddf-platform-init.service failed %d\"%status)\n        return False\n    \n    return True\n\ndef stop_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service failed %d\"%status)\n        return False\n\n    return True\n\ndef main():\n    print(\"stop_platform_svc\")\n    stop_platform_svc()\n    #print\"start_platform_svc\"\n    #start_platform_svc()\n    #print\"start_platform_pddf\"\n    #start_platform_pddf()\n    print(\"stop_platform_pddf\")\n    stop_platform_pddf()\n    #pass\n\nif __name__ == \"__main__\":\n    main()\n\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import commands\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = commands.getstatusoutput(\"systemctl stop as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Stop as7712-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl disable as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Disable as7712-platform-init.service failed %d\"%status)\n         return False\n     \n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"clean\"])\n     if status:\n-        print(\"accton_as7712_util.py clean command failed %d\"%status)\n+        print(\"accton_as7712_util.py clean failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n", "add": 6, "remove": 6, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py", "badparts": ["import commands", "    status, output = commands.getstatusoutput(\"systemctl stop as7712-platform-init.service\")", "    status, output = commands.getstatusoutput(\"systemctl disable as7712-platform-init.service\")", "    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py clean\")", "        print(\"accton_as7712_util.py clean command failed %d\"%status)", "    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7712-platform-init.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7712-platform-init.service\"])", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"clean\"])", "        print(\"accton_as7712_util.py clean failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n     \n def start_platform_svc():\n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"install\"])\n     if status:\n-        print(\"accton_as7712_util.py install command failed %d\"%status)\n+        print(\"accton_as7712_util.py install failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Enable as7712-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Start as7712-platform-init.service failed %d\"%status)\n         return False\n", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py install\")", "        print(\"accton_as7712_util.py install command failed %d\"%status)", "    status, output = commands.getstatusoutput(\"systemctl enable as7712-platform-init.service\")", "    status, output = commands.getstatusoutput(\"systemctl start as7712-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"install\"])", "        print(\"accton_as7712_util.py install failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7712-platform-init.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7712-platform-init.service\"])"]}, {"diff": "\n     return True\n \n def start_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n \n def stop_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service f", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}], "source": "\n import commands def check_pddf_support(): return True def stop_platform_svc(): status, output=commands.getstatusoutput(\"systemctl stop as7712-platform-init.service\") if status: print(\"Stop as7712-platform-init.service failed %d\"%status) return False status, output=commands.getstatusoutput(\"systemctl disable as7712-platform-init.service\") if status: print(\"Disable as7712-platform-init.service failed %d\"%status) return False status, output=commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py clean\") if status: print(\"accton_as7712_util.py clean command failed %d\"%status) return False status, output=commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status) return False return True def start_platform_svc(): status, output=commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py install\") if status: print(\"accton_as7712_util.py install command failed %d\"%status) return False status, output=commands.getstatusoutput(\"systemctl enable as7712-platform-init.service\") if status: print(\"Enable as7712-platform-init.service failed %d\"%status) return False status, output=commands.getstatusoutput(\"systemctl start as7712-platform-init.service\") if status: print(\"Start as7712-platform-init.service failed %d\"%status) return False return True def start_platform_pddf(): status, output=commands.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print(\"Start pddf-platform-init.service failed %d\"%status) return False return True def stop_platform_pddf(): status, output=commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service failed %d\"%status) return False return True def main(): pass if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services. \n# This will be used while switching the pddf->non-pddf mode and vice versa\nimport commands\n\ndef check_pddf_support():\n    return True\n\ndef stop_platform_svc():\n    status, output = commands.getstatusoutput(\"systemctl stop as7712-platform-init.service\")\n    if status:\n        print(\"Stop as7712-platform-init.service failed %d\"%status)\n        return False\n    status, output = commands.getstatusoutput(\"systemctl disable as7712-platform-init.service\")\n    if status:\n        print(\"Disable as7712-platform-init.service failed %d\"%status)\n        return False\n    \n    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py clean\")\n    if status:\n        print(\"accton_as7712_util.py clean command failed %d\"%status)\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n        return False\n\n    return True\n    \ndef start_platform_svc():\n    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py install\")\n    if status:\n        print(\"accton_as7712_util.py install command failed %d\"%status)\n        return False\n\n    status, output = commands.getstatusoutput(\"systemctl enable as7712-platform-init.service\")\n    if status:\n        print(\"Enable as7712-platform-init.service failed %d\"%status)\n        return False\n    status, output = commands.getstatusoutput(\"systemctl start as7712-platform-init.service\")\n    if status:\n        print(\"Start as7712-platform-init.service failed %d\"%status)\n        return False\n\n    return True\n\ndef start_platform_pddf():\n    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print(\"Start pddf-platform-init.service failed %d\"%status)\n        return False\n    \n    return True\n\ndef stop_platform_pddf():\n    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service failed %d\"%status)\n        return False\n\n    return True\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py": {"changes": [{"diff": "\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', line", "add": 6, "remove": 6, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py", "badparts": ["    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cdump -y 0 0x42 s 0x9a\"", "        status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]", "        status, output = getstatusoutput_noshell(cmd)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes show : show all systen status sff : dump SFP eeprom set : change board setting with fan|led|sfp \"\"\" import subprocess import getopt import sys import logging import re import time PROJECT_NAME='as7716_32x' version='0.0.1' verbose=False DEBUG=False args=[] ALL_DEVICE={} DEVICE_NO={'led':5, 'fan1':1, 'fan2':1,'fan3':1,'fan4':1,'fan5':1,'thermal':3, 'psu':2, 'sfp':54} led_prefix='/sys/devices/platform/as7716_32x_led/leds/accton_'+PROJECT_NAME+'_led::' fan_prefix='/sys/devices/platform/as7716_32x_' hwmon_types={'led':['diag','fan','loc','psu1','psu2'], 'fan1':['fan'], 'fan2':['fan'], 'fan3':['fan'], 'fan4':['fan'], 'fan5':['fan'], } hwmon_nodes={'led':['brightness'], 'fan1':['fan_duty_cycle_percentage', 'fan1_fault', 'fan1_speed_rpm', 'fan1_direction', 'fanr1_fault', 'fanr1_speed_rpm'], 'fan2':['fan_duty_cycle_percentage','fan2_fault', 'fan2_speed_rpm', 'fan2_direction', 'fanr2_fault', 'fanr2_speed_rpm'], 'fan3':['fan_duty_cycle_percentage','fan3_fault', 'fan3_speed_rpm', 'fan3_direction', 'fanr3_fault', 'fanr3_speed_rpm'], 'fan4':['fan4_duty_cycle_percentage','fan4_fault', 'fan4_speed_rpm', 'fan4_direction', 'fanr4_fault', 'fanr4_speed_rpm'], 'fan5':['fan_duty_cycle_percentage','fan5_fault', 'fan5_speed_rpm', 'fan5_direction', 'fanr5_fault', 'fanr5_speed_rpm'], \t } hwmon_prefix={'led': led_prefix, 'fan1': fan_prefix, 'fan2': fan_prefix, 'fan3': fan_prefix, 'fan4': fan_prefix, 'fan5': fan_prefix, } i2c_prefix='/sys/bus/i2c/devices/' i2c_bus={'thermal':['10-0048','10-0049', '10-004a'], 'psu':['17-0050','18-0053'], 'sfp':['-0050']} i2c_nodes={ 'thermal':['hwmon/hwmon*/temp1_input'], 'psu':['psu_present ', 'psu_power_good'] , 'sfp':['sfp_is_present ', 'sfp_tx_disable']} sfp_map=[29, 30, 31, 32, 34, 33, 36, 35, 25, 26, 27, 28, 37, 38, 39, 40, 41, 42, 43, 44, 53, 54, 55, 56, 45, 46, 47, 48, 49, 50, 51, 52] mknod=[ 'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo as7716_32x_fan 0x66 > /sys/bus/i2c/devices/i2c-9/new_device', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-10/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-10/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-10/new_device', 'echo as7716_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-11/new_device', 'echo accton_i2c_cpld 0x62 > /sys/bus/i2c/devices/i2c-12/new_device', 'echo accton_i2c_cpld 0x64 > /sys/bus/i2c/devices/i2c-13/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo as7716_32x_psu1 0x53 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-18/new_device', 'echo as7716_32x_psu2 0x50> /sys/bus/i2c/devices/i2c-17/new_device', 'echo ym2651 0x58 > /sys/bus/i2c/devices/i2c-17/new_device', 'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-1/new_device', ] mknod2=[ 'echo as7716_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo accton_i2c_cpld 0x61 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo accton_i2c_cpld 0x62 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo as7716_32x_psu1 0x38 > /sys/bus/i2c/devices/i2c-57/new_device', 'echo cpr_4011_4mxx 0x3c > /sys/bus/i2c/devices/i2c-57/new_device', 'echo as7716_32x_psu1 0x50 > /sys/bus/i2c/devices/i2c-57/new_device', 'echo ym2401 0x58 > /sys/bus/i2c/devices/i2c-57/new_device', 'echo as7716_32x_psu2 0x3b > /sys/bus/i2c/devices/i2c-58/new_device', 'echo cpr_4011_4mxx 0x3f > /sys/bus/i2c/devices/i2c-58/new_device', 'echo as7716_32x_psu2 0x53 > /sys/bus/i2c/devices/i2c-58/new_device', 'echo ym2401 0x5b > /sys/bus/i2c/devices/i2c-58/new_device', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-61/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-62/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-63/new_device', 'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-1/new_device', ] FORCE=0 logging.basicConfig(filename=PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG) logging.basicConfig(level=logging.INFO) if DEBUG==True: print(sys.argv[0]) print('ARGV :', sys.argv[1:]) def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print(options) print(args) print(len(sys.argv)) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': do_install() elif arg=='clean': do_uninstall() elif arg=='show': device_traversal() elif arg=='sff': if len(args)!=2: show_eeprom_help() elif int(args[1])==0 or int(args[1]) > DEVICE_NO['sfp']: show_eeprom_help() else: show_eeprom(args[1]) return elif arg=='set': if len(args)<3: show_set_help() else: set_device(args[1:]) return else: show_help() return 0 def show_help(): print(__doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]}) sys.exit(0) def show_set_help(): cmd= sys.argv[0].split(\"/\")[-1]+\" \" +args[0] print(cmd +\"[led|sfp|fan]\") print(\" use \\\"\"+cmd +\" led 0-4 \\\" to set led color\") print(\" use \\\"\"+cmd +\" fan 0-100\\\" to set fan duty percetage\") print(\" use \\\"\"+cmd +\" sfp 1-32{0|1}\\\" to set sfp sys.exit(0) def dis_i2c_ir3570a(addr): cmd=\"i2cset -y 0 0x%x 0xE5 0x01\" % addr status, output=subprocess.getstatusoutput(cmd) cmd=\"i2cset -y 0 0x%x 0x12 0x02\" % addr status, output=subprocess.getstatusoutput(cmd) return status def ir3570_check(): cmd=\"i2cdump -y 0 0x42 s 0x9a\" try: status, output=subprocess.getstatusoutput(cmd) lines=output.split('\\n') hn=re.findall(r'\\w+', lines[-1]) version=int(hn[1], 16) if version==0x24: ret=dis_i2c_ir3570a(4) else: ret=0 except Exception as e: print(\"Error on ir3570_check() e:\" +str(e)) return -1 return ret def show_eeprom_help(): cmd= sys.argv[0].split(\"/\")[-1]+\" \" +args[0] print(\" use \\\"\"+cmd +\" 1-32 \\\" to dump sfp sys.exit(0) def my_log(txt): if DEBUG==True: print(\"[ACCTON DBG]: \"+txt) return def log_os_system(cmd, show): logging.info('Run:'+cmd) status=1 output=\"\" status, output=subprocess.getstatusoutput(cmd) my_log(cmd +\"with result:\" +str(status)) my_log(\"cmd:\" +cmd) my_log(\" output:\"+output) if status: logging.info('Failed:'+cmd) if show: print(('Failed:'+cmd)) return status, output def driver_inserted(): ret, lsmod=log_os_system(\"ls /sys/module/*accton*\", 0) logging.info('mods:'+lsmod) if ret: return False else: return True kos=[ 'depmod -ae', 'modprobe i2c_dev', 'modprobe i2c_mux_pca954x force_deselect_on_exit=1', 'modprobe accton_i2c_cpld', 'modprobe cpr_4011_4mxx', 'modprobe ym2651y', 'modprobe accton_as7716_32x_cpld1', 'modprobe accton_as7716_32x_fan', 'modprobe accton_as7716_32x_leds', 'modprobe accton_as7716_32x_psu'] def driver_install(): global FORCE for i in range(0,len(kos)): status, output=log_os_system(kos[i], 1) if status: if FORCE==0: return status return 0 def driver_uninstall(): global FORCE for i in range(0,len(kos)): rm=kos[-(i+1)] lst=rm.split(\" \") if len(lst) > 2: del(lst[2:]) rm=\" \".join(lst) rm=rm.replace(\"modprobe\", \"modprobe -rq\") rm=rm.replace(\"insmod\", \"rmmod\") status, output=log_os_system(rm, 1) if status: if FORCE==0: return status return 0 def i2c_order_check(): tmp=\"echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-1/new_device\" status, output=log_os_system(tmp, 0) if not device_exist(): order=1 else: order=0 tmp=\"echo 0x70 > /sys/bus/i2c/devices/i2c-1/delete_device\" status, output=log_os_system(tmp, 0) return order def device_install(): global FORCE for i in range(0,len(mknod)): if mknod[i].find('pca954') !=-1: time.sleep(2) status, output=log_os_system(mknod[i], 1) if status: print(output) if FORCE==0: return status for i in range(0,len(sfp_map)): status, output=log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1) if status: print(output) if FORCE==0: return status status, output=log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1) if status: print(output) if FORCE==0: return status return def device_uninstall(): global FORCE status, output=log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0) if status==0: I2C_ORDER=1 else: \tI2C_ORDER=0 for i in range(0,len(sfp_map)): target=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\" status, output=log_os_system(\"echo 0x50 > \"+target, 1) if status: print(output) if FORCE==0: return status if I2C_ORDER==0: nodelist=mknod else: nodelist=mknod2 for i in range(len(nodelist)): target=nodelist[-(i+1)] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status return def system_ready(): if driver_inserted()==False: return False if not device_exist(): print(\"not device_exist()\") return False return True def do_install(): if driver_inserted()==False: status=driver_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" drivers detected....\") ir3570_check() if not device_exist(): status=device_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" devices detected....\") return def do_uninstall(): if not device_exist(): print(PROJECT_NAME.upper() +\" has no device installed....\") else: print(\"Removing device....\") status=device_uninstall() if status: if FORCE==0: return status if driver_inserted()==False: print(PROJECT_NAME.upper() +\" has no driver installed....\") else: print(\"Removing installed driver....\") status=driver_uninstall() if status: if FORCE==0: return status return def devices_info(): global DEVICE_NO global ALL_DEVICE global i2c_bus, hwmon_types for key in DEVICE_NO: ALL_DEVICE[key]={} for i in range(0,DEVICE_NO[key]): ALL_DEVICE[key][key+str(i+1)]=[] for key in i2c_bus: buses=i2c_bus[key] nodes=i2c_nodes[key] for i in range(0,len(buses)): for j in range(0,len(nodes)): if 'fan'==key: for k in range(0,DEVICE_NO[key]): node=key+str(k+1) path=i2c_prefix+buses[i]+\"/fan\"+str(k+1)+\"_\"+nodes[j] my_log(node+\": \"+path) ALL_DEVICE[key][node].append(path) elif 'sfp'==key: for k in range(0,DEVICE_NO[key]): node=key+str(k+1) path=i2c_prefix+str(sfp_map[k])+buses[i]+\"/\"+nodes[j] my_log(node+\": \"+path) ALL_DEVICE[key][node].append(path) else: node=key+str(i+1) path=i2c_prefix+buses[i]+\"/\"+nodes[j] my_log(node+\": \"+path) ALL_DEVICE[key][node].append(path) for key in hwmon_types: itypes=hwmon_types[key] nodes=hwmon_nodes[key] for i in range(0,len(itypes)): for j in range(0,len(nodes)): node=key+\"_\"+itypes[i] path=hwmon_prefix[key]+itypes[i]+\"/\"+nodes[j] my_log(node+\": \"+path) ALL_DEVICE[key][ key+str(i+1)].append(path) if DEBUG==True: for i in sorted(ALL_DEVICE.keys()): print((i+\": \")) for j in sorted(ALL_DEVICE[i].keys()): print((\" \"+j)) for k in(ALL_DEVICE[i][j]): print((\" \"+\" \"+k)) return def show_eeprom(index): if system_ready()==False: print(\"System's not ready.\") print(\"Please install first!\") return if len(ALL_DEVICE)==0: devices_info() node=ALL_DEVICE['sfp']['sfp'+str(index)][0] node=node.replace(node.split(\"/\")[-1], 'sfp_eeprom') ret, log=log_os_system(\"which hexdump\", 0) ret, log2=log_os_system(\"which busybox hexdump\", 0) if len(log): hex_cmd='hexdump' elif len(log2): hex_cmd=' busybox hexdump' else: log='Failed: no hexdump cmd!!' logging.info(log) print(log) return 1 print(node +\":\") ret, log=log_os_system(\"cat \"+node+\"| \"+hex_cmd+\" -C\", 1) if ret==0: print(log) else: print(\"**********device no found**********\") return def set_device(args): global DEVICE_NO global ALL_DEVICE if system_ready()==False: print(\"System's not ready.\") print(\"Please install first!\") return if len(ALL_DEVICE)==0: devices_info() if args[0]=='led': if int(args[1])>4: show_set_help() return for i in range(0,len(ALL_DEVICE['led'])): for k in(ALL_DEVICE['led']['led'+str(i+1)]): ret, log=log_os_system(\"echo \"+args[1]+\" >\"+k, 1) if ret: return ret elif args[0]=='fan': if int(args[1])>100: show_set_help() return node=ALL_DEVICE['fan1']['fan11'][0] node=node.replace(node.split(\"/\")[-1], 'fan1_duty_cycle_percentage') ret, log=log_os_system(\"cat \"+node, 1) if ret==0: print((\"Previous fan duty: \" +log.strip() +\"%\")) ret, log=log_os_system(\"echo \"+args[1]+\" >\"+node, 1) if ret==0: print((\"Current fan duty: \" +args[1] +\"%\")) return ret elif args[0]=='sfp': if int(args[1])> DEVICE_NO[args[0]] or int(args[1])==0: show_set_help() return if len(args)<2: show_set_help() return if int(args[2])>1: show_set_help() return for i in range(0,len(ALL_DEVICE[args[0]])): for j in ALL_DEVICE[args[0]][args[0]+str(args[1])]: if j.find('tx_disable')!=-1: ret, log=log_os_system(\"echo \"+args[2]+\" >\"+j, 1) if ret: return ret return def get_value(input): digit=re.findall('\\d+', input) return int(digit[0]) def device_traversal(): if system_ready()==False: print(\"System's not ready.\") print(\"Please install first!\") return if len(ALL_DEVICE)==0: devices_info() for i in sorted(ALL_DEVICE.keys()): print(\"============================================\") print((i.upper()+\": \")) print(\"============================================\") for j in sorted(list(ALL_DEVICE[i].keys()), key=get_value): print(\" \"+j+\":\", end=' ') for k in(ALL_DEVICE[i][j]): ret, log=log_os_system(\"cat \"+k, 0) func=k.split(\"/\")[-1].strip() func=re.sub(j+'_','',func,1) func=re.sub(i.lower()+'_','',func,1) if ret==0: print(func+\"=\"+log+\" \", end=' ') else: print(func+\"=\"+\"X\"+\" \", end=' ') print() print(\"----------------------------------------------------------------\") print() return def device_exist(): ret1, log=log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0) ret2, log=log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2016 Accton Networks, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean\ncommand:\n    install     : install drivers and generate related sysfs nodes\n    clean       : uninstall drivers and remove related sysfs nodes\n    show        : show all systen status\n    sff         : dump SFP eeprom\n    set         : change board setting with fan|led|sfp\n\"\"\"\n\nimport subprocess\nimport getopt\nimport sys\nimport logging\nimport re\nimport time\n\nPROJECT_NAME = 'as7716_32x'\nversion = '0.0.1'\nverbose = False\nDEBUG = False\nargs = []\nALL_DEVICE = {}\nDEVICE_NO = {'led':5, 'fan1':1, 'fan2':1,'fan3':1,'fan4':1,'fan5':1,'thermal':3, 'psu':2, 'sfp':54}\n\n\nled_prefix ='/sys/devices/platform/as7716_32x_led/leds/accton_'+PROJECT_NAME+'_led::'\nfan_prefix ='/sys/devices/platform/as7716_32x_'\nhwmon_types = {'led': ['diag','fan','loc','psu1','psu2'],\n               'fan1': ['fan'],\n               'fan2': ['fan'],\n               'fan3': ['fan'],\n               'fan4': ['fan'],\n               'fan5': ['fan'],\n              }\nhwmon_nodes = {'led': ['brightness'] ,\n               'fan1': ['fan_duty_cycle_percentage', 'fan1_fault', 'fan1_speed_rpm', 'fan1_direction', 'fanr1_fault', 'fanr1_speed_rpm'],\n               'fan2': ['fan_duty_cycle_percentage','fan2_fault', 'fan2_speed_rpm', 'fan2_direction', 'fanr2_fault', 'fanr2_speed_rpm'],\n               'fan3': ['fan_duty_cycle_percentage','fan3_fault', 'fan3_speed_rpm', 'fan3_direction', 'fanr3_fault', 'fanr3_speed_rpm'],\n               'fan4': ['fan4_duty_cycle_percentage','fan4_fault', 'fan4_speed_rpm', 'fan4_direction', 'fanr4_fault', 'fanr4_speed_rpm'],\n               'fan5': ['fan_duty_cycle_percentage','fan5_fault', 'fan5_speed_rpm', 'fan5_direction', 'fanr5_fault', 'fanr5_speed_rpm'],\n\t      }\nhwmon_prefix ={'led': led_prefix,\n               'fan1': fan_prefix,\n               'fan2': fan_prefix,\n               'fan3': fan_prefix,\n               'fan4': fan_prefix,\n               'fan5': fan_prefix,\n              }\n\ni2c_prefix = '/sys/bus/i2c/devices/'\ni2c_bus = {'thermal': ['10-0048','10-0049', '10-004a'] ,\n           'psu': ['17-0050','18-0053'],\n           'sfp': ['-0050']}\ni2c_nodes = {\n           'thermal': ['hwmon/hwmon*/temp1_input'] ,\n           'psu': ['psu_present ', 'psu_power_good']    ,\n           'sfp': ['sfp_is_present ', 'sfp_tx_disable']}\n\nsfp_map = [29, 30, 31, 32, 34, 33, 36, 35,\n          25, 26, 27, 28, 37, 38, 39, 40, \n          41, 42, 43, 44, 53, 54, 55, 56, \n          45, 46, 47, 48, 49, 50, 51, 52]\n\nmknod =[\n'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo as7716_32x_fan 0x66 > /sys/bus/i2c/devices/i2c-9/new_device',\n\n'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-10/new_device',\n'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-10/new_device',\n'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-10/new_device',\n\n'echo as7716_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-11/new_device',\n'echo accton_i2c_cpld 0x62 > /sys/bus/i2c/devices/i2c-12/new_device',\n'echo accton_i2c_cpld 0x64 > /sys/bus/i2c/devices/i2c-13/new_device',\n\n'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-2/new_device',\n\n# PSU-1\n'echo as7716_32x_psu1 0x53 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-18/new_device',\n\n# PSU-2\n'echo as7716_32x_psu2 0x50> /sys/bus/i2c/devices/i2c-17/new_device',\n'echo ym2651 0x58 > /sys/bus/i2c/devices/i2c-17/new_device',\n\n\n\n#EERPOM\n'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-1/new_device',\n]\n\nmknod2 =[\n'echo as7716_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo accton_i2c_cpld 0x61 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo accton_i2c_cpld 0x62 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-0/new_device',\n\n# PSU-1\n'echo as7716_32x_psu1 0x38 > /sys/bus/i2c/devices/i2c-57/new_device',\n'echo cpr_4011_4mxx  0x3c > /sys/bus/i2c/devices/i2c-57/new_device',\n'echo as7716_32x_psu1 0x50 > /sys/bus/i2c/devices/i2c-57/new_device',\n'echo ym2401 0x58 > /sys/bus/i2c/devices/i2c-57/new_device',\n\n# PSU-2\n'echo as7716_32x_psu2 0x3b > /sys/bus/i2c/devices/i2c-58/new_device',\n'echo cpr_4011_4mxx 0x3f > /sys/bus/i2c/devices/i2c-58/new_device',\n'echo as7716_32x_psu2 0x53 > /sys/bus/i2c/devices/i2c-58/new_device',\n'echo ym2401 0x5b > /sys/bus/i2c/devices/i2c-58/new_device',\n\n'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-61/new_device',\n'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-62/new_device',\n'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-63/new_device',\n\n#EERPOM\n'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-1/new_device',\n]\n\nFORCE = 0\nlogging.basicConfig(filename= PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG)\nlogging.basicConfig(level=logging.INFO)\n\n\nif DEBUG == True:\n    print(sys.argv[0])\n    print('ARGV      :', sys.argv[1:])\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n\n    if len(sys.argv)<2:\n        show_help()\n\n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:\n        print(options)\n        print(args)\n        print(len(sys.argv))\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n           do_install()\n        elif arg == 'clean':\n           do_uninstall()\n        elif arg == 'show':\n           device_traversal()\n        elif arg == 'sff':\n            if len(args)!=2:\n                show_eeprom_help()\n            elif int(args[1]) ==0 or int(args[1]) > DEVICE_NO['sfp']:\n                show_eeprom_help()\n            else:\n                show_eeprom(args[1])\n            return\n        elif arg == 'set':\n            if len(args)<3:\n                show_set_help()\n            else:\n                set_device(args[1:])\n            return\n        else:\n            show_help()\n\n\n    return 0\n\ndef show_help():\n    print(__doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]})\n    sys.exit(0)\n\ndef  show_set_help():\n    cmd =  sys.argv[0].split(\"/\")[-1]+ \" \"  + args[0]\n    print(cmd +\" [led|sfp|fan]\")\n    print(\"    use \\\"\"+ cmd + \" led 0-4 \\\"  to set led color\")\n    print(\"    use \\\"\"+ cmd + \" fan 0-100\\\" to set fan duty percetage\")\n    print(\"    use \\\"\"+ cmd + \" sfp 1-32 {0|1}\\\" to set sfp# tx_disable\")\n    sys.exit(0)\n\ndef dis_i2c_ir3570a(addr):\n    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef ir3570_check():\n    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n    try:\n        status, output = subprocess.getstatusoutput(cmd)\n        lines = output.split('\\n')\n        hn = re.findall(r'\\w+', lines[-1])\n        version = int(hn[1], 16)\n        if version == 0x24:  #only for ir3570a\n            ret = dis_i2c_ir3570a(4)\n        else:\n            ret = 0\n    except Exception as e:\n        print(\"Error on ir3570_check() e:\" + str(e))\n        return -1\n    return ret\n\ndef  show_eeprom_help():\n    cmd =  sys.argv[0].split(\"/\")[-1]+ \" \"  + args[0]\n    print(\"    use \\\"\"+ cmd + \" 1-32 \\\" to dump sfp# eeprom\")\n    sys.exit(0)\n\ndef my_log(txt):\n    if DEBUG == True:\n        print(\"[ACCTON DBG]: \"+txt)\n    return\n\ndef log_os_system(cmd, show):\n    logging.info('Run :'+cmd)\n    status = 1\n    output = \"\"\n    status, output = subprocess.getstatusoutput(cmd)\n    my_log (cmd +\"with result:\" + str(status))\n    my_log (\"cmd:\" + cmd)\n    my_log (\"      output:\"+output)\n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print(('Failed :'+cmd))\n    return  status, output\n\ndef driver_inserted():\n    ret, lsmod = log_os_system(\"ls /sys/module/*accton*\", 0)\n    logging.info('mods:'+lsmod)\n    if ret :\n        return False\n    else :\n        return True\n\n#'modprobe cpr_4011_4mxx',\n\nkos = [\n'depmod -ae',\n'modprobe i2c_dev',\n'modprobe i2c_mux_pca954x force_deselect_on_exit=1',\n'modprobe accton_i2c_cpld',\n'modprobe cpr_4011_4mxx',\n'modprobe ym2651y',\n'modprobe accton_as7716_32x_cpld1',\n'modprobe accton_as7716_32x_fan',\n'modprobe accton_as7716_32x_leds',\n'modprobe accton_as7716_32x_psu']\n\ndef driver_install():\n    global FORCE\n    for i in range(0,len(kos)):\n        status, output = log_os_system(kos[i], 1)\n        if status:\n            if FORCE == 0:\n                return status\n    return 0\n\ndef driver_uninstall():\n    global FORCE\n    for i in range(0,len(kos)):\n        #remove parameter if any\n        rm = kos[-(i+1)]\n        lst = rm.split(\" \")\n        if len(lst) > 2:\n            del(lst[2:])\n        rm = \" \".join(lst)\n\n        #Change to removing commands\n        rm = rm.replace(\"modprobe\", \"modprobe -rq\")\n        rm = rm.replace(\"insmod\", \"rmmod\")\n        status, output = log_os_system(rm, 1)\n        if status:\n            if FORCE == 0:\n                return status\n    return 0\n\n\n\ndef i2c_order_check():\n    # i2c bus 0 and 1 might be installed in different order.\n    # Here check if 0x76 is exist @ i2c-0\n    tmp = \"echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-1/new_device\"\n    status, output = log_os_system(tmp, 0)\n    if not device_exist():\n        order = 1\n    else:\n        order = 0\n    tmp = \"echo 0x70 > /sys/bus/i2c/devices/i2c-1/delete_device\"\n    status, output = log_os_system(tmp, 0)\n    return order\n\ndef device_install():\n    global FORCE\n\n    for i in range(0,len(mknod)):\n        #for pca932x need times to built new i2c buses\n        if mknod[i].find('pca954') != -1:\n            time.sleep(2)\n        \n        status, output = log_os_system(mknod[i], 1)        \n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n    \n    for i in range(0,len(sfp_map)):\n        status, output =log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n        status, output =log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n    return\n\ndef device_uninstall():\n    global FORCE\n\n    status, output =log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0)\n    if status==0:\n        I2C_ORDER=1\n    else:\n    \tI2C_ORDER=0\n\n    for i in range(0,len(sfp_map)):\n        target = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\"\n        status, output =log_os_system(\"echo 0x50 > \"+ target, 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    if I2C_ORDER==0:\n        nodelist = mknod\n    else:\n        nodelist = mknod2\n\n    for i in range(len(nodelist)):\n        target = nodelist[-(i+1)]\n        temp = target.split()\n        del temp[1]\n        temp[-1] = temp[-1].replace('new_device', 'delete_device')\n        status, output = log_os_system(\" \".join(temp), 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    return\n\ndef system_ready():\n    if driver_inserted() == False:        \n        return False\n    if not device_exist():\n        print(\"not device_exist()\")\n        return False\n    return True\n\ndef do_install():\n    if driver_inserted() == False:\n        status = driver_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print(PROJECT_NAME.upper()+\" drivers detected....\")\n\n    ir3570_check()\n\n    if not device_exist():\n        status = device_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print(PROJECT_NAME.upper()+\" devices detected....\")\n    return\n\ndef do_uninstall():\n    if not device_exist():\n        print(PROJECT_NAME.upper() +\" has no device installed....\")\n    else:\n        print(\"Removing device....\")\n        status = device_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    if driver_inserted()== False :\n        print(PROJECT_NAME.upper() +\" has no driver installed....\")\n    else:\n        print(\"Removing installed driver....\")\n        status = driver_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    return\n\ndef devices_info():\n    global DEVICE_NO\n    global ALL_DEVICE\n    global i2c_bus, hwmon_types\n    for key in DEVICE_NO:\n        ALL_DEVICE[key]= {}\n        for i in range(0,DEVICE_NO[key]):\n            ALL_DEVICE[key][key+str(i+1)] = []\n\n    for key in i2c_bus:\n        buses = i2c_bus[key]\n        nodes = i2c_nodes[key]\n        for i in range(0,len(buses)):\n            for j in range(0,len(nodes)):\n                if  'fan' == key:\n                    for k in range(0,DEVICE_NO[key]):\n                        node = key+str(k+1)\n                        path = i2c_prefix+ buses[i]+\"/fan\"+str(k+1)+\"_\"+ nodes[j]\n                        my_log(node+\": \"+ path)\n                        ALL_DEVICE[key][node].append(path)\n                elif  'sfp' == key:\n                    for k in range(0,DEVICE_NO[key]):\n                        node = key+str(k+1)\n                        path = i2c_prefix+ str(sfp_map[k])+ buses[i]+\"/\"+ nodes[j]\n                        my_log(node+\": \"+ path)\n                        ALL_DEVICE[key][node].append(path)\n                else:\n                    node = key+str(i+1)\n                    path = i2c_prefix+ buses[i]+\"/\"+ nodes[j]\n                    my_log(node+\": \"+ path)\n                    ALL_DEVICE[key][node].append(path)\n\n    for key in hwmon_types:\n        itypes = hwmon_types[key]\n        nodes = hwmon_nodes[key]\n        for i in range(0,len(itypes)):\n            for j in range(0,len(nodes)):\n                node = key+\"_\"+itypes[i]\n                path = hwmon_prefix[key]+ itypes[i]+\"/\"+ nodes[j]\n                my_log(node+\": \"+ path)\n                ALL_DEVICE[key][ key+str(i+1)].append(path)\n\n    #show dict all in the order\n    if DEBUG == True:\n        for i in sorted(ALL_DEVICE.keys()):\n            print((i+\": \"))\n            for j in sorted(ALL_DEVICE[i].keys()):\n                print((\"   \"+j))\n                for k in (ALL_DEVICE[i][j]):\n                    print((\"   \"+\"   \"+k))\n    return\n\ndef show_eeprom(index):\n    if system_ready()==False:\n        print(\"System's not ready.\")\n        print(\"Please install first!\")\n        return\n\n    if len(ALL_DEVICE)==0:\n        devices_info()\n    node = ALL_DEVICE['sfp'] ['sfp'+str(index)][0]\n    node = node.replace(node.split(\"/\")[-1], 'sfp_eeprom')\n    # check if got hexdump command in current environment\n    ret, log = log_os_system(\"which hexdump\", 0)\n    ret, log2 = log_os_system(\"which busybox hexdump\", 0)\n    if len(log):\n        hex_cmd = 'hexdump'\n    elif len(log2):\n        hex_cmd = ' busybox hexdump'\n    else:\n        log = 'Failed : no hexdump cmd!!'\n        logging.info(log)\n        print(log)\n        return 1\n\n    print(node + \":\")\n    ret, log = log_os_system(\"cat \"+node+\"| \"+hex_cmd+\" -C\", 1)\n    if ret==0:\n        print(log)\n    else:\n        print(\"**********device no found**********\")\n    return\n\ndef set_device(args):\n    global DEVICE_NO\n    global ALL_DEVICE\n    if system_ready()==False:\n        print(\"System's not ready.\")\n        print(\"Please install first!\")\n        return\n\n    if len(ALL_DEVICE)==0:\n        devices_info()\n\n    if args[0]=='led':\n        if int(args[1])>4:\n            show_set_help()\n            return\n        #print  ALL_DEVICE['led']\n        for i in range(0,len(ALL_DEVICE['led'])):\n            for k in (ALL_DEVICE['led']['led'+str(i+1)]):\n                ret, log = log_os_system(\"echo \"+args[1]+\" >\"+k, 1)\n                if ret:\n                    return ret\n    elif args[0]=='fan':\n        if int(args[1])>100:\n            show_set_help()\n            return\n        #print  ALL_DEVICE['fan']\n        #fan1~6 is all fine, all fan share same setting\n        node = ALL_DEVICE['fan1'] ['fan11'][0]\n        node = node.replace(node.split(\"/\")[-1], 'fan1_duty_cycle_percentage')\n        ret, log = log_os_system(\"cat \"+ node, 1)\n        if ret==0:\n            print((\"Previous fan duty: \" + log.strip() +\"%\"))\n        ret, log = log_os_system(\"echo \"+args[1]+\" >\"+node, 1)\n        if ret==0:\n            print((\"Current fan duty: \" + args[1] +\"%\"))\n        return ret\n    elif args[0]=='sfp':\n        if int(args[1])> DEVICE_NO[args[0]] or int(args[1])==0:\n            show_set_help()\n            return\n        if len(args)<2:\n            show_set_help()\n            return\n\n        if int(args[2])>1:\n            show_set_help()\n            return\n\n        #print  ALL_DEVICE[args[0]]\n        for i in range(0,len(ALL_DEVICE[args[0]])):\n            for j in ALL_DEVICE[args[0]][args[0]+str(args[1])]:\n                if j.find('tx_disable')!= -1:\n                    ret, log = log_os_system(\"echo \"+args[2]+\" >\"+ j, 1)\n                    if ret:\n                        return ret\n\n    return\n\n#get digits inside a string.\n#Ex: 31 for \"sfp31\"\ndef get_value(input):\n    digit = re.findall('\\d+', input)\n    return int(digit[0])\n\ndef device_traversal():\n    if system_ready()==False:\n        print(\"System's not ready.\")\n        print(\"Please install first!\")\n        return\n\n    if len(ALL_DEVICE)==0:\n        devices_info()\n    for i in sorted(ALL_DEVICE.keys()):\n        print(\"============================================\")\n        print((i.upper()+\": \"))\n        print(\"============================================\")\n\n        for j in sorted(list(ALL_DEVICE[i].keys()), key=get_value):\n            print(\"   \"+j+\":\", end=' ')\n            for k in (ALL_DEVICE[i][j]):\n                ret, log = log_os_system(\"cat \"+k, 0)\n                func = k.split(\"/\")[-1].strip()\n                func = re.sub(j+'_','',func,1)\n                func = re.sub(i.lower()+'_','',func,1)\n                if ret==0:\n                    print(func+\"=\"+log+\" \", end=' ')\n                else:\n                    print(func+\"=\"+\"X\"+\" \", end=' ')\n            print()\n            print(\"----------------------------------------------------------------\")\n\n\n        print()\n    return\n\ndef device_exist():\n    ret1, log = log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0)\n    ret2, log = log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py": {"changes": [{"diff": "\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py", "badparts": ["               os.system('reboot')           "], "goodparts": ["               subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}], "source": "\n try: import os import getopt import sys import logging import logging.config import logging.handlers import time from as7726_32x.fanutil import FanUtil from as7726_32x.thermalutil import ThermalUtil except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as7726_32x_monitor' global log_file global log_level class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False fan_policy_state=1 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0, 0, 0, 0, 0] temp_test_data=0 class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 logging.debug('temp=%d', temp) for i in range(0, len(policy)): if temp > policy[i][2]: if temp <=policy[i][3]: state=i logging.debug('temp=%d >=policy[%d][2]=%d, temp=%d < policy[%d][3]=%d', temp, i, policy[i][2], temp, i, policy[i][3]) logging.debug('fan_state=%d', state) break return state def manage_fans(self): global fan_policy_state global fan_fail global test_temp global test_temp_list global alarm_state global temp_test_data LEVEL_FAN_DEF=0 LEVEL_FAN_MID=1 LEVEL_FAN_MAX=2 LEVEL_TEMP_HIGH=3 LEVEL_TEMP_CRITICAL=4 fan_policy_f2b={ LEVEL_FAN_DEF: [38, 0x4, 0, 38000], LEVEL_FAN_MID: [63, 0x6, 38000, 46000], LEVEL_FAN_MAX: [100, 0xE, 46000, 58000], LEVEL_TEMP_HIGH: [100, 0xE, 58000, 66000], LEVEL_TEMP_CRITICAL:[100, 0xE, 58000, 200000], } fan_policy_b2f={ LEVEL_FAN_DEF: [38, 0x4, 0, 34000], LEVEL_FAN_MID: [63, 0x8, 34000, 44000], LEVEL_FAN_MAX: [100, 0xE, 44000, 59000], LEVEL_TEMP_HIGH: [100, 0xE, 59000, 67000], LEVEL_TEMP_CRITICAL:[100, 0xE, 59000, 200000], } fan_policy=fan_policy_f2b thermal=ThermalUtil() fan=FanUtil() fan_dir=fan.get_fan_dir(1) if fan_dir==1: fan_dri=1 else: fan_policy=fan_policy_b2f ori_pwm=fan.get_fan_duty_cycle() new_pwm=0 logging.debug('fan_dir=%d, ori_pwm=%d', fan_dir, ori_pwm) logging.debug('test_temp=%d', test_temp) if test_temp==0: temp1=thermal._get_thermal_val(1) temp2=thermal._get_thermal_val(2) temp3=thermal._get_thermal_val(3) temp4=thermal._get_thermal_val(4) temp5=thermal._get_thermal_val(5) else: temp1=test_temp_list[0] temp2=test_temp_list[1] temp3=test_temp_list[2] temp4=test_temp_list[3] temp5=test_temp_list[4] fan_fail=0 if temp3==0: temp_get=50000 logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%') elif temp4==0: temp_get=50000 logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%') else: temp_get=(temp3 +temp4)/2 ori_state=fan_policy_state if test_temp!=0: temp_test_data=temp_test_data+1000 temp_get=temp_get +temp_test_data logging.debug('Unit test:temp_get=%d', temp_get) fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy) logging.debug('lm75_48=%d, lm75_49=%d, lm75_4a=%d, lm_4b=%d, lm_4c=%d', temp1,temp2,temp3,temp4,temp5) logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state) new_pwm=fan_policy[fan_policy_state][0] if fan_fail==0: logging.debug('new_fan_cycle=%d', new_pwm) if fan_fail==0: if new_pwm!=ori_pwm: fan.set_fan_duty_cycle(new_pwm) logging.info('Set fan speed from %d to %d', ori_pwm, new_pwm) for i in range(fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1): if fan.get_fan_status(i)==0: new_pwm=100 logging.debug('fan_%d fail, set pwm to 100',i) if test_temp==0: fan_fail=1 fan.set_fan_duty_cycle(new_pwm) break else: fan_fail=0 new_state=fan_policy_state if ori_state==LEVEL_FAN_DEF: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected, reboot DUT') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MID: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MAX: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if alarm_state==1: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_HIGH: if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if new_state <=LEVEL_FAN_MID: logging.warning('Alarm for temperature high is cleared') alarm_state=0 if new_state <=LEVEL_FAN_MAX: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_CRITICAL: if new_state <=LEVEL_FAN_MAX: logging.warning('Alarm for temperature critical is cleared') return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv,'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv)!=7: print(\"temp test, need input six temp\") return 0 i=0 for x in range(2, 7): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) fan=FanUtil() fan.set_fan_duty_cycle(38) print(\"set default fan speed to 37.5%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(5) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2017 Accton Technology Corporation\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    mm/dd/yyyy (A.D.)#   \n#    4/20/2018: Jostar modify for as7726_32x\n#    12/03/2018:Jostar modify for as7726_32x thermal plan\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import getopt\n    import sys\n    import logging\n    import logging.config\n    import logging.handlers\n    import time  # this is only being used as part of the example\n    from as7726_32x.fanutil import FanUtil\n    from as7726_32x.thermalutil import ThermalUtil\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as7726_32x_monitor'\n\nglobal log_file\nglobal log_level\n\n \n#  Air Flow Front to Back :\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 <=38C : Keep 37.5%(0x04) Fan speed\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 38C : Change Fan speed from 37.5%(0x04) to 62.5%(0x08)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 46C : Change Fan speed from 62.5%(0x08) to 100%(0x0E)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 58C : Send alarm message\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 66C : Shut down system\n#  One Fan fail : Change Fan speed to 100%(0x0E)\n\n\n#  Air Flow Back to Front :\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 <=34C : Keep 37.5%(0x04) Fan speed\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 34C : Change Fan speed from 37.5%(0x04) to 62.5%(0x08)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 44C : Change Fan speed from 62.5%(0x08) to 100%(0x0E)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 59C : Send alarm message\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 67C : Shut down system\n#  One Fan fail:  Change Fan speed to 100%(0x0E)\n#  sensor_LM75_CPU == sensor_LM75_4B\n \n     \nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n \n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n     \n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args: # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\n\nfan_policy_state=1\nfan_fail=0\nalarm_state = 0 #0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0, 0, 0, 0, 0]\ntemp_test_data=0\n# Make a class we can use to capture stdout and sterr in the log\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm=0\n    ori_pwm = 0\n    default_pwm=0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format= '[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = handler = logging.handlers.SysLogHandler(address = '/dev/log')\n        sys_handler.setLevel(logging.WARNING)       \n        logging.getLogger('').addHandler(sys_handler)\n          \n    def get_state_from_fan_policy(self, temp, policy):\n        state=0\n        \n        logging.debug('temp=%d', temp)\n        for i in range(0, len(policy)):\n            if temp > policy[i][2]:\n                if temp <= policy[i][3]:\n                    state =i\n                    logging.debug ('temp=%d >= policy[%d][2]=%d,  temp=%d < policy[%d][3]=%d' , temp, i, policy[i][2], temp, i, policy[i][3])\n                    logging.debug ('fan_state=%d', state)\n                    break\n        \n        return state\n\n    def manage_fans(self):\n       \n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list        \n        global alarm_state\n        global temp_test_data\n        \n        LEVEL_FAN_DEF=0\n        LEVEL_FAN_MID=1       \n        LEVEL_FAN_MAX=2\n        LEVEL_TEMP_HIGH=3\n        LEVEL_TEMP_CRITICAL=4\n        \n        fan_policy_f2b = {\n           LEVEL_FAN_DEF:       [38,  0x4, 0,     38000],\n           LEVEL_FAN_MID:       [63,  0x6, 38000, 46000],\n           LEVEL_FAN_MAX:       [100, 0xE, 46000, 58000],\n           LEVEL_TEMP_HIGH:     [100, 0xE, 58000, 66000],\n           LEVEL_TEMP_CRITICAL: [100, 0xE, 58000, 200000],\n        }\n        fan_policy_b2f = {\n           LEVEL_FAN_DEF:       [38,  0x4, 0,     34000],\n           LEVEL_FAN_MID:       [63,  0x8, 34000, 44000],\n           LEVEL_FAN_MAX:       [100, 0xE, 44000, 59000],\n           LEVEL_TEMP_HIGH:     [100, 0xE, 59000, 67000],\n           LEVEL_TEMP_CRITICAL: [100, 0xE, 59000, 200000],\n        }\n        \n        fan_policy = fan_policy_f2b\n        \n        thermal = ThermalUtil()\n        fan = FanUtil()\n        fan_dir=fan.get_fan_dir(1)            \n        if fan_dir == 1:\n            fan_dri=1 #something wrong, set fan_dir to default val\n        else:\n            fan_policy = fan_policy_b2f\n        \n        ori_pwm=fan.get_fan_duty_cycle()\n        new_pwm=0  \n        logging.debug('fan_dir=%d, ori_pwm=%d', fan_dir, ori_pwm)\n        logging.debug('test_temp=%d', test_temp)\n        if test_temp==0: \n            temp1 = thermal._get_thermal_val(1)\n            temp2 = thermal._get_thermal_val(2)\n            temp3 = thermal._get_thermal_val(3)\n            temp4 = thermal._get_thermal_val(4)\n            temp5 = thermal._get_thermal_val(5)            \n        else:\n            temp1 = test_temp_list[0]\n            temp2 = test_temp_list[1]\n            temp3 = test_temp_list[2]\n            temp4 = test_temp_list[3]\n            temp5 = test_temp_list[4]            \n            fan_fail=0\n       \n        if temp3==0:\n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%')\n        elif temp4==0:        \n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%')\n        else:    \n            temp_get= (temp3 + temp4)/2  # Use (sensor_LM75_4a + sensor_LM75_4b) /2 \n        ori_state=fan_policy_state\n        \n        if test_temp!=0:\n            temp_test_data=temp_test_data+1000\n            temp_get = temp_get + temp_test_data\n            logging.debug('Unit test:temp_get=%d', temp_get)\n        \n        fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy)\n                                \n        logging.debug('lm75_48=%d, lm75_49=%d, lm75_4a=%d, lm_4b=%d, lm_4c=%d', temp1,temp2,temp3,temp4,temp5)\n        logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state)\n        new_pwm = fan_policy[fan_policy_state][0]\n        if fan_fail==0:\n            logging.debug('new_fan_cycle=%d', new_pwm)\n        \n        if fan_fail==0:\n            if new_pwm!=ori_pwm:\n                fan.set_fan_duty_cycle(new_pwm)\n                logging.info('Set fan speed from %d to %d', ori_pwm, new_pwm)\n        \n        #Check Fan status\n        for i in range (fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1):\n            if fan.get_fan_status(i)==0:\n                new_pwm=100\n                logging.debug('fan_%d fail, set pwm to 100',i)                \n                if test_temp==0:\n                    fan_fail=1\n                    fan.set_fan_duty_cycle(new_pwm)\n                    break\n            else:\n                fan_fail=0\n        \n        new_state = fan_policy_state\n          \n        if ori_state==LEVEL_FAN_DEF:            \n           if new_state==LEVEL_TEMP_HIGH:\n               if alarm_state==0:\n                   logging.warning('Alarm for temperature high is detected')\n               alarm_state=1\n           if new_state==LEVEL_TEMP_CRITICAL:\n               logging.critical('Alarm for temperature critical is detected, reboot DUT')\n               time.sleep(2)\n               os.system('reboot')           \n        if ori_state==LEVEL_FAN_MID:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state=1 \n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n        if ori_state==LEVEL_FAN_MAX:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected') \n                alarm_state=1\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n            if alarm_state==1:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_HIGH:\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n            if new_state <= LEVEL_FAN_MID:\n                logging.warning('Alarm for temperature high is cleared')\n                alarm_state=0\n            if new_state <= LEVEL_FAN_MAX:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_CRITICAL:            \n            if new_state <= LEVEL_FAN_MAX:\n                logging.warning('Alarm for temperature critical is cleared')\n      \n        return True\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv,'hdlt:',['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg            \n        \n        if sys.argv[1]== '-t':\n            if len(sys.argv)!=7:\n                print(\"temp test, need input six temp\")\n                return 0\n            \n            i=0\n            for x in range(2, 7):\n               test_temp_list[i]= int(sys.argv[x])*1000\n               i=i+1\n            test_temp = 1   \n            log_level = logging.DEBUG\n            print(test_temp_list)                       \n    \n    fan = FanUtil()\n    fan.set_fan_duty_cycle(38)\n    print(\"set default fan speed to 37.5%\")\n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(5)\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    \n"}, "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py": {"changes": [{"diff": "\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py", "badparts": ["               os.system('reboot')           "], "goodparts": ["               subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high i", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}], "source": "\n try: import os import sys import getopt import logging import logging.config import logging.handlers import time from sonic_platform import platform except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as7726_32x_pddf_monitor' platform_chassis=None class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False fan_policy_state=1 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0, 0, 0, 0, 0] temp_test_data=0 class device_monitor(object): def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 logging.debug('temp=%d', temp) for i in range(0, len(policy)): if temp > policy[i][2]: if temp <=policy[i][3]: state=i logging.debug('temp=%d >=policy[%d][2]=%d, temp=%d < policy[%d][3]=%d', temp, i, policy[i][2], temp, i, policy[i][3]) logging.debug('fan_state=%d', state) break return state def manage_fans(self): global fan_policy_state global fan_fail global test_temp global test_temp_list global alarm_state global temp_test_data global platform_chassis LEVEL_FAN_DEF=0 LEVEL_FAN_MID=1 LEVEL_FAN_MAX=2 LEVEL_TEMP_HIGH=3 LEVEL_TEMP_CRITICAL=4 FAN_NUM_MAX=6 FANS_PERTRAY=2 fan_policy_f2b={ LEVEL_FAN_DEF: [38, 0x4, 0, 38000], LEVEL_FAN_MID: [63, 0x6, 38000, 46000], LEVEL_FAN_MAX: [100, 0xE, 46000, 58000], LEVEL_TEMP_HIGH: [100, 0xE, 58000, 66000], LEVEL_TEMP_CRITICAL:[100, 0xE, 58000, 200000], } fan_policy_b2f={ LEVEL_FAN_DEF: [38, 0x4, 0, 34000], LEVEL_FAN_MID: [63, 0x8, 34000, 44000], LEVEL_FAN_MAX: [100, 0xE, 44000, 59000], LEVEL_TEMP_HIGH: [100, 0xE, 59000, 67000], LEVEL_TEMP_CRITICAL:[100, 0xE, 59000, 200000], } fan_dir=platform_chassis.get_fan(0).get_direction() if fan_dir=='EXHAUST': fan_policy=fan_policy_f2b else: fan_policy=fan_policy_b2f ori_perc=platform_chassis.get_fan(0).get_speed() logging.debug('fan_dir=%s, ori_perc=%d, test_temp=%d', fan_dir, ori_perc, test_temp) if test_temp==0: temp4=platform_chassis.get_thermal(3).get_temperature()*1000 temp5=platform_chassis.get_thermal(4).get_temperature()*1000 else: temp4=test_temp_list[3] temp5=test_temp_list[4] fan_fail=0 if temp4==0: temp_get=50000 logging.debug('lm75_4a detect fail, so set temp_get=50000, let fan to 75%') elif temp5==0: temp_get=50000 logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%') else: temp_get=(temp4 +temp5)/2 ori_state=fan_policy_state if test_temp!=0: temp_test_data=temp_test_data+1000 temp_get=temp_get +temp_test_data logging.debug('Unit test:temp_get=%d', temp_get) fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy) logging.debug('lm75_4a=%d, lm_4b=%d', temp4,temp5) logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state) new_perc=fan_policy[fan_policy_state][0] if fan_fail==0: logging.debug('new_fan_cycle=%d', new_perc) if fan_fail==0: if new_perc!=ori_perc: platform_chassis.get_fan(0).set_speed(new_perc) logging.info('Set fan speed from %d to %d', ori_perc, new_perc) for i in range(FAN_NUM_MAX*FANS_PERTRAY): if not platform_chassis.get_fan(i).get_status() or not platform_chassis.get_fan(i).get_speed_rpm(): logging.debug('fan-%d status=%d, rpm=%d', i+1, platform_chassis.get_fan(i).get_status(), platform_chassis.get_fan(i).get_speed_rpm()) new_perc=100 logging.debug('fan_%d fail, set new_perc to 100',i+1) if test_temp==0: fan_fail=1 platform_chassis.get_fan(0).set_speed(new_perc) break else: fan_fail=0 new_state=fan_policy_state if ori_state==LEVEL_FAN_DEF: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected, reboot DUT') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MID: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MAX: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if alarm_state==1: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_HIGH: if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if new_state <=LEVEL_FAN_MID: logging.warning('Alarm for temperature high is cleared') alarm_state=0 if new_state <=LEVEL_FAN_MAX: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_CRITICAL: if new_state <=LEVEL_FAN_MAX: logging.warning('Alarm for temperature critical is cleared') return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv,'hdlt:',['lfile=']) except getopt.GetoptError: print(('Usage: %s[-d][-l <log_file>]' % sys.argv[0])) return 0 for opt, arg in opts: if opt=='-h': print(('Usage: %s[-d][-l <log_file>]' % sys.argv[0])) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv)!=7: print(\"temp test, need input six temp\") return 0 i=0 for x in range(2, 7): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) global platform_chassis platform_chassis=platform.Platform().get_chassis() platform_chassis.get_fan(0).set_speed(38) print(\"set default fan speed to 37.5%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(10) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2017 Accton Technology Corporation\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    mm/dd/yyyy (A.D.)#   \n#    4/20/2018: Jostar modify for as7726_32x\n#    12/03/2018:Jostar modify for as7726_32x thermal plan\n#    11/16/2020:Jostar modify for as7726_32x thermal plan based on PDDF\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import sys\n    import getopt\n    import logging\n    import logging.config\n    import logging.handlers\n    import time\n    from sonic_platform import platform\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as7726_32x_pddf_monitor'\n\nplatform_chassis = None\n \n#  Air Flow Front to Back :\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 <=38C : Keep 37.5%(0x04) Fan speed\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 38C : Change Fan speed from 37.5%(0x04) to 62.5%(0x08)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 46C : Change Fan speed from 62.5%(0x08) to 100%(0x0E)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 58C : Send alarm message\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 66C : Shut down system\n#  One Fan fail : Change Fan speed to 100%(0x0E)\n\n\n#  Air Flow Back to Front :\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 <=34C : Keep 37.5%(0x04) Fan speed\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 34C : Change Fan speed from 37.5%(0x04) to 62.5%(0x08)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 44C : Change Fan speed from 62.5%(0x08) to 100%(0x0E)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 59C : Send alarm message\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 67C : Shut down system\n#  One Fan fail:  Change Fan speed to 100%(0x0E)\n#  sensor_LM75_CPU == sensor_LM75_4B\n \n     \nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n \n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n     \n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args: # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\n\nfan_policy_state=1\nfan_fail=0\nalarm_state = 0 #0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0, 0, 0, 0, 0]\ntemp_test_data=0\n\n\n# Make a class we can use to capture stdout and sterr in the log\nclass device_monitor(object):\n        \n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format= '[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = logging.handlers.SysLogHandler(address = '/dev/log')\n        sys_handler.setLevel(logging.WARNING)       \n        logging.getLogger('').addHandler(sys_handler)\n          \n    def get_state_from_fan_policy(self, temp, policy):\n        state=0\n        \n        logging.debug('temp=%d', temp)\n        for i in range(0, len(policy)):\n            if temp > policy[i][2]:\n                if temp <= policy[i][3]:\n                    state =i\n                    logging.debug ('temp=%d >= policy[%d][2]=%d,  temp=%d < policy[%d][3]=%d' , temp, i, policy[i][2], temp, i, policy[i][3])\n                    logging.debug ('fan_state=%d', state)\n                    break\n        \n        return state\n\n    def manage_fans(self):\n       \n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list        \n        global alarm_state\n        global temp_test_data\n        global platform_chassis\n        \n        LEVEL_FAN_DEF=0\n        LEVEL_FAN_MID=1       \n        LEVEL_FAN_MAX=2\n        LEVEL_TEMP_HIGH=3\n        LEVEL_TEMP_CRITICAL=4\n        FAN_NUM_MAX = 6\n        FANS_PERTRAY=2\n        \n        fan_policy_f2b = {\n           LEVEL_FAN_DEF:       [38,  0x4, 0,     38000],\n           LEVEL_FAN_MID:       [63,  0x6, 38000, 46000],\n           LEVEL_FAN_MAX:       [100, 0xE, 46000, 58000],\n           LEVEL_TEMP_HIGH:     [100, 0xE, 58000, 66000],\n           LEVEL_TEMP_CRITICAL: [100, 0xE, 58000, 200000],\n        }\n        fan_policy_b2f = {\n           LEVEL_FAN_DEF:       [38,  0x4, 0,     34000],\n           LEVEL_FAN_MID:       [63,  0x8, 34000, 44000],\n           LEVEL_FAN_MAX:       [100, 0xE, 44000, 59000],\n           LEVEL_TEMP_HIGH:     [100, 0xE, 59000, 67000],\n           LEVEL_TEMP_CRITICAL: [100, 0xE, 59000, 200000],\n        }\n        \n        fan_dir= platform_chassis.get_fan(0).get_direction()\n        if fan_dir == 'EXHAUST':\n            fan_policy = fan_policy_f2b\n        else:\n            fan_policy = fan_policy_b2f\n        \n        ori_perc=platform_chassis.get_fan(0).get_speed()\n        #ori_perc=fan.get_fan_duty_cycle()\n        logging.debug('fan_dir=%s, ori_perc=%d, test_temp=%d', fan_dir, ori_perc, test_temp)\n        if test_temp==0:\n            temp4 = platform_chassis.get_thermal(3).get_temperature()*1000\n            temp5 = platform_chassis.get_thermal(4).get_temperature()*1000\n        else:\n            temp4 = test_temp_list[3]\n            temp5 = test_temp_list[4]            \n            fan_fail=0\n        \n        if temp4==0:\n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_4a detect fail, so set temp_get=50000, let fan to 75%')\n        elif temp5==0:        \n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%')\n        else:    \n            temp_get= (temp4 + temp5)/2  # Use (sensor_LM75_4a + sensor_LM75_4b) /2 \n            \n        ori_state=fan_policy_state\n        \n        if test_temp!=0:\n            temp_test_data=temp_test_data+1000\n            temp_get = temp_get + temp_test_data\n            logging.debug('Unit test:temp_get=%d', temp_get)\n        \n        fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy)\n                        \n        logging.debug('lm75_4a=%d, lm_4b=%d', temp4,temp5)\n        logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state)\n        new_perc = fan_policy[fan_policy_state][0]\n        if fan_fail==0:\n            logging.debug('new_fan_cycle=%d', new_perc)\n        \n        if fan_fail==0:\n            if new_perc!=ori_perc:\n                platform_chassis.get_fan(0).set_speed(new_perc)\n                logging.info('Set fan speed from %d to %d', ori_perc, new_perc)\n        \n        #Check Fan status\n        for i in range(FAN_NUM_MAX*FANS_PERTRAY):\n            if not platform_chassis.get_fan(i).get_status() or not platform_chassis.get_fan(i).get_speed_rpm():\n                logging.debug('fan-%d status=%d, rpm=%d', i+1, platform_chassis.get_fan(i).get_status(), platform_chassis.get_fan(i).get_speed_rpm())\n                new_perc=100\n                logging.debug('fan_%d fail, set new_perc to 100',i+1)                \n                if test_temp==0:\n                    fan_fail=1\n                    platform_chassis.get_fan(0).set_speed(new_perc)\n                    break\n            else:\n                fan_fail=0\n      \n        new_state = fan_policy_state\n        \n        if ori_state==LEVEL_FAN_DEF:            \n           if new_state==LEVEL_TEMP_HIGH:\n               if alarm_state==0:\n                   logging.warning('Alarm for temperature high is detected')\n               alarm_state=1\n           if new_state==LEVEL_TEMP_CRITICAL:\n               logging.critical('Alarm for temperature critical is detected, reboot DUT')\n               time.sleep(2)\n               os.system('reboot')           \n        if ori_state==LEVEL_FAN_MID:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state=1 \n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n        if ori_state==LEVEL_FAN_MAX:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected') \n                alarm_state=1\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n            if alarm_state==1:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_HIGH:\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n            if new_state <= LEVEL_FAN_MID:\n                logging.warning('Alarm for temperature high is cleared')\n                alarm_state=0\n            if new_state <= LEVEL_FAN_MAX:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_CRITICAL:            \n            if new_state <= LEVEL_FAN_MAX:\n                logging.warning('Alarm for temperature critical is cleared')\n      \n        return True\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv,'hdlt:',['lfile='])\n        except getopt.GetoptError:\n            print(('Usage: %s [-d] [-l <log_file>]' % sys.argv[0]))\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print(('Usage: %s [-d] [-l <log_file>]' % sys.argv[0]))\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg            \n        \n        if sys.argv[1]== '-t':\n            if len(sys.argv)!=7:\n                print(\"temp test, need input six temp\")\n                return 0\n            \n            i=0\n            for x in range(2, 7):\n               test_temp_list[i]= int(sys.argv[x])*1000\n               i=i+1\n            test_temp = 1   \n            log_level = logging.DEBUG\n            print(test_temp_list)\n    \n    global platform_chassis\n    platform_chassis = platform.Platform().get_chassis()\n    \n    platform_chassis.get_fan(0).set_speed(38)\n  \n    print(\"set default fan speed to 37.5%\")\n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(10)\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    \n"}, "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py": {"changes": [{"diff": "\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', l", "add": 6, "remove": 6, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py", "badparts": ["    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cdump -y 0 0x42 s 0x9a\"", "        status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]", "        status, output = getstatusoutput_noshell(cmd)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes \"\"\" import subprocess import getopt import sys import logging import re import time PROJECT_NAME='as7726_32x' version='0.0.1' verbose=False DEBUG=False args=[] ALL_DEVICE={} i2c_prefix='/sys/bus/i2c/devices/' ''' i2c_bus={'fan':['54-0066'], 'thermal':['54-004c', '55-0048','55-0049', '55-004a', '55-004b'], 'psu':['49-0050','50-0053'], 'sfp':['-0050']} i2c_nodes={'fan':['present', 'front_speed_rpm', 'rear_speed_rpm'], 'thermal':['hwmon/hwmon*/temp1_input'], 'psu':['psu_present ', 'psu_power_good'] , 'sfp':['module_present_ ', 'module_tx_disable_']} ''' sfp_map=[21, 22, 23, 24, 26, 25, 28, 27, 17, 18, 19, 20, 29, 30, 31, 32, 33, 34, 35, 36, 45, 46, 47, 48, 37, 38, 39, 40, 41, 42, 43, 44, 15, 16] mknod=[ 'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo as7726_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-11/new_device', 'echo as7726_32x_cpld2 0x62 > /sys/bus/i2c/devices/i2c-12/new_device', 'echo as7726_32x_cpld3 0x64 > /sys/bus/i2c/devices/i2c-13/new_device', 'echo as7726_32x_fan 0x66 > /sys/bus/i2c/devices/i2c-54/new_device', 'echo lm75 0x4c > /sys/bus/i2c/devices/i2c-54/new_device', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-55/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-55/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-55/new_device', 'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-55/new_device', 'echo as7726_32x_psu1 0x53 > /sys/bus/i2c/devices/i2c-50/new_device', 'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-50/new_device', 'echo as7726_32x_psu2 0x50> /sys/bus/i2c/devices/i2c-49/new_device', 'echo ym2651 0x58 > /sys/bus/i2c/devices/i2c-49/new_device', 'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-0/new_device', ] FORCE=0 logging.basicConfig(filename=PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG) logging.basicConfig(level=logging.INFO) if DEBUG==True: print((sys.argv[0])) print(('ARGV :', sys.argv[1:])) def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print(options) print(args) print((len(sys.argv))) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': do_install() elif arg=='clean': do_uninstall() else: show_help() return 0 def show_help(): print(( __doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]})) sys.exit(0) def dis_i2c_ir3570a(addr): cmd=\"i2cset -y 0 0x%x 0xE5 0x01\" % addr status, output=subprocess.getstatusoutput(cmd) cmd=\"i2cset -y 0 0x%x 0x12 0x02\" % addr status, output=subprocess.getstatusoutput(cmd) return status def ir3570_check(): cmd=\"i2cdump -y 0 0x42 s 0x9a\" try: status, output=subprocess.getstatusoutput(cmd) lines=output.split('\\n') hn=re.findall(r'\\w+', lines[-1]) version=int(hn[1], 16) if version==0x24: ret=dis_i2c_ir3570a(4) else: ret=0 except Exception as e: print(( \"Error on ir3570_check() e:\" +str(e))) return -1 return ret def my_log(txt): if DEBUG==True: print((\"[ACCTON DBG]: \",txt)) return def log_os_system(cmd, show): logging.info('Run:'+cmd) status=1 output=\"\" status, output=subprocess.getstatusoutput(cmd) my_log(cmd +\" with result:\" +str(status)) if status: logging.info('Failed:'+cmd) if show: print(('Failed:'+cmd)) return status, output def driver_inserted(): ret, lsmod=log_os_system(\"ls /sys/module/*accton*\", 0) logging.info('mods:'+lsmod) if ret: return False else: return True def cpld_reset_mac(): ret, lsmod=log_os_system(\"i2cset -y 0 0x77 0x1\", 0) ret, lsmod=log_os_system(\"i2cset -y 0 0x76 0x4\", 0) ret, lsmod=log_os_system(\"i2cset -y 0 0x60 0x8 0x77\", 0) time.sleep(1) ret, lsmod=log_os_system(\"i2cset -y 0 0x60 0x8 0xf7\", 0) return True kos=[ 'depmod -ae', 'modprobe i2c_dev', 'modprobe i2c_mux_pca954x force_deselect_on_exit=1', 'modprobe ym2651y', 'modprobe accton_as7726_32x_cpld', 'modprobe accton_as7726_32x_fan', 'modprobe accton_as7726_32x_leds', 'modprobe accton_as7726_32x_psu', 'modprobe optoe'] def driver_install(): global FORCE for i in range(0,len(kos)): status, output=log_os_system(kos[i], 1) if status: if FORCE==0: return status print(\"Done driver_install\") return 0 def driver_uninstall(): global FORCE for i in range(0,len(kos)): rm=kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\") lst=rm.split(\" \") if len(lst) > 3: del(lst[3]) rm=\" \".join(lst) status, output=log_os_system(rm, 1) if status: if FORCE==0: return status return 0 def device_install(): global FORCE for i in range(0,len(mknod)): if mknod[i].find('pca954') !=-1: time.sleep(2) status, output=log_os_system(mknod[i], 1) if status: print(output) if FORCE==0: return status for i in range(0,len(sfp_map)): status, output=log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1) if status: print(output) if FORCE==0: return status status, output=log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1) if status: print(output) if FORCE==0: return status print(\"Done device_install\") return def device_uninstall(): global FORCE status, output=log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0) if status==0: I2C_ORDER=1 else: \tI2C_ORDER=0 for i in range(0,len(sfp_map)): target=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\" status, output=log_os_system(\"echo 0x50 > \"+target, 1) if status: print(output) if FORCE==0: return status nodelist=mknod for i in range(len(nodelist)): target=nodelist[-(i+1)] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status return def system_ready(): if driver_inserted()==False: return False if not device_exist(): print(\"not device_exist()\") return False return True def do_install(): if driver_inserted()==False: status=driver_install() if status: if FORCE==0: return status else: print((PROJECT_NAME.upper()+\" drivers detected....\")) ir3570_check() if not device_exist(): status=device_install() if status: if FORCE==0: return status else: print((PROJECT_NAME.upper()+\" devices detected....\")) return def do_uninstall(): if not device_exist(): print((PROJECT_NAME.upper()+\" has no device installed....\")) else: print(\"Removing device....\") status=device_uninstall() if status: if FORCE==0: return status if driver_inserted()==False: print((PROJECT_NAME.upper()+\" has no driver installed....\")) else: print(\"Removing installed driver....\") status=driver_uninstall() if status: if FORCE==0: return status return def device_exist(): ret1, log=log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0) ret2, log=log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# Copyright (C) 2016 Accton Networks, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean\ncommand:\n    install     : install drivers and generate related sysfs nodes\n    clean       : uninstall drivers and remove related sysfs nodes\n\"\"\"\nimport subprocess\nimport getopt\nimport sys\nimport logging\nimport re\nimport time\n\nPROJECT_NAME = 'as7726_32x'\nversion = '0.0.1'\nverbose = False\nDEBUG = False\nargs = []\nALL_DEVICE = {}\n\ni2c_prefix = '/sys/bus/i2c/devices/'\n'''\ni2c_bus = {'fan': ['54-0066'],\n           'thermal': ['54-004c', '55-0048','55-0049', '55-004a', '55-004b'] ,\n           'psu': ['49-0050','50-0053'],\n           'sfp': ['-0050']}\ni2c_nodes = {'fan': ['present', 'front_speed_rpm', 'rear_speed_rpm'],\n           'thermal': ['hwmon/hwmon*/temp1_input'] ,\n           'psu': ['psu_present ', 'psu_power_good']    ,\n           'sfp': ['module_present_ ', 'module_tx_disable_']}\n'''\nsfp_map = [21, 22, 23, 24, 26, 25, 28, 27,\n             17, 18, 19, 20, 29, 30, 31, 32,\n             33, 34, 35, 36, 45, 46, 47, 48,\n             37, 38, 39, 40, 41, 42, 43, 44,\n             15, 16]\n\nmknod =[\n'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-2/new_device',\n\n'echo as7726_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-11/new_device',\n'echo as7726_32x_cpld2 0x62 > /sys/bus/i2c/devices/i2c-12/new_device',\n'echo as7726_32x_cpld3 0x64 > /sys/bus/i2c/devices/i2c-13/new_device',\n\n'echo as7726_32x_fan 0x66 > /sys/bus/i2c/devices/i2c-54/new_device',\n\n\n'echo lm75 0x4c > /sys/bus/i2c/devices/i2c-54/new_device',\n'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-55/new_device',\n'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-55/new_device',\n'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-55/new_device',\n'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-55/new_device',\n\n\n# PSU-1\n'echo as7726_32x_psu1 0x53 > /sys/bus/i2c/devices/i2c-50/new_device',\n'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-50/new_device',\n\n# PSU-2\n'echo as7726_32x_psu2 0x50> /sys/bus/i2c/devices/i2c-49/new_device',\n'echo ym2651 0x58 > /sys/bus/i2c/devices/i2c-49/new_device',\n\n#EERPOM\n'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-0/new_device',\n]\n\n\n\nFORCE = 0\nlogging.basicConfig(filename= PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG)\nlogging.basicConfig(level=logging.INFO)\n\n\nif DEBUG == True:\n    print((sys.argv[0]))\n    print(('ARGV      :', sys.argv[1:]))\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n\n    if len(sys.argv)<2:\n        show_help()\n\n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:\n        print(options)\n        print(args)\n        print((len(sys.argv)))\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n           do_install()\n        elif arg == 'clean':\n           do_uninstall()\n        else:\n            show_help()\n\n\n    return 0\n\ndef show_help():\n    print(( __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]}))\n    sys.exit(0)\n\ndef dis_i2c_ir3570a(addr):\n    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef ir3570_check():\n    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n    try:\n        status, output = subprocess.getstatusoutput(cmd)\n        lines = output.split('\\n')\n        hn = re.findall(r'\\w+', lines[-1])\n        version = int(hn[1], 16)\n        if version == 0x24:  #only for ir3570a\n            ret = dis_i2c_ir3570a(4)\n        else:\n            ret = 0\n    except Exception as e:\n        print(( \"Error on ir3570_check() e:\" + str(e)))\n        return -1\n    return ret\n\n\ndef my_log(txt):\n    if DEBUG == True:\n        print((\"[ACCTON DBG]: \",txt))\n    return\n\ndef log_os_system(cmd, show):\n    logging.info('Run :'+cmd)\n    status = 1\n    output = \"\"\n    status, output = subprocess.getstatusoutput(cmd)\n    my_log (cmd +\" with result:\" + str(status))\n    #my_log (\"cmd:\" + cmd)\n    #my_log (\"      output:\"+output)\n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print(('Failed :'+cmd))\n    return  status, output\n\ndef driver_inserted():\n    ret, lsmod = log_os_system(\"ls /sys/module/*accton*\", 0)\n    logging.info('mods:'+lsmod)\n    if ret :\n        return False\n    else :\n        return True\n\ndef cpld_reset_mac():\n    ret, lsmod = log_os_system(\"i2cset -y 0 0x77 0x1\", 0)\n    ret, lsmod = log_os_system(\"i2cset -y 0 0x76 0x4\", 0)\n    ret, lsmod = log_os_system(\"i2cset -y 0 0x60 0x8 0x77\", 0)\n    time.sleep(1)\n    ret, lsmod = log_os_system(\"i2cset -y 0 0x60 0x8 0xf7\", 0)\n    return True\n\n\n\n#'modprobe cpr_4011_4mxx',\n\nkos = [\n'depmod -ae',\n'modprobe i2c_dev',\n'modprobe i2c_mux_pca954x force_deselect_on_exit=1',\n'modprobe ym2651y',\n'modprobe accton_as7726_32x_cpld',\n'modprobe accton_as7726_32x_fan',\n'modprobe accton_as7726_32x_leds',\n'modprobe accton_as7726_32x_psu',\n'modprobe optoe']\n\ndef driver_install():\n    global FORCE\n    for i in range(0,len(kos)):\n        status, output = log_os_system(kos[i], 1)\n        if status:\n            if FORCE == 0:\n                return status\n\n    print(\"Done driver_install\")\n    \n    #status=cpld_reset_mac()\n    return 0\n\ndef driver_uninstall():\n    global FORCE\n    for i in range(0,len(kos)):\n        rm = kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\")        \n        lst = rm.split(\" \")\n\n        if len(lst) > 3:\n            del(lst[3])\n        rm = \" \".join(lst)\n        status, output = log_os_system(rm, 1)\n        if status:\n            if FORCE == 0:\n                return status\n    return 0\n\ndef device_install():\n    global FORCE\n\n    for i in range(0,len(mknod)):\n        #for pca954x need times to built new i2c buses\n        if mknod[i].find('pca954') != -1:\n            time.sleep(2)\n        \n        status, output = log_os_system(mknod[i], 1)        \n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    for i in range(0,len(sfp_map)):\n        status, output =log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n        status, output =log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    print(\"Done device_install\")\n\n    return\n\ndef device_uninstall():\n    global FORCE\n\n    status, output =log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0)\n    if status==0:\n        I2C_ORDER=1\n    else:\n    \tI2C_ORDER=0\n\n    for i in range(0,len(sfp_map)):\n        target = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\"\n        status, output =log_os_system(\"echo 0x50 > \"+ target, 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n                \n    nodelist = mknod\n\n    for i in range(len(nodelist)):\n        target = nodelist[-(i+1)]\n        temp = target.split()\n        del temp[1]\n        temp[-1] = temp[-1].replace('new_device', 'delete_device')\n        status, output = log_os_system(\" \".join(temp), 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    return\n\ndef system_ready():\n    if driver_inserted() == False:        \n        return False\n    if not device_exist():\n        print(\"not device_exist()\")\n        return False\n    return True\n\ndef do_install():\n    if driver_inserted() == False:\n        status = driver_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print((PROJECT_NAME.upper()+\" drivers detected....\"))\n\n    ir3570_check()\n\n    if not device_exist():\n        status = device_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print((PROJECT_NAME.upper()+\" devices detected....\"))\n    return\n\ndef do_uninstall():\n    if not device_exist():\n        print((PROJECT_NAME.upper()+\" has no device installed....\"))\n    else:\n        print(\"Removing device....\")\n        status = device_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    if driver_inserted()== False :\n        print((PROJECT_NAME.upper()+\" has no driver installed....\"))\n    else:\n        print(\"Removing installed driver....\")\n        status = driver_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    return\n\ndef device_exist():\n    ret1, log = log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0)\n    ret2, log = log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as7726_32x_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n", "add": 9, "remove": 9, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py", "badparts": ["import subprocess", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py clean\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py\", \"clean\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py install\"])\n     if status:\n         print(\"accton_as7726_32x_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n", "add": 7, "remove": 7, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py install\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py install\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor.service\"])"]}, {"diff": "\n     return True\n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.serv", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}], "source": "\n import subprocess def check_pddf_support(): return True def stop_platform_svc(): status, output=subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-fan.service\") if status: print(\"Stop as7726-32x-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-fan.service\") if status: print(\"Disable as7726-32x-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-psu.service\") if status: print(\"Stop as7726-32x-platform-monitor-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-psu.service\") if status: print(\"Disable as7726-32x-platform-monitor-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor.service\") if status: print(\"Stop as7726-32x-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor.service\") if status: print(\"Disable as7726-32x-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py clean\") if status: print(\"accton_as7726_32x_util.py clean command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status) return False return True def start_platform_svc(): status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py install\") if status: print(\"accton_as7726_32x_util.py install command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-fan.service\") if status: print(\"Enable as7726-32x-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-fan.service\") if status: print(\"Start as7726-32x-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-psu.service\") if status: print(\"Enable as7726-32x-platform-monitor-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-psu.service\") if status: print(\"Start as7726-32x-platform-monitor-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor.service\") if status: print(\"Enable as7726-32x-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor.service\") if status: print(\"Start as7726-32x-platform-monitor.service failed %d\"%status) return False return True def start_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print(\"Start pddf-platform-init.service failed %d\"%status) return False return True def stop_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service failed %d\"%status) return False return True def main(): pass if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services. \n# This will be used while switching the pddf->non-pddf mode and vice versa\n\nimport subprocess\n\ndef check_pddf_support():\n    return True\n\ndef stop_platform_svc():\n    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-fan.service\")\n    if status:\n        print(\"Stop as7726-32x-platform-monitor-fan.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-fan.service\")\n    if status:\n        print(\"Disable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-psu.service\")\n    if status:\n        print(\"Stop as7726-32x-platform-monitor-psu.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-psu.service\")\n    if status:\n        print(\"Disable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor.service\")\n    if status:\n        print(\"Stop as7726-32x-platform-monitor.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor.service\")\n    if status:\n        print(\"Disable as7726-32x-platform-monitor.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py clean\")\n    if status:\n        print(\"accton_as7726_32x_util.py clean command failed %d\"%status)\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n        return False\n\n    return True\n    \ndef start_platform_svc():\n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py install\")\n    if status:\n        print(\"accton_as7726_32x_util.py install command failed %d\"%status)\n        return False\n\n    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-fan.service\")\n    if status:\n        print(\"Enable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-fan.service\")\n    if status:\n        print(\"Start as7726-32x-platform-monitor-fan.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-psu.service\")\n    if status:\n        print(\"Enable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-psu.service\")\n    if status:\n        print(\"Start as7726-32x-platform-monitor-psu.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor.service\")\n    if status:\n        print(\"Enable as7726-32x-platform-monitor.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor.service\")\n    if status:\n        print(\"Start as7726-32x-platform-monitor.service failed %d\"%status)\n        return False\n\n    return True\n\ndef start_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print(\"Start pddf-platform-init.service failed %d\"%status)\n        return False\n    \n    return True\n\ndef stop_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service failed %d\"%status)\n        return False\n\n    return True\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py": {"changes": [{"diff": "\n     print( __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]})\n     sys.exit(0)\n \n-   \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+',", "add": 6, "remove": 7, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py", "badparts": ["    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cdump -y 0 0x42 s 0x9a\"", "        status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]", "        status, output = getstatusoutput_noshell(cmd)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes \"\"\" import subprocess import getopt import sys import logging import re import time import os PROJECT_NAME='as7816_64x' version='0.1.0' verbose=False DEBUG=False args=[] ALL_DEVICE={} FORCE=0 if DEBUG==True: print(sys.argv[0]) print('ARGV :', sys.argv[1:] ) def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print(options) print(args) print(len(sys.argv)) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': do_install() elif arg=='clean': do_uninstall() elif arg=='api': do_sonic_platform_install() elif arg=='api_clean': do_sonic_platform_clean() else: show_help() return 0 def show_help(): print( __doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]}) sys.exit(0) def dis_i2c_ir3570a(addr): cmd=\"i2cset -y 0 0x%x 0xE5 0x01\" % addr status, output=subprocess.getstatusoutput(cmd) cmd=\"i2cset -y 0 0x%x 0x12 0x02\" % addr status, output=subprocess.getstatusoutput(cmd) return status def ir3570_check(): cmd=\"i2cdump -y 0 0x42 s 0x9a\" try: status, output=subprocess.getstatusoutput(cmd) lines=output.split('\\n') hn=re.findall(r'\\w+', lines[-1]) version=int(hn[1], 16) if version==0x24: ret=dis_i2c_ir3570a(4) else: ret=0 except Exception as e: print(\"Error on ir3570_check() e:\" +str(e)) return -1 return ret def my_log(txt): if DEBUG==True: print(\"[ROY]\"+txt) return def log_os_system(cmd, show): logging.info('Run:'+cmd) status, output=subprocess.getstatusoutput(cmd) my_log(cmd +\"with result:\" +str(status)) my_log(\" output:\"+output) if status: logging.info('Failed:'+cmd) if show: print('Failed:'+cmd) return status, output def driver_check(): ret, lsmod=log_os_system(\"ls /sys/module/*accton*\", 0) logging.info('mods:'+lsmod) if ret: return False else: return True kos=[ 'modprobe i2c_dev', 'modprobe i2c_mux_pca954x force_deselect_on_exit=1', 'modprobe optoe', 'modprobe accton_i2c_cpld' , 'modprobe ym2651y' , 'modprobe x86-64-accton-as7816-64x-fan' , 'modprobe x86-64-accton-as7816-64x-leds' , 'modprobe x86-64-accton-as7816-64x-psu'] def driver_install(): global FORCE status, output=log_os_system(\"depmod\", 1) for i in range(0,len(kos)): status, output=log_os_system(kos[i], 1) if status: if FORCE==0: return status print(\"Done driver_install\") return 0 def driver_uninstall(): global FORCE for i in range(0,len(kos)): rm=kos[-(i+1)] lst=rm.split(\" \") if len(lst) > 2: del(lst[2:]) rm=\" \".join(lst) rm=rm.replace(\"modprobe\", \"modprobe -rq\") rm=rm.replace(\"insmod\", \"rmmod\") status, output=log_os_system(rm, 1) if status: if FORCE==0: return status return 0 i2c_prefix='/sys/bus/i2c/devices/' ''' i2c_bus={'fan':['17-0068'] , 'thermal':['18-0048','18-0049', '18-004a', '18-004b', '17-004d', '17-004e'], 'psu':['10-0053','9-0050'], 'sfp':['-0050']} i2c_nodes={'fan':['present', 'front_speed_rpm', 'rear_speed_rpm'], 'thermal':['hwmon/hwmon*/temp1_input'], 'psu':['psu_present', 'psu_power_good'] , 'sfp':['module_present']} ''' sfp_map=[37,38,39,40,42,41,44,43,33,34,35,36,45,46,47,48,49,50,51,52, 61,62,63,64,53,54,55,56,57,58,59,60,69,70,71,72,77,78,79,80,65, \t 66,67,68,73,74,75,76,85,86,87,88,31,32,29,30,81,82,83,84,25,26, 27,28] mknod=[ 'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo as7816_64x_psu1 0x53 > /sys/bus/i2c/devices/i2c-10/new_device', 'echo ym2851 0x5b > /sys/bus/i2c/devices/i2c-10/new_device', 'echo as7816_64x_psu2 0x50 > /sys/bus/i2c/devices/i2c-9/new_device', 'echo ym2851 0x58 > /sys/bus/i2c/devices/i2c-9/new_device', 'echo as7816_64x_fan 0x68 > /sys/bus/i2c/devices/i2c-17/new_device', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4d > /sys/bus/i2c/devices/i2c-17/new_device', 'echo lm75 0x4e > /sys/bus/i2c/devices/i2c-17/new_device', 'echo cpld_as7816 0x60 > /sys/bus/i2c/devices/i2c-19/new_device', 'echo cpld_plain 0x62 > /sys/bus/i2c/devices/i2c-20/new_device', 'echo cpld_plain 0x64 > /sys/bus/i2c/devices/i2c-21/new_device', 'echo cpld_plain 0x66 > /sys/bus/i2c/devices/i2c-22/new_device'] def i2c_order_check(): return 0 def device_install(): global FORCE for i in range(0,len(mknod)): if mknod[i].find('pca954') !=-1: time.sleep(1) status, output=log_os_system(mknod[i], 1) if status: print(output) if FORCE==0: return status for i in range(0,len(sfp_map)): path=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\" status, output=log_os_system(\"echo optoe1 0x50 > \" +path, 1) if status: print(output) if FORCE==0: return status print(\"Done device_install\") return def device_uninstall(): global FORCE status, output=log_os_system(\"ls /sys/bus/i2c/devices/1-0076\", 0) for i in range(0,len(sfp_map)): target=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\" status, output=log_os_system(\"echo 0x50 > \"+target, 1) if status: print(output) if FORCE==0: return status nodelist=mknod for i in range(len(nodelist)): target=nodelist[-(i+1)] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status return def system_ready(): if driver_check()==False: return False if not device_exist(): return False return True PLATFORM_ROOT_PATH='/usr/share/sonic/device' PLATFORM_API2_WHL_FILE_PY3='sonic_platform-1.0-py3-none-any.whl' def do_sonic_platform_install(): device_path=\"{}{}{}{}\".format(PLATFORM_ROOT_PATH, '/x86_64-accton_', PROJECT_NAME, '-r0') SONIC_PLATFORM_BSP_WHL_PKG_PY3=\"/\".join([device_path, PLATFORM_API2_WHL_FILE_PY3]) status, output=log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0) if status: if os.path.exists(SONIC_PLATFORM_BSP_WHL_PKG_PY3): status, output=log_os_system(\"pip3 install \"+SONIC_PLATFORM_BSP_WHL_PKG_PY3, 1) if status: print(\"Error: Failed to install{}\".format(PLATFORM_API2_WHL_FILE_PY3)) return status else: print(\"Successfully installed{} package\".format(PLATFORM_API2_WHL_FILE_PY3)) else: print('{} is not found'.format(PLATFORM_API2_WHL_FILE_PY3)) else: print('{} has installed'.format(PLATFORM_API2_WHL_FILE_PY3)) return def do_sonic_platform_clean(): status, output=log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0) if status: print('{} does not install, not need to uninstall'.format(PLATFORM_API2_WHL_FILE_PY3)) else: status, output=log_os_system(\"pip3 uninstall sonic-platform -y\", 0) if status: print('Error: Failed to uninstall{}'.format(PLATFORM_API2_WHL_FILE_PY3)) return status else: print('{} is uninstalled'.format(PLATFORM_API2_WHL_FILE_PY3)) return def do_install(): print(\"Checking system....\") if driver_check()==False: print(\"No driver, installing....\") status=driver_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" drivers detected....\") ir3570_check() if not device_exist(): print(\"No device, installing....\") status=device_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" devices detected....\") do_sonic_platform_install() return def do_uninstall(): print(\"Checking system....\") if not device_exist(): print(PROJECT_NAME.upper() +\" has no device installed....\") else: print(\"Removing device....\") status=device_uninstall() if status: if FORCE==0: return status if driver_check()==False: print(PROJECT_NAME.upper() +\" has no driver installed....\") else: print(\"Removing installed driver....\") status=driver_uninstall() if status: if FORCE==0: return status do_sonic_platform_clean() return def device_exist(): ret1, log=log_os_system(\"ls \"+i2c_prefix+\"*0076\", 0) ret2, log=log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# Copyright (C) 2016 Accton Networks, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean\ncommand:\n    install     : install drivers and generate related sysfs nodes\n    clean       : uninstall drivers and remove related sysfs nodes\n\"\"\"\nimport subprocess\nimport getopt\nimport sys\nimport logging\nimport re\nimport time\nimport os\n\n\n\nPROJECT_NAME = 'as7816_64x'\nversion = '0.1.0'\nverbose = False\nDEBUG = False\nargs = []\nALL_DEVICE = {}               \n\nFORCE = 0\n#logging.basicConfig(filename= PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG)\n#logging.basicConfig(level=logging.INFO)\n\n\nif DEBUG == True:\n    print(sys.argv[0])\n    print('ARGV      :', sys.argv[1:]   )\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n        \n    if len(sys.argv)<2:\n        show_help()\n         \n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:\n        print(options)\n        print(args)\n        print(len(sys.argv))\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n           do_install()\n        elif arg == 'clean':\n           do_uninstall()\n        elif arg == 'api':\n           do_sonic_platform_install()\n        elif arg == 'api_clean':   \n           do_sonic_platform_clean()\n        \n        else:\n            show_help()\n\n\n    return 0\n\ndef show_help():\n    print( __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]})\n    sys.exit(0)\n\n   \ndef dis_i2c_ir3570a(addr):\n    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef ir3570_check():\n    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n    try:\n        status, output = subprocess.getstatusoutput(cmd)\n        lines = output.split('\\n')\n        hn = re.findall(r'\\w+', lines[-1])\n        version = int(hn[1], 16)\n        if version == 0x24:  #only for ir3570a\n            ret = dis_i2c_ir3570a(4)\n        else:\n            ret = 0\n    except Exception as e:\n        print(\"Error on ir3570_check() e:\" + str(e))\n        return -1\n    return ret\n\ndef my_log(txt):\n    if DEBUG == True:\n        print(\"[ROY]\"+txt)\n    return\n    \ndef log_os_system(cmd, show):\n    logging.info('Run :'+cmd)  \n    status, output = subprocess.getstatusoutput(cmd)    \n    my_log (cmd +\"with result:\" + str(status))\n    my_log (\"      output:\"+output)    \n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print('Failed :'+cmd)\n    return  status, output\n            \ndef driver_check():\n    ret, lsmod = log_os_system(\"ls /sys/module/*accton*\", 0)\n    logging.info('mods:'+lsmod)\n    if ret :\n        return False\n    else :\n        return True\n\n\n\nkos = [\n'modprobe i2c_dev',\n'modprobe i2c_mux_pca954x force_deselect_on_exit=1',\n'modprobe optoe',\n'modprobe accton_i2c_cpld'  ,\n'modprobe ym2651y'                  ,\n'modprobe x86-64-accton-as7816-64x-fan'     ,\n#'modprobe x86-64-accton-as7816-64x-sfp'      ,\n'modprobe x86-64-accton-as7816-64x-leds'      ,\n'modprobe x86-64-accton-as7816-64x-psu' ]\n\ndef driver_install():\n    global FORCE\n    status, output = log_os_system(\"depmod\", 1)\n    for i in range(0,len(kos)):\n        status, output = log_os_system(kos[i], 1)\n        if status:\n            if FORCE == 0:        \n                return status              \n    \n    print(\"Done driver_install\")\n    \n    return 0\n    \ndef driver_uninstall():\n    global FORCE\n    for i in range(0,len(kos)):\n        #remove parameter if any\n        rm = kos[-(i+1)]\n        lst = rm.split(\" \")\n        if len(lst) > 2:\n            del(lst[2:])\n        rm = \" \".join(lst)\n\n        #Change to removing commands\n        rm = rm.replace(\"modprobe\", \"modprobe -rq\")\n        rm = rm.replace(\"insmod\", \"rmmod\")        \n        status, output = log_os_system(rm, 1)\n        if status:\n            if FORCE == 0:        \n                return status              \n    return 0\n\n\ni2c_prefix = '/sys/bus/i2c/devices/'\n'''\ni2c_bus = {'fan': ['17-0068']                 ,\n           'thermal': ['18-0048','18-0049', '18-004a' , '18-004b', '17-004d', '17-004e'] ,\n           'psu': ['10-0053','9-0050'], \n           'sfp': ['-0050']}\ni2c_nodes = {'fan': ['present', 'front_speed_rpm', 'rear_speed_rpm'] ,\n           'thermal': ['hwmon/hwmon*/temp1_input'] ,\n           'psu': ['psu_present', 'psu_power_good']    ,\n           'sfp': ['module_present']}\n'''                  \n\nsfp_map =  [37,38,39,40,42,41,44,43,33,34,35,36,45,46,47,48,49,50,51,52,\n           61,62,63,64,53,54,55,56,57,58,59,60,69,70,71,72,77,78,79,80,65,\n\t   66,67,68,73,74,75,76,85,86,87,88,31,32,29,30,81,82,83,84,25,26,\n           27,28]\n\n\nmknod =[   \n'echo pca9548  0x77 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo pca9548  0x71 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548  0x76 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548  0x73 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548  0x70 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x71 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x72 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x73 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x74 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x75 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x76 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo 24c02  0x56 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo as7816_64x_psu1  0x53 > /sys/bus/i2c/devices/i2c-10/new_device',\n'echo ym2851  0x5b > /sys/bus/i2c/devices/i2c-10/new_device',\n'echo as7816_64x_psu2  0x50 > /sys/bus/i2c/devices/i2c-9/new_device',\n'echo ym2851  0x58 > /sys/bus/i2c/devices/i2c-9/new_device',\n'echo as7816_64x_fan  0x68 > /sys/bus/i2c/devices/i2c-17/new_device',\n'echo lm75  0x48 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75  0x49 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75  0x4a > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75  0x4b > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75  0x4d > /sys/bus/i2c/devices/i2c-17/new_device',\n'echo lm75  0x4e > /sys/bus/i2c/devices/i2c-17/new_device',\n'echo cpld_as7816  0x60 > /sys/bus/i2c/devices/i2c-19/new_device',\n'echo cpld_plain  0x62 > /sys/bus/i2c/devices/i2c-20/new_device',\n'echo cpld_plain  0x64 > /sys/bus/i2c/devices/i2c-21/new_device',\n'echo cpld_plain  0x66 > /sys/bus/i2c/devices/i2c-22/new_device']\n       \ndef i2c_order_check():    \n    return 0\n                     \ndef device_install():\n    global FORCE\n    \n    for i in range(0,len(mknod)):\n        #for pca954x need times to built new i2c buses            \n        if mknod[i].find('pca954') != -1:\n           time.sleep(1)         \n           \n        status, output = log_os_system(mknod[i], 1)\n        if status:\n            print(output)\n            if FORCE == 0:                \n                return status  \n\n    for i in range(0,len(sfp_map)):\n        path = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\"\n        status, output =log_os_system(\"echo optoe1 0x50 > \" + path, 1)\n        if status:\n            print(output)\n            if FORCE == 0:            \n                return status                                  \n     \n    print(\"Done device_install\")\n     \n    return \n    \ndef device_uninstall():\n    global FORCE\n    \n    status, output =log_os_system(\"ls /sys/bus/i2c/devices/1-0076\", 0)\n    \n    for i in range(0,len(sfp_map)):\n        target = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\"\n        status, output =log_os_system(\"echo 0x50 > \"+ target, 1)\n        if status:\n            print(output)\n            if FORCE == 0:            \n                return status\n       \n    nodelist = mknod\n           \n    for i in range(len(nodelist)):\n        target = nodelist[-(i+1)]\n        temp = target.split()\n        del temp[1]\n        temp[-1] = temp[-1].replace('new_device', 'delete_device')\n        status, output = log_os_system(\" \".join(temp), 1)\n        if status:\n            print(output)\n            if FORCE == 0:            \n                return status  \n                                  \n    return \n        \ndef system_ready():\n    if driver_check() == False:\n        return False\n    if not device_exist(): \n        return False\n    return True\n\nPLATFORM_ROOT_PATH = '/usr/share/sonic/device'\nPLATFORM_API2_WHL_FILE_PY3 ='sonic_platform-1.0-py3-none-any.whl'\ndef do_sonic_platform_install():\n    device_path = \"{}{}{}{}\".format(PLATFORM_ROOT_PATH, '/x86_64-accton_', PROJECT_NAME, '-r0')\n    SONIC_PLATFORM_BSP_WHL_PKG_PY3 = \"/\".join([device_path, PLATFORM_API2_WHL_FILE_PY3])\n        \n    #Check API2.0 on py whl file\n    status, output = log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0)\n    if status:\n        if os.path.exists(SONIC_PLATFORM_BSP_WHL_PKG_PY3): \n            status, output = log_os_system(\"pip3 install \"+ SONIC_PLATFORM_BSP_WHL_PKG_PY3, 1)\n            if status:\n                print(\"Error: Failed to install {}\".format(PLATFORM_API2_WHL_FILE_PY3))\n                return status\n            else:\n                print(\"Successfully installed {} package\".format(PLATFORM_API2_WHL_FILE_PY3))\n        else:\n            print('{} is not found'.format(PLATFORM_API2_WHL_FILE_PY3))\n    else:        \n        print('{} has installed'.format(PLATFORM_API2_WHL_FILE_PY3))\n     \n    return \n     \ndef do_sonic_platform_clean():\n    status, output = log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0)   \n    if status:\n        print('{} does not install, not need to uninstall'.format(PLATFORM_API2_WHL_FILE_PY3))\n        \n    else:        \n        status, output = log_os_system(\"pip3 uninstall sonic-platform -y\", 0)\n        if status:\n            print('Error: Failed to uninstall {}'.format(PLATFORM_API2_WHL_FILE_PY3))\n            return status\n        else:\n            print('{} is uninstalled'.format(PLATFORM_API2_WHL_FILE_PY3))\n\n    return\ndef do_install():\n    print(\"Checking system....\")\n    if driver_check() == False:\n        print(\"No driver, installing....\")    \n        status = driver_install()\n        if status:\n            if FORCE == 0:        \n                return  status\n    else:\n        print(PROJECT_NAME.upper()+\" drivers detected....\")\n\n    ir3570_check()\n\n    if not device_exist():\n        print(\"No device, installing....\")\n        status = device_install() \n        if status:\n            if FORCE == 0:        \n                return  status        \n    else:\n        print(PROJECT_NAME.upper()+\" devices detected....\")\n    do_sonic_platform_install()\n\n    return\n    \ndef do_uninstall():\n    print(\"Checking system....\")\n    if not device_exist():\n        print(PROJECT_NAME.upper() +\" has no device installed....\")\n    else:\n        print(\"Removing device....\")\n        status = device_uninstall() \n        if status:\n            if FORCE == 0:            \n                return  status  \n                \n    if driver_check()== False :\n        print(PROJECT_NAME.upper() +\" has no driver installed....\")\n    else:\n        print(\"Removing installed driver....\")\n        status = driver_uninstall()\n        if status:\n            if FORCE == 0:        \n                return  status                          \n                    \n    do_sonic_platform_clean() \n\n    return       \n\ndef device_exist():\n    ret1, log = log_os_system(\"ls \"+i2c_prefix+\"*0076\", 0)\n    ret2, log = log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services.\n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n def check_pddf_support():\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py", "badparts": ["import subprocess"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n \n def stop_platform_svc():\n \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Stop as7816-platform-init.service failed %d\" % status))\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Disable as7816-platform-init.service failed %d\" % status))\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"clean\"])\n     if status:\n         print((\"accton_as7816_util.py clean command failed %d\" % status))\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Stop pddf-platform-init.service along with other platform serives failed %d\" % status))\n         return False\n", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl stop as7816-platform-init.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as7816-platform-init.service\")", "    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py clean\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7816-platform-init.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7816-platform-init.service\"])", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"clean\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}, {"diff": "\n \n \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"install\"])\n     if status:\n         print((\"accton_as7816_util.py install command failed %d\" % status))\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Enable as7816-platform-init.service failed %d\" % status))\n         return False\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py install\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as7816-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"install\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7816-platform-init.service\"])"]}, {"diff": "\n \n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Start pddf-platform-init.service failed %d\" % status))\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])"]}, {"diff": "\n \n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Stop pddf-platform-init.servi", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}], "source": "\n import subprocess def check_pddf_support(): return True def stop_platform_svc(): status, output=subprocess.getstatusoutput(\"systemctl stop as7816-platform-init.service\") if status: print((\"Stop as7816-platform-init.service failed %d\" % status)) return False status, output=subprocess.getstatusoutput(\"systemctl disable as7816-platform-init.service\") if status: print((\"Disable as7816-platform-init.service failed %d\" % status)) return False status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py clean\") if status: print((\"accton_as7816_util.py clean command failed %d\" % status)) return False status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print((\"Stop pddf-platform-init.service along with other platform serives failed %d\" % status)) return False return True def start_platform_svc(): status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py install\") if status: print((\"accton_as7816_util.py install command failed %d\" % status)) return False status, output=subprocess.getstatusoutput(\"systemctl enable as7816-platform-init.service\") if status: print((\"Enable as7816-platform-init.service failed %d\" % status)) return False return True def start_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print((\"Start pddf-platform-init.service failed %d\" % status)) return False return True def stop_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print((\"Stop pddf-platform-init.service failed %d\" % status)) return False return True def main(): pass if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services.\n# This will be used while switching the pddf->non-pddf mode and vice versa\nimport subprocess\n\n\ndef check_pddf_support():\n    return True\n\n\ndef stop_platform_svc():\n\n    status, output = subprocess.getstatusoutput(\"systemctl stop as7816-platform-init.service\")\n    if status:\n        print((\"Stop as7816-platform-init.service failed %d\" % status))\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as7816-platform-init.service\")\n    if status:\n        print((\"Disable as7816-platform-init.service failed %d\" % status))\n        return False\n\n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py clean\")\n    if status:\n        print((\"accton_as7816_util.py clean command failed %d\" % status))\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print((\"Stop pddf-platform-init.service along with other platform serives failed %d\" % status))\n        return False\n\n    return True\n\n\ndef start_platform_svc():\n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py install\")\n    if status:\n        print((\"accton_as7816_util.py install command failed %d\" % status))\n        return False\n\n    status, output = subprocess.getstatusoutput(\"systemctl enable as7816-platform-init.service\")\n    if status:\n        print((\"Enable as7816-platform-init.service failed %d\" % status))\n        return False\n\n    return True\n\n\ndef start_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print((\"Start pddf-platform-init.service failed %d\" % status))\n        return False\n\n    return True\n\n\ndef stop_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print((\"Stop pddf-platform-init.service failed %d\" % status))\n        return False\n\n    return True\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py": {"changes": [{"diff": "\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+", "add": 6, "remove": 6, "filename": "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py", "badparts": ["    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cdump -y 0 0x42 s 0x9a\"", "        status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]", "        status, output = getstatusoutput_noshell(cmd)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes \"\"\" import subprocess import getopt import sys import logging import re import time PROJECT_NAME='as9716_32d' version='0.0.1' verbose=False DEBUG=False args=[] ALL_DEVICE={} i2c_prefix='/sys/bus/i2c/devices/' ''' i2c_bus={'fan':['54-0066'], 'thermal':['18-0048', '18-0049','18-004a', '18-004b', '18-004c', '18-004e', '18-004f'], 'psu':['9-0058', '10-0059'], 'sfp':['-0050']} i2c_nodes={'fan':['present', 'front_speed_rpm', 'rear_speed_rpm'], 'thermal':['hwmon/hwmon*/temp1_input'], 'psu':['psu_present ', 'psu_power_good'] , 'sfp':['module_present_ ', 'module_tx_disable_']} ''' sfp_map=[25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58] mknod=[ 'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo as9716_32d_fpga 0x60 > /sys/bus/i2c/devices/i2c-19/new_device', 'echo as9716_32d_cpld1 0x61 > /sys/bus/i2c/devices/i2c-20/new_device', 'echo as9716_32d_cpld2 0x62 > /sys/bus/i2c/devices/i2c-21/new_device', 'echo as9716_32d_cpld_cpu 0x65 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo as9716_32d_fan 0x66 > /sys/bus/i2c/devices/i2c-17/new_device', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4c > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4e > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4f > /sys/bus/i2c/devices/i2c-18/new_device', 'echo as9716_32d_psu1 0x50 > /sys/bus/i2c/devices/i2c-9/new_device', 'echo acbel_fsh082 0x58 > /sys/bus/i2c/devices/i2c-9/new_device', 'echo as9716_32d_psu2 0x51 > /sys/bus/i2c/devices/i2c-10/new_device', 'echo acbel_fsh082 0x59 > /sys/bus/i2c/devices/i2c-10/new_device', ] eeprom_mknod=[ 'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-0/new_device', ] FORCE=0 logging.basicConfig(filename=PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG) logging.basicConfig(level=logging.INFO) if DEBUG==True: print((sys.argv[0])) print(('ARGV :', sys.argv[1:])) def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print(options) print(args) print((len(sys.argv))) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': do_install() elif arg=='clean': do_uninstall() else: show_help() return 0 def show_help(): print(( __doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]})) sys.exit(0) def dis_i2c_ir3570a(addr): cmd=\"i2cset -y 0 0x%x 0xE5 0x01\" % addr status, output=subprocess.getstatusoutput(cmd) cmd=\"i2cset -y 0 0x%x 0x12 0x02\" % addr status, output=subprocess.getstatusoutput(cmd) return status def ir3570_check(): cmd=\"i2cdump -y 0 0x42 s 0x9a\" try: status, output=subprocess.getstatusoutput(cmd) lines=output.split('\\n') hn=re.findall(r'\\w+', lines[-1]) version=int(hn[1], 16) if version==0x24: ret=dis_i2c_ir3570a(4) else: ret=0 except Exception as e: print(( \"Error on ir3570_check() e:\" +str(e))) return -1 return ret def my_log(txt): if DEBUG==True: print((\"[ACCTON DBG]: \"+txt)) return def log_os_system(cmd, show): logging.info('Run:'+cmd) status=1 output=\"\" status, output=subprocess.getstatusoutput(cmd) my_log(cmd +\"with result:\" +str(status)) if status: logging.info('Failed:'+cmd) if show: print(('Failed:'+cmd)) return status, output def driver_inserted(): ret, lsmod=log_os_system(\"ls /sys/module/*accton*\", 0) logging.info('mods:'+lsmod) if ret: return False else: return True kos=[ 'depmod -ae', 'modprobe i2c_dev', 'modprobe i2c_mux_pca954x force_deselect_on_exit=1', 'modprobe accton_i2c_psu', 'modprobe accton_as9716_32d_cpld', 'modprobe accton_as9716_32d_fan', 'modprobe accton_as9716_32d_leds', 'modprobe accton_as9716_32d_psu', 'modprobe optoe', 'modprobe lm75'] cpld_reset_stop='i2cset -y 0 0x65 0x3 0x0' def driver_install(): global FORCE for i in range(0,len(kos)): status, output=log_os_system(kos[i], 1) if status: if FORCE==0: return status log_os_system(cpld_reset_stop, 1) print(\"Done driver_install\") return 0 def driver_uninstall(): global FORCE for i in range(0,len(kos)): rm=kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\") lst=rm.split(\" \") if len(lst) > 3: del(lst[3]) rm=\" \".join(lst) status, output=log_os_system(rm, 1) if status: if FORCE==0: return status return 0 def eeprom_check(): cmd=\"i2cget -y -f 0 0x57\" status, output=subprocess.getstatusoutput(cmd) return status def device_install(): global FORCE global use_57_eeprom for i in range(0,len(mknod)): if mknod[i].find('pca954') !=-1: time.sleep(2) status, output=log_os_system(mknod[i], 1) if status: print(output) if FORCE==0: return status ret=eeprom_check() if ret==0: log_os_system(eeprom_mknod[0], 1) else: log_os_system(eeprom_mknod[1], 1) for i in range(0,len(sfp_map)): status, output=log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1) if status: print(output) if FORCE==0: return status status, output=log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1) if status: print(output) if FORCE==0: return status print(\"Done device_install\") return def device_uninstall(): global FORCE status, output=log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0) if status==0: I2C_ORDER=1 else: \tI2C_ORDER=0 for i in range(0,len(sfp_map)): target=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\" status, output=log_os_system(\"echo 0x50 > \"+target, 1) if status: print(output) if FORCE==0: return status nodelist=mknod for i in range(len(nodelist)): target=nodelist[-(i+1)] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status ret=eeprom_check() if ret==0: target=eeprom_mknod[0] else: target=eeprom_mknod[1] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) return def system_ready(): if driver_inserted()==False: return False if not device_exist(): print(\"not device_exist()\") return False return True def do_install(): if driver_inserted()==False: status=driver_install() if status: if FORCE==0: return status else: print((PROJECT_NAME.upper()+\" drivers detected....\")) ir3570_check() if not device_exist(): status=device_install() if status: if FORCE==0: return status else: print((PROJECT_NAME.upper()+\" devices detected....\")) return def do_uninstall(): if not device_exist(): print((PROJECT_NAME.upper()+\" has no device installed....\")) else: print(\"Removing device....\") status=device_uninstall() if status: if FORCE==0: return status if driver_inserted()==False: print((PROJECT_NAME.upper()+\" has no driver installed....\")) else: print(\"Removing installed driver....\") status=driver_uninstall() if status: if FORCE==0: return status return def device_exist(): ret1, log=log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0) ret2, log=log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# Copyright (C) 2016 Accton Networks, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean\ncommand:\n    install     : install drivers and generate related sysfs nodes\n    clean       : uninstall drivers and remove related sysfs nodes\n\"\"\"\nimport subprocess\nimport getopt\nimport sys\nimport logging\nimport re\nimport time\n\nPROJECT_NAME = 'as9716_32d'\nversion = '0.0.1'\nverbose = False\nDEBUG = False\nargs = []\nALL_DEVICE = {}\n\ni2c_prefix = '/sys/bus/i2c/devices/'\n'''\ni2c_bus = {'fan': ['54-0066'],\n           'thermal': ['18-0048', '18-0049','18-004a', '18-004b', '18-004c', '18-004e', '18-004f'] ,\n           'psu': ['9-0058', '10-0059'],\n           'sfp': ['-0050']}\ni2c_nodes = {'fan': ['present', 'front_speed_rpm', 'rear_speed_rpm'],\n           'thermal': ['hwmon/hwmon*/temp1_input'] ,\n           'psu': ['psu_present ', 'psu_power_good']    ,\n           'sfp': ['module_present_ ', 'module_tx_disable_']}\n'''\n\nsfp_map = [25, 26, 27, 28, 29, 30, 31, 32,\n           33, 34, 35, 36, 37, 38, 39, 40,\n           41, 42, 43, 44, 45, 46, 47, 48,\n           49, 50, 51, 52, 53, 54, 55, 56,\n           57, 58]\n\n#sfp_map = [25, 26]\n\nmknod =[\n'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-2/new_device',\n\n'echo as9716_32d_fpga 0x60 > /sys/bus/i2c/devices/i2c-19/new_device',\n'echo as9716_32d_cpld1 0x61 > /sys/bus/i2c/devices/i2c-20/new_device',\n'echo as9716_32d_cpld2 0x62 > /sys/bus/i2c/devices/i2c-21/new_device',\n'echo as9716_32d_cpld_cpu 0x65 > /sys/bus/i2c/devices/i2c-0/new_device',\n\n'echo as9716_32d_fan 0x66 > /sys/bus/i2c/devices/i2c-17/new_device',\n\n'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x4c > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x4e > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x4f > /sys/bus/i2c/devices/i2c-18/new_device',\n \n# PSU-1\n'echo as9716_32d_psu1 0x50 > /sys/bus/i2c/devices/i2c-9/new_device',\n'echo acbel_fsh082    0x58 > /sys/bus/i2c/devices/i2c-9/new_device',\n\n# PSU-2\n'echo as9716_32d_psu2 0x51 > /sys/bus/i2c/devices/i2c-10/new_device',\n'echo acbel_fsh082    0x59 > /sys/bus/i2c/devices/i2c-10/new_device',\n]\n\n#EERPOM\neeprom_mknod =[\n'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-0/new_device',\n]\n\nFORCE = 0\nlogging.basicConfig(filename= PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG)\nlogging.basicConfig(level=logging.INFO)\n\n\nif DEBUG == True:\n    print((sys.argv[0]))\n    print(('ARGV      :', sys.argv[1:]))\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n\n    if len(sys.argv)<2:\n        show_help()\n\n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:\n        print(options)\n        print(args)\n        print((len(sys.argv)))\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n           do_install()\n        elif arg == 'clean':\n           do_uninstall()\n        else:\n            show_help()\n\n\n    return 0\n\ndef show_help():\n    print(( __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]}))\n    sys.exit(0)\n\ndef dis_i2c_ir3570a(addr):\n    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef ir3570_check():\n    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n    try:\n        status, output = subprocess.getstatusoutput(cmd)\n        lines = output.split('\\n')\n        hn = re.findall(r'\\w+', lines[-1])\n        version = int(hn[1], 16)\n        if version == 0x24:  #only for ir3570a\n            ret = dis_i2c_ir3570a(4)\n        else:\n            ret = 0\n    except Exception as e:\n        print(( \"Error on ir3570_check() e:\" + str(e)))\n        return -1\n    return ret\n\n\ndef my_log(txt):\n    if DEBUG == True:\n        print((\"[ACCTON DBG]: \"+txt))\n    return\n\ndef log_os_system(cmd, show):\n    logging.info('Run :'+cmd)\n    status = 1\n    output = \"\"\n    status, output = subprocess.getstatusoutput(cmd)\n    my_log (cmd +\"with result:\" + str(status))\n    #my_log (\"cmd:\" + cmd)\n    #my_log (\"      output:\"+output)\n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print(('Failed :'+cmd))\n    return  status, output\n\ndef driver_inserted():\n    ret, lsmod = log_os_system(\"ls /sys/module/*accton*\", 0)\n    logging.info('mods:'+lsmod)\n    if ret :\n        return False\n    else :\n        return True\n\n\nkos = [\n'depmod -ae',\n'modprobe i2c_dev',\n'modprobe i2c_mux_pca954x force_deselect_on_exit=1',\n'modprobe accton_i2c_psu',\n'modprobe accton_as9716_32d_cpld',\n'modprobe accton_as9716_32d_fan',\n'modprobe accton_as9716_32d_leds',\n'modprobe accton_as9716_32d_psu',\n'modprobe optoe',\n'modprobe lm75']\n\ncpld_reset_stop='i2cset -y 0 0x65 0x3 0x0'\n\ndef driver_install():\n    \n    global FORCE\n    for i in range(0,len(kos)):\n        status, output = log_os_system(kos[i], 1)\n        if status:\n            if FORCE == 0:\n                return status\n    log_os_system(cpld_reset_stop, 1)\n    print(\"Done driver_install\")\n    return 0\n\ndef driver_uninstall():\n    global FORCE\n    for i in range(0,len(kos)):\n        rm = kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\")        \n        lst = rm.split(\" \")\n\n        if len(lst) > 3:\n            del(lst[3])\n        rm = \" \".join(lst)\n        status, output = log_os_system(rm, 1)\n        if status:\n            if FORCE == 0:\n                return status\n    return 0\n\ndef eeprom_check():\n    cmd = \"i2cget -y -f 0 0x57\"\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef device_install():\n    global FORCE\n    global use_57_eeprom\n\n    for i in range(0,len(mknod)):\n        #for pca954x need times to built new i2c buses\n        if mknod[i].find('pca954') != -1:\n            time.sleep(2)\n        #print(\"init i2c device instance\")\n        status, output = log_os_system(mknod[i], 1)        \n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n    \n    ret=eeprom_check()\n    if ret==0:\n        log_os_system(eeprom_mknod[0], 1) #new board, 0x57 eeprom\n    else:\n        log_os_system(eeprom_mknod[1], 1) #old board, 0x56 eeprom\n        \n    for i in range(0,len(sfp_map)):\n        status, output =log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n        status, output =log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    print(\"Done device_install\")\n\n    return\n\ndef device_uninstall():\n    global FORCE\n\n    status, output =log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0)\n    if status==0:\n        I2C_ORDER=1\n    else:\n    \tI2C_ORDER=0\n\n    for i in range(0,len(sfp_map)):\n        target = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\"\n        status, output =log_os_system(\"echo 0x50 > \"+ target, 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n                \n    nodelist = mknod\n\n    for i in range(len(nodelist)):\n        target = nodelist[-(i+1)]\n        temp = target.split()\n        del temp[1]\n        temp[-1] = temp[-1].replace('new_device', 'delete_device')\n        status, output = log_os_system(\" \".join(temp), 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    ret=eeprom_check()\n    if ret==0:\n        target = eeprom_mknod[0] #0x57\n    else:\n        target = eeprom_mknod[1] #0x56\n    \n    temp = target.split()\n    del temp[1]\n    temp[-1] = temp[-1].replace('new_device', 'delete_device')\n    status, output = log_os_system(\" \".join(temp), 1)\n   \n    return\n\ndef system_ready():\n    if driver_inserted() == False:        \n        return False\n    if not device_exist():\n        print(\"not device_exist()\")\n        return False\n    return True\n\ndef do_install():\n    if driver_inserted() == False:\n        status = driver_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print((PROJECT_NAME.upper()+\" drivers detected....\"))\n\n    ir3570_check()\n\n    if not device_exist():\n        status = device_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print((PROJECT_NAME.upper()+\" devices detected....\"))\n    return\n\ndef do_uninstall():\n    if not device_exist():\n        print((PROJECT_NAME.upper()+\" has no device installed....\"))\n    else:\n        print(\"Removing device....\")\n        status = device_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    if driver_inserted()== False :\n        print((PROJECT_NAME.upper()+\" has no driver installed....\"))\n    else:\n        print(\"Removing installed driver....\")\n        status = driver_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    return\n\ndef device_exist():\n    ret1, log = log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0)\n    ret2, log = log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-fan.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-init.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Disable as9716-32d-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as9716_32d_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n", "add": 7, "remove": 7, "filename": "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py", "badparts": ["import subprocess", "    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as9716-32d-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py clean\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as9716-32d-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"clean\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"install\"])\n     if status:\n         print(\"accton_as9716_32d_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Enable as9716-32d-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as9716-32d-platform-monitor-fan.service failed %d\"%status)\n         return False\n         \n-    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as9716-32d-platform-monitor-psu.service failed %d\"%status)\n         return False\n", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py install\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as9716-32d-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-psu.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"install\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as9716-32d-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-psu.service\"])"]}, {"diff": "\n \n def start_platform_pddf():   \n \n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])"]}, {"diff": "\n \n def stop_platform_pddf():   \n \n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}], "source": "\n import subprocess def check_pddf_support(): return True def stop_platform_svc(): status, output=subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-fan.service\") if status: print(\"Stop as9716-32d-platform-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-psu.service\") if status: print(\"Stop as9716-32d-platform-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor.service\") if status: print(\"Stop as9716-32d-platform-init.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl disable as9716-32d-platform-monitor.service\") if status: print(\"Disable as9716-32d-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py clean\") if status: print(\"accton_as9716_32d_util.py clean command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status) return False return True def start_platform_svc(): status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py install\") if status: print(\"accton_as9716_32d_util.py install command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl enable as9716-32d-platform-monitor.service\") if status: print(\"Enable as9716-32d-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-fan.service\") if status: print(\"Start as9716-32d-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-psu.service\") if status: print(\"Start as9716-32d-platform-monitor-psu.service failed %d\"%status) return False return True def start_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print(\"Start pddf-platform-init.service failed %d\"%status) return False return True def stop_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service failed %d\"%status) return False return True ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services. \n# This will be used while switching the pddf->non-pddf mode and vice versa\nimport subprocess\n\ndef check_pddf_support():\n    return True\n\ndef stop_platform_svc():\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-fan.service\")\n    if status:\n        print(\"Stop as9716-32d-platform-fan.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-psu.service\")\n    if status:\n        print(\"Stop as9716-32d-platform-psu.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor.service\")\n    if status:\n        print(\"Stop as9716-32d-platform-init.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as9716-32d-platform-monitor.service\")\n    if status:\n        print(\"Disable as9716-32d-platform-monitor.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py clean\")\n    if status:\n        print(\"accton_as9716_32d_util.py clean command failed %d\"%status)\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n        return False\n\n    return True\n    \ndef start_platform_svc():\n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py install\")\n    if status:\n        print(\"accton_as9716_32d_util.py install command failed %d\"%status)\n        return False\n\n    status, output = subprocess.getstatusoutput(\"systemctl enable as9716-32d-platform-monitor.service\")\n    if status:\n        print(\"Enable as9716-32d-platform-monitor.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-fan.service\")\n    if status:\n        print(\"Start as9716-32d-platform-monitor-fan.service failed %d\"%status)\n        return False\n        \n    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-psu.service\")\n    if status:\n        print(\"Start as9716-32d-platform-monitor-psu.service failed %d\"%status)\n        return False\n\n    return True\n\ndef start_platform_pddf():   \n\n    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print(\"Start pddf-platform-init.service failed %d\"%status)\n        return False\n    \n    return True\n\ndef stop_platform_pddf():   \n\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service failed %d\"%status)\n        return False\n\n    return True\n\n"}}, "msg": "[device/accton] Replace os.system and remove subprocess with shell=True (#11985)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\n#### Why I did it\r\n`subprocess.Popen()` and `subprocess.run()` is used with `shell=True`, which is very dangerous for shell injection.\r\n`os` - not secure against maliciously constructed input and dangerous if used to evaluate dynamic content\r\n#### How I did it\r\nReplace `os` by `subprocess`\r\nRemove unused functions"}, "2b3e884209d5028c1763b0f83cfc42b5249b4efb": {"url": "https://api.github.com/repos/SovereignCloudStack/sonic-buildimage/commits/2b3e884209d5028c1763b0f83cfc42b5249b4efb", "html_url": "https://github.com/SovereignCloudStack/sonic-buildimage/commit/2b3e884209d5028c1763b0f83cfc42b5249b4efb", "sha": "2b3e884209d5028c1763b0f83cfc42b5249b4efb", "keyword": "function injection malicious", "diff": "diff --git a/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py b/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py\nindex cbd48237c..12a1bbe5d 100644\n--- a/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py\n+++ b/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py\n@@ -10,5 +10,7 @@ class board(eeprom_tlvinfo.TlvInfoDecoder):\n     def __init__(self, name, path, cpld_root, ro):\n         self.eeprom_path = \"/sys/class/i2c-adapter/i2c-0/0-0053/eeprom\"\n         if not os.path.exists(self.eeprom_path):\n-            os.system(\"echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device\")\n+            file = \"/sys/class/i2c-adapter/i2c-0/new_device\"\n+            with open(file, 'w') as f:\n+                f.write('24c02 0x53\\n')\n         super(board, self).__init__(self.eeprom_path, 0, '', True)\ndiff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py\nindex eb507a49e..008d5ba08 100755\n--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py\n+++ b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py\n@@ -18,6 +18,7 @@\n     from sonic_platform.thermal import Thermal\n     from sonic_platform.component import Component\n     from sonic_py_common import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -27,11 +28,6 @@\n except ImportError as e:\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n MAX_SELECT_DELAY = 3600\n COPPER_PORT_START = 1\n COPPER_PORT_END = 48\n@@ -209,7 +205,7 @@ def get_revision(self):\n             string: Revision value of chassis\n         \"\"\"\n         if smbus_present == 0:  # called from host\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x0')\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x0'])\n         else:\n             bus = smbus.SMBus(0)\n             DEVICE_ADDRESS = 0x41\n@@ -331,7 +327,7 @@ def set_status_led(self, color):\n \n         # Write sys led\n         if smbus_present == 0:  # called from host (e.g. 'show system-health')\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cset -y 0 0x41 0x7 %d' % value)\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '0', '0x41', '0x7', str(value)])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"  System LED set %s failed\" % value)\n                 return False\n@@ -353,7 +349,7 @@ def get_status_led(self):\n         \"\"\"\n         # Read sys led\n         if smbus_present == 0:  # called from host\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x7')\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x7'])\n             value = int(value, 16)\n         else:\n             bus = smbus.SMBus(0)\ndiff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py\nindex 134856ea4..4e8863e64 100644\n--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py\n+++ b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py\n@@ -9,10 +9,10 @@\n \n try:\n     import os\n-    import sys\n     import subprocess\n     import ntpath\n     from sonic_platform_base.component_base import ComponentBase\n+    from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -22,11 +22,6 @@\n except ImportError as e:\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n \n class Component(ComponentBase):\n     \"\"\"Nokia platform-specific Component class\"\"\"\n@@ -35,29 +30,20 @@ class Component(ComponentBase):\n         [\"System-CPLD\", \"Used for managing SFPs, LEDs, PSUs and FANs \"],\n         [\"U-Boot\", \"Performs initialization during booting\"],\n     ]\n-    CPLD_UPDATE_COMMAND = 'cp /usr/sbin/vme /tmp; cp {} /tmp; cd /tmp; ./vme {};'\n+    CPLD_UPDATE_COMMAND1 = ['cp', '/usr/sbin/vme', '/tmp']\n+    CPLD_UPDATE_COMMAND2 = ['cp', '', '/tmp']\n+    CPLD_UPDATE_COMMAND3 = ['cd', '/tmp']\n+    CPLD_UPDATE_COMMAND4 = ['./vme', '']\n \n     def __init__(self, component_index):\n         self.index = component_index\n         self.name = self.CHASSIS_COMPONENTS[self.index][0]\n         self.description = self.CHASSIS_COMPONENTS[self.index][1]\n \n-    def _get_command_result(self, cmdline):\n-        try:\n-            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,\n-                                    stderr=subprocess.STDOUT)\n-            stdout = proc.communicate()[0]\n-            proc.wait()\n-            result = stdout.rstrip('\\n')\n-        except OSError:\n-            result = None\n-\n-        return result\n-\n     def _get_cpld_version(self, cpld_number):\n \n         if smbus_present == 0:\n-            cmdstatus, cpld_version = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x2')\n+            cmdstatus, cpld_version = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x2'])\n         else:\n             bus = smbus.SMBus(0)\n             DEVICE_ADDRESS = 0x41\n@@ -144,7 +130,10 @@ def get_firmware_version(self):\n             return self._get_cpld_version(self.index)\n \n         if self.index == 1:\n-            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -1 | cut -d\" \" -f2-4')\n+            cmd1 = ['grep', '--null-data', 'U-Boot', '/dev/mtd0ro']\n+            cmd2 = ['head', '-1']\n+            cmd3 = ['cut', '-d', ' ', '-f2-4']\n+            cmdstatus, uboot_version = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)\n             return uboot_version\n \n     def install_firmware(self, image_path):\n@@ -165,12 +154,16 @@ def install_firmware(self, image_path):\n             print(\"ERROR: the cpld image {} doesn't exist \".format(image_path))\n             return False\n \n-        cmdline = self.CPLD_UPDATE_COMMAND.format(image_path, image_name)\n+        self.CPLD_UPDATE_COMMAND2[1] = image_path\n+        self.CPLD_UPDATE_COMMAND4[1] = image_name\n \n         success_flag = False\n-\n-        try:\n-            subprocess.check_call(cmdline, stderr=subprocess.STDOUT, shell=True)\n+ \n+        try:   \n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND1, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND2, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND3, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND4, stderr=subprocess.STDOUT)\n             success_flag = True\n         except subprocess.CalledProcessError as e:\n             print(\"ERROR: Failed to upgrade CPLD: rc={}\".format(e.returncode))\ndiff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py\nindex 383eb2481..243b807ed 100644\n--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py\n+++ b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py\n@@ -8,18 +8,13 @@\n \n try:\n     import os\n-    import sys\n     from sonic_platform_base.psu_base import PsuBase\n     from sonic_py_common import logger\n     from sonic_platform.eeprom import Eeprom\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n smbus_present = 1\n try:\n     import smbus\n@@ -86,7 +81,7 @@ def get_presence(self):\n         \"\"\"\n \n         if smbus_present == 0:  # if called from psuutil outside of pmon\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n@@ -150,7 +145,7 @@ def get_status(self):\n         \"\"\"\n \n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n             sonic_logger.log_warning(\"PMON psu-smbus - presence = 0 \")\n         else:\n@@ -179,7 +174,7 @@ def get_voltage(self):\n             e.g. 12.1\n         \"\"\"\n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n@@ -226,7 +221,7 @@ def get_powergood_status(self):\n         \"\"\"\n \n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus(0)\ndiff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py\nindex d95e7a522..9d8e7e739 100644\n--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py\n+++ b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py\n@@ -3,8 +3,7 @@\n #\n #############################################################################\n \n-import os\n-import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.sfp_base import SfpBase\n@@ -12,14 +11,10 @@\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom\n     from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper\n     from sonic_py_common import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n smbus_present = 1\n \n try:\n@@ -118,7 +113,7 @@ class Sfp(SfpBase):\n     # Paths\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"armhf-nokia_ixs7215_52x-r0\"\n     HWSKU = \"Nokia-7215\"\n@@ -186,7 +181,7 @@ def __convert_string_to_num(self, value_str):\n             return 'N/A'\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n@@ -811,7 +806,7 @@ def tx_disable(self, tx_disable):\n             return False\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, register = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x5')\n+            cmdstatus, register = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x5'])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"sfp cmdstatus i2c get failed %s\" % register )\n                 return False\n@@ -824,13 +819,13 @@ def tx_disable(self, tx_disable):\n \n         pos = [1, 2, 4, 8]\n         mask = pos[self.index-SFP_PORT_START]\n-        if tx_disable == True:\n+        if tx_disable is True:\n             setbits = register | mask\n         else:\n             setbits = register & ~mask\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, output = cmd.getstatusoutput('sudo i2cset -y -m 0x0f 0 0x41 0x5 %d' % setbits)\n+            cmdstatus, output = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '-m', '0x0f', '0', '0x41', '0x5', str(setbits)])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"sfp cmdstatus i2c write failed %s\" % output )\n                 return False\n@@ -912,7 +907,7 @@ def get_presence(self):\n             return False\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')\n+            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])\n             sfpstatus = int(sfpstatus, 16)\n         else:\n             bus = smbus.SMBus(0)\ndiff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py\nindex fd494ca67..34fc2bc6a 100644\n--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py\n+++ b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py\n@@ -1,9 +1,9 @@\n '''\n listen for the SFP change event and return to chassis.\n '''\n-import sys\n import time\n from sonic_py_common import logger\n+from sonic_py_common.general import getstatusoutput_noshell\n \n smbus_present = 1\n \n@@ -12,11 +12,6 @@\n except ImportError as e:\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n # system level event/error\n EVENT_ON_ALL_SFP = '-1'\n SYSTEM_NOT_READY = 'system_not_ready'\n@@ -51,7 +46,7 @@ def deinitialize(self):\n     def _get_transceiver_status(self):\n         if smbus_present == 0:\n             sonic_logger.log_info(\"  PMON - smbus ERROR - DEBUG sfp_event   \")\n-            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')\n+            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])\n             sfpstatus = int(sfpstatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n", "message": "", "files": {"/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py": {"changes": [{"diff": "\n     def __init__(self, name, path, cpld_root, ro):\n         self.eeprom_path = \"/sys/class/i2c-adapter/i2c-0/0-0053/eeprom\"\n         if not os.path.exists(self.eeprom_path):\n-            os.system(\"echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device\")\n+            file = \"/sys/class/i2c-adapter/i2c-0/new_device\"\n+            with open(file, 'w') as f:\n+                f.write('24c02 0x53\\n')\n         super(board, self).__init__(self.eeprom_path, 0, '', True)", "add": 3, "remove": 1, "filename": "/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py", "badparts": ["            os.system(\"echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device\")"], "goodparts": ["            file = \"/sys/class/i2c-adapter/i2c-0/new_device\"", "            with open(file, 'w') as f:", "                f.write('24c02 0x53\\n')"]}], "source": "\ntry: import os from sonic_eeprom import eeprom_tlvinfo except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class board(eeprom_tlvinfo.TlvInfoDecoder): def __init__(self, name, path, cpld_root, ro): self.eeprom_path=\"/sys/class/i2c-adapter/i2c-0/0-0053/eeprom\" if not os.path.exists(self.eeprom_path): os.system(\"echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device\") super(board, self).__init__(self.eeprom_path, 0, '', True) ", "sourceWithComments": "try:\n    import os\n    from sonic_eeprom import eeprom_tlvinfo\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass board(eeprom_tlvinfo.TlvInfoDecoder):\n\n    def __init__(self, name, path, cpld_root, ro):\n        self.eeprom_path = \"/sys/class/i2c-adapter/i2c-0/0-0053/eeprom\"\n        if not os.path.exists(self.eeprom_path):\n            os.system(\"echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device\")\n        super(board, self).__init__(self.eeprom_path, 0, '', True)\n"}, "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py": {"changes": [{"diff": "\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n MAX_SELECT_DELAY = 3600\n COPPER_PORT_START = 1\n COPPER_PORT_END = 48\n", "add": 0, "remove": 5, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py", "badparts": ["if sys.version_info[0] < 3:", "    import commands as cmd", "else:", "    import subprocess as cmd"], "goodparts": []}, {"diff": "\n             string: Revision value of chassis\n         \"\"\"\n         if smbus_present == 0:  # called from host\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x0')\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x0'])\n         else:\n             bus = smbus.SMBus(0)\n             DEVICE_ADDRESS = 0x41\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py", "badparts": ["            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x0')"], "goodparts": ["            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x0'])"]}, {"diff": "\n \n         # Write sys led\n         if smbus_present == 0:  # called from host (e.g. 'show system-health')\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cset -y 0 0x41 0x7 %d' % value)\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '0', '0x41', '0x7', str(value)])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"  System LED set %s failed\" % value)\n                 return False\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py", "badparts": ["            cmdstatus, value = cmd.getstatusoutput('sudo i2cset -y 0 0x41 0x7 %d' % value)"], "goodparts": ["            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '0', '0x41', '0x7', str(value)])"]}, {"diff": "\n         \"\"\"\n         # Read sys led\n         if smbus_present == 0:  # called from host\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x7')\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x7'])\n             value = int(value, 16)\n         else:\n             bus = smbus.SMBus(0", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py", "badparts": ["            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x7')"], "goodparts": ["            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x7'])"]}], "source": "\n try: import os import sys import glob from sonic_platform_base.chassis_base import ChassisBase from sonic_platform.sfp import Sfp from sonic_platform.eeprom import Eeprom from sonic_platform.fan import Fan from.fan_drawer import RealDrawer from sonic_platform.psu import Psu from sonic_platform.thermal import Thermal from sonic_platform.component import Component from sonic_py_common import logger except ImportError as e: raise ImportError(str(e) +\"-required module not found\") smbus_present=1 try: import smbus except ImportError as e: smbus_present=0 if sys.version_info[0] < 3: import commands as cmd else: import subprocess as cmd MAX_SELECT_DELAY=3600 COPPER_PORT_START=1 COPPER_PORT_END=48 SFP_PORT_START=49 SFP_PORT_END=52 PORT_END=52 MAX_7215_FAN_DRAWERS=2 MAX_7215_FANS_PER_DRAWER=1 MAX_7215_PSU=2 MAX_7215_THERMAL=6 MAX_7215_COMPONENT=2 SYSLOG_IDENTIFIER=\"chassis\" sonic_logger=logger.Logger(SYSLOG_IDENTIFIER) class Chassis(ChassisBase): \"\"\" Nokia platform-specific Chassis class Derived from Dell S6000 platform. customized for the 7215 platform. \"\"\" def __init__(self): ChassisBase.__init__(self) self.system_led_supported_color=['off', 'amber', 'green', 'amber_blink', 'green_blink'] self.COPPER_PORT_START=COPPER_PORT_START self.COPPER_PORT_END=COPPER_PORT_END self.SFP_PORT_START=SFP_PORT_START self.SFP_PORT_END=SFP_PORT_END self.PORT_END=PORT_END for index in range(self.COPPER_PORT_START, self.COPPER_PORT_END+1): sfp_node=Sfp(index, 'COPPER', 'N/A', 'N/A') self._sfp_list.append(sfp_node) eeprom_path=\"/sys/class/i2c-adapter/i2c-{0}/{0}-0050/eeprom\" mux_dev=sorted(glob.glob(\"/sys/class/i2c-adapter/i2c-0/i2c-[0-9]\")) y=0 for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1): mux_dev_num=mux_dev[y] port_i2c_map=mux_dev_num[-1] y=y +1 port_eeprom_path=eeprom_path.format(port_i2c_map) if not os.path.exists(port_eeprom_path): sonic_logger.log_info(\"path %s didnt exist\" % port_eeprom_path) sfp_node=Sfp(index, 'SFP', port_eeprom_path, port_i2c_map) self._sfp_list.append(sfp_node) self.sfp_event_initialized=False self._eeprom=Eeprom() drawer_num=MAX_7215_FAN_DRAWERS fan_num_per_drawer=MAX_7215_FANS_PER_DRAWER drawer_ctor=RealDrawer fan_index=0 for drawer_index in range(drawer_num): drawer=drawer_ctor(drawer_index) self._fan_drawer_list.append(drawer) for index in range(fan_num_per_drawer): fan=Fan(fan_index, drawer) fan_index +=1 drawer._fan_list.append(fan) self._fan_list.append(fan) for i in range(MAX_7215_PSU): psu=Psu(i) self._psu_list.append(psu) for i in range(MAX_7215_THERMAL): thermal=Thermal(i) self._thermal_list.append(thermal) for i in range(MAX_7215_COMPONENT): component=Component(i) self._component_list.append(component) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of physical SFP ports in a chassis starting from 1. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_name(self): \"\"\" Retrieves the name of the chassis Returns: string: The name of the chassis \"\"\" return self._eeprom.modelstr() def get_presence(self): \"\"\" Retrieves the presence of the chassis Returns: bool: True if chassis is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the chassis Returns: string: Model/part number of chassis \"\"\" return self._eeprom.part_number_str() def get_service_tag(self): \"\"\" Retrieves the Service Tag of the chassis Returns: string: Service Tag of chassis \"\"\" return self._eeprom.service_tag_str() def get_status(self): \"\"\" Retrieves the operational status of the chassis Returns: bool: A boolean value, True if chassis is operating properly False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.base_mac_addr() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.serial_number_str() def get_revision(self): \"\"\" Retrieves the hardware revision of the chassis Returns: string: Revision value of chassis \"\"\" if smbus_present==0: cmdstatus, value=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x0') else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0x0 value=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) return str(value) def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.system_eeprom_info() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" return(ChassisBase.REBOOT_CAUSE_NON_HARDWARE, None) def get_change_event(self, timeout=0): \"\"\" Returns a nested dictionary containing all devices which have experienced a change at chassis level Args: timeout: Timeout in milliseconds(optional). If timeout==0, this method will block until a change is detected. Returns: (bool, dict): -True if call successful, False if not; -A nested dictionary where key is a device type, value is a dictionary with key:value pairs in the format of {'device_id':'device_event'}, where device_id is the device ID for this device and device_event, status='1' represents device inserted, status='0' represents device removed. Ex.{'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}} indicates that fan 0 has been removed, fan 2 has been inserted and sfp 11 has been removed. \"\"\" if not self.sfp_event_initialized: from sonic_platform.sfp_event import sfp_event self.sfp_event=sfp_event() self.sfp_event.initialize() self.MAX_SELECT_EVENT_RETURNED=self.PORT_END self.sfp_event_initialized=True wait_for_ever=(timeout==0) port_dict={} if wait_for_ever: timeout=MAX_SELECT_DELAY while True: status=self.sfp_event.check_sfp_status(port_dict, timeout) if not port_dict=={}: break else: status=self.sfp_event.check_sfp_status(port_dict, timeout) if status: return True,{'sfp': port_dict} else: return True,{'sfp':{}} def get_thermal_manager(self): from.thermal_manager import ThermalManager return ThermalManager def initizalize_system_led(self): return True def set_status_led(self, color): \"\"\" Sets the state of the system LED Args: color: A string representing the color with which to set the system LED Returns: bool: True if system LED state is set successfully, False if not \"\"\" if color not in self.system_led_supported_color: return False if(color=='off'): value=0x00 elif(color=='amber'): value=0x01 elif(color=='green'): value=0x02 elif(color=='amber_blink'): value=0x03 elif(color=='green_blink'): value=0x04 else: return False if smbus_present==0: cmdstatus, value=cmd.getstatusoutput('sudo i2cset -y 0 0x41 0x7 %d' % value) if cmdstatus: sonic_logger.log_warning(\" System LED set %s failed\" % value) return False else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICEREG=0x7 bus.write_byte_data(DEVICE_ADDRESS, DEVICEREG, value) return True def get_status_led(self): \"\"\" Gets the state of the system LED Returns: A string, one of the valid LED color strings which could be vendor specified. \"\"\" if smbus_present==0: cmdstatus, value=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x7') value=int(value, 16) else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0x7 value=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) if value==0x00: color='off' elif value==0x01: color='amber' elif value==0x02: color='green' elif value==0x03: color='amber_blink' elif value==0x04: color='green_blink' else: return None return color def get_watchdog(self): \"\"\" Retrieves hardware watchdog device on this chassis Returns: An object derived from WatchdogBase representing the hardware watchdog device Note: We overload this method to ensure that watchdog is only initialized when it is referenced. Currently, only one daemon can open the watchdog. To initialize watchdog in the constructor causes multiple daemon try opening watchdog when loading and constructing a chassis object and fail. By doing so we can eliminate that risk. \"\"\" try: if self._watchdog is None: from sonic_platform.watchdog import WatchdogImplBase watchdog_device_path=\"/dev/watchdog0\" self._watchdog=WatchdogImplBase(watchdog_device_path) except Exception as e: sonic_logger.log_warning(\" Fail to load watchdog{}\".format(repr(e))) return self._watchdog def get_position_in_parent(self): \"\"\" \t\tRetrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned \t\tReturns: \t\t integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \t\t\"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the platform information\n#\n#############################################################################\n\ntry:\n    import os\n    import sys\n    import glob\n    from sonic_platform_base.chassis_base import ChassisBase\n    from sonic_platform.sfp import Sfp\n    from sonic_platform.eeprom import Eeprom\n    from sonic_platform.fan import Fan\n    from .fan_drawer import RealDrawer\n    from sonic_platform.psu import Psu\n    from sonic_platform.thermal import Thermal\n    from sonic_platform.component import Component\n    from sonic_py_common import logger\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nsmbus_present = 1\ntry:\n    import smbus\nexcept ImportError as e:\n    smbus_present = 0\n\nif sys.version_info[0] < 3:\n    import commands as cmd\nelse:\n    import subprocess as cmd\n\nMAX_SELECT_DELAY = 3600\nCOPPER_PORT_START = 1\nCOPPER_PORT_END = 48\nSFP_PORT_START = 49\nSFP_PORT_END = 52\nPORT_END = 52\n\n# Device counts\nMAX_7215_FAN_DRAWERS = 2\nMAX_7215_FANS_PER_DRAWER = 1\nMAX_7215_PSU = 2\nMAX_7215_THERMAL = 6\n\n# Temp - disable these to help with early debug\nMAX_7215_COMPONENT = 2\n\nSYSLOG_IDENTIFIER = \"chassis\"\nsonic_logger = logger.Logger(SYSLOG_IDENTIFIER)\n\n\nclass Chassis(ChassisBase):\n    \"\"\"\n    Nokia platform-specific Chassis class\n        Derived from Dell S6000 platform.\n        customized for the 7215 platform.\n    \"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self.system_led_supported_color = ['off', 'amber', 'green', 'amber_blink', 'green_blink']\n        # Port numbers for SFP List Initialization\n        self.COPPER_PORT_START = COPPER_PORT_START\n        self.COPPER_PORT_END = COPPER_PORT_END\n        self.SFP_PORT_START = SFP_PORT_START\n        self.SFP_PORT_END = SFP_PORT_END\n        self.PORT_END = PORT_END\n\n        # for non-sfp ports create dummy objects for copper / non-sfp ports\n        for index in range(self.COPPER_PORT_START, self.COPPER_PORT_END+1):\n            sfp_node = Sfp(index, 'COPPER', 'N/A', 'N/A')\n            self._sfp_list.append(sfp_node)\n\n        # Verify optoe2 driver SFP eeprom devices were enumerated and exist\n        # then create the sfp nodes\n        eeprom_path = \"/sys/class/i2c-adapter/i2c-{0}/{0}-0050/eeprom\"\n        mux_dev = sorted(glob.glob(\"/sys/class/i2c-adapter/i2c-0/i2c-[0-9]\"))\n        y = 0\n        for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1):\n            mux_dev_num = mux_dev[y]\n            port_i2c_map = mux_dev_num[-1]\n            y = y + 1\n            port_eeprom_path = eeprom_path.format(port_i2c_map)\n            if not os.path.exists(port_eeprom_path):\n                sonic_logger.log_info(\"path %s didnt exist\" % port_eeprom_path)\n            sfp_node = Sfp(index, 'SFP', port_eeprom_path, port_i2c_map)\n            self._sfp_list.append(sfp_node)\n        self.sfp_event_initialized = False\n\n        # Instantiate system eeprom object\n        self._eeprom = Eeprom()\n\n        # Construct lists fans, power supplies, thermals & components\n        drawer_num = MAX_7215_FAN_DRAWERS\n        fan_num_per_drawer = MAX_7215_FANS_PER_DRAWER\n        drawer_ctor = RealDrawer\n        fan_index = 0\n        for drawer_index in range(drawer_num):\n            drawer = drawer_ctor(drawer_index)\n            self._fan_drawer_list.append(drawer)\n            for index in range(fan_num_per_drawer):\n                fan = Fan(fan_index, drawer)\n                fan_index += 1\n                drawer._fan_list.append(fan)\n                self._fan_list.append(fan)\n\n        for i in range(MAX_7215_PSU):\n            psu = Psu(i)\n            self._psu_list.append(psu)\n\n        for i in range(MAX_7215_THERMAL):\n            thermal = Thermal(i)\n            self._thermal_list.append(thermal)\n\n        for i in range(MAX_7215_COMPONENT):\n            component = Component(i)\n            self._component_list.append(component)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of physical SFP ports in a\n            chassis starting from 1.\n\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the chassis\n        Returns:\n            string: The name of the chassis\n        \"\"\"\n        return self._eeprom.modelstr()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the chassis\n        Returns:\n            bool: True if chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the chassis\n        Returns:\n            string: Model/part number of chassis\n        \"\"\"\n        return self._eeprom.part_number_str()\n\n    def get_service_tag(self):\n        \"\"\"\n        Retrieves the Service Tag of the chassis\n        Returns:\n            string: Service Tag of chassis\n        \"\"\"\n        return self._eeprom.service_tag_str()\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the chassis\n        Returns:\n            bool: A boolean value, True if chassis is operating properly\n            False if not\n        \"\"\"\n        return True\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.base_mac_addr()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n\n        Returns:\n            A string containing the hardware serial number for this\n            chassis.\n        \"\"\"\n        return self._eeprom.serial_number_str()\n\n    def get_revision(self):\n        \"\"\"\n        Retrieves the hardware revision of the chassis\n\n        Returns:\n            string: Revision value of chassis\n        \"\"\"\n        if smbus_present == 0:  # called from host\n            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x0')\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0x0\n            value = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n        return str(value)\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the\n        chassis\n\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their\n            corresponding values.\n        \"\"\"\n        return self._eeprom.system_eeprom_info()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        # The ixs7215 CPLD does not have a hardware reboot cause register so\n        # the hardware portion of reboot cause can't be implemented\n\n        return (ChassisBase.REBOOT_CAUSE_NON_HARDWARE, None)\n\n    def get_change_event(self, timeout=0):\n        \"\"\"\n        Returns a nested dictionary containing all devices which have\n        experienced a change at chassis level\n\n        Args:\n            timeout: Timeout in milliseconds (optional). If timeout == 0,\n                this method will block until a change is detected.\n\n        Returns:\n            (bool, dict):\n                - True if call successful, False if not;\n                - A nested dictionary where key is a device type,\n                  value is a dictionary with key:value pairs in the format of\n                  {'device_id':'device_event'},\n                  where device_id is the device ID for this device and\n                        device_event,\n                             status='1' represents device inserted,\n                             status='0' represents device removed.\n                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}\n                      indicates that fan 0 has been removed, fan 2\n                      has been inserted and sfp 11 has been removed.\n        \"\"\"\n        # Initialize SFP event first\n        if not self.sfp_event_initialized:\n            from sonic_platform.sfp_event import sfp_event\n            self.sfp_event = sfp_event()\n            self.sfp_event.initialize()\n            self.MAX_SELECT_EVENT_RETURNED = self.PORT_END\n            self.sfp_event_initialized = True\n\n        wait_for_ever = (timeout == 0)\n        port_dict = {}\n        if wait_for_ever:\n            # xrcvd will call this monitor loop in the \"SYSTEM_READY\" state\n            timeout = MAX_SELECT_DELAY\n            while True:\n                status = self.sfp_event.check_sfp_status(port_dict, timeout)\n                if not port_dict == {}:\n                    break\n        else:\n            # At boot up and in \"INIT\" state call from xrcvd will have timeout\n            # value return true without change after timeout and will\n            # transition to \"SYSTEM_READY\"\n            status = self.sfp_event.check_sfp_status(port_dict, timeout)\n\n        if status:\n            return True, {'sfp': port_dict}\n        else:\n            return True, {'sfp': {}}\n\n    def get_thermal_manager(self):\n        from .thermal_manager import ThermalManager\n        return ThermalManager\n\n    def initizalize_system_led(self):\n        return True\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the system LED\n\n        Args:\n            color: A string representing the color with which to set the\n                   system LED\n\n        Returns:\n            bool: True if system LED state is set successfully, False if not\n        \"\"\"\n        if color not in self.system_led_supported_color:\n            return False\n\n        if (color == 'off'):\n            value = 0x00\n        elif (color == 'amber'):\n            value = 0x01\n        elif (color == 'green'):\n            value = 0x02\n        elif (color == 'amber_blink'):\n            value = 0x03\n        elif (color == 'green_blink'):\n            value = 0x04\n        else:\n            return False\n\n        # Write sys led\n        if smbus_present == 0:  # called from host (e.g. 'show system-health')\n            cmdstatus, value = cmd.getstatusoutput('sudo i2cset -y 0 0x41 0x7 %d' % value)\n            if cmdstatus:\n                sonic_logger.log_warning(\"  System LED set %s failed\" % value)\n                return False\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICEREG = 0x7\n            bus.write_byte_data(DEVICE_ADDRESS, DEVICEREG, value)\n\n        return True\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the system LED\n\n        Returns:\n            A string, one of the valid LED color strings which could be vendor\n            specified.\n        \"\"\"\n        # Read sys led\n        if smbus_present == 0:  # called from host\n            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x7')\n            value = int(value, 16)\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0x7\n            value = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n        if value == 0x00:\n            color = 'off'\n        elif value == 0x01:\n            color = 'amber'\n        elif value == 0x02:\n            color = 'green'\n        elif value == 0x03:\n            color = 'amber_blink'\n        elif value == 0x04:\n            color = 'green_blink'\n        else:\n            return None\n\n        return color\n\n    def get_watchdog(self):\n        \"\"\"\n        Retrieves hardware watchdog device on this chassis\n\n        Returns:\n            An object derived from WatchdogBase representing the hardware\n            watchdog device\n\n        Note:\n            We overload this method to ensure that watchdog is only initialized\n            when it is referenced. Currently, only one daemon can open the\n            watchdog. To initialize watchdog in the constructor causes multiple\n            daemon try opening watchdog when loading and constructing a chassis\n            object and fail. By doing so we can eliminate that risk.\n        \"\"\"\n        try:\n            if self._watchdog is None:\n                from sonic_platform.watchdog import WatchdogImplBase\n                watchdog_device_path = \"/dev/watchdog0\"\n                self._watchdog = WatchdogImplBase(watchdog_device_path)\n        except Exception as e:\n            sonic_logger.log_warning(\" Fail to load watchdog {}\".format(repr(e)))\n\n        return self._watchdog\n\n    def get_position_in_parent(self):\n        \"\"\"\n\t\tRetrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n\t\tReturns:\n\t\t    integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n\t\t\"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py": {"changes": [{"diff": "\n \n try:\n     import os\n-    import sys\n     import subprocess\n     import ntpath\n     from sonic_platform_base.component_base import ComponentBase\n+    from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py", "badparts": ["    import sys"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe"]}, {"diff": "\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n \n class Component(ComponentBase):\n     \"\"\"Nokia platform-specific Component class\"\"\"\n", "add": 0, "remove": 5, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py", "badparts": ["if sys.version_info[0] < 3:", "    import commands as cmd", "else:", "    import subprocess as cmd"], "goodparts": []}, {"diff": "\n         [\"System-CPLD\", \"Used for managing SFPs, LEDs, PSUs and FANs \"],\n         [\"U-Boot\", \"Performs initialization during booting\"],\n     ]\n-    CPLD_UPDATE_COMMAND = 'cp /usr/sbin/vme /tmp; cp {} /tmp; cd /tmp; ./vme {};'\n+    CPLD_UPDATE_COMMAND1 = ['cp', '/usr/sbin/vme', '/tmp']\n+    CPLD_UPDATE_COMMAND2 = ['cp', '', '/tmp']\n+    CPLD_UPDATE_COMMAND3 = ['cd', '/tmp']\n+    CPLD_UPDATE_COMMAND4 = ['./vme', '']\n \n     def __init__(self, component_index):\n         self.index = component_index\n         self.name = self.CHASSIS_COMPONENTS[self.index][0]\n         self.description = self.CHASSIS_COMPONENTS[self.index][1]\n \n-    def _get_command_result(self, cmdline):\n-        try:\n-            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,\n-                                    stderr=subprocess.STDOUT)\n-            stdout = proc.communicate()[0]\n-            proc.wait()\n-            result = stdout.rstrip('\\n')\n-        except OSError:\n-            result = None\n-\n-        return result\n-\n     def _get_cpld_version(self, cpld_number):\n \n         if smbus_present == 0:\n-            cmdstatus, cpld_version = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x2')\n+            cmdstatus, cpld_version = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x2'])\n         else:\n             bus = smbus.SMBus(0)\n             DEVICE_ADDRESS = 0x41\n", "add": 5, "remove": 14, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py", "badparts": ["    CPLD_UPDATE_COMMAND = 'cp /usr/sbin/vme /tmp; cp {} /tmp; cd /tmp; ./vme {};'", "    def _get_command_result(self, cmdline):", "        try:", "            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,", "                                    stderr=subprocess.STDOUT)", "            stdout = proc.communicate()[0]", "            proc.wait()", "            result = stdout.rstrip('\\n')", "        except OSError:", "            result = None", "        return result", "            cmdstatus, cpld_version = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x2')"], "goodparts": ["    CPLD_UPDATE_COMMAND1 = ['cp', '/usr/sbin/vme', '/tmp']", "    CPLD_UPDATE_COMMAND2 = ['cp', '', '/tmp']", "    CPLD_UPDATE_COMMAND3 = ['cd', '/tmp']", "    CPLD_UPDATE_COMMAND4 = ['./vme', '']", "            cmdstatus, cpld_version = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x2'])"]}, {"diff": "\n             return self._get_cpld_version(self.index)\n \n         if self.index == 1:\n-            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -1 | cut -d\" \" -f2-4')\n+            cmd1 = ['grep', '--null-data', 'U-Boot', '/dev/mtd0ro']\n+            cmd2 = ['head', '-1']\n+            cmd3 = ['cut', '-d', ' ', '-f2-4']\n+            cmdstatus, uboot_version = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)\n             return uboot_version\n \n     def install_firmware(self, image_path):\n", "add": 4, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py", "badparts": ["            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -1 | cut -d\" \" -f2-4')"], "goodparts": ["            cmd1 = ['grep', '--null-data', 'U-Boot', '/dev/mtd0ro']", "            cmd2 = ['head', '-1']", "            cmd3 = ['cut', '-d', ' ', '-f2-4']", "            cmdstatus, uboot_version = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)"]}, {"diff": "\n             print(\"ERROR: the cpld image {} doesn't exist \".format(image_path))\n             return False\n \n-        cmdline = self.CPLD_UPDATE_COMMAND.format(image_path, image_name)\n+        self.CPLD_UPDATE_COMMAND2[1] = image_path\n+        self.CPLD_UPDATE_COMMAND4[1] = image_name\n \n         success_flag = False\n-\n-        try:\n-            subprocess.check_call(cmdline, stderr=subprocess.STDOUT, shell=True)\n+ \n+        try:   \n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND1, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND2, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND3, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND4, stderr=subprocess.STDOUT)\n             success_flag = True\n         except subprocess.CalledProcessError as e:\n             print(\"ERROR: Failed to upgrade CPLD: rc={}\".format(e.returncode", "add": 8, "remove": 4, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py", "badparts": ["        cmdline = self.CPLD_UPDATE_COMMAND.format(image_path, image_name)", "        try:", "            subprocess.check_call(cmdline, stderr=subprocess.STDOUT, shell=True)"], "goodparts": ["        self.CPLD_UPDATE_COMMAND2[1] = image_path", "        self.CPLD_UPDATE_COMMAND4[1] = image_name", "        try:   ", "            subprocess.check_call(self.CPLD_UPDATE_COMMAND1, stderr=subprocess.STDOUT)", "            subprocess.check_call(self.CPLD_UPDATE_COMMAND2, stderr=subprocess.STDOUT)", "            subprocess.check_call(self.CPLD_UPDATE_COMMAND3, stderr=subprocess.STDOUT)", "            subprocess.check_call(self.CPLD_UPDATE_COMMAND4, stderr=subprocess.STDOUT)"]}], "source": "\n try: import os import sys import subprocess import ntpath from sonic_platform_base.component_base import ComponentBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") smbus_present=1 try: import smbus except ImportError as e: smbus_present=0 if sys.version_info[0] < 3: import commands as cmd else: import subprocess as cmd class Component(ComponentBase): \"\"\"Nokia platform-specific Component class\"\"\" CHASSIS_COMPONENTS=[ [\"System-CPLD\", \"Used for managing SFPs, LEDs, PSUs and FANs \"], [\"U-Boot\", \"Performs initialization during booting\"], ] CPLD_UPDATE_COMMAND='cp /usr/sbin/vme /tmp; cp{} /tmp; cd /tmp;./vme{};' def __init__(self, component_index): self.index=component_index self.name=self.CHASSIS_COMPONENTS[self.index][0] self.description=self.CHASSIS_COMPONENTS[self.index][1] def _get_command_result(self, cmdline): try: proc=subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE, stderr=subprocess.STDOUT) stdout=proc.communicate()[0] proc.wait() result=stdout.rstrip('\\n') except OSError: result=None return result def _get_cpld_version(self, cpld_number): if smbus_present==0: cmdstatus, cpld_version=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x2') else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0x2 cpld_version=str(bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)) return str(int(cpld_version, 16)) def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return self.name def get_model(self): \"\"\" Retrieves the part number of the component Returns: string: Part number of component \"\"\" return 'NA' def get_serial(self): \"\"\" Retrieves the serial number of the component Returns: string: Serial number of component \"\"\" return 'NA' def get_presence(self): \"\"\" Retrieves the presence of the component Returns: bool: True if present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the component Returns: bool: True if component is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether component is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return self.description def get_firmware_version(self): \"\"\" Retrieves the firmware version of the component Returns: A string containing the firmware version of the component \"\"\" if self.index==0: return self._get_cpld_version(self.index) if self.index==1: cmdstatus, uboot_version=cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -1 | cut -d\" \" -f2-4') return uboot_version def install_firmware(self, image_path): \"\"\" Installs firmware to the component Args: image_path: A string, path to firmware image Returns: A boolean, True if install was successful, False if not \"\"\" image_name=ntpath.basename(image_path) print(\" ixs7215 -install cpld{}\".format(image_name)) if not os.path.isfile(image_path): print(\"ERROR: the cpld image{} doesn't exist \".format(image_path)) return False cmdline=self.CPLD_UPDATE_COMMAND.format(image_path, image_name) success_flag=False try: subprocess.check_call(cmdline, stderr=subprocess.STDOUT, shell=True) success_flag=True except subprocess.CalledProcessError as e: print(\"ERROR: Failed to upgrade CPLD: rc={}\".format(e.returncode)) if success_flag: print(\"INFO: Refresh or power cycle is required to finish CPLD installation\") return success_flag ", "sourceWithComments": "########################################################################\n# NOKIA IXS7215\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Components' (e.g., BIOS, CPLD, FPGA, etc.) available in\n# the platform\n#\n########################################################################\n\ntry:\n    import os\n    import sys\n    import subprocess\n    import ntpath\n    from sonic_platform_base.component_base import ComponentBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nsmbus_present = 1\ntry:\n    import smbus\nexcept ImportError as e:\n    smbus_present = 0\n\nif sys.version_info[0] < 3:\n    import commands as cmd\nelse:\n    import subprocess as cmd\n\n\nclass Component(ComponentBase):\n    \"\"\"Nokia platform-specific Component class\"\"\"\n\n    CHASSIS_COMPONENTS = [\n        [\"System-CPLD\", \"Used for managing SFPs, LEDs, PSUs and FANs \"],\n        [\"U-Boot\", \"Performs initialization during booting\"],\n    ]\n    CPLD_UPDATE_COMMAND = 'cp /usr/sbin/vme /tmp; cp {} /tmp; cd /tmp; ./vme {};'\n\n    def __init__(self, component_index):\n        self.index = component_index\n        self.name = self.CHASSIS_COMPONENTS[self.index][0]\n        self.description = self.CHASSIS_COMPONENTS[self.index][1]\n\n    def _get_command_result(self, cmdline):\n        try:\n            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,\n                                    stderr=subprocess.STDOUT)\n            stdout = proc.communicate()[0]\n            proc.wait()\n            result = stdout.rstrip('\\n')\n        except OSError:\n            result = None\n\n        return result\n\n    def _get_cpld_version(self, cpld_number):\n\n        if smbus_present == 0:\n            cmdstatus, cpld_version = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x2')\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0x2\n            cpld_version = str(bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG))\n\n        return str(int(cpld_version, 16))\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n\n        Returns:\n            A string containing the name of the component\n        \"\"\"\n        return self.name\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the part number of the component\n        Returns:\n            string: Part number of component\n        \"\"\"\n        return 'NA'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the component\n        Returns:\n            string: Serial number of component\n        \"\"\"\n        return 'NA'\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the component\n        Returns:\n            bool: True if  present, False if not\n        \"\"\"\n        return True\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the component\n        Returns:\n            bool: True if component is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        Returns:\n            integer: The 1-based relative physical position in parent\n            device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether component is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n\n        Returns:\n            A string containing the description of the component\n        \"\"\"\n        return self.description\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of the component\n\n        Returns:\n            A string containing the firmware version of the component\n        \"\"\"\n        if self.index == 0:\n            return self._get_cpld_version(self.index)\n\n        if self.index == 1:\n            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -1 | cut -d\" \" -f2-4')\n            return uboot_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Installs firmware to the component\n\n        Args:\n            image_path: A string, path to firmware image\n\n        Returns:\n            A boolean, True if install was successful, False if not\n        \"\"\"\n        image_name = ntpath.basename(image_path)\n        print(\" ixs7215 - install cpld {}\".format(image_name))\n\n        # check whether the image file exists\n        if not os.path.isfile(image_path):\n            print(\"ERROR: the cpld image {} doesn't exist \".format(image_path))\n            return False\n\n        cmdline = self.CPLD_UPDATE_COMMAND.format(image_path, image_name)\n\n        success_flag = False\n\n        try:\n            subprocess.check_call(cmdline, stderr=subprocess.STDOUT, shell=True)\n            success_flag = True\n        except subprocess.CalledProcessError as e:\n            print(\"ERROR: Failed to upgrade CPLD: rc={}\".format(e.returncode))\n\n        if success_flag:\n            print(\"INFO: Refresh or power cycle is required to finish CPLD installation\")\n\n        return success_flag\n\n"}, "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py": {"changes": [{"diff": "\n \n try:\n     import os\n-    import sys\n     from sonic_platform_base.psu_base import PsuBase\n     from sonic_py_common import logger\n     from sonic_platform.eeprom import Eeprom\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n smbus_present = 1\n try:\n     import smbus\n", "add": 1, "remove": 6, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py", "badparts": ["    import sys", "if sys.version_info[0] < 3:", "    import commands as cmd", "else:", "    import subprocess as cmd"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         \"\"\"\n \n         if smbus_present == 0:  # if called from psuutil outside of pmon\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py", "badparts": ["            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')"], "goodparts": ["            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])"]}, {"diff": "\n         \"\"\"\n \n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n             sonic_logger.log_warning(\"PMON psu-smbus - presence = 0 \")\n         else:\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py", "badparts": ["            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')"], "goodparts": ["            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])"]}, {"diff": "\n             e.g. 12.1\n         \"\"\"\n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py", "badparts": ["            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')"], "goodparts": ["            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])"]}, {"diff": "\n         \"\"\"\n \n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py", "badparts": ["            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')"], "goodparts": ["            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])"]}], "source": "\n try: import os import sys from sonic_platform_base.psu_base import PsuBase from sonic_py_common import logger from sonic_platform.eeprom import Eeprom except ImportError as e: raise ImportError(str(e) +\"-required module not found\") if sys.version_info[0] < 3: import commands as cmd else: import subprocess as cmd smbus_present=1 try: import smbus except ImportError as e: smbus_present=0 sonic_logger=logger.Logger('psu') class Psu(PsuBase): \"\"\"Nokia platform-specific PSU class for 7215 \"\"\" def __init__(self, psu_index): PsuBase.__init__(self) self.index=psu_index +1 self._fan_list=[] self.eeprom=Eeprom(is_psu=True, psu_index=self.index) def _write_sysfs_file(self, sysfs_file, value): rv='ERR' if(not os.path.isfile(sysfs_file)): return rv try: with open(sysfs_file, 'w') as fd: rv=fd.write(str(value)) except Exception as e: rv='ERR' return rv def _read_sysfs_file(self, sysfs_file): rv='ERR' if(not os.path.isfile(sysfs_file)): return rv try: with open(sysfs_file, 'r') as fd: rv=fd.read() except Exception as e: rv='ERR' rv=rv.rstrip('\\r\\n') rv=rv.lstrip(\" \") return rv def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return \"PSU{}\".format(self.index) def get_presence(self): \"\"\" Retrieves the presence of the Power Supply Unit(PSU) Returns: bool: True if PSU is present, False if not \"\"\" if smbus_present==0: cmdstatus, psustatus=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa') psustatus=int(psustatus, 16) else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0xa psustatus=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) if self.index==1: psustatus=psustatus & 1 if psustatus==1: return False if self.index==2: psustatus=psustatus & 2 if psustatus==2: return False return True def get_model(self): \"\"\" Retrieves the part number of the PSU Returns: string: Part number of PSU \"\"\" return self.eeprom.modelstr() def get_serial(self): \"\"\" Retrieves the serial number of the PSU Returns: string: Serial number of PSU \"\"\" return self.eeprom.serial_number_str() def get_revision(self): \"\"\" Retrieves the HW revision of the PSU Returns: string: HW revision of PSU \"\"\" return self.eeprom.part_number_str() def get_part_number(self): \"\"\" Retrieves the part number of the PSU Returns: string: Part number of PSU \"\"\" return self.eeprom.part_number_str() def get_status(self): \"\"\" Retrieves the operational status of the PSU Returns: bool: True if PSU is operating properly, False if not \"\"\" if smbus_present==0: cmdstatus, psustatus=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa') psustatus=int(psustatus, 16) sonic_logger.log_warning(\"PMON psu-smbus -presence=0 \") else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0xa psustatus=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) if self.index==1: psustatus=psustatus & 4 if psustatus==4: return True if self.index==2: psustatus=psustatus & 8 if psustatus==8: return True return False def get_voltage(self): \"\"\" Retrieves current PSU voltage output Returns: A float number, the output voltage in volts, e.g. 12.1 \"\"\" if smbus_present==0: cmdstatus, psustatus=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa') psustatus=int(psustatus, 16) else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0xa psustatus=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) if self.index==1: psustatus=psustatus & 4 if psustatus==4: psu_voltage=12.0 return psu_voltage if self.index==2: psustatus=psustatus & 8 if psustatus==8: psu_voltage=12.0 return psu_voltage psu_voltage=0.0 return psu_voltage def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device Returns: integer: The 1-based relative physical position in parent device \"\"\" return self.index def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return True def get_powergood_status(self): \"\"\" Retrieves the powergood status of PSU Returns: A boolean, True if PSU has stablized its output voltages and passed all its internal self-tests, False if not. \"\"\" if smbus_present==0: cmdstatus, psustatus=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa') psustatus=int(psustatus, 16) else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0xa psustatus=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) if self.index==1: psustatus=psustatus & 4 if psustatus==4: return True if self.index==2: psustatus=psustatus & 8 if psustatus==8: return True return False def get_status_led(self): \"\"\" Gets the state of the PSU status LED Returns: A string, one of the predefined STATUS_LED_COLOR_* strings. \"\"\" if self.get_powergood_status(): return self.STATUS_LED_COLOR_GREEN else: return self.STATUS_LED_COLOR_OFF def set_status_led(self, color): \"\"\" Sets the state of the PSU status LED Args: color: A string representing the color with which to set the PSU status LED Returns: bool: True if status LED state is set successfully, False if not \"\"\" return False def get_status_master_led(self): \"\"\" Gets the state of the front panel PSU status LED Returns: A string, one of the predefined STATUS_LED_COLOR_* strings. \"\"\" if(not os.path.isfile(\"/sys/class/gpio/psuLedGreen/value\") or not os.path.isfile(\"/sys/class/gpio/psuLedAmber/value\")): return None green=self._read_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\") amber=self._read_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\") if green==\"ERR\" or amber==\"ERR\": return None if green==\"1\": return self.STATUS_LED_COLOR_GREEN elif amber==\"1\": return self.STATUS_LED_COLOR_AMBER else: return None def set_status_master_led(self, color): \"\"\" Sets the state of the front panel PSU status LED Returns: bool: True if status LED state is set successfully, False if not \"\"\" if(not os.path.isfile(\"/sys/class/gpio/psuLedGreen/value\") or not os.path.isfile(\"/sys/class/gpio/psuLedAmber/value\")): return False if color==self.STATUS_LED_COLOR_GREEN: rvg=self._write_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\", 1) if rvg !=\"ERR\": rva=self._write_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\", 0) elif color==self.STATUS_LED_COLOR_AMBER: rvg=self._write_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\", 0) if rvg !=\"ERR\": rva=self._write_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\", 1) else: return False if rvg==\"ERR\" or rva==\"ERR\": return False return True ", "sourceWithComments": "########################################################################\n# Nokia IXS7215\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the PSUs' information which are available in the platform\n#\n########################################################################\n\ntry:\n    import os\n    import sys\n    from sonic_platform_base.psu_base import PsuBase\n    from sonic_py_common import logger\n    from sonic_platform.eeprom import Eeprom\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nif sys.version_info[0] < 3:\n    import commands as cmd\nelse:\n    import subprocess as cmd\n\nsmbus_present = 1\ntry:\n    import smbus\nexcept ImportError as e:\n    smbus_present = 0\n\nsonic_logger = logger.Logger('psu')\n\nclass Psu(PsuBase):\n    \"\"\"Nokia platform-specific PSU class for 7215 \"\"\"\n\n    def __init__(self, psu_index):\n        PsuBase.__init__(self)\n        # PSU is 1-based in Nokia platforms\n        self.index = psu_index + 1\n        self._fan_list = []\n\n        # PSU eeprom\n        self.eeprom = Eeprom(is_psu=True, psu_index=self.index)\n\n    def _write_sysfs_file(self, sysfs_file, value):\n        rv = 'ERR'\n\n        if (not os.path.isfile(sysfs_file)):\n            return rv\n        try:\n            with open(sysfs_file, 'w') as fd:\n                rv = fd.write(str(value))\n        except Exception as e:\n            rv = 'ERR'\n\n        return rv\n\n    def _read_sysfs_file(self, sysfs_file):\n        rv = 'ERR'\n\n        if (not os.path.isfile(sysfs_file)):\n            return rv\n        try:\n            with open(sysfs_file, 'r') as fd:\n                rv = fd.read()\n        except Exception as e:\n            rv = 'ERR'\n\n        rv = rv.rstrip('\\r\\n')\n        rv = rv.lstrip(\" \")\n        return rv\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n\n        Returns:\n            string: The name of the device\n        \"\"\"\n        return \"PSU{}\".format(self.index)\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Power Supply Unit (PSU)\n\n        Returns:\n            bool: True if PSU is present, False if not\n        \"\"\"\n\n        if smbus_present == 0:  # if called from psuutil outside of pmon\n            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n            psustatus = int(psustatus, 16)\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0xa\n            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n        if self.index == 1:\n            psustatus = psustatus & 1\n            if psustatus == 1:\n                return False\n        if self.index == 2:\n            psustatus = psustatus & 2\n            if psustatus == 2:\n                return False\n\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the part number of the PSU\n\n        Returns:\n            string: Part number of PSU\n        \"\"\"\n        return self.eeprom.modelstr()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the PSU\n\n        Returns:\n            string: Serial number of PSU\n        \"\"\"\n        return self.eeprom.serial_number_str()\n\n    def get_revision(self):\n        \"\"\"\n        Retrieves the HW revision of the PSU\n\n        Returns:\n            string: HW revision of PSU\n        \"\"\"\n        return self.eeprom.part_number_str()\n\n    def get_part_number(self):\n        \"\"\"\n        Retrieves the part number of the PSU\n\n        Returns:\n            string: Part number of PSU\n        \"\"\"\n        return self.eeprom.part_number_str()\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the PSU\n\n        Returns:\n            bool: True if PSU is operating properly, False if not\n        \"\"\"\n\n        if smbus_present == 0:\n            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n            psustatus = int(psustatus, 16)\n            sonic_logger.log_warning(\"PMON psu-smbus - presence = 0 \")\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0xa\n            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n        if self.index == 1:\n            psustatus = psustatus & 4\n            if psustatus == 4:\n                return True\n        if self.index == 2:\n            psustatus = psustatus & 8\n            if psustatus == 8:\n                return True\n\n        return False\n\n    def get_voltage(self):\n        \"\"\"\n        Retrieves current PSU voltage output\n\n        Returns:\n            A float number, the output voltage in volts,\n            e.g. 12.1\n        \"\"\"\n        if smbus_present == 0:\n            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n            psustatus = int(psustatus, 16)\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0xa\n            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n        if self.index == 1:\n            psustatus = psustatus & 4\n            if psustatus == 4:\n                psu_voltage = 12.0\n                return psu_voltage\n        if self.index == 2:\n            psustatus = psustatus & 8\n            if psustatus == 8:\n                psu_voltage = 12.0\n                return psu_voltage\n\n        psu_voltage = 0.0\n        return psu_voltage\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device\n        Returns:\n            integer: The 1-based relative physical position in parent device\n        \"\"\"\n        return self.index\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return True\n\n    def get_powergood_status(self):\n        \"\"\"\n        Retrieves the powergood status of PSU\n        Returns:\n            A boolean, True if PSU has stablized its output voltages and\n            passed all its internal self-tests, False if not.\n        \"\"\"\n\n        if smbus_present == 0:\n            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n            psustatus = int(psustatus, 16)\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0xa\n            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n        if self.index == 1:\n            psustatus = psustatus & 4\n            if psustatus == 4:\n                return True\n        if self.index == 2:\n            psustatus = psustatus & 8\n            if psustatus == 8:\n                return True\n\n        return False\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the PSU status LED\n\n        Returns:\n            A string, one of the predefined STATUS_LED_COLOR_* strings.\n        \"\"\"\n        if self.get_powergood_status():\n            return self.STATUS_LED_COLOR_GREEN\n        else:\n            return self.STATUS_LED_COLOR_OFF\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the PSU status LED\n        Args:\n            color: A string representing the color with which to set the\n                   PSU status LED\n        Returns:\n            bool: True if status LED state is set successfully, False if\n                  not\n        \"\"\"\n        # The firmware running in the PSU controls the LED\n        # and the PSU LED state cannot be changed from CPU.\n        return False\n\n    def get_status_master_led(self):\n        \"\"\"\n        Gets the state of the front panel PSU status LED\n\n        Returns:\n            A string, one of the predefined STATUS_LED_COLOR_* strings.\n        \"\"\"\n        if (not os.path.isfile(\"/sys/class/gpio/psuLedGreen/value\") or\n            not os.path.isfile(\"/sys/class/gpio/psuLedAmber/value\")):\n            return None\n\n        green = self._read_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\")\n        amber = self._read_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\")\n        if green == \"ERR\" or amber == \"ERR\":\n            return None\n        if green == \"1\":\n            return self.STATUS_LED_COLOR_GREEN\n        elif amber == \"1\":\n            return self.STATUS_LED_COLOR_AMBER\n        else:\n            return None\n\n    def set_status_master_led(self, color):\n        \"\"\"\n        Sets the state of the front panel PSU status LED\n\n        Returns:\n            bool: True if status LED state is set successfully, False if\n                  not\n        \"\"\"\n        if (not os.path.isfile(\"/sys/class/gpio/psuLedGreen/value\") or\n            not os.path.isfile(\"/sys/class/gpio/psuLedAmber/value\")):\n            return False\n\n        if color == self.STATUS_LED_COLOR_GREEN:\n            rvg = self._write_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\", 1)\n            if rvg != \"ERR\":\n                rva = self._write_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\", 0)\n        elif color == self.STATUS_LED_COLOR_AMBER:\n            rvg = self._write_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\", 0)\n            if rvg != \"ERR\":\n                rva = self._write_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\", 1)\n        else:\n            return False\n\n        if rvg == \"ERR\" or rva == \"ERR\":\n            return False\n\n        return True\n"}, "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import os\n-import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.sfp_base import SfpBase\n", "add": 1, "remove": 2, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["import sys"], "goodparts": ["import subprocess"]}, {"diff": "\n     from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper\n     from sonic_py_common import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n smbus_present = 1\n \n try:\n", "add": 1, "remove": 5, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["if sys.version_info[0] < 3:", "    import commands as cmd", "else:", "    import subprocess as cmd"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n     # Paths\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"armhf-nokia_ixs7215_52x-r0\"\n     HWSKU = \"Nokia-7215\"\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n             return 'N/A'\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}, {"diff": "\n             return False\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, register = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x5')\n+            cmdstatus, register = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x5'])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"sfp cmdstatus i2c get failed %s\" % register )\n                 return False\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["            cmdstatus, register = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x5')"], "goodparts": ["            cmdstatus, register = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x5'])"]}, {"diff": "\n \n         pos = [1, 2, 4, 8]\n         mask = pos[self.index-SFP_PORT_START]\n-        if tx_disable == True:\n+        if tx_disable is True:\n             setbits = register | mask\n         else:\n             setbits = register & ~mask\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, output = cmd.getstatusoutput('sudo i2cset -y -m 0x0f 0 0x41 0x5 %d' % setbits)\n+            cmdstatus, output = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '-m', '0x0f', '0', '0x41', '0x5', str(setbits)])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"sfp cmdstatus i2c write failed %s\" % output )\n                 return False\n", "add": 2, "remove": 2, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["        if tx_disable == True:", "            cmdstatus, output = cmd.getstatusoutput('sudo i2cset -y -m 0x0f 0 0x41 0x5 %d' % setbits)"], "goodparts": ["        if tx_disable is True:", "            cmdstatus, output = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '-m', '0x0f', '0', '0x41', '0x5', str(setbits)])"]}, {"diff": "\n             return False\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')\n+            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])\n             sfpstatus = int(sfpstatus, 16)\n         else:\n             bus = smbus.SMBu", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')"], "goodparts": ["            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])"]}]}, "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py": {"changes": [{"diff": "\n '''\n listen for the SFP change event and return to chassis.\n '''\n-import sys\n import time\n from sonic_py_common import logger\n+from sonic_py_common.general import getstatusoutput_noshell\n \n smbus_present = 1\n \n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py", "badparts": ["import sys"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n # system level event/error\n EVENT_ON_ALL_SFP = '-1'\n SYSTEM_NOT_READY = 'system_not_ready'\n", "add": 0, "remove": 5, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py", "badparts": ["if sys.version_info[0] < 3:", "    import commands as cmd", "else:", "    import subprocess as cmd"], "goodparts": []}, {"diff": "\n     def _get_transceiver_status(self):\n         if smbus_present == 0:\n             sonic_logger.log_info(\"  PMON - smbus ERROR - DEBUG sfp_event   \")\n-            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')\n+            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])\n             sfpstatus = int(sfpstatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py", "badparts": ["            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')"], "goodparts": ["            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])"]}], "source": "\n''' listen for the SFP change event and return to chassis. ''' import sys import time from sonic_py_common import logger smbus_present=1 try: import smbus except ImportError as e: smbus_present=0 if sys.version_info[0] < 3: import commands as cmd else: import subprocess as cmd EVENT_ON_ALL_SFP='-1' SYSTEM_NOT_READY='system_not_ready' SYSTEM_READY='system_become_ready' SYSTEM_FAIL='system_fail' SFP_PORT_START=49 SFP_PORT_END=52 SYSLOG_IDENTIFIER=\"sfp_event\" sonic_logger=logger.Logger(SYSLOG_IDENTIFIER) class sfp_event: ''' Listen to plugin/plugout cable events ''' def __init__(self): self.handle=None def initialize(self): self.modprs_register=0 time.sleep(5) self.modprs_register=self._get_transceiver_status() sonic_logger.log_info(\"Initial SFP presence=%d\" % self.modprs_register) def deinitialize(self): if self.handle is None: return def _get_transceiver_status(self): if smbus_present==0: sonic_logger.log_info(\" PMON -smbus ERROR -DEBUG sfp_event \") cmdstatus, sfpstatus=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3') sfpstatus=int(sfpstatus, 16) else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0x3 sfpstatus=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) sfpstatus=~sfpstatus sfpstatus=sfpstatus & 0xF return sfpstatus def check_sfp_status(self, port_change, timeout): \"\"\" check_sfp_status called from get_change_event, this will return correct status of all 4 SFP ports if there is a change in any of them \"\"\" start_time=time.time() port=SFP_PORT_START forever=False if timeout==0: forever=True elif timeout > 0: timeout=timeout / float(1000) else: return False,{} end_time=start_time +timeout if(start_time > end_time): return False,{} while(timeout >=0): reg_value=self._get_transceiver_status() if(reg_value !=self.modprs_register): changed_ports=(self.modprs_register ^ reg_value) while(port >=SFP_PORT_START and port <=SFP_PORT_END): mask=(1 << port-SFP_PORT_START) if(changed_ports & mask): if reg_value & mask==0: port_change[port]='0' else: port_change[port]='1' port +=1 self.modprs_register=reg_value return True, port_change if forever: time.sleep(1) else: timeout=end_time -time.time() if timeout >=1: time.sleep(1) else: if timeout > 0: time.sleep(timeout) return True,{} return False,{} ", "sourceWithComments": "'''\nlisten for the SFP change event and return to chassis.\n'''\nimport sys\nimport time\nfrom sonic_py_common import logger\n\nsmbus_present = 1\n\ntry:\n    import smbus\nexcept ImportError as e:\n    smbus_present = 0\n\nif sys.version_info[0] < 3:\n    import commands as cmd\nelse:\n    import subprocess as cmd\n\n# system level event/error\nEVENT_ON_ALL_SFP = '-1'\nSYSTEM_NOT_READY = 'system_not_ready'\nSYSTEM_READY = 'system_become_ready'\nSYSTEM_FAIL = 'system_fail'\n\n# SFP PORT numbers\nSFP_PORT_START = 49\nSFP_PORT_END = 52\n\nSYSLOG_IDENTIFIER = \"sfp_event\"\nsonic_logger = logger.Logger(SYSLOG_IDENTIFIER)\n\n\nclass sfp_event:\n    ''' Listen to plugin/plugout cable events '''\n\n    def __init__(self):\n        self.handle = None\n\n    def initialize(self):\n        self.modprs_register = 0\n        # Get Transceiver status\n        time.sleep(5)\n        self.modprs_register = self._get_transceiver_status()\n        sonic_logger.log_info(\"Initial SFP presence=%d\" % self.modprs_register)\n\n    def deinitialize(self):\n        if self.handle is None:\n            return\n\n    def _get_transceiver_status(self):\n        if smbus_present == 0:\n            sonic_logger.log_info(\"  PMON - smbus ERROR - DEBUG sfp_event   \")\n            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')\n            sfpstatus = int(sfpstatus, 16)\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0x3\n            sfpstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n            sfpstatus = ~sfpstatus\n            sfpstatus = sfpstatus & 0xF\n\n        return sfpstatus\n\n    def check_sfp_status(self, port_change, timeout):\n        \"\"\"\n        check_sfp_status called from get_change_event, this will return correct\n            status of all 4 SFP ports if there is a change in any of them\n        \"\"\"\n        start_time = time.time()\n        port = SFP_PORT_START\n        forever = False\n\n        if timeout == 0:\n            forever = True\n        elif timeout > 0:\n            timeout = timeout / float(1000)  # Convert to secs\n        else:\n            return False, {}\n        end_time = start_time + timeout\n\n        if (start_time > end_time):\n            return False, {}  # Time wrap or possibly incorrect timeout\n\n        while (timeout >= 0):\n            # Check for OIR events and return updated port_change\n            reg_value = self._get_transceiver_status()\n            if (reg_value != self.modprs_register):\n                changed_ports = (self.modprs_register ^ reg_value)\n                while (port >= SFP_PORT_START and port <= SFP_PORT_END):\n                    # Mask off the bit corresponding to our port\n                    mask = (1 << port-SFP_PORT_START)\n                    if (changed_ports & mask):\n                        # ModPrsL is active high\n                        if reg_value & mask == 0:\n                            port_change[port] = '0'\n                        else:\n                            port_change[port] = '1'\n                    port += 1\n\n                # Update reg value\n                self.modprs_register = reg_value\n                return True, port_change\n\n            if forever:\n                time.sleep(1)\n            else:\n                timeout = end_time - time.time()\n                if timeout >= 1:\n                    time.sleep(1)  # We poll at 1 second granularity\n                else:\n                    if timeout > 0:\n                        time.sleep(timeout)\n                    return True, {}\n        return False, {}\n"}}, "msg": "[nokia] Replace os.system and remove subprocess with shell=True (#12100)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\nDependency: [https://github.com/sonic-net/sonic-buildimage/pull/12065](https://github.com/sonic-net/sonic-buildimage/pull/12065)\r\n#### Why I did it\r\n`subprocess.Popen()` and `subprocess.run()` is used with `shell=True`, which is very dangerous for shell injection.\r\n`os` - not secure against maliciously constructed input and dangerous if used to evaluate dynamic content\r\n`getstatusoutput` is dangerous because it contains `shell=True` in the implementation\r\n#### How I did it\r\nReplace `os` by `subprocess`, use with `shell=False`\r\nRemove unused functions"}}, "https://github.com/SaranyaAzhgamuthaiyan/sonic-buildimage": {"5b0c4ec1e64f0bc604a3fd3e828b46d8974544d8": {"url": "https://api.github.com/repos/SaranyaAzhgamuthaiyan/sonic-buildimage/commits/5b0c4ec1e64f0bc604a3fd3e828b46d8974544d8", "html_url": "https://github.com/SaranyaAzhgamuthaiyan/sonic-buildimage/commit/5b0c4ec1e64f0bc604a3fd3e828b46d8974544d8", "sha": "5b0c4ec1e64f0bc604a3fd3e828b46d8974544d8", "keyword": "function injection malicious", "diff": "diff --git a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py\nindex 310d0433d..c1192b3a2 100644\n--- a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py\n@@ -6,8 +6,8 @@\n #\n #############################################################################\n \n-import os\n import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -27,7 +27,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n@@ -97,7 +97,7 @@ def __initialize_watchdog(self):\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py\nindex 53a01c1f1..c942a2fed 100644\n--- a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py\n@@ -6,9 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -38,22 +35,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py\nindex b124ca29f..b19fab85d 100644\n--- a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py\nindex c42176102..4205b17ef 100644\n--- a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py\n@@ -6,10 +6,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -30,7 +29,7 @@ class Sfp(SfpOptoeBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as4630_54pe-r0\"\n     HWSKU = \"Accton-AS4630-54PE\"\n@@ -60,7 +59,7 @@ def get_eeprom_path(self):\n         return self.port_to_eeprom_mapping[self.port_num]\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py\nindex 7a54eee6f..9f39c903c 100644\n--- a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py\n@@ -6,7 +6,7 @@\n #\n #############################################################################\n \n-import os\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -26,7 +26,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n SYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n@@ -95,7 +95,7 @@ def __initialize_watchdog(self):\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py\nindex c34da7044..8137d0f3a 100644\n--- a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py\n@@ -6,9 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -38,22 +35,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()        \n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py\nindex b124ca29f..b19fab85d 100644\n--- a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py\nindex 4529c2f0a..adab3d294 100644\n--- a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py\n@@ -8,10 +8,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -127,7 +126,7 @@ class Sfp(SfpBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-accton_as4630_54te-r0\"\n     HWSKU = \"Accton-AS4630-54TE\"\n@@ -193,7 +192,7 @@ def __write_txt_file(self, file_path, value):\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py\nindex dce9f3c15..c4a062f49 100644\n--- a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py\n@@ -6,8 +6,8 @@\n #\n #############################################################################\n \n-import os\n import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -28,7 +28,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE= \"/sys/class/leds/as5835_54x_led::diag/brightness\"\n \n SYSLED_MODES = {\n@@ -98,7 +98,7 @@ def __initialize_watchdog(self):\n     \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py\nindex f3c9b3cee..ef47a154e 100644\n--- a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py\n@@ -6,10 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n-\n try:\n     from sonic_platform_base.component_base import ComponentBase\n     from .helper import APIHelper\n@@ -44,23 +40,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()\n \n-\n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py\nindex b124ca29f..b19fab85d 100644\n--- a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py\nindex ec16e8056..39813a877 100644\n--- a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py\n@@ -6,10 +6,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -31,7 +30,7 @@ class Sfp(SfpOptoeBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as5835_54x-r0\"\n     HWSKU = \"Accton-AS5835-54X\"\n@@ -121,7 +120,7 @@ def __get_cpld_num(self, port_num):\n \n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess(self.HOST_CHK_CMD).returncode == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py\nindex 86ae121c6..178f3c562 100644\n--- a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py\n@@ -5,12 +5,7 @@\n #\n #############################################################################\n try:\n-    import sys\n-    import re\n-    import os\n     import subprocess\n-    import json\n-    import syslog\n     from sonic_platform_base.chassis_base import ChassisBase\n     from sonic_py_common.logger import Logger\n     from sonic_platform.fan import Fan\n@@ -36,7 +31,7 @@\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n COMPONENT_NAME_LIST = [\"BIOS\"]\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n@@ -71,7 +66,7 @@ def __init__(self):\n         logger.log_info(\"Chassis loaded successfully\")\n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py\nindex 15d8e9e15..5e1e800d5 100644\n--- a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py\n@@ -3,10 +3,7 @@\n # provides the components firmware management function\n #############################################################################\n \n-import json\n import os.path\n-import shutil\n-import shlex\n import subprocess\n \n try:\n@@ -29,8 +26,7 @@ def __init__(self, component_name):\n     def __run_command(self, command):\n         # Run bash command and print output to stdout\n         try:\n-            process = subprocess.Popen(\n-                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n+            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n             while True:\n                 output = process.stdout.readline()\n                 if output == '' and process.poll() is not None:\ndiff --git a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py\nindex 6aabc1441..39c21c0d1 100644\n--- a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py\n@@ -3,10 +3,8 @@\n # provides the sfp device status which are available in the platform\n #############################################################################\n try:\n-    import os\n     import time\n     import subprocess\n-    import syslog\n     from ctypes import create_string_buffer\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom\n@@ -173,7 +171,7 @@ class Sfp(SfpBase):\n \n     PLATFORM_ROOT_PATH = '/usr/share/sonic/device'\n     PMON_HWSKU_PATH = '/usr/share/sonic/hwsku'\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-accton_as7116_54x-r0\"\n     HWSKU = \"Accton-AS7116-54X-R0\"\n@@ -233,7 +231,7 @@ def __read_txt_file(self, file_path):\n         return \"\"\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py\nindex ceece0f9d..a1143b112 100644\n--- a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py\n@@ -6,7 +6,7 @@\n #\n #############################################################################\n \n-import os\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -24,7 +24,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n@@ -87,7 +87,7 @@ def __initialize_watchdog(self):\n     \n     \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py\nindex 5300e1e73..2ba405f9f 100644\n--- a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py\n@@ -6,8 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -43,22 +41,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py\nindex 4cd60ac90..2c644ecbf 100644\n--- a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py\nindex 445b39edc..fd6d0f852 100644\n--- a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py\n@@ -6,10 +6,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -125,7 +124,7 @@ class Sfp(SfpBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n         \n     PLATFORM = \"x86_64-accton_as7312_54x-r0\"\n     HWSKU = \"Accton-AS7312-54X\"\n@@ -256,7 +255,7 @@ def __write_txt_file(self, file_path, value):\n         return True\n     \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py\nindex f32f381b7..1c97d0e87 100644\n--- a/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py\n@@ -6,8 +6,8 @@\n #\n #############################################################################\n \n-import os\n import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -27,7 +27,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE= \"/sys/class/leds/accton_as7326_56x_led::diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n@@ -93,7 +93,7 @@ def __initialize_watchdog(self):\n         self._watchdog = Watchdog()\n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py\nindex 95a54e554..16fe60bfb 100644\n--- a/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py\n@@ -6,10 +6,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -40,7 +39,7 @@ class Sfp(SfpOptoeBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n \n     PLATFORM = \"x86_64-accton_as7326_56x-r0\"\n     HWSKU = \"Accton-AS7326-56X\"\n@@ -144,7 +143,7 @@ def __write_txt_file(self, file_path, value):\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py\nindex 44a759045..164da5fd6 100644\n--- a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py\n@@ -6,8 +6,8 @@\n #\n #############################################################################\n \n-import os\n import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -26,7 +26,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE = \"/sys/class/leds/as7816_64x_led::diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n@@ -96,7 +96,7 @@ def __initialize_watchdog(self):\n     \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py\nindex 6af2f6008..d024e43e1 100644\n--- a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py\n@@ -6,8 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -43,22 +41,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py\nindex b124ca29f..b19fab85d 100644\n--- a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py\nindex 01e568ef3..d8ff303b3 100644\n--- a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py\n@@ -6,10 +6,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -31,7 +30,7 @@ class Sfp(SfpOptoeBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as7816_64x-r0\"\n     HWSKU = \"Accton-AS7816-64X\"\n@@ -119,7 +118,7 @@ def get_eeprom_path(self):\n         return self.port_to_eeprom_mapping[self.port_num]\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py\nindex 7eb9601d8..b0a573432 100644\n--- a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py\n@@ -6,7 +6,7 @@\n #\n #############################################################################\n \n-import os\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -28,7 +28,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n@@ -96,7 +96,7 @@ def __initialize_watchdog(self):\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py\nindex c34da7044..8137d0f3a 100644\n--- a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py\n@@ -6,9 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -38,22 +35,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()        \n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py\nindex 4cd60ac90..2c644ecbf 100644\n--- a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py\nindex 6cefc2a29..5d7c03d00 100644\n--- a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py\n@@ -6,11 +6,10 @@\n #\n #############################################################################\n \n-import os\n import sys\n import time\n import struct\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -272,7 +271,7 @@\n \n class Sfp(SfpBase):\n     \"\"\"Platform-specific Sfp class\"\"\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n     PLATFORM = \"x86_64-accton_as9726_32d-r0\"\n     HWSKU = \"Accton-AS9726-32D\"\n \n@@ -310,7 +309,7 @@ def __write_txt_file(self, file_path, value):\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py\nindex 226963415..2659d16f1 100644\n--- a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py\n@@ -8,8 +8,8 @@\n #############################################################################\n \n try:\n-    import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -67,8 +67,8 @@ def get_firmware_version(self):\n         if self.name == \"BIOS\":\n             fw_version = self.__get_bios_version()\n         elif \"CPLD\" in self.name:\n-            cmd = \"i2cget -f -y {0} {1} 0x1\".format(self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1])\n-            status, value = subprocess.getstatusoutput(cmd)\n+            cmd = [\"i2cget\", \"-f\", \"-y\", self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1], \"0x1\"]\n+            status, value = getstatusoutput_noshell(cmd)\n             if not status:\n                 fw_version = value.rstrip()\n \ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py\nindex b07417713..e79137785 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py\n@@ -26,9 +26,9 @@\n     import logging.config\n     import logging.handlers\n     import time\n-    import subprocess\n     from as4630_54pe.fanutil import FanUtil\n     from as4630_54pe.thermalutil import ThermalUtil\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n@@ -198,9 +198,9 @@ def manage_fans(self):\n         if temp[0] >= 70000: #LM75-48    \n             #critical case*/\n             logging.critical('Alarm-Critical for temperature critical is detected, reset DUT')\n-            cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2);\n-            status, output = subprocess.getstatusoutput(cmd_str)\n+            status, output = getstatusoutput_noshell(cmd_str)\n                 \n         #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_state, fan_policy_state, temp_val)\n         \ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py\nindex d9299b96a..6bbaeaa06 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py\n@@ -28,6 +28,7 @@\n     import logging.handlers\n     import time\n     from sonic_platform import platform\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n@@ -209,10 +210,12 @@ def manage_fans(self):\n             # Critical: Either all the fans are faulty or they are removed, shutdown the system\n             logging.critical('Alarm for all fan faulty/absent is detected')\n             logging.critical(\"Alarm for all fan faulty/absent is detected, reset DUT\")\n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2)\n-            subprocess.getstatusoutput('sync; sync; sync')\n-            subprocess.getstatusoutput(cmd_str)\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell(cmd_str)\n         elif sum(fan_fail_list) != 0:\n             # Set the 100% speed only for first fan failure detection\n             logging.warning('Fan_{} failed, set remaining fan speed to 100%'.format(\n@@ -235,7 +238,7 @@ def manage_fans(self):\n             as4630_54pe_set_fan_speed(new_duty_cycle)\n             if test_temp == 1:\n                 time.sleep(3)\n-                status, output = subprocess.getstatusoutput('pddf_fanutil getspeed')\n+                status, output = getstatusoutput_noshell(['pddf_fanutil', 'getspeed'])\n                 logging.debug('\\n%s\\n', output)\n \n         if temp[0] >= 70000:  # LM77-48\n@@ -252,10 +255,12 @@ def manage_fans(self):\n             if status:\n                 logging.warning('Reboot cause file not updated. {}'.format(output))\n \n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n-            subprocess.getstatusoutput('sync; sync; sync')\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n             time.sleep(3)\n-            subprocess.getstatusoutput(cmd_str)\n+            getstatusoutput_noshell(cmd_str)\n \n         logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n', ori_state, fan_policy_state, temp_val)\n \ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py\nindex 5a505e19f..5c00f338b 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py\n@@ -2,111 +2,111 @@\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import commands\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"clean\"])\n     if status:\n-        print \"accton_as4630_54pe_util.py clean command failed %d\"%status\n+        print(\"accton_as4630_54pe_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Stop pddf-platform-init.service along with other platform serives failed %d\"%status\n+        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status\n+        print(\"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status)\n         return False\n \n     return True\n     \n def start_platform_svc():\n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"install\"])\n     if status:\n-        print \"accton_as4630_54pe_util.py install  command failed %d\"%status\n+        print(\"accton_as4630_54pe_util.py install  command failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n \n     return True\n \n def start_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Start pddf-platform-init.service failed %d\"%status\n+        print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n+        print(\"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status)\n         return False\n     \n     return True\n \n def stop_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Stop pddf-platform-init.service failed %d\"%status\n+        print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n+        print(\"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status)\n         return False\n \n     return True\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py\nindex d3c2b2c86..aa5076c2c 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py\n@@ -20,7 +20,6 @@\n # ------------------------------------------------------------------\n \n try:\n-    import os\n     import sys\n     import getopt\n     import logging\n@@ -194,9 +193,9 @@ def manage_fans(self):\n             # critical case*/\n             logging.critical(\n                 'Alarm-Critical for temperature critical is detected, reset DUT')\n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2)\n-            return_value = os.system(cmd_str)\n+            return_value = subprocess.call(cmd_str)\n             logging.warning('Fan set: i2cset -y -f 3 0x60 0x4 0xE4, status is %d', return_value)\n \n         #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_state, fan_policy_state, temp_val)\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py b/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py\nindex 31697f7c6..9dc8d94ef 100644\n--- a/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py\n@@ -24,10 +24,8 @@\n # ------------------------------------------------------------------\n \n try:\n-    import time\n     import logging\n-    from collections import namedtuple\n-    import subprocess\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n@@ -65,10 +63,11 @@ def _get_fan_to_device_node(self, fan_num, node_num):\n         return \"fan{0}_{1}\".format(fan_num, self.node_postfix[node_num-1])\n     \n     def _get_fan_i2c_bus_addr(self):\n-        cmd_template = 'i2cget -f -y {} 0x{} 0'\n+        cmd_template = ['i2cget', '-f', '-y', '', '', '0']\n         for bus_no, dev_addr in self.I2CADDR_CANDIDATES:\n-            cmd = cmd_template.format(bus_no, dev_addr)\n-            if subprocess.getstatusoutput(cmd)[0] == 0:\n+            cmd_template[3] = str(bus_no)\n+            cmd_template[4] = '0x' + str(dev_addr)\n+            if getstatusoutput_noshell(cmd_template)[0] == 0:\n                 return bus_no, dev_addr\n         raise IOError('Unable to reach fan CPLD via I2C')\n \ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py\nindex ec3a4c133..da046335c 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py\n@@ -23,10 +23,10 @@\n # ------------------------------------------------------------------\n \n try:\n-    import os\n     import getopt\n     import sys\n     import logging\n+    import subprocess\n     import logging.config\n     import logging.handlers\n     import time  # this is only being used as part of the example\n@@ -233,7 +233,7 @@ def manage_fans(self):\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -242,7 +242,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -251,7 +251,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n@@ -260,7 +260,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is cleared')\n                 alarm_state=0\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py\nindex faa4f7d48..7f3add4e4 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py\n@@ -22,10 +22,10 @@\n # ------------------------------------------------------------------\n \n try:\n-    import os\n     import sys\n     import getopt\n     import logging\n+    import subprocess\n     import logging.config\n     import logging.handlers\n     import time\n@@ -218,7 +218,7 @@ def manage_fans(self):\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n         if ori_state == LEVEL_FAN_MID:\n             if new_state == LEVEL_TEMP_HIGH:\n                 if alarm_state == 0:\n@@ -227,7 +227,7 @@ def manage_fans(self):\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n         if ori_state == LEVEL_FAN_MAX:\n             if new_state == LEVEL_TEMP_HIGH:\n                 if alarm_state == 0:\n@@ -236,7 +236,7 @@ def manage_fans(self):\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if alarm_state == 1:\n                 if temp_get < (fan_policy[3][0] - 5000):  # below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n@@ -245,7 +245,7 @@ def manage_fans(self):\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is cleared')\n                 alarm_state = 0\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py\nindex c3e1c5036..f4335bd44 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py\n@@ -33,7 +33,7 @@\n import re\n import time\n import os\n-\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n PROJECT_NAME = 'as7326_56x'\n@@ -100,16 +100,16 @@ def show_help():\n \n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\n@@ -257,8 +257,8 @@ def i2c_order_check():\n     return 0\n \n def eeprom_check():\n-    cmd = \"i2cget -y -f 0 0x56\"\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cget\", \"-y\", \"-f\", \"0\", \"0x56\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def device_install():\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py\nindex 1b5f46ef0..f02202b21 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py\n@@ -2,39 +2,39 @@\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as7326-platform-fan.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as7326-platform-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Stop as7326-platform-init.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Disable as7326-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as7326_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n@@ -42,21 +42,21 @@ def stop_platform_svc():\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"install\"])\n     if status:\n         print(\"accton_as7326_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Enable as7326-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as7326-platform-monitor-fan.service failed %d\"%status)\n         return False\n         \n-    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as7326-platform-monitor-psu.service failed %d\"%status)\n         return False\n@@ -64,7 +64,7 @@ def start_platform_svc():\n     return True\n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n@@ -72,7 +72,7 @@ def start_platform_pddf():\n     return True\n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py\nindex 3ed3f7604..0f6c82893 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py\n@@ -1,28 +1,28 @@\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import commands\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = commands.getstatusoutput(\"systemctl stop as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Stop as7712-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl disable as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Disable as7712-platform-init.service failed %d\"%status)\n         return False\n     \n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"clean\"])\n     if status:\n-        print(\"accton_as7712_util.py clean command failed %d\"%status)\n+        print(\"accton_as7712_util.py clean failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n@@ -30,16 +30,16 @@ def stop_platform_svc():\n     return True\n     \n def start_platform_svc():\n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"install\"])\n     if status:\n-        print(\"accton_as7712_util.py install command failed %d\"%status)\n+        print(\"accton_as7712_util.py install failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Enable as7712-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Start as7712-platform-init.service failed %d\"%status)\n         return False\n@@ -47,7 +47,7 @@ def start_platform_svc():\n     return True\n \n def start_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n@@ -55,7 +55,7 @@ def start_platform_pddf():\n     return True\n \n def stop_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py b/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py\nindex 6322aac6b..f312d2261 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py\n@@ -36,6 +36,7 @@\n import logging\n import re\n import time\n+from sonic_py_common.general import getstatusoutput_noshell\n \n PROJECT_NAME = 'as7716_32x'\n version = '0.0.1'\n@@ -220,16 +221,16 @@ def  show_set_help():\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py\nindex f506b72f8..b889dcf71 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py\n@@ -23,10 +23,10 @@\n # ------------------------------------------------------------------\n \n try:\n-    import os\n     import getopt\n     import sys\n     import logging\n+    import subprocess\n     import logging.config\n     import logging.handlers\n     import time  # this is only being used as part of the example\n@@ -242,7 +242,7 @@ def manage_fans(self):\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -251,7 +251,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -260,7 +260,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n@@ -269,7 +269,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is cleared')\n                 alarm_state=0\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py\nindex fd283cd6c..2b18ac646 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py\n@@ -24,10 +24,10 @@\n # ------------------------------------------------------------------\n \n try:\n-    import os\n     import sys\n     import getopt\n     import logging\n+    import subprocess\n     import logging.config\n     import logging.handlers\n     import time\n@@ -230,7 +230,7 @@ def manage_fans(self):\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -239,7 +239,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -248,7 +248,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n@@ -257,7 +257,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is cleared')\n                 alarm_state=0\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py\nindex bee413fe0..949f1230d 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py\n@@ -32,6 +32,7 @@\n import logging\n import re\n import time\n+from sonic_py_common.general import getstatusoutput_noshell\n \n PROJECT_NAME = 'as7726_32x'\n version = '0.0.1'\n@@ -147,16 +148,16 @@ def show_help():\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py\nindex 9664d21b6..e8b42aaa1 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py\n@@ -2,44 +2,44 @@\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as7726_32x_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n@@ -47,32 +47,32 @@ def stop_platform_svc():\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py install\"])\n     if status:\n         print(\"accton_as7726_32x_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n@@ -80,7 +80,7 @@ def start_platform_svc():\n     return True\n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n@@ -88,7 +88,7 @@ def start_platform_pddf():\n     return True\n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py b/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py\nindex 1e9314fb8..5ab3d8f20 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py\n@@ -32,7 +32,7 @@\n import re\n import time\n import os\n-\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n PROJECT_NAME = 'as7816_64x'\n@@ -99,18 +99,17 @@ def show_help():\n     print( __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]})\n     sys.exit(0)\n \n-   \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py\nindex 98bf05eca..166b9c12f 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py\n@@ -1,7 +1,7 @@\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services.\n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n def check_pddf_support():\n@@ -10,22 +10,22 @@ def check_pddf_support():\n \n def stop_platform_svc():\n \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Stop as7816-platform-init.service failed %d\" % status))\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Disable as7816-platform-init.service failed %d\" % status))\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"clean\"])\n     if status:\n         print((\"accton_as7816_util.py clean command failed %d\" % status))\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Stop pddf-platform-init.service along with other platform serives failed %d\" % status))\n         return False\n@@ -34,12 +34,12 @@ def stop_platform_svc():\n \n \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"install\"])\n     if status:\n         print((\"accton_as7816_util.py install command failed %d\" % status))\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Enable as7816-platform-init.service failed %d\" % status))\n         return False\n@@ -48,7 +48,7 @@ def start_platform_svc():\n \n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Start pddf-platform-init.service failed %d\" % status))\n         return False\n@@ -57,7 +57,7 @@ def start_platform_pddf():\n \n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Stop pddf-platform-init.service failed %d\" % status))\n         return False\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py b/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py\nindex 647e26e07..53126109f 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py\n@@ -32,6 +32,7 @@\n import logging\n import re\n import time\n+from sonic_py_common.general import getstatusoutput_noshell\n \n PROJECT_NAME = 'as9716_32d'\n version = '0.0.1'\n@@ -153,16 +154,16 @@ def show_help():\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py\nindex 95e42b5c8..1d672015d 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py\n@@ -1,39 +1,39 @@\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-fan.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-init.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Disable as9716-32d-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as9716_32d_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n@@ -41,21 +41,21 @@ def stop_platform_svc():\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"install\"])\n     if status:\n         print(\"accton_as9716_32d_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Enable as9716-32d-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as9716-32d-platform-monitor-fan.service failed %d\"%status)\n         return False\n         \n-    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as9716-32d-platform-monitor-psu.service failed %d\"%status)\n         return False\n@@ -64,7 +64,7 @@ def start_platform_svc():\n \n def start_platform_pddf():   \n \n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n@@ -73,7 +73,7 @@ def start_platform_pddf():\n \n def stop_platform_pddf():   \n \n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\n", "message": "", "files": {"/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os import sys try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper from.event import SfpEvent except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=3 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=3 PORT_START=49 PORT_END=54 NUM_COMPONENT=2 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" SYSLED_FNODE=\"/sys/class/leds/diag/brightness\" SYSLED_MODES={ \"0\": \"STATUS_LED_COLOR_OFF\", \"1\": \"STATUS_LED_COLOR_GREEN\", \"2\": \"STATUS_LED_COLOR_AMBER\", \"5\": \"STATUS_LED_COLOR_GREEN_BLINK\" } class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(0, PORT_END): sfp=Sfp(index) self._sfp_list.append(sfp) self._sfpevent=SfpEvent(self._sfp_list) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for fant_index in range(NUM_FAN_TRAY): fandrawer=FanDrawer(fant_index) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._eeprom.get_product_name() def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_change_event(self, timeout=0): if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfpevent.get_sfp_event(timeout) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def initizalize_system_led(self): return True def get_status_led(self): val=self._api_helper.read_txt_file(SYSLED_FNODE) return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\" def set_status_led(self, color): mode=None for key, val in SYSLED_MODES.items(): if val==color: mode=key break if mode is None: return False else: return self._api_helper.write_txt_file(SYSLED_FNODE, mode) ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\nimport sys\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\n    from .event import SfpEvent\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 3\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 3\nPORT_START = 49\nPORT_END = 54\nNUM_COMPONENT = 2\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\nSYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\nSYSLED_MODES = {\n    \"0\" : \"STATUS_LED_COLOR_OFF\",\n    \"1\" : \"STATUS_LED_COLOR_GREEN\",\n    \"2\" : \"STATUS_LED_COLOR_AMBER\",\n    \"5\" : \"STATUS_LED_COLOR_GREEN_BLINK\"\n}\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n        \n        self.config_data = {}\n        \n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n    \n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(0, PORT_END):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self._sfpevent = SfpEvent(self._sfp_list)\n        self.sfp_module_initialized = True\n\n    def __initialize_fan(self):\n       from sonic_platform.fan_drawer import FanDrawer\n       for fant_index in range(NUM_FAN_TRAY):\n           fandrawer = FanDrawer(fant_index)\n           self._fan_drawer_list.append(fandrawer)\n           self._fan_list.extend(fandrawer._fan_list)\n               \n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n    \n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n    \n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n\n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        \n        return self._eeprom.get_product_name()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n\n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_change_event(self, timeout=0):\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return self._sfpevent.get_sfp_event(timeout)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n\n    def initizalize_system_led(self):\n        return True\n\n    def get_status_led(self):\n        val = self._api_helper.read_txt_file(SYSLED_FNODE)\n        return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\"\n\n    def set_status_led(self, color):\n        mode = None\n        for key, val in SYSLED_MODES.items():\n            if val == color:\n                mode = key\n                break\n        if mode is None:\n            return False\n        else:\n            return self._api_helper.write_txt_file(SYSLED_FNODE, mode)\n\n"}, "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 3, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try", "add": 0, "remove": 16, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"3-0060\" } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"BIOS\", \"Basic Input/Output System\") ] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return 'N/A' def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return 'N/A' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is'0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"3-0060\"\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n   \n]\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)\n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n        \n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n        \n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of\n        entPhysicalContainedIn is'0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device\n            or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, resu", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, resu"], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r', errors='replace') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r', errors='replace') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as4630_54pe-r0\"\n     HWSKU = \"Accton-AS4630-54PE\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n         return self.port_to_eeprom_mapping[self.port_num]\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFOR", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}], "source": "\n import os import time import sys from ctypes import create_string_buffer try: from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_I2C_PATH=\"/sys/bus/i2c/devices/3-0060/\" class Sfp(SfpOptoeBase): \"\"\"Platform-specific Sfp class\"\"\" PORT_START=49 PORT_END=54 PLATFORM_ROOT_PATH=\"/usr/share/sonic/device\" PMON_HWSKU_PATH=\"/usr/share/sonic/hwsku\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" PLATFORM=\"x86_64-accton_as4630_54pe-r0\" HWSKU=\"Accton-AS4630-54PE\" _port_to_i2c_mapping={ 49: 18, 50: 19, 51: 20, 52: 21, 53: 22, 54: 23, } def __init__(self, sfp_index=0): SfpOptoeBase.__init__(self) self._api_helper=APIHelper() self.index=sfp_index self.port_num=self.index +1 eeprom_path='/sys/bus/i2c/devices/{0}-0050/eeprom' self.port_to_eeprom_mapping={} for x in range(self.PORT_START, self.PORT_END +1): self.port_to_eeprom_mapping[x]=eeprom_path.format(self._port_to_i2c_mapping[x]) def get_eeprom_path(self): return self.port_to_eeprom_mapping[self.port_num] def __is_host(self): return os.system(self.HOST_CHK_CMD)==0 def __get_path_to_port_config_file(self): platform_path=\"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM]) hwsku_path=\"/\".join([platform_path, self.HWSKU] ) if self.__is_host() else self.PMON_HWSKU_PATH return \"/\".join([hwsku_path, \"port_config.ini\"]) def __read_eeprom_specific_bytes(self, offset, num_bytes): sysfsfile_eeprom=None eeprom_raw=[] for i in range(0, num_bytes): eeprom_raw.append(\"0x00\") sysfs_sfp_i2c_client_eeprom_path=self.port_to_eeprom_mapping[self.port_num] try: sysfsfile_eeprom=open( sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0) sysfsfile_eeprom.seek(offset) raw=sysfsfile_eeprom.read(num_bytes) if sys.version_info[0] >=3: for n in range(0, num_bytes): eeprom_raw[n]=hex(raw[n])[2:].zfill(2) else: for n in range(0, num_bytes): eeprom_raw[n]=hex(ord(raw[n]))[2:].zfill(2) except Exception: pass finally: if sysfsfile_eeprom: sysfsfile_eeprom.close() return eeprom_raw def get_reset_status(self): \"\"\" Retrieves the reset status of SFP Returns: A Boolean, True if reset enabled, False if disabled \"\"\" if self.port_num < 53: return False reset_path=\"{}{}{}\".format(CPLD_I2C_PATH, \"module_reset_\", str(self.port_num)) val=self._api_helper.read_txt_file(reset_path) if val is not None: return int(val, 10)==1 else: return False def get_rx_los(self): \"\"\" Retrieves the RX LOS(lost-of-signal) status of SFP Returns: A Boolean, True if SFP has RX LOS, False if not. Note: RX LOS status is latched until a call to get_rx_los or a reset. \"\"\" rx_los=False if self.port_num < 49: return False if self.port_num < 53: rx_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_rx_los_', self.port_num) rx_los=self._api_helper.read_txt_file(rx_path) if rx_los is None: return False else: rx_los_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: rx_los_data=int(dom_channel_monitor_raw[0], 16) rx_los_list.append(rx_los_data & 0x01 !=0) rx_los_list.append(rx_los_data & 0x02 !=0) rx_los_list.append(rx_los_data & 0x04 !=0) rx_los_list.append(rx_los_data & 0x08 !=0) rx_los=rx_los_list[0] and rx_los_list[1] and rx_los_list[2] and rx_los_list[3] return rx_los def get_tx_fault(self): \"\"\" Retrieves the TX fault status of SFP Returns: A Boolean, True if SFP has TX fault, False if not Note: TX fault status is lached until a call to get_tx_fault or a reset. \"\"\" tx_fault=False if self.port_num < 49: return False if self.port_num < 53: tx_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_fault_', self.port_num) tx_fault=self._api_helper.read_txt_file(tx_path) if tx_fault is None: return False else: tx_fault_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: tx_fault_data=int(dom_channel_monitor_raw[0], 16) tx_fault_list.append(tx_fault_data & 0x01 !=0) tx_fault_list.append(tx_fault_data & 0x02 !=0) tx_fault_list.append(tx_fault_data & 0x04 !=0) tx_fault_list.append(tx_fault_data & 0x08 !=0) tx_fault=tx_fault_list[0] and tx_fault_list[1] and tx_fault_list[2] and tx_fault_list[3] return tx_fault def get_tx_disable(self): \"\"\" Retrieves the tx_disable status of this SFP Returns: A Boolean, True if tx_disable is enabled, False if disabled \"\"\" if self.port_num < 49: return False if self.port_num < 53: tx_disable=False tx_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_disable_', self.port_num) tx_disable=self._api_helper.read_txt_file(tx_path) if tx_disable is not None: return tx_disable else: return False else: tx_disable_list=[] sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) tx_disable_list.append( 'On'==dom_control_data['data']['TX1Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX2Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX3Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX4Disable']['value']) return tx_disable_list def get_tx_disable_channel(self): \"\"\" Retrieves the TX disabled channels in this SFP Returns: A hex of 4 bits(bit 0 to bit 3 as channel 0 to channel 3) to represent TX channels which have been disabled in this SFP. As an example, a returned value of 0x5 indicates that channel 0 and channel 2 have been disabled. \"\"\" if self.port_num < 53: return False else: tx_disable_list=self.get_tx_disable() if tx_disable_list is None: return 0 tx_disabled=0 for i in range(len(tx_disable_list)): if tx_disable_list[i]: tx_disabled |=1 << i return tx_disabled def get_lpmode(self): \"\"\" Retrieves the lpmode(low power mode) status of this SFP Returns: A Boolean, True if lpmode is enabled, False if disabled \"\"\" if self.port_num < 53: return False else: power_set=self.get_power_set() power_override=self.get_power_override() return power_set and power_override def reset(self): \"\"\" Reset SFP and return all user module settings to their default srate. Returns: A boolean, True if successful, False if not \"\"\" if self.port_num < 53: return False reset_path=\"{}{}{}\".format(CPLD_I2C_PATH, 'module_reset_', self.port_num) ret=self._api_helper.write_txt_file(reset_path, 1) if ret is not True: return ret time.sleep(0.01) ret=self._api_helper.write_txt_file(reset_path, 0) time.sleep(0.2) return ret def tx_disable(self, tx_disable): \"\"\" Disable SFP TX for all channels Args: tx_disable: A Boolean, True to enable tx_disable mode, False to disable tx_disable mode. Returns: A boolean, True if tx_disable is set successfully, False if not \"\"\" if self.port_num < 49: return False if self.port_num < 53: tx_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_disable_', self.port_num) ret=self._api_helper.write_txt_file(tx_path, 1 if tx_disable else 0) if ret is not None: time.sleep(0.01) return ret else: return False else: if not self.get_presence(): return False sysfsfile_eeprom=None try: tx_disable_ctl=0xf if tx_disable else 0x0 buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=tx_disable_ctl else: buffer[0]=chr(tx_disable_ctl) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ',str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def tx_disable_channel(self, channel, disable): \"\"\" Sets the tx_disable for specified SFP channels Args: channel: A hex of 4 bits(bit 0 to bit 3) which represent channel 0 to 3, e.g. 0x5 for channel 0 and channel 2. disable: A boolean, True to disable TX channels specified in channel, False to enable Returns: A boolean, True if successful, False if not \"\"\" if self.port_num < 53: return False else: if not self.get_presence(): return False sysfsfile_eeprom=None try: channel_state=self.get_tx_disable_channel() for i in range(4): channel_mask=(1 << i) if not(channel & channel_mask): continue if disable: channel_state |=channel_mask else: channel_state &=~channel_mask buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=channel_state else: buffer[0]=chr(channel_state) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ', str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def set_lpmode(self, lpmode): \"\"\" Sets the lpmode(low power mode) of SFP Args: lpmode: A Boolean, True to enable lpmode, False to disable it Note : lpmode can be overridden by set_power_override Returns: A boolean, True if lpmode is set successfully, False if not \"\"\" if self.port_num < 53: return False else: if lpmode is True: self.set_power_override(True, True) else: self.set_power_override(False, False) return True def set_power_override(self, power_override, power_set): \"\"\" Sets SFP power level using power_override and power_set Args: power_override: A Boolean, True to override set_lpmode and use power_set to control SFP power, False to disable SFP power control through power_override/power_set and use set_lpmode to control SFP power. power_set: Only valid when power_override is True. A Boolean, True to set SFP to low power mode, False to set SFP to high power mode. Returns: A boolean, True if power-override and power_set are set successfully, False if not \"\"\" if self.port_num < 53: return False else: if not self.get_presence(): return False try: power_override_bit=(1 << 0) if power_override else 0 power_set_bit =(1 << 1) if power_set else(1 << 3) buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=(power_override_bit | power_set_bit) else: buffer[0]=chr(power_override_bit | power_set_bit) with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd: fd.seek(QSFP_POWEROVERRIDE_OFFSET) fd.write(buffer[0]) time.sleep(0.01) except IOError as e: print('Error: unable to open file: ', str(e)) return False return True def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" name=None sfputil_helper=SfpUtilHelper() sfputil_helper.read_porttab_mappings( self.__get_path_to_port_config_file()) name=sfputil_helper.logical[self.index] or \"Unknown\" return name def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" if self.port_num < 49: return False present_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_present_', self.port_num) val=self._api_helper.read_txt_file(present_path) if val is not None: return int(val, 10)==1 else: return False def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return self.get_presence() def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return self.port_num def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return True ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Sfp contains an implementation of SONiC Platform Base API and\n# provides the sfp device status which are available in the platform\n#\n#############################################################################\n\nimport os\nimport time\nimport sys\n\nfrom ctypes import create_string_buffer\n\ntry:\n    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_I2C_PATH = \"/sys/bus/i2c/devices/3-0060/\"\n\nclass Sfp(SfpOptoeBase):\n    \"\"\"Platform-specific Sfp class\"\"\"\n\n    # Port number\n    PORT_START = 49\n    PORT_END = 54\n\n    # Path to sysfs\n    PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n    PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n        \n    PLATFORM = \"x86_64-accton_as4630_54pe-r0\"\n    HWSKU = \"Accton-AS4630-54PE\"\n\n    _port_to_i2c_mapping = {\n           49: 18,\n           50: 19,\n           51: 20,\n           52: 21,\n           53: 22,\n           54: 23,\n    }\n\n    def __init__(self, sfp_index=0):\n        SfpOptoeBase.__init__(self)\n        self._api_helper=APIHelper()\n        # Init index\n        self.index = sfp_index\n        self.port_num = self.index + 1\n        # Init eeprom path\n        eeprom_path = '/sys/bus/i2c/devices/{0}-0050/eeprom'\n        self.port_to_eeprom_mapping = {}\n        for x in range(self.PORT_START, self.PORT_END + 1):\n            self.port_to_eeprom_mapping[x] = eeprom_path.format(self._port_to_i2c_mapping[x])\n\n    def get_eeprom_path(self):\n        return self.port_to_eeprom_mapping[self.port_num]\n\n    def __is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def __get_path_to_port_config_file(self):\n        platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n        hwsku_path = \"/\".join([platform_path, self.HWSKU]\n                              ) if self.__is_host() else self.PMON_HWSKU_PATH\n        return \"/\".join([hwsku_path, \"port_config.ini\"])\n\n    def __read_eeprom_specific_bytes(self, offset, num_bytes):\n        sysfsfile_eeprom = None\n        eeprom_raw = []\n        for i in range(0, num_bytes):\n            eeprom_raw.append(\"0x00\")\n\n        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]\n        try:\n            sysfsfile_eeprom = open(\n                sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0)\n            sysfsfile_eeprom.seek(offset)\n            raw = sysfsfile_eeprom.read(num_bytes)\n            if sys.version_info[0] >= 3:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(raw[n])[2:].zfill(2)\n            else:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(ord(raw[n]))[2:].zfill(2)\n        except Exception:\n            pass\n        finally:\n            if sysfsfile_eeprom:\n                sysfsfile_eeprom.close()\n\n        return eeprom_raw\n\n    def get_reset_status(self):\n        \"\"\"\n        Retrieves the reset status of SFP\n        Returns:\n            A Boolean, True if reset enabled, False if disabled\n        \"\"\"\n        if self.port_num < 53: #Copper port and sfp ports are suported.\n            return False\n\n        reset_path=\"{}{}{}\".format(CPLD_I2C_PATH , \"module_reset_\" , str(self.port_num))\n        val = self._api_helper.read_txt_file(reset_path)\n        \n        if val is not None:\n            return int(val, 10) == 1\n        else:        \n            return False\n\n    def get_rx_los(self):\n        \"\"\"\n        Retrieves the RX LOS (lost-of-signal) status of SFP\n        Returns:\n            A Boolean, True if SFP has RX LOS, False if not.\n            Note : RX LOS status is latched until a call to get_rx_los or a reset.\n        \"\"\"\n        rx_los = False\n        \n        if self.port_num < 49: #Copper port, no sysfs\n            return False\n            \n        if self.port_num < 53:\n            rx_path = \"{}{}{}\".format(CPLD_I2C_PATH, '/module_rx_los_', self.port_num)\n            rx_los=self._api_helper.read_txt_file(rx_path)\n            if rx_los is None:\n                return False\n        else:\n            rx_los_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None\n            if dom_channel_monitor_raw is not None:\n                rx_los_data = int(dom_channel_monitor_raw[0], 16)\n                rx_los_list.append(rx_los_data & 0x01 != 0)\n                rx_los_list.append(rx_los_data & 0x02 != 0)\n                rx_los_list.append(rx_los_data & 0x04 != 0)\n                rx_los_list.append(rx_los_data & 0x08 != 0)\n                rx_los = rx_los_list[0] and rx_los_list[1] and rx_los_list[2] and rx_los_list[3]\n        return rx_los\n\n    def get_tx_fault(self):\n        \"\"\"\n        Retrieves the TX fault status of SFP\n        Returns:\n            A Boolean, True if SFP has TX fault, False if not\n            Note : TX fault status is lached until a call to get_tx_fault or a reset.\n        \"\"\"\n        tx_fault = False\n        if self.port_num < 49: #Copper port, no sysfs\n            return False\n        \n        if self.port_num < 53:\n            tx_path = \"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_fault_', self.port_num)\n            tx_fault=self._api_helper.read_txt_file(tx_path)\n            if tx_fault is None:\n                return False\n        else:\n            tx_fault_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None\n            if dom_channel_monitor_raw is not None:\n                tx_fault_data = int(dom_channel_monitor_raw[0], 16)\n                tx_fault_list.append(tx_fault_data & 0x01 != 0)\n                tx_fault_list.append(tx_fault_data & 0x02 != 0)\n                tx_fault_list.append(tx_fault_data & 0x04 != 0)\n                tx_fault_list.append(tx_fault_data & 0x08 != 0)\n                tx_fault = tx_fault_list[0] and tx_fault_list[1] and tx_fault_list[2] and tx_fault_list[3]\n\n        return tx_fault\n\n    def get_tx_disable(self):\n        \"\"\"\n        Retrieves the tx_disable status of this SFP\n        Returns:\n            A Boolean, True if tx_disable is enabled, False if disabled\n        \"\"\"\n        if self.port_num < 49: #Copper port, no sysfs\n            return False\n        \n        if self.port_num < 53: \n            tx_disable = False            \n                \n            tx_path = \"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_disable_', self.port_num)\n            tx_disable=self._api_helper.read_txt_file(tx_path)\n            \n            if tx_disable is not None:\n                return tx_disable \n            else:\n                return False\n                   \n        else:\n            tx_disable_list = []\n    \n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n    \n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX1Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX2Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX3Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX4Disable']['value'])\n    \n            return tx_disable_list\n\n    def get_tx_disable_channel(self):\n        \"\"\"\n        Retrieves the TX disabled channels in this SFP\n        Returns:\n            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent\n            TX channels which have been disabled in this SFP.\n            As an example, a returned value of 0x5 indicates that channel 0\n            and channel 2 have been disabled.\n        \"\"\"\n        if self.port_num < 53: \n            # SFP doesn't support this feature\n            return False\n        else:\n            tx_disable_list = self.get_tx_disable()\n            if tx_disable_list is None:\n                return 0\n            tx_disabled = 0\n            for i in range(len(tx_disable_list)):\n                if tx_disable_list[i]:\n                    tx_disabled |= 1 << i\n            return tx_disabled\n\n    def get_lpmode(self):\n        \"\"\"\n        Retrieves the lpmode (low power mode) status of this SFP\n        Returns:\n            A Boolean, True if lpmode is enabled, False if disabled\n        \"\"\"\n        if self.port_num < 53: \n            # SFP doesn't support this feature\n            return False\n        else:\n            power_set=self.get_power_set()\n            power_override = self.get_power_override()\n            return power_set and power_override\n      \n    \n    def reset(self):\n        \"\"\"\n        Reset SFP and return all user module settings to their default srate.\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        # Check for invalid port_num\n        if self.port_num < 53: #Copper port and  sfp ports are not supported.\n            return False\n\n        reset_path = \"{}{}{}\".format(CPLD_I2C_PATH, 'module_reset_', self.port_num)\n        ret = self._api_helper.write_txt_file(reset_path, 1)\n        if ret is not True:\n            return ret\n        \n        time.sleep(0.01)\n        ret = self._api_helper.write_txt_file(reset_path, 0)\n        time.sleep(0.2)\n        \n        return ret\n        \n    def tx_disable(self, tx_disable):\n        \"\"\"\n        Disable SFP TX for all channels\n        Args:\n            tx_disable : A Boolean, True to enable tx_disable mode, False to disable\n                         tx_disable mode.\n        Returns:\n            A boolean, True if tx_disable is set successfully, False if not\n        \"\"\"\n        if self.port_num < 49: #Copper port, no sysfs\n            return False\n        \n        if self.port_num < 53:\n            tx_path = \"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_disable_', self.port_num)      \n            ret = self._api_helper.write_txt_file(tx_path,  1 if tx_disable else 0)\n            if ret is not None:\n                time.sleep(0.01)\n                return ret\n            else:\n                return False\n        \n        else:\n            if not self.get_presence():\n                return False\n            sysfsfile_eeprom = None\n            try:\n                tx_disable_ctl = 0xf if tx_disable else 0x0\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = tx_disable_ctl\n                else:\n                    buffer[0] = chr(tx_disable_ctl)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print ('Error: unable to open file: ',str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n        return True\n\n    def tx_disable_channel(self, channel, disable):\n        \"\"\"\n        Sets the tx_disable for specified SFP channels\n        Args:\n            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,\n                      e.g. 0x5 for channel 0 and channel 2.\n            disable : A boolean, True to disable TX channels specified in channel,\n                      False to enable\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        \n        if self.port_num < 53:\n            return False # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n\n            sysfsfile_eeprom = None\n            try:\n                channel_state = self.get_tx_disable_channel()\n\n                for i in range(4):\n                    channel_mask = (1 << i)\n                    if not (channel & channel_mask):\n                        continue\n\n                    if disable:\n                        channel_state |= channel_mask\n                    else:\n                        channel_state &= ~channel_mask\n\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = channel_state\n                else:\n                    buffer[0] = chr(channel_state)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print ('Error: unable to open file: ', str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n            return True\n\n    def set_lpmode(self, lpmode):\n        \"\"\"\n        Sets the lpmode (low power mode) of SFP\n        Args:\n            lpmode: A Boolean, True to enable lpmode, False to disable it\n            Note  : lpmode can be overridden by set_power_override\n        Returns:\n            A boolean, True if lpmode is set successfully, False if not\n        \"\"\"\n        if self.port_num < 53:\n            return False # SFP doesn't support this feature\n        else:\n            if lpmode is True:\n                self.set_power_override(True, True)\n            else:\n                self.set_power_override(False, False)\n    \n            return True\n       \n    def set_power_override(self, power_override, power_set):\n        \"\"\"\n        Sets SFP power level using power_override and power_set\n        Args:\n            power_override :\n                    A Boolean, True to override set_lpmode and use power_set\n                    to control SFP power, False to disable SFP power control\n                    through power_override/power_set and use set_lpmode\n                    to control SFP power.\n            power_set :\n                    Only valid when power_override is True.\n                    A Boolean, True to set SFP to low power mode, False to set\n                    SFP to high power mode.\n        Returns:\n            A boolean, True if power-override and power_set are set successfully,\n            False if not\n        \"\"\"\n        if self.port_num < 53:\n            return False # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n            try:\n                power_override_bit = (1 << 0) if power_override else 0\n                power_set_bit      = (1 << 1) if power_set else (1 << 3)\n    \n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = (power_override_bit | power_set_bit)\n                else:\n                    buffer[0] = chr(power_override_bit | power_set_bit)\n                # Write to eeprom\n                with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd:\n                    fd.seek(QSFP_POWEROVERRIDE_OFFSET)\n                    fd.write(buffer[0])\n                    time.sleep(0.01)\n            except IOError as e:\n                print ('Error: unable to open file: ', str(e))\n                return False\n            return True\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        name = None\n        sfputil_helper = SfpUtilHelper()\n        sfputil_helper.read_porttab_mappings(\n            self.__get_path_to_port_config_file())\n        name = sfputil_helper.logical[self.index] or \"Unknown\"\n        return name\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        if self.port_num < 49: #Copper port, no sysfs\n            return False\n            \n        present_path = \"{}{}{}\".format(CPLD_I2C_PATH, '/module_present_', self.port_num)\n        val=self._api_helper.read_txt_file(present_path)\n        if val is not None:\n            return int(val, 10)==1\n        else:\n            return False\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return self.get_presence()\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return self.port_num\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return True\n"}, "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n SYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         ", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=3 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=3 NUM_QSFP=6 PORT_START=49 PORT_END=54 NUM_COMPONENT=2 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"docker > /dev/null 2>&1\" SYSLED_FNODE=\"/sys/class/leds/diag/brightness\" SYSLED_MODES={ \"0\": \"STATUS_LED_COLOR_OFF\", \"1\": \"STATUS_LED_COLOR_GREEN\", \"2\": \"STATUS_LED_COLOR_AMBER\", \"5\": \"STATUS_LED_COLOR_GREEN_BLINK\" } class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(0, PORT_END): sfp=Sfp(index) self._sfp_list.append(sfp) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for fant_index in range(NUM_FAN_TRAY): fandrawer=FanDrawer(fant_index) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._api_helper.hwsku def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_serial_number(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def initizalize_system_led(self): return True def get_status_led(self): val=self._api_helper.read_txt_file(SYSLED_FNODE) return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\" def set_status_led(self, color): mode=None for key, val in SYSLED_MODES.items(): if val==color: mode=key break if mode is None: return False else: return self._api_helper.write_txt_file(SYSLED_FNODE, mode) ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 3\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 3\nNUM_QSFP = 6\nPORT_START = 49\nPORT_END = 54\nNUM_COMPONENT = 2\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nSYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\nSYSLED_MODES = {\n    \"0\" : \"STATUS_LED_COLOR_OFF\",\n    \"1\" : \"STATUS_LED_COLOR_GREEN\",\n    \"2\" : \"STATUS_LED_COLOR_AMBER\",\n    \"5\" : \"STATUS_LED_COLOR_GREEN_BLINK\"\n}\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n\n        self.config_data = {}\n\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n\n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(0, PORT_END):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self.sfp_module_initialized = True\n\n    def __initialize_fan(self):\n        from sonic_platform.fan_drawer import FanDrawer\n        for fant_index in range(NUM_FAN_TRAY):\n            fandrawer = FanDrawer(fant_index)\n            self._fan_drawer_list.append(fandrawer)\n            self._fan_list.extend(fandrawer._fan_list)\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n\n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n\n        return self._api_helper.hwsku\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_serial_number(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n\n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n\n    def initizalize_system_led(self):\n        return True\n\n    def get_status_led(self):\n        val = self._api_helper.read_txt_file(SYSLED_FNODE)\n        return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\"\n\n    def set_status_led(self, color):\n        mode = None\n        for key, val in SYSLED_MODES.items():\n            if val == color:\n                mode = key\n                break\n        if mode is None:\n            return False\n        else:\n            return self._api_helper.write_txt_file(SYSLED_FNODE, mode)\n"}, "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 3, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()        \n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n        ", "add": 0, "remove": 16, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"3-0060\" } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"BIOS\", \"Basic Input/Output System\") ] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError ", "sourceWithComments": "#############################################################################\n# Accton\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"3-0060\"\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n\n]\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()        \n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)               \n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n\n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()           \n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n"}, "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, ", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, "], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r', errors='replace') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r', errors='replace') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-accton_as4630_54te-r0\"\n     HWSKU = \"Accton-AS4630-54TE\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLA", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}]}, "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE= \"/sys/class/leds/as5835_54x_led::diag/brightness\"\n \n SYSLED_MODES = {\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n     \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n     ", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os import sys try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper from.event import SfpEvent except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=5 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=4 NUM_QSFP=54 PORT_START=1 PORT_END=54 NUM_COMPONENT=4 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" SYSLED_FNODE=\"/sys/class/leds/as5835_54x_led::diag/brightness\" SYSLED_MODES={ \"0\": \"STATUS_LED_COLOR_OFF\", \"1\": \"STATUS_LED_COLOR_GREEN\", \"3\": \"STATUS_LED_COLOR_AMBER\" } class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(0, PORT_END): sfp=Sfp(index) self._sfp_list.append(sfp) self._sfpevent=SfpEvent(self._sfp_list) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for fant_index in range(NUM_FAN_TRAY): fandrawer=FanDrawer(fant_index) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._eeprom.get_product_name() def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_change_event(self, timeout=0): if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfpevent.get_sfp_event(timeout) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def initizalize_system_led(self): return True def get_status_led(self): val=self._api_helper.read_txt_file(SYSLED_FNODE) return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\" def set_status_led(self, color): mode=None for key, val in SYSLED_MODES.items(): if val==color: mode=key break if mode is None: return False else: return self._api_helper.write_txt_file(SYSLED_FNODE, mode) ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\nimport sys\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\n    from .event import SfpEvent\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 5\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 4\nNUM_QSFP = 54\nPORT_START = 1\nPORT_END = 54\nNUM_COMPONENT = 4\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\nSYSLED_FNODE= \"/sys/class/leds/as5835_54x_led::diag/brightness\"\n\nSYSLED_MODES = {\n    \"0\" : \"STATUS_LED_COLOR_OFF\",\n    \"1\" : \"STATUS_LED_COLOR_GREEN\",\n    \"3\" : \"STATUS_LED_COLOR_AMBER\"\n}\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n        \n        self.config_data = {}\n        \n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n    \n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(0, PORT_END):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self._sfpevent = SfpEvent(self._sfp_list)\n        self.sfp_module_initialized = True\n        \n    def __initialize_fan(self):\n       from sonic_platform.fan_drawer import FanDrawer\n       for fant_index in range(NUM_FAN_TRAY):\n           fandrawer = FanDrawer(fant_index)\n           self._fan_drawer_list.append(fandrawer)\n           self._fan_list.extend(fandrawer._fan_list)\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n    \n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n    \n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n    \n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return self._eeprom.get_product_name()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n    \n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n    \n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n        \n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n\n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_change_event(self, timeout=0):\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n        return self._sfpevent.get_sfp_event(timeout)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n        \n    def initizalize_system_led(self):\n        return True\n\n    def get_status_led(self):\n        val = self._api_helper.read_txt_file(SYSLED_FNODE)\n        return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\"\n\n    def set_status_led(self, color):\n        mode = None\n        for key, val in SYSLED_MODES.items():\n            if val == color:\n                mode = key\n                break\n        if mode is None:\n            return False\n        else:\n            return self._api_helper.write_txt_file(SYSLED_FNODE, mode)\n            \n"}, "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n-\n try:\n     from sonic_platform_base.component_base import ComponentBase\n     from .helper import APIHelper\n", "add": 0, "remove": 4, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()\n \n-\n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n    ", "add": 0, "remove": 17, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"3-0060\", \"CPLD2\": \"3-0061\", \"CPLD3\": \"3-0062\", } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"CPLD2\", \"CPLD 2\"), (\"CPLD3\", \"CPLD 3\"), (\"BIOS\", \"Basic Input/Output System\") ] COMPONENT_DES_LIST=[\"CPLD\",\"Basic Input/Output System\"] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: print('Get exception when read bios') return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return 'N/A' def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return 'N/A' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is'0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"3-0060\",\n    \"CPLD2\": \"3-0061\",\n    \"CPLD3\": \"3-0062\",\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"CPLD2\", \"CPLD 2\"),\n   (\"CPLD3\", \"CPLD 3\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n   \n]\nCOMPONENT_DES_LIST = [\"CPLD\",\"Basic Input/Output System\"]\n\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            print('Get exception when read bios')\n        return None\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)\n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n        \n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n        #return \"testhwsku\"\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of\n        entPhysicalContainedIn is'0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device\n            or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return stat", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return stat"], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r', errors='replace') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r', errors='replace') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as5835_54x-r0\"\n     HWSKU = \"Accton-AS5835-54X\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n \n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess(self.HOST_CHK_CMD).returncode == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess(self.HOST_CHK_CMD).returncode == 0"]}], "source": "\n import os import time import sys from ctypes import create_string_buffer try: from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_I2C_PATH=\"/sys/bus/i2c/devices/\" class Sfp(SfpOptoeBase): \"\"\"Platform-specific Sfp class\"\"\" PORT_START=1 PORT_END=54 QSFP_PORT_START=49 PLATFORM_ROOT_PATH=\"/usr/share/sonic/device\" PMON_HWSKU_PATH=\"/usr/share/sonic/hwsku\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" PLATFORM=\"x86_64-accton_as5835_54x-r0\" HWSKU=\"Accton-AS5835-54X\" _cpld_mapping={ 0: \"3-0060\", 1: \"3-0061\", 2: \"3-0062\", } _port_to_i2c_mapping={ 1: 42, 2: 43, 3: 44, 4: 45, 5: 46, 6: 47, 7: 48, 8: 49, 9: 50, 10: 51, 11: 52, 12: 53, 13: 54, 14: 55, 15: 56, 16: 57, 17: 58, 18: 59, 19: 60, 20: 61, 21: 62, 22: 63, 23: 64, 24: 65, 25: 66, 26: 67, 27: 68, 28: 69, 29: 70, 30: 71, 31: 72, 32: 73, 33: 74, 34: 75, 35: 76, 36: 77, 37: 78, 38: 79, 39: 80, 40: 81, 41: 82, 42: 83, 43: 84, 44: 85, 45: 86, 46: 87, 47: 88, 48: 89, 49: 28, 50: 29, 51: 26, 52: 30, 53: 31, 54: 27, } def __init__(self, sfp_index=0): SfpOptoeBase.__init__(self) self._api_helper=APIHelper() self.index=sfp_index self.port_num=self.index +1 eeprom_path='/sys/bus/i2c/devices/{0}-0050/eeprom' self.port_to_eeprom_mapping={} for x in range(self.PORT_START, self.PORT_END +1): self.port_to_eeprom_mapping[x]=eeprom_path.format(self._port_to_i2c_mapping[x]) def get_eeprom_path(self): return self.port_to_eeprom_mapping[self.port_num] def __get_cpld_num(self, port_num): return 1 if(port_num < 39) else 2 def __is_host(self): return os.system(self.HOST_CHK_CMD)==0 def __get_path_to_port_config_file(self): platform_path=\"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM]) hwsku_path=\"/\".join([platform_path, self.HWSKU] ) if self.__is_host() else self.PMON_HWSKU_PATH return \"/\".join([hwsku_path, \"port_config.ini\"]) def __read_eeprom_specific_bytes(self, offset, num_bytes): sysfsfile_eeprom=None eeprom_raw=[] for i in range(0, num_bytes): eeprom_raw.append(\"0x00\") sysfs_sfp_i2c_client_eeprom_path=self.port_to_eeprom_mapping[self.port_num] try: sysfsfile_eeprom=open( sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0) sysfsfile_eeprom.seek(offset) raw=sysfsfile_eeprom.read(num_bytes) if sys.version_info[0] >=3: for n in range(0, num_bytes): eeprom_raw[n]=hex(raw[n])[2:].zfill(2) else: for n in range(0, num_bytes): eeprom_raw[n]=hex(ord(raw[n]))[2:].zfill(2) except Exception: pass finally: if sysfsfile_eeprom: sysfsfile_eeprom.close() return eeprom_raw def get_reset_status(self): \"\"\" Retrieves the reset status of SFP Returns: A Boolean, True if reset enabled, False if disabled \"\"\" if self.port_num <49: return False cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] reset_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_reset_', self.port_num) val=self._api_helper.read_txt_file(reset_path) if val is not None: return int(val, 10)==1 else: return False def get_rx_los(self): \"\"\" Retrieves the RX LOS(lost-of-signal) status of SFP Returns: A Boolean, True if SFP has RX LOS, False if not. Note: RX LOS status is latched until a call to get_rx_los or a reset. \"\"\" rx_los=False if self.port_num < 49: cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] rx_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_rx_los_', self.port_num) rx_los=self._api_helper.read_txt_file(rx_path) if int(rx_los, 10)==1: return[True] else: return[False] else: rx_los_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: rx_los_data=int(dom_channel_monitor_raw[0], 16) rx_los_list.append(rx_los_data & 0x01 !=0) rx_los_list.append(rx_los_data & 0x02 !=0) rx_los_list.append(rx_los_data & 0x04 !=0) rx_los_list.append(rx_los_data & 0x08 !=0) return rx_los_list else: return[False]*4 def get_tx_fault(self): \"\"\" Retrieves the TX fault status of SFP Returns: A list of boolean values, representing the TX fault status of each available channel, value is True if SFP channel has TX fault, False if not. E.g., for a tranceiver with four channels:[False, False, True, False] Note: TX fault status is lached until a call to get_tx_fault or a reset. \"\"\" tx_fault=False if self.port_num < 49: cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] tx_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_fault_', self.port_num) tx_fault=self._api_helper.read_txt_file(tx_path) if int(tx_fault, 10)==1: return[True] else: return[False] else: tx_fault_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: tx_fault_data=int(dom_channel_monitor_raw[0], 16) tx_fault_list.append(tx_fault_data & 0x01 !=0) tx_fault_list.append(tx_fault_data & 0x02 !=0) tx_fault_list.append(tx_fault_data & 0x04 !=0) tx_fault_list.append(tx_fault_data & 0x08 !=0) return tx_fault_list else: return[False]*4 def get_tx_disable(self): \"\"\" Retrieves the tx_disable status of this SFP Returns: A list of boolean values, representing the TX disable status of each available channel, value is True if SFP channel is TX disabled, False if not. E.g., for a tranceiver with four channels:[False, False, True, False] \"\"\" if self.port_num < 49: tx_disable=False cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] tx_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_disable_', self.port_num) tx_disable=self._api_helper.read_txt_file(tx_path) if int(tx_disable, 10)==0: return[False] else: return[True] else: tx_disable_list=[] sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) tx_disable_list.append( 'On'==dom_control_data['data']['TX1Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX2Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX3Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX4Disable']['value']) return tx_disable_list else: return[False]*4 def get_tx_disable_channel(self): \"\"\" Retrieves the TX disabled channels in this SFP Returns: A hex of 4 bits(bit 0 to bit 3 as channel 0 to channel 3) to represent TX channels which have been disabled in this SFP. As an example, a returned value of 0x5 indicates that channel 0 and channel 2 have been disabled. \"\"\" tx_disable_list=self.get_tx_disable() if tx_disable_list is None: return 0 tx_disabled=0 for i in range(len(tx_disable_list)): if tx_disable_list[i]: tx_disabled |=1 << i return tx_disabled def get_lpmode(self): \"\"\" Retrieves the lpmode(low power mode) status of this SFP Returns: A Boolean, True if lpmode is enabled, False if disabled \"\"\" if self.port_num < 49: return False else: power_set=self.get_power_set() power_override=self.get_power_override() return power_set and power_override def get_power_set(self): if self.port_num < 49: return False else: power_set=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) power_set=( 'On'==dom_control_data['data']['PowerSet']['value']) return power_set def get_power_override(self): \"\"\" Retrieves the power-override status of this SFP Returns: A Boolean, True if power-override is enabled, False if disabled \"\"\" if self.port_num < 49: return False else: power_override=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) power_override=( 'On'==dom_control_data['data']['PowerOverride']['value']) return power_override def reset(self): \"\"\" Reset SFP and return all user module settings to their default srate. Returns: A boolean, True if successful, False if not \"\"\" if self.port_num <49: return False cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] reset_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_reset_', self.port_num) ret=self._api_helper.write_txt_file(reset_path, 1) if ret is not True: return ret time.sleep(0.01) ret=self._api_helper.write_txt_file(reset_path, 0) time.sleep(0.2) return ret def tx_disable(self, tx_disable): \"\"\" Disable SFP TX for all channels Args: tx_disable: A Boolean, True to enable tx_disable mode, False to disable tx_disable mode. Returns: A boolean, True if tx_disable is set successfully, False if not \"\"\" if self.port_num < 49: cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] tx_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_disable_', self.port_num) ret=self._api_helper.write_txt_file(tx_path, 1 if tx_disable else 0) if ret is not None: time.sleep(0.01) return ret else: return False else: if not self.get_presence(): return False sysfsfile_eeprom=None try: tx_disable_ctl=0xf if tx_disable else 0x0 buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=tx_disable_ctl else: buffer[0]=chr(tx_disable_ctl) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ',str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def tx_disable_channel(self, channel, disable): \"\"\" Sets the tx_disable for specified SFP channels Args: channel: A hex of 4 bits(bit 0 to bit 3) which represent channel 0 to 3, e.g. 0x5 for channel 0 and channel 2. disable: A boolean, True to disable TX channels specified in channel, False to enable Returns: A boolean, True if successful, False if not \"\"\" if self.port_num < 49: return False else: if not self.get_presence(): return False sysfsfile_eeprom=None try: channel_state=self.get_tx_disable_channel() for i in range(4): channel_mask=(1 << i) if not(channel & channel_mask): continue if disable: channel_state |=channel_mask else: channel_state &=~channel_mask buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=channel_state else: buffer[0]=chr(channel_state) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ', str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def set_lpmode(self, lpmode): \"\"\" Sets the lpmode(low power mode) of SFP Args: lpmode: A Boolean, True to enable lpmode, False to disable it Note : lpmode can be overridden by set_power_override Returns: A boolean, True if lpmode is set successfully, False if not \"\"\" if self.port_num < 49: return False else: if lpmode: self.set_power_override(True, True) else: self.set_power_override(False, False) return True def set_power_override(self, power_override, power_set): \"\"\" Sets SFP power level using power_override and power_set Args: power_override: A Boolean, True to override set_lpmode and use power_set to control SFP power, False to disable SFP power control through power_override/power_set and use set_lpmode to control SFP power. power_set: Only valid when power_override is True. A Boolean, True to set SFP to low power mode, False to set SFP to high power mode. Returns: A boolean, True if power-override and power_set are set successfully, False if not \"\"\" if self.port_num < 49: return False else: if not self.get_presence(): return False try: power_override_bit=(1 << 0) if power_override else 0 power_set_bit =(1 << 1) if power_set else(1 << 3) buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=(power_override_bit | power_set_bit) else: buffer[0]=chr(power_override_bit | power_set_bit) with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd: fd.seek(QSFP_POWEROVERRIDE_OFFSET) fd.write(buffer[0]) time.sleep(0.01) except Exception: print('Error: unable to open file: ', str(e)) return False return True def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" sfputil_helper=SfpUtilHelper() sfputil_helper.read_porttab_mappings( self.__get_path_to_port_config_file()) name=sfputil_helper.logical[self.index] or \"Unknown\" return name def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] present_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_present_', self.port_num) val=self._api_helper.read_txt_file(present_path) if val is not None: return int(val, 10)==1 else: return False def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return self.get_presence() def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return self.port_num def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return True ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Sfp contains an implementation of SONiC Platform Base API and\n# provides the sfp device status which are available in the platform\n#\n#############################################################################\n\nimport os\nimport time\nimport sys\n\nfrom ctypes import create_string_buffer\n\ntry:\n    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_I2C_PATH = \"/sys/bus/i2c/devices/\"\n\nclass Sfp(SfpOptoeBase):\n    \"\"\"Platform-specific Sfp class\"\"\"\n\n    # Port number\n    PORT_START = 1\n    PORT_END = 54\n    QSFP_PORT_START = 49\n\n    # Path to sysfs\n    PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n    PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n        \n    PLATFORM = \"x86_64-accton_as5835_54x-r0\"\n    HWSKU = \"Accton-AS5835-54X\"\n\n    _cpld_mapping = {\n        0:  \"3-0060\",\n        1:  \"3-0061\",\n        2:  \"3-0062\",\n    }\n    _port_to_i2c_mapping = {\n        1:  42,\n        2:  43,\n        3:  44,\n        4:  45,\n        5:  46,\n        6:  47,\n        7:  48,\n        8:  49,\n        9:  50,\n        10: 51,\n        11: 52,\n        12: 53,\n        13: 54,\n        14: 55,\n        15: 56,\n        16: 57,\n        17: 58,\n        18: 59,\n        19: 60,\n        20: 61,\n        21: 62,\n        22: 63,\n        23: 64,\n        24: 65,\n        25: 66,\n        26: 67,\n        27: 68,\n        28: 69,\n        29: 70,\n        30: 71,\n        31: 72,\n        32: 73,\n        33: 74,\n        34: 75,\n        35: 76,\n        36: 77,\n        37: 78,\n        38: 79,\n        39: 80,\n        40: 81,\n        41: 82,\n        42: 83,\n        43: 84,\n        44: 85,\n        45: 86,\n        46: 87,\n        47: 88,\n        48: 89,\n        49: 28,  # QSFP49\n        50: 29,  # QSFP50\n        51: 26,  # QSFP51\n        52: 30,  # QSFP52\n        53: 31,  # QSFP53\n        54: 27,  # QSFP54\n        \n    }\n\n    def __init__(self, sfp_index=0):\n        SfpOptoeBase.__init__(self)\n        self._api_helper=APIHelper()\n        # Init index\n        self.index = sfp_index\n        self.port_num = self.index + 1\n\n        # Init eeprom path\n        eeprom_path = '/sys/bus/i2c/devices/{0}-0050/eeprom'\n        self.port_to_eeprom_mapping = {}\n        for x in range(self.PORT_START, self.PORT_END + 1):\n            self.port_to_eeprom_mapping[x] = eeprom_path.format(self._port_to_i2c_mapping[x])\n\n    def get_eeprom_path(self):\n        return self.port_to_eeprom_mapping[self.port_num]\n        \n    # For cage 1~38 are at cpld2, others are at cpld3.\n    def __get_cpld_num(self, port_num):\n        return 1 if (port_num < 39) else 2\n\n\n    def __is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def __get_path_to_port_config_file(self):\n        platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n        hwsku_path = \"/\".join([platform_path, self.HWSKU]\n                              ) if self.__is_host() else self.PMON_HWSKU_PATH\n        return \"/\".join([hwsku_path, \"port_config.ini\"])\n\n    def __read_eeprom_specific_bytes(self, offset, num_bytes):\n        sysfsfile_eeprom = None\n        eeprom_raw = []\n        for i in range(0, num_bytes):\n            eeprom_raw.append(\"0x00\")\n\n        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]\n        try:\n            sysfsfile_eeprom = open(\n                sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0)\n            sysfsfile_eeprom.seek(offset)\n            raw = sysfsfile_eeprom.read(num_bytes)\n            if sys.version_info[0] >= 3:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(raw[n])[2:].zfill(2)\n            else:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(ord(raw[n]))[2:].zfill(2)\n        except Exception:\n            pass\n        finally:\n            if sysfsfile_eeprom:\n                sysfsfile_eeprom.close()\n\n        return eeprom_raw\n\n    def get_reset_status(self):\n        \"\"\"\n        Retrieves the reset status of SFP\n        Returns:\n            A Boolean, True if reset enabled, False if disabled\n        \"\"\"\n        if self.port_num <49:\n            return False # SPF port doesn't support this feature\n          \n        cpld_i = self.__get_cpld_num(self.port_num)\n        cpld_path = self._cpld_mapping[cpld_i]        \n        reset_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_reset_', self.port_num)\n        val=self._api_helper.read_txt_file(reset_path)\n        if val is not None:\n            return int(val, 10)==1\n        else:\n            return False\n\n    def get_rx_los(self):\n        \"\"\"\n        Retrieves the RX LOS (lost-of-signal) status of SFP\n        Returns:\n            A Boolean, True if SFP has RX LOS, False if not.\n            Note : RX LOS status is latched until a call to get_rx_los or a reset.\n        \"\"\"\n        rx_los = False\n        if self.port_num < 49:\n            cpld_i = self.__get_cpld_num(self.port_num)\n            cpld_path = self._cpld_mapping[cpld_i]        \n            rx_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_rx_los_', self.port_num)\n\n            rx_los=self._api_helper.read_txt_file(rx_path)\n            if int(rx_los, 10) == 1:\n                return [True]\n            else:\n                return [False]\n            #status_control_raw = self.__read_eeprom_specific_bytes(\n            #    SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            #if status_control_raw:\n            #    data = int(status_control_raw[0], 16)\n            #    rx_los = (sffbase().test_bit(data, 1) != 0)\n            \n        else:\n            rx_los_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None\n            if dom_channel_monitor_raw is not None:\n                rx_los_data = int(dom_channel_monitor_raw[0], 16)\n                rx_los_list.append(rx_los_data & 0x01 != 0)\n                rx_los_list.append(rx_los_data & 0x02 != 0)\n                rx_los_list.append(rx_los_data & 0x04 != 0)\n                rx_los_list.append(rx_los_data & 0x08 != 0)\n                return rx_los_list\n            else:\n                return [False]*4\n\n    def get_tx_fault(self):\n        \"\"\"\n        Retrieves the TX fault status of SFP\n        Returns:\n            A list of boolean values, representing the TX fault status\n            of each available channel, value is True if SFP channel\n            has TX fault, False if not.\n            E.g., for a tranceiver with four channels: [False, False, True, False]\n            Note : TX fault status is lached until a call to get_tx_fault or a reset.\n        \"\"\"\n        tx_fault = False\n        if self.port_num < 49:\n            cpld_i = self.__get_cpld_num(self.port_num)\n            cpld_path = self._cpld_mapping[cpld_i]        \n            tx_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_fault_', self.port_num)\n\n            tx_fault=self._api_helper.read_txt_file(tx_path)\n            if int(tx_fault, 10) == 1:\n                return [True]\n            else:\n                return [False]\n            #status_control_raw = self.__read_eeprom_specific_bytes(\n            #    SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            #if status_control_raw:\n            #    data = int(status_control_raw[0], 16)\n            #    tx_fault = (sffbase().test_bit(data, 2) != 0)\n        else:\n            tx_fault_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None\n            if dom_channel_monitor_raw is not None:\n                tx_fault_data = int(dom_channel_monitor_raw[0], 16)\n                tx_fault_list.append(tx_fault_data & 0x01 != 0)\n                tx_fault_list.append(tx_fault_data & 0x02 != 0)\n                tx_fault_list.append(tx_fault_data & 0x04 != 0)\n                tx_fault_list.append(tx_fault_data & 0x08 != 0)\n                return tx_fault_list\n            else:\n                return [False]*4\n\n\n    def get_tx_disable(self):\n        \"\"\"\n        Retrieves the tx_disable status of this SFP\n        Returns:\n            A list of boolean values, representing the TX disable status\n            of each available channel, value is True if SFP channel\n            is TX disabled, False if not.\n            E.g., for a tranceiver with four channels: [False, False, True, False]\n        \"\"\"\n        if self.port_num < 49: \n            tx_disable = False\n            \n            cpld_i = self.__get_cpld_num(self.port_num)\n            cpld_path = self._cpld_mapping[cpld_i]        \n            tx_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_disable_', self.port_num)\n\n            tx_disable=self._api_helper.read_txt_file(tx_path)\n            \n            #status_control_raw = self.__read_eeprom_specific_bytes(\n            #    SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            #if status_control_raw:\n            #    data = int(status_control_raw[0], 16)\n            #    tx_disable_hard = (sffbase().test_bit(\n            #        data, SFP_TX_DISABLE_HARD_BIT) != 0)\n            #    tx_disable_soft = (sffbase().test_bit(\n            #        data, SFP_TX_DISABLE_SOFT_BIT) != 0)\n            #    tx_disable = tx_disable_hard | tx_disable_soft\n            if int(tx_disable, 10)==0:\n                return [False]\n            else:\n                return [True]\n\n        else:\n            tx_disable_list = []\n    \n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n    \n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX1Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX2Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX3Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX4Disable']['value'])\n                return tx_disable_list\n            else:\n                return [False]*4\n\n    def get_tx_disable_channel(self):\n        \"\"\"\n        Retrieves the TX disabled channels in this SFP\n        Returns:\n            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent\n            TX channels which have been disabled in this SFP.\n            As an example, a returned value of 0x5 indicates that channel 0\n            and channel 2 have been disabled.\n        \"\"\"\n        tx_disable_list = self.get_tx_disable()\n        if tx_disable_list is None:\n            return 0\n        tx_disabled = 0\n        for i in range(len(tx_disable_list)):\n            if tx_disable_list[i]:\n                tx_disabled |= 1 << i\n        return tx_disabled\n\n    def get_lpmode(self):\n        \"\"\"\n        Retrieves the lpmode (low power mode) status of this SFP\n        Returns:\n            A Boolean, True if lpmode is enabled, False if disabled\n        \"\"\"\n        if self.port_num < 49: \n            # SFP doesn't support this feature\n            return False\n        else:\n            power_set=self.get_power_set()\n            power_override = self.get_power_override()\n            return power_set and power_override\n       \n    \n    def get_power_set(self):\n        \n        if self.port_num < 49: \n            # SFP doesn't support this feature\n            return False\n        else:\n            power_set = False\n            \n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n    \n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n                power_set = (\n                    'On' == dom_control_data['data']['PowerSet']['value'])\n    \n            return power_set\n\n    def get_power_override(self):\n        \"\"\"\n        Retrieves the power-override status of this SFP\n        Returns:\n            A Boolean, True if power-override is enabled, False if disabled\n        \"\"\"\n        if self.port_num < 49:\n            return False # SFP doesn't support this feature\n        else:\n            power_override = False\n    \n            \n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n    \n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n                power_override = (\n                    'On' == dom_control_data['data']['PowerOverride']['value'])\n    \n            return power_override\n\n    def reset(self):\n        \"\"\"\n        Reset SFP and return all user module settings to their default srate.\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        if self.port_num <49:\n            return False # SFP doesn't support this feature\n          \n        cpld_i = self.__get_cpld_num(self.port_num)\n        cpld_path = self._cpld_mapping[cpld_i]        \n        reset_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_reset_', self.port_num)      \n        ret = self._api_helper.write_txt_file(reset_path, 1)\n\n        if ret is not True:\n            return ret\n\n        time.sleep(0.01)\n        ret = self._api_helper.write_txt_file(reset_path, 0)\n        time.sleep(0.2)\n        \n        return ret\n      \n    def tx_disable(self, tx_disable):\n        \"\"\"\n        Disable SFP TX for all channels\n        Args:\n            tx_disable : A Boolean, True to enable tx_disable mode, False to disable\n                         tx_disable mode.\n        Returns:\n            A boolean, True if tx_disable is set successfully, False if not\n        \"\"\"\n        if self.port_num < 49:\n            cpld_i = self.__get_cpld_num(self.port_num)\n            cpld_path = self._cpld_mapping[cpld_i]        \n            tx_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_disable_', self.port_num)      \n            ret = self._api_helper.write_txt_file(tx_path,  1 if tx_disable else 0)\n\n            if ret is not None:\n                time.sleep(0.01)\n                return ret\n            else:\n                return False\n        \n        else:\n            if not self.get_presence():\n                return False\n            sysfsfile_eeprom = None\n            try:\n                tx_disable_ctl = 0xf if tx_disable else 0x0\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = tx_disable_ctl\n                else:\n                    buffer[0] = chr(tx_disable_ctl)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print ('Error: unable to open file: ',str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n        return True\n\n    def tx_disable_channel(self, channel, disable):\n        \"\"\"\n        Sets the tx_disable for specified SFP channels\n        Args:\n            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,\n                      e.g. 0x5 for channel 0 and channel 2.\n            disable : A boolean, True to disable TX channels specified in channel,\n                      False to enable\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        \n        if self.port_num < 49:\n            return False # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n\n            sysfsfile_eeprom = None\n            try:\n                channel_state = self.get_tx_disable_channel()\n\n                for i in range(4):\n                    channel_mask = (1 << i)\n                    if not (channel & channel_mask):\n                        continue\n\n                    if disable:\n                        channel_state |= channel_mask\n                    else:\n                        channel_state &= ~channel_mask\n\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = channel_state\n                else:\n                    buffer[0] = chr(channel_state)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print ('Error: unable to open file: ', str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n            return True\n\n    def set_lpmode(self, lpmode):\n        \"\"\"\n        Sets the lpmode (low power mode) of SFP\n        Args:\n            lpmode: A Boolean, True to enable lpmode, False to disable it\n            Note  : lpmode can be overridden by set_power_override\n        Returns:\n            A boolean, True if lpmode is set successfully, False if not\n        \"\"\"\n        if self.port_num < 49:\n            return False # SFP doesn't support this feature\n        else:\n            if lpmode:\n                self.set_power_override(True, True)\n            else:\n                self.set_power_override(False, False)\n    \n            return True\n       \n    def set_power_override(self, power_override, power_set):\n        \"\"\"\n        Sets SFP power level using power_override and power_set\n        Args:\n            power_override :\n                    A Boolean, True to override set_lpmode and use power_set\n                    to control SFP power, False to disable SFP power control\n                    through power_override/power_set and use set_lpmode\n                    to control SFP power.\n            power_set :\n                    Only valid when power_override is True.\n                    A Boolean, True to set SFP to low power mode, False to set\n                    SFP to high power mode.\n        Returns:\n            A boolean, True if power-override and power_set are set successfully,\n            False if not\n        \"\"\"\n        if self.port_num < 49:\n            return False # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n            try:\n                power_override_bit = (1 << 0) if power_override else 0\n                power_set_bit      = (1 << 1) if power_set else (1 << 3)\n    \n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = (power_override_bit | power_set_bit)\n                else:\n                    buffer[0] = chr(power_override_bit | power_set_bit)\n                # Write to eeprom\n                with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd:\n                    fd.seek(QSFP_POWEROVERRIDE_OFFSET)\n                    fd.write(buffer[0])\n                    time.sleep(0.01)\n            except Exception:\n                print ('Error: unable to open file: ', str(e))\n                return False\n            return True\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        sfputil_helper = SfpUtilHelper()\n        sfputil_helper.read_porttab_mappings(\n            self.__get_path_to_port_config_file())\n        name = sfputil_helper.logical[self.index] or \"Unknown\"\n        return name\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        cpld_i = self.__get_cpld_num(self.port_num)\n        cpld_path = self._cpld_mapping[cpld_i]          \n        present_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_present_', self.port_num)\n        val=self._api_helper.read_txt_file(present_path)\n        if val is not None:\n            return int(val, 10)==1\n        else:\n            return False\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return self.get_presence()\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return self.port_num\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return True\n"}, "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n #\n #############################################################################\n try:\n-    import sys\n-    import re\n-    import os\n     import subprocess\n-    import json\n-    import syslog\n     from sonic_platform_base.chassis_base import ChassisBase\n     from sonic_py_common.logger import Logger\n     from sonic_platform.fan import Fan\n", "add": 0, "remove": 5, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py", "badparts": ["    import sys", "    import re", "    import json", "    import syslog"], "goodparts": []}, {"diff": "\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n COMPONENT_NAME_LIST = [\"BIOS\"]\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         logger.log_info(\"Chassis loaded successfully\")\n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n ", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n try: import sys import re import os import subprocess import json import syslog from sonic_platform_base.chassis_base import ChassisBase from sonic_py_common.logger import Logger from sonic_platform.fan import Fan from sonic_platform.psu import Psu from sonic_platform.component import Component from sonic_platform.thermal import Thermal from sonic_platform.sfp import Sfp from sonic_platform.eeprom import Tlv except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=5 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=4 NUM_SFP=54 SFP_PORT_START=0 QSFP_PORT_START=48 SFP_PORT_END=47 QSFP_PORT_END=53 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" COMPONENT_NAME_LIST=[\"BIOS\"] HOST_CHK_CMD=\"docker > /dev/null 2>&1\" class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): super(Chassis, self).__init__() for fantray_index in range(0, NUM_FAN_TRAY): for fan_index in range(0, NUM_FAN): fan=Fan(fantray_index, fan_index) self._fan_list.append(fan) for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) self.PORT_START=SFP_PORT_START self.QSFP_PORT_START=QSFP_PORT_START self.PORT_END=QSFP_PORT_END for index in range(0, NUM_SFP): if index in range(self.QSFP_PORT_START, self.QSPORT_END +1): sfp_module=Sfp(index, 'QSFP') else: sfp_module=Sfp(index, 'SFP') self._sfp_list.append(sfp_module) self._component_name_list=COMPONENT_NAME_LIST self._watchdog=Watchdog() self._eeprom=Tlv() logger.log_info(\"Chassis loaded successfully\") def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_firmware_version(self, component_name): \"\"\" Retrieves platform-specific hardware/firmware versions for chassis componenets such as BIOS, CPLD, FPGA, etc. Args: type: A string, component name Returns: A string containing platform-specific component versions \"\"\" self.component=Component(component_name) if component_name not in self._component_name_list: return None return self.component.get_firmware_version() def install_component_firmware(self, component_name, image_path): \"\"\" Install firmware to module Args: type: A string, component name. image_path: A string, path to firmware image. Returns: A boolean, True if install successfully, False if not \"\"\" self.component=Component(component_name) if component_name not in self._component_name_list: return False return self.component.upgrade_firmware(image_path) def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" description='None' reboot_cause=self.REBOOT_CAUSE_HARDWARE_OTHER reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) if self.__is_host( ) else PMON_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE prev_reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +PREV_REBOOT_CAUSE_FILE) if self.__is_host( ) else PMON_REBOOT_CAUSE_PATH +PREV_REBOOT_CAUSE_FILE sw_reboot_cause=self.__read_txt_file( reboot_cause_path) or \"Unknown\" prev_sw_reboot_cause=self.__read_txt_file( prev_reboot_cause_path) or \"Unknown\" if sw_reboot_cause !=\"Unknown\": reboot_cause=self.REBOOT_CAUSE_NON_HARDWARE description=sw_reboot_cause else: reboot_cause=self.REBOOT_CAUSE_HARDWARE_OTHER description='Unknown reason' return(reboot_cause, description) ", "sourceWithComments": "#############################################################################\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\ntry:\n    import sys\n    import re\n    import os\n    import subprocess\n    import json\n    import syslog\n    from sonic_platform_base.chassis_base import ChassisBase\n    from sonic_py_common.logger import Logger\n    from sonic_platform.fan import Fan\n    from sonic_platform.psu import Psu\n    from sonic_platform.component import Component\n    from sonic_platform.thermal import Thermal\n    from sonic_platform.sfp import Sfp\n    from sonic_platform.eeprom import Tlv\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 5\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 4\nNUM_SFP = 54\nSFP_PORT_START = 0\nQSFP_PORT_START = 48\nSFP_PORT_END = 47\nQSFP_PORT_END = 53\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nCOMPONENT_NAME_LIST = [\"BIOS\"]\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        super(Chassis, self).__init__()\n\n        for fantray_index in range(0, NUM_FAN_TRAY):\n            for fan_index in range(0, NUM_FAN):\n                fan = Fan(fantray_index, fan_index)\n                self._fan_list.append(fan)\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n\n        self.PORT_START = SFP_PORT_START\n        self.QSFP_PORT_START = QSFP_PORT_START\n        self.PORT_END = QSFP_PORT_END\n        for index in range(0, NUM_SFP):\n            if index in range(self.QSFP_PORT_START, self.QSPORT_END + 1):\n                sfp_module = Sfp(index, 'QSFP')\n            else:\n                sfp_module = Sfp(index, 'SFP')\n            self._sfp_list.append(sfp_module)\n        self._component_name_list = COMPONENT_NAME_LIST\n        self._watchdog = Watchdog()\n        self._eeprom = Tlv()\n        logger.log_info(\"Chassis loaded successfully\")\n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_firmware_version(self, component_name):\n        \"\"\"\n        Retrieves platform-specific hardware/firmware versions for chassis\n        componenets such as BIOS, CPLD, FPGA, etc.\n        Args:\n            type: A string, component name\n\n        Returns:\n            A string containing platform-specific component versions\n        \"\"\"\n        self.component = Component(component_name)\n        if component_name not in self._component_name_list:\n            return None\n        return self.component.get_firmware_version()\n\n    def install_component_firmware(self, component_name, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            type: A string, component name.\n            image_path: A string, path to firmware image.\n\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        self.component = Component(component_name)\n        if component_name not in self._component_name_list:\n            return False\n        return self.component.upgrade_firmware(image_path)\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        description = 'None'\n        reboot_cause = self.REBOOT_CAUSE_HARDWARE_OTHER\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE) if self.__is_host(\n        ) else PMON_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE\n        prev_reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + PREV_REBOOT_CAUSE_FILE) if self.__is_host(\n        ) else PMON_REBOOT_CAUSE_PATH + PREV_REBOOT_CAUSE_FILE\n        sw_reboot_cause = self.__read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n        prev_sw_reboot_cause = self.__read_txt_file(\n            prev_reboot_cause_path) or \"Unknown\"\n\n        if sw_reboot_cause != \"Unknown\":\n            reboot_cause = self.REBOOT_CAUSE_NON_HARDWARE\n            description = sw_reboot_cause\n        else:\n            reboot_cause = self.REBOOT_CAUSE_HARDWARE_OTHER\n            description = 'Unknown reason'\n\n        return (reboot_cause, description)\n"}, "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py": {"changes": [{"diff": "\n # provides the components firmware management function\n #############################################################################\n \n-import json\n import os.path\n-import shutil\n-import shlex\n import subprocess\n \n try:\n", "add": 0, "remove": 3, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py", "badparts": ["import json", "import shutil", "import shlex"], "goodparts": []}, {"diff": "\n     def __run_command(self, command):\n         # Run bash command and print output to stdout\n         try:\n-            process = subprocess.Popen(\n-                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n+            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n             while True:\n                 output = process.stdout.readline()\n                 if output == '' and process.poll()", "add": 1, "remove": 2, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py", "badparts": ["            process = subprocess.Popen(", "                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)"], "goodparts": ["            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)"]}], "source": "\n import json import os.path import shutil import shlex import subprocess try: from sonic_platform_base.device_base import DeviceBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" class Component(DeviceBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_name): DeviceBase.__init__(self) self.name=component_name.upper() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() return fw_version def upgrade_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" if not os.path.isfile(image_path): return False if self.name==\"BIOS\": print(\"Not supported\") return False return self.__run_command(install_command) ", "sourceWithComments": "#############################################################################\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#############################################################################\n\nimport json\nimport os.path\nimport shutil\nimport shlex\nimport subprocess\n\ntry:\n    from sonic_platform_base.device_base import DeviceBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\n\n\nclass Component(DeviceBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_name):\n        DeviceBase.__init__(self)\n        self.name = component_name.upper()\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n\n        return fw_version\n\n    def upgrade_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        if not os.path.isfile(image_path):\n            return False\n\n        if self.name == \"BIOS\":\n            print(\"Not supported\")\n            return False\n\n        return self.__run_command(install_command)\n"}, "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n # provides the sfp device status which are available in the platform\n #############################################################################\n try:\n-    import os\n     import time\n     import subprocess\n-    import syslog\n     from ctypes import create_string_buffer\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom\n", "add": 0, "remove": 2, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py", "badparts": ["    import syslog"], "goodparts": []}, {"diff": "\n \n     PLATFORM_ROOT_PATH = '/usr/share/sonic/device'\n     PMON_HWSKU_PATH = '/usr/share/sonic/hwsku'\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-accton_as7116_54x-r0\"\n     HWSKU = \"Accton-AS7116-54X-R0\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         return \"\"\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, s", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}]}, "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n     \n     \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path)", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=6 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=4 PORT_END=54 NUM_COMPONENT=4 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"docker > /dev/null 2>&1\" class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(0, PORT_END): sfp=Sfp(index) self._sfp_list.append(sfp) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan import Fan for fant_index in range(0, NUM_FAN_TRAY): for fan_index in range(0, NUM_FAN): fan=Fan(fant_index, fan_index) self._fan_list.append(fan) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._api_helper.hwsku def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_serial_number(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 6\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 4\nPORT_END = 54\nNUM_COMPONENT = 4\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n        \n        self.config_data = {}\n        \n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n    \n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(0, PORT_END):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self.sfp_module_initialized = True\n        \n    def __initialize_fan(self):\n        from sonic_platform.fan import Fan\n        for fant_index in range(0, NUM_FAN_TRAY):\n            for fan_index in range(0, NUM_FAN):\n                fan = Fan(fant_index, fan_index)\n                self._fan_list.append(fan)\n                \n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n    \n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n    \n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n    \n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n    \n    \n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        \n        return self._api_helper.hwsku\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n    \n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n    \n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_serial_number(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()   \n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        \n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n         \n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n"}, "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 2, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware versi", "add": 0, "remove": 16, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"4-0060\", \"CPLD2\": \"5-0062\", \"CPLD3\": \"6-0064\", } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"CPLD2\", \"CPLD 2\"), (\"CPLD3\", \"CPLD 3\"), (\"BIOS\", \"Basic Input/Output System\") ] COMPONENT_DES_LIST=[\"CPLD\",\"Basic Input/Output System\"] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"4-0060\",\n    \"CPLD2\": \"5-0062\",\n    \"CPLD3\": \"6-0064\",\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"CPLD2\", \"CPLD 2\"),\n   (\"CPLD3\", \"CPLD 3\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n   \n]\nCOMPONENT_DES_LIST = [\"CPLD\",\"Basic Input/Output System\"]\n\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n   \n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)\n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n        \n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n        #return \"testhwsku\"\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n"}, "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        retu", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        retu"], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n         \n     PLATFORM = \"x86_64-accton_as7312_54x-r0\"\n     HWSKU = \"Accton-AS7312-54X\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         return True\n     \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PAT", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}]}, "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE= \"/sys/class/leds/accton_as7326_56x_led::diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n         self._watchdog = Watchdog()\n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_p", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os import sys try: from sonic_platform_base.chassis_base import ChassisBase from.event import SfpEvent from sonic_py_common import device_info except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=6 NUM_PSU=2 NUM_THERMAL=4 NUM_PORT=58 NUM_COMPONENT=4 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" SYSLED_FNODE=\"/sys/class/leds/accton_as7326_56x_led::diag/brightness\" SYSLED_MODES={ \"0\": \"STATUS_LED_COLOR_OFF\", \"1\": \"STATUS_LED_COLOR_GREEN\", \"3\": \"STATUS_LED_COLOR_RED\", \"5\": \"STATUS_LED_COLOR_GREEN_BLINK\" } class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self.config_data={} (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(NUM_PORT): sfp=Sfp(index) self._sfp_list.append(sfp) self._sfpevent=SfpEvent(self._sfp_list) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for fant_index in range(NUM_FAN_TRAY): fandrawer=FanDrawer(fant_index) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: return fd.read().strip() except IOError: pass return None def __write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except Exception: return False return True def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._eeprom.get_product_name() def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" description='None' reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) if self.__is_host( ) else(PMON_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) prev_reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +PREV_REBOOT_CAUSE_FILE) if self.__is_host( ) else(PMON_REBOOT_CAUSE_PATH +PREV_REBOOT_CAUSE_FILE) sw_reboot_cause =self.__read_txt_file(reboot_cause_path) or \"Unknown\" prev_sw_reboot_cause=self.__read_txt_file(prev_reboot_cause_path) or \"Unknown\" if sw_reboot_cause !=\"Unknown\": reboot_cause=self.REBOOT_CAUSE_NON_HARDWARE description=sw_reboot_cause elif prev_reboot_cause_path !=\"Unknown\": reboot_cause=self.REBOOT_CAUSE_NON_HARDWARE description=prev_sw_reboot_cause return(reboot_cause, description) def get_change_event(self, timeout=0): if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfpevent.get_sfp_event(timeout) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def initizalize_system_led(self): return True def get_status_led(self): val=self.__read_txt_file(SYSLED_FNODE) return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\" def set_status_led(self, color): mode=None for key, val in SYSLED_MODES.items(): if val==color: mode=key break if mode is None: return False else: return self.__write_txt_file(SYSLED_FNODE, mode) ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\nimport sys\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .event import SfpEvent\n    from sonic_py_common import device_info\n\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 6\nNUM_PSU = 2\nNUM_THERMAL = 4\nNUM_PORT = 58\nNUM_COMPONENT = 4\n\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\nSYSLED_FNODE= \"/sys/class/leds/accton_as7326_56x_led::diag/brightness\"\nSYSLED_MODES = {\n    \"0\" : \"STATUS_LED_COLOR_OFF\",\n    \"1\" : \"STATUS_LED_COLOR_GREEN\",\n    \"3\" : \"STATUS_LED_COLOR_RED\",\n    \"5\" : \"STATUS_LED_COLOR_GREEN_BLINK\"\n}\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self.config_data = {}\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n\n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(NUM_PORT):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self._sfpevent = SfpEvent(self._sfp_list)\n        self.sfp_module_initialized = True\n\n    def __initialize_fan(self):\n        from sonic_platform.fan_drawer import FanDrawer\n        for fant_index in range(NUM_FAN_TRAY):\n            fandrawer = FanDrawer(fant_index)\n            self._fan_drawer_list.append(fandrawer)\n            self._fan_list.extend(fandrawer._fan_list)\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        self._watchdog = Watchdog()\n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                return fd.read().strip()\n        except IOError:\n            pass\n        return None\n\n    def __write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except Exception:\n            return False\n        return True\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return self._eeprom.get_product_name()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        description = 'None'\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE) if self.__is_host(\n        ) else (PMON_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        prev_reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + PREV_REBOOT_CAUSE_FILE) if self.__is_host(\n        ) else (PMON_REBOOT_CAUSE_PATH + PREV_REBOOT_CAUSE_FILE)\n\n        sw_reboot_cause      = self.__read_txt_file(reboot_cause_path) or \"Unknown\"\n        prev_sw_reboot_cause = self.__read_txt_file(prev_reboot_cause_path) or \"Unknown\"\n\n        if sw_reboot_cause != \"Unknown\":\n            reboot_cause = self.REBOOT_CAUSE_NON_HARDWARE\n            description = sw_reboot_cause\n        elif prev_reboot_cause_path != \"Unknown\":\n            reboot_cause = self.REBOOT_CAUSE_NON_HARDWARE\n            description = prev_sw_reboot_cause\n\n        return (reboot_cause, description)\n\n    def get_change_event(self, timeout=0):\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n        return self._sfpevent.get_sfp_event(timeout)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n\n    def initizalize_system_led(self):\n        return True\n\n    def get_status_led(self):\n        val = self.__read_txt_file(SYSLED_FNODE)\n        return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\"\n\n    def set_status_led(self, color):\n        mode = None\n        for key, val in SYSLED_MODES.items():\n            if val == color:\n                mode = key\n                break\n        if mode is None:\n            return False\n        else:\n            return self.__write_txt_file(SYSLED_FNODE, mode)\n"}, "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n \n     PLATFORM = \"x86_64-accton_as7326_56x-r0\"\n     HWSKU = \"Accton-AS7326-56X\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_P", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}], "source": "\n import os import time import sys from ctypes import create_string_buffer try: from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ 0:{ \"bus\": 18, \"addr\": \"60\" }, 1:{ \"bus\": 12, \"addr\": \"62\" }, } CPLD_I2C_PATH=\"/sys/bus/i2c/devices/{}-00{}/\" class Sfp(SfpOptoeBase): \"\"\"Platform-specific Sfp class\"\"\" PORT_START=1 PORT_END=58 PLATFORM_ROOT_PATH=\"/usr/share/sonic/device\" PMON_HWSKU_PATH=\"/usr/share/sonic/hwsku\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" PLATFORM=\"x86_64-accton_as7326_56x-r0\" HWSKU=\"Accton-AS7326-56X\" _port_to_i2c_mapping={ 1:[42], 2:[41], 3:[44], 4:[43], 5:[47], 6:[45], 7:[46], 8:[50], 9:[48], 10:[49], 11:[52], 12:[51], 13:[53], 14:[56], 15:[55], 16:[54], 17:[58], 18:[57], 19:[60], 20:[59], 21:[61], 22:[63], 23:[62], 24:[64], 25:[66], 26:[68], 27:[65], 28:[67], 29:[69], 30:[71], 31:[72], 32:[70], 33:[74], 34:[73], 35:[76], 36:[75], 37:[77], 38:[79], 39:[78], 40:[80], 41:[81], 42:[82], 43:[84], 44:[85], 45:[83], 46:[87], 47:[88], 48:[86], 49:[25], 50:[26], 51:[27], 52:[28], 53:[29], 54:[30], 55:[31], 56:[32], 57:[22], 58:[23] } def __init__(self, sfp_index=0): SfpOptoeBase.__init__(self) self.index=sfp_index self.port_num=self.index +1 cpld_idx=0 if self.port_num > 30 else 1 bus=CPLD_ADDR_MAPPING[cpld_idx][\"bus\"] addr=CPLD_ADDR_MAPPING[cpld_idx][\"addr\"] self.cpld_path=CPLD_I2C_PATH.format(bus, addr) eeprom_path='/sys/bus/i2c/devices/{0}-0050/eeprom' self.port_to_eeprom_mapping={} for x in range(self.PORT_START, self.PORT_END +1): self.port_to_eeprom_mapping[x]=eeprom_path.format( self._port_to_i2c_mapping[x][0]) def get_eeprom_path(self): return self.port_to_eeprom_mapping[self.port_num] def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: return fd.read().strip() except IOError: pass return \"\" def __write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except Exception: return False return True def __is_host(self): return os.system(self.HOST_CHK_CMD)==0 def __get_path_to_port_config_file(self): platform_path=\"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM]) hwsku_path=\"/\".join( [platform_path, self.HWSKU]) if self.__is_host() else self.PMON_HWSKU_PATH return \"/\".join([hwsku_path, \"port_config.ini\"]) def __read_eeprom_specific_bytes(self, offset, num_bytes): sysfsfile_eeprom=None eeprom_raw=[] for i in range(0, num_bytes): eeprom_raw.append(\"0x00\") sysfs_sfp_i2c_client_eeprom_path=self.port_to_eeprom_mapping[ self.port_num] try: sysfsfile_eeprom=open( sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0) sysfsfile_eeprom.seek(offset) raw=sysfsfile_eeprom.read(num_bytes) for n in range(0, num_bytes): if sys.version_info[0] >=3: eeprom_raw[n]=hex(raw[n])[2:].zfill(2) else: eeprom_raw[n]=hex(ord(raw[n]))[2:].zfill(2) except Exception: pass finally: if sysfsfile_eeprom: sysfsfile_eeprom.close() return eeprom_raw def get_reset_status(self): \"\"\" Retrieves the reset status of SFP Returns: A Boolean, True if reset enabled, False if disabled \"\"\" if self.port_num <=48 or self.port_num >=57: return False val=self.__read_txt_file( self.cpld_path +\"module_reset_\" +str(self.port_num)) return int(val, 10)==1 def get_rx_los(self): \"\"\" Retrieves the RX LOS(lost-of-signal) status of SFP Returns: A Boolean, True if SFP has RX LOS, False if not. Note: RX LOS status is latched until a call to get_rx_los or a reset. \"\"\" if self.port_num <=48 or self.port_num >=57: rx_los=self.__read_txt_file( self.cpld_path +\"module_rx_los_\" +str(self.port_num)) if int(rx_los, 10)==1: return[True] else: return[False] else: rx_los_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence( ) else None if dom_channel_monitor_raw is not None: rx_los_data=int(dom_channel_monitor_raw[0], 16) rx_los_list.append(rx_los_data & 0x01 !=0) rx_los_list.append(rx_los_data & 0x02 !=0) rx_los_list.append(rx_los_data & 0x04 !=0) rx_los_list.append(rx_los_data & 0x08 !=0) return rx_los_list else: return[False]*4 def get_tx_fault(self): \"\"\" Retrieves the TX fault status of SFP Returns: A list of boolean values, representing the TX fault status of each available channel, value is True if SFP channel has TX fault, False if not. E.g., for a tranceiver with four channels:[False, False, True, False] Note: TX fault status is lached until a call to get_tx_fault or a reset. \"\"\" tx_fault=False if self.port_num <=48 or self.port_num >=57: tx_fault=self.__read_txt_file( self.cpld_path +\"module_tx_fault_\" +str(self.port_num)) if int(tx_fault, 10)==1: return[True] else: return[False] else: tx_fault_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence( ) else None if dom_channel_monitor_raw is not None: tx_fault_data=int(dom_channel_monitor_raw[0], 16) tx_fault_list.append(tx_fault_data & 0x01 !=0) tx_fault_list.append(tx_fault_data & 0x02 !=0) tx_fault_list.append(tx_fault_data & 0x04 !=0) tx_fault_list.append(tx_fault_data & 0x08 !=0) return tx_fault_list else: return[False]*4 def get_tx_disable(self): \"\"\" Retrieves the tx_disable status of this SFP Returns: A list of boolean values, representing the TX disable status of each available channel, value is True if SFP channel is TX disabled, False if not. E.g., for a tranceiver with four channels:[False, False, True, False] \"\"\" if self.port_num <=48 or self.port_num >=57: tx_disable=False status_control_raw=self.__read_eeprom_specific_bytes( SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH) if status_control_raw: cpld_val=self.__read_txt_file( self.cpld_path +\"module_tx_disable_\" +str(self.port_num)) tx_disable_hard=(int(cpld_val, 10)==1) data=int(status_control_raw[0], 16) tx_disable_soft=(sffbase().test_bit( data, SFP_TX_DISABLE_SOFT_BIT) !=0) tx_disable=tx_disable_hard | tx_disable_soft if tx_disable==0: return[False] else: return[True] else: return[False] else: tx_disable_list=[] sfpd_obj=sff8436Dom() if sfpd_obj is None: return[False] dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes( dom_control_raw, 0) tx_disable_list.append( 'On'==dom_control_data['data']['TX1Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX2Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX3Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX4Disable']['value']) return tx_disable_list else: return[False]*4 def get_tx_disable_channel(self): \"\"\" Retrieves the TX disabled channels in this SFP Returns: A hex of 4 bits(bit 0 to bit 3 as channel 0 to channel 3) to represent TX channels which have been disabled in this SFP. As an example, a returned value of 0x5 indicates that channel 0 and channel 2 have been disabled. \"\"\" tx_disable_list=self.get_tx_disable() if tx_disable_list is None: return 0 tx_disabled=0 for i in range(len(tx_disable_list)): if tx_disable_list[i]: tx_disabled |=1 << i return tx_disabled def get_lpmode(self): \"\"\" Retrieves the lpmode(low power mode) status of this SFP Returns: A Boolean, True if lpmode is enabled, False if disabled \"\"\" if self.port_num <=48 or self.port_num >=57: return False power_set=self.get_power_set() power_override=self.get_power_override() return power_set and power_override def get_power_set(self): if self.port_num <=48 or self.port_num >=57: return False else: power_set=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes( dom_control_raw, 0) power_set=( 'On'==dom_control_data['data']['PowerSet']['value']) return power_set def get_power_override(self): \"\"\" Retrieves the power-override status of this SFP Returns: A Boolean, True if power-override is enabled, False if disabled \"\"\" if self.port_num <=48 or self.port_num >=57: return False else: power_override=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes( dom_control_raw, 0) power_override=( 'On'==dom_control_data['data']['PowerOverride']['value']) return power_override def reset(self): \"\"\" Reset SFP and return all user module settings to their default srate. Returns: A boolean, True if successful, False if not \"\"\" if self.port_num <=48 or self.port_num >=57: return False ret=self.__write_txt_file( self.cpld_path +\"module_reset_\" +str(self.port_num), 1) if ret is not True: return ret time.sleep(0.01) ret=self.__write_txt_file( self.cpld_path +\"module_reset_\" +str(self.port_num), 0) time.sleep(0.2) return ret def tx_disable(self, tx_disable): \"\"\" Disable SFP TX for all channels Args: tx_disable: A Boolean, True to enable tx_disable mode, False to disable tx_disable mode. Returns: A boolean, True if tx_disable is set successfully, False if not \"\"\" if self.port_num <=48 or self.port_num >=57: ret=self.__write_txt_file( self.cpld_path +\"module_tx_disable_\" +str(self.port_num), 1 if tx_disable else 0) time.sleep(0.01) return ret else: if not self.get_presence(): return False sysfsfile_eeprom=None try: tx_disable_ctl=0xf if tx_disable else 0x0 buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=tx_disable_ctl else: buffer[0]=chr(tx_disable_ctl) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def tx_disable_channel(self, channel, disable): \"\"\" Sets the tx_disable for specified SFP channels Args: channel: A hex of 4 bits(bit 0 to bit 3) which represent channel 0 to 3, e.g. 0x5 for channel 0 and channel 2. disable: A boolean, True to disable TX channels specified in channel, False to enable Returns: A boolean, True if successful, False if not \"\"\" if self.port_num <=48 or self.port_num >=57: return False else: if not self.get_presence(): return False sysfsfile_eeprom=None try: channel_state=self.get_tx_disable_channel() for i in range(4): channel_mask=(1 << i) if not(channel & channel_mask): continue if disable: channel_state |=channel_mask else: channel_state &=~channel_mask buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=channel_state else: buffer[0]=chr(channel_state) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def set_lpmode(self, lpmode): \"\"\" Sets the lpmode(low power mode) of SFP Args: lpmode: A Boolean, True to enable lpmode, False to disable it Note : lpmode can be overridden by set_power_override Returns: A boolean, True if lpmode is set successfully, False if not \"\"\" if self.port_num <=48 or self.port_num >=57: return False if lpmode: return self.set_power_override(True, True) else: return self.set_power_override(True, False) def set_power_override(self, power_override, power_set): \"\"\" Sets SFP power level using power_override and power_set Args: power_override: A Boolean, True to override set_lpmode and use power_set to control SFP power, False to disable SFP power control through power_override/power_set and use set_lpmode to control SFP power. power_set: Only valid when power_override is True. A Boolean, True to set SFP to low power mode, False to set SFP to high power mode. Returns: A boolean, True if power-override and power_set are set successfully, False if not \"\"\" if self.port_num <=48 or self.port_num >=57: return False else: if not self.get_presence(): return False try: power_override_bit=(1 << 0) if power_override else 0 power_set_bit=(1 << 1) if power_set else(1 << 3) buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=(power_override_bit | power_set_bit) else: buffer[0]=chr(power_override_bit | power_set_bit) with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd: fd.seek(QSFP_POWEROVERRIDE_OFFSET) fd.write(buffer[0]) time.sleep(0.01) except Exception: print(\"Error: unable to open file: %s\" % str(e)) return False return True def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" sfputil_helper=SfpUtilHelper() sfputil_helper.read_porttab_mappings( self.__get_path_to_port_config_file()) name=sfputil_helper.logical[self.index] or \"Unknown\" return name def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" val=self.__read_txt_file( self.cpld_path +\"module_present_\" +str(self.port_num)) return val=='1' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return self.get_presence() def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return self.port_num def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return True ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Sfp contains an implementation of SONiC Platform Base API and\n# provides the sfp device status which are available in the platform\n#\n#############################################################################\n\nimport os\nimport time\nimport sys\n\nfrom ctypes import create_string_buffer\n\ntry:\n    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase\n    from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    0: {\n        \"bus\": 18,\n        \"addr\": \"60\"\n    },  # port 31-56\n    1: {\n        \"bus\": 12,\n        \"addr\": \"62\"\n    },  # port  1-30\n}\nCPLD_I2C_PATH = \"/sys/bus/i2c/devices/{}-00{}/\"\n\nclass Sfp(SfpOptoeBase):\n    \"\"\"Platform-specific Sfp class\"\"\"\n\n    # Port number\n    PORT_START = 1\n    PORT_END = 58\n\n    # Path to sysfs\n    PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n    PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n\n    PLATFORM = \"x86_64-accton_as7326_56x-r0\"\n    HWSKU = \"Accton-AS7326-56X\"\n\n    _port_to_i2c_mapping = {\n        1: [42],\n        2: [41],\n        3: [44],\n        4: [43],\n        5: [47],\n        6: [45],\n        7: [46],\n        8: [50],\n        9: [48],\n        10: [49],\n        11: [52],\n        12: [51],\n        13: [53],\n        14: [56],\n        15: [55],\n        16: [54],\n        17: [58],\n        18: [57],\n        19: [60],\n        20: [59],\n        21: [61],\n        22: [63],\n        23: [62],\n        24: [64],\n        25: [66],\n        26: [68],\n        27: [65],\n        28: [67],\n        29: [69],\n        30: [71],\n        31: [72],\n        32: [70],\n        33: [74],\n        34: [73],\n        35: [76],\n        36: [75],\n        37: [77],\n        38: [79],\n        39: [78],\n        40: [80],\n        41: [81],\n        42: [82],\n        43: [84],\n        44: [85],\n        45: [83],\n        46: [87],\n        47: [88],\n        48: [86],\n        49: [25],\n        50: [26],\n        51: [27],\n        52: [28],\n        53: [29],\n        54: [30],\n        55: [31],\n        56: [32],\n        57: [22],\n        58: [23]\n    }\n\n    def __init__(self, sfp_index=0):\n        SfpOptoeBase.__init__(self)\n        # Init index\n        self.index = sfp_index\n        self.port_num = self.index + 1\n\n        cpld_idx = 0 if self.port_num > 30 else 1\n        bus = CPLD_ADDR_MAPPING[cpld_idx][\"bus\"]\n        addr = CPLD_ADDR_MAPPING[cpld_idx][\"addr\"]\n        self.cpld_path = CPLD_I2C_PATH.format(bus, addr)\n\n        # Init eeprom path\n        eeprom_path = '/sys/bus/i2c/devices/{0}-0050/eeprom'\n        self.port_to_eeprom_mapping = {}\n        for x in range(self.PORT_START, self.PORT_END + 1):\n            self.port_to_eeprom_mapping[x] = eeprom_path.format(\n                self._port_to_i2c_mapping[x][0])\n\n    def get_eeprom_path(self):\n        return self.port_to_eeprom_mapping[self.port_num]\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                return fd.read().strip()\n        except IOError:\n            pass\n        return \"\"\n\n    def __write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except Exception:\n            return False\n        return True\n\n    def __is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def __get_path_to_port_config_file(self):\n        platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n        hwsku_path = \"/\".join(\n            [platform_path,\n             self.HWSKU]) if self.__is_host() else self.PMON_HWSKU_PATH\n        return \"/\".join([hwsku_path, \"port_config.ini\"])\n\n    def __read_eeprom_specific_bytes(self, offset, num_bytes):\n        sysfsfile_eeprom = None\n        eeprom_raw = []\n        for i in range(0, num_bytes):\n            eeprom_raw.append(\"0x00\")\n\n        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[\n            self.port_num]\n        try:\n            sysfsfile_eeprom = open(\n                sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0)\n            sysfsfile_eeprom.seek(offset)\n            raw = sysfsfile_eeprom.read(num_bytes)\n            for n in range(0, num_bytes):\n                if sys.version_info[0] >= 3:\n                    eeprom_raw[n] = hex(raw[n])[2:].zfill(2)\n                else:\n                    eeprom_raw[n] = hex(ord(raw[n]))[2:].zfill(2)\n        except Exception:\n            pass\n        finally:\n            if sysfsfile_eeprom:\n                sysfsfile_eeprom.close()\n\n        return eeprom_raw\n\n    def get_reset_status(self):\n        \"\"\"\n        Retrieves the reset status of SFP\n        Returns:\n            A Boolean, True if reset enabled, False if disabled\n        \"\"\"\n        if self.port_num <= 48  or self.port_num >=57:\n            return False  # SPF port doesn't support this feature\n\n        val = self.__read_txt_file(\n            self.cpld_path + \"module_reset_\" + str(self.port_num))\n        return int(val, 10) == 1\n\n    def get_rx_los(self):\n        \"\"\"\n        Retrieves the RX LOS (lost-of-signal) status of SFP\n        Returns:\n            A Boolean, True if SFP has RX LOS, False if not.\n            Note : RX LOS status is latched until a call to get_rx_los or a reset.\n        \"\"\"\n        if self.port_num <= 48  or self.port_num >=57:\n            rx_los = self.__read_txt_file(\n                self.cpld_path + \"module_rx_los_\" + str(self.port_num))\n            if int(rx_los, 10) == 1:\n                return [True]\n            else:\n                return [False]\n            #status_control_raw = self.__read_eeprom_specific_bytes(\n            #    SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            #if status_control_raw:\n            #    data = int(status_control_raw[0], 16)\n            #    rx_los = (sffbase().test_bit(data, 1) != 0)\n        else:\n            rx_los_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_RX_LOS_STATUS_OFFSET,\n                QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence(\n                ) else None\n            if dom_channel_monitor_raw is not None:\n                rx_los_data = int(dom_channel_monitor_raw[0], 16)\n                rx_los_list.append(rx_los_data & 0x01 != 0)\n                rx_los_list.append(rx_los_data & 0x02 != 0)\n                rx_los_list.append(rx_los_data & 0x04 != 0)\n                rx_los_list.append(rx_los_data & 0x08 != 0)\n                return rx_los_list\n            else:\n                return [False]*4\n\n    def get_tx_fault(self):\n        \"\"\"\n        Retrieves the TX fault status of SFP\n        \n        Returns:\n            A list of boolean values, representing the TX fault status\n            of each available channel, value is True if SFP channel\n            has TX fault, False if not.\n            E.g., for a tranceiver with four channels: [False, False, True, False]\n            Note : TX fault status is lached until a call to get_tx_fault or a reset.\n        \"\"\"\n        tx_fault = False\n        if self.port_num <= 48  or self.port_num >=57:\n            tx_fault = self.__read_txt_file(\n                self.cpld_path + \"module_tx_fault_\" + str(self.port_num))\n            if int(tx_fault, 10) == 1:\n                return [True]\n            else:\n                return [False]\n            #status_control_raw = self.__read_eeprom_specific_bytes(\n            #    SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            #if status_control_raw:\n            #    data = int(status_control_raw[0], 16)\n            #    tx_fault = (sffbase().test_bit(data, 2) != 0)\n        else:\n            tx_fault_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_TX_FAULT_STATUS_OFFSET,\n                QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence(\n                ) else None\n            if dom_channel_monitor_raw is not None:\n                tx_fault_data = int(dom_channel_monitor_raw[0], 16)\n                tx_fault_list.append(tx_fault_data & 0x01 != 0)\n                tx_fault_list.append(tx_fault_data & 0x02 != 0)\n                tx_fault_list.append(tx_fault_data & 0x04 != 0)\n                tx_fault_list.append(tx_fault_data & 0x08 != 0)\n                return tx_fault_list\n            else:\n                return [False]*4\n\n\n    def get_tx_disable(self):\n        \"\"\"\n        Retrieves the tx_disable status of this SFP\n        Returns:\n            A list of boolean values, representing the TX disable status\n            of each available channel, value is True if SFP channel\n            is TX disabled, False if not.\n            E.g., for a tranceiver with four channels: [False, False, True, False]\n        \"\"\"\n        if self.port_num <= 48 or self.port_num >=57:\n            tx_disable = False\n\n            status_control_raw = self.__read_eeprom_specific_bytes(\n                SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            if status_control_raw:\n                cpld_val = self.__read_txt_file(\n                    self.cpld_path + \"module_tx_disable_\" + str(self.port_num))\n                tx_disable_hard = (int(cpld_val, 10) == 1)\n                data = int(status_control_raw[0], 16)\n                #tx_disable_hard = (sffbase().test_bit(\n                #    data, SFP_TX_DISABLE_HARD_BIT) != 0)\n                tx_disable_soft = (sffbase().test_bit(\n                    data, SFP_TX_DISABLE_SOFT_BIT) != 0)\n                tx_disable = tx_disable_hard | tx_disable_soft\n                if tx_disable==0:\n                    return [False]\n                else:\n                    return [True]\n                \n            else:\n                return [False]\n\n        else:\n            tx_disable_list = []\n\n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return [False]\n\n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET,\n                QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(\n                    dom_control_raw, 0)\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX1Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX2Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX3Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX4Disable']['value'])\n                return tx_disable_list\n            else:\n                return [False]*4\n\n    def get_tx_disable_channel(self):\n        \"\"\"\n        Retrieves the TX disabled channels in this SFP\n        Returns:\n            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent\n            TX channels which have been disabled in this SFP.\n            As an example, a returned value of 0x5 indicates that channel 0\n            and channel 2 have been disabled.\n        \"\"\"\n        tx_disable_list = self.get_tx_disable()\n        if tx_disable_list is None:\n            return 0\n        tx_disabled = 0\n        for i in range(len(tx_disable_list)):\n            if tx_disable_list[i]:\n                tx_disabled |= 1 << i\n        return tx_disabled\n\n    def get_lpmode(self):\n        \"\"\"\n        Retrieves the lpmode (low power mode) status of this SFP\n        Returns:\n            A Boolean, True if lpmode is enabled, False if disabled\n        \"\"\"\n        if self.port_num <= 48 or self.port_num >= 57:\n            # SFP doesn't support this feature\n            return False\n\n        power_set = self.get_power_set()\n        power_override = self.get_power_override()\n        return power_set and power_override\n\n    def get_power_set(self):\n\n        if self.port_num <= 48 or self.port_num >= 57:\n            # SFP doesn't support this feature\n            return False\n        else:\n            power_set = False\n\n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n\n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET,\n                QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(\n                    dom_control_raw, 0)\n                power_set = (\n                    'On' == dom_control_data['data']['PowerSet']['value'])\n\n            return power_set\n\n    def get_power_override(self):\n        \"\"\"\n        Retrieves the power-override status of this SFP\n        Returns:\n            A Boolean, True if power-override is enabled, False if disabled\n        \"\"\"\n        if self.port_num <= 48 or self.port_num >= 57:\n            return False  # SFP doesn't support this feature\n        else:\n            power_override = False\n\n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n\n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET,\n                QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(\n                    dom_control_raw, 0)\n                power_override = (\n                    'On' == dom_control_data['data']['PowerOverride']['value'])\n\n            return power_override\n\n    def reset(self):\n        \"\"\"\n        Reset SFP and return all user module settings to their default srate.\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        # Check for invalid port_num\n        if self.port_num <= 48  or self.port_num >=57:\n            return False  # SFP doesn't support this feature\n\n        ret = self.__write_txt_file(\n            self.cpld_path + \"module_reset_\" + str(self.port_num), 1)\n        if ret is not True:\n            return ret\n\n        time.sleep(0.01)\n        ret = self.__write_txt_file(\n            self.cpld_path + \"module_reset_\" + str(self.port_num), 0)\n        time.sleep(0.2)\n        return ret\n\n    def tx_disable(self, tx_disable):\n        \"\"\"\n        Disable SFP TX for all channels\n        Args:\n            tx_disable : A Boolean, True to enable tx_disable mode, False to disable\n                         tx_disable mode.\n        Returns:\n            A boolean, True if tx_disable is set successfully, False if not\n        \"\"\"\n        if self.port_num <= 48  or self.port_num >=57:\n            ret = self.__write_txt_file(\n                self.cpld_path + \"module_tx_disable_\" + str(self.port_num), 1\n                if tx_disable else 0)\n            time.sleep(0.01)\n            return ret\n        else:\n            if not self.get_presence():\n                return False\n\n            sysfsfile_eeprom = None\n            try:\n                tx_disable_ctl = 0xf if tx_disable else 0x0\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = tx_disable_ctl\n                else:\n                    buffer[0] = chr(tx_disable_ctl)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print(\"Error: unable to open file: %s\" % str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n        return True\n\n    def tx_disable_channel(self, channel, disable):\n        \"\"\"\n        Sets the tx_disable for specified SFP channels\n        Args:\n            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,\n                      e.g. 0x5 for channel 0 and channel 2.\n            disable : A boolean, True to disable TX channels specified in channel,\n                      False to enable\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n\n        if self.port_num <= 48  or self.port_num >=57:\n            return False  # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n\n            sysfsfile_eeprom = None\n            try:\n                channel_state = self.get_tx_disable_channel()\n\n                for i in range(4):\n                    channel_mask = (1 << i)\n                    if not (channel & channel_mask):\n                        continue\n\n                    if disable:\n                        channel_state |= channel_mask\n                    else:\n                        channel_state &= ~channel_mask\n\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = channel_state\n                else:\n                    buffer[0] = chr(channel_state)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print(\"Error: unable to open file: %s\" % str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n            return True\n\n    def set_lpmode(self, lpmode):\n        \"\"\"\n        Sets the lpmode (low power mode) of SFP\n        Args:\n            lpmode: A Boolean, True to enable lpmode, False to disable it\n            Note  : lpmode can be overridden by set_power_override\n        Returns:\n            A boolean, True if lpmode is set successfully, False if not\n        \"\"\"\n        if self.port_num <= 48  or self.port_num >=57:\n            return False  # SFP doesn't support this feature\n\n        if lpmode:\n            return self.set_power_override(True, True)\n        else:\n            return self.set_power_override(True, False)\n\n    def set_power_override(self, power_override, power_set):\n        \"\"\"\n        Sets SFP power level using power_override and power_set\n        Args:\n            power_override :\n                    A Boolean, True to override set_lpmode and use power_set\n                    to control SFP power, False to disable SFP power control\n                    through power_override/power_set and use set_lpmode\n                    to control SFP power.\n            power_set :\n                    Only valid when power_override is True.\n                    A Boolean, True to set SFP to low power mode, False to set\n                    SFP to high power mode.\n        Returns:\n            A boolean, True if power-override and power_set are set successfully,\n            False if not\n        \"\"\"\n        if self.port_num <= 48  or self.port_num >=57:\n            return False  # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n            try:\n                power_override_bit = (1 << 0) if power_override else 0\n                power_set_bit = (1 << 1) if power_set else (1 << 3)\n\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = (power_override_bit | power_set_bit)\n                else:\n                    buffer[0] = chr(power_override_bit | power_set_bit)\n                # Write to eeprom\n                with open(self.port_to_eeprom_mapping[self.port_num],\n                          \"r+b\") as fd:\n                    fd.seek(QSFP_POWEROVERRIDE_OFFSET)\n                    fd.write(buffer[0])\n                    time.sleep(0.01)\n            except Exception:\n                print(\"Error: unable to open file: %s\" % str(e))\n                return False\n            return True\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        sfputil_helper = SfpUtilHelper()\n        sfputil_helper.read_porttab_mappings(\n            self.__get_path_to_port_config_file())\n        name = sfputil_helper.logical[self.index] or \"Unknown\"\n        return name\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        val = self.__read_txt_file(\n            self.cpld_path + \"module_present_\" + str(self.port_num))\n        return val == '1'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return self.get_presence()\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return self.port_num\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return True\n"}, "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE = \"/sys/class/leds/as7816_64x_led::diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n     \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os import sys try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper from.event import SfpEvent except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=4 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=6 NUM_PORT=64 NUM_COMPONENT=5 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" SYSLED_FNODE=\"/sys/class/leds/as7816_64x_led::diag/brightness\" SYSLED_MODES={ \"0\": \"STATUS_LED_COLOR_OFF\", \"16\": \"STATUS_LED_COLOR_GREEN\", \"10\": \"STATUS_LED_COLOR_RED\" } class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(0, NUM_PORT): sfp=Sfp(index) self._sfp_list.append(sfp) self._sfpevent=SfpEvent(self._sfp_list) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for fant_index in range(NUM_FAN_TRAY): fandrawer=FanDrawer(fant_index) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._eeprom.get_product_name() def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_change_event(self, timeout=0): if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfpevent.get_sfp_event(timeout) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def initizalize_system_led(self): return True def get_status_led(self): val=self._api_helper.read_txt_file(SYSLED_FNODE) return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\" def set_status_led(self, color): mode=None for key, val in SYSLED_MODES.items(): if val==color: mode=key break if mode is None: return False else: return self._api_helper.write_txt_file(SYSLED_FNODE, mode) ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\nimport sys\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\n    from .event import SfpEvent\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 4\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 6\nNUM_PORT = 64\nNUM_COMPONENT = 5\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\nSYSLED_FNODE = \"/sys/class/leds/as7816_64x_led::diag/brightness\"\nSYSLED_MODES = {\n    \"0\" : \"STATUS_LED_COLOR_OFF\",\n    \"16\" : \"STATUS_LED_COLOR_GREEN\",\n    \"10\" : \"STATUS_LED_COLOR_RED\"\n\n}\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n        \n        self.config_data = {}\n\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n\n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(0, NUM_PORT):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self._sfpevent = SfpEvent(self._sfp_list)\n        self.sfp_module_initialized = True\n\n    def __initialize_fan(self):\n        from sonic_platform.fan_drawer import FanDrawer\n        for fant_index in range(NUM_FAN_TRAY):\n            fandrawer = FanDrawer(fant_index)\n            self._fan_drawer_list.append(fandrawer)\n            self._fan_list.extend(fandrawer._fan_list)\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n    \n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return self._eeprom.get_product_name()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n    \n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n    \n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n        \n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n      \n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n\n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_change_event(self, timeout=0):\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n        return self._sfpevent.get_sfp_event(timeout)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n        \n    def initizalize_system_led(self):\n        return True\n\n    def get_status_led(self):\n        val = self._api_helper.read_txt_file(SYSLED_FNODE)\n        return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\"\n\n    def set_status_led(self, color):\n        mode = None\n        for key, val in SYSLED_MODES.items():\n            if val == color:\n                mode = key\n                break\n        if mode is None:\n            return False\n        else:\n            return self._api_helper.write_txt_file(SYSLED_FNODE, mode)\n"}, "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 2, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware", "add": 0, "remove": 16, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"19-0060\", \"CPLD2\": \"20-0062\", \"CPLD3\": \"21-0064\", \"CPLD4\": \"22-0066\", } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"CPLD2\", \"CPLD 2\"), (\"CPLD3\", \"CPLD 3\"), (\"CPLD4\", \"CPLD 4\"), (\"BIOS\", \"Basic Input/Output System\") ] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return 'N/A' def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return 'N/A' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is'0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"19-0060\",\n    \"CPLD2\": \"20-0062\",\n    \"CPLD3\": \"21-0064\",\n    \"CPLD4\": \"22-0066\",\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"CPLD2\", \"CPLD 2\"),\n   (\"CPLD3\", \"CPLD 3\"),\n   (\"CPLD4\", \"CPLD 4\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n   \n]\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)\n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n        \n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of\n        entPhysicalContainedIn is'0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device\n            or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-      ", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False"], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r', errors='replace') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r', errors='replace') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as7816_64x-r0\"\n     HWSKU = \"Accton-AS7816-64X\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n         return self.port_to_eeprom_mapping[self.port_num]\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_RO", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}], "source": "\n import os import time import sys from ctypes import create_string_buffer try: from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_I2C_PATH=\"/sys/bus/i2c/devices/19-0060/\" class Sfp(SfpOptoeBase): \"\"\"Platform-specific Sfp class\"\"\" PORT_START=1 PORT_END=64 PLATFORM_ROOT_PATH=\"/usr/share/sonic/device\" PMON_HWSKU_PATH=\"/usr/share/sonic/hwsku\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" PLATFORM=\"x86_64-accton_as7816_64x-r0\" HWSKU=\"Accton-AS7816-64X\" _port_to_i2c_mapping={ 61: 25, 62: 26, 63: 27, 64: 28, 55: 29, 56: 30, 53: 31, 54: 32, 9: 33, 10: 34, 11: 35, 12: 36, 1: 37, 2: 38, 3: 39, 4: 40, 6: 41, 5: 42, 8: 43, 7: 44, 13: 45, 14: 46, 15: 47, 16: 48, 17: 49, 18: 50, 19: 51, 20: 52, 25: 53, 26: 54, 27: 55, 28: 56, 29: 57, 30: 58, 31: 59, 32: 60, 21: 61, 22: 62, 23: 63, 24: 64, 41: 65, 42: 66, 43: 67, 44: 68, 33: 69, 34: 70, 35: 71, 36: 72, 45: 73, 46: 74, 47: 75, 48: 76, 37: 77, 38: 78, 39: 79, 40: 80, 57: 81, 58: 82, 59: 83, 60: 84, 49: 85, 50: 86, 51: 87, 52: 88 } def __init__(self, sfp_index=0): SfpOptoeBase.__init__(self) self._api_helper=APIHelper() self.index=sfp_index self.port_num=self.index +1 eeprom_path='/sys/bus/i2c/devices/{0}-0050/eeprom' self.port_to_eeprom_mapping={} for x in range(self.PORT_START, self.PORT_END +1): self.port_to_eeprom_mapping[x]=eeprom_path.format(self._port_to_i2c_mapping[x]) def get_eeprom_path(self): return self.port_to_eeprom_mapping[self.port_num] def __is_host(self): return os.system(self.HOST_CHK_CMD)==0 def __get_path_to_port_config_file(self): platform_path=\"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM]) hwsku_path=\"/\".join([platform_path, self.HWSKU] ) if self.__is_host() else self.PMON_HWSKU_PATH return \"/\".join([hwsku_path, \"port_config.ini\"]) def __read_eeprom_specific_bytes(self, offset, num_bytes): sysfsfile_eeprom=None eeprom_raw=[] for i in range(0, num_bytes): eeprom_raw.append(\"0x00\") sysfs_sfp_i2c_client_eeprom_path=self.port_to_eeprom_mapping[self.port_num] try: sysfsfile_eeprom=open( sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0) sysfsfile_eeprom.seek(offset) raw=sysfsfile_eeprom.read(num_bytes) if sys.version_info[0] >=3: for n in range(0, num_bytes): eeprom_raw[n]=hex(raw[n])[2:].zfill(2) else: for n in range(0, num_bytes): eeprom_raw[n]=hex(ord(raw[n]))[2:].zfill(2) except Exception: pass finally: if sysfsfile_eeprom: sysfsfile_eeprom.close() return eeprom_raw def get_reset_status(self): \"\"\" Retrieves the reset status of SFP Returns: A Boolean, True if reset enabled, False if disabled \"\"\" reset_path=\"{}{}{}\".format(CPLD_I2C_PATH, \"module_reset_\", str(self.port_num)) val=self._api_helper.read_txt_file(reset_path) if val is not None: return int(val, 10)==1 else: return False def get_rx_los(self): \"\"\" Retrieves the RX LOS(lost-of-signal) status of SFP Returns: A Boolean, True if SFP has RX LOS, False if not. Note: RX LOS status is latched until a call to get_rx_los or a reset. \"\"\" rx_los_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: rx_los_data=int(dom_channel_monitor_raw[0], 16) rx_los_list.append(rx_los_data & 0x01 !=0) rx_los_list.append(rx_los_data & 0x02 !=0) rx_los_list.append(rx_los_data & 0x04 !=0) rx_los_list.append(rx_los_data & 0x08 !=0) return rx_los_list else: return[False]*4 def get_tx_fault(self): \"\"\" Retrieves the TX fault status of SFP Returns: A Boolean, True if SFP has TX fault, False if not Note: TX fault status is lached until a call to get_tx_fault or a reset. \"\"\" tx_fault_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: tx_fault_data=int(dom_channel_monitor_raw[0], 16) tx_fault_list.append(tx_fault_data & 0x01 !=0) tx_fault_list.append(tx_fault_data & 0x02 !=0) tx_fault_list.append(tx_fault_data & 0x04 !=0) tx_fault_list.append(tx_fault_data & 0x08 !=0) return tx_fault_list else: return[False]*4 def get_tx_disable(self): \"\"\" Retrieves the tx_disable status of this SFP Returns: A Boolean, True if tx_disable is enabled, False if disabled \"\"\" tx_disable_list=[] sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) tx_disable_list.append( 'On'==dom_control_data['data']['TX1Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX2Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX3Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX4Disable']['value']) return tx_disable_list else: return[False]*4 def get_tx_disable_channel(self): \"\"\" Retrieves the TX disabled channels in this SFP Returns: A hex of 4 bits(bit 0 to bit 3 as channel 0 to channel 3) to represent TX channels which have been disabled in this SFP. As an example, a returned value of 0x5 indicates that channel 0 and channel 2 have been disabled. \"\"\" tx_disable_list=self.get_tx_disable() if tx_disable_list is None: return 0 tx_disabled=0 for i in range(len(tx_disable_list)): if tx_disable_list[i]: tx_disabled |=1 << i return tx_disabled def get_lpmode(self): \"\"\" Retrieves the lpmode(low power mode) status of this SFP Returns: A Boolean, True if lpmode is enabled, False if disabled \"\"\" power_set=self.get_power_set() power_override=self.get_power_override() return power_set and power_override def get_power_set(self): power_set=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) power_set=( 'On'==dom_control_data['data']['PowerSet']['value']) return power_set def get_power_override(self): \"\"\" Retrieves the power-override status of this SFP Returns: A Boolean, True if power-override is enabled, False if disabled \"\"\" power_override=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) power_override=( 'On'==dom_control_data['data']['PowerOverride']['value']) return power_override def reset(self): \"\"\" Reset SFP and return all user module settings to their default srate. Returns: A boolean, True if successful, False if not \"\"\" reset_path=\"{}{}{}\".format(CPLD_I2C_PATH, 'module_reset_', self.port_num) ret=self._api_helper.write_txt_file(reset_path, 1) if ret is not True: return ret time.sleep(0.01) ret=self._api_helper.write_txt_file(reset_path, 0) time.sleep(0.2) return ret def tx_disable(self, tx_disable): \"\"\" Disable SFP TX for all channels Args: tx_disable: A Boolean, True to enable tx_disable mode, False to disable tx_disable mode. Returns: A boolean, True if tx_disable is set successfully, False if not \"\"\" if not self.get_presence(): return False sysfsfile_eeprom=None try: tx_disable_ctl=0xf if tx_disable else 0x0 buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=tx_disable_ctl else: buffer[0]=chr(tx_disable_ctl) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ',str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def tx_disable_channel(self, channel, disable): \"\"\" Sets the tx_disable for specified SFP channels Args: channel: A hex of 4 bits(bit 0 to bit 3) which represent channel 0 to 3, e.g. 0x5 for channel 0 and channel 2. disable: A boolean, True to disable TX channels specified in channel, False to enable Returns: A boolean, True if successful, False if not \"\"\" if not self.get_presence(): return False sysfsfile_eeprom=None try: channel_state=self.get_tx_disable_channel() for i in range(4): channel_mask=(1 << i) if not(channel & channel_mask): continue if disable: channel_state |=channel_mask else: channel_state &=~channel_mask buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=channel_state else: buffer[0]=chr(channel_state) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ', str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def set_lpmode(self, lpmode): \"\"\" Sets the lpmode(low power mode) of SFP Args: lpmode: A Boolean, True to enable lpmode, False to disable it Note : lpmode can be overridden by set_power_override Returns: A boolean, True if lpmode is set successfully, False if not \"\"\" if lpmode: self.set_power_override(True, True) else: self.set_power_override(False, False) return True def set_power_override(self, power_override, power_set): \"\"\" Sets SFP power level using power_override and power_set Args: power_override: A Boolean, True to override set_lpmode and use power_set to control SFP power, False to disable SFP power control through power_override/power_set and use set_lpmode to control SFP power. power_set: Only valid when power_override is True. A Boolean, True to set SFP to low power mode, False to set SFP to high power mode. Returns: A boolean, True if power-override and power_set are set successfully, False if not \"\"\" if not self.get_presence(): return False try: power_override_bit=(1 << 0) if power_override else 0 power_set_bit =(1 << 1) if power_set else(1 << 3) buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=(power_override_bit | power_set_bit) else: buffer[0]=chr(power_override_bit | power_set_bit) with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd: fd.seek(QSFP_POWEROVERRIDE_OFFSET) fd.write(buffer[0]) time.sleep(0.01) except Exception: print('Error: unable to open file: ', str(e)) return False return True def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" sfputil_helper=SfpUtilHelper() sfputil_helper.read_porttab_mappings( self.__get_path_to_port_config_file()) name=sfputil_helper.logical[self.index] or \"Unknown\" return name def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" present_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_present_', self.port_num) val=self._api_helper.read_txt_file(present_path) if val is not None: return int(val, 10)==1 else: return False def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return self.get_presence() def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return self.port_num def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return True ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Sfp contains an implementation of SONiC Platform Base API and\n# provides the sfp device status which are available in the platform\n#\n#############################################################################\n\nimport os\nimport time\nimport sys\n\nfrom ctypes import create_string_buffer\n\ntry:\n    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_I2C_PATH = \"/sys/bus/i2c/devices/19-0060/\"\n\n\nclass Sfp(SfpOptoeBase):\n    \"\"\"Platform-specific Sfp class\"\"\"\n\n    # Port number\n    PORT_START = 1\n    PORT_END = 64\n\n    # Path to sysfs\n    PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n    PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n        \n    PLATFORM = \"x86_64-accton_as7816_64x-r0\"\n    HWSKU = \"Accton-AS7816-64X\"\n\n    _port_to_i2c_mapping = {\n        61: 25,\n        62: 26,\n        63: 27,\n        64: 28,\n        55: 29,\n        56: 30,\n        53: 31,\n        54: 32,\n        9:  33,\n        10: 34,\n        11: 35,\n        12: 36,\n        1:  37,\n        2:  38,\n        3:  39,\n        4:  40,\n        6:  41,\n        5:  42,\n        8:  43,\n        7:  44,\n        13: 45,\n        14: 46,\n        15: 47,\n        16: 48,\n        17: 49,\n        18: 50,\n        19: 51,\n        20: 52,\n        25: 53,\n        26: 54,\n        27: 55,\n        28: 56,\n        29: 57,\n        30: 58,\n        31: 59,\n        32: 60,\n        21: 61,\n        22: 62,\n        23: 63,\n        24: 64,\n        41: 65,\n        42: 66,\n        43: 67,\n        44: 68,\n        33: 69,\n        34: 70,\n        35: 71,\n        36: 72,\n        45: 73,\n        46: 74,\n        47: 75,\n        48: 76,\n        37: 77,\n        38: 78,\n        39: 79,\n        40: 80,\n        57: 81,\n        58: 82,\n        59: 83,\n        60: 84,\n        49: 85,\n        50: 86,\n        51: 87,\n        52: 88 \n    }\n\n    def __init__(self, sfp_index=0):\n        SfpOptoeBase.__init__(self)\n        self._api_helper=APIHelper()\n        # Init index\n        self.index = sfp_index\n        self.port_num = self.index + 1\n        # Init eeprom path\n        eeprom_path = '/sys/bus/i2c/devices/{0}-0050/eeprom'\n        self.port_to_eeprom_mapping = {}\n        for x in range(self.PORT_START, self.PORT_END + 1):\n            self.port_to_eeprom_mapping[x] = eeprom_path.format(self._port_to_i2c_mapping[x])\n        \n    def get_eeprom_path(self):\n        return self.port_to_eeprom_mapping[self.port_num]\n\n    def __is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def __get_path_to_port_config_file(self):\n        platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n        hwsku_path = \"/\".join([platform_path, self.HWSKU]\n                              ) if self.__is_host() else self.PMON_HWSKU_PATH\n        return \"/\".join([hwsku_path, \"port_config.ini\"])\n\n    def __read_eeprom_specific_bytes(self, offset, num_bytes):\n        sysfsfile_eeprom = None\n        eeprom_raw = []\n        for i in range(0, num_bytes):\n            eeprom_raw.append(\"0x00\")\n\n        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]\n        try:\n            sysfsfile_eeprom = open(\n                sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0)\n            sysfsfile_eeprom.seek(offset)\n            raw = sysfsfile_eeprom.read(num_bytes)\n            if sys.version_info[0] >= 3:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(raw[n])[2:].zfill(2)\n            else:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(ord(raw[n]))[2:].zfill(2)\n        except Exception:\n            pass\n        finally:\n            if sysfsfile_eeprom:\n                sysfsfile_eeprom.close()\n\n        return eeprom_raw\n\n    def get_reset_status(self):\n        \"\"\"\n        Retrieves the reset status of SFP\n        Returns:\n            A Boolean, True if reset enabled, False if disabled\n        \"\"\"\n        reset_path=\"{}{}{}\".format(CPLD_I2C_PATH , \"module_reset_\" , str(self.port_num))\n        val = self._api_helper.read_txt_file(reset_path)\n        \n        if val is not None:\n            return int(val, 10) == 1\n        else:\n            return False\n\n    def get_rx_los(self):\n        \"\"\"\n        Retrieves the RX LOS (lost-of-signal) status of SFP\n        Returns:\n            A Boolean, True if SFP has RX LOS, False if not.\n            Note : RX LOS status is latched until a call to get_rx_los or a reset.\n        \"\"\"\n\n        rx_los_list = []\n        dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None\n        if dom_channel_monitor_raw is not None:\n                rx_los_data = int(dom_channel_monitor_raw[0], 16)\n                rx_los_list.append(rx_los_data & 0x01 != 0)\n                rx_los_list.append(rx_los_data & 0x02 != 0)\n                rx_los_list.append(rx_los_data & 0x04 != 0)\n                rx_los_list.append(rx_los_data & 0x08 != 0)\n                return rx_los_list\n        else:\n            return [False]*4\n\n\n    def get_tx_fault(self):\n        \"\"\"\n        Retrieves the TX fault status of SFP\n        Returns:\n            A Boolean, True if SFP has TX fault, False if not\n            Note : TX fault status is lached until a call to get_tx_fault or a reset.\n        \"\"\"\n        tx_fault_list = []\n        dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None\n        if dom_channel_monitor_raw is not None:\n            tx_fault_data = int(dom_channel_monitor_raw[0], 16)\n            tx_fault_list.append(tx_fault_data & 0x01 != 0)\n            tx_fault_list.append(tx_fault_data & 0x02 != 0)\n            tx_fault_list.append(tx_fault_data & 0x04 != 0)\n            tx_fault_list.append(tx_fault_data & 0x08 != 0)\n            return tx_fault_list\n        else:\n            return [False]*4\n\n    def get_tx_disable(self):\n        \"\"\"\n        Retrieves the tx_disable status of this SFP\n        Returns:\n            A Boolean, True if tx_disable is enabled, False if disabled\n        \"\"\"\n        \n        tx_disable_list = []\n    \n        sfpd_obj = sff8436Dom()\n        if sfpd_obj is None:\n            return False\n    \n        dom_control_raw = self.__read_eeprom_specific_bytes(\n            QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n        if dom_control_raw is not None:\n            dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n            tx_disable_list.append(\n                'On' == dom_control_data['data']['TX1Disable']['value'])\n            tx_disable_list.append(\n                'On' == dom_control_data['data']['TX2Disable']['value'])\n            tx_disable_list.append(\n                'On' == dom_control_data['data']['TX3Disable']['value'])\n            tx_disable_list.append(\n                'On' == dom_control_data['data']['TX4Disable']['value'])\n            return tx_disable_list\n        else:\n            return [False]*4\n\n    def get_tx_disable_channel(self):\n        \"\"\"\n        Retrieves the TX disabled channels in this SFP\n        Returns:\n            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent\n            TX channels which have been disabled in this SFP.\n            As an example, a returned value of 0x5 indicates that channel 0\n            and channel 2 have been disabled.\n        \"\"\"\n        tx_disable_list = self.get_tx_disable()\n        if tx_disable_list is None:\n            return 0\n        tx_disabled = 0\n        for i in range(len(tx_disable_list)):\n            if tx_disable_list[i]:\n                tx_disabled |= 1 << i\n        return tx_disabled\n\n    def get_lpmode(self):\n        \"\"\"\n        Retrieves the lpmode (low power mode) status of this SFP\n        Returns:\n            A Boolean, True if lpmode is enabled, False if disabled\n        \"\"\"\n\n        power_set=self.get_power_set()\n        power_override = self.get_power_override()\n        return power_set and power_override\n\n    def get_power_set(self):\n        power_set = False\n        sfpd_obj = sff8436Dom()\n        if sfpd_obj is None:\n            return False\n        dom_control_raw = self.__read_eeprom_specific_bytes(\n            QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n        if dom_control_raw is not None:\n            dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n            power_set = (\n                'On' == dom_control_data['data']['PowerSet']['value'])\n    \n        return power_set\n\n    def get_power_override(self):\n        \"\"\"\n        Retrieves the power-override status of this SFP\n        Returns:\n            A Boolean, True if power-override is enabled, False if disabled\n        \"\"\"\n        power_override = False\n        sfpd_obj = sff8436Dom()\n        if sfpd_obj is None:\n            return False\n\n        dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n        if dom_control_raw is not None:\n            dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n            power_override = (\n                'On' == dom_control_data['data']['PowerOverride']['value'])\n\n        return power_override\n\n    def reset(self):\n        \"\"\"\n        Reset SFP and return all user module settings to their default srate.\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        reset_path = \"{}{}{}\".format(CPLD_I2C_PATH , 'module_reset_' , self.port_num)\n        ret = self._api_helper.write_txt_file(reset_path, 1)\n        if ret is not True:\n            return ret\n\n        time.sleep(0.01)\n        ret = self._api_helper.write_txt_file(reset_path, 0)\n        time.sleep(0.2)\n\n        return ret\n\n    def tx_disable(self, tx_disable):\n        \"\"\"\n        Disable SFP TX for all channels\n        Args:\n            tx_disable : A Boolean, True to enable tx_disable mode, False to disable\n                         tx_disable mode.\n        Returns:\n            A boolean, True if tx_disable is set successfully, False if not\n        \"\"\"\n        if not self.get_presence():\n            return False\n        sysfsfile_eeprom = None\n        try:\n            tx_disable_ctl = 0xf if tx_disable else 0x0\n            buffer = create_string_buffer(1)\n            if sys.version_info[0] >= 3:\n                buffer[0] = tx_disable_ctl\n            else:\n                buffer[0] = chr(tx_disable_ctl)\n            # Write to eeprom\n            sysfsfile_eeprom = open(\n                self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n            sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n            sysfsfile_eeprom.write(buffer[0])\n        except IOError as e:\n            print ('Error: unable to open file: ',str(e))\n            return False\n        finally:\n            if sysfsfile_eeprom is not None:\n                sysfsfile_eeprom.close()\n                time.sleep(0.01)\n        \n        return True\n\n    def tx_disable_channel(self, channel, disable):\n        \"\"\"\n        Sets the tx_disable for specified SFP channels\n        Args:\n            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,\n                      e.g. 0x5 for channel 0 and channel 2.\n            disable : A boolean, True to disable TX channels specified in channel,\n                      False to enable\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"        \n        if not self.get_presence():\n            return False\n\n        sysfsfile_eeprom = None\n        try:\n            channel_state = self.get_tx_disable_channel()\n            for i in range(4):\n                channel_mask = (1 << i)\n                if not (channel & channel_mask):\n                    continue\n\n                if disable:\n                    channel_state |= channel_mask\n                else:\n                    channel_state &= ~channel_mask\n\n            buffer = create_string_buffer(1)\n            if sys.version_info[0] >= 3:\n                buffer[0] = channel_state\n            else:\n                buffer[0] = chr(channel_state)\n            # Write to eeprom\n            sysfsfile_eeprom = open(\n                self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n            sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n            sysfsfile_eeprom.write(buffer[0])\n        except IOError as e:\n            print ('Error: unable to open file: ', str(e))\n            return False\n        finally:\n            if sysfsfile_eeprom is not None:\n                sysfsfile_eeprom.close()\n                time.sleep(0.01)\n\n        return True\n\n    def set_lpmode(self, lpmode):\n        \"\"\"\n        Sets the lpmode (low power mode) of SFP\n        Args:\n            lpmode: A Boolean, True to enable lpmode, False to disable it\n            Note  : lpmode can be overridden by set_power_override\n        Returns:\n            A boolean, True if lpmode is set successfully, False if not\n        \"\"\"        \n        if lpmode:\n            self.set_power_override(True, True)\n        else:\n            self.set_power_override(False, False)\n    \n        return True\n       \n    def set_power_override(self, power_override, power_set):\n        \"\"\"\n        Sets SFP power level using power_override and power_set\n        Args:\n            power_override :\n                    A Boolean, True to override set_lpmode and use power_set\n                    to control SFP power, False to disable SFP power control\n                    through power_override/power_set and use set_lpmode\n                    to control SFP power.\n            power_set :\n                    Only valid when power_override is True.\n                    A Boolean, True to set SFP to low power mode, False to set\n                    SFP to high power mode.\n        Returns:\n            A boolean, True if power-override and power_set are set successfully,\n            False if not\n        \"\"\"\n       \n        if not self.get_presence():\n            return False\n        try:\n            power_override_bit = (1 << 0) if power_override else 0\n            power_set_bit      = (1 << 1) if power_set else (1 << 3)\n    \n            buffer = create_string_buffer(1)\n            if sys.version_info[0] >= 3:\n                buffer[0] = (power_override_bit | power_set_bit)\n            else:\n                buffer[0] = chr(power_override_bit | power_set_bit)\n            # Write to eeprom\n            with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd:\n                fd.seek(QSFP_POWEROVERRIDE_OFFSET)\n                fd.write(buffer[0])\n                time.sleep(0.01)\n        except Exception:\n            print ('Error: unable to open file: ', str(e))\n            return False\n\n        return True\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        sfputil_helper = SfpUtilHelper()\n        sfputil_helper.read_porttab_mappings(\n            self.__get_path_to_port_config_file())\n        name = sfputil_helper.logical[self.index] or \"Unknown\"\n        return name\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        present_path = \"{}{}{}\".format(CPLD_I2C_PATH , '/module_present_' , self.port_num)\n        val=self._api_helper.read_txt_file(present_path)\n        if val is not None:\n            return int(val, 10)==1\n        else:\n            return False\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return self.get_presence()\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return self.port_num\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return True\n"}, "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, ", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=6 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=3 NUM_QSFP=32 PORT_START=1 PORT_END=34 QSFP_PORT_START=0 QSFP_PORT_END=31 NUM_COMPONENT=2 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"docker > /dev/null 2>&1\" class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp self.QSFP_PORT_START=QSFP_PORT_START self.QSFP_PORT_END=QSFP_PORT_END for index in range(0, PORT_END): if index in range(self.QSFP_PORT_START, self.QSFP_PORT_END +1): sfp_module=Sfp(index, 'QSFP') else: sfp_module=Sfp(index, 'SFP') self._sfp_list.append(sfp_module) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan import Fan for fant_index in range(0, NUM_FAN_TRAY): for fan_index in range(0, NUM_FAN): fan=Fan(fant_index, fan_index) self._fan_list.append(fan) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._api_helper.hwsku def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_serial_number(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp ", "sourceWithComments": "#############################################################################\n# Accton\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 6\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 3\nNUM_QSFP = 32\nPORT_START = 1\nPORT_END = 34\nQSFP_PORT_START = 0\nQSFP_PORT_END = 31\nNUM_COMPONENT = 2\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n\n        self.config_data = {}\n\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n\n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n\n        self.QSFP_PORT_START = QSFP_PORT_START\n        self.QSFP_PORT_END = QSFP_PORT_END\n        for index in range(0, PORT_END):\n            if index in range(self.QSFP_PORT_START, self.QSFP_PORT_END + 1):\n                sfp_module = Sfp(index, 'QSFP')\n            else:\n                sfp_module = Sfp(index, 'SFP')\n            self._sfp_list.append(sfp_module)\n        self.sfp_module_initialized = True\n\n    def __initialize_fan(self):\n        from sonic_platform.fan import Fan\n        for fant_index in range(0, NUM_FAN_TRAY):\n            for fan_index in range(0, NUM_FAN):\n                fan = Fan(fant_index, fan_index)\n                self._fan_list.append(fan)\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n\n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n\n        return self._api_helper.hwsku\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_serial_number(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n\n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n"}, "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 3, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()        \n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firm", "add": 0, "remove": 16, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"3-0060\" } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"BIOS\", \"Basic Input/Output System\") ] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError ", "sourceWithComments": "#############################################################################\n# Accton\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"3-0060\"\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n\n]\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()        \n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)               \n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n\n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()           \n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n"}, "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-  ", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False"], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n class Sfp(SfpBase):\n     \"\"\"Platform-specific Sfp class\"\"\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n     PLATFORM = \"x86_64-accton_as9726_32d-r0\"\n     HWSKU = \"Accton-AS9726-32D\"\n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFOR", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}]}, "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py": {"changes": [{"diff": "\n #############################################################################\n \n try:\n-    import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py", "badparts": ["    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         if self.name == \"BIOS\":\n             fw_version = self.__get_bios_version()\n         elif \"CPLD\" in self.name:\n-            cmd = \"i2cget -f -y {0} {1} 0x1\".format(self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1])\n-            status, value = subprocess.getstatusoutput(cmd)\n+            cmd = [\"i2cget\", \"-f\", \"-y\", self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1], \"0x1\"]\n+            status, value = getstatusoutput_noshell(cmd)\n             if not status:\n                 ", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py", "badparts": ["            cmd = \"i2cget -f -y {0} {1} 0x1\".format(self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1])", "            status, value = subprocess.getstatusoutput(cmd)"], "goodparts": ["            cmd = [\"i2cget\", \"-f\", \"-y\", self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1], \"0x1\"]", "            status, value = getstatusoutput_noshell(cmd)"]}], "source": "\n try: import subprocess from sonic_platform_base.component_base import ComponentBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"BIOS\", \"Basic Input/Output System\") ] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" def __init__(self, component_index): self.index=component_index self.name=self.get_name() self.cpld_mapping={ 0:['3', '0x60'] } def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cmd=\"i2cget -f -y{0}{1} 0x1\".format(self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1]) status, value=subprocess.getstatusoutput(cmd) if not status: fw_version=value.rstrip() return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError ", "sourceWithComments": "#!/usr/bin/env python\n\n#############################################################################\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the component information (such as CPLD, FPGA, BIOS etc) which are available in the platform\n#\n#############################################################################\n\ntry:\n    import subprocess\n    from sonic_platform_base.component_base import ComponentBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\n#COMPONENT_NAME_LIST = [\"CPLD1\"]\nCOMPONENT_LIST =  [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n]\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n\n    def __init__(self, component_index):\n        self.index = component_index\n        self.name = self.get_name()\n        self.cpld_mapping = {\n                0: ['3', '0x60']                \n            }\n\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n    \n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n    \n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cmd = \"i2cget -f -y {0} {1} 0x1\".format(self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1])\n            status, value = subprocess.getstatusoutput(cmd)\n            if not status:\n                fw_version = value.rstrip()\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n"}, "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py": {"changes": [{"diff": "\n     import logging.config\n     import logging.handlers\n     import time\n-    import subprocess\n     from as4630_54pe.fanutil import FanUtil\n     from as4630_54pe.thermalutil import ThermalUtil\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py", "badparts": ["    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         if temp[0] >= 70000: #LM75-48    \n             #critical case*/\n             logging.critical('Alarm-Critical for temperature critical is detected, reset DUT')\n-            cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2);\n-            status, output = subprocess.getstatusoutput(cmd_str)\n+            status, output = getstatusoutput_noshell(cmd_str)\n                 \n         #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_state, fan_pol", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py", "badparts": ["            cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\"", "            status, output = subprocess.getstatusoutput(cmd_str)"], "goodparts": ["            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]", "            status, output = getstatusoutput_noshell(cmd_str)"]}], "source": "\n try: import getopt import sys import logging import logging.config import logging.handlers import time import subprocess from as4630_54pe.fanutil import FanUtil from as4630_54pe.thermalutil import ThermalUtil except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as4630_54pe_monitor' global log_file global log_level class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False fan_policy_state=0 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0, 0] temp_test_data=0 test_temp_revert=0 class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 for i in range(0, len(policy)): if(temp > policy[i][2]): if temp <=policy[i][3]: state=i return state def manage_fans(self): global fan_policy_state global fan_fail global test_temp global test_temp_list global alarm_state global temp_test_data global test_temp_revert LEVEL_FAN_MIN=0 LEVEL_FAN_NORMAL=1 LEVEL_FAN_MID=2 LEVEL_FAN_HIGH=3 LEVEL_TEMP_CRITICAL=4 fan_policy={ LEVEL_FAN_MIN: [50, 8, 0, 140000], LEVEL_FAN_NORMAL: [62, 10, 140000, 150000], LEVEL_FAN_MID: [75, 12, 150000, 160000], LEVEL_FAN_HIGH: [88, 14, 160000, 240000], LEVEL_TEMP_CRITICAL:[100, 16, 240000, 300000], } temp=[0, 0, 0] temp_fail=0 thermal=ThermalUtil() fan=FanUtil() ori_duty_cycle=fan.get_fan_duty_cycle() new_duty_cycle=0 if test_temp==0: for i in range(0,3): temp[i]=thermal._get_thermal_val(i+1) if temp[i]==0 or temp[i]==None: temp_fail=1 logging.warning(\"Get temp-%d fail\", i); return False else: if test_temp_revert==0: temp_test_data=temp_test_data+2000 else: temp_test_data=temp_test_data-2000 for i in range(0,3): temp[i]=test_temp_list[i]+temp_test_data fan_fail=0 temp_val=0 for i in range(0,3): if temp[i]==None: break temp_val+=temp[i] for i in range(fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1): if fan.get_fan_status(i)==0: new_pwm=100 logging.warning('Fan_%d fail, set pwm to 100',i) if test_temp==0: fan_fail=1 fan.set_fan_duty_cycle(new_pwm) break else: fan_fail=0 ori_state=fan_policy_state fan_policy_state=self.get_state_from_fan_policy(temp_val, fan_policy) if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN: logging.error(\"Get error fan current_state\\n\"); return 0 if fan_fail==0 and ori_duty_cycle!=fan_policy[fan_policy_state][0]: new_duty_cycle=fan_policy[fan_policy_state][0]; fan.set_fan_duty_cycle(new_duty_cycle) if temp[0] >=70000: logging.critical('Alarm-Critical for temperature critical is detected, reset DUT') cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\" time.sleep(2); status, output=subprocess.getstatusoutput(cmd_str) if ori_state < LEVEL_FAN_HIGH: if fan_policy_state >=LEVEL_FAN_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if fan_policy_state < LEVEL_FAN_MID: if alarm_state==1: logging.info('Alarm for temperature high is cleared') alarm_state=0 return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv,'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv)!=5: print(\"temp test, need input three temp\") return 0 i=0 for x in range(2, 5): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) fan=FanUtil() fan.set_fan_duty_cycle(50) print(\"set default fan speed to 50%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(10) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python\n# -*- coding: utf-8 -*\n# Copyright (c) 2019 Edgecore Networks Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n# THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR\n# CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT\n# LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS\n# FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.\n#\n# See the Apache Version 2.0 License for specific language governing\n# permissions and limitations under the License.\n# \n# HISTORY:\n#    mm/dd/yyyy (A.D.)#   \n#    10/24/2019:Jostar create for as4630_54pe thermal plan\n# ------------------------------------------------------------------\n\ntry:\n    import getopt\n    import sys\n    import logging\n    import logging.config\n    import logging.handlers\n    import time\n    import subprocess\n    from as4630_54pe.fanutil import FanUtil\n    from as4630_54pe.thermalutil import ThermalUtil\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as4630_54pe_monitor'\n\nglobal log_file\nglobal log_level\n\n \n\n\n\n# Temperature Policy\n# If any fan fail , please set fan speed register to 16\n# The max value of fan speed register is 14\n#  LM77(48)+LM75(4B)+LM75(4A)  >  140, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  >  150, Set 12\n#  LM77(48)+LM75(4B)+LM75(4A)  >  160, Set 14\n#  LM77(48)+LM75(4B)+LM75(4A)  <  140, Set 8\n#  LM77(48)+LM75(4B)+LM75(4A)  <  150, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  <  160, Set 12\n#  Reset DUT:LM77(48)>=70C\n#\nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n \n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n     \n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args: # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\nfan_policy_state=0\nfan_fail=0\nalarm_state = 0 #0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0, 0]\ntemp_test_data=0\ntest_temp_revert=0\n# Make a class we can use to capture stdout and sterr in the log\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm=0\n    ori_pwm = 0\n    default_pwm=0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format= '[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = handler = logging.handlers.SysLogHandler(address = '/dev/log')\n        sys_handler.setLevel(logging.WARNING)       \n        logging.getLogger('').addHandler(sys_handler)\n          \n    def get_state_from_fan_policy(self, temp, policy):\n        state=0\n        for i in range(0, len(policy)):\n            if (temp > policy[i][2]): #temp_down\n                if temp <= policy[i][3]: #temp_up\n                    state =i\n                            \n        return state\n\n    def manage_fans(self):\n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list        \n        global alarm_state\n        global temp_test_data  \n        global test_temp_revert      \n        LEVEL_FAN_MIN=0\n        LEVEL_FAN_NORMAL=1   \n        LEVEL_FAN_MID=2\n        LEVEL_FAN_HIGH=3\n        LEVEL_TEMP_CRITICAL=4\n        fan_policy = {\n           LEVEL_FAN_MIN:       [50,   8, 0,      140000],\n           LEVEL_FAN_NORMAL:    [62,  10, 140000, 150000],\n           LEVEL_FAN_MID:       [75,  12, 150000, 160000],\n           LEVEL_FAN_HIGH:      [88,  14, 160000, 240000],\n           LEVEL_TEMP_CRITICAL: [100, 16, 240000, 300000],\n        }\n        temp = [0, 0 , 0]\n        temp_fail=0\n        thermal = ThermalUtil()\n        fan = FanUtil()\n        ori_duty_cycle=fan.get_fan_duty_cycle()\n        new_duty_cycle=0\n        \n        if test_temp==0:\n            for i in range(0,3):\n                temp[i]=thermal._get_thermal_val(i+1)\n                if temp[i]==0 or temp[i]==None:\n                    temp_fail=1\n                    logging.warning(\"Get temp-%d fail\", i);\n                    return False\n        else:\n            if test_temp_revert==0:\n                temp_test_data=temp_test_data+2000\n            else:            \n                temp_test_data=temp_test_data-2000\n                \n            for i in range(0,3):\n                temp[i]=test_temp_list[i]+temp_test_data\n            fan_fail=0\n\n        temp_val=0 \n        for i in range(0,3):\n            if temp[i]==None:\n                break\n            temp_val+=temp[i]\n        \n        #Check Fan status\n        for i in range (fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1):\n            if fan.get_fan_status(i)==0:\n                new_pwm=100\n                logging.warning('Fan_%d fail, set pwm to 100',i)                \n                if test_temp==0:\n                    fan_fail=1\n                    fan.set_fan_duty_cycle(new_pwm)\n                    break\n            else:\n                fan_fail=0\n        \n        ori_state=fan_policy_state        \n        fan_policy_state=self.get_state_from_fan_policy(temp_val, fan_policy)\n        \n        if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN:\n            logging.error(\"Get error fan current_state\\n\");\n            return 0\n    \n        #Decision : Decide new fan pwm percent.\n        if fan_fail==0 and ori_duty_cycle!=fan_policy[fan_policy_state][0]:\n            new_duty_cycle = fan_policy[fan_policy_state][0];\n            fan.set_fan_duty_cycle(new_duty_cycle)\n\n        if temp[0] >= 70000: #LM75-48    \n            #critical case*/\n            logging.critical('Alarm-Critical for temperature critical is detected, reset DUT')\n            cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\"\n            time.sleep(2);\n            status, output = subprocess.getstatusoutput(cmd_str)\n                \n        #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_state, fan_policy_state, temp_val)\n        \n        if ori_state < LEVEL_FAN_HIGH:            \n           if fan_policy_state >= LEVEL_FAN_HIGH:\n               if alarm_state==0:\n                   logging.warning('Alarm for temperature high is detected')\n                   alarm_state=1\n                  \n        if fan_policy_state < LEVEL_FAN_MID:\n            if alarm_state==1:\n                logging.info('Alarm for temperature high is cleared')\n                alarm_state=0\n                \n        return True\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv,'hdlt:',['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg            \n        \n        if sys.argv[1]== '-t':\n            if len(sys.argv)!=5:\n                print(\"temp test, need input three temp\")\n                return 0\n            \n            i=0\n            for x in range(2, 5):\n               test_temp_list[i]= int(sys.argv[x])*1000\n               i=i+1\n            test_temp = 1   \n            log_level = logging.DEBUG\n            print(test_temp_list)                       \n    \n    fan = FanUtil()\n    fan.set_fan_duty_cycle(50)\n    print(\"set default fan speed to 50%\")\n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(10) #10sec\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n\n"}, "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py": {"changes": [{"diff": "\n             # Critical: Either all the fans are faulty or they are removed, shutdown the system\n             logging.critical('Alarm for all fan faulty/absent is detected')\n             logging.critical(\"Alarm for all fan faulty/absent is detected, reset DUT\")\n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2)\n-            subprocess.getstatusoutput('sync; sync; sync')\n-            subprocess.getstatusoutput(cmd_str)\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell(cmd_str)\n         elif sum(fan_fail_list) != 0:\n             # Set the 100% speed only for first fan failure detection\n             logging.warning('Fan_{} failed, set remaining fan speed to 100%'.format(\n", "add": 5, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py", "badparts": ["            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"", "            subprocess.getstatusoutput('sync; sync; sync')", "            subprocess.getstatusoutput(cmd_str)"], "goodparts": ["            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell(cmd_str)"]}, {"diff": "\n             as4630_54pe_set_fan_speed(new_duty_cycle)\n             if test_temp == 1:\n                 time.sleep(3)\n-                status, output = subprocess.getstatusoutput('pddf_fanutil getspeed')\n+                status, output = getstatusoutput_noshell(['pddf_fanutil', 'getspeed'])\n                 logging.debug('\\n%s\\n', output)\n \n         if temp[0] >= 70000:  # LM77-48\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py", "badparts": ["                status, output = subprocess.getstatusoutput('pddf_fanutil getspeed')"], "goodparts": ["                status, output = getstatusoutput_noshell(['pddf_fanutil', 'getspeed'])"]}, {"diff": "\n             if status:\n                 logging.warning('Reboot cause file not updated. {}'.format(output))\n \n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n-            subprocess.getstatusoutput('sync; sync; sync')\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n             time.sleep(3)\n-            subprocess.getstatusoutput(cmd_str)\n+            getstatusoutput_noshell(cmd_str)\n \n         logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n', ori_state", "add": 5, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py", "badparts": ["            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"", "            subprocess.getstatusoutput('sync; sync; sync')", "            subprocess.getstatusoutput(cmd_str)"], "goodparts": ["            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell(cmd_str)"]}], "source": "\n try: import os import sys import getopt import subprocess import logging import logging.handlers import time from sonic_platform import platform except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as4630_54pe_pddf_monitor' class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False def as4630_54pe_set_fan_speed(pwm): if pwm < 0 or pwm > 100: print(\"Error: Wrong duty cycle value %d\" %(pwm)) platform_chassis.get_fan(0).set_speed(pwm) platform_chassis.get_fan(2).set_speed(pwm) return 0 fan_policy_state=0 fan_fail=0 fan_fail_list=[0, 0, 0] alarm_state=0 test_temp=0 simulate_temp_decline=0 test_temp_list=[0, 0, 0] temp_test_data=0 test_temp_revert=0 platform_chassis=None class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(asctime)-15s %(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 for i in range(0, len(policy)): if(temp > policy[i][2]): if temp <=policy[i][3]: state=i return state def manage_fans(self): global fan_policy_state global fan_fail global fan_fail_list global test_temp global simulate_temp_decline global test_temp_list global alarm_state global temp_test_data global test_temp_revert global platform_chassis NUM_FANS=3 LEVEL_FAN_MIN=0 LEVEL_FAN_NORMAL=1 LEVEL_FAN_MID=2 LEVEL_FAN_HIGH=3 LEVEL_TEMP_CRITICAL=4 fan_policy={ LEVEL_FAN_MIN: [50, 8, 0, 140000], LEVEL_FAN_NORMAL: [62, 10, 140000, 150000], LEVEL_FAN_MID: [75, 12, 150000, 160000], LEVEL_FAN_HIGH: [88, 14, 160000, 240000], LEVEL_TEMP_CRITICAL:[100, 16, 240000, 300000], } temp=[0, 0, 0] ori_duty_cycle=platform_chassis.get_fan(0).get_speed() new_duty_cycle=0 if test_temp==0: for i in range(0, 3): temp[i]=platform_chassis.get_thermal(i).get_temperature() if temp[i]==0.0 or temp[i] is None: logging.warning(\"Get temp-%d fail\", i) return False temp[i]=int(temp[i]*1000) else: if test_temp_revert==0: temp_test_data=temp_test_data+2000 else: if temp_test_data > 0: temp_test_data=temp_test_data-2000 else: sys.exit('Simulation Ends !') for i in range(0, 3): temp[i]=test_temp_list[i]+temp_test_data fan_fail=0 temp_val=0 for i in range(0, 3): if temp[i] is None: break temp_val +=temp[i] for i in range(NUM_FANS): if not platform_chassis.get_fan(i).get_status(): if test_temp==0: fan_fail=1 if fan_fail_list[i]==0: fan_fail_list[i]=1 else: if fan_fail_list[i]==1: fan_fail_list[i]=0 if sum(fan_fail_list)==NUM_FANS: logging.critical('Alarm for all fan faulty/absent is detected') logging.critical(\"Alarm for all fan faulty/absent is detected, reset DUT\") cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\" time.sleep(2) subprocess.getstatusoutput('sync; sync; sync') subprocess.getstatusoutput(cmd_str) elif sum(fan_fail_list) !=0: logging.warning('Fan_{} failed, set remaining fan speed to 100%'.format( ' Fan_'.join(str(item+1) for item, val in enumerate(fan_fail_list) if val==1))) new_pwm=100 as4630_54pe_set_fan_speed(new_pwm) else: fan_fail=0 ori_state=fan_policy_state fan_policy_state=self.get_state_from_fan_policy(temp_val, fan_policy) if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN: logging.error(\"Get error fan current_state\\n\") return 0 if fan_fail==0 and ori_duty_cycle !=fan_policy[fan_policy_state][0]: new_duty_cycle=fan_policy[fan_policy_state][0] as4630_54pe_set_fan_speed(new_duty_cycle) if test_temp==1: time.sleep(3) status, output=subprocess.getstatusoutput('pddf_fanutil getspeed') logging.debug('\\n%s\\n', output) if temp[0] >=70000: logging.critical('Alarm for temperature critical is detected') logging.critical(\"Alarm-Critical for temperature critical is detected, reset DUT\") status, output=subprocess.getstatusoutput( 'echo \"Thermal Overload: Other\" > /host/reboot-cause/reboot-cause.txt') status, output=subprocess.getstatusoutput( 'echo \"System rebooted because alarm for critical temperature(70 C) is detected[Time: $(eval date)]\" >> /host/reboot-cause/reboot-cause.txt') if status: logging.warning('Reboot cause file not updated.{}'.format(output)) cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\" subprocess.getstatusoutput('sync; sync; sync') time.sleep(3) subprocess.getstatusoutput(cmd_str) logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n', ori_state, fan_policy_state, temp_val) if ori_state < LEVEL_FAN_HIGH: if fan_policy_state >=LEVEL_FAN_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if simulate_temp_decline==1: logging.info('Temperature decline simulation is ON. Testing temperature will decrease now') test_temp_revert=1 if fan_policy_state < LEVEL_FAN_MID: if alarm_state==1: logging.warning('Alarm for temperature high is cleared') alarm_state=0 return True def main(argv): if not os.path.exists('/usr/share/sonic/platform/pddf_support'): print(\"PDDF mode is not enabled\") return 0 log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp global simulate_temp_decline if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv, 'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv) !=6: print(\"temp test, need input temp decline option and three temp values\") return 0 i=0 simulate_temp_decline=int(sys.argv[2]) for x in range(3, 6): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) global platform_chassis platform_chassis=platform.Platform().get_chassis() as4630_54pe_set_fan_speed(50) monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(10) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*\n# Copyright (c) 2019 Edgecore Networks Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n# THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR\n# CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT\n# LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS\n# FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.\n#\n# See the Apache Version 2.0 License for specific language governing\n# permissions and limitations under the License.\n#\n# HISTORY:\n#    mm/dd/yyyy (A.D.)#\n#    10/24/2019:Jostar create for as4630_54pe thermal plan\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import sys\n    import getopt\n    import subprocess\n    import logging\n    import logging.handlers\n    import time\n    from sonic_platform import platform\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as4630_54pe_pddf_monitor'\n\n\n\n\n\n# Temperature Policy\n# If any fan fail , please set fan speed register to 16\n# The max value of fan speed register is 14\n#  LM77(48)+LM75(4B)+LM75(4A)  >  140, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  >  150, Set 12\n#  LM77(48)+LM75(4B)+LM75(4A)  >  160, Set 14\n#  LM77(48)+LM75(4B)+LM75(4A)  <  140, Set 8\n#  LM77(48)+LM75(4B)+LM75(4A)  <  150, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  <  160, Set 12\n#  Reset DUT:LM77(48)>=70C\n#\nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n\n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n\n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args:  # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\n\ndef as4630_54pe_set_fan_speed(pwm):\n    # This platform has 2 fans controlled by one register on CPLD and 3rd fan by another register\n    # Hence, we need to change the speed for all\n    if pwm < 0 or pwm > 100:\n        print(\"Error: Wrong duty cycle value %d\" % (pwm))\n    platform_chassis.get_fan(0).set_speed(pwm)\n    platform_chassis.get_fan(2).set_speed(pwm)\n   \n    return 0\n\n\nfan_policy_state = 0\nfan_fail = 0\nfan_fail_list = [0, 0, 0]\nalarm_state = 0  # 0->default or clear, 1-->alarm detect\ntest_temp = 0\nsimulate_temp_decline = 0\ntest_temp_list = [0, 0, 0]\ntemp_test_data = 0\ntest_temp_revert = 0\nplatform_chassis = None\n# Make a class we can use to capture stdout and sterr in the log\n\n\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm = 0\n    ori_pwm = 0\n    default_pwm = 0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format='[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(asctime)-15s %(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = logging.handlers.SysLogHandler(address='/dev/log')\n        sys_handler.setLevel(logging.WARNING)\n        logging.getLogger('').addHandler(sys_handler)\n\n    def get_state_from_fan_policy(self, temp, policy):\n        state = 0\n        for i in range(0, len(policy)):\n            if (temp > policy[i][2]):  # temp_down\n                if temp <= policy[i][3]:  # temp_up\n                    state = i\n\n        return state\n\n    def manage_fans(self):\n        global fan_policy_state\n        global fan_fail\n        global fan_fail_list\n        global test_temp\n        global simulate_temp_decline\n        global test_temp_list\n        global alarm_state\n        global temp_test_data\n        global test_temp_revert\n        global platform_chassis\n        NUM_FANS = 3\n        LEVEL_FAN_MIN = 0\n        LEVEL_FAN_NORMAL = 1\n        LEVEL_FAN_MID = 2\n        LEVEL_FAN_HIGH = 3\n        LEVEL_TEMP_CRITICAL = 4\n        fan_policy = {\n            LEVEL_FAN_MIN:       [50,   8, 0,      140000],\n            LEVEL_FAN_NORMAL:    [62,  10, 140000, 150000],\n            LEVEL_FAN_MID:       [75,  12, 150000, 160000],\n            LEVEL_FAN_HIGH:      [88,  14, 160000, 240000],\n            LEVEL_TEMP_CRITICAL: [100, 16, 240000, 300000],\n        }\n        temp = [0, 0, 0]\n        \n        #thermal = ThermalUtil()\n        #fan = FanUtil()\n        # Supposedly all the fans are set with same duty cycle\n        ori_duty_cycle = platform_chassis.get_fan(0).get_speed()\n        new_duty_cycle = 0\n\n        if test_temp == 0:\n            for i in range(0, 3):\n                temp[i] = platform_chassis.get_thermal(i).get_temperature()\n                if temp[i] == 0.0 or temp[i] is None:\n                    \n                    logging.warning(\"Get temp-%d fail\", i)\n                    return False\n                temp[i] = int(temp[i]*1000)\n        else:\n            if test_temp_revert == 0:\n                temp_test_data = temp_test_data+2000\n            else:\n                if temp_test_data > 0:\n                    temp_test_data = temp_test_data-2000\n                else:\n                    # Stop the simulation\n                    sys.exit('Simulation Ends !')\n\n            for i in range(0, 3):\n                temp[i] = test_temp_list[i]+temp_test_data\n            fan_fail = 0\n\n        temp_val = 0\n        for i in range(0, 3):\n            if temp[i] is None:\n                break\n            temp_val += temp[i]\n\n        # Check Fan status\n        for i in range(NUM_FANS):\n            if not platform_chassis.get_fan(i).get_status():\n                if test_temp == 0:\n                    fan_fail = 1\n                    if fan_fail_list[i] == 0:\n                        fan_fail_list[i] = 1\n            else:\n                if fan_fail_list[i] == 1:\n                    fan_fail_list[i] = 0\n\n        if sum(fan_fail_list) == NUM_FANS:\n            # Critical: Either all the fans are faulty or they are removed, shutdown the system\n            logging.critical('Alarm for all fan faulty/absent is detected')\n            logging.critical(\"Alarm for all fan faulty/absent is detected, reset DUT\")\n            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n            time.sleep(2)\n            subprocess.getstatusoutput('sync; sync; sync')\n            subprocess.getstatusoutput(cmd_str)\n        elif sum(fan_fail_list) != 0:\n            # Set the 100% speed only for first fan failure detection\n            logging.warning('Fan_{} failed, set remaining fan speed to 100%'.format(\n                ' Fan_'.join(str(item+1) for item, val in enumerate(fan_fail_list) if val == 1)))\n            new_pwm = 100\n            as4630_54pe_set_fan_speed(new_pwm)\n        else:\n            fan_fail = 0\n\n        ori_state = fan_policy_state\n        fan_policy_state = self.get_state_from_fan_policy(temp_val, fan_policy)\n\n        if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN:\n            logging.error(\"Get error fan current_state\\n\")\n            return 0\n\n        # Decision : Decide new fan pwm percent.\n        if fan_fail == 0 and ori_duty_cycle != fan_policy[fan_policy_state][0]:\n            new_duty_cycle = fan_policy[fan_policy_state][0]\n            as4630_54pe_set_fan_speed(new_duty_cycle)\n            if test_temp == 1:\n                time.sleep(3)\n                status, output = subprocess.getstatusoutput('pddf_fanutil getspeed')\n                logging.debug('\\n%s\\n', output)\n\n        if temp[0] >= 70000:  # LM77-48\n            # critical case*/\n            logging.critical('Alarm for temperature critical is detected')\n            logging.critical(\"Alarm-Critical for temperature critical is detected, reset DUT\")\n            # Update the reboot cause file to reflect that critical temperature\n            # has been crossed. Upon next boot, the contents of this file will\n            # be used to determine the cause of the previous reboot\n            status, output = subprocess.getstatusoutput(\n                'echo \"Thermal Overload: Other\" > /host/reboot-cause/reboot-cause.txt')\n            status, output = subprocess.getstatusoutput(\n                'echo \"System rebooted because alarm for critical temperature (70 C) is detected [Time: $(eval date)]\" >> /host/reboot-cause/reboot-cause.txt')\n            if status:\n                logging.warning('Reboot cause file not updated. {}'.format(output))\n\n            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n            subprocess.getstatusoutput('sync; sync; sync')\n            time.sleep(3)\n            subprocess.getstatusoutput(cmd_str)\n\n        logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n', ori_state, fan_policy_state, temp_val)\n\n        if ori_state < LEVEL_FAN_HIGH:\n            if fan_policy_state >= LEVEL_FAN_HIGH:\n                if alarm_state == 0:\n                    logging.warning('Alarm for temperature high is detected')\n                    alarm_state = 1\n                    # Add a mechanism to decrease the test_temp values\n                    if simulate_temp_decline == 1:\n                        logging.info('Temperature decline simulation is ON. Testing temperature will decrease now')\n                        test_temp_revert = 1\n\n        if fan_policy_state < LEVEL_FAN_MID:\n            if alarm_state == 1:\n                logging.warning('Alarm for temperature high is cleared')\n                alarm_state = 0\n\n        return True\n\n\ndef main(argv):\n    # Check if PDDF mode is enabled\n    if not os.path.exists('/usr/share/sonic/platform/pddf_support'):\n        print(\"PDDF mode is not enabled\")\n        return 0\n\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    global simulate_temp_decline\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv, 'hdlt:', ['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg\n\n        if sys.argv[1] == '-t':\n            if len(sys.argv) != 6:\n                print(\"temp test, need input temp decline option and three temp values\")\n                return 0\n\n            i = 0\n            simulate_temp_decline = int(sys.argv[2])\n            for x in range(3, 6):\n                test_temp_list[i] = int(sys.argv[x])*1000\n                i = i+1\n            test_temp = 1\n            log_level = logging.DEBUG\n            print(test_temp_list)\n\n    global platform_chassis\n    platform_chassis = platform.Platform().get_chassis()\n\n    as4630_54pe_set_fan_speed(50)\n    \n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(10)  # 10sec\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n"}, "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import commands\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"clean\"])\n     if status:\n-        print \"accton_as4630_54pe_util.py clean command failed %d\"%status\n+        print(\"accton_as4630_54pe_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Stop pddf-platform-init.service along with other platform serives failed %d\"%status\n+        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status\n+        print(\"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status)\n         return False\n \n     return True\n     \n def start_platform_svc():\n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"install\"])\n     if status:\n-        print \"accton_as4630_54pe_util.py install  command failed %d\"%status\n+        print(\"accton_as4630_54pe_util.py install  command failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n \n     return True\n \n def start_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Start pddf-platform-init.service failed %d\"%status\n+        print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n+        print(\"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status)\n         return False\n     \n     return True\n \n def stop_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Stop pddf-platform-init.service failed %d\"%status\n+        print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n+        print(\"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status)\n        ", "add": 41, "remove": 41, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py", "badparts": ["import commands", "    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-fan.service\")", "        print \"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-fan.service\")", "        print \"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-psu.service\")", "        print \"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-psu.service\")", "        print \"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor.service\")", "        print \"Disable as4630-54pe-platform-monitor.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor.service\")", "        print \"Stop as4630-54pe-platform-monitor.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py clean\")", "        print \"accton_as4630_54pe_util.py clean command failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")", "        print \"Stop pddf-platform-init.service along with other platform serives failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")", "        print \"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status", "    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py install\")", "        print \"accton_as4630_54pe_util.py install  command failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-fan.service\")", "        print \"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-fan.service\")", "        print \"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-psu.service\")", "        print \"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-psu.service\")", "        print \"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor.service\")", "        print \"Enable as4630-54pe-platform-monitor.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor.service\")", "        print \"Start as4630-54pe-platform-monitor.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")", "        print \"Start pddf-platform-init.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-pddf-platform-monitor.service\")", "        print \"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")", "        print \"Stop pddf-platform-init.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")", "        print \"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-fan.service\"])", "        print(\"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-fan.service\"])", "        print(\"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-psu.service\"])", "        print(\"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-psu.service\"])", "        print(\"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor.service\"])", "        print(\"Disable as4630-54pe-platform-monitor.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor.service\"])", "        print(\"Stop as4630-54pe-platform-monitor.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"clean\"])", "        print(\"accton_as4630_54pe_util.py clean command failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])", "        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])", "        print(\"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"install\"])", "        print(\"accton_as4630_54pe_util.py install  command failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-fan.service\"])", "        print(\"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-fan.service\"])", "        print(\"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-psu.service\"])", "        print(\"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-psu.service\"])", "        print(\"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor.service\"])", "        print(\"Enable as4630-54pe-platform-monitor.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor.service\"])", "        print(\"Start as4630-54pe-platform-monitor.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])", "        print(\"Start pddf-platform-init.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-pddf-platform-monitor.service\"])", "        print(\"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])", "        print(\"Stop pddf-platform-init.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])", "        print(\"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status)"]}], "source": "\n import commands def check_pddf_support(): return True def stop_platform_svc(): status, output=commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-fan.service\") if status: print \"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-fan.service\") if status: print \"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-psu.service\") if status: print \"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-psu.service\") if status: print \"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor.service\") if status: print \"Disable as4630-54pe-platform-monitor.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor.service\") if status: print \"Stop as4630-54pe-platform-monitor.service failed %d\"%status return False status, output=commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py clean\") if status: print \"accton_as4630_54pe_util.py clean command failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print \"Stop pddf-platform-init.service along with other platform serives failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\") if status: print \"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status return False return True def start_platform_svc(): status, output=commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py install\") if status: print \"accton_as4630_54pe_util.py install command failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-fan.service\") if status: print \"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-fan.service\") if status: print \"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-psu.service\") if status: print \"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-psu.service\") if status: print \"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor.service\") if status: print \"Enable as4630-54pe-platform-monitor.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor.service\") if status: print \"Start as4630-54pe-platform-monitor.service failed %d\"%status return False return True def start_platform_pddf(): status, output=commands.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print \"Start pddf-platform-init.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl start as4630-54pe-pddf-platform-monitor.service\") if status: print \"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status return False return True def stop_platform_pddf(): status, output=commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print \"Stop pddf-platform-init.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\") if status: print \"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status return False return True def main(): pass if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services. \n# This will be used while switching the pddf->non-pddf mode and vice versa\n\nimport commands\n\ndef check_pddf_support():\n    return True\n\ndef stop_platform_svc():\n    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-fan.service\")\n    if status:\n        print \"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-fan.service\")\n    if status:\n        print \"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status\n        return False\n\n    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-psu.service\")\n    if status:\n        print \"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-psu.service\")\n    if status:\n        print \"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status\n        return False\n    \n    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor.service\")\n    if status:\n        print \"Disable as4630-54pe-platform-monitor.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor.service\")\n    if status:\n        print \"Stop as4630-54pe-platform-monitor.service failed %d\"%status\n        return False\n\n    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py clean\")\n    if status:\n        print \"accton_as4630_54pe_util.py clean command failed %d\"%status\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print \"Stop pddf-platform-init.service along with other platform serives failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n    if status:\n        print \"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status\n        return False\n\n    return True\n    \ndef start_platform_svc():\n    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py install\")\n    if status:\n        print \"accton_as4630_54pe_util.py install  command failed %d\"%status\n        return False\n\n    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-fan.service\")\n    if status:\n        print \"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-fan.service\")\n    if status:\n        print \"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status\n        return False\n\n    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-psu.service\")\n    if status:\n        print \"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-psu.service\")\n    if status:\n        print \"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status\n        return False\n\n    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor.service\")\n    if status:\n        print \"Enable as4630-54pe-platform-monitor.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor.service\")\n    if status:\n        print \"Start as4630-54pe-platform-monitor.service failed %d\"%status\n        return False\n\n    return True\n\ndef start_platform_pddf():\n    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print \"Start pddf-platform-init.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-pddf-platform-monitor.service\")\n    if status:\n        print \"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n        return False\n    \n    return True\n\ndef stop_platform_pddf():\n    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print \"Stop pddf-platform-init.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n    if status:\n        print \"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n        return False\n\n    return True\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py": {"changes": [{"diff": "\n             # critical case*/\n             logging.critical(\n                 'Alarm-Critical for temperature critical is detected, reset DUT')\n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2)\n-            return_value = os.system(cmd_str)\n+            return_value = subprocess.call(cmd_str)\n             logging.warning('Fan set: i2cset -y -f 3 0x60 0x4 0xE4, status is %d', return_value)\n \n         #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_s", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py", "badparts": ["            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"", "            return_value = os.system(cmd_str)"], "goodparts": ["            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]", "            return_value = subprocess.call(cmd_str)"]}], "source": "\n try: import os import sys import getopt import logging import logging.config import logging.handlers import time from as4630_54te.fanutil import FanUtil from as4630_54te.thermalutil import ThermalUtil except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as4630_54te_monitor' class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False fan_policy_state=0 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0, 0] temp_test_data=0 test_temp_revert=0 class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S') if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter( '%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=logging.handlers.SysLogHandler( address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 for i in range(0, len(policy)): if(temp > policy[i][2]): if temp <=policy[i][3]: state=i return state def manage_fans(self): global fan_policy_state global fan_fail global test_temp global test_temp_list global alarm_state global temp_test_data global test_temp_revert LEVEL_FAN_MIN=0 LEVEL_FAN_NORMAL=1 LEVEL_FAN_MID=2 LEVEL_FAN_HIGH=3 LEVEL_TEMP_CRITICAL=4 fan_policy={ LEVEL_FAN_MIN:[50, 8, 0, 140000], LEVEL_FAN_NORMAL:[62, 10, 140000, 150000], LEVEL_FAN_MID:[75, 12, 150000, 160000], LEVEL_FAN_HIGH:[88, 14, 160000, 240000], LEVEL_TEMP_CRITICAL:[100, 16, 240000, 300000], } temp=[0, 0, 0] thermal=ThermalUtil() fan=FanUtil() ori_duty_cycle=fan.get_fan_duty_cycle() new_duty_cycle=0 if test_temp==0: for i in range(0, 3): temp[i]=thermal._get_thermal_val(i +1) if temp[i]==0 or temp[i] is None: logging.warning(\"Get temp-%d fail\", i) return False else: if test_temp_revert==0: temp_test_data=temp_test_data +2000 else: temp_test_data=temp_test_data -2000 for i in range(0, 3): temp[i]=test_temp_list[i] +temp_test_data fan_fail=0 temp_val=0 for i in range(0, 3): if temp[i] is None: break temp_val +=temp[i] for i in range(fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD +1): if fan.get_fan_status(i)==0: new_pwm=100 logging.warning('Fan_%d fail, set pwm to 100', i) if test_temp==0: fan_fail=1 fan.set_fan_duty_cycle(new_pwm) break else: fan_fail=0 ori_state=fan_policy_state fan_policy_state=self.get_state_from_fan_policy(temp_val, fan_policy) if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN: logging.error(\"Get error fan current_state\\n\") return 0 if fan_fail==0 and ori_duty_cycle !=fan_policy[fan_policy_state][0]: new_duty_cycle=fan_policy[fan_policy_state][0] fan.set_fan_duty_cycle(new_duty_cycle) if temp[0] >=70000: logging.critical( 'Alarm-Critical for temperature critical is detected, reset DUT') cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\" time.sleep(2) return_value=os.system(cmd_str) logging.warning('Fan set: i2cset -y -f 3 0x60 0x4 0xE4, status is %d', return_value) if ori_state < LEVEL_FAN_HIGH: if fan_policy_state >=LEVEL_FAN_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if fan_policy_state < LEVEL_FAN_MID: if alarm_state==1: logging.info('Alarm for temperature high is cleared') alarm_state=0 return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv, 'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv) !=5: print(\"temp test, need input three temp\") return 0 i=0 for x in range(2, 5): test_temp_list[i]=int(sys.argv[x]) * 1000 i=i +1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) fan=FanUtil() fan.set_fan_duty_cycle(50) print(\"set default fan speed to 50%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(10) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python\n# -*- coding: utf-8 -*\n# Copyright (c) 2019 Edgecore Networks Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n# THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR\n# CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT\n# LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS\n# FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.\n#\n# See the Apache Version 2.0 License for specific language governing\n# permissions and limitations under the License.\n#\n# HISTORY:\n#    mm/dd/yyyy (A.D.)#\n#    10/24/2019:Jostar create for as4630_54te thermal plan\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import sys\n    import getopt\n    import logging\n    import logging.config\n    import logging.handlers\n    import time\n    from as4630_54te.fanutil import FanUtil\n    from as4630_54te.thermalutil import ThermalUtil\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as4630_54te_monitor'\n\n# Temperature Policy\n# If any fan fail , please set fan speed register to 16\n# The max value of fan speed register is 14\n#  LM77(48)+LM75(4B)+LM75(4A)  >  140, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  >  150, Set 12\n#  LM77(48)+LM75(4B)+LM75(4A)  >  160, Set 14\n#  LM77(48)+LM75(4B)+LM75(4A)  <  140, Set 8\n#  LM77(48)+LM75(4B)+LM75(4A)  <  150, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  <  160, Set 12\n#  Reset DUT:LM77(48)>=70C\n#\nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n\n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n\n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args:  # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\n\nfan_policy_state = 0\nfan_fail = 0\nalarm_state = 0  # 0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0, 0]\ntemp_test_data = 0\ntest_temp_revert = 0\n# Make a class we can use to capture stdout and sterr in the log\n\n\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm = 0\n    ori_pwm = 0\n    default_pwm = 0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format='[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S')\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter(\n                '%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = logging.handlers.SysLogHandler(\n            address='/dev/log')\n        sys_handler.setLevel(logging.WARNING)\n        logging.getLogger('').addHandler(sys_handler)\n\n    def get_state_from_fan_policy(self, temp, policy):\n        state = 0\n        for i in range(0, len(policy)):\n            if (temp > policy[i][2]):  # temp_down\n                if temp <= policy[i][3]:  # temp_up\n                    state = i\n\n        return state\n\n    def manage_fans(self):\n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list\n        global alarm_state\n        global temp_test_data\n        global test_temp_revert\n        LEVEL_FAN_MIN = 0\n        LEVEL_FAN_NORMAL = 1\n        LEVEL_FAN_MID = 2\n        LEVEL_FAN_HIGH = 3\n        LEVEL_TEMP_CRITICAL = 4\n        fan_policy = {\n            LEVEL_FAN_MIN: [50, 8, 0, 140000],\n            LEVEL_FAN_NORMAL: [62, 10, 140000, 150000],\n            LEVEL_FAN_MID: [75, 12, 150000, 160000],\n            LEVEL_FAN_HIGH: [88, 14, 160000, 240000],\n            LEVEL_TEMP_CRITICAL: [100, 16, 240000, 300000],\n        }\n        temp = [0, 0, 0]\n        thermal = ThermalUtil()\n        fan = FanUtil()\n        ori_duty_cycle = fan.get_fan_duty_cycle()\n        new_duty_cycle = 0\n\n        if test_temp == 0:\n            for i in range(0, 3):\n                temp[i] = thermal._get_thermal_val(i + 1)\n                if temp[i] == 0 or temp[i] is None:\n                    logging.warning(\"Get temp-%d fail\", i)\n                    return False\n        else:\n            if test_temp_revert == 0:\n                temp_test_data = temp_test_data + 2000\n            else:\n                temp_test_data = temp_test_data - 2000\n\n            for i in range(0, 3):\n                temp[i] = test_temp_list[i] + temp_test_data\n            fan_fail = 0\n\n        temp_val = 0\n        for i in range(0, 3):\n            if temp[i] is None:\n                break\n            temp_val += temp[i]\n\n        # Check Fan status\n        for i in range(fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD + 1):\n            if fan.get_fan_status(i) == 0:\n                new_pwm = 100\n                logging.warning('Fan_%d fail, set pwm to 100', i)\n                if test_temp == 0:\n                    fan_fail = 1\n                    fan.set_fan_duty_cycle(new_pwm)\n                    break\n            else:\n                fan_fail = 0\n\n        ori_state = fan_policy_state\n        fan_policy_state = self.get_state_from_fan_policy(temp_val, fan_policy)\n\n        if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN:\n            logging.error(\"Get error fan current_state\\n\")\n            return 0\n\n        # Decision : Decide new fan pwm percent.\n        if fan_fail == 0 and ori_duty_cycle != fan_policy[fan_policy_state][0]:\n            new_duty_cycle = fan_policy[fan_policy_state][0]\n            fan.set_fan_duty_cycle(new_duty_cycle)\n\n        if temp[0] >= 70000:  # LM75-48\n            # critical case*/\n            logging.critical(\n                'Alarm-Critical for temperature critical is detected, reset DUT')\n            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n            time.sleep(2)\n            return_value = os.system(cmd_str)\n            logging.warning('Fan set: i2cset -y -f 3 0x60 0x4 0xE4, status is %d', return_value)\n\n        #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_state, fan_policy_state, temp_val)\n\n        if ori_state < LEVEL_FAN_HIGH:\n            if fan_policy_state >= LEVEL_FAN_HIGH:\n                if alarm_state == 0:\n                    logging.warning('Alarm for temperature high is detected')\n                    alarm_state = 1\n\n        if fan_policy_state < LEVEL_FAN_MID:\n            if alarm_state == 1:\n                logging.info('Alarm for temperature high is cleared')\n                alarm_state = 0\n\n        return True\n\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv, 'hdlt:', ['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg\n\n        if sys.argv[1] == '-t':\n            if len(sys.argv) != 5:\n                print(\"temp test, need input three temp\")\n                return 0\n\n            i = 0\n            for x in range(2, 5):\n                test_temp_list[i] = int(sys.argv[x]) * 1000\n                i = i + 1\n            test_temp = 1\n            log_level = logging.DEBUG\n            print(test_temp_list)\n\n    fan = FanUtil()\n    fan.set_fan_duty_cycle(50)\n    print(\"set default fan speed to 50%\")\n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(10)  # 10sec\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py": {"changes": [{"diff": "\n # ------------------------------------------------------------------\n \n try:\n-    import time\n     import logging\n-    from collections import namedtuple\n-    import subprocess\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n", "add": 1, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py", "badparts": ["    import time", "    from collections import namedtuple", "    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         return \"fan{0}_{1}\".format(fan_num, self.node_postfix[node_num-1])\n     \n     def _get_fan_i2c_bus_addr(self):\n-        cmd_template = 'i2cget -f -y {} 0x{} 0'\n+        cmd_template = ['i2cget', '-f', '-y', '', '', '0']\n         for bus_no, dev_addr in self.I2CADDR_CANDIDATES:\n-            cmd = cmd_template.format(bus_no, dev_addr)\n-            if subprocess.getstatusoutput(cmd)[0] == 0:\n+            cmd_template[3] = str(bus_no)\n+            cmd_template[4] = '0x' + str(dev_addr)\n+            if getstatusoutput_noshell(cmd_template)[0] == 0:\n                 return bus_no, dev_addr\n         raise IOError('Un", "add": 4, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py", "badparts": ["        cmd_template = 'i2cget -f -y {} 0x{} 0'", "            cmd = cmd_template.format(bus_no, dev_addr)", "            if subprocess.getstatusoutput(cmd)[0] == 0:"], "goodparts": ["        cmd_template = ['i2cget', '-f', '-y', '', '', '0']", "            cmd_template[3] = str(bus_no)", "            cmd_template[4] = '0x' + str(dev_addr)", "            if getstatusoutput_noshell(cmd_template)[0] == 0:"]}], "source": "\n try: import time import logging from collections import namedtuple import subprocess except ImportError as e: raise ImportError('%s -required module not found' % str(e)) class FanUtil(object): \"\"\"Platform-specific FanUtil class\"\"\" FAN_TOTAL_NUM=5 FAN_NUM_1_IDX=1 FAN_NODE_NUM=2 FAN_FAULT_IDX=1 FAN_DIR_IDX=2 I2CADDR_CANDIDATES=((9, 66), (50, 66)) PATH_PREFIX='/sys/bus/i2c/devices/{}-00{}/' BASE_VAL_PATH='{0}' FAN_DUTY_PATH='fan{0}_pwm' \"\"\" Dictionary where key1=fan id index(integer) starting from 1 key2=fan node index(interger) starting from 1 value=path to fan device file(string) \"\"\" dev_paths={} node_postfix=[\"fault\", \"direction\"] def _get_fan_to_device_node(self, fan_num, node_num): return \"fan{0}_{1}\".format(fan_num, self.node_postfix[node_num-1]) def _get_fan_i2c_bus_addr(self): cmd_template='i2cget -f -y{} 0x{} 0' for bus_no, dev_addr in self.I2CADDR_CANDIDATES: cmd=cmd_template.format(bus_no, dev_addr) if subprocess.getstatusoutput(cmd)[0]==0: return bus_no, dev_addr raise IOError('Unable to reach fan CPLD via I2C') def _init_fnode_basepath(self): '''format BASE_VAL_PATH and FAN_DUTY_PATH ''' bus, addr=self._get_fan_i2c_bus_addr() self.PATH_PREFIX=self.PATH_PREFIX.format(bus, addr) self.BASE_VAL_PATH=self.PATH_PREFIX +self.BASE_VAL_PATH self.FAN_DUTY_PATH=self.PATH_PREFIX +self.FAN_DUTY_PATH def _get_fan_node_val(self, fan_num, node_num): if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM: self.logger.debug('GET. Parameter error. fan_num:%d', fan_num) return None if node_num < self.FAN_FAULT_IDX or node_num > self.FAN_NODE_NUM: self.logger.debug('GET. Parameter error. node_num:%d', node_num) return None device_path=self.get_fan_to_device_path(fan_num, node_num) try: val_file=open(device_path, 'r') except IOError as e: self.logger.error('GET. unable to open file: %s', str(e)) return None content=val_file.readline().rstrip() if content=='': self.logger.debug('GET. content is NULL. device_path:%s', device_path) return None try: val_file.close() except: self.logger.debug('GET. unable to close file. device_path:%s', device_path) return None return int(content) def _set_fan_node_val(self, fan_num, node_num, val): if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM: self.logger.debug('GET. Parameter error. fan_num:%d', fan_num) return None if node_num < self.FAN_FAULT_IDX or node_num > self.FAN_NODE_NUM: self.logger.debug('GET. Parameter error. node_num:%d', node_num) return None content=str(val) if content=='': self.logger.debug('GET. content is NULL. device_path:%s', device_path) return None device_path=self.get_fan_to_device_path(fan_num, node_num) try: val_file=open(device_path, 'w') except IOError as e: self.logger.error('GET. unable to open file: %s', str(e)) return None val_file.write(content) try: val_file.close() except: self.logger.debug('GET. unable to close file. device_path:%s', device_path) return None return True logger=logging.getLogger(__name__) def __init__(self, log_level=logging.DEBUG): ch=logging.StreamHandler() ch.setLevel(log_level) self.logger.addHandler(ch) self._init_fnode_basepath() fan_path=self.BASE_VAL_PATH for fan_num in range(self.FAN_NUM_1_IDX, self.FAN_TOTAL_NUM+1): for node_num in range(1, self.FAN_NODE_NUM+1): node=self._get_fan_to_device_node(fan_num, node_num) self.dev_paths[(fan_num, node_num)]=fan_path.format(node) def get_num_fans(self): return self.FAN_TOTAL_NUM def get_idx_fan_start(self): return self.FAN_NUM_1_IDX def get_num_nodes(self): return self.FAN_NODE_NUM def get_idx_node_start(self): return self.FAN_FAULT_IDX def get_size_node_map(self): return len(self.dev_paths) def get_size_path_map(self): return len(self.dev_paths) def get_fan_to_device_path(self, fan_num, node_num): return self.dev_paths[(fan_num, node_num)] def get_fan_fault(self, fan_num): return self._get_fan_node_val(fan_num, self.FAN_FAULT_IDX) def get_fan_dir(self, fan_num): return self._get_fan_node_val(fan_num, self.FAN_DIR_IDX) def get_fan_duty_cycle(self): try: val_file=open(self.FAN_DUTY_PATH.format(1)) except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False content=val_file.readline().rstrip() val_file.close() return int(content) def set_fan_duty_cycle(self, val): for fan_num in range(1, self.FAN_TOTAL_NUM+1): try: fan_file=open(self.FAN_DUTY_PATH.format(fan_num), 'r+') except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False fan_file.write(str(val)) fan_file.close() return True def get_fan_status(self, fan_num): if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM: self.logger.debug('GET. Parameter error. fan_num, %d', fan_num) return None if self.get_fan_fault(fan_num) is not None and self.get_fan_fault(fan_num) > 0: self.logger.debug('GET. FAN fault. fan_num, %d', fan_num) return False return True ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2017 Accton Technology Corporation\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    mm/dd/yyyy (A.D.)\n#    11/13/2017: Polly Hsu, Create\n#    1/10/2018: Jostar modify for as7716_32\n#    5/02/2019: Roy Lee modify for as7816_64x\n# ------------------------------------------------------------------\n\ntry:\n    import time\n    import logging\n    from collections import namedtuple\n    import subprocess\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n\nclass FanUtil(object):\n    \"\"\"Platform-specific FanUtil class\"\"\"\n\n    FAN_TOTAL_NUM = 5\n    FAN_NUM_1_IDX = 1\n\n    FAN_NODE_NUM = 2\n    FAN_FAULT_IDX = 1\n    #FAN_SPEED_IDX = 2\n    FAN_DIR_IDX = 2\n    #FAN_NODE_DUTY_IDX_OF_MAP = 4\n    #FANR_NODE_FAULT_IDX_OF_MAP = 5\n\n    I2CADDR_CANDIDATES = ((9, 66), # for R0C HW and later\n                         (50, 66)) # for R0A, R0B HW\n    PATH_PREFIX = '/sys/bus/i2c/devices/{}-00{}/'\n    BASE_VAL_PATH = '{0}'\n    FAN_DUTY_PATH = 'fan{0}_pwm'\n\n    #logfile = ''\n    #loglevel = self.logger.INFO\n\n    \"\"\" Dictionary where\n        key1 = fan id index (integer) starting from 1\n        key2 = fan node index (interger) starting from 1\n        value = path to fan device file (string) \"\"\"\n    dev_paths = {}\n    \n    node_postfix = [\"fault\", \"direction\"]\n    def _get_fan_to_device_node(self, fan_num, node_num):\n        return \"fan{0}_{1}\".format(fan_num, self.node_postfix[node_num-1])\n    \n    def _get_fan_i2c_bus_addr(self):\n        cmd_template = 'i2cget -f -y {} 0x{} 0'\n        for bus_no, dev_addr in self.I2CADDR_CANDIDATES:\n            cmd = cmd_template.format(bus_no, dev_addr)\n            if subprocess.getstatusoutput(cmd)[0] == 0:\n                return bus_no, dev_addr\n        raise IOError('Unable to reach fan CPLD via I2C')\n\n    def _init_fnode_basepath(self):\n        '''format BASE_VAL_PATH and FAN_DUTY_PATH '''\n        bus, addr = self._get_fan_i2c_bus_addr()\n        self.PATH_PREFIX = self.PATH_PREFIX.format(bus, addr)\n        self.BASE_VAL_PATH = self.PATH_PREFIX + self.BASE_VAL_PATH\n        self.FAN_DUTY_PATH = self.PATH_PREFIX + self.FAN_DUTY_PATH\n\n    def _get_fan_node_val(self, fan_num, node_num):\n        if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM:\n            self.logger.debug('GET. Parameter error. fan_num:%d', fan_num)\n            return None\n\n        if node_num < self.FAN_FAULT_IDX or node_num > self.FAN_NODE_NUM:\n            self.logger.debug('GET. Parameter error. node_num:%d', node_num)\n            return None\n\n        device_path = self.get_fan_to_device_path(fan_num, node_num)\n       \n        try:\n            val_file = open(device_path, 'r')\n        except IOError as e:\n            self.logger.error('GET. unable to open file: %s', str(e))\n            return None\n\n        content = val_file.readline().rstrip()\n        \n        if content == '':\n            self.logger.debug('GET. content is NULL. device_path:%s', device_path)\n            return None\n\n        try:\n            val_file.close()\n        except:\n            self.logger.debug('GET. unable to close file. device_path:%s', device_path)\n            return None\n\n        return int(content)\n\n    def _set_fan_node_val(self, fan_num, node_num, val):\n        if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM:\n            self.logger.debug('GET. Parameter error. fan_num:%d', fan_num)\n            return None\n\n        if node_num < self.FAN_FAULT_IDX or node_num > self.FAN_NODE_NUM:\n            self.logger.debug('GET. Parameter error. node_num:%d', node_num)\n            return None\n\n        content = str(val)\n        if content == '':\n            self.logger.debug('GET. content is NULL. device_path:%s', device_path)\n            return None\n\n        device_path = self.get_fan_to_device_path(fan_num, node_num)\n        try:\n            val_file = open(device_path, 'w')\n        except IOError as e:\n            self.logger.error('GET. unable to open file: %s', str(e))\n            return None\n\n        val_file.write(content)\n\n        try:\n            val_file.close()\n        except:\n            self.logger.debug('GET. unable to close file. device_path:%s', device_path)\n            return None\n\n        return True\n\n    logger = logging.getLogger(__name__)\n    def __init__(self, log_level=logging.DEBUG):\n        ch = logging.StreamHandler()\n        ch.setLevel(log_level)\n        self.logger.addHandler(ch)\n\n        self._init_fnode_basepath()\n        fan_path = self.BASE_VAL_PATH \n        for fan_num in range(self.FAN_NUM_1_IDX, self.FAN_TOTAL_NUM+1):\n            for node_num in range(1, self.FAN_NODE_NUM+1):\n                node = self._get_fan_to_device_node(fan_num, node_num)\n                self.dev_paths[(fan_num, node_num)] = fan_path.format(node)\n               \n    def get_num_fans(self):\n        return self.FAN_TOTAL_NUM\n\n    def get_idx_fan_start(self):\n        return self.FAN_NUM_1_IDX\n\n    def get_num_nodes(self):\n        return self.FAN_NODE_NUM\n\n    def get_idx_node_start(self):\n        return self.FAN_FAULT_IDX\n\n    def get_size_node_map(self):\n        return len(self.dev_paths)\n\n    def get_size_path_map(self):\n        return len(self.dev_paths)\n\n    def get_fan_to_device_path(self, fan_num, node_num):\n        return self.dev_paths[(fan_num, node_num)]\n\n    def get_fan_fault(self, fan_num):\n        return self._get_fan_node_val(fan_num, self.FAN_FAULT_IDX)\n\n    #def get_fan_speed(self, fan_num):\n    #    return self._get_fan_node_val(fan_num, self.FAN_SPEED_IDX)\n\n    def get_fan_dir(self, fan_num):\n        return self._get_fan_node_val(fan_num, self.FAN_DIR_IDX)\n\n    def get_fan_duty_cycle(self):\n        try:\n            val_file = open(self.FAN_DUTY_PATH.format(1))\n        except IOError as e:\n            print(\"Error: unable to open file: %s\" % str(e))          \n            return False\n\n        content = val_file.readline().rstrip()\n        val_file.close()\n        return int(content)\n\n    def set_fan_duty_cycle(self, val):\n        for fan_num in range(1, self.FAN_TOTAL_NUM+1):\n            try:\n                fan_file = open(self.FAN_DUTY_PATH.format(fan_num), 'r+')\n            except IOError as e:\n                print(\"Error: unable to open file: %s\" % str(e))          \n                return False\n            fan_file.write(str(val))\n            fan_file.close()\n        return True\n\n    def get_fan_status(self, fan_num):\n        if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM:\n            self.logger.debug('GET. Parameter error. fan_num, %d', fan_num)\n            return None\n\n        if self.get_fan_fault(fan_num) is not None and self.get_fan_fault(fan_num) > 0:\n            self.logger.debug('GET. FAN fault. fan_num, %d', fan_num)\n            return False\n\n        #if self.get_fanr_fault(fan_num) is not None and self.get_fanr_fault(fan_num) > 0:\n        #    self.logger.debug('GET. FANR fault. fan_num, %d', fan_num)\n        #   return False\n\n        return True\n\n#def main():\n#    fan = FanUtil()\n#\n#    print 'get_size_node_map : %d' % fan.get_size_node_map()\n#    print 'get_size_path_map : %d' % fan.get_size_path_map()\n#    for x in range(fan.get_idx_fan_start(), fan.get_num_fans()+1):\n#        for y in range(fan.get_idx_node_start(), fan.get_num_nodes()+1):\n#            print fan.get_fan_to_device_path(x, y)\n#\n#if __name__ == '__main__':\n#    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py": {"changes": [{"diff": "\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py", "badparts": ["               os.system('reboot')           "], "goodparts": ["               subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is clear", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}], "source": "\n try: import os import getopt import sys import logging import logging.config import logging.handlers import time from as7326_56x.fanutil import FanUtil from as7326_56x.thermalutil import ThermalUtil except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as7326_monitor' global log_file global log_level class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False fan_policy_state=1 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0, 0, 0, 0, 0] class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 logging.debug('temp=%d', temp) for i in range(0, len(policy)): if temp > policy[i][0]: if temp <=policy[i][1]: state=policy[i][2] logging.debug('temp=%d >=policy[%d][0]=%d, temp=%d < policy[%d][1]=%d', temp, i, policy[i][0], temp, i, policy[i][1]) logging.debug('fan_state=%d', state) if state==0: state=policy[0][2] logging.debug('set default state') return state def manage_fans(self): thermal_pwm_list={} LEVEL_FAN_DEF=1 LEVEL_FAN_MID=2 LEVEL_FAN_MAX=3 LEVEL_TEMP_HIGH=4 LEVEL_TEMP_CRITICAL=5 fan_policy_state_pwm_tlb={ LEVEL_FAN_DEF: [38, 0x4], LEVEL_FAN_MID: [75, 0xB], LEVEL_FAN_MAX: [100, 0xE], LEVEL_TEMP_HIGH: [100, 0xE], LEVEL_TEMP_CRITICAL: [100, 0xE], } global fan_policy_state global fan_fail global test_temp global test_temp_list global alarm_state fan_policy={ 0:[0, 39000, LEVEL_FAN_DEF], 1:[39000, 45000, LEVEL_FAN_MID], 2:[45000, 61000, LEVEL_FAN_MAX], 3:[61000, 66000, LEVEL_TEMP_HIGH], 4:[66000, 200000, LEVEL_TEMP_CRITICAL], } thermal=ThermalUtil() fan=FanUtil() ori_pwm=fan.get_fan_duty_cycle() new_pwm=0 logging.debug('test_temp=%d', test_temp) if test_temp==0: temp1=thermal._get_thermal_val(1) temp2=thermal._get_thermal_val(2) temp3=thermal._get_thermal_val(3) temp4=thermal._get_thermal_val(4) temp5=thermal._get_thermal_val(5) temp6=0 else: temp1=test_temp_list[0] temp2=test_temp_list[1] temp3=test_temp_list[2] temp4=test_temp_list[3] temp5=test_temp_list[4] temp6=0 fan_fail=0 if temp2==0: temp_get=50000 logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%') elif temp2==0: temp_get=50000 logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%') else: temp_get=(temp2 +temp4)/2 ori_state=fan_policy_state fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy) logging.debug('lm75_48=%d, lm75_49=%d, lm75_4a=%d, lm_4b=%d, cpu=%d, bcm=%d', temp1,temp2,temp3,temp4,temp5,temp6) logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state) new_pwm=fan_policy_state_pwm_tlb[fan_policy_state][0] if fan_fail==0: logging.debug('new_pwm=%d', new_pwm) if fan_fail==0: if new_pwm!=ori_pwm: fan.set_fan_duty_cycle(new_pwm) logging.info('Set fan speed from %d to %d', ori_pwm, new_pwm) for i in range(fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1): if fan.get_fan_status(i)==0: new_pwm=100 logging.debug('fan_%d fail, set pwm to 100',i) if test_temp==0: fan_fail=1 fan.set_fan_duty_cycle(new_pwm) break else: fan_fail=0 new_state=fan_policy_state if ori_state==LEVEL_FAN_DEF: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected, reboot DUT') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MID: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MAX: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if alarm_state==1: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_HIGH: if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if new_state <=LEVEL_FAN_MID: logging.warning('Alarm for temperature high is cleared') alarm_state=0 if new_state <=LEVEL_FAN_MAX: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_CRITICAL: if new_state <=LEVEL_FAN_MAX: logging.warning('Alarm for temperature critical is cleared') return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv,'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv)!=8: print(\"temp test, need input six temp\") return 0 i=0 for x in range(2, 8): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) fan=FanUtil() fan.set_fan_duty_cycle(38) print(\"set default fan speed to 37.5%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(5) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2017 Accton Technology Corporation\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    mm/dd/yyyy (A.D.)\n#    3/23/2018: Roy Lee modify for as7326_56x\n#    6/26/2018: Jostar implement by new thermal policy from HW RD\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import getopt\n    import sys\n    import logging\n    import logging.config\n    import logging.handlers\n    import time  # this is only being used as part of the example\n    from as7326_56x.fanutil import FanUtil\n    from as7326_56x.thermalutil import ThermalUtil\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as7326_monitor'\n\nglobal log_file\nglobal log_level\n\n\n#Default FAN speed: 37.5%(0x05)\n#Ori is that detect: (U45_BCM56873 + Thermal sensor_LM75_CPU:0x4B) /2 \n#New Detect: (sensor_LM75_49 + Thermal sensor_LM75_CPU_4B) /2 \n#Thermal policy: Both F2B and B2F\n#1.\t(sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 =< 39C   , Keep 37.5%(0x05) Fan speed\n#2.\t(sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 39C   , Change Fan speed from 37.5%(0x05) to % 75%(0x0B)\n#3.\t(sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 45C   , Change Fan speed from 75%(0x0B) to 100%(0x0F)\n#4.\t(sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 61C   , Send alarm message\n#5.\t(sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 66C   , Shutdown system\n#6.\tOne Fan fail      , Change Fan speed to 100%(0x0F)\n\n#fan-dev 0-11 speed 0x05     Setup fan speed 37.50%\t\t\n#fan-dev 0-11 speed 0xB      Setup fan speed 75%\t\t\n#fan-dev 0-11 speed 0xF      Setup fan speed 100.00%\t\t\n\n\nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n \n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n     \n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args: # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\n\nfan_policy_state=1\nfan_fail=0\nalarm_state = 0 #0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0, 0, 0, 0, 0]\n\n# Make a class we can use to capture stdout and sterr in the log\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm=0\n    ori_pwm = 0\n    default_pwm=0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format= '[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = handler = logging.handlers.SysLogHandler(address = '/dev/log')\n        sys_handler.setLevel(logging.WARNING)       \n        logging.getLogger('').addHandler(sys_handler)\n\n        #logging.debug('SET. logfile:%s / loglevel:%d', log_file, log_level)\n          \n    def get_state_from_fan_policy(self, temp, policy):\n        state=0\n        logging.debug('temp=%d', temp)\n        for i in range(0, len(policy)):\n            #logging.debug('policy[%d][0]=%d, policy[%d][1]=%d', i,policy[i][0],i, policy[i][1])\n            if temp > policy[i][0]:\n                if temp <= policy[i][1]:\n                    state =policy[i][2]\n                    logging.debug ('temp=%d >= policy[%d][0]=%d,  temp=%d < policy[%d][1]=%d' , temp, i, policy[i][0], temp, i, policy[i][1])\n                    logging.debug ('fan_state=%d', state)\n        if state==0:\n            state=policy[0][2] #below fan_min, set to default pwm\n            logging.debug('set default state')\n        return state\n    \n    def manage_fans(self):\n        \n        thermal_pwm_list = {} #Ori sort is lm75_48, 49, 4a, 4b, cpu, bcm\n                              # After get pwm, do sort to get max pwm.\n        LEVEL_FAN_DEF=1\n        LEVEL_FAN_MID=2       \n        LEVEL_FAN_MAX=3\n        LEVEL_TEMP_HIGH=4\n        LEVEL_TEMP_CRITICAL=5         \n        \n        fan_policy_state_pwm_tlb = {\n        LEVEL_FAN_DEF:          [38,  0x4],\n        LEVEL_FAN_MID:          [75,  0xB],     \n        LEVEL_FAN_MAX:          [100, 0xE],\n        LEVEL_TEMP_HIGH:        [100, 0xE],\n        LEVEL_TEMP_CRITICAL:    [100, 0xE],\n        }\n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list        \n        global alarm_state\n        fan_policy ={\n        0: [0,     39000,   LEVEL_FAN_DEF],  #F2B_policy, B2F_plicy, PWM, reg_val\n        1: [39000, 45000,   LEVEL_FAN_MID],  \n        2: [45000, 61000,   LEVEL_FAN_MAX],\n        3: [61000, 66000,   LEVEL_TEMP_HIGH],        \n        4: [66000, 200000,  LEVEL_TEMP_CRITICAL],        \n        }\n              \n        thermal = ThermalUtil()\n        fan = FanUtil()\n        #fan_dir=fan.get_fan_dir(1)            \n        #if fan_dir > 1:\n        #    fan_dri=1 #something wrong, set fan_dir to default val\n        #if fan_dir < 0:\n        #    fan_dri=1 #something wrong, set fan_dir to default val\n        ori_pwm=fan.get_fan_duty_cycle()\n        new_pwm=0  \n        #logging.debug('fan_dir=%d, ori_pwm=%d', fan_dir, ori_pwm)\n        logging.debug('test_temp=%d', test_temp)\n        if test_temp==0: \n            temp1 = thermal._get_thermal_val(1)\n            temp2 = thermal._get_thermal_val(2)\n            temp3 = thermal._get_thermal_val(3)\n            temp4 = thermal._get_thermal_val(4)\n            temp5 = thermal._get_thermal_val(5)\n            temp6=0\n        else:\n            temp1 = test_temp_list[0]\n            temp2 = test_temp_list[1]\n            temp3 = test_temp_list[2]\n            temp4 = test_temp_list[3]\n            temp5 = test_temp_list[4]\n            temp6=0\n            fan_fail=0\n       \n        if temp2==0:\n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%')\n        elif temp2==0:        \n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%')\n        else:    \n            temp_get= (temp2 + temp4)/2  # Use (sensor_LM75_49 + Thermal sensor_LM75_CPU_4B) /2 \n        ori_state=fan_policy_state\n        fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy)    \n        logging.debug('lm75_48=%d, lm75_49=%d, lm75_4a=%d, lm_4b=%d, cpu=%d, bcm=%d', temp1,temp2,temp3,temp4,temp5,temp6)\n        logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state)\n        new_pwm = fan_policy_state_pwm_tlb[fan_policy_state][0]\n        if fan_fail==0:\n            logging.debug('new_pwm=%d', new_pwm)\n        \n        if fan_fail==0:\n            if new_pwm!=ori_pwm:\n                fan.set_fan_duty_cycle(new_pwm)\n                logging.info('Set fan speed from %d to %d', ori_pwm, new_pwm)\n        \n        for i in range (fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1):\n            if fan.get_fan_status(i)==0:\n                new_pwm=100\n                logging.debug('fan_%d fail, set pwm to 100',i)\n                if test_temp==0:\n                    fan_fail=1\n                    fan.set_fan_duty_cycle(new_pwm)\n                    break\n            else:\n                fan_fail=0        \n       \n        new_state = fan_policy_state       \n        \n        if ori_state==LEVEL_FAN_DEF:            \n           if new_state==LEVEL_TEMP_HIGH:\n               if alarm_state==0:\n                   logging.warning('Alarm for temperature high is detected')\n               alarm_state=1\n           if new_state==LEVEL_TEMP_CRITICAL:\n               logging.critical('Alarm for temperature critical is detected, reboot DUT')\n               time.sleep(2)\n               os.system('reboot')           \n        if ori_state==LEVEL_FAN_MID:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state=1 \n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n        if ori_state==LEVEL_FAN_MAX:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected') \n                alarm_state=1\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n            if alarm_state==1:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_HIGH:\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n            if new_state <= LEVEL_FAN_MID:\n                logging.warning('Alarm for temperature high is cleared')\n                alarm_state=0\n            if new_state <= LEVEL_FAN_MAX:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_CRITICAL:            \n            if new_state <= LEVEL_FAN_MAX:\n                logging.warning('Alarm for temperature critical is cleared')\n      \n        return True\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv,'hdlt:',['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg            \n        \n        if sys.argv[1]== '-t':\n            if len(sys.argv)!=8:\n                print(\"temp test, need input six temp\")\n                return 0\n            \n            i=0\n            for x in range(2, 8):\n               test_temp_list[i]= int(sys.argv[x])*1000\n               i=i+1\n            test_temp = 1   \n            log_level = logging.DEBUG\n            print(test_temp_list)                       \n    \n    fan = FanUtil()\n    fan.set_fan_duty_cycle(38)\n    print(\"set default fan speed to 37.5%\")\n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(5)\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    \n"}, "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py": {"changes": [{"diff": "\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n         if ori_state == LEVEL_FAN_MID:\n             if new_state == LEVEL_TEMP_HIGH:\n                 if alarm_state == 0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n         if ori_state == LEVEL_FAN_MAX:\n             if new_state == LEVEL_TEMP_HIGH:\n                 if alarm_state == 0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if alarm_state == 1:\n                 if temp_get < (fan_policy[3][0] - 5000):  # below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is cleare", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}], "source": "\n try: import os import sys import getopt import logging import logging.config import logging.handlers import time from sonic_platform import platform except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='accton_as7326_56x_monitor' platform_chassis=None fan_policy_state=1 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0] temp_test_data=0 test_temp_revert=0 class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 logging.debug('temp=%d', temp) for i in range(0, len(policy)): if temp > policy[i][0]: if temp <=policy[i][1]: state=policy[i][2] logging.debug('temp=%d >=policy[%d][0]=%d, temp=%d < policy[%d][1]=%d', temp, i, policy[i][0], temp, i, policy[i][1]) logging.debug('fan_state=%d', state) if state==0: state=policy[0][2] logging.debug('set default state') return state def manage_fans(self): LEVEL_FAN_DEF=1 LEVEL_FAN_MID=2 LEVEL_FAN_MAX=3 LEVEL_TEMP_HIGH=4 LEVEL_TEMP_CRITICAL=5 FAN_NUM=2 FAN_TRAY_NUM=6 fan_policy_state_pwm_tlb={ LEVEL_FAN_DEF: [38, 0x4], LEVEL_FAN_MID: [75, 0xB], LEVEL_FAN_MAX: [100, 0xE], LEVEL_TEMP_HIGH: [100, 0xE], LEVEL_TEMP_CRITICAL: [100, 0xE], } global platform_chassis global fan_policy_state global fan_fail global test_temp global test_temp_list global temp_test_data global test_temp_revert global alarm_state fan_policy={ 0:[0, 39000, LEVEL_FAN_DEF], 1:[39000, 45000, LEVEL_FAN_MID], 2:[45000, 61000, LEVEL_FAN_MAX], 3:[61000, 66000, LEVEL_TEMP_HIGH], 4:[66000, 200000, LEVEL_TEMP_CRITICAL], } ori_perc=platform_chassis.get_fan(0).get_speed() if test_temp==0: temp2=platform_chassis.get_thermal(1).get_temperature()*1000 temp4=platform_chassis.get_thermal(3).get_temperature()*1000 else: temp2=test_temp_list[0] temp4=test_temp_list[1] if test_temp_revert==0: temp_test_data=temp_test_data+2000 else: temp_test_data=temp_test_data-2000 if temp2==0: temp_get=50000 logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%') elif temp4==0: temp_get=50000 logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%') else: temp_get=(temp2 +temp4)/2 logging.debug('Begeinning,fan_policy_state=%d', fan_policy_state) if test_temp==1: temp_get=temp_get+temp_test_data ori_state=fan_policy_state fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy) logging.debug('temp2=lm75_49=%d,temp4=lm_4b=%d, temp_get=%d, ori_state=%d', temp2, temp4, temp_get, ori_state) if fan_policy_state > ori_state: logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state) new_perc=fan_policy_state_pwm_tlb[fan_policy_state][0] if fan_fail==0: if new_perc !=ori_perc: platform_chassis.get_fan(0).set_speed(new_perc) logging.info('Set fan speed from %d to %d', ori_perc, new_perc) for i in range(FAN_TRAY_NUM * FAN_NUM): if not platform_chassis.get_fan(i).get_status() or not platform_chassis.get_fan(i).get_speed_rpm(): new_perc=100 logging.debug('fan_%d fail, set new_perc to 100', i+1) fan_fail=1 if ori_state < LEVEL_FAN_MAX: fan_policy_state=new_state=LEVEL_FAN_MAX logging.debug('fan_policy_state=%d', fan_policy_state) logging.warning('fan_policy_state is LEVEL_FAN_MAX') platform_chassis.get_fan(0).set_speed(new_perc) break else: fan_fail=0 if fan_fail==0: new_state=fan_policy_state else: if fan_policy_state > ori_state: new_state=fan_policy_state else: fan_policy_state=new_state=LEVEL_FAN_MAX if ori_state==LEVEL_FAN_DEF: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected, reboot DUT') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MID: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MAX: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if alarm_state==1: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_HIGH: if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if new_state <=LEVEL_FAN_MID: logging.warning('Alarm for temperature high is cleared') alarm_state=0 if new_state <=LEVEL_FAN_MAX: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_CRITICAL: if new_state <=LEVEL_FAN_MAX: logging.warning('Alarm for temperature critical is cleared') return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv, 'hdlt:',['lfile=']) except getopt.GetoptError: print(('Usage: %s[-d][-l <log_file>]' % sys.argv[0])) return 0 for opt, arg in opts: if opt=='-h': print(('Usage: %s[-d][-l <log_file>]' % sys.argv[0])) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv) !=4: print(\"temp test, need input four temp\") return 0 i=0 for x in range(2, 4): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) global platform_chassis platform_chassis=platform.Platform().get_chassis() platform_chassis.get_fan(0).set_speed(38) print(\"set default fan speed to 37.5%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(5) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    mm/dd/yyyy (A.D.)\n#    3/23/2018: Roy Lee modify for as7326_56x\n#    6/26/2018: Jostar implement by new thermal policy from HW RD\n#    09/18/2020: Jostar Yang, change to call PDDF API .\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import sys\n    import getopt\n    import logging\n    import logging.config\n    import logging.handlers\n    import time\n    from sonic_platform import platform\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = 'accton_as7326_56x_monitor'\n\nplatform_chassis = None\n\n# Default FAN speed: 37.5%(0x05)\n# Ori is that detect: (U45_BCM56873 + Thermal sensor_LM75_CPU:0x4B) /2\n# New Detect: (sensor_LM75_49 + Thermal sensor_LM75_CPU_4B) /2\n# Thermal policy: Both F2B and B2F\n# 1.    (sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 =< 39C   , Keep 37.5%(0x05) Fan speed\n# 2.    (sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 39C   , Change Fan speed from 37.5%(0x05) to % 75%(0x0B)\n# 3.    (sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 45C   , Change Fan speed from 75%(0x0B) to 100%(0x0F)\n# 4.    (sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 61C   , Send alarm message\n# 5.    (sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 66C   , Shutdown system\n# 6.    One Fan fail      , Change Fan speed to 100%(0x0F)\n\n# fan-dev 0-11 speed 0x05     Setup fan speed 37.50%\n# fan-dev 0-11 speed 0xB      Setup fan speed 75%\n# fan-dev 0-11 speed 0xF      Setup fan speed 100.00%\n\nfan_policy_state = 1\nfan_fail = 0\nalarm_state = 0  # 0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0]\ntemp_test_data = 0\ntest_temp_revert = 0\n\n# Make a class we can use to capture stdout and sterr in the log\n\n\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm = 0\n    ori_pwm = 0\n    default_pwm = 0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format='[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = logging.handlers.SysLogHandler(address='/dev/log')\n        sys_handler.setLevel(logging.WARNING)\n        logging.getLogger('').addHandler(sys_handler)\n\n    def get_state_from_fan_policy(self, temp, policy):\n        state = 0\n        logging.debug('temp=%d', temp)\n        for i in range(0, len(policy)):\n            #logging.debug('policy[%d][0]=%d, policy[%d][1]=%d', i,policy[i][0],i, policy[i][1])\n            if temp > policy[i][0]:\n                if temp <= policy[i][1]:\n                    state = policy[i][2]\n                    logging.debug('temp=%d >= policy[%d][0]=%d,  temp=%d < policy[%d][1]=%d',\n                                  temp, i, policy[i][0], temp, i, policy[i][1])\n                    logging.debug('fan_state=%d', state)\n        if state == 0:\n            state = policy[0][2]  # below fan_min, set to default pwm\n            logging.debug('set default state')\n        return state\n\n    def manage_fans(self):\n        LEVEL_FAN_DEF = 1\n        LEVEL_FAN_MID = 2\n        LEVEL_FAN_MAX = 3\n        LEVEL_TEMP_HIGH = 4\n        LEVEL_TEMP_CRITICAL = 5\n\n        FAN_NUM = 2\n        FAN_TRAY_NUM = 6\n\n        fan_policy_state_pwm_tlb = {\n            LEVEL_FAN_DEF:          [38,  0x4],\n            LEVEL_FAN_MID:          [75,  0xB],\n            LEVEL_FAN_MAX:          [100, 0xE],\n            LEVEL_TEMP_HIGH:        [100, 0xE],\n            LEVEL_TEMP_CRITICAL:    [100, 0xE],\n        }\n        global platform_chassis\n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list\n        global temp_test_data\n        global test_temp_revert\n        global alarm_state\n        fan_policy = {\n            0: [0,     39000,   LEVEL_FAN_DEF],  # F2B_policy, B2F_plicy, PWM, reg_val\n            1: [39000, 45000,   LEVEL_FAN_MID],\n            2: [45000, 61000,   LEVEL_FAN_MAX],\n            3: [61000, 66000,   LEVEL_TEMP_HIGH],\n            4: [66000, 200000,  LEVEL_TEMP_CRITICAL],\n        }\n        \n        ori_perc = platform_chassis.get_fan(0).get_speed()\n        #logging.debug('test_temp=%d', test_temp)\n        if test_temp == 0:\n            temp2 = platform_chassis.get_thermal(1).get_temperature()*1000\n            temp4 = platform_chassis.get_thermal(3).get_temperature()*1000\n        else:\n            temp2 = test_temp_list[0]\n            temp4 = test_temp_list[1]\n            # fan_fail=0 # When test no-fan DUT. Need to use this.\n            if test_temp_revert == 0:\n                temp_test_data = temp_test_data+2000\n            else:\n                temp_test_data = temp_test_data-2000\n\n        if temp2 == 0:\n            temp_get = 50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75%\n            logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%')\n        elif temp4 == 0:\n            temp_get = 50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75%\n            logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%')\n        else:\n            temp_get = (temp2 + temp4)/2  # Use (sensor_LM75_49 + Thermal sensor_LM75_CPU_4B) /2\n        logging.debug('Begeinning ,fan_policy_state=%d', fan_policy_state)\n        if test_temp == 1:\n            temp_get = temp_get+temp_test_data\n\n        ori_state = fan_policy_state\n        fan_policy_state = self.get_state_from_fan_policy(temp_get, fan_policy)\n        #logging.debug(\"temp2=\" + str(temp2))\n        #logging.debug(\"temp4=\" + str(temp4))\n        #logging.debug(\"temp_get=\" + str(temp_get))\n        logging.debug('temp2=lm75_49=%d,temp4=lm_4b=%d, temp_get=%d, ori_state=%d', temp2, temp4, temp_get, ori_state)\n        if fan_policy_state > ori_state:\n            logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state)\n        new_perc = fan_policy_state_pwm_tlb[fan_policy_state][0]\n\n        if fan_fail == 0:\n            if new_perc != ori_perc:\n                # fan.set_fan_duty_cycle(new_perc)\n                platform_chassis.get_fan(0).set_speed(new_perc)\n                logging.info('Set fan speed from %d to %d', ori_perc, new_perc)\n\n        # for i in range (fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1):\n        for i in range(FAN_TRAY_NUM * FAN_NUM):\n            if not platform_chassis.get_fan(i).get_status() or not platform_chassis.get_fan(i).get_speed_rpm():\n                new_perc = 100\n                logging.debug('fan_%d fail, set new_perc to 100', i+1)\n                # if test_temp==0:# When test no-fan DUT. Need to use this.\n                fan_fail = 1\n                if ori_state < LEVEL_FAN_MAX:\n                    fan_policy_state = new_state = LEVEL_FAN_MAX\n                    logging.debug('fan_policy_state=%d', fan_policy_state)\n                    logging.warning('fan_policy_state is LEVEL_FAN_MAX')\n                platform_chassis.get_fan(0).set_speed(new_perc)\n                break\n            else:\n                fan_fail = 0\n\n        if fan_fail == 0:\n            new_state = fan_policy_state\n        else:\n            if fan_policy_state > ori_state:\n                new_state = fan_policy_state\n            else:\n                fan_policy_state = new_state = LEVEL_FAN_MAX\n\n        if ori_state == LEVEL_FAN_DEF:\n            if new_state == LEVEL_TEMP_HIGH:\n                if alarm_state == 0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state = 1\n            if new_state == LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n                os.system('reboot')\n        if ori_state == LEVEL_FAN_MID:\n            if new_state == LEVEL_TEMP_HIGH:\n                if alarm_state == 0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state = 1\n            if new_state == LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n        if ori_state == LEVEL_FAN_MAX:\n            if new_state == LEVEL_TEMP_HIGH:\n                if alarm_state == 0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state = 1\n            if new_state == LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n            if alarm_state == 1:\n                if temp_get < (fan_policy[3][0] - 5000):  # below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state = 0\n        if ori_state == LEVEL_TEMP_HIGH:\n            if new_state == LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n            if new_state <= LEVEL_FAN_MID:\n                logging.warning('Alarm for temperature high is cleared')\n                alarm_state = 0\n            if new_state <= LEVEL_FAN_MAX:\n                if temp_get < (fan_policy[3][0] - 5000):  # below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state = 0\n        if ori_state == LEVEL_TEMP_CRITICAL:\n            if new_state <= LEVEL_FAN_MAX:\n                logging.warning('Alarm for temperature critical is cleared')\n\n        return True\n\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv, 'hdlt:', ['lfile='])\n        except getopt.GetoptError:\n            print(('Usage: %s [-d] [-l <log_file>]' % sys.argv[0]))\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print(('Usage: %s [-d] [-l <log_file>]' % sys.argv[0]))\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg\n\n        if sys.argv[1] == '-t':\n            if len(sys.argv) != 4:\n                print(\"temp test, need input four temp\")\n                return 0\n\n            i = 0\n            for x in range(2, 4):\n                test_temp_list[i] = int(sys.argv[x])*1000\n                i = i+1\n            test_temp = 1\n            log_level = logging.DEBUG\n            print(test_temp_list)\n\n    global platform_chassis\n    platform_chassis = platform.Platform().get_chassis()\n\n    platform_chassis.get_fan(0).set_speed(38)\n\n    print(\"set default fan speed to 37.5%\")\n    monitor = device_monitor(log_file, log_level)\n\n    while True:\n        monitor.manage_fans()\n        time.sleep(5)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py": {"changes": [{"diff": "\n \n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\n", "add": 6, "remove": 6, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py", "badparts": ["    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cdump -y 0 0x42 s 0x9a\"", "        status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]", "        status, output = getstatusoutput_noshell(cmd)"]}, {"diff": "\n     return 0\n \n def eeprom_check():\n-    cmd = \"i2cget -y -f 0 0x56\"\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cget\", \"-y\", \"-f\", \"0\", \"0x56\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     r", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py", "badparts": ["    cmd = \"i2cget -y -f 0 0x56\"", "    status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cget\", \"-y\", \"-f\", \"0\", \"0x56\"]", "    status, output = getstatusoutput_noshell(cmd)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes \"\"\" import subprocess import getopt import sys import logging import re import time import os PROJECT_NAME='as7326_56x' version='0.1.0' verbose=False DEBUG=False args=[] ALL_DEVICE={} DEVICE_NO={'led':5, 'fan':6,'thermal':4, 'psu':2, 'sfp':58} FORCE=0 if DEBUG==True: print(sys.argv[0]) print('ARGV :', sys.argv[1:]) def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print(options) print(args) print(len(sys.argv)) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': do_install() elif arg=='api': do_sonic_platform_install() elif arg=='api_clean': do_sonic_platform_clean() elif arg=='clean': do_uninstall() else: show_help() return 0 def show_help(): print(__doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]}) sys.exit(0) def dis_i2c_ir3570a(addr): cmd=\"i2cset -y 0 0x%x 0xE5 0x01\" % addr status, output=subprocess.getstatusoutput(cmd) cmd=\"i2cset -y 0 0x%x 0x12 0x02\" % addr status, output=subprocess.getstatusoutput(cmd) return status def ir3570_check(): cmd=\"i2cdump -y 0 0x42 s 0x9a\" try: status, output=subprocess.getstatusoutput(cmd) lines=output.split('\\n') hn=re.findall(r'\\w+', lines[-1]) version=int(hn[1], 16) if version==0x24: ret=dis_i2c_ir3570a(4) else: ret=0 except Exception as e: print(\"Error on ir3570_check() e:\" +str(e)) return -1 return ret def my_log(txt): if DEBUG==True: print(\"[ROY]\"+txt) return def log_os_system(cmd, show): logging.info('Run:'+cmd) status, output=subprocess.getstatusoutput(cmd) my_log(cmd +\"with result:\" +str(status)) my_log(\" output:\"+output) if status: logging.info('Failed:'+cmd) if show: print('Failed:'+cmd) return status, output def driver_check(): ret, lsmod=log_os_system(\"ls /sys/module/*accton*\", 0) logging.info('mods:'+lsmod) if ret: return False else: return True kos=[ 'modprobe i2c_dev', 'modprobe i2c_mux_pca954x', 'modprobe accton_i2c_cpld' , 'modprobe ym2651y' , 'modprobe accton_as7326_56x_fan' , 'modprobe optoe' , 'modprobe accton_as7326_56x_leds' , 'modprobe accton_as7326_56x_psu'] def driver_install(): global FORCE status, output=log_os_system('modprobe i2c_dev', 1) status, output=log_os_system(\"depmod\", 1) for i in range(0,len(kos)): status, output=log_os_system(kos[i], 1) if status: if FORCE==0: return status print(\"Done driver_install\") return 0 def driver_uninstall(): global FORCE for i in range(0,len(kos)): rm=kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\") rm=rm.replace(\"insmod\", \"rmmod\") lst=rm.split(\" \") if len(lst) > 3: del(lst[3]) rm=\" \".join(lst) status, output=log_os_system(rm, 1) if status: if FORCE==0: return status return 0 i2c_prefix='/sys/bus/i2c/devices/' ''' i2c_bus={'fan':['11-0066'] , 'thermal':['15-0048','15-0049', '15-004a', '15-004b'], 'psu':['17-0051','13-0053'], 'sfp':['-0050']} i2c_nodes={'fan':['present', 'front_speed_rpm', 'rear_speed_rpm'], 'thermal':['hwmon/hwmon*/temp1_input'], 'psu':['psu_present ', 'psu_power_good'] , 'sfp':['module_present_', 'module_tx_disable_']} ''' sfp_map=[ 42,41,44,43,47,45,46,50, 48,49,52,51,53,56,55,54, 58,57,60,59,61,63,62,64, 66,68,65,67,69,71,72,70, 74,73,76,75,77,79,78,80, 81,82,84,85,83,87,88,86, 25,26,27,28,29,30,31,32, 22,23] qsfp_start=48 qsfp_end =56 cpld_of_module={'12-0062': list(range(0,30)), \t\t '18-0060': list(range(30,58))} mknod=[ 'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-24/new_device', 'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-33/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-34/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-35/new_device', 'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-36/new_device', 'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-37/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-38/new_device', 'echo as7326_56x_fan 0x66 > /sys/bus/i2c/devices/i2c-11/new_device ', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-15/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-15/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-15/new_device', 'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-15/new_device', 'echo as7326_56x_psu1 0x51 > /sys/bus/i2c/devices/i2c-17/new_device', 'echo ym2651 0x59 > /sys/bus/i2c/devices/i2c-17/new_device', 'echo as7326_56x_psu2 0x53 > /sys/bus/i2c/devices/i2c-13/new_device', 'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-13/new_device', 'echo as7326_56x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo as7326_56x_cpld2 0x62 > /sys/bus/i2c/devices/i2c-12/new_device', 'echo as7326_56x_cpld3 0x64 > /sys/bus/i2c/devices/i2c-19/new_device'] mknod2=[ ] eeprom_mknod=[ 'echo 24c04 0x56 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-0/new_device' ] def i2c_order_check(): return 0 def eeprom_check(): cmd=\"i2cget -y -f 0 0x56\" status, output=subprocess.getstatusoutput(cmd) return status def device_install(): global FORCE order=i2c_order_check() if order: for i in range(0,len(mknod2)): if mknod2[i].find('pca954') !=-1: time.sleep(1) status, output=log_os_system(mknod2[i], 1) if status: print(output) if FORCE==0: return status else: for i in range(0,len(mknod)): if mknod[i].find('pca954') !=-1: time.sleep(1) status, output=log_os_system(mknod[i], 1) if status: print(output) if FORCE==0: return status cmd='echo -2 | tee /sys/bus/i2c/drivers/pca954x/*-00*/idle_state' status, output=log_os_system(cmd, 1) if status: print(output) if FORCE==0: return status log_os_system(\"i2cset -f -y 0 0x77 0 \", 1) ret=eeprom_check() if ret==0: log_os_system(eeprom_mknod[0], 1) time.sleep(0.2) exists=os.path.isfile('/sys/bus/i2c/devices/0-0056/eeprom') if(exists is False): subprocess.call('echo 0x56 > /sys/bus/i2c/devices/i2c-0/delete_device', shell=True) log_os_system(eeprom_mknod[1], 1) else: log_os_system(eeprom_mknod[1], 1) for i in range(0,len(sfp_map)): if i < qsfp_start or i >=qsfp_end: status, output=log_os_system(\"echo optoe2 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1) else: status, output=log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1) if status: print(output) if FORCE==0: return status print(\"Done device_install\") return def device_uninstall(): global FORCE status, output=log_os_system(\"ls /sys/bus/i2c/devices/1-0076\", 0) if status==0: I2C_ORDER=1 else: I2C_ORDER=0 for i in range(0,len(sfp_map)): target=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\" status, output=log_os_system(\"echo 0x50 > \"+target, 1) if status: print(output) if FORCE==0: return status if I2C_ORDER==0: nodelist=mknod else: nodelist=mknod2 for i in range(len(nodelist)): target=nodelist[-(i+1)] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status exists=os.path.isfile('/sys/bus/i2c/devices/0-0056/eeprom') if(exists is True): target=eeprom_mknod[0] else: target=eeprom_mknod[1] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status return def system_ready(): if driver_check()==False: return False if not device_exist(): return False return True PLATFORM_ROOT_PATH='/usr/share/sonic/device' PLATFORM_API2_WHL_FILE_PY3='sonic_platform-1.0-py3-none-any.whl' def do_sonic_platform_install(): device_path=\"{}{}{}{}\".format(PLATFORM_ROOT_PATH, '/x86_64-accton_', PROJECT_NAME, '-r0') SONIC_PLATFORM_BSP_WHL_PKG_PY3=\"/\".join([device_path, PLATFORM_API2_WHL_FILE_PY3]) status, output=log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0) if status: if os.path.exists(SONIC_PLATFORM_BSP_WHL_PKG_PY3): status, output=log_os_system(\"pip3 install \"+SONIC_PLATFORM_BSP_WHL_PKG_PY3, 1) if status: print(\"Error: Failed to install{}\".format(PLATFORM_API2_WHL_FILE_PY3)) return status else: print(\"Successfully installed{} package\".format(PLATFORM_API2_WHL_FILE_PY3)) else: print('{} is not found'.format(PLATFORM_API2_WHL_FILE_PY3)) else: print('{} has installed'.format(PLATFORM_API2_WHL_FILE_PY3)) return def do_sonic_platform_clean(): status, output=log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0) if status: print('{} does not install, not need to uninstall'.format(PLATFORM_API2_WHL_FILE_PY3)) else: status, output=log_os_system(\"pip3 uninstall sonic-platform -y\", 0) if status: print('Error: Failed to uninstall{}'.format(PLATFORM_API2_WHL_FILE_PY3)) return status else: print('{} is uninstalled'.format(PLATFORM_API2_WHL_FILE_PY3)) return def do_install(): print(\"Checking system....\") if driver_check()==False: print(\"No driver, installing....\") status=driver_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" drivers detected....\") ir3570_check() if not device_exist(): print(\"No device, installing....\") status=device_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" devices detected....\") do_sonic_platform_install() return def do_uninstall(): print(\"Checking system....\") if not device_exist(): print(PROJECT_NAME.upper() +\" has no device installed....\") else: print(\"Removing device....\") status=device_uninstall() if status: if FORCE==0: return status if driver_check()==False: print(PROJECT_NAME.upper() +\" has no driver installed....\") else: print(\"Removing installed driver....\") status=driver_uninstall() if status: if FORCE==0: return status do_sonic_platform_clean() return def device_exist(): ret1, log=log_os_system(\"ls \"+i2c_prefix+\"*0070\", 0) ret2, log=log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# Copyright (C) 2016 Accton Networks, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean\ncommand:\n    install     : install drivers and generate related sysfs nodes\n    clean       : uninstall drivers and remove related sysfs nodes\n\"\"\"\nimport subprocess\nimport getopt\nimport sys\nimport logging\nimport re\nimport time\nimport os\n\n\n\nPROJECT_NAME = 'as7326_56x'\nversion = '0.1.0'\nverbose = False\nDEBUG = False\nargs = []\nALL_DEVICE = {}\nDEVICE_NO = {'led':5, 'fan':6,'thermal':4, 'psu':2, 'sfp':58}\nFORCE = 0\n#logging.basicConfig(filename= PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG)\n#logging.basicConfig(level=logging.INFO)\n\n\nif DEBUG == True:\n    print(sys.argv[0])\n    print('ARGV      :', sys.argv[1:])\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n\n    if len(sys.argv)<2:\n        show_help()\n\n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:                \n        print(options)\n        print(args)\n        print(len(sys.argv))\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n           do_install()\n        elif arg == 'api':\n           do_sonic_platform_install()\n        elif arg == 'api_clean':\n           do_sonic_platform_clean()\n        elif arg == 'clean':\n           do_uninstall()\n        else:\n            show_help()\n    return 0\n\ndef show_help():\n    print(__doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]})\n    sys.exit(0)\n\n\n\ndef dis_i2c_ir3570a(addr):\n    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef ir3570_check():\n    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n    try:\n        status, output = subprocess.getstatusoutput(cmd)\n        lines = output.split('\\n')\n        hn = re.findall(r'\\w+', lines[-1])\n        version = int(hn[1], 16)\n        if version == 0x24:  #only for ir3570a\n            ret = dis_i2c_ir3570a(4)\n        else:\n            ret = 0\n    except Exception as e:\n        print(\"Error on ir3570_check() e:\" + str(e))\n        return -1\n    return ret\n\n\ndef my_log(txt):\n    if DEBUG == True:\n        print(\"[ROY]\"+txt)\n    return\n\ndef log_os_system(cmd, show):\n    logging.info('Run :'+cmd)\n    status, output = subprocess.getstatusoutput(cmd)\n    my_log (cmd +\"with result:\" + str(status))\n    my_log (\"      output:\"+output)\n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print('Failed :'+cmd)\n    return  status, output\n\ndef driver_check():\n    ret, lsmod = log_os_system(\"ls /sys/module/*accton*\", 0)\n    logging.info('mods:'+lsmod)\n    if ret :\n        return False\n    else :\n        return True\n\n\n\nkos = [\n'modprobe i2c_dev',\n'modprobe i2c_mux_pca954x',\n'modprobe accton_i2c_cpld'  ,\n'modprobe ym2651y'                  ,\n'modprobe accton_as7326_56x_fan'     ,\n'modprobe optoe'      ,\n'modprobe accton_as7326_56x_leds'      ,\n'modprobe accton_as7326_56x_psu' ]\n\ndef driver_install():\n    global FORCE\n    \n    status, output = log_os_system('modprobe i2c_dev', 1)\n    status, output = log_os_system(\"depmod\", 1)\n    for i in range(0,len(kos)):\n        status, output = log_os_system(kos[i], 1)\n        if status:\n            if FORCE == 0:\n                return status\n    print(\"Done driver_install\")\n    \n    return 0\n\ndef driver_uninstall():\n    global FORCE\n    for i in range(0,len(kos)):\n        rm = kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\")\n        rm = rm.replace(\"insmod\", \"rmmod\")\n        lst = rm.split(\" \")\n        if len(lst) > 3:\n            del(lst[3])\n        rm = \" \".join(lst)\n        status, output = log_os_system(rm, 1)\n        if status:\n            if FORCE == 0:\n                return status\n    return 0\n\ni2c_prefix = '/sys/bus/i2c/devices/'\n'''\ni2c_bus = {'fan': ['11-0066']                 ,\n           'thermal': ['15-0048','15-0049', '15-004a', '15-004b'] ,\n           'psu': ['17-0051','13-0053'],\n           'sfp': ['-0050']}\ni2c_nodes = {'fan': ['present', 'front_speed_rpm', 'rear_speed_rpm'] ,\n           'thermal': ['hwmon/hwmon*/temp1_input'] ,\n           'psu': ['psu_present ', 'psu_power_good']    ,\n           'sfp': ['module_present_', 'module_tx_disable_']}\n'''\nsfp_map =  [\n        42,41,44,43,47,45,46,50,\n        48,49,52,51,53,56,55,54,\n        58,57,60,59,61,63,62,64,\n        66,68,65,67,69,71,72,70,\n        74,73,76,75,77,79,78,80,\n        81,82,84,85,83,87,88,86,    #port 41~48\n        25,26,27,28,29,30,31,32,    #port 49~56 QSFP\n        22,23]                      #port 57~58 SFP+ from CPU NIF.\nqsfp_start = 48\nqsfp_end   = 56\n\n#For sideband signals of SFP/QSFP modules.\ncpld_of_module = {'12-0062': list(range(0,30)),\n\t\t  '18-0060': list(range(30,58)) }\n\n\nmknod =[\n'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-1/new_device' ,\n'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-1/new_device' ,\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-24/new_device' ,\n'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-2/new_device' ,\n'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-33/new_device',\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-34/new_device',\n'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-35/new_device',\n'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-36/new_device',\n'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-37/new_device',\n'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-38/new_device',\n\n'echo as7326_56x_fan 0x66 > /sys/bus/i2c/devices/i2c-11/new_device ',\n'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-15/new_device',\n'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-15/new_device',\n'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-15/new_device',\n'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-15/new_device',\n'echo as7326_56x_psu1 0x51 > /sys/bus/i2c/devices/i2c-17/new_device',\n'echo ym2651 0x59 > /sys/bus/i2c/devices/i2c-17/new_device',\n'echo as7326_56x_psu2 0x53 > /sys/bus/i2c/devices/i2c-13/new_device',\n'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-13/new_device',\n'echo as7326_56x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo as7326_56x_cpld2 0x62 > /sys/bus/i2c/devices/i2c-12/new_device',\n'echo as7326_56x_cpld3 0x64 > /sys/bus/i2c/devices/i2c-19/new_device']\n\nmknod2 =[\n]\n\n#EERPOM\neeprom_mknod =[\n'echo 24c04 0x56 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-0/new_device'\n]\n\n\ndef i2c_order_check():\n    # This project has only 1 i2c bus.\n    return 0\n\ndef eeprom_check():\n    cmd = \"i2cget -y -f 0 0x56\"\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef device_install():\n    global FORCE\n\n    order = i2c_order_check()\n\n    # if 0x70 is not exist @i2c-1, use reversed bus order\n    if order:\n        for i in range(0,len(mknod2)):\n            #for pca954x need times to built new i2c buses\n            if mknod2[i].find('pca954') != -1:\n               time.sleep(1)\n\n            status, output = log_os_system(mknod2[i], 1)\n            if status:\n                print(output)\n                if FORCE == 0:\n                    return status\n    else:\n        for i in range(0,len(mknod)):\n            #for pca954x need times to built new i2c buses\n            if mknod[i].find('pca954') != -1:\n               time.sleep(1)\n\n            status, output = log_os_system(mknod[i], 1)\n            if status:\n                print(output)\n                if FORCE == 0:\n                    return status\n\n    # set all pca954x idle_disconnect\n    cmd = 'echo -2 | tee /sys/bus/i2c/drivers/pca954x/*-00*/idle_state'\n    status, output = log_os_system(cmd, 1)\n    if status:\n        print(output)\n        if FORCE == 0:\n            return status\n    \n    # initiate IDPROM\n    # Close 0x77 mux to make sure if the I2C address of IDPROM is 0x56 or 0x57\n    log_os_system(\"i2cset -f -y 0 0x77 0 \", 1)\n    ret=eeprom_check()\n    if ret==0:\n        log_os_system(eeprom_mknod[0], 1) #old board, 0x56 eeprom\n        time.sleep(0.2)\n        exists = os.path.isfile('/sys/bus/i2c/devices/0-0056/eeprom')\n        if (exists is False):\n            subprocess.call('echo 0x56 > /sys/bus/i2c/devices/i2c-0/delete_device', shell=True)\n            log_os_system(eeprom_mknod[1], 1)\n    else:\n        log_os_system(eeprom_mknod[1], 1) #new board, 0x57 eeprom                \n                    \n                    \n    for i in range(0,len(sfp_map)):\n        if i < qsfp_start or i >= qsfp_end:\n            status, output =log_os_system(\"echo optoe2 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1)\n        else:\n            status, output =log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n    print(\"Done device_install\")\n    return\n\ndef device_uninstall():\n    global FORCE\n\n    status, output =log_os_system(\"ls /sys/bus/i2c/devices/1-0076\", 0)\n    if status==0:\n        I2C_ORDER=1\n    else:\n        I2C_ORDER=0\n\n    for i in range(0,len(sfp_map)):\n        target = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\"\n        status, output =log_os_system(\"echo 0x50 > \"+ target, 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    if I2C_ORDER==0:\n        nodelist = mknod\n    else:\n        nodelist = mknod2\n\n    for i in range(len(nodelist)):\n        target = nodelist[-(i+1)]\n        temp = target.split()\n        del temp[1]\n        temp[-1] = temp[-1].replace('new_device', 'delete_device')\n        status, output = log_os_system(\" \".join(temp), 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    #Deal with for del 0x56 or 0x57 sysfs device    \n    exists = os.path.isfile('/sys/bus/i2c/devices/0-0056/eeprom')\n        \n    if (exists is True):\n        target = eeprom_mknod[0] #0x56\n    else:\n        target = eeprom_mknod[1] #0x57\n    \n    temp = target.split()\n    del temp[1]\n    temp[-1] = temp[-1].replace('new_device', 'delete_device')\n    status, output = log_os_system(\" \".join(temp), 1)\n    if status:\n        print(output)\n        if FORCE == 0:\n           return status\n\n    return\n\ndef system_ready():\n    if driver_check() == False:\n        return False\n    if not device_exist():\n        return False\n    return True\nPLATFORM_ROOT_PATH = '/usr/share/sonic/device'\nPLATFORM_API2_WHL_FILE_PY3 ='sonic_platform-1.0-py3-none-any.whl'\ndef do_sonic_platform_install():\n    device_path = \"{}{}{}{}\".format(PLATFORM_ROOT_PATH, '/x86_64-accton_', PROJECT_NAME, '-r0')\n    SONIC_PLATFORM_BSP_WHL_PKG_PY3 = \"/\".join([device_path, PLATFORM_API2_WHL_FILE_PY3])\n\n    #Check API2.0 on py whl file\n    status, output = log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0)\n    if status:\n        if os.path.exists(SONIC_PLATFORM_BSP_WHL_PKG_PY3): \n            status, output = log_os_system(\"pip3 install \"+ SONIC_PLATFORM_BSP_WHL_PKG_PY3, 1)\n            if status:\n                print(\"Error: Failed to install {}\".format(PLATFORM_API2_WHL_FILE_PY3))\n                return status\n            else:\n                print(\"Successfully installed {} package\".format(PLATFORM_API2_WHL_FILE_PY3))\n        else:\n            print('{} is not found'.format(PLATFORM_API2_WHL_FILE_PY3))\n    else:        \n        print('{} has installed'.format(PLATFORM_API2_WHL_FILE_PY3))\n     \n    return \n     \ndef do_sonic_platform_clean():\n    status, output = log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0)   \n    if status:\n        print('{} does not install, not need to uninstall'.format(PLATFORM_API2_WHL_FILE_PY3))\n        \n    else:        \n        status, output = log_os_system(\"pip3 uninstall sonic-platform -y\", 0)\n        if status:\n            print('Error: Failed to uninstall {}'.format(PLATFORM_API2_WHL_FILE_PY3))\n            return status\n        else:\n            print('{} is uninstalled'.format(PLATFORM_API2_WHL_FILE_PY3))\n    \n    \n    return\n\ndef do_install():\n    print(\"Checking system....\")\n    if driver_check() == False:\n        print(\"No driver, installing....\")\n        status = driver_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print(PROJECT_NAME.upper()+\" drivers detected....\")\n\n    ir3570_check()\n\n    if not device_exist():\n        print(\"No device, installing....\")\n        status = device_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print(PROJECT_NAME.upper()+\" devices detected....\")\n\n    do_sonic_platform_install()\n        \n    return\n\ndef do_uninstall():\n    print(\"Checking system....\")\n    if not device_exist():\n        print(PROJECT_NAME.upper() +\" has no device installed....\")\n    else:\n        print(\"Removing device....\")\n        status = device_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    if driver_check()== False :\n        print(PROJECT_NAME.upper() +\" has no driver installed....\")\n    else:\n        print(\"Removing installed driver....\")\n        status = driver_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    do_sonic_platform_clean()\n\n    return\n\ndef device_exist():\n    ret1, log = log_os_system(\"ls \"+i2c_prefix+\"*0070\", 0)\n    ret2, log = log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as7326-platform-fan.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as7326-platform-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Stop as7326-platform-init.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Disable as7326-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as7326_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n", "add": 7, "remove": 7, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py", "badparts": ["import subprocess", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as7326-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py clean\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7326-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"clean\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"install\"])\n     if status:\n         print(\"accton_as7326_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Enable as7326-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as7326-platform-monitor-fan.service failed %d\"%status)\n         return False\n         \n-    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as7326-platform-monitor-psu.service failed %d\"%status)\n         return False\n", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py install\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as7326-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-psu.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"install\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7326-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-psu.service\"])"]}, {"diff": "\n     return True\n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service fa", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}], "source": "\n import subprocess def check_pddf_support(): return True def stop_platform_svc(): status, output=subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-fan.service\") if status: print(\"Stop as7326-platform-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-psu.service\") if status: print(\"Stop as7326-platform-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor.service\") if status: print(\"Stop as7326-platform-init.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl disable as7326-platform-monitor.service\") if status: print(\"Disable as7326-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py clean\") if status: print(\"accton_as7326_util.py clean command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status) return False return True def start_platform_svc(): status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py install\") if status: print(\"accton_as7326_util.py install command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl enable as7326-platform-monitor.service\") if status: print(\"Enable as7326-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-fan.service\") if status: print(\"Start as7326-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-psu.service\") if status: print(\"Start as7326-platform-monitor-psu.service failed %d\"%status) return False return True def start_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print(\"Start pddf-platform-init.service failed %d\"%status) return False return True def stop_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service failed %d\"%status) return False return True def main(): print(\"stop_platform_svc\") stop_platform_svc() print(\"stop_platform_pddf\") stop_platform_pddf() if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services. \n# This will be used while switching the pddf->non-pddf mode and vice versa\n\nimport subprocess\n\ndef check_pddf_support():\n    return True\n\ndef stop_platform_svc():\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-fan.service\")\n    if status:\n        print(\"Stop as7326-platform-fan.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-psu.service\")\n    if status:\n        print(\"Stop as7326-platform-psu.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor.service\")\n    if status:\n        print(\"Stop as7326-platform-init.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as7326-platform-monitor.service\")\n    if status:\n        print(\"Disable as7326-platform-monitor.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py clean\")\n    if status:\n        print(\"accton_as7326_util.py clean command failed %d\"%status)\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n        return False\n\n    return True\n    \ndef start_platform_svc():\n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py install\")\n    if status:\n        print(\"accton_as7326_util.py install command failed %d\"%status)\n        return False\n\n    status, output = subprocess.getstatusoutput(\"systemctl enable as7326-platform-monitor.service\")\n    if status:\n        print(\"Enable as7326-platform-monitor.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-fan.service\")\n    if status:\n        print(\"Start as7326-platform-monitor-fan.service failed %d\"%status)\n        return False\n        \n    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-psu.service\")\n    if status:\n        print(\"Start as7326-platform-monitor-psu.service failed %d\"%status)\n        return False\n\n    return True\n\ndef start_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print(\"Start pddf-platform-init.service failed %d\"%status)\n        return False\n    \n    return True\n\ndef stop_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service failed %d\"%status)\n        return False\n\n    return True\n\ndef main():\n    print(\"stop_platform_svc\")\n    stop_platform_svc()\n    #print\"start_platform_svc\"\n    #start_platform_svc()\n    #print\"start_platform_pddf\"\n    #start_platform_pddf()\n    print(\"stop_platform_pddf\")\n    stop_platform_pddf()\n    #pass\n\nif __name__ == \"__main__\":\n    main()\n\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import commands\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = commands.getstatusoutput(\"systemctl stop as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Stop as7712-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl disable as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Disable as7712-platform-init.service failed %d\"%status)\n         return False\n     \n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"clean\"])\n     if status:\n-        print(\"accton_as7712_util.py clean command failed %d\"%status)\n+        print(\"accton_as7712_util.py clean failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n", "add": 6, "remove": 6, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py", "badparts": ["import commands", "    status, output = commands.getstatusoutput(\"systemctl stop as7712-platform-init.service\")", "    status, output = commands.getstatusoutput(\"systemctl disable as7712-platform-init.service\")", "    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py clean\")", "        print(\"accton_as7712_util.py clean command failed %d\"%status)", "    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7712-platform-init.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7712-platform-init.service\"])", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"clean\"])", "        print(\"accton_as7712_util.py clean failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n     \n def start_platform_svc():\n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"install\"])\n     if status:\n-        print(\"accton_as7712_util.py install command failed %d\"%status)\n+        print(\"accton_as7712_util.py install failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Enable as7712-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Start as7712-platform-init.service failed %d\"%status)\n         return False\n", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py install\")", "        print(\"accton_as7712_util.py install command failed %d\"%status)", "    status, output = commands.getstatusoutput(\"systemctl enable as7712-platform-init.service\")", "    status, output = commands.getstatusoutput(\"systemctl start as7712-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"install\"])", "        print(\"accton_as7712_util.py install failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7712-platform-init.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7712-platform-init.service\"])"]}, {"diff": "\n     return True\n \n def start_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n \n def stop_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service f", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}], "source": "\n import commands def check_pddf_support(): return True def stop_platform_svc(): status, output=commands.getstatusoutput(\"systemctl stop as7712-platform-init.service\") if status: print(\"Stop as7712-platform-init.service failed %d\"%status) return False status, output=commands.getstatusoutput(\"systemctl disable as7712-platform-init.service\") if status: print(\"Disable as7712-platform-init.service failed %d\"%status) return False status, output=commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py clean\") if status: print(\"accton_as7712_util.py clean command failed %d\"%status) return False status, output=commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status) return False return True def start_platform_svc(): status, output=commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py install\") if status: print(\"accton_as7712_util.py install command failed %d\"%status) return False status, output=commands.getstatusoutput(\"systemctl enable as7712-platform-init.service\") if status: print(\"Enable as7712-platform-init.service failed %d\"%status) return False status, output=commands.getstatusoutput(\"systemctl start as7712-platform-init.service\") if status: print(\"Start as7712-platform-init.service failed %d\"%status) return False return True def start_platform_pddf(): status, output=commands.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print(\"Start pddf-platform-init.service failed %d\"%status) return False return True def stop_platform_pddf(): status, output=commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service failed %d\"%status) return False return True def main(): pass if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services. \n# This will be used while switching the pddf->non-pddf mode and vice versa\nimport commands\n\ndef check_pddf_support():\n    return True\n\ndef stop_platform_svc():\n    status, output = commands.getstatusoutput(\"systemctl stop as7712-platform-init.service\")\n    if status:\n        print(\"Stop as7712-platform-init.service failed %d\"%status)\n        return False\n    status, output = commands.getstatusoutput(\"systemctl disable as7712-platform-init.service\")\n    if status:\n        print(\"Disable as7712-platform-init.service failed %d\"%status)\n        return False\n    \n    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py clean\")\n    if status:\n        print(\"accton_as7712_util.py clean command failed %d\"%status)\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n        return False\n\n    return True\n    \ndef start_platform_svc():\n    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py install\")\n    if status:\n        print(\"accton_as7712_util.py install command failed %d\"%status)\n        return False\n\n    status, output = commands.getstatusoutput(\"systemctl enable as7712-platform-init.service\")\n    if status:\n        print(\"Enable as7712-platform-init.service failed %d\"%status)\n        return False\n    status, output = commands.getstatusoutput(\"systemctl start as7712-platform-init.service\")\n    if status:\n        print(\"Start as7712-platform-init.service failed %d\"%status)\n        return False\n\n    return True\n\ndef start_platform_pddf():\n    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print(\"Start pddf-platform-init.service failed %d\"%status)\n        return False\n    \n    return True\n\ndef stop_platform_pddf():\n    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service failed %d\"%status)\n        return False\n\n    return True\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py": {"changes": [{"diff": "\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', line", "add": 6, "remove": 6, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py", "badparts": ["    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cdump -y 0 0x42 s 0x9a\"", "        status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]", "        status, output = getstatusoutput_noshell(cmd)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes show : show all systen status sff : dump SFP eeprom set : change board setting with fan|led|sfp \"\"\" import subprocess import getopt import sys import logging import re import time PROJECT_NAME='as7716_32x' version='0.0.1' verbose=False DEBUG=False args=[] ALL_DEVICE={} DEVICE_NO={'led':5, 'fan1':1, 'fan2':1,'fan3':1,'fan4':1,'fan5':1,'thermal':3, 'psu':2, 'sfp':54} led_prefix='/sys/devices/platform/as7716_32x_led/leds/accton_'+PROJECT_NAME+'_led::' fan_prefix='/sys/devices/platform/as7716_32x_' hwmon_types={'led':['diag','fan','loc','psu1','psu2'], 'fan1':['fan'], 'fan2':['fan'], 'fan3':['fan'], 'fan4':['fan'], 'fan5':['fan'], } hwmon_nodes={'led':['brightness'], 'fan1':['fan_duty_cycle_percentage', 'fan1_fault', 'fan1_speed_rpm', 'fan1_direction', 'fanr1_fault', 'fanr1_speed_rpm'], 'fan2':['fan_duty_cycle_percentage','fan2_fault', 'fan2_speed_rpm', 'fan2_direction', 'fanr2_fault', 'fanr2_speed_rpm'], 'fan3':['fan_duty_cycle_percentage','fan3_fault', 'fan3_speed_rpm', 'fan3_direction', 'fanr3_fault', 'fanr3_speed_rpm'], 'fan4':['fan4_duty_cycle_percentage','fan4_fault', 'fan4_speed_rpm', 'fan4_direction', 'fanr4_fault', 'fanr4_speed_rpm'], 'fan5':['fan_duty_cycle_percentage','fan5_fault', 'fan5_speed_rpm', 'fan5_direction', 'fanr5_fault', 'fanr5_speed_rpm'], \t } hwmon_prefix={'led': led_prefix, 'fan1': fan_prefix, 'fan2': fan_prefix, 'fan3': fan_prefix, 'fan4': fan_prefix, 'fan5': fan_prefix, } i2c_prefix='/sys/bus/i2c/devices/' i2c_bus={'thermal':['10-0048','10-0049', '10-004a'], 'psu':['17-0050','18-0053'], 'sfp':['-0050']} i2c_nodes={ 'thermal':['hwmon/hwmon*/temp1_input'], 'psu':['psu_present ', 'psu_power_good'] , 'sfp':['sfp_is_present ', 'sfp_tx_disable']} sfp_map=[29, 30, 31, 32, 34, 33, 36, 35, 25, 26, 27, 28, 37, 38, 39, 40, 41, 42, 43, 44, 53, 54, 55, 56, 45, 46, 47, 48, 49, 50, 51, 52] mknod=[ 'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo as7716_32x_fan 0x66 > /sys/bus/i2c/devices/i2c-9/new_device', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-10/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-10/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-10/new_device', 'echo as7716_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-11/new_device', 'echo accton_i2c_cpld 0x62 > /sys/bus/i2c/devices/i2c-12/new_device', 'echo accton_i2c_cpld 0x64 > /sys/bus/i2c/devices/i2c-13/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo as7716_32x_psu1 0x53 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-18/new_device', 'echo as7716_32x_psu2 0x50> /sys/bus/i2c/devices/i2c-17/new_device', 'echo ym2651 0x58 > /sys/bus/i2c/devices/i2c-17/new_device', 'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-1/new_device', ] mknod2=[ 'echo as7716_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo accton_i2c_cpld 0x61 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo accton_i2c_cpld 0x62 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo as7716_32x_psu1 0x38 > /sys/bus/i2c/devices/i2c-57/new_device', 'echo cpr_4011_4mxx 0x3c > /sys/bus/i2c/devices/i2c-57/new_device', 'echo as7716_32x_psu1 0x50 > /sys/bus/i2c/devices/i2c-57/new_device', 'echo ym2401 0x58 > /sys/bus/i2c/devices/i2c-57/new_device', 'echo as7716_32x_psu2 0x3b > /sys/bus/i2c/devices/i2c-58/new_device', 'echo cpr_4011_4mxx 0x3f > /sys/bus/i2c/devices/i2c-58/new_device', 'echo as7716_32x_psu2 0x53 > /sys/bus/i2c/devices/i2c-58/new_device', 'echo ym2401 0x5b > /sys/bus/i2c/devices/i2c-58/new_device', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-61/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-62/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-63/new_device', 'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-1/new_device', ] FORCE=0 logging.basicConfig(filename=PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG) logging.basicConfig(level=logging.INFO) if DEBUG==True: print(sys.argv[0]) print('ARGV :', sys.argv[1:]) def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print(options) print(args) print(len(sys.argv)) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': do_install() elif arg=='clean': do_uninstall() elif arg=='show': device_traversal() elif arg=='sff': if len(args)!=2: show_eeprom_help() elif int(args[1])==0 or int(args[1]) > DEVICE_NO['sfp']: show_eeprom_help() else: show_eeprom(args[1]) return elif arg=='set': if len(args)<3: show_set_help() else: set_device(args[1:]) return else: show_help() return 0 def show_help(): print(__doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]}) sys.exit(0) def show_set_help(): cmd= sys.argv[0].split(\"/\")[-1]+\" \" +args[0] print(cmd +\"[led|sfp|fan]\") print(\" use \\\"\"+cmd +\" led 0-4 \\\" to set led color\") print(\" use \\\"\"+cmd +\" fan 0-100\\\" to set fan duty percetage\") print(\" use \\\"\"+cmd +\" sfp 1-32{0|1}\\\" to set sfp sys.exit(0) def dis_i2c_ir3570a(addr): cmd=\"i2cset -y 0 0x%x 0xE5 0x01\" % addr status, output=subprocess.getstatusoutput(cmd) cmd=\"i2cset -y 0 0x%x 0x12 0x02\" % addr status, output=subprocess.getstatusoutput(cmd) return status def ir3570_check(): cmd=\"i2cdump -y 0 0x42 s 0x9a\" try: status, output=subprocess.getstatusoutput(cmd) lines=output.split('\\n') hn=re.findall(r'\\w+', lines[-1]) version=int(hn[1], 16) if version==0x24: ret=dis_i2c_ir3570a(4) else: ret=0 except Exception as e: print(\"Error on ir3570_check() e:\" +str(e)) return -1 return ret def show_eeprom_help(): cmd= sys.argv[0].split(\"/\")[-1]+\" \" +args[0] print(\" use \\\"\"+cmd +\" 1-32 \\\" to dump sfp sys.exit(0) def my_log(txt): if DEBUG==True: print(\"[ACCTON DBG]: \"+txt) return def log_os_system(cmd, show): logging.info('Run:'+cmd) status=1 output=\"\" status, output=subprocess.getstatusoutput(cmd) my_log(cmd +\"with result:\" +str(status)) my_log(\"cmd:\" +cmd) my_log(\" output:\"+output) if status: logging.info('Failed:'+cmd) if show: print(('Failed:'+cmd)) return status, output def driver_inserted(): ret, lsmod=log_os_system(\"ls /sys/module/*accton*\", 0) logging.info('mods:'+lsmod) if ret: return False else: return True kos=[ 'depmod -ae', 'modprobe i2c_dev', 'modprobe i2c_mux_pca954x force_deselect_on_exit=1', 'modprobe accton_i2c_cpld', 'modprobe cpr_4011_4mxx', 'modprobe ym2651y', 'modprobe accton_as7716_32x_cpld1', 'modprobe accton_as7716_32x_fan', 'modprobe accton_as7716_32x_leds', 'modprobe accton_as7716_32x_psu'] def driver_install(): global FORCE for i in range(0,len(kos)): status, output=log_os_system(kos[i], 1) if status: if FORCE==0: return status return 0 def driver_uninstall(): global FORCE for i in range(0,len(kos)): rm=kos[-(i+1)] lst=rm.split(\" \") if len(lst) > 2: del(lst[2:]) rm=\" \".join(lst) rm=rm.replace(\"modprobe\", \"modprobe -rq\") rm=rm.replace(\"insmod\", \"rmmod\") status, output=log_os_system(rm, 1) if status: if FORCE==0: return status return 0 def i2c_order_check(): tmp=\"echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-1/new_device\" status, output=log_os_system(tmp, 0) if not device_exist(): order=1 else: order=0 tmp=\"echo 0x70 > /sys/bus/i2c/devices/i2c-1/delete_device\" status, output=log_os_system(tmp, 0) return order def device_install(): global FORCE for i in range(0,len(mknod)): if mknod[i].find('pca954') !=-1: time.sleep(2) status, output=log_os_system(mknod[i], 1) if status: print(output) if FORCE==0: return status for i in range(0,len(sfp_map)): status, output=log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1) if status: print(output) if FORCE==0: return status status, output=log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1) if status: print(output) if FORCE==0: return status return def device_uninstall(): global FORCE status, output=log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0) if status==0: I2C_ORDER=1 else: \tI2C_ORDER=0 for i in range(0,len(sfp_map)): target=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\" status, output=log_os_system(\"echo 0x50 > \"+target, 1) if status: print(output) if FORCE==0: return status if I2C_ORDER==0: nodelist=mknod else: nodelist=mknod2 for i in range(len(nodelist)): target=nodelist[-(i+1)] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status return def system_ready(): if driver_inserted()==False: return False if not device_exist(): print(\"not device_exist()\") return False return True def do_install(): if driver_inserted()==False: status=driver_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" drivers detected....\") ir3570_check() if not device_exist(): status=device_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" devices detected....\") return def do_uninstall(): if not device_exist(): print(PROJECT_NAME.upper() +\" has no device installed....\") else: print(\"Removing device....\") status=device_uninstall() if status: if FORCE==0: return status if driver_inserted()==False: print(PROJECT_NAME.upper() +\" has no driver installed....\") else: print(\"Removing installed driver....\") status=driver_uninstall() if status: if FORCE==0: return status return def devices_info(): global DEVICE_NO global ALL_DEVICE global i2c_bus, hwmon_types for key in DEVICE_NO: ALL_DEVICE[key]={} for i in range(0,DEVICE_NO[key]): ALL_DEVICE[key][key+str(i+1)]=[] for key in i2c_bus: buses=i2c_bus[key] nodes=i2c_nodes[key] for i in range(0,len(buses)): for j in range(0,len(nodes)): if 'fan'==key: for k in range(0,DEVICE_NO[key]): node=key+str(k+1) path=i2c_prefix+buses[i]+\"/fan\"+str(k+1)+\"_\"+nodes[j] my_log(node+\": \"+path) ALL_DEVICE[key][node].append(path) elif 'sfp'==key: for k in range(0,DEVICE_NO[key]): node=key+str(k+1) path=i2c_prefix+str(sfp_map[k])+buses[i]+\"/\"+nodes[j] my_log(node+\": \"+path) ALL_DEVICE[key][node].append(path) else: node=key+str(i+1) path=i2c_prefix+buses[i]+\"/\"+nodes[j] my_log(node+\": \"+path) ALL_DEVICE[key][node].append(path) for key in hwmon_types: itypes=hwmon_types[key] nodes=hwmon_nodes[key] for i in range(0,len(itypes)): for j in range(0,len(nodes)): node=key+\"_\"+itypes[i] path=hwmon_prefix[key]+itypes[i]+\"/\"+nodes[j] my_log(node+\": \"+path) ALL_DEVICE[key][ key+str(i+1)].append(path) if DEBUG==True: for i in sorted(ALL_DEVICE.keys()): print((i+\": \")) for j in sorted(ALL_DEVICE[i].keys()): print((\" \"+j)) for k in(ALL_DEVICE[i][j]): print((\" \"+\" \"+k)) return def show_eeprom(index): if system_ready()==False: print(\"System's not ready.\") print(\"Please install first!\") return if len(ALL_DEVICE)==0: devices_info() node=ALL_DEVICE['sfp']['sfp'+str(index)][0] node=node.replace(node.split(\"/\")[-1], 'sfp_eeprom') ret, log=log_os_system(\"which hexdump\", 0) ret, log2=log_os_system(\"which busybox hexdump\", 0) if len(log): hex_cmd='hexdump' elif len(log2): hex_cmd=' busybox hexdump' else: log='Failed: no hexdump cmd!!' logging.info(log) print(log) return 1 print(node +\":\") ret, log=log_os_system(\"cat \"+node+\"| \"+hex_cmd+\" -C\", 1) if ret==0: print(log) else: print(\"**********device no found**********\") return def set_device(args): global DEVICE_NO global ALL_DEVICE if system_ready()==False: print(\"System's not ready.\") print(\"Please install first!\") return if len(ALL_DEVICE)==0: devices_info() if args[0]=='led': if int(args[1])>4: show_set_help() return for i in range(0,len(ALL_DEVICE['led'])): for k in(ALL_DEVICE['led']['led'+str(i+1)]): ret, log=log_os_system(\"echo \"+args[1]+\" >\"+k, 1) if ret: return ret elif args[0]=='fan': if int(args[1])>100: show_set_help() return node=ALL_DEVICE['fan1']['fan11'][0] node=node.replace(node.split(\"/\")[-1], 'fan1_duty_cycle_percentage') ret, log=log_os_system(\"cat \"+node, 1) if ret==0: print((\"Previous fan duty: \" +log.strip() +\"%\")) ret, log=log_os_system(\"echo \"+args[1]+\" >\"+node, 1) if ret==0: print((\"Current fan duty: \" +args[1] +\"%\")) return ret elif args[0]=='sfp': if int(args[1])> DEVICE_NO[args[0]] or int(args[1])==0: show_set_help() return if len(args)<2: show_set_help() return if int(args[2])>1: show_set_help() return for i in range(0,len(ALL_DEVICE[args[0]])): for j in ALL_DEVICE[args[0]][args[0]+str(args[1])]: if j.find('tx_disable')!=-1: ret, log=log_os_system(\"echo \"+args[2]+\" >\"+j, 1) if ret: return ret return def get_value(input): digit=re.findall('\\d+', input) return int(digit[0]) def device_traversal(): if system_ready()==False: print(\"System's not ready.\") print(\"Please install first!\") return if len(ALL_DEVICE)==0: devices_info() for i in sorted(ALL_DEVICE.keys()): print(\"============================================\") print((i.upper()+\": \")) print(\"============================================\") for j in sorted(list(ALL_DEVICE[i].keys()), key=get_value): print(\" \"+j+\":\", end=' ') for k in(ALL_DEVICE[i][j]): ret, log=log_os_system(\"cat \"+k, 0) func=k.split(\"/\")[-1].strip() func=re.sub(j+'_','',func,1) func=re.sub(i.lower()+'_','',func,1) if ret==0: print(func+\"=\"+log+\" \", end=' ') else: print(func+\"=\"+\"X\"+\" \", end=' ') print() print(\"----------------------------------------------------------------\") print() return def device_exist(): ret1, log=log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0) ret2, log=log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2016 Accton Networks, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean\ncommand:\n    install     : install drivers and generate related sysfs nodes\n    clean       : uninstall drivers and remove related sysfs nodes\n    show        : show all systen status\n    sff         : dump SFP eeprom\n    set         : change board setting with fan|led|sfp\n\"\"\"\n\nimport subprocess\nimport getopt\nimport sys\nimport logging\nimport re\nimport time\n\nPROJECT_NAME = 'as7716_32x'\nversion = '0.0.1'\nverbose = False\nDEBUG = False\nargs = []\nALL_DEVICE = {}\nDEVICE_NO = {'led':5, 'fan1':1, 'fan2':1,'fan3':1,'fan4':1,'fan5':1,'thermal':3, 'psu':2, 'sfp':54}\n\n\nled_prefix ='/sys/devices/platform/as7716_32x_led/leds/accton_'+PROJECT_NAME+'_led::'\nfan_prefix ='/sys/devices/platform/as7716_32x_'\nhwmon_types = {'led': ['diag','fan','loc','psu1','psu2'],\n               'fan1': ['fan'],\n               'fan2': ['fan'],\n               'fan3': ['fan'],\n               'fan4': ['fan'],\n               'fan5': ['fan'],\n              }\nhwmon_nodes = {'led': ['brightness'] ,\n               'fan1': ['fan_duty_cycle_percentage', 'fan1_fault', 'fan1_speed_rpm', 'fan1_direction', 'fanr1_fault', 'fanr1_speed_rpm'],\n               'fan2': ['fan_duty_cycle_percentage','fan2_fault', 'fan2_speed_rpm', 'fan2_direction', 'fanr2_fault', 'fanr2_speed_rpm'],\n               'fan3': ['fan_duty_cycle_percentage','fan3_fault', 'fan3_speed_rpm', 'fan3_direction', 'fanr3_fault', 'fanr3_speed_rpm'],\n               'fan4': ['fan4_duty_cycle_percentage','fan4_fault', 'fan4_speed_rpm', 'fan4_direction', 'fanr4_fault', 'fanr4_speed_rpm'],\n               'fan5': ['fan_duty_cycle_percentage','fan5_fault', 'fan5_speed_rpm', 'fan5_direction', 'fanr5_fault', 'fanr5_speed_rpm'],\n\t      }\nhwmon_prefix ={'led': led_prefix,\n               'fan1': fan_prefix,\n               'fan2': fan_prefix,\n               'fan3': fan_prefix,\n               'fan4': fan_prefix,\n               'fan5': fan_prefix,\n              }\n\ni2c_prefix = '/sys/bus/i2c/devices/'\ni2c_bus = {'thermal': ['10-0048','10-0049', '10-004a'] ,\n           'psu': ['17-0050','18-0053'],\n           'sfp': ['-0050']}\ni2c_nodes = {\n           'thermal': ['hwmon/hwmon*/temp1_input'] ,\n           'psu': ['psu_present ', 'psu_power_good']    ,\n           'sfp': ['sfp_is_present ', 'sfp_tx_disable']}\n\nsfp_map = [29, 30, 31, 32, 34, 33, 36, 35,\n          25, 26, 27, 28, 37, 38, 39, 40, \n          41, 42, 43, 44, 53, 54, 55, 56, \n          45, 46, 47, 48, 49, 50, 51, 52]\n\nmknod =[\n'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo as7716_32x_fan 0x66 > /sys/bus/i2c/devices/i2c-9/new_device',\n\n'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-10/new_device',\n'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-10/new_device',\n'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-10/new_device',\n\n'echo as7716_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-11/new_device',\n'echo accton_i2c_cpld 0x62 > /sys/bus/i2c/devices/i2c-12/new_device',\n'echo accton_i2c_cpld 0x64 > /sys/bus/i2c/devices/i2c-13/new_device',\n\n'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-2/new_device',\n\n# PSU-1\n'echo as7716_32x_psu1 0x53 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-18/new_device',\n\n# PSU-2\n'echo as7716_32x_psu2 0x50> /sys/bus/i2c/devices/i2c-17/new_device',\n'echo ym2651 0x58 > /sys/bus/i2c/devices/i2c-17/new_device',\n\n\n\n#EERPOM\n'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-1/new_device',\n]\n\nmknod2 =[\n'echo as7716_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo accton_i2c_cpld 0x61 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo accton_i2c_cpld 0x62 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-0/new_device',\n\n# PSU-1\n'echo as7716_32x_psu1 0x38 > /sys/bus/i2c/devices/i2c-57/new_device',\n'echo cpr_4011_4mxx  0x3c > /sys/bus/i2c/devices/i2c-57/new_device',\n'echo as7716_32x_psu1 0x50 > /sys/bus/i2c/devices/i2c-57/new_device',\n'echo ym2401 0x58 > /sys/bus/i2c/devices/i2c-57/new_device',\n\n# PSU-2\n'echo as7716_32x_psu2 0x3b > /sys/bus/i2c/devices/i2c-58/new_device',\n'echo cpr_4011_4mxx 0x3f > /sys/bus/i2c/devices/i2c-58/new_device',\n'echo as7716_32x_psu2 0x53 > /sys/bus/i2c/devices/i2c-58/new_device',\n'echo ym2401 0x5b > /sys/bus/i2c/devices/i2c-58/new_device',\n\n'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-61/new_device',\n'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-62/new_device',\n'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-63/new_device',\n\n#EERPOM\n'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-1/new_device',\n]\n\nFORCE = 0\nlogging.basicConfig(filename= PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG)\nlogging.basicConfig(level=logging.INFO)\n\n\nif DEBUG == True:\n    print(sys.argv[0])\n    print('ARGV      :', sys.argv[1:])\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n\n    if len(sys.argv)<2:\n        show_help()\n\n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:\n        print(options)\n        print(args)\n        print(len(sys.argv))\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n           do_install()\n        elif arg == 'clean':\n           do_uninstall()\n        elif arg == 'show':\n           device_traversal()\n        elif arg == 'sff':\n            if len(args)!=2:\n                show_eeprom_help()\n            elif int(args[1]) ==0 or int(args[1]) > DEVICE_NO['sfp']:\n                show_eeprom_help()\n            else:\n                show_eeprom(args[1])\n            return\n        elif arg == 'set':\n            if len(args)<3:\n                show_set_help()\n            else:\n                set_device(args[1:])\n            return\n        else:\n            show_help()\n\n\n    return 0\n\ndef show_help():\n    print(__doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]})\n    sys.exit(0)\n\ndef  show_set_help():\n    cmd =  sys.argv[0].split(\"/\")[-1]+ \" \"  + args[0]\n    print(cmd +\" [led|sfp|fan]\")\n    print(\"    use \\\"\"+ cmd + \" led 0-4 \\\"  to set led color\")\n    print(\"    use \\\"\"+ cmd + \" fan 0-100\\\" to set fan duty percetage\")\n    print(\"    use \\\"\"+ cmd + \" sfp 1-32 {0|1}\\\" to set sfp# tx_disable\")\n    sys.exit(0)\n\ndef dis_i2c_ir3570a(addr):\n    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef ir3570_check():\n    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n    try:\n        status, output = subprocess.getstatusoutput(cmd)\n        lines = output.split('\\n')\n        hn = re.findall(r'\\w+', lines[-1])\n        version = int(hn[1], 16)\n        if version == 0x24:  #only for ir3570a\n            ret = dis_i2c_ir3570a(4)\n        else:\n            ret = 0\n    except Exception as e:\n        print(\"Error on ir3570_check() e:\" + str(e))\n        return -1\n    return ret\n\ndef  show_eeprom_help():\n    cmd =  sys.argv[0].split(\"/\")[-1]+ \" \"  + args[0]\n    print(\"    use \\\"\"+ cmd + \" 1-32 \\\" to dump sfp# eeprom\")\n    sys.exit(0)\n\ndef my_log(txt):\n    if DEBUG == True:\n        print(\"[ACCTON DBG]: \"+txt)\n    return\n\ndef log_os_system(cmd, show):\n    logging.info('Run :'+cmd)\n    status = 1\n    output = \"\"\n    status, output = subprocess.getstatusoutput(cmd)\n    my_log (cmd +\"with result:\" + str(status))\n    my_log (\"cmd:\" + cmd)\n    my_log (\"      output:\"+output)\n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print(('Failed :'+cmd))\n    return  status, output\n\ndef driver_inserted():\n    ret, lsmod = log_os_system(\"ls /sys/module/*accton*\", 0)\n    logging.info('mods:'+lsmod)\n    if ret :\n        return False\n    else :\n        return True\n\n#'modprobe cpr_4011_4mxx',\n\nkos = [\n'depmod -ae',\n'modprobe i2c_dev',\n'modprobe i2c_mux_pca954x force_deselect_on_exit=1',\n'modprobe accton_i2c_cpld',\n'modprobe cpr_4011_4mxx',\n'modprobe ym2651y',\n'modprobe accton_as7716_32x_cpld1',\n'modprobe accton_as7716_32x_fan',\n'modprobe accton_as7716_32x_leds',\n'modprobe accton_as7716_32x_psu']\n\ndef driver_install():\n    global FORCE\n    for i in range(0,len(kos)):\n        status, output = log_os_system(kos[i], 1)\n        if status:\n            if FORCE == 0:\n                return status\n    return 0\n\ndef driver_uninstall():\n    global FORCE\n    for i in range(0,len(kos)):\n        #remove parameter if any\n        rm = kos[-(i+1)]\n        lst = rm.split(\" \")\n        if len(lst) > 2:\n            del(lst[2:])\n        rm = \" \".join(lst)\n\n        #Change to removing commands\n        rm = rm.replace(\"modprobe\", \"modprobe -rq\")\n        rm = rm.replace(\"insmod\", \"rmmod\")\n        status, output = log_os_system(rm, 1)\n        if status:\n            if FORCE == 0:\n                return status\n    return 0\n\n\n\ndef i2c_order_check():\n    # i2c bus 0 and 1 might be installed in different order.\n    # Here check if 0x76 is exist @ i2c-0\n    tmp = \"echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-1/new_device\"\n    status, output = log_os_system(tmp, 0)\n    if not device_exist():\n        order = 1\n    else:\n        order = 0\n    tmp = \"echo 0x70 > /sys/bus/i2c/devices/i2c-1/delete_device\"\n    status, output = log_os_system(tmp, 0)\n    return order\n\ndef device_install():\n    global FORCE\n\n    for i in range(0,len(mknod)):\n        #for pca932x need times to built new i2c buses\n        if mknod[i].find('pca954') != -1:\n            time.sleep(2)\n        \n        status, output = log_os_system(mknod[i], 1)        \n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n    \n    for i in range(0,len(sfp_map)):\n        status, output =log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n        status, output =log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n    return\n\ndef device_uninstall():\n    global FORCE\n\n    status, output =log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0)\n    if status==0:\n        I2C_ORDER=1\n    else:\n    \tI2C_ORDER=0\n\n    for i in range(0,len(sfp_map)):\n        target = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\"\n        status, output =log_os_system(\"echo 0x50 > \"+ target, 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    if I2C_ORDER==0:\n        nodelist = mknod\n    else:\n        nodelist = mknod2\n\n    for i in range(len(nodelist)):\n        target = nodelist[-(i+1)]\n        temp = target.split()\n        del temp[1]\n        temp[-1] = temp[-1].replace('new_device', 'delete_device')\n        status, output = log_os_system(\" \".join(temp), 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    return\n\ndef system_ready():\n    if driver_inserted() == False:        \n        return False\n    if not device_exist():\n        print(\"not device_exist()\")\n        return False\n    return True\n\ndef do_install():\n    if driver_inserted() == False:\n        status = driver_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print(PROJECT_NAME.upper()+\" drivers detected....\")\n\n    ir3570_check()\n\n    if not device_exist():\n        status = device_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print(PROJECT_NAME.upper()+\" devices detected....\")\n    return\n\ndef do_uninstall():\n    if not device_exist():\n        print(PROJECT_NAME.upper() +\" has no device installed....\")\n    else:\n        print(\"Removing device....\")\n        status = device_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    if driver_inserted()== False :\n        print(PROJECT_NAME.upper() +\" has no driver installed....\")\n    else:\n        print(\"Removing installed driver....\")\n        status = driver_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    return\n\ndef devices_info():\n    global DEVICE_NO\n    global ALL_DEVICE\n    global i2c_bus, hwmon_types\n    for key in DEVICE_NO:\n        ALL_DEVICE[key]= {}\n        for i in range(0,DEVICE_NO[key]):\n            ALL_DEVICE[key][key+str(i+1)] = []\n\n    for key in i2c_bus:\n        buses = i2c_bus[key]\n        nodes = i2c_nodes[key]\n        for i in range(0,len(buses)):\n            for j in range(0,len(nodes)):\n                if  'fan' == key:\n                    for k in range(0,DEVICE_NO[key]):\n                        node = key+str(k+1)\n                        path = i2c_prefix+ buses[i]+\"/fan\"+str(k+1)+\"_\"+ nodes[j]\n                        my_log(node+\": \"+ path)\n                        ALL_DEVICE[key][node].append(path)\n                elif  'sfp' == key:\n                    for k in range(0,DEVICE_NO[key]):\n                        node = key+str(k+1)\n                        path = i2c_prefix+ str(sfp_map[k])+ buses[i]+\"/\"+ nodes[j]\n                        my_log(node+\": \"+ path)\n                        ALL_DEVICE[key][node].append(path)\n                else:\n                    node = key+str(i+1)\n                    path = i2c_prefix+ buses[i]+\"/\"+ nodes[j]\n                    my_log(node+\": \"+ path)\n                    ALL_DEVICE[key][node].append(path)\n\n    for key in hwmon_types:\n        itypes = hwmon_types[key]\n        nodes = hwmon_nodes[key]\n        for i in range(0,len(itypes)):\n            for j in range(0,len(nodes)):\n                node = key+\"_\"+itypes[i]\n                path = hwmon_prefix[key]+ itypes[i]+\"/\"+ nodes[j]\n                my_log(node+\": \"+ path)\n                ALL_DEVICE[key][ key+str(i+1)].append(path)\n\n    #show dict all in the order\n    if DEBUG == True:\n        for i in sorted(ALL_DEVICE.keys()):\n            print((i+\": \"))\n            for j in sorted(ALL_DEVICE[i].keys()):\n                print((\"   \"+j))\n                for k in (ALL_DEVICE[i][j]):\n                    print((\"   \"+\"   \"+k))\n    return\n\ndef show_eeprom(index):\n    if system_ready()==False:\n        print(\"System's not ready.\")\n        print(\"Please install first!\")\n        return\n\n    if len(ALL_DEVICE)==0:\n        devices_info()\n    node = ALL_DEVICE['sfp'] ['sfp'+str(index)][0]\n    node = node.replace(node.split(\"/\")[-1], 'sfp_eeprom')\n    # check if got hexdump command in current environment\n    ret, log = log_os_system(\"which hexdump\", 0)\n    ret, log2 = log_os_system(\"which busybox hexdump\", 0)\n    if len(log):\n        hex_cmd = 'hexdump'\n    elif len(log2):\n        hex_cmd = ' busybox hexdump'\n    else:\n        log = 'Failed : no hexdump cmd!!'\n        logging.info(log)\n        print(log)\n        return 1\n\n    print(node + \":\")\n    ret, log = log_os_system(\"cat \"+node+\"| \"+hex_cmd+\" -C\", 1)\n    if ret==0:\n        print(log)\n    else:\n        print(\"**********device no found**********\")\n    return\n\ndef set_device(args):\n    global DEVICE_NO\n    global ALL_DEVICE\n    if system_ready()==False:\n        print(\"System's not ready.\")\n        print(\"Please install first!\")\n        return\n\n    if len(ALL_DEVICE)==0:\n        devices_info()\n\n    if args[0]=='led':\n        if int(args[1])>4:\n            show_set_help()\n            return\n        #print  ALL_DEVICE['led']\n        for i in range(0,len(ALL_DEVICE['led'])):\n            for k in (ALL_DEVICE['led']['led'+str(i+1)]):\n                ret, log = log_os_system(\"echo \"+args[1]+\" >\"+k, 1)\n                if ret:\n                    return ret\n    elif args[0]=='fan':\n        if int(args[1])>100:\n            show_set_help()\n            return\n        #print  ALL_DEVICE['fan']\n        #fan1~6 is all fine, all fan share same setting\n        node = ALL_DEVICE['fan1'] ['fan11'][0]\n        node = node.replace(node.split(\"/\")[-1], 'fan1_duty_cycle_percentage')\n        ret, log = log_os_system(\"cat \"+ node, 1)\n        if ret==0:\n            print((\"Previous fan duty: \" + log.strip() +\"%\"))\n        ret, log = log_os_system(\"echo \"+args[1]+\" >\"+node, 1)\n        if ret==0:\n            print((\"Current fan duty: \" + args[1] +\"%\"))\n        return ret\n    elif args[0]=='sfp':\n        if int(args[1])> DEVICE_NO[args[0]] or int(args[1])==0:\n            show_set_help()\n            return\n        if len(args)<2:\n            show_set_help()\n            return\n\n        if int(args[2])>1:\n            show_set_help()\n            return\n\n        #print  ALL_DEVICE[args[0]]\n        for i in range(0,len(ALL_DEVICE[args[0]])):\n            for j in ALL_DEVICE[args[0]][args[0]+str(args[1])]:\n                if j.find('tx_disable')!= -1:\n                    ret, log = log_os_system(\"echo \"+args[2]+\" >\"+ j, 1)\n                    if ret:\n                        return ret\n\n    return\n\n#get digits inside a string.\n#Ex: 31 for \"sfp31\"\ndef get_value(input):\n    digit = re.findall('\\d+', input)\n    return int(digit[0])\n\ndef device_traversal():\n    if system_ready()==False:\n        print(\"System's not ready.\")\n        print(\"Please install first!\")\n        return\n\n    if len(ALL_DEVICE)==0:\n        devices_info()\n    for i in sorted(ALL_DEVICE.keys()):\n        print(\"============================================\")\n        print((i.upper()+\": \"))\n        print(\"============================================\")\n\n        for j in sorted(list(ALL_DEVICE[i].keys()), key=get_value):\n            print(\"   \"+j+\":\", end=' ')\n            for k in (ALL_DEVICE[i][j]):\n                ret, log = log_os_system(\"cat \"+k, 0)\n                func = k.split(\"/\")[-1].strip()\n                func = re.sub(j+'_','',func,1)\n                func = re.sub(i.lower()+'_','',func,1)\n                if ret==0:\n                    print(func+\"=\"+log+\" \", end=' ')\n                else:\n                    print(func+\"=\"+\"X\"+\" \", end=' ')\n            print()\n            print(\"----------------------------------------------------------------\")\n\n\n        print()\n    return\n\ndef device_exist():\n    ret1, log = log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0)\n    ret2, log = log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py": {"changes": [{"diff": "\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py", "badparts": ["               os.system('reboot')           "], "goodparts": ["               subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}], "source": "\n try: import os import getopt import sys import logging import logging.config import logging.handlers import time from as7726_32x.fanutil import FanUtil from as7726_32x.thermalutil import ThermalUtil except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as7726_32x_monitor' global log_file global log_level class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False fan_policy_state=1 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0, 0, 0, 0, 0] temp_test_data=0 class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 logging.debug('temp=%d', temp) for i in range(0, len(policy)): if temp > policy[i][2]: if temp <=policy[i][3]: state=i logging.debug('temp=%d >=policy[%d][2]=%d, temp=%d < policy[%d][3]=%d', temp, i, policy[i][2], temp, i, policy[i][3]) logging.debug('fan_state=%d', state) break return state def manage_fans(self): global fan_policy_state global fan_fail global test_temp global test_temp_list global alarm_state global temp_test_data LEVEL_FAN_DEF=0 LEVEL_FAN_MID=1 LEVEL_FAN_MAX=2 LEVEL_TEMP_HIGH=3 LEVEL_TEMP_CRITICAL=4 fan_policy_f2b={ LEVEL_FAN_DEF: [38, 0x4, 0, 38000], LEVEL_FAN_MID: [63, 0x6, 38000, 46000], LEVEL_FAN_MAX: [100, 0xE, 46000, 58000], LEVEL_TEMP_HIGH: [100, 0xE, 58000, 66000], LEVEL_TEMP_CRITICAL:[100, 0xE, 58000, 200000], } fan_policy_b2f={ LEVEL_FAN_DEF: [38, 0x4, 0, 34000], LEVEL_FAN_MID: [63, 0x8, 34000, 44000], LEVEL_FAN_MAX: [100, 0xE, 44000, 59000], LEVEL_TEMP_HIGH: [100, 0xE, 59000, 67000], LEVEL_TEMP_CRITICAL:[100, 0xE, 59000, 200000], } fan_policy=fan_policy_f2b thermal=ThermalUtil() fan=FanUtil() fan_dir=fan.get_fan_dir(1) if fan_dir==1: fan_dri=1 else: fan_policy=fan_policy_b2f ori_pwm=fan.get_fan_duty_cycle() new_pwm=0 logging.debug('fan_dir=%d, ori_pwm=%d', fan_dir, ori_pwm) logging.debug('test_temp=%d', test_temp) if test_temp==0: temp1=thermal._get_thermal_val(1) temp2=thermal._get_thermal_val(2) temp3=thermal._get_thermal_val(3) temp4=thermal._get_thermal_val(4) temp5=thermal._get_thermal_val(5) else: temp1=test_temp_list[0] temp2=test_temp_list[1] temp3=test_temp_list[2] temp4=test_temp_list[3] temp5=test_temp_list[4] fan_fail=0 if temp3==0: temp_get=50000 logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%') elif temp4==0: temp_get=50000 logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%') else: temp_get=(temp3 +temp4)/2 ori_state=fan_policy_state if test_temp!=0: temp_test_data=temp_test_data+1000 temp_get=temp_get +temp_test_data logging.debug('Unit test:temp_get=%d', temp_get) fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy) logging.debug('lm75_48=%d, lm75_49=%d, lm75_4a=%d, lm_4b=%d, lm_4c=%d', temp1,temp2,temp3,temp4,temp5) logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state) new_pwm=fan_policy[fan_policy_state][0] if fan_fail==0: logging.debug('new_fan_cycle=%d', new_pwm) if fan_fail==0: if new_pwm!=ori_pwm: fan.set_fan_duty_cycle(new_pwm) logging.info('Set fan speed from %d to %d', ori_pwm, new_pwm) for i in range(fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1): if fan.get_fan_status(i)==0: new_pwm=100 logging.debug('fan_%d fail, set pwm to 100',i) if test_temp==0: fan_fail=1 fan.set_fan_duty_cycle(new_pwm) break else: fan_fail=0 new_state=fan_policy_state if ori_state==LEVEL_FAN_DEF: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected, reboot DUT') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MID: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MAX: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if alarm_state==1: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_HIGH: if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if new_state <=LEVEL_FAN_MID: logging.warning('Alarm for temperature high is cleared') alarm_state=0 if new_state <=LEVEL_FAN_MAX: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_CRITICAL: if new_state <=LEVEL_FAN_MAX: logging.warning('Alarm for temperature critical is cleared') return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv,'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv)!=7: print(\"temp test, need input six temp\") return 0 i=0 for x in range(2, 7): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) fan=FanUtil() fan.set_fan_duty_cycle(38) print(\"set default fan speed to 37.5%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(5) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2017 Accton Technology Corporation\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    mm/dd/yyyy (A.D.)#   \n#    4/20/2018: Jostar modify for as7726_32x\n#    12/03/2018:Jostar modify for as7726_32x thermal plan\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import getopt\n    import sys\n    import logging\n    import logging.config\n    import logging.handlers\n    import time  # this is only being used as part of the example\n    from as7726_32x.fanutil import FanUtil\n    from as7726_32x.thermalutil import ThermalUtil\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as7726_32x_monitor'\n\nglobal log_file\nglobal log_level\n\n \n#  Air Flow Front to Back :\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 <=38C : Keep 37.5%(0x04) Fan speed\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 38C : Change Fan speed from 37.5%(0x04) to 62.5%(0x08)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 46C : Change Fan speed from 62.5%(0x08) to 100%(0x0E)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 58C : Send alarm message\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 66C : Shut down system\n#  One Fan fail : Change Fan speed to 100%(0x0E)\n\n\n#  Air Flow Back to Front :\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 <=34C : Keep 37.5%(0x04) Fan speed\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 34C : Change Fan speed from 37.5%(0x04) to 62.5%(0x08)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 44C : Change Fan speed from 62.5%(0x08) to 100%(0x0E)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 59C : Send alarm message\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 67C : Shut down system\n#  One Fan fail:  Change Fan speed to 100%(0x0E)\n#  sensor_LM75_CPU == sensor_LM75_4B\n \n     \nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n \n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n     \n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args: # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\n\nfan_policy_state=1\nfan_fail=0\nalarm_state = 0 #0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0, 0, 0, 0, 0]\ntemp_test_data=0\n# Make a class we can use to capture stdout and sterr in the log\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm=0\n    ori_pwm = 0\n    default_pwm=0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format= '[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = handler = logging.handlers.SysLogHandler(address = '/dev/log')\n        sys_handler.setLevel(logging.WARNING)       \n        logging.getLogger('').addHandler(sys_handler)\n          \n    def get_state_from_fan_policy(self, temp, policy):\n        state=0\n        \n        logging.debug('temp=%d', temp)\n        for i in range(0, len(policy)):\n            if temp > policy[i][2]:\n                if temp <= policy[i][3]:\n                    state =i\n                    logging.debug ('temp=%d >= policy[%d][2]=%d,  temp=%d < policy[%d][3]=%d' , temp, i, policy[i][2], temp, i, policy[i][3])\n                    logging.debug ('fan_state=%d', state)\n                    break\n        \n        return state\n\n    def manage_fans(self):\n       \n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list        \n        global alarm_state\n        global temp_test_data\n        \n        LEVEL_FAN_DEF=0\n        LEVEL_FAN_MID=1       \n        LEVEL_FAN_MAX=2\n        LEVEL_TEMP_HIGH=3\n        LEVEL_TEMP_CRITICAL=4\n        \n        fan_policy_f2b = {\n           LEVEL_FAN_DEF:       [38,  0x4, 0,     38000],\n           LEVEL_FAN_MID:       [63,  0x6, 38000, 46000],\n           LEVEL_FAN_MAX:       [100, 0xE, 46000, 58000],\n           LEVEL_TEMP_HIGH:     [100, 0xE, 58000, 66000],\n           LEVEL_TEMP_CRITICAL: [100, 0xE, 58000, 200000],\n        }\n        fan_policy_b2f = {\n           LEVEL_FAN_DEF:       [38,  0x4, 0,     34000],\n           LEVEL_FAN_MID:       [63,  0x8, 34000, 44000],\n           LEVEL_FAN_MAX:       [100, 0xE, 44000, 59000],\n           LEVEL_TEMP_HIGH:     [100, 0xE, 59000, 67000],\n           LEVEL_TEMP_CRITICAL: [100, 0xE, 59000, 200000],\n        }\n        \n        fan_policy = fan_policy_f2b\n        \n        thermal = ThermalUtil()\n        fan = FanUtil()\n        fan_dir=fan.get_fan_dir(1)            \n        if fan_dir == 1:\n            fan_dri=1 #something wrong, set fan_dir to default val\n        else:\n            fan_policy = fan_policy_b2f\n        \n        ori_pwm=fan.get_fan_duty_cycle()\n        new_pwm=0  \n        logging.debug('fan_dir=%d, ori_pwm=%d', fan_dir, ori_pwm)\n        logging.debug('test_temp=%d', test_temp)\n        if test_temp==0: \n            temp1 = thermal._get_thermal_val(1)\n            temp2 = thermal._get_thermal_val(2)\n            temp3 = thermal._get_thermal_val(3)\n            temp4 = thermal._get_thermal_val(4)\n            temp5 = thermal._get_thermal_val(5)            \n        else:\n            temp1 = test_temp_list[0]\n            temp2 = test_temp_list[1]\n            temp3 = test_temp_list[2]\n            temp4 = test_temp_list[3]\n            temp5 = test_temp_list[4]            \n            fan_fail=0\n       \n        if temp3==0:\n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%')\n        elif temp4==0:        \n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%')\n        else:    \n            temp_get= (temp3 + temp4)/2  # Use (sensor_LM75_4a + sensor_LM75_4b) /2 \n        ori_state=fan_policy_state\n        \n        if test_temp!=0:\n            temp_test_data=temp_test_data+1000\n            temp_get = temp_get + temp_test_data\n            logging.debug('Unit test:temp_get=%d', temp_get)\n        \n        fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy)\n                                \n        logging.debug('lm75_48=%d, lm75_49=%d, lm75_4a=%d, lm_4b=%d, lm_4c=%d', temp1,temp2,temp3,temp4,temp5)\n        logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state)\n        new_pwm = fan_policy[fan_policy_state][0]\n        if fan_fail==0:\n            logging.debug('new_fan_cycle=%d', new_pwm)\n        \n        if fan_fail==0:\n            if new_pwm!=ori_pwm:\n                fan.set_fan_duty_cycle(new_pwm)\n                logging.info('Set fan speed from %d to %d', ori_pwm, new_pwm)\n        \n        #Check Fan status\n        for i in range (fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1):\n            if fan.get_fan_status(i)==0:\n                new_pwm=100\n                logging.debug('fan_%d fail, set pwm to 100',i)                \n                if test_temp==0:\n                    fan_fail=1\n                    fan.set_fan_duty_cycle(new_pwm)\n                    break\n            else:\n                fan_fail=0\n        \n        new_state = fan_policy_state\n          \n        if ori_state==LEVEL_FAN_DEF:            \n           if new_state==LEVEL_TEMP_HIGH:\n               if alarm_state==0:\n                   logging.warning('Alarm for temperature high is detected')\n               alarm_state=1\n           if new_state==LEVEL_TEMP_CRITICAL:\n               logging.critical('Alarm for temperature critical is detected, reboot DUT')\n               time.sleep(2)\n               os.system('reboot')           \n        if ori_state==LEVEL_FAN_MID:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state=1 \n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n        if ori_state==LEVEL_FAN_MAX:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected') \n                alarm_state=1\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n            if alarm_state==1:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_HIGH:\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n            if new_state <= LEVEL_FAN_MID:\n                logging.warning('Alarm for temperature high is cleared')\n                alarm_state=0\n            if new_state <= LEVEL_FAN_MAX:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_CRITICAL:            \n            if new_state <= LEVEL_FAN_MAX:\n                logging.warning('Alarm for temperature critical is cleared')\n      \n        return True\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv,'hdlt:',['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg            \n        \n        if sys.argv[1]== '-t':\n            if len(sys.argv)!=7:\n                print(\"temp test, need input six temp\")\n                return 0\n            \n            i=0\n            for x in range(2, 7):\n               test_temp_list[i]= int(sys.argv[x])*1000\n               i=i+1\n            test_temp = 1   \n            log_level = logging.DEBUG\n            print(test_temp_list)                       \n    \n    fan = FanUtil()\n    fan.set_fan_duty_cycle(38)\n    print(\"set default fan speed to 37.5%\")\n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(5)\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    \n"}, "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py": {"changes": [{"diff": "\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py", "badparts": ["               os.system('reboot')           "], "goodparts": ["               subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high i", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}], "source": "\n try: import os import sys import getopt import logging import logging.config import logging.handlers import time from sonic_platform import platform except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as7726_32x_pddf_monitor' platform_chassis=None class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False fan_policy_state=1 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0, 0, 0, 0, 0] temp_test_data=0 class device_monitor(object): def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 logging.debug('temp=%d', temp) for i in range(0, len(policy)): if temp > policy[i][2]: if temp <=policy[i][3]: state=i logging.debug('temp=%d >=policy[%d][2]=%d, temp=%d < policy[%d][3]=%d', temp, i, policy[i][2], temp, i, policy[i][3]) logging.debug('fan_state=%d', state) break return state def manage_fans(self): global fan_policy_state global fan_fail global test_temp global test_temp_list global alarm_state global temp_test_data global platform_chassis LEVEL_FAN_DEF=0 LEVEL_FAN_MID=1 LEVEL_FAN_MAX=2 LEVEL_TEMP_HIGH=3 LEVEL_TEMP_CRITICAL=4 FAN_NUM_MAX=6 FANS_PERTRAY=2 fan_policy_f2b={ LEVEL_FAN_DEF: [38, 0x4, 0, 38000], LEVEL_FAN_MID: [63, 0x6, 38000, 46000], LEVEL_FAN_MAX: [100, 0xE, 46000, 58000], LEVEL_TEMP_HIGH: [100, 0xE, 58000, 66000], LEVEL_TEMP_CRITICAL:[100, 0xE, 58000, 200000], } fan_policy_b2f={ LEVEL_FAN_DEF: [38, 0x4, 0, 34000], LEVEL_FAN_MID: [63, 0x8, 34000, 44000], LEVEL_FAN_MAX: [100, 0xE, 44000, 59000], LEVEL_TEMP_HIGH: [100, 0xE, 59000, 67000], LEVEL_TEMP_CRITICAL:[100, 0xE, 59000, 200000], } fan_dir=platform_chassis.get_fan(0).get_direction() if fan_dir=='EXHAUST': fan_policy=fan_policy_f2b else: fan_policy=fan_policy_b2f ori_perc=platform_chassis.get_fan(0).get_speed() logging.debug('fan_dir=%s, ori_perc=%d, test_temp=%d', fan_dir, ori_perc, test_temp) if test_temp==0: temp4=platform_chassis.get_thermal(3).get_temperature()*1000 temp5=platform_chassis.get_thermal(4).get_temperature()*1000 else: temp4=test_temp_list[3] temp5=test_temp_list[4] fan_fail=0 if temp4==0: temp_get=50000 logging.debug('lm75_4a detect fail, so set temp_get=50000, let fan to 75%') elif temp5==0: temp_get=50000 logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%') else: temp_get=(temp4 +temp5)/2 ori_state=fan_policy_state if test_temp!=0: temp_test_data=temp_test_data+1000 temp_get=temp_get +temp_test_data logging.debug('Unit test:temp_get=%d', temp_get) fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy) logging.debug('lm75_4a=%d, lm_4b=%d', temp4,temp5) logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state) new_perc=fan_policy[fan_policy_state][0] if fan_fail==0: logging.debug('new_fan_cycle=%d', new_perc) if fan_fail==0: if new_perc!=ori_perc: platform_chassis.get_fan(0).set_speed(new_perc) logging.info('Set fan speed from %d to %d', ori_perc, new_perc) for i in range(FAN_NUM_MAX*FANS_PERTRAY): if not platform_chassis.get_fan(i).get_status() or not platform_chassis.get_fan(i).get_speed_rpm(): logging.debug('fan-%d status=%d, rpm=%d', i+1, platform_chassis.get_fan(i).get_status(), platform_chassis.get_fan(i).get_speed_rpm()) new_perc=100 logging.debug('fan_%d fail, set new_perc to 100',i+1) if test_temp==0: fan_fail=1 platform_chassis.get_fan(0).set_speed(new_perc) break else: fan_fail=0 new_state=fan_policy_state if ori_state==LEVEL_FAN_DEF: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected, reboot DUT') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MID: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MAX: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if alarm_state==1: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_HIGH: if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if new_state <=LEVEL_FAN_MID: logging.warning('Alarm for temperature high is cleared') alarm_state=0 if new_state <=LEVEL_FAN_MAX: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_CRITICAL: if new_state <=LEVEL_FAN_MAX: logging.warning('Alarm for temperature critical is cleared') return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv,'hdlt:',['lfile=']) except getopt.GetoptError: print(('Usage: %s[-d][-l <log_file>]' % sys.argv[0])) return 0 for opt, arg in opts: if opt=='-h': print(('Usage: %s[-d][-l <log_file>]' % sys.argv[0])) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv)!=7: print(\"temp test, need input six temp\") return 0 i=0 for x in range(2, 7): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) global platform_chassis platform_chassis=platform.Platform().get_chassis() platform_chassis.get_fan(0).set_speed(38) print(\"set default fan speed to 37.5%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(10) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2017 Accton Technology Corporation\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    mm/dd/yyyy (A.D.)#   \n#    4/20/2018: Jostar modify for as7726_32x\n#    12/03/2018:Jostar modify for as7726_32x thermal plan\n#    11/16/2020:Jostar modify for as7726_32x thermal plan based on PDDF\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import sys\n    import getopt\n    import logging\n    import logging.config\n    import logging.handlers\n    import time\n    from sonic_platform import platform\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as7726_32x_pddf_monitor'\n\nplatform_chassis = None\n \n#  Air Flow Front to Back :\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 <=38C : Keep 37.5%(0x04) Fan speed\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 38C : Change Fan speed from 37.5%(0x04) to 62.5%(0x08)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 46C : Change Fan speed from 62.5%(0x08) to 100%(0x0E)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 58C : Send alarm message\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 66C : Shut down system\n#  One Fan fail : Change Fan speed to 100%(0x0E)\n\n\n#  Air Flow Back to Front :\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 <=34C : Keep 37.5%(0x04) Fan speed\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 34C : Change Fan speed from 37.5%(0x04) to 62.5%(0x08)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 44C : Change Fan speed from 62.5%(0x08) to 100%(0x0E)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 59C : Send alarm message\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 67C : Shut down system\n#  One Fan fail:  Change Fan speed to 100%(0x0E)\n#  sensor_LM75_CPU == sensor_LM75_4B\n \n     \nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n \n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n     \n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args: # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\n\nfan_policy_state=1\nfan_fail=0\nalarm_state = 0 #0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0, 0, 0, 0, 0]\ntemp_test_data=0\n\n\n# Make a class we can use to capture stdout and sterr in the log\nclass device_monitor(object):\n        \n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format= '[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = logging.handlers.SysLogHandler(address = '/dev/log')\n        sys_handler.setLevel(logging.WARNING)       \n        logging.getLogger('').addHandler(sys_handler)\n          \n    def get_state_from_fan_policy(self, temp, policy):\n        state=0\n        \n        logging.debug('temp=%d', temp)\n        for i in range(0, len(policy)):\n            if temp > policy[i][2]:\n                if temp <= policy[i][3]:\n                    state =i\n                    logging.debug ('temp=%d >= policy[%d][2]=%d,  temp=%d < policy[%d][3]=%d' , temp, i, policy[i][2], temp, i, policy[i][3])\n                    logging.debug ('fan_state=%d', state)\n                    break\n        \n        return state\n\n    def manage_fans(self):\n       \n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list        \n        global alarm_state\n        global temp_test_data\n        global platform_chassis\n        \n        LEVEL_FAN_DEF=0\n        LEVEL_FAN_MID=1       \n        LEVEL_FAN_MAX=2\n        LEVEL_TEMP_HIGH=3\n        LEVEL_TEMP_CRITICAL=4\n        FAN_NUM_MAX = 6\n        FANS_PERTRAY=2\n        \n        fan_policy_f2b = {\n           LEVEL_FAN_DEF:       [38,  0x4, 0,     38000],\n           LEVEL_FAN_MID:       [63,  0x6, 38000, 46000],\n           LEVEL_FAN_MAX:       [100, 0xE, 46000, 58000],\n           LEVEL_TEMP_HIGH:     [100, 0xE, 58000, 66000],\n           LEVEL_TEMP_CRITICAL: [100, 0xE, 58000, 200000],\n        }\n        fan_policy_b2f = {\n           LEVEL_FAN_DEF:       [38,  0x4, 0,     34000],\n           LEVEL_FAN_MID:       [63,  0x8, 34000, 44000],\n           LEVEL_FAN_MAX:       [100, 0xE, 44000, 59000],\n           LEVEL_TEMP_HIGH:     [100, 0xE, 59000, 67000],\n           LEVEL_TEMP_CRITICAL: [100, 0xE, 59000, 200000],\n        }\n        \n        fan_dir= platform_chassis.get_fan(0).get_direction()\n        if fan_dir == 'EXHAUST':\n            fan_policy = fan_policy_f2b\n        else:\n            fan_policy = fan_policy_b2f\n        \n        ori_perc=platform_chassis.get_fan(0).get_speed()\n        #ori_perc=fan.get_fan_duty_cycle()\n        logging.debug('fan_dir=%s, ori_perc=%d, test_temp=%d', fan_dir, ori_perc, test_temp)\n        if test_temp==0:\n            temp4 = platform_chassis.get_thermal(3).get_temperature()*1000\n            temp5 = platform_chassis.get_thermal(4).get_temperature()*1000\n        else:\n            temp4 = test_temp_list[3]\n            temp5 = test_temp_list[4]            \n            fan_fail=0\n        \n        if temp4==0:\n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_4a detect fail, so set temp_get=50000, let fan to 75%')\n        elif temp5==0:        \n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%')\n        else:    \n            temp_get= (temp4 + temp5)/2  # Use (sensor_LM75_4a + sensor_LM75_4b) /2 \n            \n        ori_state=fan_policy_state\n        \n        if test_temp!=0:\n            temp_test_data=temp_test_data+1000\n            temp_get = temp_get + temp_test_data\n            logging.debug('Unit test:temp_get=%d', temp_get)\n        \n        fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy)\n                        \n        logging.debug('lm75_4a=%d, lm_4b=%d', temp4,temp5)\n        logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state)\n        new_perc = fan_policy[fan_policy_state][0]\n        if fan_fail==0:\n            logging.debug('new_fan_cycle=%d', new_perc)\n        \n        if fan_fail==0:\n            if new_perc!=ori_perc:\n                platform_chassis.get_fan(0).set_speed(new_perc)\n                logging.info('Set fan speed from %d to %d', ori_perc, new_perc)\n        \n        #Check Fan status\n        for i in range(FAN_NUM_MAX*FANS_PERTRAY):\n            if not platform_chassis.get_fan(i).get_status() or not platform_chassis.get_fan(i).get_speed_rpm():\n                logging.debug('fan-%d status=%d, rpm=%d', i+1, platform_chassis.get_fan(i).get_status(), platform_chassis.get_fan(i).get_speed_rpm())\n                new_perc=100\n                logging.debug('fan_%d fail, set new_perc to 100',i+1)                \n                if test_temp==0:\n                    fan_fail=1\n                    platform_chassis.get_fan(0).set_speed(new_perc)\n                    break\n            else:\n                fan_fail=0\n      \n        new_state = fan_policy_state\n        \n        if ori_state==LEVEL_FAN_DEF:            \n           if new_state==LEVEL_TEMP_HIGH:\n               if alarm_state==0:\n                   logging.warning('Alarm for temperature high is detected')\n               alarm_state=1\n           if new_state==LEVEL_TEMP_CRITICAL:\n               logging.critical('Alarm for temperature critical is detected, reboot DUT')\n               time.sleep(2)\n               os.system('reboot')           \n        if ori_state==LEVEL_FAN_MID:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state=1 \n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n        if ori_state==LEVEL_FAN_MAX:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected') \n                alarm_state=1\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n            if alarm_state==1:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_HIGH:\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n            if new_state <= LEVEL_FAN_MID:\n                logging.warning('Alarm for temperature high is cleared')\n                alarm_state=0\n            if new_state <= LEVEL_FAN_MAX:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_CRITICAL:            \n            if new_state <= LEVEL_FAN_MAX:\n                logging.warning('Alarm for temperature critical is cleared')\n      \n        return True\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv,'hdlt:',['lfile='])\n        except getopt.GetoptError:\n            print(('Usage: %s [-d] [-l <log_file>]' % sys.argv[0]))\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print(('Usage: %s [-d] [-l <log_file>]' % sys.argv[0]))\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg            \n        \n        if sys.argv[1]== '-t':\n            if len(sys.argv)!=7:\n                print(\"temp test, need input six temp\")\n                return 0\n            \n            i=0\n            for x in range(2, 7):\n               test_temp_list[i]= int(sys.argv[x])*1000\n               i=i+1\n            test_temp = 1   \n            log_level = logging.DEBUG\n            print(test_temp_list)\n    \n    global platform_chassis\n    platform_chassis = platform.Platform().get_chassis()\n    \n    platform_chassis.get_fan(0).set_speed(38)\n  \n    print(\"set default fan speed to 37.5%\")\n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(10)\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    \n"}, "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py": {"changes": [{"diff": "\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', l", "add": 6, "remove": 6, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py", "badparts": ["    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cdump -y 0 0x42 s 0x9a\"", "        status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]", "        status, output = getstatusoutput_noshell(cmd)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes \"\"\" import subprocess import getopt import sys import logging import re import time PROJECT_NAME='as7726_32x' version='0.0.1' verbose=False DEBUG=False args=[] ALL_DEVICE={} i2c_prefix='/sys/bus/i2c/devices/' ''' i2c_bus={'fan':['54-0066'], 'thermal':['54-004c', '55-0048','55-0049', '55-004a', '55-004b'], 'psu':['49-0050','50-0053'], 'sfp':['-0050']} i2c_nodes={'fan':['present', 'front_speed_rpm', 'rear_speed_rpm'], 'thermal':['hwmon/hwmon*/temp1_input'], 'psu':['psu_present ', 'psu_power_good'] , 'sfp':['module_present_ ', 'module_tx_disable_']} ''' sfp_map=[21, 22, 23, 24, 26, 25, 28, 27, 17, 18, 19, 20, 29, 30, 31, 32, 33, 34, 35, 36, 45, 46, 47, 48, 37, 38, 39, 40, 41, 42, 43, 44, 15, 16] mknod=[ 'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo as7726_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-11/new_device', 'echo as7726_32x_cpld2 0x62 > /sys/bus/i2c/devices/i2c-12/new_device', 'echo as7726_32x_cpld3 0x64 > /sys/bus/i2c/devices/i2c-13/new_device', 'echo as7726_32x_fan 0x66 > /sys/bus/i2c/devices/i2c-54/new_device', 'echo lm75 0x4c > /sys/bus/i2c/devices/i2c-54/new_device', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-55/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-55/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-55/new_device', 'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-55/new_device', 'echo as7726_32x_psu1 0x53 > /sys/bus/i2c/devices/i2c-50/new_device', 'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-50/new_device', 'echo as7726_32x_psu2 0x50> /sys/bus/i2c/devices/i2c-49/new_device', 'echo ym2651 0x58 > /sys/bus/i2c/devices/i2c-49/new_device', 'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-0/new_device', ] FORCE=0 logging.basicConfig(filename=PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG) logging.basicConfig(level=logging.INFO) if DEBUG==True: print((sys.argv[0])) print(('ARGV :', sys.argv[1:])) def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print(options) print(args) print((len(sys.argv))) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': do_install() elif arg=='clean': do_uninstall() else: show_help() return 0 def show_help(): print(( __doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]})) sys.exit(0) def dis_i2c_ir3570a(addr): cmd=\"i2cset -y 0 0x%x 0xE5 0x01\" % addr status, output=subprocess.getstatusoutput(cmd) cmd=\"i2cset -y 0 0x%x 0x12 0x02\" % addr status, output=subprocess.getstatusoutput(cmd) return status def ir3570_check(): cmd=\"i2cdump -y 0 0x42 s 0x9a\" try: status, output=subprocess.getstatusoutput(cmd) lines=output.split('\\n') hn=re.findall(r'\\w+', lines[-1]) version=int(hn[1], 16) if version==0x24: ret=dis_i2c_ir3570a(4) else: ret=0 except Exception as e: print(( \"Error on ir3570_check() e:\" +str(e))) return -1 return ret def my_log(txt): if DEBUG==True: print((\"[ACCTON DBG]: \",txt)) return def log_os_system(cmd, show): logging.info('Run:'+cmd) status=1 output=\"\" status, output=subprocess.getstatusoutput(cmd) my_log(cmd +\" with result:\" +str(status)) if status: logging.info('Failed:'+cmd) if show: print(('Failed:'+cmd)) return status, output def driver_inserted(): ret, lsmod=log_os_system(\"ls /sys/module/*accton*\", 0) logging.info('mods:'+lsmod) if ret: return False else: return True def cpld_reset_mac(): ret, lsmod=log_os_system(\"i2cset -y 0 0x77 0x1\", 0) ret, lsmod=log_os_system(\"i2cset -y 0 0x76 0x4\", 0) ret, lsmod=log_os_system(\"i2cset -y 0 0x60 0x8 0x77\", 0) time.sleep(1) ret, lsmod=log_os_system(\"i2cset -y 0 0x60 0x8 0xf7\", 0) return True kos=[ 'depmod -ae', 'modprobe i2c_dev', 'modprobe i2c_mux_pca954x force_deselect_on_exit=1', 'modprobe ym2651y', 'modprobe accton_as7726_32x_cpld', 'modprobe accton_as7726_32x_fan', 'modprobe accton_as7726_32x_leds', 'modprobe accton_as7726_32x_psu', 'modprobe optoe'] def driver_install(): global FORCE for i in range(0,len(kos)): status, output=log_os_system(kos[i], 1) if status: if FORCE==0: return status print(\"Done driver_install\") return 0 def driver_uninstall(): global FORCE for i in range(0,len(kos)): rm=kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\") lst=rm.split(\" \") if len(lst) > 3: del(lst[3]) rm=\" \".join(lst) status, output=log_os_system(rm, 1) if status: if FORCE==0: return status return 0 def device_install(): global FORCE for i in range(0,len(mknod)): if mknod[i].find('pca954') !=-1: time.sleep(2) status, output=log_os_system(mknod[i], 1) if status: print(output) if FORCE==0: return status for i in range(0,len(sfp_map)): status, output=log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1) if status: print(output) if FORCE==0: return status status, output=log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1) if status: print(output) if FORCE==0: return status print(\"Done device_install\") return def device_uninstall(): global FORCE status, output=log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0) if status==0: I2C_ORDER=1 else: \tI2C_ORDER=0 for i in range(0,len(sfp_map)): target=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\" status, output=log_os_system(\"echo 0x50 > \"+target, 1) if status: print(output) if FORCE==0: return status nodelist=mknod for i in range(len(nodelist)): target=nodelist[-(i+1)] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status return def system_ready(): if driver_inserted()==False: return False if not device_exist(): print(\"not device_exist()\") return False return True def do_install(): if driver_inserted()==False: status=driver_install() if status: if FORCE==0: return status else: print((PROJECT_NAME.upper()+\" drivers detected....\")) ir3570_check() if not device_exist(): status=device_install() if status: if FORCE==0: return status else: print((PROJECT_NAME.upper()+\" devices detected....\")) return def do_uninstall(): if not device_exist(): print((PROJECT_NAME.upper()+\" has no device installed....\")) else: print(\"Removing device....\") status=device_uninstall() if status: if FORCE==0: return status if driver_inserted()==False: print((PROJECT_NAME.upper()+\" has no driver installed....\")) else: print(\"Removing installed driver....\") status=driver_uninstall() if status: if FORCE==0: return status return def device_exist(): ret1, log=log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0) ret2, log=log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# Copyright (C) 2016 Accton Networks, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean\ncommand:\n    install     : install drivers and generate related sysfs nodes\n    clean       : uninstall drivers and remove related sysfs nodes\n\"\"\"\nimport subprocess\nimport getopt\nimport sys\nimport logging\nimport re\nimport time\n\nPROJECT_NAME = 'as7726_32x'\nversion = '0.0.1'\nverbose = False\nDEBUG = False\nargs = []\nALL_DEVICE = {}\n\ni2c_prefix = '/sys/bus/i2c/devices/'\n'''\ni2c_bus = {'fan': ['54-0066'],\n           'thermal': ['54-004c', '55-0048','55-0049', '55-004a', '55-004b'] ,\n           'psu': ['49-0050','50-0053'],\n           'sfp': ['-0050']}\ni2c_nodes = {'fan': ['present', 'front_speed_rpm', 'rear_speed_rpm'],\n           'thermal': ['hwmon/hwmon*/temp1_input'] ,\n           'psu': ['psu_present ', 'psu_power_good']    ,\n           'sfp': ['module_present_ ', 'module_tx_disable_']}\n'''\nsfp_map = [21, 22, 23, 24, 26, 25, 28, 27,\n             17, 18, 19, 20, 29, 30, 31, 32,\n             33, 34, 35, 36, 45, 46, 47, 48,\n             37, 38, 39, 40, 41, 42, 43, 44,\n             15, 16]\n\nmknod =[\n'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-2/new_device',\n\n'echo as7726_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-11/new_device',\n'echo as7726_32x_cpld2 0x62 > /sys/bus/i2c/devices/i2c-12/new_device',\n'echo as7726_32x_cpld3 0x64 > /sys/bus/i2c/devices/i2c-13/new_device',\n\n'echo as7726_32x_fan 0x66 > /sys/bus/i2c/devices/i2c-54/new_device',\n\n\n'echo lm75 0x4c > /sys/bus/i2c/devices/i2c-54/new_device',\n'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-55/new_device',\n'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-55/new_device',\n'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-55/new_device',\n'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-55/new_device',\n\n\n# PSU-1\n'echo as7726_32x_psu1 0x53 > /sys/bus/i2c/devices/i2c-50/new_device',\n'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-50/new_device',\n\n# PSU-2\n'echo as7726_32x_psu2 0x50> /sys/bus/i2c/devices/i2c-49/new_device',\n'echo ym2651 0x58 > /sys/bus/i2c/devices/i2c-49/new_device',\n\n#EERPOM\n'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-0/new_device',\n]\n\n\n\nFORCE = 0\nlogging.basicConfig(filename= PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG)\nlogging.basicConfig(level=logging.INFO)\n\n\nif DEBUG == True:\n    print((sys.argv[0]))\n    print(('ARGV      :', sys.argv[1:]))\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n\n    if len(sys.argv)<2:\n        show_help()\n\n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:\n        print(options)\n        print(args)\n        print((len(sys.argv)))\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n           do_install()\n        elif arg == 'clean':\n           do_uninstall()\n        else:\n            show_help()\n\n\n    return 0\n\ndef show_help():\n    print(( __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]}))\n    sys.exit(0)\n\ndef dis_i2c_ir3570a(addr):\n    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef ir3570_check():\n    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n    try:\n        status, output = subprocess.getstatusoutput(cmd)\n        lines = output.split('\\n')\n        hn = re.findall(r'\\w+', lines[-1])\n        version = int(hn[1], 16)\n        if version == 0x24:  #only for ir3570a\n            ret = dis_i2c_ir3570a(4)\n        else:\n            ret = 0\n    except Exception as e:\n        print(( \"Error on ir3570_check() e:\" + str(e)))\n        return -1\n    return ret\n\n\ndef my_log(txt):\n    if DEBUG == True:\n        print((\"[ACCTON DBG]: \",txt))\n    return\n\ndef log_os_system(cmd, show):\n    logging.info('Run :'+cmd)\n    status = 1\n    output = \"\"\n    status, output = subprocess.getstatusoutput(cmd)\n    my_log (cmd +\" with result:\" + str(status))\n    #my_log (\"cmd:\" + cmd)\n    #my_log (\"      output:\"+output)\n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print(('Failed :'+cmd))\n    return  status, output\n\ndef driver_inserted():\n    ret, lsmod = log_os_system(\"ls /sys/module/*accton*\", 0)\n    logging.info('mods:'+lsmod)\n    if ret :\n        return False\n    else :\n        return True\n\ndef cpld_reset_mac():\n    ret, lsmod = log_os_system(\"i2cset -y 0 0x77 0x1\", 0)\n    ret, lsmod = log_os_system(\"i2cset -y 0 0x76 0x4\", 0)\n    ret, lsmod = log_os_system(\"i2cset -y 0 0x60 0x8 0x77\", 0)\n    time.sleep(1)\n    ret, lsmod = log_os_system(\"i2cset -y 0 0x60 0x8 0xf7\", 0)\n    return True\n\n\n\n#'modprobe cpr_4011_4mxx',\n\nkos = [\n'depmod -ae',\n'modprobe i2c_dev',\n'modprobe i2c_mux_pca954x force_deselect_on_exit=1',\n'modprobe ym2651y',\n'modprobe accton_as7726_32x_cpld',\n'modprobe accton_as7726_32x_fan',\n'modprobe accton_as7726_32x_leds',\n'modprobe accton_as7726_32x_psu',\n'modprobe optoe']\n\ndef driver_install():\n    global FORCE\n    for i in range(0,len(kos)):\n        status, output = log_os_system(kos[i], 1)\n        if status:\n            if FORCE == 0:\n                return status\n\n    print(\"Done driver_install\")\n    \n    #status=cpld_reset_mac()\n    return 0\n\ndef driver_uninstall():\n    global FORCE\n    for i in range(0,len(kos)):\n        rm = kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\")        \n        lst = rm.split(\" \")\n\n        if len(lst) > 3:\n            del(lst[3])\n        rm = \" \".join(lst)\n        status, output = log_os_system(rm, 1)\n        if status:\n            if FORCE == 0:\n                return status\n    return 0\n\ndef device_install():\n    global FORCE\n\n    for i in range(0,len(mknod)):\n        #for pca954x need times to built new i2c buses\n        if mknod[i].find('pca954') != -1:\n            time.sleep(2)\n        \n        status, output = log_os_system(mknod[i], 1)        \n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    for i in range(0,len(sfp_map)):\n        status, output =log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n        status, output =log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    print(\"Done device_install\")\n\n    return\n\ndef device_uninstall():\n    global FORCE\n\n    status, output =log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0)\n    if status==0:\n        I2C_ORDER=1\n    else:\n    \tI2C_ORDER=0\n\n    for i in range(0,len(sfp_map)):\n        target = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\"\n        status, output =log_os_system(\"echo 0x50 > \"+ target, 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n                \n    nodelist = mknod\n\n    for i in range(len(nodelist)):\n        target = nodelist[-(i+1)]\n        temp = target.split()\n        del temp[1]\n        temp[-1] = temp[-1].replace('new_device', 'delete_device')\n        status, output = log_os_system(\" \".join(temp), 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    return\n\ndef system_ready():\n    if driver_inserted() == False:        \n        return False\n    if not device_exist():\n        print(\"not device_exist()\")\n        return False\n    return True\n\ndef do_install():\n    if driver_inserted() == False:\n        status = driver_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print((PROJECT_NAME.upper()+\" drivers detected....\"))\n\n    ir3570_check()\n\n    if not device_exist():\n        status = device_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print((PROJECT_NAME.upper()+\" devices detected....\"))\n    return\n\ndef do_uninstall():\n    if not device_exist():\n        print((PROJECT_NAME.upper()+\" has no device installed....\"))\n    else:\n        print(\"Removing device....\")\n        status = device_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    if driver_inserted()== False :\n        print((PROJECT_NAME.upper()+\" has no driver installed....\"))\n    else:\n        print(\"Removing installed driver....\")\n        status = driver_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    return\n\ndef device_exist():\n    ret1, log = log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0)\n    ret2, log = log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as7726_32x_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n", "add": 9, "remove": 9, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py", "badparts": ["import subprocess", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py clean\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py\", \"clean\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py install\"])\n     if status:\n         print(\"accton_as7726_32x_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n", "add": 7, "remove": 7, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py install\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py install\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor.service\"])"]}, {"diff": "\n     return True\n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.serv", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}], "source": "\n import subprocess def check_pddf_support(): return True def stop_platform_svc(): status, output=subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-fan.service\") if status: print(\"Stop as7726-32x-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-fan.service\") if status: print(\"Disable as7726-32x-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-psu.service\") if status: print(\"Stop as7726-32x-platform-monitor-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-psu.service\") if status: print(\"Disable as7726-32x-platform-monitor-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor.service\") if status: print(\"Stop as7726-32x-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor.service\") if status: print(\"Disable as7726-32x-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py clean\") if status: print(\"accton_as7726_32x_util.py clean command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status) return False return True def start_platform_svc(): status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py install\") if status: print(\"accton_as7726_32x_util.py install command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-fan.service\") if status: print(\"Enable as7726-32x-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-fan.service\") if status: print(\"Start as7726-32x-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-psu.service\") if status: print(\"Enable as7726-32x-platform-monitor-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-psu.service\") if status: print(\"Start as7726-32x-platform-monitor-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor.service\") if status: print(\"Enable as7726-32x-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor.service\") if status: print(\"Start as7726-32x-platform-monitor.service failed %d\"%status) return False return True def start_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print(\"Start pddf-platform-init.service failed %d\"%status) return False return True def stop_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service failed %d\"%status) return False return True def main(): pass if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services. \n# This will be used while switching the pddf->non-pddf mode and vice versa\n\nimport subprocess\n\ndef check_pddf_support():\n    return True\n\ndef stop_platform_svc():\n    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-fan.service\")\n    if status:\n        print(\"Stop as7726-32x-platform-monitor-fan.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-fan.service\")\n    if status:\n        print(\"Disable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-psu.service\")\n    if status:\n        print(\"Stop as7726-32x-platform-monitor-psu.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-psu.service\")\n    if status:\n        print(\"Disable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor.service\")\n    if status:\n        print(\"Stop as7726-32x-platform-monitor.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor.service\")\n    if status:\n        print(\"Disable as7726-32x-platform-monitor.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py clean\")\n    if status:\n        print(\"accton_as7726_32x_util.py clean command failed %d\"%status)\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n        return False\n\n    return True\n    \ndef start_platform_svc():\n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py install\")\n    if status:\n        print(\"accton_as7726_32x_util.py install command failed %d\"%status)\n        return False\n\n    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-fan.service\")\n    if status:\n        print(\"Enable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-fan.service\")\n    if status:\n        print(\"Start as7726-32x-platform-monitor-fan.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-psu.service\")\n    if status:\n        print(\"Enable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-psu.service\")\n    if status:\n        print(\"Start as7726-32x-platform-monitor-psu.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor.service\")\n    if status:\n        print(\"Enable as7726-32x-platform-monitor.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor.service\")\n    if status:\n        print(\"Start as7726-32x-platform-monitor.service failed %d\"%status)\n        return False\n\n    return True\n\ndef start_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print(\"Start pddf-platform-init.service failed %d\"%status)\n        return False\n    \n    return True\n\ndef stop_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service failed %d\"%status)\n        return False\n\n    return True\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py": {"changes": [{"diff": "\n     print( __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]})\n     sys.exit(0)\n \n-   \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+',", "add": 6, "remove": 7, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py", "badparts": ["    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cdump -y 0 0x42 s 0x9a\"", "        status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]", "        status, output = getstatusoutput_noshell(cmd)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes \"\"\" import subprocess import getopt import sys import logging import re import time import os PROJECT_NAME='as7816_64x' version='0.1.0' verbose=False DEBUG=False args=[] ALL_DEVICE={} FORCE=0 if DEBUG==True: print(sys.argv[0]) print('ARGV :', sys.argv[1:] ) def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print(options) print(args) print(len(sys.argv)) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': do_install() elif arg=='clean': do_uninstall() elif arg=='api': do_sonic_platform_install() elif arg=='api_clean': do_sonic_platform_clean() else: show_help() return 0 def show_help(): print( __doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]}) sys.exit(0) def dis_i2c_ir3570a(addr): cmd=\"i2cset -y 0 0x%x 0xE5 0x01\" % addr status, output=subprocess.getstatusoutput(cmd) cmd=\"i2cset -y 0 0x%x 0x12 0x02\" % addr status, output=subprocess.getstatusoutput(cmd) return status def ir3570_check(): cmd=\"i2cdump -y 0 0x42 s 0x9a\" try: status, output=subprocess.getstatusoutput(cmd) lines=output.split('\\n') hn=re.findall(r'\\w+', lines[-1]) version=int(hn[1], 16) if version==0x24: ret=dis_i2c_ir3570a(4) else: ret=0 except Exception as e: print(\"Error on ir3570_check() e:\" +str(e)) return -1 return ret def my_log(txt): if DEBUG==True: print(\"[ROY]\"+txt) return def log_os_system(cmd, show): logging.info('Run:'+cmd) status, output=subprocess.getstatusoutput(cmd) my_log(cmd +\"with result:\" +str(status)) my_log(\" output:\"+output) if status: logging.info('Failed:'+cmd) if show: print('Failed:'+cmd) return status, output def driver_check(): ret, lsmod=log_os_system(\"ls /sys/module/*accton*\", 0) logging.info('mods:'+lsmod) if ret: return False else: return True kos=[ 'modprobe i2c_dev', 'modprobe i2c_mux_pca954x force_deselect_on_exit=1', 'modprobe optoe', 'modprobe accton_i2c_cpld' , 'modprobe ym2651y' , 'modprobe x86-64-accton-as7816-64x-fan' , 'modprobe x86-64-accton-as7816-64x-leds' , 'modprobe x86-64-accton-as7816-64x-psu'] def driver_install(): global FORCE status, output=log_os_system(\"depmod\", 1) for i in range(0,len(kos)): status, output=log_os_system(kos[i], 1) if status: if FORCE==0: return status print(\"Done driver_install\") return 0 def driver_uninstall(): global FORCE for i in range(0,len(kos)): rm=kos[-(i+1)] lst=rm.split(\" \") if len(lst) > 2: del(lst[2:]) rm=\" \".join(lst) rm=rm.replace(\"modprobe\", \"modprobe -rq\") rm=rm.replace(\"insmod\", \"rmmod\") status, output=log_os_system(rm, 1) if status: if FORCE==0: return status return 0 i2c_prefix='/sys/bus/i2c/devices/' ''' i2c_bus={'fan':['17-0068'] , 'thermal':['18-0048','18-0049', '18-004a', '18-004b', '17-004d', '17-004e'], 'psu':['10-0053','9-0050'], 'sfp':['-0050']} i2c_nodes={'fan':['present', 'front_speed_rpm', 'rear_speed_rpm'], 'thermal':['hwmon/hwmon*/temp1_input'], 'psu':['psu_present', 'psu_power_good'] , 'sfp':['module_present']} ''' sfp_map=[37,38,39,40,42,41,44,43,33,34,35,36,45,46,47,48,49,50,51,52, 61,62,63,64,53,54,55,56,57,58,59,60,69,70,71,72,77,78,79,80,65, \t 66,67,68,73,74,75,76,85,86,87,88,31,32,29,30,81,82,83,84,25,26, 27,28] mknod=[ 'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo as7816_64x_psu1 0x53 > /sys/bus/i2c/devices/i2c-10/new_device', 'echo ym2851 0x5b > /sys/bus/i2c/devices/i2c-10/new_device', 'echo as7816_64x_psu2 0x50 > /sys/bus/i2c/devices/i2c-9/new_device', 'echo ym2851 0x58 > /sys/bus/i2c/devices/i2c-9/new_device', 'echo as7816_64x_fan 0x68 > /sys/bus/i2c/devices/i2c-17/new_device', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4d > /sys/bus/i2c/devices/i2c-17/new_device', 'echo lm75 0x4e > /sys/bus/i2c/devices/i2c-17/new_device', 'echo cpld_as7816 0x60 > /sys/bus/i2c/devices/i2c-19/new_device', 'echo cpld_plain 0x62 > /sys/bus/i2c/devices/i2c-20/new_device', 'echo cpld_plain 0x64 > /sys/bus/i2c/devices/i2c-21/new_device', 'echo cpld_plain 0x66 > /sys/bus/i2c/devices/i2c-22/new_device'] def i2c_order_check(): return 0 def device_install(): global FORCE for i in range(0,len(mknod)): if mknod[i].find('pca954') !=-1: time.sleep(1) status, output=log_os_system(mknod[i], 1) if status: print(output) if FORCE==0: return status for i in range(0,len(sfp_map)): path=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\" status, output=log_os_system(\"echo optoe1 0x50 > \" +path, 1) if status: print(output) if FORCE==0: return status print(\"Done device_install\") return def device_uninstall(): global FORCE status, output=log_os_system(\"ls /sys/bus/i2c/devices/1-0076\", 0) for i in range(0,len(sfp_map)): target=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\" status, output=log_os_system(\"echo 0x50 > \"+target, 1) if status: print(output) if FORCE==0: return status nodelist=mknod for i in range(len(nodelist)): target=nodelist[-(i+1)] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status return def system_ready(): if driver_check()==False: return False if not device_exist(): return False return True PLATFORM_ROOT_PATH='/usr/share/sonic/device' PLATFORM_API2_WHL_FILE_PY3='sonic_platform-1.0-py3-none-any.whl' def do_sonic_platform_install(): device_path=\"{}{}{}{}\".format(PLATFORM_ROOT_PATH, '/x86_64-accton_', PROJECT_NAME, '-r0') SONIC_PLATFORM_BSP_WHL_PKG_PY3=\"/\".join([device_path, PLATFORM_API2_WHL_FILE_PY3]) status, output=log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0) if status: if os.path.exists(SONIC_PLATFORM_BSP_WHL_PKG_PY3): status, output=log_os_system(\"pip3 install \"+SONIC_PLATFORM_BSP_WHL_PKG_PY3, 1) if status: print(\"Error: Failed to install{}\".format(PLATFORM_API2_WHL_FILE_PY3)) return status else: print(\"Successfully installed{} package\".format(PLATFORM_API2_WHL_FILE_PY3)) else: print('{} is not found'.format(PLATFORM_API2_WHL_FILE_PY3)) else: print('{} has installed'.format(PLATFORM_API2_WHL_FILE_PY3)) return def do_sonic_platform_clean(): status, output=log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0) if status: print('{} does not install, not need to uninstall'.format(PLATFORM_API2_WHL_FILE_PY3)) else: status, output=log_os_system(\"pip3 uninstall sonic-platform -y\", 0) if status: print('Error: Failed to uninstall{}'.format(PLATFORM_API2_WHL_FILE_PY3)) return status else: print('{} is uninstalled'.format(PLATFORM_API2_WHL_FILE_PY3)) return def do_install(): print(\"Checking system....\") if driver_check()==False: print(\"No driver, installing....\") status=driver_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" drivers detected....\") ir3570_check() if not device_exist(): print(\"No device, installing....\") status=device_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" devices detected....\") do_sonic_platform_install() return def do_uninstall(): print(\"Checking system....\") if not device_exist(): print(PROJECT_NAME.upper() +\" has no device installed....\") else: print(\"Removing device....\") status=device_uninstall() if status: if FORCE==0: return status if driver_check()==False: print(PROJECT_NAME.upper() +\" has no driver installed....\") else: print(\"Removing installed driver....\") status=driver_uninstall() if status: if FORCE==0: return status do_sonic_platform_clean() return def device_exist(): ret1, log=log_os_system(\"ls \"+i2c_prefix+\"*0076\", 0) ret2, log=log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# Copyright (C) 2016 Accton Networks, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean\ncommand:\n    install     : install drivers and generate related sysfs nodes\n    clean       : uninstall drivers and remove related sysfs nodes\n\"\"\"\nimport subprocess\nimport getopt\nimport sys\nimport logging\nimport re\nimport time\nimport os\n\n\n\nPROJECT_NAME = 'as7816_64x'\nversion = '0.1.0'\nverbose = False\nDEBUG = False\nargs = []\nALL_DEVICE = {}               \n\nFORCE = 0\n#logging.basicConfig(filename= PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG)\n#logging.basicConfig(level=logging.INFO)\n\n\nif DEBUG == True:\n    print(sys.argv[0])\n    print('ARGV      :', sys.argv[1:]   )\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n        \n    if len(sys.argv)<2:\n        show_help()\n         \n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:\n        print(options)\n        print(args)\n        print(len(sys.argv))\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n           do_install()\n        elif arg == 'clean':\n           do_uninstall()\n        elif arg == 'api':\n           do_sonic_platform_install()\n        elif arg == 'api_clean':   \n           do_sonic_platform_clean()\n        \n        else:\n            show_help()\n\n\n    return 0\n\ndef show_help():\n    print( __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]})\n    sys.exit(0)\n\n   \ndef dis_i2c_ir3570a(addr):\n    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef ir3570_check():\n    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n    try:\n        status, output = subprocess.getstatusoutput(cmd)\n        lines = output.split('\\n')\n        hn = re.findall(r'\\w+', lines[-1])\n        version = int(hn[1], 16)\n        if version == 0x24:  #only for ir3570a\n            ret = dis_i2c_ir3570a(4)\n        else:\n            ret = 0\n    except Exception as e:\n        print(\"Error on ir3570_check() e:\" + str(e))\n        return -1\n    return ret\n\ndef my_log(txt):\n    if DEBUG == True:\n        print(\"[ROY]\"+txt)\n    return\n    \ndef log_os_system(cmd, show):\n    logging.info('Run :'+cmd)  \n    status, output = subprocess.getstatusoutput(cmd)    \n    my_log (cmd +\"with result:\" + str(status))\n    my_log (\"      output:\"+output)    \n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print('Failed :'+cmd)\n    return  status, output\n            \ndef driver_check():\n    ret, lsmod = log_os_system(\"ls /sys/module/*accton*\", 0)\n    logging.info('mods:'+lsmod)\n    if ret :\n        return False\n    else :\n        return True\n\n\n\nkos = [\n'modprobe i2c_dev',\n'modprobe i2c_mux_pca954x force_deselect_on_exit=1',\n'modprobe optoe',\n'modprobe accton_i2c_cpld'  ,\n'modprobe ym2651y'                  ,\n'modprobe x86-64-accton-as7816-64x-fan'     ,\n#'modprobe x86-64-accton-as7816-64x-sfp'      ,\n'modprobe x86-64-accton-as7816-64x-leds'      ,\n'modprobe x86-64-accton-as7816-64x-psu' ]\n\ndef driver_install():\n    global FORCE\n    status, output = log_os_system(\"depmod\", 1)\n    for i in range(0,len(kos)):\n        status, output = log_os_system(kos[i], 1)\n        if status:\n            if FORCE == 0:        \n                return status              \n    \n    print(\"Done driver_install\")\n    \n    return 0\n    \ndef driver_uninstall():\n    global FORCE\n    for i in range(0,len(kos)):\n        #remove parameter if any\n        rm = kos[-(i+1)]\n        lst = rm.split(\" \")\n        if len(lst) > 2:\n            del(lst[2:])\n        rm = \" \".join(lst)\n\n        #Change to removing commands\n        rm = rm.replace(\"modprobe\", \"modprobe -rq\")\n        rm = rm.replace(\"insmod\", \"rmmod\")        \n        status, output = log_os_system(rm, 1)\n        if status:\n            if FORCE == 0:        \n                return status              \n    return 0\n\n\ni2c_prefix = '/sys/bus/i2c/devices/'\n'''\ni2c_bus = {'fan': ['17-0068']                 ,\n           'thermal': ['18-0048','18-0049', '18-004a' , '18-004b', '17-004d', '17-004e'] ,\n           'psu': ['10-0053','9-0050'], \n           'sfp': ['-0050']}\ni2c_nodes = {'fan': ['present', 'front_speed_rpm', 'rear_speed_rpm'] ,\n           'thermal': ['hwmon/hwmon*/temp1_input'] ,\n           'psu': ['psu_present', 'psu_power_good']    ,\n           'sfp': ['module_present']}\n'''                  \n\nsfp_map =  [37,38,39,40,42,41,44,43,33,34,35,36,45,46,47,48,49,50,51,52,\n           61,62,63,64,53,54,55,56,57,58,59,60,69,70,71,72,77,78,79,80,65,\n\t   66,67,68,73,74,75,76,85,86,87,88,31,32,29,30,81,82,83,84,25,26,\n           27,28]\n\n\nmknod =[   \n'echo pca9548  0x77 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo pca9548  0x71 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548  0x76 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548  0x73 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548  0x70 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x71 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x72 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x73 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x74 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x75 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x76 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo 24c02  0x56 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo as7816_64x_psu1  0x53 > /sys/bus/i2c/devices/i2c-10/new_device',\n'echo ym2851  0x5b > /sys/bus/i2c/devices/i2c-10/new_device',\n'echo as7816_64x_psu2  0x50 > /sys/bus/i2c/devices/i2c-9/new_device',\n'echo ym2851  0x58 > /sys/bus/i2c/devices/i2c-9/new_device',\n'echo as7816_64x_fan  0x68 > /sys/bus/i2c/devices/i2c-17/new_device',\n'echo lm75  0x48 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75  0x49 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75  0x4a > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75  0x4b > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75  0x4d > /sys/bus/i2c/devices/i2c-17/new_device',\n'echo lm75  0x4e > /sys/bus/i2c/devices/i2c-17/new_device',\n'echo cpld_as7816  0x60 > /sys/bus/i2c/devices/i2c-19/new_device',\n'echo cpld_plain  0x62 > /sys/bus/i2c/devices/i2c-20/new_device',\n'echo cpld_plain  0x64 > /sys/bus/i2c/devices/i2c-21/new_device',\n'echo cpld_plain  0x66 > /sys/bus/i2c/devices/i2c-22/new_device']\n       \ndef i2c_order_check():    \n    return 0\n                     \ndef device_install():\n    global FORCE\n    \n    for i in range(0,len(mknod)):\n        #for pca954x need times to built new i2c buses            \n        if mknod[i].find('pca954') != -1:\n           time.sleep(1)         \n           \n        status, output = log_os_system(mknod[i], 1)\n        if status:\n            print(output)\n            if FORCE == 0:                \n                return status  \n\n    for i in range(0,len(sfp_map)):\n        path = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\"\n        status, output =log_os_system(\"echo optoe1 0x50 > \" + path, 1)\n        if status:\n            print(output)\n            if FORCE == 0:            \n                return status                                  \n     \n    print(\"Done device_install\")\n     \n    return \n    \ndef device_uninstall():\n    global FORCE\n    \n    status, output =log_os_system(\"ls /sys/bus/i2c/devices/1-0076\", 0)\n    \n    for i in range(0,len(sfp_map)):\n        target = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\"\n        status, output =log_os_system(\"echo 0x50 > \"+ target, 1)\n        if status:\n            print(output)\n            if FORCE == 0:            \n                return status\n       \n    nodelist = mknod\n           \n    for i in range(len(nodelist)):\n        target = nodelist[-(i+1)]\n        temp = target.split()\n        del temp[1]\n        temp[-1] = temp[-1].replace('new_device', 'delete_device')\n        status, output = log_os_system(\" \".join(temp), 1)\n        if status:\n            print(output)\n            if FORCE == 0:            \n                return status  \n                                  \n    return \n        \ndef system_ready():\n    if driver_check() == False:\n        return False\n    if not device_exist(): \n        return False\n    return True\n\nPLATFORM_ROOT_PATH = '/usr/share/sonic/device'\nPLATFORM_API2_WHL_FILE_PY3 ='sonic_platform-1.0-py3-none-any.whl'\ndef do_sonic_platform_install():\n    device_path = \"{}{}{}{}\".format(PLATFORM_ROOT_PATH, '/x86_64-accton_', PROJECT_NAME, '-r0')\n    SONIC_PLATFORM_BSP_WHL_PKG_PY3 = \"/\".join([device_path, PLATFORM_API2_WHL_FILE_PY3])\n        \n    #Check API2.0 on py whl file\n    status, output = log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0)\n    if status:\n        if os.path.exists(SONIC_PLATFORM_BSP_WHL_PKG_PY3): \n            status, output = log_os_system(\"pip3 install \"+ SONIC_PLATFORM_BSP_WHL_PKG_PY3, 1)\n            if status:\n                print(\"Error: Failed to install {}\".format(PLATFORM_API2_WHL_FILE_PY3))\n                return status\n            else:\n                print(\"Successfully installed {} package\".format(PLATFORM_API2_WHL_FILE_PY3))\n        else:\n            print('{} is not found'.format(PLATFORM_API2_WHL_FILE_PY3))\n    else:        \n        print('{} has installed'.format(PLATFORM_API2_WHL_FILE_PY3))\n     \n    return \n     \ndef do_sonic_platform_clean():\n    status, output = log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0)   \n    if status:\n        print('{} does not install, not need to uninstall'.format(PLATFORM_API2_WHL_FILE_PY3))\n        \n    else:        \n        status, output = log_os_system(\"pip3 uninstall sonic-platform -y\", 0)\n        if status:\n            print('Error: Failed to uninstall {}'.format(PLATFORM_API2_WHL_FILE_PY3))\n            return status\n        else:\n            print('{} is uninstalled'.format(PLATFORM_API2_WHL_FILE_PY3))\n\n    return\ndef do_install():\n    print(\"Checking system....\")\n    if driver_check() == False:\n        print(\"No driver, installing....\")    \n        status = driver_install()\n        if status:\n            if FORCE == 0:        \n                return  status\n    else:\n        print(PROJECT_NAME.upper()+\" drivers detected....\")\n\n    ir3570_check()\n\n    if not device_exist():\n        print(\"No device, installing....\")\n        status = device_install() \n        if status:\n            if FORCE == 0:        \n                return  status        \n    else:\n        print(PROJECT_NAME.upper()+\" devices detected....\")\n    do_sonic_platform_install()\n\n    return\n    \ndef do_uninstall():\n    print(\"Checking system....\")\n    if not device_exist():\n        print(PROJECT_NAME.upper() +\" has no device installed....\")\n    else:\n        print(\"Removing device....\")\n        status = device_uninstall() \n        if status:\n            if FORCE == 0:            \n                return  status  \n                \n    if driver_check()== False :\n        print(PROJECT_NAME.upper() +\" has no driver installed....\")\n    else:\n        print(\"Removing installed driver....\")\n        status = driver_uninstall()\n        if status:\n            if FORCE == 0:        \n                return  status                          \n                    \n    do_sonic_platform_clean() \n\n    return       \n\ndef device_exist():\n    ret1, log = log_os_system(\"ls \"+i2c_prefix+\"*0076\", 0)\n    ret2, log = log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services.\n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n def check_pddf_support():\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py", "badparts": ["import subprocess"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n \n def stop_platform_svc():\n \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Stop as7816-platform-init.service failed %d\" % status))\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Disable as7816-platform-init.service failed %d\" % status))\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"clean\"])\n     if status:\n         print((\"accton_as7816_util.py clean command failed %d\" % status))\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Stop pddf-platform-init.service along with other platform serives failed %d\" % status))\n         return False\n", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl stop as7816-platform-init.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as7816-platform-init.service\")", "    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py clean\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7816-platform-init.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7816-platform-init.service\"])", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"clean\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}, {"diff": "\n \n \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"install\"])\n     if status:\n         print((\"accton_as7816_util.py install command failed %d\" % status))\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Enable as7816-platform-init.service failed %d\" % status))\n         return False\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py install\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as7816-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"install\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7816-platform-init.service\"])"]}, {"diff": "\n \n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Start pddf-platform-init.service failed %d\" % status))\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])"]}, {"diff": "\n \n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Stop pddf-platform-init.servi", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}], "source": "\n import subprocess def check_pddf_support(): return True def stop_platform_svc(): status, output=subprocess.getstatusoutput(\"systemctl stop as7816-platform-init.service\") if status: print((\"Stop as7816-platform-init.service failed %d\" % status)) return False status, output=subprocess.getstatusoutput(\"systemctl disable as7816-platform-init.service\") if status: print((\"Disable as7816-platform-init.service failed %d\" % status)) return False status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py clean\") if status: print((\"accton_as7816_util.py clean command failed %d\" % status)) return False status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print((\"Stop pddf-platform-init.service along with other platform serives failed %d\" % status)) return False return True def start_platform_svc(): status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py install\") if status: print((\"accton_as7816_util.py install command failed %d\" % status)) return False status, output=subprocess.getstatusoutput(\"systemctl enable as7816-platform-init.service\") if status: print((\"Enable as7816-platform-init.service failed %d\" % status)) return False return True def start_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print((\"Start pddf-platform-init.service failed %d\" % status)) return False return True def stop_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print((\"Stop pddf-platform-init.service failed %d\" % status)) return False return True def main(): pass if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services.\n# This will be used while switching the pddf->non-pddf mode and vice versa\nimport subprocess\n\n\ndef check_pddf_support():\n    return True\n\n\ndef stop_platform_svc():\n\n    status, output = subprocess.getstatusoutput(\"systemctl stop as7816-platform-init.service\")\n    if status:\n        print((\"Stop as7816-platform-init.service failed %d\" % status))\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as7816-platform-init.service\")\n    if status:\n        print((\"Disable as7816-platform-init.service failed %d\" % status))\n        return False\n\n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py clean\")\n    if status:\n        print((\"accton_as7816_util.py clean command failed %d\" % status))\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print((\"Stop pddf-platform-init.service along with other platform serives failed %d\" % status))\n        return False\n\n    return True\n\n\ndef start_platform_svc():\n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py install\")\n    if status:\n        print((\"accton_as7816_util.py install command failed %d\" % status))\n        return False\n\n    status, output = subprocess.getstatusoutput(\"systemctl enable as7816-platform-init.service\")\n    if status:\n        print((\"Enable as7816-platform-init.service failed %d\" % status))\n        return False\n\n    return True\n\n\ndef start_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print((\"Start pddf-platform-init.service failed %d\" % status))\n        return False\n\n    return True\n\n\ndef stop_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print((\"Stop pddf-platform-init.service failed %d\" % status))\n        return False\n\n    return True\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py": {"changes": [{"diff": "\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+", "add": 6, "remove": 6, "filename": "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py", "badparts": ["    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cdump -y 0 0x42 s 0x9a\"", "        status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]", "        status, output = getstatusoutput_noshell(cmd)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes \"\"\" import subprocess import getopt import sys import logging import re import time PROJECT_NAME='as9716_32d' version='0.0.1' verbose=False DEBUG=False args=[] ALL_DEVICE={} i2c_prefix='/sys/bus/i2c/devices/' ''' i2c_bus={'fan':['54-0066'], 'thermal':['18-0048', '18-0049','18-004a', '18-004b', '18-004c', '18-004e', '18-004f'], 'psu':['9-0058', '10-0059'], 'sfp':['-0050']} i2c_nodes={'fan':['present', 'front_speed_rpm', 'rear_speed_rpm'], 'thermal':['hwmon/hwmon*/temp1_input'], 'psu':['psu_present ', 'psu_power_good'] , 'sfp':['module_present_ ', 'module_tx_disable_']} ''' sfp_map=[25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58] mknod=[ 'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo as9716_32d_fpga 0x60 > /sys/bus/i2c/devices/i2c-19/new_device', 'echo as9716_32d_cpld1 0x61 > /sys/bus/i2c/devices/i2c-20/new_device', 'echo as9716_32d_cpld2 0x62 > /sys/bus/i2c/devices/i2c-21/new_device', 'echo as9716_32d_cpld_cpu 0x65 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo as9716_32d_fan 0x66 > /sys/bus/i2c/devices/i2c-17/new_device', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4c > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4e > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4f > /sys/bus/i2c/devices/i2c-18/new_device', 'echo as9716_32d_psu1 0x50 > /sys/bus/i2c/devices/i2c-9/new_device', 'echo acbel_fsh082 0x58 > /sys/bus/i2c/devices/i2c-9/new_device', 'echo as9716_32d_psu2 0x51 > /sys/bus/i2c/devices/i2c-10/new_device', 'echo acbel_fsh082 0x59 > /sys/bus/i2c/devices/i2c-10/new_device', ] eeprom_mknod=[ 'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-0/new_device', ] FORCE=0 logging.basicConfig(filename=PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG) logging.basicConfig(level=logging.INFO) if DEBUG==True: print((sys.argv[0])) print(('ARGV :', sys.argv[1:])) def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print(options) print(args) print((len(sys.argv))) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': do_install() elif arg=='clean': do_uninstall() else: show_help() return 0 def show_help(): print(( __doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]})) sys.exit(0) def dis_i2c_ir3570a(addr): cmd=\"i2cset -y 0 0x%x 0xE5 0x01\" % addr status, output=subprocess.getstatusoutput(cmd) cmd=\"i2cset -y 0 0x%x 0x12 0x02\" % addr status, output=subprocess.getstatusoutput(cmd) return status def ir3570_check(): cmd=\"i2cdump -y 0 0x42 s 0x9a\" try: status, output=subprocess.getstatusoutput(cmd) lines=output.split('\\n') hn=re.findall(r'\\w+', lines[-1]) version=int(hn[1], 16) if version==0x24: ret=dis_i2c_ir3570a(4) else: ret=0 except Exception as e: print(( \"Error on ir3570_check() e:\" +str(e))) return -1 return ret def my_log(txt): if DEBUG==True: print((\"[ACCTON DBG]: \"+txt)) return def log_os_system(cmd, show): logging.info('Run:'+cmd) status=1 output=\"\" status, output=subprocess.getstatusoutput(cmd) my_log(cmd +\"with result:\" +str(status)) if status: logging.info('Failed:'+cmd) if show: print(('Failed:'+cmd)) return status, output def driver_inserted(): ret, lsmod=log_os_system(\"ls /sys/module/*accton*\", 0) logging.info('mods:'+lsmod) if ret: return False else: return True kos=[ 'depmod -ae', 'modprobe i2c_dev', 'modprobe i2c_mux_pca954x force_deselect_on_exit=1', 'modprobe accton_i2c_psu', 'modprobe accton_as9716_32d_cpld', 'modprobe accton_as9716_32d_fan', 'modprobe accton_as9716_32d_leds', 'modprobe accton_as9716_32d_psu', 'modprobe optoe', 'modprobe lm75'] cpld_reset_stop='i2cset -y 0 0x65 0x3 0x0' def driver_install(): global FORCE for i in range(0,len(kos)): status, output=log_os_system(kos[i], 1) if status: if FORCE==0: return status log_os_system(cpld_reset_stop, 1) print(\"Done driver_install\") return 0 def driver_uninstall(): global FORCE for i in range(0,len(kos)): rm=kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\") lst=rm.split(\" \") if len(lst) > 3: del(lst[3]) rm=\" \".join(lst) status, output=log_os_system(rm, 1) if status: if FORCE==0: return status return 0 def eeprom_check(): cmd=\"i2cget -y -f 0 0x57\" status, output=subprocess.getstatusoutput(cmd) return status def device_install(): global FORCE global use_57_eeprom for i in range(0,len(mknod)): if mknod[i].find('pca954') !=-1: time.sleep(2) status, output=log_os_system(mknod[i], 1) if status: print(output) if FORCE==0: return status ret=eeprom_check() if ret==0: log_os_system(eeprom_mknod[0], 1) else: log_os_system(eeprom_mknod[1], 1) for i in range(0,len(sfp_map)): status, output=log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1) if status: print(output) if FORCE==0: return status status, output=log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1) if status: print(output) if FORCE==0: return status print(\"Done device_install\") return def device_uninstall(): global FORCE status, output=log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0) if status==0: I2C_ORDER=1 else: \tI2C_ORDER=0 for i in range(0,len(sfp_map)): target=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\" status, output=log_os_system(\"echo 0x50 > \"+target, 1) if status: print(output) if FORCE==0: return status nodelist=mknod for i in range(len(nodelist)): target=nodelist[-(i+1)] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status ret=eeprom_check() if ret==0: target=eeprom_mknod[0] else: target=eeprom_mknod[1] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) return def system_ready(): if driver_inserted()==False: return False if not device_exist(): print(\"not device_exist()\") return False return True def do_install(): if driver_inserted()==False: status=driver_install() if status: if FORCE==0: return status else: print((PROJECT_NAME.upper()+\" drivers detected....\")) ir3570_check() if not device_exist(): status=device_install() if status: if FORCE==0: return status else: print((PROJECT_NAME.upper()+\" devices detected....\")) return def do_uninstall(): if not device_exist(): print((PROJECT_NAME.upper()+\" has no device installed....\")) else: print(\"Removing device....\") status=device_uninstall() if status: if FORCE==0: return status if driver_inserted()==False: print((PROJECT_NAME.upper()+\" has no driver installed....\")) else: print(\"Removing installed driver....\") status=driver_uninstall() if status: if FORCE==0: return status return def device_exist(): ret1, log=log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0) ret2, log=log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# Copyright (C) 2016 Accton Networks, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean\ncommand:\n    install     : install drivers and generate related sysfs nodes\n    clean       : uninstall drivers and remove related sysfs nodes\n\"\"\"\nimport subprocess\nimport getopt\nimport sys\nimport logging\nimport re\nimport time\n\nPROJECT_NAME = 'as9716_32d'\nversion = '0.0.1'\nverbose = False\nDEBUG = False\nargs = []\nALL_DEVICE = {}\n\ni2c_prefix = '/sys/bus/i2c/devices/'\n'''\ni2c_bus = {'fan': ['54-0066'],\n           'thermal': ['18-0048', '18-0049','18-004a', '18-004b', '18-004c', '18-004e', '18-004f'] ,\n           'psu': ['9-0058', '10-0059'],\n           'sfp': ['-0050']}\ni2c_nodes = {'fan': ['present', 'front_speed_rpm', 'rear_speed_rpm'],\n           'thermal': ['hwmon/hwmon*/temp1_input'] ,\n           'psu': ['psu_present ', 'psu_power_good']    ,\n           'sfp': ['module_present_ ', 'module_tx_disable_']}\n'''\n\nsfp_map = [25, 26, 27, 28, 29, 30, 31, 32,\n           33, 34, 35, 36, 37, 38, 39, 40,\n           41, 42, 43, 44, 45, 46, 47, 48,\n           49, 50, 51, 52, 53, 54, 55, 56,\n           57, 58]\n\n#sfp_map = [25, 26]\n\nmknod =[\n'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-2/new_device',\n\n'echo as9716_32d_fpga 0x60 > /sys/bus/i2c/devices/i2c-19/new_device',\n'echo as9716_32d_cpld1 0x61 > /sys/bus/i2c/devices/i2c-20/new_device',\n'echo as9716_32d_cpld2 0x62 > /sys/bus/i2c/devices/i2c-21/new_device',\n'echo as9716_32d_cpld_cpu 0x65 > /sys/bus/i2c/devices/i2c-0/new_device',\n\n'echo as9716_32d_fan 0x66 > /sys/bus/i2c/devices/i2c-17/new_device',\n\n'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x4c > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x4e > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x4f > /sys/bus/i2c/devices/i2c-18/new_device',\n \n# PSU-1\n'echo as9716_32d_psu1 0x50 > /sys/bus/i2c/devices/i2c-9/new_device',\n'echo acbel_fsh082    0x58 > /sys/bus/i2c/devices/i2c-9/new_device',\n\n# PSU-2\n'echo as9716_32d_psu2 0x51 > /sys/bus/i2c/devices/i2c-10/new_device',\n'echo acbel_fsh082    0x59 > /sys/bus/i2c/devices/i2c-10/new_device',\n]\n\n#EERPOM\neeprom_mknod =[\n'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-0/new_device',\n]\n\nFORCE = 0\nlogging.basicConfig(filename= PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG)\nlogging.basicConfig(level=logging.INFO)\n\n\nif DEBUG == True:\n    print((sys.argv[0]))\n    print(('ARGV      :', sys.argv[1:]))\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n\n    if len(sys.argv)<2:\n        show_help()\n\n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:\n        print(options)\n        print(args)\n        print((len(sys.argv)))\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n           do_install()\n        elif arg == 'clean':\n           do_uninstall()\n        else:\n            show_help()\n\n\n    return 0\n\ndef show_help():\n    print(( __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]}))\n    sys.exit(0)\n\ndef dis_i2c_ir3570a(addr):\n    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef ir3570_check():\n    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n    try:\n        status, output = subprocess.getstatusoutput(cmd)\n        lines = output.split('\\n')\n        hn = re.findall(r'\\w+', lines[-1])\n        version = int(hn[1], 16)\n        if version == 0x24:  #only for ir3570a\n            ret = dis_i2c_ir3570a(4)\n        else:\n            ret = 0\n    except Exception as e:\n        print(( \"Error on ir3570_check() e:\" + str(e)))\n        return -1\n    return ret\n\n\ndef my_log(txt):\n    if DEBUG == True:\n        print((\"[ACCTON DBG]: \"+txt))\n    return\n\ndef log_os_system(cmd, show):\n    logging.info('Run :'+cmd)\n    status = 1\n    output = \"\"\n    status, output = subprocess.getstatusoutput(cmd)\n    my_log (cmd +\"with result:\" + str(status))\n    #my_log (\"cmd:\" + cmd)\n    #my_log (\"      output:\"+output)\n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print(('Failed :'+cmd))\n    return  status, output\n\ndef driver_inserted():\n    ret, lsmod = log_os_system(\"ls /sys/module/*accton*\", 0)\n    logging.info('mods:'+lsmod)\n    if ret :\n        return False\n    else :\n        return True\n\n\nkos = [\n'depmod -ae',\n'modprobe i2c_dev',\n'modprobe i2c_mux_pca954x force_deselect_on_exit=1',\n'modprobe accton_i2c_psu',\n'modprobe accton_as9716_32d_cpld',\n'modprobe accton_as9716_32d_fan',\n'modprobe accton_as9716_32d_leds',\n'modprobe accton_as9716_32d_psu',\n'modprobe optoe',\n'modprobe lm75']\n\ncpld_reset_stop='i2cset -y 0 0x65 0x3 0x0'\n\ndef driver_install():\n    \n    global FORCE\n    for i in range(0,len(kos)):\n        status, output = log_os_system(kos[i], 1)\n        if status:\n            if FORCE == 0:\n                return status\n    log_os_system(cpld_reset_stop, 1)\n    print(\"Done driver_install\")\n    return 0\n\ndef driver_uninstall():\n    global FORCE\n    for i in range(0,len(kos)):\n        rm = kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\")        \n        lst = rm.split(\" \")\n\n        if len(lst) > 3:\n            del(lst[3])\n        rm = \" \".join(lst)\n        status, output = log_os_system(rm, 1)\n        if status:\n            if FORCE == 0:\n                return status\n    return 0\n\ndef eeprom_check():\n    cmd = \"i2cget -y -f 0 0x57\"\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef device_install():\n    global FORCE\n    global use_57_eeprom\n\n    for i in range(0,len(mknod)):\n        #for pca954x need times to built new i2c buses\n        if mknod[i].find('pca954') != -1:\n            time.sleep(2)\n        #print(\"init i2c device instance\")\n        status, output = log_os_system(mknod[i], 1)        \n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n    \n    ret=eeprom_check()\n    if ret==0:\n        log_os_system(eeprom_mknod[0], 1) #new board, 0x57 eeprom\n    else:\n        log_os_system(eeprom_mknod[1], 1) #old board, 0x56 eeprom\n        \n    for i in range(0,len(sfp_map)):\n        status, output =log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n        status, output =log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    print(\"Done device_install\")\n\n    return\n\ndef device_uninstall():\n    global FORCE\n\n    status, output =log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0)\n    if status==0:\n        I2C_ORDER=1\n    else:\n    \tI2C_ORDER=0\n\n    for i in range(0,len(sfp_map)):\n        target = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\"\n        status, output =log_os_system(\"echo 0x50 > \"+ target, 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n                \n    nodelist = mknod\n\n    for i in range(len(nodelist)):\n        target = nodelist[-(i+1)]\n        temp = target.split()\n        del temp[1]\n        temp[-1] = temp[-1].replace('new_device', 'delete_device')\n        status, output = log_os_system(\" \".join(temp), 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    ret=eeprom_check()\n    if ret==0:\n        target = eeprom_mknod[0] #0x57\n    else:\n        target = eeprom_mknod[1] #0x56\n    \n    temp = target.split()\n    del temp[1]\n    temp[-1] = temp[-1].replace('new_device', 'delete_device')\n    status, output = log_os_system(\" \".join(temp), 1)\n   \n    return\n\ndef system_ready():\n    if driver_inserted() == False:        \n        return False\n    if not device_exist():\n        print(\"not device_exist()\")\n        return False\n    return True\n\ndef do_install():\n    if driver_inserted() == False:\n        status = driver_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print((PROJECT_NAME.upper()+\" drivers detected....\"))\n\n    ir3570_check()\n\n    if not device_exist():\n        status = device_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print((PROJECT_NAME.upper()+\" devices detected....\"))\n    return\n\ndef do_uninstall():\n    if not device_exist():\n        print((PROJECT_NAME.upper()+\" has no device installed....\"))\n    else:\n        print(\"Removing device....\")\n        status = device_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    if driver_inserted()== False :\n        print((PROJECT_NAME.upper()+\" has no driver installed....\"))\n    else:\n        print(\"Removing installed driver....\")\n        status = driver_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    return\n\ndef device_exist():\n    ret1, log = log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0)\n    ret2, log = log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-fan.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-init.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Disable as9716-32d-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as9716_32d_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n", "add": 7, "remove": 7, "filename": "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py", "badparts": ["import subprocess", "    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as9716-32d-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py clean\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as9716-32d-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"clean\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"install\"])\n     if status:\n         print(\"accton_as9716_32d_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Enable as9716-32d-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as9716-32d-platform-monitor-fan.service failed %d\"%status)\n         return False\n         \n-    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as9716-32d-platform-monitor-psu.service failed %d\"%status)\n         return False\n", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py install\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as9716-32d-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-psu.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"install\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as9716-32d-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-psu.service\"])"]}, {"diff": "\n \n def start_platform_pddf():   \n \n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])"]}, {"diff": "\n \n def stop_platform_pddf():   \n \n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}], "source": "\n import subprocess def check_pddf_support(): return True def stop_platform_svc(): status, output=subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-fan.service\") if status: print(\"Stop as9716-32d-platform-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-psu.service\") if status: print(\"Stop as9716-32d-platform-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor.service\") if status: print(\"Stop as9716-32d-platform-init.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl disable as9716-32d-platform-monitor.service\") if status: print(\"Disable as9716-32d-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py clean\") if status: print(\"accton_as9716_32d_util.py clean command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status) return False return True def start_platform_svc(): status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py install\") if status: print(\"accton_as9716_32d_util.py install command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl enable as9716-32d-platform-monitor.service\") if status: print(\"Enable as9716-32d-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-fan.service\") if status: print(\"Start as9716-32d-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-psu.service\") if status: print(\"Start as9716-32d-platform-monitor-psu.service failed %d\"%status) return False return True def start_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print(\"Start pddf-platform-init.service failed %d\"%status) return False return True def stop_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service failed %d\"%status) return False return True ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services. \n# This will be used while switching the pddf->non-pddf mode and vice versa\nimport subprocess\n\ndef check_pddf_support():\n    return True\n\ndef stop_platform_svc():\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-fan.service\")\n    if status:\n        print(\"Stop as9716-32d-platform-fan.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-psu.service\")\n    if status:\n        print(\"Stop as9716-32d-platform-psu.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor.service\")\n    if status:\n        print(\"Stop as9716-32d-platform-init.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as9716-32d-platform-monitor.service\")\n    if status:\n        print(\"Disable as9716-32d-platform-monitor.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py clean\")\n    if status:\n        print(\"accton_as9716_32d_util.py clean command failed %d\"%status)\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n        return False\n\n    return True\n    \ndef start_platform_svc():\n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py install\")\n    if status:\n        print(\"accton_as9716_32d_util.py install command failed %d\"%status)\n        return False\n\n    status, output = subprocess.getstatusoutput(\"systemctl enable as9716-32d-platform-monitor.service\")\n    if status:\n        print(\"Enable as9716-32d-platform-monitor.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-fan.service\")\n    if status:\n        print(\"Start as9716-32d-platform-monitor-fan.service failed %d\"%status)\n        return False\n        \n    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-psu.service\")\n    if status:\n        print(\"Start as9716-32d-platform-monitor-psu.service failed %d\"%status)\n        return False\n\n    return True\n\ndef start_platform_pddf():   \n\n    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print(\"Start pddf-platform-init.service failed %d\"%status)\n        return False\n    \n    return True\n\ndef stop_platform_pddf():   \n\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service failed %d\"%status)\n        return False\n\n    return True\n\n"}}, "msg": "[device/accton] Replace os.system and remove subprocess with shell=True (#11985)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\n#### Why I did it\r\n`subprocess.Popen()` and `subprocess.run()` is used with `shell=True`, which is very dangerous for shell injection.\r\n`os` - not secure against maliciously constructed input and dangerous if used to evaluate dynamic content\r\n#### How I did it\r\nReplace `os` by `subprocess`\r\nRemove unused functions"}, "2b3e884209d5028c1763b0f83cfc42b5249b4efb": {"url": "https://api.github.com/repos/SaranyaAzhgamuthaiyan/sonic-buildimage/commits/2b3e884209d5028c1763b0f83cfc42b5249b4efb", "html_url": "https://github.com/SaranyaAzhgamuthaiyan/sonic-buildimage/commit/2b3e884209d5028c1763b0f83cfc42b5249b4efb", "sha": "2b3e884209d5028c1763b0f83cfc42b5249b4efb", "keyword": "function injection malicious", "diff": "diff --git a/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py b/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py\nindex cbd48237c..12a1bbe5d 100644\n--- a/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py\n+++ b/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py\n@@ -10,5 +10,7 @@ class board(eeprom_tlvinfo.TlvInfoDecoder):\n     def __init__(self, name, path, cpld_root, ro):\n         self.eeprom_path = \"/sys/class/i2c-adapter/i2c-0/0-0053/eeprom\"\n         if not os.path.exists(self.eeprom_path):\n-            os.system(\"echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device\")\n+            file = \"/sys/class/i2c-adapter/i2c-0/new_device\"\n+            with open(file, 'w') as f:\n+                f.write('24c02 0x53\\n')\n         super(board, self).__init__(self.eeprom_path, 0, '', True)\ndiff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py\nindex eb507a49e..008d5ba08 100755\n--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py\n+++ b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py\n@@ -18,6 +18,7 @@\n     from sonic_platform.thermal import Thermal\n     from sonic_platform.component import Component\n     from sonic_py_common import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -27,11 +28,6 @@\n except ImportError as e:\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n MAX_SELECT_DELAY = 3600\n COPPER_PORT_START = 1\n COPPER_PORT_END = 48\n@@ -209,7 +205,7 @@ def get_revision(self):\n             string: Revision value of chassis\n         \"\"\"\n         if smbus_present == 0:  # called from host\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x0')\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x0'])\n         else:\n             bus = smbus.SMBus(0)\n             DEVICE_ADDRESS = 0x41\n@@ -331,7 +327,7 @@ def set_status_led(self, color):\n \n         # Write sys led\n         if smbus_present == 0:  # called from host (e.g. 'show system-health')\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cset -y 0 0x41 0x7 %d' % value)\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '0', '0x41', '0x7', str(value)])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"  System LED set %s failed\" % value)\n                 return False\n@@ -353,7 +349,7 @@ def get_status_led(self):\n         \"\"\"\n         # Read sys led\n         if smbus_present == 0:  # called from host\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x7')\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x7'])\n             value = int(value, 16)\n         else:\n             bus = smbus.SMBus(0)\ndiff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py\nindex 134856ea4..4e8863e64 100644\n--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py\n+++ b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py\n@@ -9,10 +9,10 @@\n \n try:\n     import os\n-    import sys\n     import subprocess\n     import ntpath\n     from sonic_platform_base.component_base import ComponentBase\n+    from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -22,11 +22,6 @@\n except ImportError as e:\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n \n class Component(ComponentBase):\n     \"\"\"Nokia platform-specific Component class\"\"\"\n@@ -35,29 +30,20 @@ class Component(ComponentBase):\n         [\"System-CPLD\", \"Used for managing SFPs, LEDs, PSUs and FANs \"],\n         [\"U-Boot\", \"Performs initialization during booting\"],\n     ]\n-    CPLD_UPDATE_COMMAND = 'cp /usr/sbin/vme /tmp; cp {} /tmp; cd /tmp; ./vme {};'\n+    CPLD_UPDATE_COMMAND1 = ['cp', '/usr/sbin/vme', '/tmp']\n+    CPLD_UPDATE_COMMAND2 = ['cp', '', '/tmp']\n+    CPLD_UPDATE_COMMAND3 = ['cd', '/tmp']\n+    CPLD_UPDATE_COMMAND4 = ['./vme', '']\n \n     def __init__(self, component_index):\n         self.index = component_index\n         self.name = self.CHASSIS_COMPONENTS[self.index][0]\n         self.description = self.CHASSIS_COMPONENTS[self.index][1]\n \n-    def _get_command_result(self, cmdline):\n-        try:\n-            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,\n-                                    stderr=subprocess.STDOUT)\n-            stdout = proc.communicate()[0]\n-            proc.wait()\n-            result = stdout.rstrip('\\n')\n-        except OSError:\n-            result = None\n-\n-        return result\n-\n     def _get_cpld_version(self, cpld_number):\n \n         if smbus_present == 0:\n-            cmdstatus, cpld_version = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x2')\n+            cmdstatus, cpld_version = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x2'])\n         else:\n             bus = smbus.SMBus(0)\n             DEVICE_ADDRESS = 0x41\n@@ -144,7 +130,10 @@ def get_firmware_version(self):\n             return self._get_cpld_version(self.index)\n \n         if self.index == 1:\n-            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -1 | cut -d\" \" -f2-4')\n+            cmd1 = ['grep', '--null-data', 'U-Boot', '/dev/mtd0ro']\n+            cmd2 = ['head', '-1']\n+            cmd3 = ['cut', '-d', ' ', '-f2-4']\n+            cmdstatus, uboot_version = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)\n             return uboot_version\n \n     def install_firmware(self, image_path):\n@@ -165,12 +154,16 @@ def install_firmware(self, image_path):\n             print(\"ERROR: the cpld image {} doesn't exist \".format(image_path))\n             return False\n \n-        cmdline = self.CPLD_UPDATE_COMMAND.format(image_path, image_name)\n+        self.CPLD_UPDATE_COMMAND2[1] = image_path\n+        self.CPLD_UPDATE_COMMAND4[1] = image_name\n \n         success_flag = False\n-\n-        try:\n-            subprocess.check_call(cmdline, stderr=subprocess.STDOUT, shell=True)\n+ \n+        try:   \n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND1, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND2, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND3, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND4, stderr=subprocess.STDOUT)\n             success_flag = True\n         except subprocess.CalledProcessError as e:\n             print(\"ERROR: Failed to upgrade CPLD: rc={}\".format(e.returncode))\ndiff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py\nindex 383eb2481..243b807ed 100644\n--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py\n+++ b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py\n@@ -8,18 +8,13 @@\n \n try:\n     import os\n-    import sys\n     from sonic_platform_base.psu_base import PsuBase\n     from sonic_py_common import logger\n     from sonic_platform.eeprom import Eeprom\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n smbus_present = 1\n try:\n     import smbus\n@@ -86,7 +81,7 @@ def get_presence(self):\n         \"\"\"\n \n         if smbus_present == 0:  # if called from psuutil outside of pmon\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n@@ -150,7 +145,7 @@ def get_status(self):\n         \"\"\"\n \n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n             sonic_logger.log_warning(\"PMON psu-smbus - presence = 0 \")\n         else:\n@@ -179,7 +174,7 @@ def get_voltage(self):\n             e.g. 12.1\n         \"\"\"\n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n@@ -226,7 +221,7 @@ def get_powergood_status(self):\n         \"\"\"\n \n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus(0)\ndiff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py\nindex d95e7a522..9d8e7e739 100644\n--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py\n+++ b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py\n@@ -3,8 +3,7 @@\n #\n #############################################################################\n \n-import os\n-import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.sfp_base import SfpBase\n@@ -12,14 +11,10 @@\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom\n     from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper\n     from sonic_py_common import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n smbus_present = 1\n \n try:\n@@ -118,7 +113,7 @@ class Sfp(SfpBase):\n     # Paths\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"armhf-nokia_ixs7215_52x-r0\"\n     HWSKU = \"Nokia-7215\"\n@@ -186,7 +181,7 @@ def __convert_string_to_num(self, value_str):\n             return 'N/A'\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n@@ -811,7 +806,7 @@ def tx_disable(self, tx_disable):\n             return False\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, register = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x5')\n+            cmdstatus, register = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x5'])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"sfp cmdstatus i2c get failed %s\" % register )\n                 return False\n@@ -824,13 +819,13 @@ def tx_disable(self, tx_disable):\n \n         pos = [1, 2, 4, 8]\n         mask = pos[self.index-SFP_PORT_START]\n-        if tx_disable == True:\n+        if tx_disable is True:\n             setbits = register | mask\n         else:\n             setbits = register & ~mask\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, output = cmd.getstatusoutput('sudo i2cset -y -m 0x0f 0 0x41 0x5 %d' % setbits)\n+            cmdstatus, output = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '-m', '0x0f', '0', '0x41', '0x5', str(setbits)])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"sfp cmdstatus i2c write failed %s\" % output )\n                 return False\n@@ -912,7 +907,7 @@ def get_presence(self):\n             return False\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')\n+            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])\n             sfpstatus = int(sfpstatus, 16)\n         else:\n             bus = smbus.SMBus(0)\ndiff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py\nindex fd494ca67..34fc2bc6a 100644\n--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py\n+++ b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py\n@@ -1,9 +1,9 @@\n '''\n listen for the SFP change event and return to chassis.\n '''\n-import sys\n import time\n from sonic_py_common import logger\n+from sonic_py_common.general import getstatusoutput_noshell\n \n smbus_present = 1\n \n@@ -12,11 +12,6 @@\n except ImportError as e:\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n # system level event/error\n EVENT_ON_ALL_SFP = '-1'\n SYSTEM_NOT_READY = 'system_not_ready'\n@@ -51,7 +46,7 @@ def deinitialize(self):\n     def _get_transceiver_status(self):\n         if smbus_present == 0:\n             sonic_logger.log_info(\"  PMON - smbus ERROR - DEBUG sfp_event   \")\n-            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')\n+            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])\n             sfpstatus = int(sfpstatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n", "message": "", "files": {"/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py": {"changes": [{"diff": "\n     def __init__(self, name, path, cpld_root, ro):\n         self.eeprom_path = \"/sys/class/i2c-adapter/i2c-0/0-0053/eeprom\"\n         if not os.path.exists(self.eeprom_path):\n-            os.system(\"echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device\")\n+            file = \"/sys/class/i2c-adapter/i2c-0/new_device\"\n+            with open(file, 'w') as f:\n+                f.write('24c02 0x53\\n')\n         super(board, self).__init__(self.eeprom_path, 0, '', True)", "add": 3, "remove": 1, "filename": "/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py", "badparts": ["            os.system(\"echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device\")"], "goodparts": ["            file = \"/sys/class/i2c-adapter/i2c-0/new_device\"", "            with open(file, 'w') as f:", "                f.write('24c02 0x53\\n')"]}], "source": "\ntry: import os from sonic_eeprom import eeprom_tlvinfo except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class board(eeprom_tlvinfo.TlvInfoDecoder): def __init__(self, name, path, cpld_root, ro): self.eeprom_path=\"/sys/class/i2c-adapter/i2c-0/0-0053/eeprom\" if not os.path.exists(self.eeprom_path): os.system(\"echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device\") super(board, self).__init__(self.eeprom_path, 0, '', True) ", "sourceWithComments": "try:\n    import os\n    from sonic_eeprom import eeprom_tlvinfo\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass board(eeprom_tlvinfo.TlvInfoDecoder):\n\n    def __init__(self, name, path, cpld_root, ro):\n        self.eeprom_path = \"/sys/class/i2c-adapter/i2c-0/0-0053/eeprom\"\n        if not os.path.exists(self.eeprom_path):\n            os.system(\"echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device\")\n        super(board, self).__init__(self.eeprom_path, 0, '', True)\n"}, "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py": {"changes": [{"diff": "\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n MAX_SELECT_DELAY = 3600\n COPPER_PORT_START = 1\n COPPER_PORT_END = 48\n", "add": 0, "remove": 5, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py", "badparts": ["if sys.version_info[0] < 3:", "    import commands as cmd", "else:", "    import subprocess as cmd"], "goodparts": []}, {"diff": "\n             string: Revision value of chassis\n         \"\"\"\n         if smbus_present == 0:  # called from host\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x0')\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x0'])\n         else:\n             bus = smbus.SMBus(0)\n             DEVICE_ADDRESS = 0x41\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py", "badparts": ["            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x0')"], "goodparts": ["            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x0'])"]}, {"diff": "\n \n         # Write sys led\n         if smbus_present == 0:  # called from host (e.g. 'show system-health')\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cset -y 0 0x41 0x7 %d' % value)\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '0', '0x41', '0x7', str(value)])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"  System LED set %s failed\" % value)\n                 return False\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py", "badparts": ["            cmdstatus, value = cmd.getstatusoutput('sudo i2cset -y 0 0x41 0x7 %d' % value)"], "goodparts": ["            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '0', '0x41', '0x7', str(value)])"]}, {"diff": "\n         \"\"\"\n         # Read sys led\n         if smbus_present == 0:  # called from host\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x7')\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x7'])\n             value = int(value, 16)\n         else:\n             bus = smbus.SMBus(0", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py", "badparts": ["            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x7')"], "goodparts": ["            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x7'])"]}], "source": "\n try: import os import sys import glob from sonic_platform_base.chassis_base import ChassisBase from sonic_platform.sfp import Sfp from sonic_platform.eeprom import Eeprom from sonic_platform.fan import Fan from.fan_drawer import RealDrawer from sonic_platform.psu import Psu from sonic_platform.thermal import Thermal from sonic_platform.component import Component from sonic_py_common import logger except ImportError as e: raise ImportError(str(e) +\"-required module not found\") smbus_present=1 try: import smbus except ImportError as e: smbus_present=0 if sys.version_info[0] < 3: import commands as cmd else: import subprocess as cmd MAX_SELECT_DELAY=3600 COPPER_PORT_START=1 COPPER_PORT_END=48 SFP_PORT_START=49 SFP_PORT_END=52 PORT_END=52 MAX_7215_FAN_DRAWERS=2 MAX_7215_FANS_PER_DRAWER=1 MAX_7215_PSU=2 MAX_7215_THERMAL=6 MAX_7215_COMPONENT=2 SYSLOG_IDENTIFIER=\"chassis\" sonic_logger=logger.Logger(SYSLOG_IDENTIFIER) class Chassis(ChassisBase): \"\"\" Nokia platform-specific Chassis class Derived from Dell S6000 platform. customized for the 7215 platform. \"\"\" def __init__(self): ChassisBase.__init__(self) self.system_led_supported_color=['off', 'amber', 'green', 'amber_blink', 'green_blink'] self.COPPER_PORT_START=COPPER_PORT_START self.COPPER_PORT_END=COPPER_PORT_END self.SFP_PORT_START=SFP_PORT_START self.SFP_PORT_END=SFP_PORT_END self.PORT_END=PORT_END for index in range(self.COPPER_PORT_START, self.COPPER_PORT_END+1): sfp_node=Sfp(index, 'COPPER', 'N/A', 'N/A') self._sfp_list.append(sfp_node) eeprom_path=\"/sys/class/i2c-adapter/i2c-{0}/{0}-0050/eeprom\" mux_dev=sorted(glob.glob(\"/sys/class/i2c-adapter/i2c-0/i2c-[0-9]\")) y=0 for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1): mux_dev_num=mux_dev[y] port_i2c_map=mux_dev_num[-1] y=y +1 port_eeprom_path=eeprom_path.format(port_i2c_map) if not os.path.exists(port_eeprom_path): sonic_logger.log_info(\"path %s didnt exist\" % port_eeprom_path) sfp_node=Sfp(index, 'SFP', port_eeprom_path, port_i2c_map) self._sfp_list.append(sfp_node) self.sfp_event_initialized=False self._eeprom=Eeprom() drawer_num=MAX_7215_FAN_DRAWERS fan_num_per_drawer=MAX_7215_FANS_PER_DRAWER drawer_ctor=RealDrawer fan_index=0 for drawer_index in range(drawer_num): drawer=drawer_ctor(drawer_index) self._fan_drawer_list.append(drawer) for index in range(fan_num_per_drawer): fan=Fan(fan_index, drawer) fan_index +=1 drawer._fan_list.append(fan) self._fan_list.append(fan) for i in range(MAX_7215_PSU): psu=Psu(i) self._psu_list.append(psu) for i in range(MAX_7215_THERMAL): thermal=Thermal(i) self._thermal_list.append(thermal) for i in range(MAX_7215_COMPONENT): component=Component(i) self._component_list.append(component) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of physical SFP ports in a chassis starting from 1. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_name(self): \"\"\" Retrieves the name of the chassis Returns: string: The name of the chassis \"\"\" return self._eeprom.modelstr() def get_presence(self): \"\"\" Retrieves the presence of the chassis Returns: bool: True if chassis is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the chassis Returns: string: Model/part number of chassis \"\"\" return self._eeprom.part_number_str() def get_service_tag(self): \"\"\" Retrieves the Service Tag of the chassis Returns: string: Service Tag of chassis \"\"\" return self._eeprom.service_tag_str() def get_status(self): \"\"\" Retrieves the operational status of the chassis Returns: bool: A boolean value, True if chassis is operating properly False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.base_mac_addr() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.serial_number_str() def get_revision(self): \"\"\" Retrieves the hardware revision of the chassis Returns: string: Revision value of chassis \"\"\" if smbus_present==0: cmdstatus, value=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x0') else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0x0 value=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) return str(value) def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.system_eeprom_info() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" return(ChassisBase.REBOOT_CAUSE_NON_HARDWARE, None) def get_change_event(self, timeout=0): \"\"\" Returns a nested dictionary containing all devices which have experienced a change at chassis level Args: timeout: Timeout in milliseconds(optional). If timeout==0, this method will block until a change is detected. Returns: (bool, dict): -True if call successful, False if not; -A nested dictionary where key is a device type, value is a dictionary with key:value pairs in the format of {'device_id':'device_event'}, where device_id is the device ID for this device and device_event, status='1' represents device inserted, status='0' represents device removed. Ex.{'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}} indicates that fan 0 has been removed, fan 2 has been inserted and sfp 11 has been removed. \"\"\" if not self.sfp_event_initialized: from sonic_platform.sfp_event import sfp_event self.sfp_event=sfp_event() self.sfp_event.initialize() self.MAX_SELECT_EVENT_RETURNED=self.PORT_END self.sfp_event_initialized=True wait_for_ever=(timeout==0) port_dict={} if wait_for_ever: timeout=MAX_SELECT_DELAY while True: status=self.sfp_event.check_sfp_status(port_dict, timeout) if not port_dict=={}: break else: status=self.sfp_event.check_sfp_status(port_dict, timeout) if status: return True,{'sfp': port_dict} else: return True,{'sfp':{}} def get_thermal_manager(self): from.thermal_manager import ThermalManager return ThermalManager def initizalize_system_led(self): return True def set_status_led(self, color): \"\"\" Sets the state of the system LED Args: color: A string representing the color with which to set the system LED Returns: bool: True if system LED state is set successfully, False if not \"\"\" if color not in self.system_led_supported_color: return False if(color=='off'): value=0x00 elif(color=='amber'): value=0x01 elif(color=='green'): value=0x02 elif(color=='amber_blink'): value=0x03 elif(color=='green_blink'): value=0x04 else: return False if smbus_present==0: cmdstatus, value=cmd.getstatusoutput('sudo i2cset -y 0 0x41 0x7 %d' % value) if cmdstatus: sonic_logger.log_warning(\" System LED set %s failed\" % value) return False else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICEREG=0x7 bus.write_byte_data(DEVICE_ADDRESS, DEVICEREG, value) return True def get_status_led(self): \"\"\" Gets the state of the system LED Returns: A string, one of the valid LED color strings which could be vendor specified. \"\"\" if smbus_present==0: cmdstatus, value=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x7') value=int(value, 16) else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0x7 value=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) if value==0x00: color='off' elif value==0x01: color='amber' elif value==0x02: color='green' elif value==0x03: color='amber_blink' elif value==0x04: color='green_blink' else: return None return color def get_watchdog(self): \"\"\" Retrieves hardware watchdog device on this chassis Returns: An object derived from WatchdogBase representing the hardware watchdog device Note: We overload this method to ensure that watchdog is only initialized when it is referenced. Currently, only one daemon can open the watchdog. To initialize watchdog in the constructor causes multiple daemon try opening watchdog when loading and constructing a chassis object and fail. By doing so we can eliminate that risk. \"\"\" try: if self._watchdog is None: from sonic_platform.watchdog import WatchdogImplBase watchdog_device_path=\"/dev/watchdog0\" self._watchdog=WatchdogImplBase(watchdog_device_path) except Exception as e: sonic_logger.log_warning(\" Fail to load watchdog{}\".format(repr(e))) return self._watchdog def get_position_in_parent(self): \"\"\" \t\tRetrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned \t\tReturns: \t\t integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \t\t\"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the platform information\n#\n#############################################################################\n\ntry:\n    import os\n    import sys\n    import glob\n    from sonic_platform_base.chassis_base import ChassisBase\n    from sonic_platform.sfp import Sfp\n    from sonic_platform.eeprom import Eeprom\n    from sonic_platform.fan import Fan\n    from .fan_drawer import RealDrawer\n    from sonic_platform.psu import Psu\n    from sonic_platform.thermal import Thermal\n    from sonic_platform.component import Component\n    from sonic_py_common import logger\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nsmbus_present = 1\ntry:\n    import smbus\nexcept ImportError as e:\n    smbus_present = 0\n\nif sys.version_info[0] < 3:\n    import commands as cmd\nelse:\n    import subprocess as cmd\n\nMAX_SELECT_DELAY = 3600\nCOPPER_PORT_START = 1\nCOPPER_PORT_END = 48\nSFP_PORT_START = 49\nSFP_PORT_END = 52\nPORT_END = 52\n\n# Device counts\nMAX_7215_FAN_DRAWERS = 2\nMAX_7215_FANS_PER_DRAWER = 1\nMAX_7215_PSU = 2\nMAX_7215_THERMAL = 6\n\n# Temp - disable these to help with early debug\nMAX_7215_COMPONENT = 2\n\nSYSLOG_IDENTIFIER = \"chassis\"\nsonic_logger = logger.Logger(SYSLOG_IDENTIFIER)\n\n\nclass Chassis(ChassisBase):\n    \"\"\"\n    Nokia platform-specific Chassis class\n        Derived from Dell S6000 platform.\n        customized for the 7215 platform.\n    \"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self.system_led_supported_color = ['off', 'amber', 'green', 'amber_blink', 'green_blink']\n        # Port numbers for SFP List Initialization\n        self.COPPER_PORT_START = COPPER_PORT_START\n        self.COPPER_PORT_END = COPPER_PORT_END\n        self.SFP_PORT_START = SFP_PORT_START\n        self.SFP_PORT_END = SFP_PORT_END\n        self.PORT_END = PORT_END\n\n        # for non-sfp ports create dummy objects for copper / non-sfp ports\n        for index in range(self.COPPER_PORT_START, self.COPPER_PORT_END+1):\n            sfp_node = Sfp(index, 'COPPER', 'N/A', 'N/A')\n            self._sfp_list.append(sfp_node)\n\n        # Verify optoe2 driver SFP eeprom devices were enumerated and exist\n        # then create the sfp nodes\n        eeprom_path = \"/sys/class/i2c-adapter/i2c-{0}/{0}-0050/eeprom\"\n        mux_dev = sorted(glob.glob(\"/sys/class/i2c-adapter/i2c-0/i2c-[0-9]\"))\n        y = 0\n        for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1):\n            mux_dev_num = mux_dev[y]\n            port_i2c_map = mux_dev_num[-1]\n            y = y + 1\n            port_eeprom_path = eeprom_path.format(port_i2c_map)\n            if not os.path.exists(port_eeprom_path):\n                sonic_logger.log_info(\"path %s didnt exist\" % port_eeprom_path)\n            sfp_node = Sfp(index, 'SFP', port_eeprom_path, port_i2c_map)\n            self._sfp_list.append(sfp_node)\n        self.sfp_event_initialized = False\n\n        # Instantiate system eeprom object\n        self._eeprom = Eeprom()\n\n        # Construct lists fans, power supplies, thermals & components\n        drawer_num = MAX_7215_FAN_DRAWERS\n        fan_num_per_drawer = MAX_7215_FANS_PER_DRAWER\n        drawer_ctor = RealDrawer\n        fan_index = 0\n        for drawer_index in range(drawer_num):\n            drawer = drawer_ctor(drawer_index)\n            self._fan_drawer_list.append(drawer)\n            for index in range(fan_num_per_drawer):\n                fan = Fan(fan_index, drawer)\n                fan_index += 1\n                drawer._fan_list.append(fan)\n                self._fan_list.append(fan)\n\n        for i in range(MAX_7215_PSU):\n            psu = Psu(i)\n            self._psu_list.append(psu)\n\n        for i in range(MAX_7215_THERMAL):\n            thermal = Thermal(i)\n            self._thermal_list.append(thermal)\n\n        for i in range(MAX_7215_COMPONENT):\n            component = Component(i)\n            self._component_list.append(component)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of physical SFP ports in a\n            chassis starting from 1.\n\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the chassis\n        Returns:\n            string: The name of the chassis\n        \"\"\"\n        return self._eeprom.modelstr()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the chassis\n        Returns:\n            bool: True if chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the chassis\n        Returns:\n            string: Model/part number of chassis\n        \"\"\"\n        return self._eeprom.part_number_str()\n\n    def get_service_tag(self):\n        \"\"\"\n        Retrieves the Service Tag of the chassis\n        Returns:\n            string: Service Tag of chassis\n        \"\"\"\n        return self._eeprom.service_tag_str()\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the chassis\n        Returns:\n            bool: A boolean value, True if chassis is operating properly\n            False if not\n        \"\"\"\n        return True\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.base_mac_addr()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n\n        Returns:\n            A string containing the hardware serial number for this\n            chassis.\n        \"\"\"\n        return self._eeprom.serial_number_str()\n\n    def get_revision(self):\n        \"\"\"\n        Retrieves the hardware revision of the chassis\n\n        Returns:\n            string: Revision value of chassis\n        \"\"\"\n        if smbus_present == 0:  # called from host\n            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x0')\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0x0\n            value = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n        return str(value)\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the\n        chassis\n\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their\n            corresponding values.\n        \"\"\"\n        return self._eeprom.system_eeprom_info()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        # The ixs7215 CPLD does not have a hardware reboot cause register so\n        # the hardware portion of reboot cause can't be implemented\n\n        return (ChassisBase.REBOOT_CAUSE_NON_HARDWARE, None)\n\n    def get_change_event(self, timeout=0):\n        \"\"\"\n        Returns a nested dictionary containing all devices which have\n        experienced a change at chassis level\n\n        Args:\n            timeout: Timeout in milliseconds (optional). If timeout == 0,\n                this method will block until a change is detected.\n\n        Returns:\n            (bool, dict):\n                - True if call successful, False if not;\n                - A nested dictionary where key is a device type,\n                  value is a dictionary with key:value pairs in the format of\n                  {'device_id':'device_event'},\n                  where device_id is the device ID for this device and\n                        device_event,\n                             status='1' represents device inserted,\n                             status='0' represents device removed.\n                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}\n                      indicates that fan 0 has been removed, fan 2\n                      has been inserted and sfp 11 has been removed.\n        \"\"\"\n        # Initialize SFP event first\n        if not self.sfp_event_initialized:\n            from sonic_platform.sfp_event import sfp_event\n            self.sfp_event = sfp_event()\n            self.sfp_event.initialize()\n            self.MAX_SELECT_EVENT_RETURNED = self.PORT_END\n            self.sfp_event_initialized = True\n\n        wait_for_ever = (timeout == 0)\n        port_dict = {}\n        if wait_for_ever:\n            # xrcvd will call this monitor loop in the \"SYSTEM_READY\" state\n            timeout = MAX_SELECT_DELAY\n            while True:\n                status = self.sfp_event.check_sfp_status(port_dict, timeout)\n                if not port_dict == {}:\n                    break\n        else:\n            # At boot up and in \"INIT\" state call from xrcvd will have timeout\n            # value return true without change after timeout and will\n            # transition to \"SYSTEM_READY\"\n            status = self.sfp_event.check_sfp_status(port_dict, timeout)\n\n        if status:\n            return True, {'sfp': port_dict}\n        else:\n            return True, {'sfp': {}}\n\n    def get_thermal_manager(self):\n        from .thermal_manager import ThermalManager\n        return ThermalManager\n\n    def initizalize_system_led(self):\n        return True\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the system LED\n\n        Args:\n            color: A string representing the color with which to set the\n                   system LED\n\n        Returns:\n            bool: True if system LED state is set successfully, False if not\n        \"\"\"\n        if color not in self.system_led_supported_color:\n            return False\n\n        if (color == 'off'):\n            value = 0x00\n        elif (color == 'amber'):\n            value = 0x01\n        elif (color == 'green'):\n            value = 0x02\n        elif (color == 'amber_blink'):\n            value = 0x03\n        elif (color == 'green_blink'):\n            value = 0x04\n        else:\n            return False\n\n        # Write sys led\n        if smbus_present == 0:  # called from host (e.g. 'show system-health')\n            cmdstatus, value = cmd.getstatusoutput('sudo i2cset -y 0 0x41 0x7 %d' % value)\n            if cmdstatus:\n                sonic_logger.log_warning(\"  System LED set %s failed\" % value)\n                return False\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICEREG = 0x7\n            bus.write_byte_data(DEVICE_ADDRESS, DEVICEREG, value)\n\n        return True\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the system LED\n\n        Returns:\n            A string, one of the valid LED color strings which could be vendor\n            specified.\n        \"\"\"\n        # Read sys led\n        if smbus_present == 0:  # called from host\n            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x7')\n            value = int(value, 16)\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0x7\n            value = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n        if value == 0x00:\n            color = 'off'\n        elif value == 0x01:\n            color = 'amber'\n        elif value == 0x02:\n            color = 'green'\n        elif value == 0x03:\n            color = 'amber_blink'\n        elif value == 0x04:\n            color = 'green_blink'\n        else:\n            return None\n\n        return color\n\n    def get_watchdog(self):\n        \"\"\"\n        Retrieves hardware watchdog device on this chassis\n\n        Returns:\n            An object derived from WatchdogBase representing the hardware\n            watchdog device\n\n        Note:\n            We overload this method to ensure that watchdog is only initialized\n            when it is referenced. Currently, only one daemon can open the\n            watchdog. To initialize watchdog in the constructor causes multiple\n            daemon try opening watchdog when loading and constructing a chassis\n            object and fail. By doing so we can eliminate that risk.\n        \"\"\"\n        try:\n            if self._watchdog is None:\n                from sonic_platform.watchdog import WatchdogImplBase\n                watchdog_device_path = \"/dev/watchdog0\"\n                self._watchdog = WatchdogImplBase(watchdog_device_path)\n        except Exception as e:\n            sonic_logger.log_warning(\" Fail to load watchdog {}\".format(repr(e)))\n\n        return self._watchdog\n\n    def get_position_in_parent(self):\n        \"\"\"\n\t\tRetrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n\t\tReturns:\n\t\t    integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n\t\t\"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py": {"changes": [{"diff": "\n \n try:\n     import os\n-    import sys\n     import subprocess\n     import ntpath\n     from sonic_platform_base.component_base import ComponentBase\n+    from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py", "badparts": ["    import sys"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe"]}, {"diff": "\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n \n class Component(ComponentBase):\n     \"\"\"Nokia platform-specific Component class\"\"\"\n", "add": 0, "remove": 5, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py", "badparts": ["if sys.version_info[0] < 3:", "    import commands as cmd", "else:", "    import subprocess as cmd"], "goodparts": []}, {"diff": "\n         [\"System-CPLD\", \"Used for managing SFPs, LEDs, PSUs and FANs \"],\n         [\"U-Boot\", \"Performs initialization during booting\"],\n     ]\n-    CPLD_UPDATE_COMMAND = 'cp /usr/sbin/vme /tmp; cp {} /tmp; cd /tmp; ./vme {};'\n+    CPLD_UPDATE_COMMAND1 = ['cp', '/usr/sbin/vme', '/tmp']\n+    CPLD_UPDATE_COMMAND2 = ['cp', '', '/tmp']\n+    CPLD_UPDATE_COMMAND3 = ['cd', '/tmp']\n+    CPLD_UPDATE_COMMAND4 = ['./vme', '']\n \n     def __init__(self, component_index):\n         self.index = component_index\n         self.name = self.CHASSIS_COMPONENTS[self.index][0]\n         self.description = self.CHASSIS_COMPONENTS[self.index][1]\n \n-    def _get_command_result(self, cmdline):\n-        try:\n-            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,\n-                                    stderr=subprocess.STDOUT)\n-            stdout = proc.communicate()[0]\n-            proc.wait()\n-            result = stdout.rstrip('\\n')\n-        except OSError:\n-            result = None\n-\n-        return result\n-\n     def _get_cpld_version(self, cpld_number):\n \n         if smbus_present == 0:\n-            cmdstatus, cpld_version = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x2')\n+            cmdstatus, cpld_version = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x2'])\n         else:\n             bus = smbus.SMBus(0)\n             DEVICE_ADDRESS = 0x41\n", "add": 5, "remove": 14, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py", "badparts": ["    CPLD_UPDATE_COMMAND = 'cp /usr/sbin/vme /tmp; cp {} /tmp; cd /tmp; ./vme {};'", "    def _get_command_result(self, cmdline):", "        try:", "            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,", "                                    stderr=subprocess.STDOUT)", "            stdout = proc.communicate()[0]", "            proc.wait()", "            result = stdout.rstrip('\\n')", "        except OSError:", "            result = None", "        return result", "            cmdstatus, cpld_version = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x2')"], "goodparts": ["    CPLD_UPDATE_COMMAND1 = ['cp', '/usr/sbin/vme', '/tmp']", "    CPLD_UPDATE_COMMAND2 = ['cp', '', '/tmp']", "    CPLD_UPDATE_COMMAND3 = ['cd', '/tmp']", "    CPLD_UPDATE_COMMAND4 = ['./vme', '']", "            cmdstatus, cpld_version = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x2'])"]}, {"diff": "\n             return self._get_cpld_version(self.index)\n \n         if self.index == 1:\n-            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -1 | cut -d\" \" -f2-4')\n+            cmd1 = ['grep', '--null-data', 'U-Boot', '/dev/mtd0ro']\n+            cmd2 = ['head', '-1']\n+            cmd3 = ['cut', '-d', ' ', '-f2-4']\n+            cmdstatus, uboot_version = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)\n             return uboot_version\n \n     def install_firmware(self, image_path):\n", "add": 4, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py", "badparts": ["            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -1 | cut -d\" \" -f2-4')"], "goodparts": ["            cmd1 = ['grep', '--null-data', 'U-Boot', '/dev/mtd0ro']", "            cmd2 = ['head', '-1']", "            cmd3 = ['cut', '-d', ' ', '-f2-4']", "            cmdstatus, uboot_version = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)"]}, {"diff": "\n             print(\"ERROR: the cpld image {} doesn't exist \".format(image_path))\n             return False\n \n-        cmdline = self.CPLD_UPDATE_COMMAND.format(image_path, image_name)\n+        self.CPLD_UPDATE_COMMAND2[1] = image_path\n+        self.CPLD_UPDATE_COMMAND4[1] = image_name\n \n         success_flag = False\n-\n-        try:\n-            subprocess.check_call(cmdline, stderr=subprocess.STDOUT, shell=True)\n+ \n+        try:   \n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND1, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND2, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND3, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND4, stderr=subprocess.STDOUT)\n             success_flag = True\n         except subprocess.CalledProcessError as e:\n             print(\"ERROR: Failed to upgrade CPLD: rc={}\".format(e.returncode", "add": 8, "remove": 4, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py", "badparts": ["        cmdline = self.CPLD_UPDATE_COMMAND.format(image_path, image_name)", "        try:", "            subprocess.check_call(cmdline, stderr=subprocess.STDOUT, shell=True)"], "goodparts": ["        self.CPLD_UPDATE_COMMAND2[1] = image_path", "        self.CPLD_UPDATE_COMMAND4[1] = image_name", "        try:   ", "            subprocess.check_call(self.CPLD_UPDATE_COMMAND1, stderr=subprocess.STDOUT)", "            subprocess.check_call(self.CPLD_UPDATE_COMMAND2, stderr=subprocess.STDOUT)", "            subprocess.check_call(self.CPLD_UPDATE_COMMAND3, stderr=subprocess.STDOUT)", "            subprocess.check_call(self.CPLD_UPDATE_COMMAND4, stderr=subprocess.STDOUT)"]}], "source": "\n try: import os import sys import subprocess import ntpath from sonic_platform_base.component_base import ComponentBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") smbus_present=1 try: import smbus except ImportError as e: smbus_present=0 if sys.version_info[0] < 3: import commands as cmd else: import subprocess as cmd class Component(ComponentBase): \"\"\"Nokia platform-specific Component class\"\"\" CHASSIS_COMPONENTS=[ [\"System-CPLD\", \"Used for managing SFPs, LEDs, PSUs and FANs \"], [\"U-Boot\", \"Performs initialization during booting\"], ] CPLD_UPDATE_COMMAND='cp /usr/sbin/vme /tmp; cp{} /tmp; cd /tmp;./vme{};' def __init__(self, component_index): self.index=component_index self.name=self.CHASSIS_COMPONENTS[self.index][0] self.description=self.CHASSIS_COMPONENTS[self.index][1] def _get_command_result(self, cmdline): try: proc=subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE, stderr=subprocess.STDOUT) stdout=proc.communicate()[0] proc.wait() result=stdout.rstrip('\\n') except OSError: result=None return result def _get_cpld_version(self, cpld_number): if smbus_present==0: cmdstatus, cpld_version=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x2') else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0x2 cpld_version=str(bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)) return str(int(cpld_version, 16)) def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return self.name def get_model(self): \"\"\" Retrieves the part number of the component Returns: string: Part number of component \"\"\" return 'NA' def get_serial(self): \"\"\" Retrieves the serial number of the component Returns: string: Serial number of component \"\"\" return 'NA' def get_presence(self): \"\"\" Retrieves the presence of the component Returns: bool: True if present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the component Returns: bool: True if component is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether component is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return self.description def get_firmware_version(self): \"\"\" Retrieves the firmware version of the component Returns: A string containing the firmware version of the component \"\"\" if self.index==0: return self._get_cpld_version(self.index) if self.index==1: cmdstatus, uboot_version=cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -1 | cut -d\" \" -f2-4') return uboot_version def install_firmware(self, image_path): \"\"\" Installs firmware to the component Args: image_path: A string, path to firmware image Returns: A boolean, True if install was successful, False if not \"\"\" image_name=ntpath.basename(image_path) print(\" ixs7215 -install cpld{}\".format(image_name)) if not os.path.isfile(image_path): print(\"ERROR: the cpld image{} doesn't exist \".format(image_path)) return False cmdline=self.CPLD_UPDATE_COMMAND.format(image_path, image_name) success_flag=False try: subprocess.check_call(cmdline, stderr=subprocess.STDOUT, shell=True) success_flag=True except subprocess.CalledProcessError as e: print(\"ERROR: Failed to upgrade CPLD: rc={}\".format(e.returncode)) if success_flag: print(\"INFO: Refresh or power cycle is required to finish CPLD installation\") return success_flag ", "sourceWithComments": "########################################################################\n# NOKIA IXS7215\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Components' (e.g., BIOS, CPLD, FPGA, etc.) available in\n# the platform\n#\n########################################################################\n\ntry:\n    import os\n    import sys\n    import subprocess\n    import ntpath\n    from sonic_platform_base.component_base import ComponentBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nsmbus_present = 1\ntry:\n    import smbus\nexcept ImportError as e:\n    smbus_present = 0\n\nif sys.version_info[0] < 3:\n    import commands as cmd\nelse:\n    import subprocess as cmd\n\n\nclass Component(ComponentBase):\n    \"\"\"Nokia platform-specific Component class\"\"\"\n\n    CHASSIS_COMPONENTS = [\n        [\"System-CPLD\", \"Used for managing SFPs, LEDs, PSUs and FANs \"],\n        [\"U-Boot\", \"Performs initialization during booting\"],\n    ]\n    CPLD_UPDATE_COMMAND = 'cp /usr/sbin/vme /tmp; cp {} /tmp; cd /tmp; ./vme {};'\n\n    def __init__(self, component_index):\n        self.index = component_index\n        self.name = self.CHASSIS_COMPONENTS[self.index][0]\n        self.description = self.CHASSIS_COMPONENTS[self.index][1]\n\n    def _get_command_result(self, cmdline):\n        try:\n            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,\n                                    stderr=subprocess.STDOUT)\n            stdout = proc.communicate()[0]\n            proc.wait()\n            result = stdout.rstrip('\\n')\n        except OSError:\n            result = None\n\n        return result\n\n    def _get_cpld_version(self, cpld_number):\n\n        if smbus_present == 0:\n            cmdstatus, cpld_version = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x2')\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0x2\n            cpld_version = str(bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG))\n\n        return str(int(cpld_version, 16))\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n\n        Returns:\n            A string containing the name of the component\n        \"\"\"\n        return self.name\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the part number of the component\n        Returns:\n            string: Part number of component\n        \"\"\"\n        return 'NA'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the component\n        Returns:\n            string: Serial number of component\n        \"\"\"\n        return 'NA'\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the component\n        Returns:\n            bool: True if  present, False if not\n        \"\"\"\n        return True\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the component\n        Returns:\n            bool: True if component is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        Returns:\n            integer: The 1-based relative physical position in parent\n            device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether component is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n\n        Returns:\n            A string containing the description of the component\n        \"\"\"\n        return self.description\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of the component\n\n        Returns:\n            A string containing the firmware version of the component\n        \"\"\"\n        if self.index == 0:\n            return self._get_cpld_version(self.index)\n\n        if self.index == 1:\n            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -1 | cut -d\" \" -f2-4')\n            return uboot_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Installs firmware to the component\n\n        Args:\n            image_path: A string, path to firmware image\n\n        Returns:\n            A boolean, True if install was successful, False if not\n        \"\"\"\n        image_name = ntpath.basename(image_path)\n        print(\" ixs7215 - install cpld {}\".format(image_name))\n\n        # check whether the image file exists\n        if not os.path.isfile(image_path):\n            print(\"ERROR: the cpld image {} doesn't exist \".format(image_path))\n            return False\n\n        cmdline = self.CPLD_UPDATE_COMMAND.format(image_path, image_name)\n\n        success_flag = False\n\n        try:\n            subprocess.check_call(cmdline, stderr=subprocess.STDOUT, shell=True)\n            success_flag = True\n        except subprocess.CalledProcessError as e:\n            print(\"ERROR: Failed to upgrade CPLD: rc={}\".format(e.returncode))\n\n        if success_flag:\n            print(\"INFO: Refresh or power cycle is required to finish CPLD installation\")\n\n        return success_flag\n\n"}, "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py": {"changes": [{"diff": "\n \n try:\n     import os\n-    import sys\n     from sonic_platform_base.psu_base import PsuBase\n     from sonic_py_common import logger\n     from sonic_platform.eeprom import Eeprom\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n smbus_present = 1\n try:\n     import smbus\n", "add": 1, "remove": 6, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py", "badparts": ["    import sys", "if sys.version_info[0] < 3:", "    import commands as cmd", "else:", "    import subprocess as cmd"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         \"\"\"\n \n         if smbus_present == 0:  # if called from psuutil outside of pmon\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py", "badparts": ["            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')"], "goodparts": ["            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])"]}, {"diff": "\n         \"\"\"\n \n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n             sonic_logger.log_warning(\"PMON psu-smbus - presence = 0 \")\n         else:\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py", "badparts": ["            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')"], "goodparts": ["            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])"]}, {"diff": "\n             e.g. 12.1\n         \"\"\"\n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py", "badparts": ["            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')"], "goodparts": ["            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])"]}, {"diff": "\n         \"\"\"\n \n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py", "badparts": ["            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')"], "goodparts": ["            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])"]}], "source": "\n try: import os import sys from sonic_platform_base.psu_base import PsuBase from sonic_py_common import logger from sonic_platform.eeprom import Eeprom except ImportError as e: raise ImportError(str(e) +\"-required module not found\") if sys.version_info[0] < 3: import commands as cmd else: import subprocess as cmd smbus_present=1 try: import smbus except ImportError as e: smbus_present=0 sonic_logger=logger.Logger('psu') class Psu(PsuBase): \"\"\"Nokia platform-specific PSU class for 7215 \"\"\" def __init__(self, psu_index): PsuBase.__init__(self) self.index=psu_index +1 self._fan_list=[] self.eeprom=Eeprom(is_psu=True, psu_index=self.index) def _write_sysfs_file(self, sysfs_file, value): rv='ERR' if(not os.path.isfile(sysfs_file)): return rv try: with open(sysfs_file, 'w') as fd: rv=fd.write(str(value)) except Exception as e: rv='ERR' return rv def _read_sysfs_file(self, sysfs_file): rv='ERR' if(not os.path.isfile(sysfs_file)): return rv try: with open(sysfs_file, 'r') as fd: rv=fd.read() except Exception as e: rv='ERR' rv=rv.rstrip('\\r\\n') rv=rv.lstrip(\" \") return rv def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return \"PSU{}\".format(self.index) def get_presence(self): \"\"\" Retrieves the presence of the Power Supply Unit(PSU) Returns: bool: True if PSU is present, False if not \"\"\" if smbus_present==0: cmdstatus, psustatus=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa') psustatus=int(psustatus, 16) else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0xa psustatus=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) if self.index==1: psustatus=psustatus & 1 if psustatus==1: return False if self.index==2: psustatus=psustatus & 2 if psustatus==2: return False return True def get_model(self): \"\"\" Retrieves the part number of the PSU Returns: string: Part number of PSU \"\"\" return self.eeprom.modelstr() def get_serial(self): \"\"\" Retrieves the serial number of the PSU Returns: string: Serial number of PSU \"\"\" return self.eeprom.serial_number_str() def get_revision(self): \"\"\" Retrieves the HW revision of the PSU Returns: string: HW revision of PSU \"\"\" return self.eeprom.part_number_str() def get_part_number(self): \"\"\" Retrieves the part number of the PSU Returns: string: Part number of PSU \"\"\" return self.eeprom.part_number_str() def get_status(self): \"\"\" Retrieves the operational status of the PSU Returns: bool: True if PSU is operating properly, False if not \"\"\" if smbus_present==0: cmdstatus, psustatus=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa') psustatus=int(psustatus, 16) sonic_logger.log_warning(\"PMON psu-smbus -presence=0 \") else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0xa psustatus=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) if self.index==1: psustatus=psustatus & 4 if psustatus==4: return True if self.index==2: psustatus=psustatus & 8 if psustatus==8: return True return False def get_voltage(self): \"\"\" Retrieves current PSU voltage output Returns: A float number, the output voltage in volts, e.g. 12.1 \"\"\" if smbus_present==0: cmdstatus, psustatus=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa') psustatus=int(psustatus, 16) else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0xa psustatus=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) if self.index==1: psustatus=psustatus & 4 if psustatus==4: psu_voltage=12.0 return psu_voltage if self.index==2: psustatus=psustatus & 8 if psustatus==8: psu_voltage=12.0 return psu_voltage psu_voltage=0.0 return psu_voltage def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device Returns: integer: The 1-based relative physical position in parent device \"\"\" return self.index def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return True def get_powergood_status(self): \"\"\" Retrieves the powergood status of PSU Returns: A boolean, True if PSU has stablized its output voltages and passed all its internal self-tests, False if not. \"\"\" if smbus_present==0: cmdstatus, psustatus=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa') psustatus=int(psustatus, 16) else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0xa psustatus=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) if self.index==1: psustatus=psustatus & 4 if psustatus==4: return True if self.index==2: psustatus=psustatus & 8 if psustatus==8: return True return False def get_status_led(self): \"\"\" Gets the state of the PSU status LED Returns: A string, one of the predefined STATUS_LED_COLOR_* strings. \"\"\" if self.get_powergood_status(): return self.STATUS_LED_COLOR_GREEN else: return self.STATUS_LED_COLOR_OFF def set_status_led(self, color): \"\"\" Sets the state of the PSU status LED Args: color: A string representing the color with which to set the PSU status LED Returns: bool: True if status LED state is set successfully, False if not \"\"\" return False def get_status_master_led(self): \"\"\" Gets the state of the front panel PSU status LED Returns: A string, one of the predefined STATUS_LED_COLOR_* strings. \"\"\" if(not os.path.isfile(\"/sys/class/gpio/psuLedGreen/value\") or not os.path.isfile(\"/sys/class/gpio/psuLedAmber/value\")): return None green=self._read_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\") amber=self._read_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\") if green==\"ERR\" or amber==\"ERR\": return None if green==\"1\": return self.STATUS_LED_COLOR_GREEN elif amber==\"1\": return self.STATUS_LED_COLOR_AMBER else: return None def set_status_master_led(self, color): \"\"\" Sets the state of the front panel PSU status LED Returns: bool: True if status LED state is set successfully, False if not \"\"\" if(not os.path.isfile(\"/sys/class/gpio/psuLedGreen/value\") or not os.path.isfile(\"/sys/class/gpio/psuLedAmber/value\")): return False if color==self.STATUS_LED_COLOR_GREEN: rvg=self._write_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\", 1) if rvg !=\"ERR\": rva=self._write_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\", 0) elif color==self.STATUS_LED_COLOR_AMBER: rvg=self._write_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\", 0) if rvg !=\"ERR\": rva=self._write_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\", 1) else: return False if rvg==\"ERR\" or rva==\"ERR\": return False return True ", "sourceWithComments": "########################################################################\n# Nokia IXS7215\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the PSUs' information which are available in the platform\n#\n########################################################################\n\ntry:\n    import os\n    import sys\n    from sonic_platform_base.psu_base import PsuBase\n    from sonic_py_common import logger\n    from sonic_platform.eeprom import Eeprom\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nif sys.version_info[0] < 3:\n    import commands as cmd\nelse:\n    import subprocess as cmd\n\nsmbus_present = 1\ntry:\n    import smbus\nexcept ImportError as e:\n    smbus_present = 0\n\nsonic_logger = logger.Logger('psu')\n\nclass Psu(PsuBase):\n    \"\"\"Nokia platform-specific PSU class for 7215 \"\"\"\n\n    def __init__(self, psu_index):\n        PsuBase.__init__(self)\n        # PSU is 1-based in Nokia platforms\n        self.index = psu_index + 1\n        self._fan_list = []\n\n        # PSU eeprom\n        self.eeprom = Eeprom(is_psu=True, psu_index=self.index)\n\n    def _write_sysfs_file(self, sysfs_file, value):\n        rv = 'ERR'\n\n        if (not os.path.isfile(sysfs_file)):\n            return rv\n        try:\n            with open(sysfs_file, 'w') as fd:\n                rv = fd.write(str(value))\n        except Exception as e:\n            rv = 'ERR'\n\n        return rv\n\n    def _read_sysfs_file(self, sysfs_file):\n        rv = 'ERR'\n\n        if (not os.path.isfile(sysfs_file)):\n            return rv\n        try:\n            with open(sysfs_file, 'r') as fd:\n                rv = fd.read()\n        except Exception as e:\n            rv = 'ERR'\n\n        rv = rv.rstrip('\\r\\n')\n        rv = rv.lstrip(\" \")\n        return rv\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n\n        Returns:\n            string: The name of the device\n        \"\"\"\n        return \"PSU{}\".format(self.index)\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Power Supply Unit (PSU)\n\n        Returns:\n            bool: True if PSU is present, False if not\n        \"\"\"\n\n        if smbus_present == 0:  # if called from psuutil outside of pmon\n            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n            psustatus = int(psustatus, 16)\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0xa\n            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n        if self.index == 1:\n            psustatus = psustatus & 1\n            if psustatus == 1:\n                return False\n        if self.index == 2:\n            psustatus = psustatus & 2\n            if psustatus == 2:\n                return False\n\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the part number of the PSU\n\n        Returns:\n            string: Part number of PSU\n        \"\"\"\n        return self.eeprom.modelstr()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the PSU\n\n        Returns:\n            string: Serial number of PSU\n        \"\"\"\n        return self.eeprom.serial_number_str()\n\n    def get_revision(self):\n        \"\"\"\n        Retrieves the HW revision of the PSU\n\n        Returns:\n            string: HW revision of PSU\n        \"\"\"\n        return self.eeprom.part_number_str()\n\n    def get_part_number(self):\n        \"\"\"\n        Retrieves the part number of the PSU\n\n        Returns:\n            string: Part number of PSU\n        \"\"\"\n        return self.eeprom.part_number_str()\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the PSU\n\n        Returns:\n            bool: True if PSU is operating properly, False if not\n        \"\"\"\n\n        if smbus_present == 0:\n            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n            psustatus = int(psustatus, 16)\n            sonic_logger.log_warning(\"PMON psu-smbus - presence = 0 \")\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0xa\n            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n        if self.index == 1:\n            psustatus = psustatus & 4\n            if psustatus == 4:\n                return True\n        if self.index == 2:\n            psustatus = psustatus & 8\n            if psustatus == 8:\n                return True\n\n        return False\n\n    def get_voltage(self):\n        \"\"\"\n        Retrieves current PSU voltage output\n\n        Returns:\n            A float number, the output voltage in volts,\n            e.g. 12.1\n        \"\"\"\n        if smbus_present == 0:\n            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n            psustatus = int(psustatus, 16)\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0xa\n            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n        if self.index == 1:\n            psustatus = psustatus & 4\n            if psustatus == 4:\n                psu_voltage = 12.0\n                return psu_voltage\n        if self.index == 2:\n            psustatus = psustatus & 8\n            if psustatus == 8:\n                psu_voltage = 12.0\n                return psu_voltage\n\n        psu_voltage = 0.0\n        return psu_voltage\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device\n        Returns:\n            integer: The 1-based relative physical position in parent device\n        \"\"\"\n        return self.index\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return True\n\n    def get_powergood_status(self):\n        \"\"\"\n        Retrieves the powergood status of PSU\n        Returns:\n            A boolean, True if PSU has stablized its output voltages and\n            passed all its internal self-tests, False if not.\n        \"\"\"\n\n        if smbus_present == 0:\n            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n            psustatus = int(psustatus, 16)\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0xa\n            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n        if self.index == 1:\n            psustatus = psustatus & 4\n            if psustatus == 4:\n                return True\n        if self.index == 2:\n            psustatus = psustatus & 8\n            if psustatus == 8:\n                return True\n\n        return False\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the PSU status LED\n\n        Returns:\n            A string, one of the predefined STATUS_LED_COLOR_* strings.\n        \"\"\"\n        if self.get_powergood_status():\n            return self.STATUS_LED_COLOR_GREEN\n        else:\n            return self.STATUS_LED_COLOR_OFF\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the PSU status LED\n        Args:\n            color: A string representing the color with which to set the\n                   PSU status LED\n        Returns:\n            bool: True if status LED state is set successfully, False if\n                  not\n        \"\"\"\n        # The firmware running in the PSU controls the LED\n        # and the PSU LED state cannot be changed from CPU.\n        return False\n\n    def get_status_master_led(self):\n        \"\"\"\n        Gets the state of the front panel PSU status LED\n\n        Returns:\n            A string, one of the predefined STATUS_LED_COLOR_* strings.\n        \"\"\"\n        if (not os.path.isfile(\"/sys/class/gpio/psuLedGreen/value\") or\n            not os.path.isfile(\"/sys/class/gpio/psuLedAmber/value\")):\n            return None\n\n        green = self._read_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\")\n        amber = self._read_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\")\n        if green == \"ERR\" or amber == \"ERR\":\n            return None\n        if green == \"1\":\n            return self.STATUS_LED_COLOR_GREEN\n        elif amber == \"1\":\n            return self.STATUS_LED_COLOR_AMBER\n        else:\n            return None\n\n    def set_status_master_led(self, color):\n        \"\"\"\n        Sets the state of the front panel PSU status LED\n\n        Returns:\n            bool: True if status LED state is set successfully, False if\n                  not\n        \"\"\"\n        if (not os.path.isfile(\"/sys/class/gpio/psuLedGreen/value\") or\n            not os.path.isfile(\"/sys/class/gpio/psuLedAmber/value\")):\n            return False\n\n        if color == self.STATUS_LED_COLOR_GREEN:\n            rvg = self._write_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\", 1)\n            if rvg != \"ERR\":\n                rva = self._write_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\", 0)\n        elif color == self.STATUS_LED_COLOR_AMBER:\n            rvg = self._write_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\", 0)\n            if rvg != \"ERR\":\n                rva = self._write_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\", 1)\n        else:\n            return False\n\n        if rvg == \"ERR\" or rva == \"ERR\":\n            return False\n\n        return True\n"}, "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import os\n-import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.sfp_base import SfpBase\n", "add": 1, "remove": 2, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["import sys"], "goodparts": ["import subprocess"]}, {"diff": "\n     from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper\n     from sonic_py_common import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n smbus_present = 1\n \n try:\n", "add": 1, "remove": 5, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["if sys.version_info[0] < 3:", "    import commands as cmd", "else:", "    import subprocess as cmd"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n     # Paths\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"armhf-nokia_ixs7215_52x-r0\"\n     HWSKU = \"Nokia-7215\"\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n             return 'N/A'\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}, {"diff": "\n             return False\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, register = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x5')\n+            cmdstatus, register = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x5'])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"sfp cmdstatus i2c get failed %s\" % register )\n                 return False\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["            cmdstatus, register = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x5')"], "goodparts": ["            cmdstatus, register = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x5'])"]}, {"diff": "\n \n         pos = [1, 2, 4, 8]\n         mask = pos[self.index-SFP_PORT_START]\n-        if tx_disable == True:\n+        if tx_disable is True:\n             setbits = register | mask\n         else:\n             setbits = register & ~mask\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, output = cmd.getstatusoutput('sudo i2cset -y -m 0x0f 0 0x41 0x5 %d' % setbits)\n+            cmdstatus, output = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '-m', '0x0f', '0', '0x41', '0x5', str(setbits)])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"sfp cmdstatus i2c write failed %s\" % output )\n                 return False\n", "add": 2, "remove": 2, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["        if tx_disable == True:", "            cmdstatus, output = cmd.getstatusoutput('sudo i2cset -y -m 0x0f 0 0x41 0x5 %d' % setbits)"], "goodparts": ["        if tx_disable is True:", "            cmdstatus, output = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '-m', '0x0f', '0', '0x41', '0x5', str(setbits)])"]}, {"diff": "\n             return False\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')\n+            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])\n             sfpstatus = int(sfpstatus, 16)\n         else:\n             bus = smbus.SMBu", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')"], "goodparts": ["            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])"]}]}, "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py": {"changes": [{"diff": "\n '''\n listen for the SFP change event and return to chassis.\n '''\n-import sys\n import time\n from sonic_py_common import logger\n+from sonic_py_common.general import getstatusoutput_noshell\n \n smbus_present = 1\n \n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py", "badparts": ["import sys"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n # system level event/error\n EVENT_ON_ALL_SFP = '-1'\n SYSTEM_NOT_READY = 'system_not_ready'\n", "add": 0, "remove": 5, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py", "badparts": ["if sys.version_info[0] < 3:", "    import commands as cmd", "else:", "    import subprocess as cmd"], "goodparts": []}, {"diff": "\n     def _get_transceiver_status(self):\n         if smbus_present == 0:\n             sonic_logger.log_info(\"  PMON - smbus ERROR - DEBUG sfp_event   \")\n-            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')\n+            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])\n             sfpstatus = int(sfpstatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py", "badparts": ["            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')"], "goodparts": ["            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])"]}], "source": "\n''' listen for the SFP change event and return to chassis. ''' import sys import time from sonic_py_common import logger smbus_present=1 try: import smbus except ImportError as e: smbus_present=0 if sys.version_info[0] < 3: import commands as cmd else: import subprocess as cmd EVENT_ON_ALL_SFP='-1' SYSTEM_NOT_READY='system_not_ready' SYSTEM_READY='system_become_ready' SYSTEM_FAIL='system_fail' SFP_PORT_START=49 SFP_PORT_END=52 SYSLOG_IDENTIFIER=\"sfp_event\" sonic_logger=logger.Logger(SYSLOG_IDENTIFIER) class sfp_event: ''' Listen to plugin/plugout cable events ''' def __init__(self): self.handle=None def initialize(self): self.modprs_register=0 time.sleep(5) self.modprs_register=self._get_transceiver_status() sonic_logger.log_info(\"Initial SFP presence=%d\" % self.modprs_register) def deinitialize(self): if self.handle is None: return def _get_transceiver_status(self): if smbus_present==0: sonic_logger.log_info(\" PMON -smbus ERROR -DEBUG sfp_event \") cmdstatus, sfpstatus=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3') sfpstatus=int(sfpstatus, 16) else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0x3 sfpstatus=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) sfpstatus=~sfpstatus sfpstatus=sfpstatus & 0xF return sfpstatus def check_sfp_status(self, port_change, timeout): \"\"\" check_sfp_status called from get_change_event, this will return correct status of all 4 SFP ports if there is a change in any of them \"\"\" start_time=time.time() port=SFP_PORT_START forever=False if timeout==0: forever=True elif timeout > 0: timeout=timeout / float(1000) else: return False,{} end_time=start_time +timeout if(start_time > end_time): return False,{} while(timeout >=0): reg_value=self._get_transceiver_status() if(reg_value !=self.modprs_register): changed_ports=(self.modprs_register ^ reg_value) while(port >=SFP_PORT_START and port <=SFP_PORT_END): mask=(1 << port-SFP_PORT_START) if(changed_ports & mask): if reg_value & mask==0: port_change[port]='0' else: port_change[port]='1' port +=1 self.modprs_register=reg_value return True, port_change if forever: time.sleep(1) else: timeout=end_time -time.time() if timeout >=1: time.sleep(1) else: if timeout > 0: time.sleep(timeout) return True,{} return False,{} ", "sourceWithComments": "'''\nlisten for the SFP change event and return to chassis.\n'''\nimport sys\nimport time\nfrom sonic_py_common import logger\n\nsmbus_present = 1\n\ntry:\n    import smbus\nexcept ImportError as e:\n    smbus_present = 0\n\nif sys.version_info[0] < 3:\n    import commands as cmd\nelse:\n    import subprocess as cmd\n\n# system level event/error\nEVENT_ON_ALL_SFP = '-1'\nSYSTEM_NOT_READY = 'system_not_ready'\nSYSTEM_READY = 'system_become_ready'\nSYSTEM_FAIL = 'system_fail'\n\n# SFP PORT numbers\nSFP_PORT_START = 49\nSFP_PORT_END = 52\n\nSYSLOG_IDENTIFIER = \"sfp_event\"\nsonic_logger = logger.Logger(SYSLOG_IDENTIFIER)\n\n\nclass sfp_event:\n    ''' Listen to plugin/plugout cable events '''\n\n    def __init__(self):\n        self.handle = None\n\n    def initialize(self):\n        self.modprs_register = 0\n        # Get Transceiver status\n        time.sleep(5)\n        self.modprs_register = self._get_transceiver_status()\n        sonic_logger.log_info(\"Initial SFP presence=%d\" % self.modprs_register)\n\n    def deinitialize(self):\n        if self.handle is None:\n            return\n\n    def _get_transceiver_status(self):\n        if smbus_present == 0:\n            sonic_logger.log_info(\"  PMON - smbus ERROR - DEBUG sfp_event   \")\n            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')\n            sfpstatus = int(sfpstatus, 16)\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0x3\n            sfpstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n            sfpstatus = ~sfpstatus\n            sfpstatus = sfpstatus & 0xF\n\n        return sfpstatus\n\n    def check_sfp_status(self, port_change, timeout):\n        \"\"\"\n        check_sfp_status called from get_change_event, this will return correct\n            status of all 4 SFP ports if there is a change in any of them\n        \"\"\"\n        start_time = time.time()\n        port = SFP_PORT_START\n        forever = False\n\n        if timeout == 0:\n            forever = True\n        elif timeout > 0:\n            timeout = timeout / float(1000)  # Convert to secs\n        else:\n            return False, {}\n        end_time = start_time + timeout\n\n        if (start_time > end_time):\n            return False, {}  # Time wrap or possibly incorrect timeout\n\n        while (timeout >= 0):\n            # Check for OIR events and return updated port_change\n            reg_value = self._get_transceiver_status()\n            if (reg_value != self.modprs_register):\n                changed_ports = (self.modprs_register ^ reg_value)\n                while (port >= SFP_PORT_START and port <= SFP_PORT_END):\n                    # Mask off the bit corresponding to our port\n                    mask = (1 << port-SFP_PORT_START)\n                    if (changed_ports & mask):\n                        # ModPrsL is active high\n                        if reg_value & mask == 0:\n                            port_change[port] = '0'\n                        else:\n                            port_change[port] = '1'\n                    port += 1\n\n                # Update reg value\n                self.modprs_register = reg_value\n                return True, port_change\n\n            if forever:\n                time.sleep(1)\n            else:\n                timeout = end_time - time.time()\n                if timeout >= 1:\n                    time.sleep(1)  # We poll at 1 second granularity\n                else:\n                    if timeout > 0:\n                        time.sleep(timeout)\n                    return True, {}\n        return False, {}\n"}}, "msg": "[nokia] Replace os.system and remove subprocess with shell=True (#12100)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\nDependency: [https://github.com/sonic-net/sonic-buildimage/pull/12065](https://github.com/sonic-net/sonic-buildimage/pull/12065)\r\n#### Why I did it\r\n`subprocess.Popen()` and `subprocess.run()` is used with `shell=True`, which is very dangerous for shell injection.\r\n`os` - not secure against maliciously constructed input and dangerous if used to evaluate dynamic content\r\n`getstatusoutput` is dangerous because it contains `shell=True` in the implementation\r\n#### How I did it\r\nReplace `os` by `subprocess`, use with `shell=False`\r\nRemove unused functions"}}, "https://github.com/sonic-net/sonic-buildimage": {"5b0c4ec1e64f0bc604a3fd3e828b46d8974544d8": {"url": "https://api.github.com/repos/sonic-net/sonic-buildimage/commits/5b0c4ec1e64f0bc604a3fd3e828b46d8974544d8", "html_url": "https://github.com/sonic-net/sonic-buildimage/commit/5b0c4ec1e64f0bc604a3fd3e828b46d8974544d8", "sha": "5b0c4ec1e64f0bc604a3fd3e828b46d8974544d8", "keyword": "function injection malicious", "diff": "diff --git a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py\nindex 310d0433d8bc..c1192b3a2eb2 100644\n--- a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py\n@@ -6,8 +6,8 @@\n #\n #############################################################################\n \n-import os\n import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -27,7 +27,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n@@ -97,7 +97,7 @@ def __initialize_watchdog(self):\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py\nindex 53a01c1f1475..c942a2fed976 100644\n--- a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py\n@@ -6,9 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -38,22 +35,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py\nindex b124ca29f0df..b19fab85deb8 100644\n--- a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py\nindex c421761025cf..4205b17efadd 100644\n--- a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py\n@@ -6,10 +6,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -30,7 +29,7 @@ class Sfp(SfpOptoeBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as4630_54pe-r0\"\n     HWSKU = \"Accton-AS4630-54PE\"\n@@ -60,7 +59,7 @@ def get_eeprom_path(self):\n         return self.port_to_eeprom_mapping[self.port_num]\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py\nindex 7a54eee6f478..9f39c903c686 100644\n--- a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py\n@@ -6,7 +6,7 @@\n #\n #############################################################################\n \n-import os\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -26,7 +26,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n SYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n@@ -95,7 +95,7 @@ def __initialize_watchdog(self):\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py\nindex c34da704432a..8137d0f3a790 100644\n--- a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py\n@@ -6,9 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -38,22 +35,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()        \n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py\nindex b124ca29f0df..b19fab85deb8 100644\n--- a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py\nindex 4529c2f0ac88..adab3d294c16 100644\n--- a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py\n@@ -8,10 +8,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -127,7 +126,7 @@ class Sfp(SfpBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-accton_as4630_54te-r0\"\n     HWSKU = \"Accton-AS4630-54TE\"\n@@ -193,7 +192,7 @@ def __write_txt_file(self, file_path, value):\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py\nindex dce9f3c150cd..c4a062f49a96 100644\n--- a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py\n@@ -6,8 +6,8 @@\n #\n #############################################################################\n \n-import os\n import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -28,7 +28,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE= \"/sys/class/leds/as5835_54x_led::diag/brightness\"\n \n SYSLED_MODES = {\n@@ -98,7 +98,7 @@ def __initialize_watchdog(self):\n     \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py\nindex f3c9b3cee754..ef47a154e954 100644\n--- a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py\n@@ -6,10 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n-\n try:\n     from sonic_platform_base.component_base import ComponentBase\n     from .helper import APIHelper\n@@ -44,23 +40,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()\n \n-\n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py\nindex b124ca29f0df..b19fab85deb8 100644\n--- a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py\nindex ec16e80568f4..39813a87728d 100644\n--- a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py\n@@ -6,10 +6,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -31,7 +30,7 @@ class Sfp(SfpOptoeBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as5835_54x-r0\"\n     HWSKU = \"Accton-AS5835-54X\"\n@@ -121,7 +120,7 @@ def __get_cpld_num(self, port_num):\n \n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess(self.HOST_CHK_CMD).returncode == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py\nindex 86ae121c6c82..178f3c56265a 100644\n--- a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py\n@@ -5,12 +5,7 @@\n #\n #############################################################################\n try:\n-    import sys\n-    import re\n-    import os\n     import subprocess\n-    import json\n-    import syslog\n     from sonic_platform_base.chassis_base import ChassisBase\n     from sonic_py_common.logger import Logger\n     from sonic_platform.fan import Fan\n@@ -36,7 +31,7 @@\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n COMPONENT_NAME_LIST = [\"BIOS\"]\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n@@ -71,7 +66,7 @@ def __init__(self):\n         logger.log_info(\"Chassis loaded successfully\")\n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py\nindex 15d8e9e15e9d..5e1e800d52f9 100644\n--- a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py\n@@ -3,10 +3,7 @@\n # provides the components firmware management function\n #############################################################################\n \n-import json\n import os.path\n-import shutil\n-import shlex\n import subprocess\n \n try:\n@@ -29,8 +26,7 @@ def __init__(self, component_name):\n     def __run_command(self, command):\n         # Run bash command and print output to stdout\n         try:\n-            process = subprocess.Popen(\n-                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n+            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n             while True:\n                 output = process.stdout.readline()\n                 if output == '' and process.poll() is not None:\ndiff --git a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py\nindex 6aabc144117c..39c21c0d11c9 100644\n--- a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py\n@@ -3,10 +3,8 @@\n # provides the sfp device status which are available in the platform\n #############################################################################\n try:\n-    import os\n     import time\n     import subprocess\n-    import syslog\n     from ctypes import create_string_buffer\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom\n@@ -173,7 +171,7 @@ class Sfp(SfpBase):\n \n     PLATFORM_ROOT_PATH = '/usr/share/sonic/device'\n     PMON_HWSKU_PATH = '/usr/share/sonic/hwsku'\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-accton_as7116_54x-r0\"\n     HWSKU = \"Accton-AS7116-54X-R0\"\n@@ -233,7 +231,7 @@ def __read_txt_file(self, file_path):\n         return \"\"\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py\nindex ceece0f9db83..a1143b11254d 100644\n--- a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py\n@@ -6,7 +6,7 @@\n #\n #############################################################################\n \n-import os\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -24,7 +24,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n@@ -87,7 +87,7 @@ def __initialize_watchdog(self):\n     \n     \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py\nindex 5300e1e73233..2ba405f9f8ad 100644\n--- a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py\n@@ -6,8 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -43,22 +41,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py\nindex 4cd60ac90611..2c644ecbfb88 100644\n--- a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py\nindex 445b39edc73d..fd6d0f8524f0 100644\n--- a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py\n@@ -6,10 +6,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -125,7 +124,7 @@ class Sfp(SfpBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n         \n     PLATFORM = \"x86_64-accton_as7312_54x-r0\"\n     HWSKU = \"Accton-AS7312-54X\"\n@@ -256,7 +255,7 @@ def __write_txt_file(self, file_path, value):\n         return True\n     \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py\nindex f32f381b7c21..1c97d0e878ae 100644\n--- a/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py\n@@ -6,8 +6,8 @@\n #\n #############################################################################\n \n-import os\n import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -27,7 +27,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE= \"/sys/class/leds/accton_as7326_56x_led::diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n@@ -93,7 +93,7 @@ def __initialize_watchdog(self):\n         self._watchdog = Watchdog()\n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py\nindex 95a54e554a01..16fe60bfb698 100644\n--- a/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py\n@@ -6,10 +6,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -40,7 +39,7 @@ class Sfp(SfpOptoeBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n \n     PLATFORM = \"x86_64-accton_as7326_56x-r0\"\n     HWSKU = \"Accton-AS7326-56X\"\n@@ -144,7 +143,7 @@ def __write_txt_file(self, file_path, value):\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py\nindex 44a759045b6b..164da5fd6122 100644\n--- a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py\n@@ -6,8 +6,8 @@\n #\n #############################################################################\n \n-import os\n import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -26,7 +26,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE = \"/sys/class/leds/as7816_64x_led::diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n@@ -96,7 +96,7 @@ def __initialize_watchdog(self):\n     \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py\nindex 6af2f6008e72..d024e43e1f41 100644\n--- a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py\n@@ -6,8 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -43,22 +41,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py\nindex b124ca29f0df..b19fab85deb8 100644\n--- a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py\nindex 01e568ef3e78..d8ff303b359d 100644\n--- a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py\n@@ -6,10 +6,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -31,7 +30,7 @@ class Sfp(SfpOptoeBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as7816_64x-r0\"\n     HWSKU = \"Accton-AS7816-64X\"\n@@ -119,7 +118,7 @@ def get_eeprom_path(self):\n         return self.port_to_eeprom_mapping[self.port_num]\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py\nindex 7eb9601d8b56..b0a573432b76 100644\n--- a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py\n@@ -6,7 +6,7 @@\n #\n #############################################################################\n \n-import os\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -28,7 +28,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n@@ -96,7 +96,7 @@ def __initialize_watchdog(self):\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py\nindex c34da704432a..8137d0f3a790 100644\n--- a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py\n@@ -6,9 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -38,22 +35,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()        \n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py\nindex 4cd60ac90611..2c644ecbfb88 100644\n--- a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py\nindex 6cefc2a29a47..5d7c03d0055b 100644\n--- a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py\n@@ -6,11 +6,10 @@\n #\n #############################################################################\n \n-import os\n import sys\n import time\n import struct\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -272,7 +271,7 @@\n \n class Sfp(SfpBase):\n     \"\"\"Platform-specific Sfp class\"\"\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n     PLATFORM = \"x86_64-accton_as9726_32d-r0\"\n     HWSKU = \"Accton-AS9726-32D\"\n \n@@ -310,7 +309,7 @@ def __write_txt_file(self, file_path, value):\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py\nindex 22696341523d..2659d16f1c80 100644\n--- a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py\n@@ -8,8 +8,8 @@\n #############################################################################\n \n try:\n-    import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -67,8 +67,8 @@ def get_firmware_version(self):\n         if self.name == \"BIOS\":\n             fw_version = self.__get_bios_version()\n         elif \"CPLD\" in self.name:\n-            cmd = \"i2cget -f -y {0} {1} 0x1\".format(self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1])\n-            status, value = subprocess.getstatusoutput(cmd)\n+            cmd = [\"i2cget\", \"-f\", \"-y\", self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1], \"0x1\"]\n+            status, value = getstatusoutput_noshell(cmd)\n             if not status:\n                 fw_version = value.rstrip()\n \ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py\nindex b074177133aa..e79137785d18 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py\n@@ -26,9 +26,9 @@\n     import logging.config\n     import logging.handlers\n     import time\n-    import subprocess\n     from as4630_54pe.fanutil import FanUtil\n     from as4630_54pe.thermalutil import ThermalUtil\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n@@ -198,9 +198,9 @@ def manage_fans(self):\n         if temp[0] >= 70000: #LM75-48    \n             #critical case*/\n             logging.critical('Alarm-Critical for temperature critical is detected, reset DUT')\n-            cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2);\n-            status, output = subprocess.getstatusoutput(cmd_str)\n+            status, output = getstatusoutput_noshell(cmd_str)\n                 \n         #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_state, fan_policy_state, temp_val)\n         \ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py\nindex d9299b96a3b2..6bbaeaa06d6e 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py\n@@ -28,6 +28,7 @@\n     import logging.handlers\n     import time\n     from sonic_platform import platform\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n@@ -209,10 +210,12 @@ def manage_fans(self):\n             # Critical: Either all the fans are faulty or they are removed, shutdown the system\n             logging.critical('Alarm for all fan faulty/absent is detected')\n             logging.critical(\"Alarm for all fan faulty/absent is detected, reset DUT\")\n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2)\n-            subprocess.getstatusoutput('sync; sync; sync')\n-            subprocess.getstatusoutput(cmd_str)\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell(cmd_str)\n         elif sum(fan_fail_list) != 0:\n             # Set the 100% speed only for first fan failure detection\n             logging.warning('Fan_{} failed, set remaining fan speed to 100%'.format(\n@@ -235,7 +238,7 @@ def manage_fans(self):\n             as4630_54pe_set_fan_speed(new_duty_cycle)\n             if test_temp == 1:\n                 time.sleep(3)\n-                status, output = subprocess.getstatusoutput('pddf_fanutil getspeed')\n+                status, output = getstatusoutput_noshell(['pddf_fanutil', 'getspeed'])\n                 logging.debug('\\n%s\\n', output)\n \n         if temp[0] >= 70000:  # LM77-48\n@@ -252,10 +255,12 @@ def manage_fans(self):\n             if status:\n                 logging.warning('Reboot cause file not updated. {}'.format(output))\n \n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n-            subprocess.getstatusoutput('sync; sync; sync')\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n             time.sleep(3)\n-            subprocess.getstatusoutput(cmd_str)\n+            getstatusoutput_noshell(cmd_str)\n \n         logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n', ori_state, fan_policy_state, temp_val)\n \ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py\nindex 5a505e19f19b..5c00f338ba61 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py\n@@ -2,111 +2,111 @@\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import commands\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"clean\"])\n     if status:\n-        print \"accton_as4630_54pe_util.py clean command failed %d\"%status\n+        print(\"accton_as4630_54pe_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Stop pddf-platform-init.service along with other platform serives failed %d\"%status\n+        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status\n+        print(\"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status)\n         return False\n \n     return True\n     \n def start_platform_svc():\n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"install\"])\n     if status:\n-        print \"accton_as4630_54pe_util.py install  command failed %d\"%status\n+        print(\"accton_as4630_54pe_util.py install  command failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n \n     return True\n \n def start_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Start pddf-platform-init.service failed %d\"%status\n+        print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n+        print(\"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status)\n         return False\n     \n     return True\n \n def stop_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Stop pddf-platform-init.service failed %d\"%status\n+        print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n+        print(\"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status)\n         return False\n \n     return True\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py\nindex d3c2b2c86094..aa5076c2caa4 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py\n@@ -20,7 +20,6 @@\n # ------------------------------------------------------------------\n \n try:\n-    import os\n     import sys\n     import getopt\n     import logging\n@@ -194,9 +193,9 @@ def manage_fans(self):\n             # critical case*/\n             logging.critical(\n                 'Alarm-Critical for temperature critical is detected, reset DUT')\n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2)\n-            return_value = os.system(cmd_str)\n+            return_value = subprocess.call(cmd_str)\n             logging.warning('Fan set: i2cset -y -f 3 0x60 0x4 0xE4, status is %d', return_value)\n \n         #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_state, fan_policy_state, temp_val)\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py b/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py\nindex 31697f7c644e..9dc8d94ef68b 100644\n--- a/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py\n@@ -24,10 +24,8 @@\n # ------------------------------------------------------------------\n \n try:\n-    import time\n     import logging\n-    from collections import namedtuple\n-    import subprocess\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n@@ -65,10 +63,11 @@ def _get_fan_to_device_node(self, fan_num, node_num):\n         return \"fan{0}_{1}\".format(fan_num, self.node_postfix[node_num-1])\n     \n     def _get_fan_i2c_bus_addr(self):\n-        cmd_template = 'i2cget -f -y {} 0x{} 0'\n+        cmd_template = ['i2cget', '-f', '-y', '', '', '0']\n         for bus_no, dev_addr in self.I2CADDR_CANDIDATES:\n-            cmd = cmd_template.format(bus_no, dev_addr)\n-            if subprocess.getstatusoutput(cmd)[0] == 0:\n+            cmd_template[3] = str(bus_no)\n+            cmd_template[4] = '0x' + str(dev_addr)\n+            if getstatusoutput_noshell(cmd_template)[0] == 0:\n                 return bus_no, dev_addr\n         raise IOError('Unable to reach fan CPLD via I2C')\n \ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py\nindex ec3a4c133cdd..da046335cdc6 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py\n@@ -23,10 +23,10 @@\n # ------------------------------------------------------------------\n \n try:\n-    import os\n     import getopt\n     import sys\n     import logging\n+    import subprocess\n     import logging.config\n     import logging.handlers\n     import time  # this is only being used as part of the example\n@@ -233,7 +233,7 @@ def manage_fans(self):\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -242,7 +242,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -251,7 +251,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n@@ -260,7 +260,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is cleared')\n                 alarm_state=0\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py\nindex faa4f7d48b15..7f3add4e4d2b 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py\n@@ -22,10 +22,10 @@\n # ------------------------------------------------------------------\n \n try:\n-    import os\n     import sys\n     import getopt\n     import logging\n+    import subprocess\n     import logging.config\n     import logging.handlers\n     import time\n@@ -218,7 +218,7 @@ def manage_fans(self):\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n         if ori_state == LEVEL_FAN_MID:\n             if new_state == LEVEL_TEMP_HIGH:\n                 if alarm_state == 0:\n@@ -227,7 +227,7 @@ def manage_fans(self):\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n         if ori_state == LEVEL_FAN_MAX:\n             if new_state == LEVEL_TEMP_HIGH:\n                 if alarm_state == 0:\n@@ -236,7 +236,7 @@ def manage_fans(self):\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if alarm_state == 1:\n                 if temp_get < (fan_policy[3][0] - 5000):  # below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n@@ -245,7 +245,7 @@ def manage_fans(self):\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is cleared')\n                 alarm_state = 0\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py\nindex c3e1c50366b7..f4335bd44566 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py\n@@ -33,7 +33,7 @@\n import re\n import time\n import os\n-\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n PROJECT_NAME = 'as7326_56x'\n@@ -100,16 +100,16 @@ def show_help():\n \n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\n@@ -257,8 +257,8 @@ def i2c_order_check():\n     return 0\n \n def eeprom_check():\n-    cmd = \"i2cget -y -f 0 0x56\"\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cget\", \"-y\", \"-f\", \"0\", \"0x56\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def device_install():\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py\nindex 1b5f46ef0e1d..f02202b210b6 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py\n@@ -2,39 +2,39 @@\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as7326-platform-fan.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as7326-platform-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Stop as7326-platform-init.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Disable as7326-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as7326_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n@@ -42,21 +42,21 @@ def stop_platform_svc():\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"install\"])\n     if status:\n         print(\"accton_as7326_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Enable as7326-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as7326-platform-monitor-fan.service failed %d\"%status)\n         return False\n         \n-    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as7326-platform-monitor-psu.service failed %d\"%status)\n         return False\n@@ -64,7 +64,7 @@ def start_platform_svc():\n     return True\n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n@@ -72,7 +72,7 @@ def start_platform_pddf():\n     return True\n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py\nindex 3ed3f7604e73..0f6c82893095 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py\n@@ -1,28 +1,28 @@\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import commands\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = commands.getstatusoutput(\"systemctl stop as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Stop as7712-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl disable as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Disable as7712-platform-init.service failed %d\"%status)\n         return False\n     \n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"clean\"])\n     if status:\n-        print(\"accton_as7712_util.py clean command failed %d\"%status)\n+        print(\"accton_as7712_util.py clean failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n@@ -30,16 +30,16 @@ def stop_platform_svc():\n     return True\n     \n def start_platform_svc():\n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"install\"])\n     if status:\n-        print(\"accton_as7712_util.py install command failed %d\"%status)\n+        print(\"accton_as7712_util.py install failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Enable as7712-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Start as7712-platform-init.service failed %d\"%status)\n         return False\n@@ -47,7 +47,7 @@ def start_platform_svc():\n     return True\n \n def start_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n@@ -55,7 +55,7 @@ def start_platform_pddf():\n     return True\n \n def stop_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py b/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py\nindex 6322aac6bbd7..f312d2261636 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py\n@@ -36,6 +36,7 @@\n import logging\n import re\n import time\n+from sonic_py_common.general import getstatusoutput_noshell\n \n PROJECT_NAME = 'as7716_32x'\n version = '0.0.1'\n@@ -220,16 +221,16 @@ def  show_set_help():\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py\nindex f506b72f83ab..b889dcf712d1 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py\n@@ -23,10 +23,10 @@\n # ------------------------------------------------------------------\n \n try:\n-    import os\n     import getopt\n     import sys\n     import logging\n+    import subprocess\n     import logging.config\n     import logging.handlers\n     import time  # this is only being used as part of the example\n@@ -242,7 +242,7 @@ def manage_fans(self):\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -251,7 +251,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -260,7 +260,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n@@ -269,7 +269,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is cleared')\n                 alarm_state=0\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py\nindex fd283cd6cc2b..2b18ac646ac9 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py\n@@ -24,10 +24,10 @@\n # ------------------------------------------------------------------\n \n try:\n-    import os\n     import sys\n     import getopt\n     import logging\n+    import subprocess\n     import logging.config\n     import logging.handlers\n     import time\n@@ -230,7 +230,7 @@ def manage_fans(self):\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -239,7 +239,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -248,7 +248,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n@@ -257,7 +257,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is cleared')\n                 alarm_state=0\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py\nindex bee413fe0655..949f1230de99 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py\n@@ -32,6 +32,7 @@\n import logging\n import re\n import time\n+from sonic_py_common.general import getstatusoutput_noshell\n \n PROJECT_NAME = 'as7726_32x'\n version = '0.0.1'\n@@ -147,16 +148,16 @@ def show_help():\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py\nindex 9664d21b6c36..e8b42aaa1b93 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py\n@@ -2,44 +2,44 @@\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as7726_32x_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n@@ -47,32 +47,32 @@ def stop_platform_svc():\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py install\"])\n     if status:\n         print(\"accton_as7726_32x_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n@@ -80,7 +80,7 @@ def start_platform_svc():\n     return True\n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n@@ -88,7 +88,7 @@ def start_platform_pddf():\n     return True\n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py b/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py\nindex 1e9314fb824e..5ab3d8f20e98 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py\n@@ -32,7 +32,7 @@\n import re\n import time\n import os\n-\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n PROJECT_NAME = 'as7816_64x'\n@@ -99,18 +99,17 @@ def show_help():\n     print( __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]})\n     sys.exit(0)\n \n-   \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py\nindex 98bf05eca115..166b9c12f0ea 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py\n@@ -1,7 +1,7 @@\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services.\n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n def check_pddf_support():\n@@ -10,22 +10,22 @@ def check_pddf_support():\n \n def stop_platform_svc():\n \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Stop as7816-platform-init.service failed %d\" % status))\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Disable as7816-platform-init.service failed %d\" % status))\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"clean\"])\n     if status:\n         print((\"accton_as7816_util.py clean command failed %d\" % status))\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Stop pddf-platform-init.service along with other platform serives failed %d\" % status))\n         return False\n@@ -34,12 +34,12 @@ def stop_platform_svc():\n \n \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"install\"])\n     if status:\n         print((\"accton_as7816_util.py install command failed %d\" % status))\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Enable as7816-platform-init.service failed %d\" % status))\n         return False\n@@ -48,7 +48,7 @@ def start_platform_svc():\n \n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Start pddf-platform-init.service failed %d\" % status))\n         return False\n@@ -57,7 +57,7 @@ def start_platform_pddf():\n \n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Stop pddf-platform-init.service failed %d\" % status))\n         return False\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py b/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py\nindex 647e26e07d2c..53126109f968 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py\n@@ -32,6 +32,7 @@\n import logging\n import re\n import time\n+from sonic_py_common.general import getstatusoutput_noshell\n \n PROJECT_NAME = 'as9716_32d'\n version = '0.0.1'\n@@ -153,16 +154,16 @@ def show_help():\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py\nindex 95e42b5c8971..1d672015d52f 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py\n@@ -1,39 +1,39 @@\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-fan.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-init.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Disable as9716-32d-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as9716_32d_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n@@ -41,21 +41,21 @@ def stop_platform_svc():\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"install\"])\n     if status:\n         print(\"accton_as9716_32d_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Enable as9716-32d-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as9716-32d-platform-monitor-fan.service failed %d\"%status)\n         return False\n         \n-    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as9716-32d-platform-monitor-psu.service failed %d\"%status)\n         return False\n@@ -64,7 +64,7 @@ def start_platform_svc():\n \n def start_platform_pddf():   \n \n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n@@ -73,7 +73,7 @@ def start_platform_pddf():\n \n def stop_platform_pddf():   \n \n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\n", "message": "", "files": {"/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os import sys try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper from.event import SfpEvent except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=3 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=3 PORT_START=49 PORT_END=54 NUM_COMPONENT=2 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" SYSLED_FNODE=\"/sys/class/leds/diag/brightness\" SYSLED_MODES={ \"0\": \"STATUS_LED_COLOR_OFF\", \"1\": \"STATUS_LED_COLOR_GREEN\", \"2\": \"STATUS_LED_COLOR_AMBER\", \"5\": \"STATUS_LED_COLOR_GREEN_BLINK\" } class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(0, PORT_END): sfp=Sfp(index) self._sfp_list.append(sfp) self._sfpevent=SfpEvent(self._sfp_list) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for fant_index in range(NUM_FAN_TRAY): fandrawer=FanDrawer(fant_index) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._eeprom.get_product_name() def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_change_event(self, timeout=0): if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfpevent.get_sfp_event(timeout) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def initizalize_system_led(self): return True def get_status_led(self): val=self._api_helper.read_txt_file(SYSLED_FNODE) return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\" def set_status_led(self, color): mode=None for key, val in SYSLED_MODES.items(): if val==color: mode=key break if mode is None: return False else: return self._api_helper.write_txt_file(SYSLED_FNODE, mode) ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\nimport sys\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\n    from .event import SfpEvent\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 3\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 3\nPORT_START = 49\nPORT_END = 54\nNUM_COMPONENT = 2\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\nSYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\nSYSLED_MODES = {\n    \"0\" : \"STATUS_LED_COLOR_OFF\",\n    \"1\" : \"STATUS_LED_COLOR_GREEN\",\n    \"2\" : \"STATUS_LED_COLOR_AMBER\",\n    \"5\" : \"STATUS_LED_COLOR_GREEN_BLINK\"\n}\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n        \n        self.config_data = {}\n        \n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n    \n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(0, PORT_END):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self._sfpevent = SfpEvent(self._sfp_list)\n        self.sfp_module_initialized = True\n\n    def __initialize_fan(self):\n       from sonic_platform.fan_drawer import FanDrawer\n       for fant_index in range(NUM_FAN_TRAY):\n           fandrawer = FanDrawer(fant_index)\n           self._fan_drawer_list.append(fandrawer)\n           self._fan_list.extend(fandrawer._fan_list)\n               \n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n    \n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n    \n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n\n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        \n        return self._eeprom.get_product_name()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n\n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_change_event(self, timeout=0):\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return self._sfpevent.get_sfp_event(timeout)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n\n    def initizalize_system_led(self):\n        return True\n\n    def get_status_led(self):\n        val = self._api_helper.read_txt_file(SYSLED_FNODE)\n        return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\"\n\n    def set_status_led(self, color):\n        mode = None\n        for key, val in SYSLED_MODES.items():\n            if val == color:\n                mode = key\n                break\n        if mode is None:\n            return False\n        else:\n            return self._api_helper.write_txt_file(SYSLED_FNODE, mode)\n\n"}, "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 3, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try", "add": 0, "remove": 16, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"3-0060\" } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"BIOS\", \"Basic Input/Output System\") ] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return 'N/A' def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return 'N/A' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is'0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"3-0060\"\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n   \n]\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)\n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n        \n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n        \n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of\n        entPhysicalContainedIn is'0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device\n            or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, resu", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, resu"], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r', errors='replace') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r', errors='replace') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as4630_54pe-r0\"\n     HWSKU = \"Accton-AS4630-54PE\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n         return self.port_to_eeprom_mapping[self.port_num]\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFOR", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}], "source": "\n import os import time import sys from ctypes import create_string_buffer try: from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_I2C_PATH=\"/sys/bus/i2c/devices/3-0060/\" class Sfp(SfpOptoeBase): \"\"\"Platform-specific Sfp class\"\"\" PORT_START=49 PORT_END=54 PLATFORM_ROOT_PATH=\"/usr/share/sonic/device\" PMON_HWSKU_PATH=\"/usr/share/sonic/hwsku\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" PLATFORM=\"x86_64-accton_as4630_54pe-r0\" HWSKU=\"Accton-AS4630-54PE\" _port_to_i2c_mapping={ 49: 18, 50: 19, 51: 20, 52: 21, 53: 22, 54: 23, } def __init__(self, sfp_index=0): SfpOptoeBase.__init__(self) self._api_helper=APIHelper() self.index=sfp_index self.port_num=self.index +1 eeprom_path='/sys/bus/i2c/devices/{0}-0050/eeprom' self.port_to_eeprom_mapping={} for x in range(self.PORT_START, self.PORT_END +1): self.port_to_eeprom_mapping[x]=eeprom_path.format(self._port_to_i2c_mapping[x]) def get_eeprom_path(self): return self.port_to_eeprom_mapping[self.port_num] def __is_host(self): return os.system(self.HOST_CHK_CMD)==0 def __get_path_to_port_config_file(self): platform_path=\"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM]) hwsku_path=\"/\".join([platform_path, self.HWSKU] ) if self.__is_host() else self.PMON_HWSKU_PATH return \"/\".join([hwsku_path, \"port_config.ini\"]) def __read_eeprom_specific_bytes(self, offset, num_bytes): sysfsfile_eeprom=None eeprom_raw=[] for i in range(0, num_bytes): eeprom_raw.append(\"0x00\") sysfs_sfp_i2c_client_eeprom_path=self.port_to_eeprom_mapping[self.port_num] try: sysfsfile_eeprom=open( sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0) sysfsfile_eeprom.seek(offset) raw=sysfsfile_eeprom.read(num_bytes) if sys.version_info[0] >=3: for n in range(0, num_bytes): eeprom_raw[n]=hex(raw[n])[2:].zfill(2) else: for n in range(0, num_bytes): eeprom_raw[n]=hex(ord(raw[n]))[2:].zfill(2) except Exception: pass finally: if sysfsfile_eeprom: sysfsfile_eeprom.close() return eeprom_raw def get_reset_status(self): \"\"\" Retrieves the reset status of SFP Returns: A Boolean, True if reset enabled, False if disabled \"\"\" if self.port_num < 53: return False reset_path=\"{}{}{}\".format(CPLD_I2C_PATH, \"module_reset_\", str(self.port_num)) val=self._api_helper.read_txt_file(reset_path) if val is not None: return int(val, 10)==1 else: return False def get_rx_los(self): \"\"\" Retrieves the RX LOS(lost-of-signal) status of SFP Returns: A Boolean, True if SFP has RX LOS, False if not. Note: RX LOS status is latched until a call to get_rx_los or a reset. \"\"\" rx_los=False if self.port_num < 49: return False if self.port_num < 53: rx_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_rx_los_', self.port_num) rx_los=self._api_helper.read_txt_file(rx_path) if rx_los is None: return False else: rx_los_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: rx_los_data=int(dom_channel_monitor_raw[0], 16) rx_los_list.append(rx_los_data & 0x01 !=0) rx_los_list.append(rx_los_data & 0x02 !=0) rx_los_list.append(rx_los_data & 0x04 !=0) rx_los_list.append(rx_los_data & 0x08 !=0) rx_los=rx_los_list[0] and rx_los_list[1] and rx_los_list[2] and rx_los_list[3] return rx_los def get_tx_fault(self): \"\"\" Retrieves the TX fault status of SFP Returns: A Boolean, True if SFP has TX fault, False if not Note: TX fault status is lached until a call to get_tx_fault or a reset. \"\"\" tx_fault=False if self.port_num < 49: return False if self.port_num < 53: tx_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_fault_', self.port_num) tx_fault=self._api_helper.read_txt_file(tx_path) if tx_fault is None: return False else: tx_fault_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: tx_fault_data=int(dom_channel_monitor_raw[0], 16) tx_fault_list.append(tx_fault_data & 0x01 !=0) tx_fault_list.append(tx_fault_data & 0x02 !=0) tx_fault_list.append(tx_fault_data & 0x04 !=0) tx_fault_list.append(tx_fault_data & 0x08 !=0) tx_fault=tx_fault_list[0] and tx_fault_list[1] and tx_fault_list[2] and tx_fault_list[3] return tx_fault def get_tx_disable(self): \"\"\" Retrieves the tx_disable status of this SFP Returns: A Boolean, True if tx_disable is enabled, False if disabled \"\"\" if self.port_num < 49: return False if self.port_num < 53: tx_disable=False tx_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_disable_', self.port_num) tx_disable=self._api_helper.read_txt_file(tx_path) if tx_disable is not None: return tx_disable else: return False else: tx_disable_list=[] sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) tx_disable_list.append( 'On'==dom_control_data['data']['TX1Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX2Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX3Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX4Disable']['value']) return tx_disable_list def get_tx_disable_channel(self): \"\"\" Retrieves the TX disabled channels in this SFP Returns: A hex of 4 bits(bit 0 to bit 3 as channel 0 to channel 3) to represent TX channels which have been disabled in this SFP. As an example, a returned value of 0x5 indicates that channel 0 and channel 2 have been disabled. \"\"\" if self.port_num < 53: return False else: tx_disable_list=self.get_tx_disable() if tx_disable_list is None: return 0 tx_disabled=0 for i in range(len(tx_disable_list)): if tx_disable_list[i]: tx_disabled |=1 << i return tx_disabled def get_lpmode(self): \"\"\" Retrieves the lpmode(low power mode) status of this SFP Returns: A Boolean, True if lpmode is enabled, False if disabled \"\"\" if self.port_num < 53: return False else: power_set=self.get_power_set() power_override=self.get_power_override() return power_set and power_override def reset(self): \"\"\" Reset SFP and return all user module settings to their default srate. Returns: A boolean, True if successful, False if not \"\"\" if self.port_num < 53: return False reset_path=\"{}{}{}\".format(CPLD_I2C_PATH, 'module_reset_', self.port_num) ret=self._api_helper.write_txt_file(reset_path, 1) if ret is not True: return ret time.sleep(0.01) ret=self._api_helper.write_txt_file(reset_path, 0) time.sleep(0.2) return ret def tx_disable(self, tx_disable): \"\"\" Disable SFP TX for all channels Args: tx_disable: A Boolean, True to enable tx_disable mode, False to disable tx_disable mode. Returns: A boolean, True if tx_disable is set successfully, False if not \"\"\" if self.port_num < 49: return False if self.port_num < 53: tx_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_disable_', self.port_num) ret=self._api_helper.write_txt_file(tx_path, 1 if tx_disable else 0) if ret is not None: time.sleep(0.01) return ret else: return False else: if not self.get_presence(): return False sysfsfile_eeprom=None try: tx_disable_ctl=0xf if tx_disable else 0x0 buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=tx_disable_ctl else: buffer[0]=chr(tx_disable_ctl) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ',str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def tx_disable_channel(self, channel, disable): \"\"\" Sets the tx_disable for specified SFP channels Args: channel: A hex of 4 bits(bit 0 to bit 3) which represent channel 0 to 3, e.g. 0x5 for channel 0 and channel 2. disable: A boolean, True to disable TX channels specified in channel, False to enable Returns: A boolean, True if successful, False if not \"\"\" if self.port_num < 53: return False else: if not self.get_presence(): return False sysfsfile_eeprom=None try: channel_state=self.get_tx_disable_channel() for i in range(4): channel_mask=(1 << i) if not(channel & channel_mask): continue if disable: channel_state |=channel_mask else: channel_state &=~channel_mask buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=channel_state else: buffer[0]=chr(channel_state) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ', str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def set_lpmode(self, lpmode): \"\"\" Sets the lpmode(low power mode) of SFP Args: lpmode: A Boolean, True to enable lpmode, False to disable it Note : lpmode can be overridden by set_power_override Returns: A boolean, True if lpmode is set successfully, False if not \"\"\" if self.port_num < 53: return False else: if lpmode is True: self.set_power_override(True, True) else: self.set_power_override(False, False) return True def set_power_override(self, power_override, power_set): \"\"\" Sets SFP power level using power_override and power_set Args: power_override: A Boolean, True to override set_lpmode and use power_set to control SFP power, False to disable SFP power control through power_override/power_set and use set_lpmode to control SFP power. power_set: Only valid when power_override is True. A Boolean, True to set SFP to low power mode, False to set SFP to high power mode. Returns: A boolean, True if power-override and power_set are set successfully, False if not \"\"\" if self.port_num < 53: return False else: if not self.get_presence(): return False try: power_override_bit=(1 << 0) if power_override else 0 power_set_bit =(1 << 1) if power_set else(1 << 3) buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=(power_override_bit | power_set_bit) else: buffer[0]=chr(power_override_bit | power_set_bit) with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd: fd.seek(QSFP_POWEROVERRIDE_OFFSET) fd.write(buffer[0]) time.sleep(0.01) except IOError as e: print('Error: unable to open file: ', str(e)) return False return True def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" name=None sfputil_helper=SfpUtilHelper() sfputil_helper.read_porttab_mappings( self.__get_path_to_port_config_file()) name=sfputil_helper.logical[self.index] or \"Unknown\" return name def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" if self.port_num < 49: return False present_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_present_', self.port_num) val=self._api_helper.read_txt_file(present_path) if val is not None: return int(val, 10)==1 else: return False def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return self.get_presence() def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return self.port_num def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return True ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Sfp contains an implementation of SONiC Platform Base API and\n# provides the sfp device status which are available in the platform\n#\n#############################################################################\n\nimport os\nimport time\nimport sys\n\nfrom ctypes import create_string_buffer\n\ntry:\n    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_I2C_PATH = \"/sys/bus/i2c/devices/3-0060/\"\n\nclass Sfp(SfpOptoeBase):\n    \"\"\"Platform-specific Sfp class\"\"\"\n\n    # Port number\n    PORT_START = 49\n    PORT_END = 54\n\n    # Path to sysfs\n    PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n    PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n        \n    PLATFORM = \"x86_64-accton_as4630_54pe-r0\"\n    HWSKU = \"Accton-AS4630-54PE\"\n\n    _port_to_i2c_mapping = {\n           49: 18,\n           50: 19,\n           51: 20,\n           52: 21,\n           53: 22,\n           54: 23,\n    }\n\n    def __init__(self, sfp_index=0):\n        SfpOptoeBase.__init__(self)\n        self._api_helper=APIHelper()\n        # Init index\n        self.index = sfp_index\n        self.port_num = self.index + 1\n        # Init eeprom path\n        eeprom_path = '/sys/bus/i2c/devices/{0}-0050/eeprom'\n        self.port_to_eeprom_mapping = {}\n        for x in range(self.PORT_START, self.PORT_END + 1):\n            self.port_to_eeprom_mapping[x] = eeprom_path.format(self._port_to_i2c_mapping[x])\n\n    def get_eeprom_path(self):\n        return self.port_to_eeprom_mapping[self.port_num]\n\n    def __is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def __get_path_to_port_config_file(self):\n        platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n        hwsku_path = \"/\".join([platform_path, self.HWSKU]\n                              ) if self.__is_host() else self.PMON_HWSKU_PATH\n        return \"/\".join([hwsku_path, \"port_config.ini\"])\n\n    def __read_eeprom_specific_bytes(self, offset, num_bytes):\n        sysfsfile_eeprom = None\n        eeprom_raw = []\n        for i in range(0, num_bytes):\n            eeprom_raw.append(\"0x00\")\n\n        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]\n        try:\n            sysfsfile_eeprom = open(\n                sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0)\n            sysfsfile_eeprom.seek(offset)\n            raw = sysfsfile_eeprom.read(num_bytes)\n            if sys.version_info[0] >= 3:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(raw[n])[2:].zfill(2)\n            else:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(ord(raw[n]))[2:].zfill(2)\n        except Exception:\n            pass\n        finally:\n            if sysfsfile_eeprom:\n                sysfsfile_eeprom.close()\n\n        return eeprom_raw\n\n    def get_reset_status(self):\n        \"\"\"\n        Retrieves the reset status of SFP\n        Returns:\n            A Boolean, True if reset enabled, False if disabled\n        \"\"\"\n        if self.port_num < 53: #Copper port and sfp ports are suported.\n            return False\n\n        reset_path=\"{}{}{}\".format(CPLD_I2C_PATH , \"module_reset_\" , str(self.port_num))\n        val = self._api_helper.read_txt_file(reset_path)\n        \n        if val is not None:\n            return int(val, 10) == 1\n        else:        \n            return False\n\n    def get_rx_los(self):\n        \"\"\"\n        Retrieves the RX LOS (lost-of-signal) status of SFP\n        Returns:\n            A Boolean, True if SFP has RX LOS, False if not.\n            Note : RX LOS status is latched until a call to get_rx_los or a reset.\n        \"\"\"\n        rx_los = False\n        \n        if self.port_num < 49: #Copper port, no sysfs\n            return False\n            \n        if self.port_num < 53:\n            rx_path = \"{}{}{}\".format(CPLD_I2C_PATH, '/module_rx_los_', self.port_num)\n            rx_los=self._api_helper.read_txt_file(rx_path)\n            if rx_los is None:\n                return False\n        else:\n            rx_los_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None\n            if dom_channel_monitor_raw is not None:\n                rx_los_data = int(dom_channel_monitor_raw[0], 16)\n                rx_los_list.append(rx_los_data & 0x01 != 0)\n                rx_los_list.append(rx_los_data & 0x02 != 0)\n                rx_los_list.append(rx_los_data & 0x04 != 0)\n                rx_los_list.append(rx_los_data & 0x08 != 0)\n                rx_los = rx_los_list[0] and rx_los_list[1] and rx_los_list[2] and rx_los_list[3]\n        return rx_los\n\n    def get_tx_fault(self):\n        \"\"\"\n        Retrieves the TX fault status of SFP\n        Returns:\n            A Boolean, True if SFP has TX fault, False if not\n            Note : TX fault status is lached until a call to get_tx_fault or a reset.\n        \"\"\"\n        tx_fault = False\n        if self.port_num < 49: #Copper port, no sysfs\n            return False\n        \n        if self.port_num < 53:\n            tx_path = \"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_fault_', self.port_num)\n            tx_fault=self._api_helper.read_txt_file(tx_path)\n            if tx_fault is None:\n                return False\n        else:\n            tx_fault_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None\n            if dom_channel_monitor_raw is not None:\n                tx_fault_data = int(dom_channel_monitor_raw[0], 16)\n                tx_fault_list.append(tx_fault_data & 0x01 != 0)\n                tx_fault_list.append(tx_fault_data & 0x02 != 0)\n                tx_fault_list.append(tx_fault_data & 0x04 != 0)\n                tx_fault_list.append(tx_fault_data & 0x08 != 0)\n                tx_fault = tx_fault_list[0] and tx_fault_list[1] and tx_fault_list[2] and tx_fault_list[3]\n\n        return tx_fault\n\n    def get_tx_disable(self):\n        \"\"\"\n        Retrieves the tx_disable status of this SFP\n        Returns:\n            A Boolean, True if tx_disable is enabled, False if disabled\n        \"\"\"\n        if self.port_num < 49: #Copper port, no sysfs\n            return False\n        \n        if self.port_num < 53: \n            tx_disable = False            \n                \n            tx_path = \"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_disable_', self.port_num)\n            tx_disable=self._api_helper.read_txt_file(tx_path)\n            \n            if tx_disable is not None:\n                return tx_disable \n            else:\n                return False\n                   \n        else:\n            tx_disable_list = []\n    \n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n    \n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX1Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX2Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX3Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX4Disable']['value'])\n    \n            return tx_disable_list\n\n    def get_tx_disable_channel(self):\n        \"\"\"\n        Retrieves the TX disabled channels in this SFP\n        Returns:\n            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent\n            TX channels which have been disabled in this SFP.\n            As an example, a returned value of 0x5 indicates that channel 0\n            and channel 2 have been disabled.\n        \"\"\"\n        if self.port_num < 53: \n            # SFP doesn't support this feature\n            return False\n        else:\n            tx_disable_list = self.get_tx_disable()\n            if tx_disable_list is None:\n                return 0\n            tx_disabled = 0\n            for i in range(len(tx_disable_list)):\n                if tx_disable_list[i]:\n                    tx_disabled |= 1 << i\n            return tx_disabled\n\n    def get_lpmode(self):\n        \"\"\"\n        Retrieves the lpmode (low power mode) status of this SFP\n        Returns:\n            A Boolean, True if lpmode is enabled, False if disabled\n        \"\"\"\n        if self.port_num < 53: \n            # SFP doesn't support this feature\n            return False\n        else:\n            power_set=self.get_power_set()\n            power_override = self.get_power_override()\n            return power_set and power_override\n      \n    \n    def reset(self):\n        \"\"\"\n        Reset SFP and return all user module settings to their default srate.\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        # Check for invalid port_num\n        if self.port_num < 53: #Copper port and  sfp ports are not supported.\n            return False\n\n        reset_path = \"{}{}{}\".format(CPLD_I2C_PATH, 'module_reset_', self.port_num)\n        ret = self._api_helper.write_txt_file(reset_path, 1)\n        if ret is not True:\n            return ret\n        \n        time.sleep(0.01)\n        ret = self._api_helper.write_txt_file(reset_path, 0)\n        time.sleep(0.2)\n        \n        return ret\n        \n    def tx_disable(self, tx_disable):\n        \"\"\"\n        Disable SFP TX for all channels\n        Args:\n            tx_disable : A Boolean, True to enable tx_disable mode, False to disable\n                         tx_disable mode.\n        Returns:\n            A boolean, True if tx_disable is set successfully, False if not\n        \"\"\"\n        if self.port_num < 49: #Copper port, no sysfs\n            return False\n        \n        if self.port_num < 53:\n            tx_path = \"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_disable_', self.port_num)      \n            ret = self._api_helper.write_txt_file(tx_path,  1 if tx_disable else 0)\n            if ret is not None:\n                time.sleep(0.01)\n                return ret\n            else:\n                return False\n        \n        else:\n            if not self.get_presence():\n                return False\n            sysfsfile_eeprom = None\n            try:\n                tx_disable_ctl = 0xf if tx_disable else 0x0\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = tx_disable_ctl\n                else:\n                    buffer[0] = chr(tx_disable_ctl)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print ('Error: unable to open file: ',str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n        return True\n\n    def tx_disable_channel(self, channel, disable):\n        \"\"\"\n        Sets the tx_disable for specified SFP channels\n        Args:\n            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,\n                      e.g. 0x5 for channel 0 and channel 2.\n            disable : A boolean, True to disable TX channels specified in channel,\n                      False to enable\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        \n        if self.port_num < 53:\n            return False # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n\n            sysfsfile_eeprom = None\n            try:\n                channel_state = self.get_tx_disable_channel()\n\n                for i in range(4):\n                    channel_mask = (1 << i)\n                    if not (channel & channel_mask):\n                        continue\n\n                    if disable:\n                        channel_state |= channel_mask\n                    else:\n                        channel_state &= ~channel_mask\n\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = channel_state\n                else:\n                    buffer[0] = chr(channel_state)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print ('Error: unable to open file: ', str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n            return True\n\n    def set_lpmode(self, lpmode):\n        \"\"\"\n        Sets the lpmode (low power mode) of SFP\n        Args:\n            lpmode: A Boolean, True to enable lpmode, False to disable it\n            Note  : lpmode can be overridden by set_power_override\n        Returns:\n            A boolean, True if lpmode is set successfully, False if not\n        \"\"\"\n        if self.port_num < 53:\n            return False # SFP doesn't support this feature\n        else:\n            if lpmode is True:\n                self.set_power_override(True, True)\n            else:\n                self.set_power_override(False, False)\n    \n            return True\n       \n    def set_power_override(self, power_override, power_set):\n        \"\"\"\n        Sets SFP power level using power_override and power_set\n        Args:\n            power_override :\n                    A Boolean, True to override set_lpmode and use power_set\n                    to control SFP power, False to disable SFP power control\n                    through power_override/power_set and use set_lpmode\n                    to control SFP power.\n            power_set :\n                    Only valid when power_override is True.\n                    A Boolean, True to set SFP to low power mode, False to set\n                    SFP to high power mode.\n        Returns:\n            A boolean, True if power-override and power_set are set successfully,\n            False if not\n        \"\"\"\n        if self.port_num < 53:\n            return False # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n            try:\n                power_override_bit = (1 << 0) if power_override else 0\n                power_set_bit      = (1 << 1) if power_set else (1 << 3)\n    \n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = (power_override_bit | power_set_bit)\n                else:\n                    buffer[0] = chr(power_override_bit | power_set_bit)\n                # Write to eeprom\n                with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd:\n                    fd.seek(QSFP_POWEROVERRIDE_OFFSET)\n                    fd.write(buffer[0])\n                    time.sleep(0.01)\n            except IOError as e:\n                print ('Error: unable to open file: ', str(e))\n                return False\n            return True\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        name = None\n        sfputil_helper = SfpUtilHelper()\n        sfputil_helper.read_porttab_mappings(\n            self.__get_path_to_port_config_file())\n        name = sfputil_helper.logical[self.index] or \"Unknown\"\n        return name\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        if self.port_num < 49: #Copper port, no sysfs\n            return False\n            \n        present_path = \"{}{}{}\".format(CPLD_I2C_PATH, '/module_present_', self.port_num)\n        val=self._api_helper.read_txt_file(present_path)\n        if val is not None:\n            return int(val, 10)==1\n        else:\n            return False\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return self.get_presence()\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return self.port_num\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return True\n"}, "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n SYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         ", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=3 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=3 NUM_QSFP=6 PORT_START=49 PORT_END=54 NUM_COMPONENT=2 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"docker > /dev/null 2>&1\" SYSLED_FNODE=\"/sys/class/leds/diag/brightness\" SYSLED_MODES={ \"0\": \"STATUS_LED_COLOR_OFF\", \"1\": \"STATUS_LED_COLOR_GREEN\", \"2\": \"STATUS_LED_COLOR_AMBER\", \"5\": \"STATUS_LED_COLOR_GREEN_BLINK\" } class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(0, PORT_END): sfp=Sfp(index) self._sfp_list.append(sfp) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for fant_index in range(NUM_FAN_TRAY): fandrawer=FanDrawer(fant_index) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._api_helper.hwsku def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_serial_number(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def initizalize_system_led(self): return True def get_status_led(self): val=self._api_helper.read_txt_file(SYSLED_FNODE) return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\" def set_status_led(self, color): mode=None for key, val in SYSLED_MODES.items(): if val==color: mode=key break if mode is None: return False else: return self._api_helper.write_txt_file(SYSLED_FNODE, mode) ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 3\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 3\nNUM_QSFP = 6\nPORT_START = 49\nPORT_END = 54\nNUM_COMPONENT = 2\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nSYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\nSYSLED_MODES = {\n    \"0\" : \"STATUS_LED_COLOR_OFF\",\n    \"1\" : \"STATUS_LED_COLOR_GREEN\",\n    \"2\" : \"STATUS_LED_COLOR_AMBER\",\n    \"5\" : \"STATUS_LED_COLOR_GREEN_BLINK\"\n}\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n\n        self.config_data = {}\n\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n\n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(0, PORT_END):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self.sfp_module_initialized = True\n\n    def __initialize_fan(self):\n        from sonic_platform.fan_drawer import FanDrawer\n        for fant_index in range(NUM_FAN_TRAY):\n            fandrawer = FanDrawer(fant_index)\n            self._fan_drawer_list.append(fandrawer)\n            self._fan_list.extend(fandrawer._fan_list)\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n\n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n\n        return self._api_helper.hwsku\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_serial_number(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n\n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n\n    def initizalize_system_led(self):\n        return True\n\n    def get_status_led(self):\n        val = self._api_helper.read_txt_file(SYSLED_FNODE)\n        return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\"\n\n    def set_status_led(self, color):\n        mode = None\n        for key, val in SYSLED_MODES.items():\n            if val == color:\n                mode = key\n                break\n        if mode is None:\n            return False\n        else:\n            return self._api_helper.write_txt_file(SYSLED_FNODE, mode)\n"}, "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 3, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()        \n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n        ", "add": 0, "remove": 16, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"3-0060\" } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"BIOS\", \"Basic Input/Output System\") ] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError ", "sourceWithComments": "#############################################################################\n# Accton\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"3-0060\"\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n\n]\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()        \n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)               \n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n\n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()           \n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n"}, "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, ", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, "], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r', errors='replace') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r', errors='replace') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-accton_as4630_54te-r0\"\n     HWSKU = \"Accton-AS4630-54TE\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLA", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}]}, "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE= \"/sys/class/leds/as5835_54x_led::diag/brightness\"\n \n SYSLED_MODES = {\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n     \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n     ", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os import sys try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper from.event import SfpEvent except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=5 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=4 NUM_QSFP=54 PORT_START=1 PORT_END=54 NUM_COMPONENT=4 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" SYSLED_FNODE=\"/sys/class/leds/as5835_54x_led::diag/brightness\" SYSLED_MODES={ \"0\": \"STATUS_LED_COLOR_OFF\", \"1\": \"STATUS_LED_COLOR_GREEN\", \"3\": \"STATUS_LED_COLOR_AMBER\" } class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(0, PORT_END): sfp=Sfp(index) self._sfp_list.append(sfp) self._sfpevent=SfpEvent(self._sfp_list) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for fant_index in range(NUM_FAN_TRAY): fandrawer=FanDrawer(fant_index) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._eeprom.get_product_name() def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_change_event(self, timeout=0): if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfpevent.get_sfp_event(timeout) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def initizalize_system_led(self): return True def get_status_led(self): val=self._api_helper.read_txt_file(SYSLED_FNODE) return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\" def set_status_led(self, color): mode=None for key, val in SYSLED_MODES.items(): if val==color: mode=key break if mode is None: return False else: return self._api_helper.write_txt_file(SYSLED_FNODE, mode) ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\nimport sys\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\n    from .event import SfpEvent\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 5\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 4\nNUM_QSFP = 54\nPORT_START = 1\nPORT_END = 54\nNUM_COMPONENT = 4\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\nSYSLED_FNODE= \"/sys/class/leds/as5835_54x_led::diag/brightness\"\n\nSYSLED_MODES = {\n    \"0\" : \"STATUS_LED_COLOR_OFF\",\n    \"1\" : \"STATUS_LED_COLOR_GREEN\",\n    \"3\" : \"STATUS_LED_COLOR_AMBER\"\n}\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n        \n        self.config_data = {}\n        \n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n    \n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(0, PORT_END):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self._sfpevent = SfpEvent(self._sfp_list)\n        self.sfp_module_initialized = True\n        \n    def __initialize_fan(self):\n       from sonic_platform.fan_drawer import FanDrawer\n       for fant_index in range(NUM_FAN_TRAY):\n           fandrawer = FanDrawer(fant_index)\n           self._fan_drawer_list.append(fandrawer)\n           self._fan_list.extend(fandrawer._fan_list)\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n    \n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n    \n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n    \n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return self._eeprom.get_product_name()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n    \n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n    \n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n        \n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n\n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_change_event(self, timeout=0):\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n        return self._sfpevent.get_sfp_event(timeout)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n        \n    def initizalize_system_led(self):\n        return True\n\n    def get_status_led(self):\n        val = self._api_helper.read_txt_file(SYSLED_FNODE)\n        return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\"\n\n    def set_status_led(self, color):\n        mode = None\n        for key, val in SYSLED_MODES.items():\n            if val == color:\n                mode = key\n                break\n        if mode is None:\n            return False\n        else:\n            return self._api_helper.write_txt_file(SYSLED_FNODE, mode)\n            \n"}, "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n-\n try:\n     from sonic_platform_base.component_base import ComponentBase\n     from .helper import APIHelper\n", "add": 0, "remove": 4, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()\n \n-\n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n    ", "add": 0, "remove": 17, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"3-0060\", \"CPLD2\": \"3-0061\", \"CPLD3\": \"3-0062\", } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"CPLD2\", \"CPLD 2\"), (\"CPLD3\", \"CPLD 3\"), (\"BIOS\", \"Basic Input/Output System\") ] COMPONENT_DES_LIST=[\"CPLD\",\"Basic Input/Output System\"] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: print('Get exception when read bios') return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return 'N/A' def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return 'N/A' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is'0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"3-0060\",\n    \"CPLD2\": \"3-0061\",\n    \"CPLD3\": \"3-0062\",\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"CPLD2\", \"CPLD 2\"),\n   (\"CPLD3\", \"CPLD 3\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n   \n]\nCOMPONENT_DES_LIST = [\"CPLD\",\"Basic Input/Output System\"]\n\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            print('Get exception when read bios')\n        return None\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)\n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n        \n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n        #return \"testhwsku\"\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of\n        entPhysicalContainedIn is'0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device\n            or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return stat", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return stat"], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r', errors='replace') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r', errors='replace') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as5835_54x-r0\"\n     HWSKU = \"Accton-AS5835-54X\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n \n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess(self.HOST_CHK_CMD).returncode == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess(self.HOST_CHK_CMD).returncode == 0"]}], "source": "\n import os import time import sys from ctypes import create_string_buffer try: from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_I2C_PATH=\"/sys/bus/i2c/devices/\" class Sfp(SfpOptoeBase): \"\"\"Platform-specific Sfp class\"\"\" PORT_START=1 PORT_END=54 QSFP_PORT_START=49 PLATFORM_ROOT_PATH=\"/usr/share/sonic/device\" PMON_HWSKU_PATH=\"/usr/share/sonic/hwsku\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" PLATFORM=\"x86_64-accton_as5835_54x-r0\" HWSKU=\"Accton-AS5835-54X\" _cpld_mapping={ 0: \"3-0060\", 1: \"3-0061\", 2: \"3-0062\", } _port_to_i2c_mapping={ 1: 42, 2: 43, 3: 44, 4: 45, 5: 46, 6: 47, 7: 48, 8: 49, 9: 50, 10: 51, 11: 52, 12: 53, 13: 54, 14: 55, 15: 56, 16: 57, 17: 58, 18: 59, 19: 60, 20: 61, 21: 62, 22: 63, 23: 64, 24: 65, 25: 66, 26: 67, 27: 68, 28: 69, 29: 70, 30: 71, 31: 72, 32: 73, 33: 74, 34: 75, 35: 76, 36: 77, 37: 78, 38: 79, 39: 80, 40: 81, 41: 82, 42: 83, 43: 84, 44: 85, 45: 86, 46: 87, 47: 88, 48: 89, 49: 28, 50: 29, 51: 26, 52: 30, 53: 31, 54: 27, } def __init__(self, sfp_index=0): SfpOptoeBase.__init__(self) self._api_helper=APIHelper() self.index=sfp_index self.port_num=self.index +1 eeprom_path='/sys/bus/i2c/devices/{0}-0050/eeprom' self.port_to_eeprom_mapping={} for x in range(self.PORT_START, self.PORT_END +1): self.port_to_eeprom_mapping[x]=eeprom_path.format(self._port_to_i2c_mapping[x]) def get_eeprom_path(self): return self.port_to_eeprom_mapping[self.port_num] def __get_cpld_num(self, port_num): return 1 if(port_num < 39) else 2 def __is_host(self): return os.system(self.HOST_CHK_CMD)==0 def __get_path_to_port_config_file(self): platform_path=\"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM]) hwsku_path=\"/\".join([platform_path, self.HWSKU] ) if self.__is_host() else self.PMON_HWSKU_PATH return \"/\".join([hwsku_path, \"port_config.ini\"]) def __read_eeprom_specific_bytes(self, offset, num_bytes): sysfsfile_eeprom=None eeprom_raw=[] for i in range(0, num_bytes): eeprom_raw.append(\"0x00\") sysfs_sfp_i2c_client_eeprom_path=self.port_to_eeprom_mapping[self.port_num] try: sysfsfile_eeprom=open( sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0) sysfsfile_eeprom.seek(offset) raw=sysfsfile_eeprom.read(num_bytes) if sys.version_info[0] >=3: for n in range(0, num_bytes): eeprom_raw[n]=hex(raw[n])[2:].zfill(2) else: for n in range(0, num_bytes): eeprom_raw[n]=hex(ord(raw[n]))[2:].zfill(2) except Exception: pass finally: if sysfsfile_eeprom: sysfsfile_eeprom.close() return eeprom_raw def get_reset_status(self): \"\"\" Retrieves the reset status of SFP Returns: A Boolean, True if reset enabled, False if disabled \"\"\" if self.port_num <49: return False cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] reset_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_reset_', self.port_num) val=self._api_helper.read_txt_file(reset_path) if val is not None: return int(val, 10)==1 else: return False def get_rx_los(self): \"\"\" Retrieves the RX LOS(lost-of-signal) status of SFP Returns: A Boolean, True if SFP has RX LOS, False if not. Note: RX LOS status is latched until a call to get_rx_los or a reset. \"\"\" rx_los=False if self.port_num < 49: cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] rx_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_rx_los_', self.port_num) rx_los=self._api_helper.read_txt_file(rx_path) if int(rx_los, 10)==1: return[True] else: return[False] else: rx_los_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: rx_los_data=int(dom_channel_monitor_raw[0], 16) rx_los_list.append(rx_los_data & 0x01 !=0) rx_los_list.append(rx_los_data & 0x02 !=0) rx_los_list.append(rx_los_data & 0x04 !=0) rx_los_list.append(rx_los_data & 0x08 !=0) return rx_los_list else: return[False]*4 def get_tx_fault(self): \"\"\" Retrieves the TX fault status of SFP Returns: A list of boolean values, representing the TX fault status of each available channel, value is True if SFP channel has TX fault, False if not. E.g., for a tranceiver with four channels:[False, False, True, False] Note: TX fault status is lached until a call to get_tx_fault or a reset. \"\"\" tx_fault=False if self.port_num < 49: cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] tx_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_fault_', self.port_num) tx_fault=self._api_helper.read_txt_file(tx_path) if int(tx_fault, 10)==1: return[True] else: return[False] else: tx_fault_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: tx_fault_data=int(dom_channel_monitor_raw[0], 16) tx_fault_list.append(tx_fault_data & 0x01 !=0) tx_fault_list.append(tx_fault_data & 0x02 !=0) tx_fault_list.append(tx_fault_data & 0x04 !=0) tx_fault_list.append(tx_fault_data & 0x08 !=0) return tx_fault_list else: return[False]*4 def get_tx_disable(self): \"\"\" Retrieves the tx_disable status of this SFP Returns: A list of boolean values, representing the TX disable status of each available channel, value is True if SFP channel is TX disabled, False if not. E.g., for a tranceiver with four channels:[False, False, True, False] \"\"\" if self.port_num < 49: tx_disable=False cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] tx_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_disable_', self.port_num) tx_disable=self._api_helper.read_txt_file(tx_path) if int(tx_disable, 10)==0: return[False] else: return[True] else: tx_disable_list=[] sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) tx_disable_list.append( 'On'==dom_control_data['data']['TX1Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX2Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX3Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX4Disable']['value']) return tx_disable_list else: return[False]*4 def get_tx_disable_channel(self): \"\"\" Retrieves the TX disabled channels in this SFP Returns: A hex of 4 bits(bit 0 to bit 3 as channel 0 to channel 3) to represent TX channels which have been disabled in this SFP. As an example, a returned value of 0x5 indicates that channel 0 and channel 2 have been disabled. \"\"\" tx_disable_list=self.get_tx_disable() if tx_disable_list is None: return 0 tx_disabled=0 for i in range(len(tx_disable_list)): if tx_disable_list[i]: tx_disabled |=1 << i return tx_disabled def get_lpmode(self): \"\"\" Retrieves the lpmode(low power mode) status of this SFP Returns: A Boolean, True if lpmode is enabled, False if disabled \"\"\" if self.port_num < 49: return False else: power_set=self.get_power_set() power_override=self.get_power_override() return power_set and power_override def get_power_set(self): if self.port_num < 49: return False else: power_set=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) power_set=( 'On'==dom_control_data['data']['PowerSet']['value']) return power_set def get_power_override(self): \"\"\" Retrieves the power-override status of this SFP Returns: A Boolean, True if power-override is enabled, False if disabled \"\"\" if self.port_num < 49: return False else: power_override=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) power_override=( 'On'==dom_control_data['data']['PowerOverride']['value']) return power_override def reset(self): \"\"\" Reset SFP and return all user module settings to their default srate. Returns: A boolean, True if successful, False if not \"\"\" if self.port_num <49: return False cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] reset_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_reset_', self.port_num) ret=self._api_helper.write_txt_file(reset_path, 1) if ret is not True: return ret time.sleep(0.01) ret=self._api_helper.write_txt_file(reset_path, 0) time.sleep(0.2) return ret def tx_disable(self, tx_disable): \"\"\" Disable SFP TX for all channels Args: tx_disable: A Boolean, True to enable tx_disable mode, False to disable tx_disable mode. Returns: A boolean, True if tx_disable is set successfully, False if not \"\"\" if self.port_num < 49: cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] tx_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_disable_', self.port_num) ret=self._api_helper.write_txt_file(tx_path, 1 if tx_disable else 0) if ret is not None: time.sleep(0.01) return ret else: return False else: if not self.get_presence(): return False sysfsfile_eeprom=None try: tx_disable_ctl=0xf if tx_disable else 0x0 buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=tx_disable_ctl else: buffer[0]=chr(tx_disable_ctl) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ',str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def tx_disable_channel(self, channel, disable): \"\"\" Sets the tx_disable for specified SFP channels Args: channel: A hex of 4 bits(bit 0 to bit 3) which represent channel 0 to 3, e.g. 0x5 for channel 0 and channel 2. disable: A boolean, True to disable TX channels specified in channel, False to enable Returns: A boolean, True if successful, False if not \"\"\" if self.port_num < 49: return False else: if not self.get_presence(): return False sysfsfile_eeprom=None try: channel_state=self.get_tx_disable_channel() for i in range(4): channel_mask=(1 << i) if not(channel & channel_mask): continue if disable: channel_state |=channel_mask else: channel_state &=~channel_mask buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=channel_state else: buffer[0]=chr(channel_state) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ', str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def set_lpmode(self, lpmode): \"\"\" Sets the lpmode(low power mode) of SFP Args: lpmode: A Boolean, True to enable lpmode, False to disable it Note : lpmode can be overridden by set_power_override Returns: A boolean, True if lpmode is set successfully, False if not \"\"\" if self.port_num < 49: return False else: if lpmode: self.set_power_override(True, True) else: self.set_power_override(False, False) return True def set_power_override(self, power_override, power_set): \"\"\" Sets SFP power level using power_override and power_set Args: power_override: A Boolean, True to override set_lpmode and use power_set to control SFP power, False to disable SFP power control through power_override/power_set and use set_lpmode to control SFP power. power_set: Only valid when power_override is True. A Boolean, True to set SFP to low power mode, False to set SFP to high power mode. Returns: A boolean, True if power-override and power_set are set successfully, False if not \"\"\" if self.port_num < 49: return False else: if not self.get_presence(): return False try: power_override_bit=(1 << 0) if power_override else 0 power_set_bit =(1 << 1) if power_set else(1 << 3) buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=(power_override_bit | power_set_bit) else: buffer[0]=chr(power_override_bit | power_set_bit) with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd: fd.seek(QSFP_POWEROVERRIDE_OFFSET) fd.write(buffer[0]) time.sleep(0.01) except Exception: print('Error: unable to open file: ', str(e)) return False return True def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" sfputil_helper=SfpUtilHelper() sfputil_helper.read_porttab_mappings( self.__get_path_to_port_config_file()) name=sfputil_helper.logical[self.index] or \"Unknown\" return name def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] present_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_present_', self.port_num) val=self._api_helper.read_txt_file(present_path) if val is not None: return int(val, 10)==1 else: return False def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return self.get_presence() def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return self.port_num def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return True ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Sfp contains an implementation of SONiC Platform Base API and\n# provides the sfp device status which are available in the platform\n#\n#############################################################################\n\nimport os\nimport time\nimport sys\n\nfrom ctypes import create_string_buffer\n\ntry:\n    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_I2C_PATH = \"/sys/bus/i2c/devices/\"\n\nclass Sfp(SfpOptoeBase):\n    \"\"\"Platform-specific Sfp class\"\"\"\n\n    # Port number\n    PORT_START = 1\n    PORT_END = 54\n    QSFP_PORT_START = 49\n\n    # Path to sysfs\n    PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n    PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n        \n    PLATFORM = \"x86_64-accton_as5835_54x-r0\"\n    HWSKU = \"Accton-AS5835-54X\"\n\n    _cpld_mapping = {\n        0:  \"3-0060\",\n        1:  \"3-0061\",\n        2:  \"3-0062\",\n    }\n    _port_to_i2c_mapping = {\n        1:  42,\n        2:  43,\n        3:  44,\n        4:  45,\n        5:  46,\n        6:  47,\n        7:  48,\n        8:  49,\n        9:  50,\n        10: 51,\n        11: 52,\n        12: 53,\n        13: 54,\n        14: 55,\n        15: 56,\n        16: 57,\n        17: 58,\n        18: 59,\n        19: 60,\n        20: 61,\n        21: 62,\n        22: 63,\n        23: 64,\n        24: 65,\n        25: 66,\n        26: 67,\n        27: 68,\n        28: 69,\n        29: 70,\n        30: 71,\n        31: 72,\n        32: 73,\n        33: 74,\n        34: 75,\n        35: 76,\n        36: 77,\n        37: 78,\n        38: 79,\n        39: 80,\n        40: 81,\n        41: 82,\n        42: 83,\n        43: 84,\n        44: 85,\n        45: 86,\n        46: 87,\n        47: 88,\n        48: 89,\n        49: 28,  # QSFP49\n        50: 29,  # QSFP50\n        51: 26,  # QSFP51\n        52: 30,  # QSFP52\n        53: 31,  # QSFP53\n        54: 27,  # QSFP54\n        \n    }\n\n    def __init__(self, sfp_index=0):\n        SfpOptoeBase.__init__(self)\n        self._api_helper=APIHelper()\n        # Init index\n        self.index = sfp_index\n        self.port_num = self.index + 1\n\n        # Init eeprom path\n        eeprom_path = '/sys/bus/i2c/devices/{0}-0050/eeprom'\n        self.port_to_eeprom_mapping = {}\n        for x in range(self.PORT_START, self.PORT_END + 1):\n            self.port_to_eeprom_mapping[x] = eeprom_path.format(self._port_to_i2c_mapping[x])\n\n    def get_eeprom_path(self):\n        return self.port_to_eeprom_mapping[self.port_num]\n        \n    # For cage 1~38 are at cpld2, others are at cpld3.\n    def __get_cpld_num(self, port_num):\n        return 1 if (port_num < 39) else 2\n\n\n    def __is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def __get_path_to_port_config_file(self):\n        platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n        hwsku_path = \"/\".join([platform_path, self.HWSKU]\n                              ) if self.__is_host() else self.PMON_HWSKU_PATH\n        return \"/\".join([hwsku_path, \"port_config.ini\"])\n\n    def __read_eeprom_specific_bytes(self, offset, num_bytes):\n        sysfsfile_eeprom = None\n        eeprom_raw = []\n        for i in range(0, num_bytes):\n            eeprom_raw.append(\"0x00\")\n\n        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]\n        try:\n            sysfsfile_eeprom = open(\n                sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0)\n            sysfsfile_eeprom.seek(offset)\n            raw = sysfsfile_eeprom.read(num_bytes)\n            if sys.version_info[0] >= 3:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(raw[n])[2:].zfill(2)\n            else:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(ord(raw[n]))[2:].zfill(2)\n        except Exception:\n            pass\n        finally:\n            if sysfsfile_eeprom:\n                sysfsfile_eeprom.close()\n\n        return eeprom_raw\n\n    def get_reset_status(self):\n        \"\"\"\n        Retrieves the reset status of SFP\n        Returns:\n            A Boolean, True if reset enabled, False if disabled\n        \"\"\"\n        if self.port_num <49:\n            return False # SPF port doesn't support this feature\n          \n        cpld_i = self.__get_cpld_num(self.port_num)\n        cpld_path = self._cpld_mapping[cpld_i]        \n        reset_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_reset_', self.port_num)\n        val=self._api_helper.read_txt_file(reset_path)\n        if val is not None:\n            return int(val, 10)==1\n        else:\n            return False\n\n    def get_rx_los(self):\n        \"\"\"\n        Retrieves the RX LOS (lost-of-signal) status of SFP\n        Returns:\n            A Boolean, True if SFP has RX LOS, False if not.\n            Note : RX LOS status is latched until a call to get_rx_los or a reset.\n        \"\"\"\n        rx_los = False\n        if self.port_num < 49:\n            cpld_i = self.__get_cpld_num(self.port_num)\n            cpld_path = self._cpld_mapping[cpld_i]        \n            rx_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_rx_los_', self.port_num)\n\n            rx_los=self._api_helper.read_txt_file(rx_path)\n            if int(rx_los, 10) == 1:\n                return [True]\n            else:\n                return [False]\n            #status_control_raw = self.__read_eeprom_specific_bytes(\n            #    SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            #if status_control_raw:\n            #    data = int(status_control_raw[0], 16)\n            #    rx_los = (sffbase().test_bit(data, 1) != 0)\n            \n        else:\n            rx_los_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None\n            if dom_channel_monitor_raw is not None:\n                rx_los_data = int(dom_channel_monitor_raw[0], 16)\n                rx_los_list.append(rx_los_data & 0x01 != 0)\n                rx_los_list.append(rx_los_data & 0x02 != 0)\n                rx_los_list.append(rx_los_data & 0x04 != 0)\n                rx_los_list.append(rx_los_data & 0x08 != 0)\n                return rx_los_list\n            else:\n                return [False]*4\n\n    def get_tx_fault(self):\n        \"\"\"\n        Retrieves the TX fault status of SFP\n        Returns:\n            A list of boolean values, representing the TX fault status\n            of each available channel, value is True if SFP channel\n            has TX fault, False if not.\n            E.g., for a tranceiver with four channels: [False, False, True, False]\n            Note : TX fault status is lached until a call to get_tx_fault or a reset.\n        \"\"\"\n        tx_fault = False\n        if self.port_num < 49:\n            cpld_i = self.__get_cpld_num(self.port_num)\n            cpld_path = self._cpld_mapping[cpld_i]        \n            tx_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_fault_', self.port_num)\n\n            tx_fault=self._api_helper.read_txt_file(tx_path)\n            if int(tx_fault, 10) == 1:\n                return [True]\n            else:\n                return [False]\n            #status_control_raw = self.__read_eeprom_specific_bytes(\n            #    SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            #if status_control_raw:\n            #    data = int(status_control_raw[0], 16)\n            #    tx_fault = (sffbase().test_bit(data, 2) != 0)\n        else:\n            tx_fault_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None\n            if dom_channel_monitor_raw is not None:\n                tx_fault_data = int(dom_channel_monitor_raw[0], 16)\n                tx_fault_list.append(tx_fault_data & 0x01 != 0)\n                tx_fault_list.append(tx_fault_data & 0x02 != 0)\n                tx_fault_list.append(tx_fault_data & 0x04 != 0)\n                tx_fault_list.append(tx_fault_data & 0x08 != 0)\n                return tx_fault_list\n            else:\n                return [False]*4\n\n\n    def get_tx_disable(self):\n        \"\"\"\n        Retrieves the tx_disable status of this SFP\n        Returns:\n            A list of boolean values, representing the TX disable status\n            of each available channel, value is True if SFP channel\n            is TX disabled, False if not.\n            E.g., for a tranceiver with four channels: [False, False, True, False]\n        \"\"\"\n        if self.port_num < 49: \n            tx_disable = False\n            \n            cpld_i = self.__get_cpld_num(self.port_num)\n            cpld_path = self._cpld_mapping[cpld_i]        \n            tx_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_disable_', self.port_num)\n\n            tx_disable=self._api_helper.read_txt_file(tx_path)\n            \n            #status_control_raw = self.__read_eeprom_specific_bytes(\n            #    SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            #if status_control_raw:\n            #    data = int(status_control_raw[0], 16)\n            #    tx_disable_hard = (sffbase().test_bit(\n            #        data, SFP_TX_DISABLE_HARD_BIT) != 0)\n            #    tx_disable_soft = (sffbase().test_bit(\n            #        data, SFP_TX_DISABLE_SOFT_BIT) != 0)\n            #    tx_disable = tx_disable_hard | tx_disable_soft\n            if int(tx_disable, 10)==0:\n                return [False]\n            else:\n                return [True]\n\n        else:\n            tx_disable_list = []\n    \n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n    \n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX1Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX2Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX3Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX4Disable']['value'])\n                return tx_disable_list\n            else:\n                return [False]*4\n\n    def get_tx_disable_channel(self):\n        \"\"\"\n        Retrieves the TX disabled channels in this SFP\n        Returns:\n            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent\n            TX channels which have been disabled in this SFP.\n            As an example, a returned value of 0x5 indicates that channel 0\n            and channel 2 have been disabled.\n        \"\"\"\n        tx_disable_list = self.get_tx_disable()\n        if tx_disable_list is None:\n            return 0\n        tx_disabled = 0\n        for i in range(len(tx_disable_list)):\n            if tx_disable_list[i]:\n                tx_disabled |= 1 << i\n        return tx_disabled\n\n    def get_lpmode(self):\n        \"\"\"\n        Retrieves the lpmode (low power mode) status of this SFP\n        Returns:\n            A Boolean, True if lpmode is enabled, False if disabled\n        \"\"\"\n        if self.port_num < 49: \n            # SFP doesn't support this feature\n            return False\n        else:\n            power_set=self.get_power_set()\n            power_override = self.get_power_override()\n            return power_set and power_override\n       \n    \n    def get_power_set(self):\n        \n        if self.port_num < 49: \n            # SFP doesn't support this feature\n            return False\n        else:\n            power_set = False\n            \n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n    \n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n                power_set = (\n                    'On' == dom_control_data['data']['PowerSet']['value'])\n    \n            return power_set\n\n    def get_power_override(self):\n        \"\"\"\n        Retrieves the power-override status of this SFP\n        Returns:\n            A Boolean, True if power-override is enabled, False if disabled\n        \"\"\"\n        if self.port_num < 49:\n            return False # SFP doesn't support this feature\n        else:\n            power_override = False\n    \n            \n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n    \n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n                power_override = (\n                    'On' == dom_control_data['data']['PowerOverride']['value'])\n    \n            return power_override\n\n    def reset(self):\n        \"\"\"\n        Reset SFP and return all user module settings to their default srate.\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        if self.port_num <49:\n            return False # SFP doesn't support this feature\n          \n        cpld_i = self.__get_cpld_num(self.port_num)\n        cpld_path = self._cpld_mapping[cpld_i]        \n        reset_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_reset_', self.port_num)      \n        ret = self._api_helper.write_txt_file(reset_path, 1)\n\n        if ret is not True:\n            return ret\n\n        time.sleep(0.01)\n        ret = self._api_helper.write_txt_file(reset_path, 0)\n        time.sleep(0.2)\n        \n        return ret\n      \n    def tx_disable(self, tx_disable):\n        \"\"\"\n        Disable SFP TX for all channels\n        Args:\n            tx_disable : A Boolean, True to enable tx_disable mode, False to disable\n                         tx_disable mode.\n        Returns:\n            A boolean, True if tx_disable is set successfully, False if not\n        \"\"\"\n        if self.port_num < 49:\n            cpld_i = self.__get_cpld_num(self.port_num)\n            cpld_path = self._cpld_mapping[cpld_i]        \n            tx_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_disable_', self.port_num)      \n            ret = self._api_helper.write_txt_file(tx_path,  1 if tx_disable else 0)\n\n            if ret is not None:\n                time.sleep(0.01)\n                return ret\n            else:\n                return False\n        \n        else:\n            if not self.get_presence():\n                return False\n            sysfsfile_eeprom = None\n            try:\n                tx_disable_ctl = 0xf if tx_disable else 0x0\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = tx_disable_ctl\n                else:\n                    buffer[0] = chr(tx_disable_ctl)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print ('Error: unable to open file: ',str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n        return True\n\n    def tx_disable_channel(self, channel, disable):\n        \"\"\"\n        Sets the tx_disable for specified SFP channels\n        Args:\n            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,\n                      e.g. 0x5 for channel 0 and channel 2.\n            disable : A boolean, True to disable TX channels specified in channel,\n                      False to enable\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        \n        if self.port_num < 49:\n            return False # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n\n            sysfsfile_eeprom = None\n            try:\n                channel_state = self.get_tx_disable_channel()\n\n                for i in range(4):\n                    channel_mask = (1 << i)\n                    if not (channel & channel_mask):\n                        continue\n\n                    if disable:\n                        channel_state |= channel_mask\n                    else:\n                        channel_state &= ~channel_mask\n\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = channel_state\n                else:\n                    buffer[0] = chr(channel_state)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print ('Error: unable to open file: ', str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n            return True\n\n    def set_lpmode(self, lpmode):\n        \"\"\"\n        Sets the lpmode (low power mode) of SFP\n        Args:\n            lpmode: A Boolean, True to enable lpmode, False to disable it\n            Note  : lpmode can be overridden by set_power_override\n        Returns:\n            A boolean, True if lpmode is set successfully, False if not\n        \"\"\"\n        if self.port_num < 49:\n            return False # SFP doesn't support this feature\n        else:\n            if lpmode:\n                self.set_power_override(True, True)\n            else:\n                self.set_power_override(False, False)\n    \n            return True\n       \n    def set_power_override(self, power_override, power_set):\n        \"\"\"\n        Sets SFP power level using power_override and power_set\n        Args:\n            power_override :\n                    A Boolean, True to override set_lpmode and use power_set\n                    to control SFP power, False to disable SFP power control\n                    through power_override/power_set and use set_lpmode\n                    to control SFP power.\n            power_set :\n                    Only valid when power_override is True.\n                    A Boolean, True to set SFP to low power mode, False to set\n                    SFP to high power mode.\n        Returns:\n            A boolean, True if power-override and power_set are set successfully,\n            False if not\n        \"\"\"\n        if self.port_num < 49:\n            return False # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n            try:\n                power_override_bit = (1 << 0) if power_override else 0\n                power_set_bit      = (1 << 1) if power_set else (1 << 3)\n    \n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = (power_override_bit | power_set_bit)\n                else:\n                    buffer[0] = chr(power_override_bit | power_set_bit)\n                # Write to eeprom\n                with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd:\n                    fd.seek(QSFP_POWEROVERRIDE_OFFSET)\n                    fd.write(buffer[0])\n                    time.sleep(0.01)\n            except Exception:\n                print ('Error: unable to open file: ', str(e))\n                return False\n            return True\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        sfputil_helper = SfpUtilHelper()\n        sfputil_helper.read_porttab_mappings(\n            self.__get_path_to_port_config_file())\n        name = sfputil_helper.logical[self.index] or \"Unknown\"\n        return name\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        cpld_i = self.__get_cpld_num(self.port_num)\n        cpld_path = self._cpld_mapping[cpld_i]          \n        present_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_present_', self.port_num)\n        val=self._api_helper.read_txt_file(present_path)\n        if val is not None:\n            return int(val, 10)==1\n        else:\n            return False\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return self.get_presence()\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return self.port_num\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return True\n"}, "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n #\n #############################################################################\n try:\n-    import sys\n-    import re\n-    import os\n     import subprocess\n-    import json\n-    import syslog\n     from sonic_platform_base.chassis_base import ChassisBase\n     from sonic_py_common.logger import Logger\n     from sonic_platform.fan import Fan\n", "add": 0, "remove": 5, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py", "badparts": ["    import sys", "    import re", "    import json", "    import syslog"], "goodparts": []}, {"diff": "\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n COMPONENT_NAME_LIST = [\"BIOS\"]\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         logger.log_info(\"Chassis loaded successfully\")\n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n ", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n try: import sys import re import os import subprocess import json import syslog from sonic_platform_base.chassis_base import ChassisBase from sonic_py_common.logger import Logger from sonic_platform.fan import Fan from sonic_platform.psu import Psu from sonic_platform.component import Component from sonic_platform.thermal import Thermal from sonic_platform.sfp import Sfp from sonic_platform.eeprom import Tlv except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=5 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=4 NUM_SFP=54 SFP_PORT_START=0 QSFP_PORT_START=48 SFP_PORT_END=47 QSFP_PORT_END=53 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" COMPONENT_NAME_LIST=[\"BIOS\"] HOST_CHK_CMD=\"docker > /dev/null 2>&1\" class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): super(Chassis, self).__init__() for fantray_index in range(0, NUM_FAN_TRAY): for fan_index in range(0, NUM_FAN): fan=Fan(fantray_index, fan_index) self._fan_list.append(fan) for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) self.PORT_START=SFP_PORT_START self.QSFP_PORT_START=QSFP_PORT_START self.PORT_END=QSFP_PORT_END for index in range(0, NUM_SFP): if index in range(self.QSFP_PORT_START, self.QSPORT_END +1): sfp_module=Sfp(index, 'QSFP') else: sfp_module=Sfp(index, 'SFP') self._sfp_list.append(sfp_module) self._component_name_list=COMPONENT_NAME_LIST self._watchdog=Watchdog() self._eeprom=Tlv() logger.log_info(\"Chassis loaded successfully\") def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_firmware_version(self, component_name): \"\"\" Retrieves platform-specific hardware/firmware versions for chassis componenets such as BIOS, CPLD, FPGA, etc. Args: type: A string, component name Returns: A string containing platform-specific component versions \"\"\" self.component=Component(component_name) if component_name not in self._component_name_list: return None return self.component.get_firmware_version() def install_component_firmware(self, component_name, image_path): \"\"\" Install firmware to module Args: type: A string, component name. image_path: A string, path to firmware image. Returns: A boolean, True if install successfully, False if not \"\"\" self.component=Component(component_name) if component_name not in self._component_name_list: return False return self.component.upgrade_firmware(image_path) def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" description='None' reboot_cause=self.REBOOT_CAUSE_HARDWARE_OTHER reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) if self.__is_host( ) else PMON_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE prev_reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +PREV_REBOOT_CAUSE_FILE) if self.__is_host( ) else PMON_REBOOT_CAUSE_PATH +PREV_REBOOT_CAUSE_FILE sw_reboot_cause=self.__read_txt_file( reboot_cause_path) or \"Unknown\" prev_sw_reboot_cause=self.__read_txt_file( prev_reboot_cause_path) or \"Unknown\" if sw_reboot_cause !=\"Unknown\": reboot_cause=self.REBOOT_CAUSE_NON_HARDWARE description=sw_reboot_cause else: reboot_cause=self.REBOOT_CAUSE_HARDWARE_OTHER description='Unknown reason' return(reboot_cause, description) ", "sourceWithComments": "#############################################################################\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\ntry:\n    import sys\n    import re\n    import os\n    import subprocess\n    import json\n    import syslog\n    from sonic_platform_base.chassis_base import ChassisBase\n    from sonic_py_common.logger import Logger\n    from sonic_platform.fan import Fan\n    from sonic_platform.psu import Psu\n    from sonic_platform.component import Component\n    from sonic_platform.thermal import Thermal\n    from sonic_platform.sfp import Sfp\n    from sonic_platform.eeprom import Tlv\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 5\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 4\nNUM_SFP = 54\nSFP_PORT_START = 0\nQSFP_PORT_START = 48\nSFP_PORT_END = 47\nQSFP_PORT_END = 53\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nCOMPONENT_NAME_LIST = [\"BIOS\"]\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        super(Chassis, self).__init__()\n\n        for fantray_index in range(0, NUM_FAN_TRAY):\n            for fan_index in range(0, NUM_FAN):\n                fan = Fan(fantray_index, fan_index)\n                self._fan_list.append(fan)\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n\n        self.PORT_START = SFP_PORT_START\n        self.QSFP_PORT_START = QSFP_PORT_START\n        self.PORT_END = QSFP_PORT_END\n        for index in range(0, NUM_SFP):\n            if index in range(self.QSFP_PORT_START, self.QSPORT_END + 1):\n                sfp_module = Sfp(index, 'QSFP')\n            else:\n                sfp_module = Sfp(index, 'SFP')\n            self._sfp_list.append(sfp_module)\n        self._component_name_list = COMPONENT_NAME_LIST\n        self._watchdog = Watchdog()\n        self._eeprom = Tlv()\n        logger.log_info(\"Chassis loaded successfully\")\n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_firmware_version(self, component_name):\n        \"\"\"\n        Retrieves platform-specific hardware/firmware versions for chassis\n        componenets such as BIOS, CPLD, FPGA, etc.\n        Args:\n            type: A string, component name\n\n        Returns:\n            A string containing platform-specific component versions\n        \"\"\"\n        self.component = Component(component_name)\n        if component_name not in self._component_name_list:\n            return None\n        return self.component.get_firmware_version()\n\n    def install_component_firmware(self, component_name, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            type: A string, component name.\n            image_path: A string, path to firmware image.\n\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        self.component = Component(component_name)\n        if component_name not in self._component_name_list:\n            return False\n        return self.component.upgrade_firmware(image_path)\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        description = 'None'\n        reboot_cause = self.REBOOT_CAUSE_HARDWARE_OTHER\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE) if self.__is_host(\n        ) else PMON_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE\n        prev_reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + PREV_REBOOT_CAUSE_FILE) if self.__is_host(\n        ) else PMON_REBOOT_CAUSE_PATH + PREV_REBOOT_CAUSE_FILE\n        sw_reboot_cause = self.__read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n        prev_sw_reboot_cause = self.__read_txt_file(\n            prev_reboot_cause_path) or \"Unknown\"\n\n        if sw_reboot_cause != \"Unknown\":\n            reboot_cause = self.REBOOT_CAUSE_NON_HARDWARE\n            description = sw_reboot_cause\n        else:\n            reboot_cause = self.REBOOT_CAUSE_HARDWARE_OTHER\n            description = 'Unknown reason'\n\n        return (reboot_cause, description)\n"}, "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py": {"changes": [{"diff": "\n # provides the components firmware management function\n #############################################################################\n \n-import json\n import os.path\n-import shutil\n-import shlex\n import subprocess\n \n try:\n", "add": 0, "remove": 3, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py", "badparts": ["import json", "import shutil", "import shlex"], "goodparts": []}, {"diff": "\n     def __run_command(self, command):\n         # Run bash command and print output to stdout\n         try:\n-            process = subprocess.Popen(\n-                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n+            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n             while True:\n                 output = process.stdout.readline()\n                 if output == '' and process.poll()", "add": 1, "remove": 2, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py", "badparts": ["            process = subprocess.Popen(", "                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)"], "goodparts": ["            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)"]}], "source": "\n import json import os.path import shutil import shlex import subprocess try: from sonic_platform_base.device_base import DeviceBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" class Component(DeviceBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_name): DeviceBase.__init__(self) self.name=component_name.upper() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() return fw_version def upgrade_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" if not os.path.isfile(image_path): return False if self.name==\"BIOS\": print(\"Not supported\") return False return self.__run_command(install_command) ", "sourceWithComments": "#############################################################################\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#############################################################################\n\nimport json\nimport os.path\nimport shutil\nimport shlex\nimport subprocess\n\ntry:\n    from sonic_platform_base.device_base import DeviceBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\n\n\nclass Component(DeviceBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_name):\n        DeviceBase.__init__(self)\n        self.name = component_name.upper()\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n\n        return fw_version\n\n    def upgrade_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        if not os.path.isfile(image_path):\n            return False\n\n        if self.name == \"BIOS\":\n            print(\"Not supported\")\n            return False\n\n        return self.__run_command(install_command)\n"}, "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n # provides the sfp device status which are available in the platform\n #############################################################################\n try:\n-    import os\n     import time\n     import subprocess\n-    import syslog\n     from ctypes import create_string_buffer\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom\n", "add": 0, "remove": 2, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py", "badparts": ["    import syslog"], "goodparts": []}, {"diff": "\n \n     PLATFORM_ROOT_PATH = '/usr/share/sonic/device'\n     PMON_HWSKU_PATH = '/usr/share/sonic/hwsku'\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-accton_as7116_54x-r0\"\n     HWSKU = \"Accton-AS7116-54X-R0\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         return \"\"\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, s", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}]}, "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n     \n     \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path)", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=6 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=4 PORT_END=54 NUM_COMPONENT=4 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"docker > /dev/null 2>&1\" class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(0, PORT_END): sfp=Sfp(index) self._sfp_list.append(sfp) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan import Fan for fant_index in range(0, NUM_FAN_TRAY): for fan_index in range(0, NUM_FAN): fan=Fan(fant_index, fan_index) self._fan_list.append(fan) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._api_helper.hwsku def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_serial_number(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 6\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 4\nPORT_END = 54\nNUM_COMPONENT = 4\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n        \n        self.config_data = {}\n        \n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n    \n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(0, PORT_END):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self.sfp_module_initialized = True\n        \n    def __initialize_fan(self):\n        from sonic_platform.fan import Fan\n        for fant_index in range(0, NUM_FAN_TRAY):\n            for fan_index in range(0, NUM_FAN):\n                fan = Fan(fant_index, fan_index)\n                self._fan_list.append(fan)\n                \n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n    \n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n    \n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n    \n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n    \n    \n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        \n        return self._api_helper.hwsku\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n    \n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n    \n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_serial_number(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()   \n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        \n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n         \n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n"}, "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 2, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware versi", "add": 0, "remove": 16, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"4-0060\", \"CPLD2\": \"5-0062\", \"CPLD3\": \"6-0064\", } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"CPLD2\", \"CPLD 2\"), (\"CPLD3\", \"CPLD 3\"), (\"BIOS\", \"Basic Input/Output System\") ] COMPONENT_DES_LIST=[\"CPLD\",\"Basic Input/Output System\"] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"4-0060\",\n    \"CPLD2\": \"5-0062\",\n    \"CPLD3\": \"6-0064\",\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"CPLD2\", \"CPLD 2\"),\n   (\"CPLD3\", \"CPLD 3\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n   \n]\nCOMPONENT_DES_LIST = [\"CPLD\",\"Basic Input/Output System\"]\n\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n   \n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)\n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n        \n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n        #return \"testhwsku\"\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n"}, "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        retu", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        retu"], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n         \n     PLATFORM = \"x86_64-accton_as7312_54x-r0\"\n     HWSKU = \"Accton-AS7312-54X\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         return True\n     \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PAT", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}]}, "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE= \"/sys/class/leds/accton_as7326_56x_led::diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n         self._watchdog = Watchdog()\n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_p", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os import sys try: from sonic_platform_base.chassis_base import ChassisBase from.event import SfpEvent from sonic_py_common import device_info except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=6 NUM_PSU=2 NUM_THERMAL=4 NUM_PORT=58 NUM_COMPONENT=4 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" SYSLED_FNODE=\"/sys/class/leds/accton_as7326_56x_led::diag/brightness\" SYSLED_MODES={ \"0\": \"STATUS_LED_COLOR_OFF\", \"1\": \"STATUS_LED_COLOR_GREEN\", \"3\": \"STATUS_LED_COLOR_RED\", \"5\": \"STATUS_LED_COLOR_GREEN_BLINK\" } class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self.config_data={} (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(NUM_PORT): sfp=Sfp(index) self._sfp_list.append(sfp) self._sfpevent=SfpEvent(self._sfp_list) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for fant_index in range(NUM_FAN_TRAY): fandrawer=FanDrawer(fant_index) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: return fd.read().strip() except IOError: pass return None def __write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except Exception: return False return True def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._eeprom.get_product_name() def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" description='None' reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) if self.__is_host( ) else(PMON_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) prev_reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +PREV_REBOOT_CAUSE_FILE) if self.__is_host( ) else(PMON_REBOOT_CAUSE_PATH +PREV_REBOOT_CAUSE_FILE) sw_reboot_cause =self.__read_txt_file(reboot_cause_path) or \"Unknown\" prev_sw_reboot_cause=self.__read_txt_file(prev_reboot_cause_path) or \"Unknown\" if sw_reboot_cause !=\"Unknown\": reboot_cause=self.REBOOT_CAUSE_NON_HARDWARE description=sw_reboot_cause elif prev_reboot_cause_path !=\"Unknown\": reboot_cause=self.REBOOT_CAUSE_NON_HARDWARE description=prev_sw_reboot_cause return(reboot_cause, description) def get_change_event(self, timeout=0): if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfpevent.get_sfp_event(timeout) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def initizalize_system_led(self): return True def get_status_led(self): val=self.__read_txt_file(SYSLED_FNODE) return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\" def set_status_led(self, color): mode=None for key, val in SYSLED_MODES.items(): if val==color: mode=key break if mode is None: return False else: return self.__write_txt_file(SYSLED_FNODE, mode) ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\nimport sys\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .event import SfpEvent\n    from sonic_py_common import device_info\n\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 6\nNUM_PSU = 2\nNUM_THERMAL = 4\nNUM_PORT = 58\nNUM_COMPONENT = 4\n\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\nSYSLED_FNODE= \"/sys/class/leds/accton_as7326_56x_led::diag/brightness\"\nSYSLED_MODES = {\n    \"0\" : \"STATUS_LED_COLOR_OFF\",\n    \"1\" : \"STATUS_LED_COLOR_GREEN\",\n    \"3\" : \"STATUS_LED_COLOR_RED\",\n    \"5\" : \"STATUS_LED_COLOR_GREEN_BLINK\"\n}\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self.config_data = {}\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n\n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(NUM_PORT):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self._sfpevent = SfpEvent(self._sfp_list)\n        self.sfp_module_initialized = True\n\n    def __initialize_fan(self):\n        from sonic_platform.fan_drawer import FanDrawer\n        for fant_index in range(NUM_FAN_TRAY):\n            fandrawer = FanDrawer(fant_index)\n            self._fan_drawer_list.append(fandrawer)\n            self._fan_list.extend(fandrawer._fan_list)\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        self._watchdog = Watchdog()\n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                return fd.read().strip()\n        except IOError:\n            pass\n        return None\n\n    def __write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except Exception:\n            return False\n        return True\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return self._eeprom.get_product_name()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        description = 'None'\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE) if self.__is_host(\n        ) else (PMON_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        prev_reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + PREV_REBOOT_CAUSE_FILE) if self.__is_host(\n        ) else (PMON_REBOOT_CAUSE_PATH + PREV_REBOOT_CAUSE_FILE)\n\n        sw_reboot_cause      = self.__read_txt_file(reboot_cause_path) or \"Unknown\"\n        prev_sw_reboot_cause = self.__read_txt_file(prev_reboot_cause_path) or \"Unknown\"\n\n        if sw_reboot_cause != \"Unknown\":\n            reboot_cause = self.REBOOT_CAUSE_NON_HARDWARE\n            description = sw_reboot_cause\n        elif prev_reboot_cause_path != \"Unknown\":\n            reboot_cause = self.REBOOT_CAUSE_NON_HARDWARE\n            description = prev_sw_reboot_cause\n\n        return (reboot_cause, description)\n\n    def get_change_event(self, timeout=0):\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n        return self._sfpevent.get_sfp_event(timeout)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n\n    def initizalize_system_led(self):\n        return True\n\n    def get_status_led(self):\n        val = self.__read_txt_file(SYSLED_FNODE)\n        return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\"\n\n    def set_status_led(self, color):\n        mode = None\n        for key, val in SYSLED_MODES.items():\n            if val == color:\n                mode = key\n                break\n        if mode is None:\n            return False\n        else:\n            return self.__write_txt_file(SYSLED_FNODE, mode)\n"}, "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n \n     PLATFORM = \"x86_64-accton_as7326_56x-r0\"\n     HWSKU = \"Accton-AS7326-56X\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_P", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}], "source": "\n import os import time import sys from ctypes import create_string_buffer try: from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ 0:{ \"bus\": 18, \"addr\": \"60\" }, 1:{ \"bus\": 12, \"addr\": \"62\" }, } CPLD_I2C_PATH=\"/sys/bus/i2c/devices/{}-00{}/\" class Sfp(SfpOptoeBase): \"\"\"Platform-specific Sfp class\"\"\" PORT_START=1 PORT_END=58 PLATFORM_ROOT_PATH=\"/usr/share/sonic/device\" PMON_HWSKU_PATH=\"/usr/share/sonic/hwsku\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" PLATFORM=\"x86_64-accton_as7326_56x-r0\" HWSKU=\"Accton-AS7326-56X\" _port_to_i2c_mapping={ 1:[42], 2:[41], 3:[44], 4:[43], 5:[47], 6:[45], 7:[46], 8:[50], 9:[48], 10:[49], 11:[52], 12:[51], 13:[53], 14:[56], 15:[55], 16:[54], 17:[58], 18:[57], 19:[60], 20:[59], 21:[61], 22:[63], 23:[62], 24:[64], 25:[66], 26:[68], 27:[65], 28:[67], 29:[69], 30:[71], 31:[72], 32:[70], 33:[74], 34:[73], 35:[76], 36:[75], 37:[77], 38:[79], 39:[78], 40:[80], 41:[81], 42:[82], 43:[84], 44:[85], 45:[83], 46:[87], 47:[88], 48:[86], 49:[25], 50:[26], 51:[27], 52:[28], 53:[29], 54:[30], 55:[31], 56:[32], 57:[22], 58:[23] } def __init__(self, sfp_index=0): SfpOptoeBase.__init__(self) self.index=sfp_index self.port_num=self.index +1 cpld_idx=0 if self.port_num > 30 else 1 bus=CPLD_ADDR_MAPPING[cpld_idx][\"bus\"] addr=CPLD_ADDR_MAPPING[cpld_idx][\"addr\"] self.cpld_path=CPLD_I2C_PATH.format(bus, addr) eeprom_path='/sys/bus/i2c/devices/{0}-0050/eeprom' self.port_to_eeprom_mapping={} for x in range(self.PORT_START, self.PORT_END +1): self.port_to_eeprom_mapping[x]=eeprom_path.format( self._port_to_i2c_mapping[x][0]) def get_eeprom_path(self): return self.port_to_eeprom_mapping[self.port_num] def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: return fd.read().strip() except IOError: pass return \"\" def __write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except Exception: return False return True def __is_host(self): return os.system(self.HOST_CHK_CMD)==0 def __get_path_to_port_config_file(self): platform_path=\"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM]) hwsku_path=\"/\".join( [platform_path, self.HWSKU]) if self.__is_host() else self.PMON_HWSKU_PATH return \"/\".join([hwsku_path, \"port_config.ini\"]) def __read_eeprom_specific_bytes(self, offset, num_bytes): sysfsfile_eeprom=None eeprom_raw=[] for i in range(0, num_bytes): eeprom_raw.append(\"0x00\") sysfs_sfp_i2c_client_eeprom_path=self.port_to_eeprom_mapping[ self.port_num] try: sysfsfile_eeprom=open( sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0) sysfsfile_eeprom.seek(offset) raw=sysfsfile_eeprom.read(num_bytes) for n in range(0, num_bytes): if sys.version_info[0] >=3: eeprom_raw[n]=hex(raw[n])[2:].zfill(2) else: eeprom_raw[n]=hex(ord(raw[n]))[2:].zfill(2) except Exception: pass finally: if sysfsfile_eeprom: sysfsfile_eeprom.close() return eeprom_raw def get_reset_status(self): \"\"\" Retrieves the reset status of SFP Returns: A Boolean, True if reset enabled, False if disabled \"\"\" if self.port_num <=48 or self.port_num >=57: return False val=self.__read_txt_file( self.cpld_path +\"module_reset_\" +str(self.port_num)) return int(val, 10)==1 def get_rx_los(self): \"\"\" Retrieves the RX LOS(lost-of-signal) status of SFP Returns: A Boolean, True if SFP has RX LOS, False if not. Note: RX LOS status is latched until a call to get_rx_los or a reset. \"\"\" if self.port_num <=48 or self.port_num >=57: rx_los=self.__read_txt_file( self.cpld_path +\"module_rx_los_\" +str(self.port_num)) if int(rx_los, 10)==1: return[True] else: return[False] else: rx_los_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence( ) else None if dom_channel_monitor_raw is not None: rx_los_data=int(dom_channel_monitor_raw[0], 16) rx_los_list.append(rx_los_data & 0x01 !=0) rx_los_list.append(rx_los_data & 0x02 !=0) rx_los_list.append(rx_los_data & 0x04 !=0) rx_los_list.append(rx_los_data & 0x08 !=0) return rx_los_list else: return[False]*4 def get_tx_fault(self): \"\"\" Retrieves the TX fault status of SFP Returns: A list of boolean values, representing the TX fault status of each available channel, value is True if SFP channel has TX fault, False if not. E.g., for a tranceiver with four channels:[False, False, True, False] Note: TX fault status is lached until a call to get_tx_fault or a reset. \"\"\" tx_fault=False if self.port_num <=48 or self.port_num >=57: tx_fault=self.__read_txt_file( self.cpld_path +\"module_tx_fault_\" +str(self.port_num)) if int(tx_fault, 10)==1: return[True] else: return[False] else: tx_fault_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence( ) else None if dom_channel_monitor_raw is not None: tx_fault_data=int(dom_channel_monitor_raw[0], 16) tx_fault_list.append(tx_fault_data & 0x01 !=0) tx_fault_list.append(tx_fault_data & 0x02 !=0) tx_fault_list.append(tx_fault_data & 0x04 !=0) tx_fault_list.append(tx_fault_data & 0x08 !=0) return tx_fault_list else: return[False]*4 def get_tx_disable(self): \"\"\" Retrieves the tx_disable status of this SFP Returns: A list of boolean values, representing the TX disable status of each available channel, value is True if SFP channel is TX disabled, False if not. E.g., for a tranceiver with four channels:[False, False, True, False] \"\"\" if self.port_num <=48 or self.port_num >=57: tx_disable=False status_control_raw=self.__read_eeprom_specific_bytes( SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH) if status_control_raw: cpld_val=self.__read_txt_file( self.cpld_path +\"module_tx_disable_\" +str(self.port_num)) tx_disable_hard=(int(cpld_val, 10)==1) data=int(status_control_raw[0], 16) tx_disable_soft=(sffbase().test_bit( data, SFP_TX_DISABLE_SOFT_BIT) !=0) tx_disable=tx_disable_hard | tx_disable_soft if tx_disable==0: return[False] else: return[True] else: return[False] else: tx_disable_list=[] sfpd_obj=sff8436Dom() if sfpd_obj is None: return[False] dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes( dom_control_raw, 0) tx_disable_list.append( 'On'==dom_control_data['data']['TX1Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX2Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX3Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX4Disable']['value']) return tx_disable_list else: return[False]*4 def get_tx_disable_channel(self): \"\"\" Retrieves the TX disabled channels in this SFP Returns: A hex of 4 bits(bit 0 to bit 3 as channel 0 to channel 3) to represent TX channels which have been disabled in this SFP. As an example, a returned value of 0x5 indicates that channel 0 and channel 2 have been disabled. \"\"\" tx_disable_list=self.get_tx_disable() if tx_disable_list is None: return 0 tx_disabled=0 for i in range(len(tx_disable_list)): if tx_disable_list[i]: tx_disabled |=1 << i return tx_disabled def get_lpmode(self): \"\"\" Retrieves the lpmode(low power mode) status of this SFP Returns: A Boolean, True if lpmode is enabled, False if disabled \"\"\" if self.port_num <=48 or self.port_num >=57: return False power_set=self.get_power_set() power_override=self.get_power_override() return power_set and power_override def get_power_set(self): if self.port_num <=48 or self.port_num >=57: return False else: power_set=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes( dom_control_raw, 0) power_set=( 'On'==dom_control_data['data']['PowerSet']['value']) return power_set def get_power_override(self): \"\"\" Retrieves the power-override status of this SFP Returns: A Boolean, True if power-override is enabled, False if disabled \"\"\" if self.port_num <=48 or self.port_num >=57: return False else: power_override=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes( dom_control_raw, 0) power_override=( 'On'==dom_control_data['data']['PowerOverride']['value']) return power_override def reset(self): \"\"\" Reset SFP and return all user module settings to their default srate. Returns: A boolean, True if successful, False if not \"\"\" if self.port_num <=48 or self.port_num >=57: return False ret=self.__write_txt_file( self.cpld_path +\"module_reset_\" +str(self.port_num), 1) if ret is not True: return ret time.sleep(0.01) ret=self.__write_txt_file( self.cpld_path +\"module_reset_\" +str(self.port_num), 0) time.sleep(0.2) return ret def tx_disable(self, tx_disable): \"\"\" Disable SFP TX for all channels Args: tx_disable: A Boolean, True to enable tx_disable mode, False to disable tx_disable mode. Returns: A boolean, True if tx_disable is set successfully, False if not \"\"\" if self.port_num <=48 or self.port_num >=57: ret=self.__write_txt_file( self.cpld_path +\"module_tx_disable_\" +str(self.port_num), 1 if tx_disable else 0) time.sleep(0.01) return ret else: if not self.get_presence(): return False sysfsfile_eeprom=None try: tx_disable_ctl=0xf if tx_disable else 0x0 buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=tx_disable_ctl else: buffer[0]=chr(tx_disable_ctl) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def tx_disable_channel(self, channel, disable): \"\"\" Sets the tx_disable for specified SFP channels Args: channel: A hex of 4 bits(bit 0 to bit 3) which represent channel 0 to 3, e.g. 0x5 for channel 0 and channel 2. disable: A boolean, True to disable TX channels specified in channel, False to enable Returns: A boolean, True if successful, False if not \"\"\" if self.port_num <=48 or self.port_num >=57: return False else: if not self.get_presence(): return False sysfsfile_eeprom=None try: channel_state=self.get_tx_disable_channel() for i in range(4): channel_mask=(1 << i) if not(channel & channel_mask): continue if disable: channel_state |=channel_mask else: channel_state &=~channel_mask buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=channel_state else: buffer[0]=chr(channel_state) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def set_lpmode(self, lpmode): \"\"\" Sets the lpmode(low power mode) of SFP Args: lpmode: A Boolean, True to enable lpmode, False to disable it Note : lpmode can be overridden by set_power_override Returns: A boolean, True if lpmode is set successfully, False if not \"\"\" if self.port_num <=48 or self.port_num >=57: return False if lpmode: return self.set_power_override(True, True) else: return self.set_power_override(True, False) def set_power_override(self, power_override, power_set): \"\"\" Sets SFP power level using power_override and power_set Args: power_override: A Boolean, True to override set_lpmode and use power_set to control SFP power, False to disable SFP power control through power_override/power_set and use set_lpmode to control SFP power. power_set: Only valid when power_override is True. A Boolean, True to set SFP to low power mode, False to set SFP to high power mode. Returns: A boolean, True if power-override and power_set are set successfully, False if not \"\"\" if self.port_num <=48 or self.port_num >=57: return False else: if not self.get_presence(): return False try: power_override_bit=(1 << 0) if power_override else 0 power_set_bit=(1 << 1) if power_set else(1 << 3) buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=(power_override_bit | power_set_bit) else: buffer[0]=chr(power_override_bit | power_set_bit) with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd: fd.seek(QSFP_POWEROVERRIDE_OFFSET) fd.write(buffer[0]) time.sleep(0.01) except Exception: print(\"Error: unable to open file: %s\" % str(e)) return False return True def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" sfputil_helper=SfpUtilHelper() sfputil_helper.read_porttab_mappings( self.__get_path_to_port_config_file()) name=sfputil_helper.logical[self.index] or \"Unknown\" return name def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" val=self.__read_txt_file( self.cpld_path +\"module_present_\" +str(self.port_num)) return val=='1' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return self.get_presence() def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return self.port_num def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return True ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Sfp contains an implementation of SONiC Platform Base API and\n# provides the sfp device status which are available in the platform\n#\n#############################################################################\n\nimport os\nimport time\nimport sys\n\nfrom ctypes import create_string_buffer\n\ntry:\n    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase\n    from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    0: {\n        \"bus\": 18,\n        \"addr\": \"60\"\n    },  # port 31-56\n    1: {\n        \"bus\": 12,\n        \"addr\": \"62\"\n    },  # port  1-30\n}\nCPLD_I2C_PATH = \"/sys/bus/i2c/devices/{}-00{}/\"\n\nclass Sfp(SfpOptoeBase):\n    \"\"\"Platform-specific Sfp class\"\"\"\n\n    # Port number\n    PORT_START = 1\n    PORT_END = 58\n\n    # Path to sysfs\n    PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n    PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n\n    PLATFORM = \"x86_64-accton_as7326_56x-r0\"\n    HWSKU = \"Accton-AS7326-56X\"\n\n    _port_to_i2c_mapping = {\n        1: [42],\n        2: [41],\n        3: [44],\n        4: [43],\n        5: [47],\n        6: [45],\n        7: [46],\n        8: [50],\n        9: [48],\n        10: [49],\n        11: [52],\n        12: [51],\n        13: [53],\n        14: [56],\n        15: [55],\n        16: [54],\n        17: [58],\n        18: [57],\n        19: [60],\n        20: [59],\n        21: [61],\n        22: [63],\n        23: [62],\n        24: [64],\n        25: [66],\n        26: [68],\n        27: [65],\n        28: [67],\n        29: [69],\n        30: [71],\n        31: [72],\n        32: [70],\n        33: [74],\n        34: [73],\n        35: [76],\n        36: [75],\n        37: [77],\n        38: [79],\n        39: [78],\n        40: [80],\n        41: [81],\n        42: [82],\n        43: [84],\n        44: [85],\n        45: [83],\n        46: [87],\n        47: [88],\n        48: [86],\n        49: [25],\n        50: [26],\n        51: [27],\n        52: [28],\n        53: [29],\n        54: [30],\n        55: [31],\n        56: [32],\n        57: [22],\n        58: [23]\n    }\n\n    def __init__(self, sfp_index=0):\n        SfpOptoeBase.__init__(self)\n        # Init index\n        self.index = sfp_index\n        self.port_num = self.index + 1\n\n        cpld_idx = 0 if self.port_num > 30 else 1\n        bus = CPLD_ADDR_MAPPING[cpld_idx][\"bus\"]\n        addr = CPLD_ADDR_MAPPING[cpld_idx][\"addr\"]\n        self.cpld_path = CPLD_I2C_PATH.format(bus, addr)\n\n        # Init eeprom path\n        eeprom_path = '/sys/bus/i2c/devices/{0}-0050/eeprom'\n        self.port_to_eeprom_mapping = {}\n        for x in range(self.PORT_START, self.PORT_END + 1):\n            self.port_to_eeprom_mapping[x] = eeprom_path.format(\n                self._port_to_i2c_mapping[x][0])\n\n    def get_eeprom_path(self):\n        return self.port_to_eeprom_mapping[self.port_num]\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                return fd.read().strip()\n        except IOError:\n            pass\n        return \"\"\n\n    def __write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except Exception:\n            return False\n        return True\n\n    def __is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def __get_path_to_port_config_file(self):\n        platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n        hwsku_path = \"/\".join(\n            [platform_path,\n             self.HWSKU]) if self.__is_host() else self.PMON_HWSKU_PATH\n        return \"/\".join([hwsku_path, \"port_config.ini\"])\n\n    def __read_eeprom_specific_bytes(self, offset, num_bytes):\n        sysfsfile_eeprom = None\n        eeprom_raw = []\n        for i in range(0, num_bytes):\n            eeprom_raw.append(\"0x00\")\n\n        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[\n            self.port_num]\n        try:\n            sysfsfile_eeprom = open(\n                sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0)\n            sysfsfile_eeprom.seek(offset)\n            raw = sysfsfile_eeprom.read(num_bytes)\n            for n in range(0, num_bytes):\n                if sys.version_info[0] >= 3:\n                    eeprom_raw[n] = hex(raw[n])[2:].zfill(2)\n                else:\n                    eeprom_raw[n] = hex(ord(raw[n]))[2:].zfill(2)\n        except Exception:\n            pass\n        finally:\n            if sysfsfile_eeprom:\n                sysfsfile_eeprom.close()\n\n        return eeprom_raw\n\n    def get_reset_status(self):\n        \"\"\"\n        Retrieves the reset status of SFP\n        Returns:\n            A Boolean, True if reset enabled, False if disabled\n        \"\"\"\n        if self.port_num <= 48  or self.port_num >=57:\n            return False  # SPF port doesn't support this feature\n\n        val = self.__read_txt_file(\n            self.cpld_path + \"module_reset_\" + str(self.port_num))\n        return int(val, 10) == 1\n\n    def get_rx_los(self):\n        \"\"\"\n        Retrieves the RX LOS (lost-of-signal) status of SFP\n        Returns:\n            A Boolean, True if SFP has RX LOS, False if not.\n            Note : RX LOS status is latched until a call to get_rx_los or a reset.\n        \"\"\"\n        if self.port_num <= 48  or self.port_num >=57:\n            rx_los = self.__read_txt_file(\n                self.cpld_path + \"module_rx_los_\" + str(self.port_num))\n            if int(rx_los, 10) == 1:\n                return [True]\n            else:\n                return [False]\n            #status_control_raw = self.__read_eeprom_specific_bytes(\n            #    SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            #if status_control_raw:\n            #    data = int(status_control_raw[0], 16)\n            #    rx_los = (sffbase().test_bit(data, 1) != 0)\n        else:\n            rx_los_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_RX_LOS_STATUS_OFFSET,\n                QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence(\n                ) else None\n            if dom_channel_monitor_raw is not None:\n                rx_los_data = int(dom_channel_monitor_raw[0], 16)\n                rx_los_list.append(rx_los_data & 0x01 != 0)\n                rx_los_list.append(rx_los_data & 0x02 != 0)\n                rx_los_list.append(rx_los_data & 0x04 != 0)\n                rx_los_list.append(rx_los_data & 0x08 != 0)\n                return rx_los_list\n            else:\n                return [False]*4\n\n    def get_tx_fault(self):\n        \"\"\"\n        Retrieves the TX fault status of SFP\n        \n        Returns:\n            A list of boolean values, representing the TX fault status\n            of each available channel, value is True if SFP channel\n            has TX fault, False if not.\n            E.g., for a tranceiver with four channels: [False, False, True, False]\n            Note : TX fault status is lached until a call to get_tx_fault or a reset.\n        \"\"\"\n        tx_fault = False\n        if self.port_num <= 48  or self.port_num >=57:\n            tx_fault = self.__read_txt_file(\n                self.cpld_path + \"module_tx_fault_\" + str(self.port_num))\n            if int(tx_fault, 10) == 1:\n                return [True]\n            else:\n                return [False]\n            #status_control_raw = self.__read_eeprom_specific_bytes(\n            #    SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            #if status_control_raw:\n            #    data = int(status_control_raw[0], 16)\n            #    tx_fault = (sffbase().test_bit(data, 2) != 0)\n        else:\n            tx_fault_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_TX_FAULT_STATUS_OFFSET,\n                QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence(\n                ) else None\n            if dom_channel_monitor_raw is not None:\n                tx_fault_data = int(dom_channel_monitor_raw[0], 16)\n                tx_fault_list.append(tx_fault_data & 0x01 != 0)\n                tx_fault_list.append(tx_fault_data & 0x02 != 0)\n                tx_fault_list.append(tx_fault_data & 0x04 != 0)\n                tx_fault_list.append(tx_fault_data & 0x08 != 0)\n                return tx_fault_list\n            else:\n                return [False]*4\n\n\n    def get_tx_disable(self):\n        \"\"\"\n        Retrieves the tx_disable status of this SFP\n        Returns:\n            A list of boolean values, representing the TX disable status\n            of each available channel, value is True if SFP channel\n            is TX disabled, False if not.\n            E.g., for a tranceiver with four channels: [False, False, True, False]\n        \"\"\"\n        if self.port_num <= 48 or self.port_num >=57:\n            tx_disable = False\n\n            status_control_raw = self.__read_eeprom_specific_bytes(\n                SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            if status_control_raw:\n                cpld_val = self.__read_txt_file(\n                    self.cpld_path + \"module_tx_disable_\" + str(self.port_num))\n                tx_disable_hard = (int(cpld_val, 10) == 1)\n                data = int(status_control_raw[0], 16)\n                #tx_disable_hard = (sffbase().test_bit(\n                #    data, SFP_TX_DISABLE_HARD_BIT) != 0)\n                tx_disable_soft = (sffbase().test_bit(\n                    data, SFP_TX_DISABLE_SOFT_BIT) != 0)\n                tx_disable = tx_disable_hard | tx_disable_soft\n                if tx_disable==0:\n                    return [False]\n                else:\n                    return [True]\n                \n            else:\n                return [False]\n\n        else:\n            tx_disable_list = []\n\n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return [False]\n\n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET,\n                QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(\n                    dom_control_raw, 0)\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX1Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX2Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX3Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX4Disable']['value'])\n                return tx_disable_list\n            else:\n                return [False]*4\n\n    def get_tx_disable_channel(self):\n        \"\"\"\n        Retrieves the TX disabled channels in this SFP\n        Returns:\n            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent\n            TX channels which have been disabled in this SFP.\n            As an example, a returned value of 0x5 indicates that channel 0\n            and channel 2 have been disabled.\n        \"\"\"\n        tx_disable_list = self.get_tx_disable()\n        if tx_disable_list is None:\n            return 0\n        tx_disabled = 0\n        for i in range(len(tx_disable_list)):\n            if tx_disable_list[i]:\n                tx_disabled |= 1 << i\n        return tx_disabled\n\n    def get_lpmode(self):\n        \"\"\"\n        Retrieves the lpmode (low power mode) status of this SFP\n        Returns:\n            A Boolean, True if lpmode is enabled, False if disabled\n        \"\"\"\n        if self.port_num <= 48 or self.port_num >= 57:\n            # SFP doesn't support this feature\n            return False\n\n        power_set = self.get_power_set()\n        power_override = self.get_power_override()\n        return power_set and power_override\n\n    def get_power_set(self):\n\n        if self.port_num <= 48 or self.port_num >= 57:\n            # SFP doesn't support this feature\n            return False\n        else:\n            power_set = False\n\n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n\n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET,\n                QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(\n                    dom_control_raw, 0)\n                power_set = (\n                    'On' == dom_control_data['data']['PowerSet']['value'])\n\n            return power_set\n\n    def get_power_override(self):\n        \"\"\"\n        Retrieves the power-override status of this SFP\n        Returns:\n            A Boolean, True if power-override is enabled, False if disabled\n        \"\"\"\n        if self.port_num <= 48 or self.port_num >= 57:\n            return False  # SFP doesn't support this feature\n        else:\n            power_override = False\n\n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n\n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET,\n                QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(\n                    dom_control_raw, 0)\n                power_override = (\n                    'On' == dom_control_data['data']['PowerOverride']['value'])\n\n            return power_override\n\n    def reset(self):\n        \"\"\"\n        Reset SFP and return all user module settings to their default srate.\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        # Check for invalid port_num\n        if self.port_num <= 48  or self.port_num >=57:\n            return False  # SFP doesn't support this feature\n\n        ret = self.__write_txt_file(\n            self.cpld_path + \"module_reset_\" + str(self.port_num), 1)\n        if ret is not True:\n            return ret\n\n        time.sleep(0.01)\n        ret = self.__write_txt_file(\n            self.cpld_path + \"module_reset_\" + str(self.port_num), 0)\n        time.sleep(0.2)\n        return ret\n\n    def tx_disable(self, tx_disable):\n        \"\"\"\n        Disable SFP TX for all channels\n        Args:\n            tx_disable : A Boolean, True to enable tx_disable mode, False to disable\n                         tx_disable mode.\n        Returns:\n            A boolean, True if tx_disable is set successfully, False if not\n        \"\"\"\n        if self.port_num <= 48  or self.port_num >=57:\n            ret = self.__write_txt_file(\n                self.cpld_path + \"module_tx_disable_\" + str(self.port_num), 1\n                if tx_disable else 0)\n            time.sleep(0.01)\n            return ret\n        else:\n            if not self.get_presence():\n                return False\n\n            sysfsfile_eeprom = None\n            try:\n                tx_disable_ctl = 0xf if tx_disable else 0x0\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = tx_disable_ctl\n                else:\n                    buffer[0] = chr(tx_disable_ctl)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print(\"Error: unable to open file: %s\" % str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n        return True\n\n    def tx_disable_channel(self, channel, disable):\n        \"\"\"\n        Sets the tx_disable for specified SFP channels\n        Args:\n            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,\n                      e.g. 0x5 for channel 0 and channel 2.\n            disable : A boolean, True to disable TX channels specified in channel,\n                      False to enable\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n\n        if self.port_num <= 48  or self.port_num >=57:\n            return False  # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n\n            sysfsfile_eeprom = None\n            try:\n                channel_state = self.get_tx_disable_channel()\n\n                for i in range(4):\n                    channel_mask = (1 << i)\n                    if not (channel & channel_mask):\n                        continue\n\n                    if disable:\n                        channel_state |= channel_mask\n                    else:\n                        channel_state &= ~channel_mask\n\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = channel_state\n                else:\n                    buffer[0] = chr(channel_state)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print(\"Error: unable to open file: %s\" % str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n            return True\n\n    def set_lpmode(self, lpmode):\n        \"\"\"\n        Sets the lpmode (low power mode) of SFP\n        Args:\n            lpmode: A Boolean, True to enable lpmode, False to disable it\n            Note  : lpmode can be overridden by set_power_override\n        Returns:\n            A boolean, True if lpmode is set successfully, False if not\n        \"\"\"\n        if self.port_num <= 48  or self.port_num >=57:\n            return False  # SFP doesn't support this feature\n\n        if lpmode:\n            return self.set_power_override(True, True)\n        else:\n            return self.set_power_override(True, False)\n\n    def set_power_override(self, power_override, power_set):\n        \"\"\"\n        Sets SFP power level using power_override and power_set\n        Args:\n            power_override :\n                    A Boolean, True to override set_lpmode and use power_set\n                    to control SFP power, False to disable SFP power control\n                    through power_override/power_set and use set_lpmode\n                    to control SFP power.\n            power_set :\n                    Only valid when power_override is True.\n                    A Boolean, True to set SFP to low power mode, False to set\n                    SFP to high power mode.\n        Returns:\n            A boolean, True if power-override and power_set are set successfully,\n            False if not\n        \"\"\"\n        if self.port_num <= 48  or self.port_num >=57:\n            return False  # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n            try:\n                power_override_bit = (1 << 0) if power_override else 0\n                power_set_bit = (1 << 1) if power_set else (1 << 3)\n\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = (power_override_bit | power_set_bit)\n                else:\n                    buffer[0] = chr(power_override_bit | power_set_bit)\n                # Write to eeprom\n                with open(self.port_to_eeprom_mapping[self.port_num],\n                          \"r+b\") as fd:\n                    fd.seek(QSFP_POWEROVERRIDE_OFFSET)\n                    fd.write(buffer[0])\n                    time.sleep(0.01)\n            except Exception:\n                print(\"Error: unable to open file: %s\" % str(e))\n                return False\n            return True\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        sfputil_helper = SfpUtilHelper()\n        sfputil_helper.read_porttab_mappings(\n            self.__get_path_to_port_config_file())\n        name = sfputil_helper.logical[self.index] or \"Unknown\"\n        return name\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        val = self.__read_txt_file(\n            self.cpld_path + \"module_present_\" + str(self.port_num))\n        return val == '1'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return self.get_presence()\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return self.port_num\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return True\n"}, "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE = \"/sys/class/leds/as7816_64x_led::diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n     \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os import sys try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper from.event import SfpEvent except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=4 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=6 NUM_PORT=64 NUM_COMPONENT=5 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" SYSLED_FNODE=\"/sys/class/leds/as7816_64x_led::diag/brightness\" SYSLED_MODES={ \"0\": \"STATUS_LED_COLOR_OFF\", \"16\": \"STATUS_LED_COLOR_GREEN\", \"10\": \"STATUS_LED_COLOR_RED\" } class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(0, NUM_PORT): sfp=Sfp(index) self._sfp_list.append(sfp) self._sfpevent=SfpEvent(self._sfp_list) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for fant_index in range(NUM_FAN_TRAY): fandrawer=FanDrawer(fant_index) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._eeprom.get_product_name() def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_change_event(self, timeout=0): if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfpevent.get_sfp_event(timeout) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def initizalize_system_led(self): return True def get_status_led(self): val=self._api_helper.read_txt_file(SYSLED_FNODE) return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\" def set_status_led(self, color): mode=None for key, val in SYSLED_MODES.items(): if val==color: mode=key break if mode is None: return False else: return self._api_helper.write_txt_file(SYSLED_FNODE, mode) ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\nimport sys\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\n    from .event import SfpEvent\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 4\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 6\nNUM_PORT = 64\nNUM_COMPONENT = 5\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\nSYSLED_FNODE = \"/sys/class/leds/as7816_64x_led::diag/brightness\"\nSYSLED_MODES = {\n    \"0\" : \"STATUS_LED_COLOR_OFF\",\n    \"16\" : \"STATUS_LED_COLOR_GREEN\",\n    \"10\" : \"STATUS_LED_COLOR_RED\"\n\n}\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n        \n        self.config_data = {}\n\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n\n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(0, NUM_PORT):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self._sfpevent = SfpEvent(self._sfp_list)\n        self.sfp_module_initialized = True\n\n    def __initialize_fan(self):\n        from sonic_platform.fan_drawer import FanDrawer\n        for fant_index in range(NUM_FAN_TRAY):\n            fandrawer = FanDrawer(fant_index)\n            self._fan_drawer_list.append(fandrawer)\n            self._fan_list.extend(fandrawer._fan_list)\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n    \n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return self._eeprom.get_product_name()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n    \n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n    \n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n        \n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n      \n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n\n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_change_event(self, timeout=0):\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n        return self._sfpevent.get_sfp_event(timeout)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n        \n    def initizalize_system_led(self):\n        return True\n\n    def get_status_led(self):\n        val = self._api_helper.read_txt_file(SYSLED_FNODE)\n        return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\"\n\n    def set_status_led(self, color):\n        mode = None\n        for key, val in SYSLED_MODES.items():\n            if val == color:\n                mode = key\n                break\n        if mode is None:\n            return False\n        else:\n            return self._api_helper.write_txt_file(SYSLED_FNODE, mode)\n"}, "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 2, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware", "add": 0, "remove": 16, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"19-0060\", \"CPLD2\": \"20-0062\", \"CPLD3\": \"21-0064\", \"CPLD4\": \"22-0066\", } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"CPLD2\", \"CPLD 2\"), (\"CPLD3\", \"CPLD 3\"), (\"CPLD4\", \"CPLD 4\"), (\"BIOS\", \"Basic Input/Output System\") ] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return 'N/A' def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return 'N/A' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is'0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"19-0060\",\n    \"CPLD2\": \"20-0062\",\n    \"CPLD3\": \"21-0064\",\n    \"CPLD4\": \"22-0066\",\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"CPLD2\", \"CPLD 2\"),\n   (\"CPLD3\", \"CPLD 3\"),\n   (\"CPLD4\", \"CPLD 4\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n   \n]\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)\n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n        \n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of\n        entPhysicalContainedIn is'0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device\n            or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-      ", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False"], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r', errors='replace') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r', errors='replace') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as7816_64x-r0\"\n     HWSKU = \"Accton-AS7816-64X\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n         return self.port_to_eeprom_mapping[self.port_num]\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_RO", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}], "source": "\n import os import time import sys from ctypes import create_string_buffer try: from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_I2C_PATH=\"/sys/bus/i2c/devices/19-0060/\" class Sfp(SfpOptoeBase): \"\"\"Platform-specific Sfp class\"\"\" PORT_START=1 PORT_END=64 PLATFORM_ROOT_PATH=\"/usr/share/sonic/device\" PMON_HWSKU_PATH=\"/usr/share/sonic/hwsku\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" PLATFORM=\"x86_64-accton_as7816_64x-r0\" HWSKU=\"Accton-AS7816-64X\" _port_to_i2c_mapping={ 61: 25, 62: 26, 63: 27, 64: 28, 55: 29, 56: 30, 53: 31, 54: 32, 9: 33, 10: 34, 11: 35, 12: 36, 1: 37, 2: 38, 3: 39, 4: 40, 6: 41, 5: 42, 8: 43, 7: 44, 13: 45, 14: 46, 15: 47, 16: 48, 17: 49, 18: 50, 19: 51, 20: 52, 25: 53, 26: 54, 27: 55, 28: 56, 29: 57, 30: 58, 31: 59, 32: 60, 21: 61, 22: 62, 23: 63, 24: 64, 41: 65, 42: 66, 43: 67, 44: 68, 33: 69, 34: 70, 35: 71, 36: 72, 45: 73, 46: 74, 47: 75, 48: 76, 37: 77, 38: 78, 39: 79, 40: 80, 57: 81, 58: 82, 59: 83, 60: 84, 49: 85, 50: 86, 51: 87, 52: 88 } def __init__(self, sfp_index=0): SfpOptoeBase.__init__(self) self._api_helper=APIHelper() self.index=sfp_index self.port_num=self.index +1 eeprom_path='/sys/bus/i2c/devices/{0}-0050/eeprom' self.port_to_eeprom_mapping={} for x in range(self.PORT_START, self.PORT_END +1): self.port_to_eeprom_mapping[x]=eeprom_path.format(self._port_to_i2c_mapping[x]) def get_eeprom_path(self): return self.port_to_eeprom_mapping[self.port_num] def __is_host(self): return os.system(self.HOST_CHK_CMD)==0 def __get_path_to_port_config_file(self): platform_path=\"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM]) hwsku_path=\"/\".join([platform_path, self.HWSKU] ) if self.__is_host() else self.PMON_HWSKU_PATH return \"/\".join([hwsku_path, \"port_config.ini\"]) def __read_eeprom_specific_bytes(self, offset, num_bytes): sysfsfile_eeprom=None eeprom_raw=[] for i in range(0, num_bytes): eeprom_raw.append(\"0x00\") sysfs_sfp_i2c_client_eeprom_path=self.port_to_eeprom_mapping[self.port_num] try: sysfsfile_eeprom=open( sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0) sysfsfile_eeprom.seek(offset) raw=sysfsfile_eeprom.read(num_bytes) if sys.version_info[0] >=3: for n in range(0, num_bytes): eeprom_raw[n]=hex(raw[n])[2:].zfill(2) else: for n in range(0, num_bytes): eeprom_raw[n]=hex(ord(raw[n]))[2:].zfill(2) except Exception: pass finally: if sysfsfile_eeprom: sysfsfile_eeprom.close() return eeprom_raw def get_reset_status(self): \"\"\" Retrieves the reset status of SFP Returns: A Boolean, True if reset enabled, False if disabled \"\"\" reset_path=\"{}{}{}\".format(CPLD_I2C_PATH, \"module_reset_\", str(self.port_num)) val=self._api_helper.read_txt_file(reset_path) if val is not None: return int(val, 10)==1 else: return False def get_rx_los(self): \"\"\" Retrieves the RX LOS(lost-of-signal) status of SFP Returns: A Boolean, True if SFP has RX LOS, False if not. Note: RX LOS status is latched until a call to get_rx_los or a reset. \"\"\" rx_los_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: rx_los_data=int(dom_channel_monitor_raw[0], 16) rx_los_list.append(rx_los_data & 0x01 !=0) rx_los_list.append(rx_los_data & 0x02 !=0) rx_los_list.append(rx_los_data & 0x04 !=0) rx_los_list.append(rx_los_data & 0x08 !=0) return rx_los_list else: return[False]*4 def get_tx_fault(self): \"\"\" Retrieves the TX fault status of SFP Returns: A Boolean, True if SFP has TX fault, False if not Note: TX fault status is lached until a call to get_tx_fault or a reset. \"\"\" tx_fault_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: tx_fault_data=int(dom_channel_monitor_raw[0], 16) tx_fault_list.append(tx_fault_data & 0x01 !=0) tx_fault_list.append(tx_fault_data & 0x02 !=0) tx_fault_list.append(tx_fault_data & 0x04 !=0) tx_fault_list.append(tx_fault_data & 0x08 !=0) return tx_fault_list else: return[False]*4 def get_tx_disable(self): \"\"\" Retrieves the tx_disable status of this SFP Returns: A Boolean, True if tx_disable is enabled, False if disabled \"\"\" tx_disable_list=[] sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) tx_disable_list.append( 'On'==dom_control_data['data']['TX1Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX2Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX3Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX4Disable']['value']) return tx_disable_list else: return[False]*4 def get_tx_disable_channel(self): \"\"\" Retrieves the TX disabled channels in this SFP Returns: A hex of 4 bits(bit 0 to bit 3 as channel 0 to channel 3) to represent TX channels which have been disabled in this SFP. As an example, a returned value of 0x5 indicates that channel 0 and channel 2 have been disabled. \"\"\" tx_disable_list=self.get_tx_disable() if tx_disable_list is None: return 0 tx_disabled=0 for i in range(len(tx_disable_list)): if tx_disable_list[i]: tx_disabled |=1 << i return tx_disabled def get_lpmode(self): \"\"\" Retrieves the lpmode(low power mode) status of this SFP Returns: A Boolean, True if lpmode is enabled, False if disabled \"\"\" power_set=self.get_power_set() power_override=self.get_power_override() return power_set and power_override def get_power_set(self): power_set=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) power_set=( 'On'==dom_control_data['data']['PowerSet']['value']) return power_set def get_power_override(self): \"\"\" Retrieves the power-override status of this SFP Returns: A Boolean, True if power-override is enabled, False if disabled \"\"\" power_override=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) power_override=( 'On'==dom_control_data['data']['PowerOverride']['value']) return power_override def reset(self): \"\"\" Reset SFP and return all user module settings to their default srate. Returns: A boolean, True if successful, False if not \"\"\" reset_path=\"{}{}{}\".format(CPLD_I2C_PATH, 'module_reset_', self.port_num) ret=self._api_helper.write_txt_file(reset_path, 1) if ret is not True: return ret time.sleep(0.01) ret=self._api_helper.write_txt_file(reset_path, 0) time.sleep(0.2) return ret def tx_disable(self, tx_disable): \"\"\" Disable SFP TX for all channels Args: tx_disable: A Boolean, True to enable tx_disable mode, False to disable tx_disable mode. Returns: A boolean, True if tx_disable is set successfully, False if not \"\"\" if not self.get_presence(): return False sysfsfile_eeprom=None try: tx_disable_ctl=0xf if tx_disable else 0x0 buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=tx_disable_ctl else: buffer[0]=chr(tx_disable_ctl) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ',str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def tx_disable_channel(self, channel, disable): \"\"\" Sets the tx_disable for specified SFP channels Args: channel: A hex of 4 bits(bit 0 to bit 3) which represent channel 0 to 3, e.g. 0x5 for channel 0 and channel 2. disable: A boolean, True to disable TX channels specified in channel, False to enable Returns: A boolean, True if successful, False if not \"\"\" if not self.get_presence(): return False sysfsfile_eeprom=None try: channel_state=self.get_tx_disable_channel() for i in range(4): channel_mask=(1 << i) if not(channel & channel_mask): continue if disable: channel_state |=channel_mask else: channel_state &=~channel_mask buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=channel_state else: buffer[0]=chr(channel_state) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ', str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def set_lpmode(self, lpmode): \"\"\" Sets the lpmode(low power mode) of SFP Args: lpmode: A Boolean, True to enable lpmode, False to disable it Note : lpmode can be overridden by set_power_override Returns: A boolean, True if lpmode is set successfully, False if not \"\"\" if lpmode: self.set_power_override(True, True) else: self.set_power_override(False, False) return True def set_power_override(self, power_override, power_set): \"\"\" Sets SFP power level using power_override and power_set Args: power_override: A Boolean, True to override set_lpmode and use power_set to control SFP power, False to disable SFP power control through power_override/power_set and use set_lpmode to control SFP power. power_set: Only valid when power_override is True. A Boolean, True to set SFP to low power mode, False to set SFP to high power mode. Returns: A boolean, True if power-override and power_set are set successfully, False if not \"\"\" if not self.get_presence(): return False try: power_override_bit=(1 << 0) if power_override else 0 power_set_bit =(1 << 1) if power_set else(1 << 3) buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=(power_override_bit | power_set_bit) else: buffer[0]=chr(power_override_bit | power_set_bit) with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd: fd.seek(QSFP_POWEROVERRIDE_OFFSET) fd.write(buffer[0]) time.sleep(0.01) except Exception: print('Error: unable to open file: ', str(e)) return False return True def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" sfputil_helper=SfpUtilHelper() sfputil_helper.read_porttab_mappings( self.__get_path_to_port_config_file()) name=sfputil_helper.logical[self.index] or \"Unknown\" return name def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" present_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_present_', self.port_num) val=self._api_helper.read_txt_file(present_path) if val is not None: return int(val, 10)==1 else: return False def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return self.get_presence() def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return self.port_num def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return True ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Sfp contains an implementation of SONiC Platform Base API and\n# provides the sfp device status which are available in the platform\n#\n#############################################################################\n\nimport os\nimport time\nimport sys\n\nfrom ctypes import create_string_buffer\n\ntry:\n    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_I2C_PATH = \"/sys/bus/i2c/devices/19-0060/\"\n\n\nclass Sfp(SfpOptoeBase):\n    \"\"\"Platform-specific Sfp class\"\"\"\n\n    # Port number\n    PORT_START = 1\n    PORT_END = 64\n\n    # Path to sysfs\n    PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n    PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n        \n    PLATFORM = \"x86_64-accton_as7816_64x-r0\"\n    HWSKU = \"Accton-AS7816-64X\"\n\n    _port_to_i2c_mapping = {\n        61: 25,\n        62: 26,\n        63: 27,\n        64: 28,\n        55: 29,\n        56: 30,\n        53: 31,\n        54: 32,\n        9:  33,\n        10: 34,\n        11: 35,\n        12: 36,\n        1:  37,\n        2:  38,\n        3:  39,\n        4:  40,\n        6:  41,\n        5:  42,\n        8:  43,\n        7:  44,\n        13: 45,\n        14: 46,\n        15: 47,\n        16: 48,\n        17: 49,\n        18: 50,\n        19: 51,\n        20: 52,\n        25: 53,\n        26: 54,\n        27: 55,\n        28: 56,\n        29: 57,\n        30: 58,\n        31: 59,\n        32: 60,\n        21: 61,\n        22: 62,\n        23: 63,\n        24: 64,\n        41: 65,\n        42: 66,\n        43: 67,\n        44: 68,\n        33: 69,\n        34: 70,\n        35: 71,\n        36: 72,\n        45: 73,\n        46: 74,\n        47: 75,\n        48: 76,\n        37: 77,\n        38: 78,\n        39: 79,\n        40: 80,\n        57: 81,\n        58: 82,\n        59: 83,\n        60: 84,\n        49: 85,\n        50: 86,\n        51: 87,\n        52: 88 \n    }\n\n    def __init__(self, sfp_index=0):\n        SfpOptoeBase.__init__(self)\n        self._api_helper=APIHelper()\n        # Init index\n        self.index = sfp_index\n        self.port_num = self.index + 1\n        # Init eeprom path\n        eeprom_path = '/sys/bus/i2c/devices/{0}-0050/eeprom'\n        self.port_to_eeprom_mapping = {}\n        for x in range(self.PORT_START, self.PORT_END + 1):\n            self.port_to_eeprom_mapping[x] = eeprom_path.format(self._port_to_i2c_mapping[x])\n        \n    def get_eeprom_path(self):\n        return self.port_to_eeprom_mapping[self.port_num]\n\n    def __is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def __get_path_to_port_config_file(self):\n        platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n        hwsku_path = \"/\".join([platform_path, self.HWSKU]\n                              ) if self.__is_host() else self.PMON_HWSKU_PATH\n        return \"/\".join([hwsku_path, \"port_config.ini\"])\n\n    def __read_eeprom_specific_bytes(self, offset, num_bytes):\n        sysfsfile_eeprom = None\n        eeprom_raw = []\n        for i in range(0, num_bytes):\n            eeprom_raw.append(\"0x00\")\n\n        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]\n        try:\n            sysfsfile_eeprom = open(\n                sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0)\n            sysfsfile_eeprom.seek(offset)\n            raw = sysfsfile_eeprom.read(num_bytes)\n            if sys.version_info[0] >= 3:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(raw[n])[2:].zfill(2)\n            else:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(ord(raw[n]))[2:].zfill(2)\n        except Exception:\n            pass\n        finally:\n            if sysfsfile_eeprom:\n                sysfsfile_eeprom.close()\n\n        return eeprom_raw\n\n    def get_reset_status(self):\n        \"\"\"\n        Retrieves the reset status of SFP\n        Returns:\n            A Boolean, True if reset enabled, False if disabled\n        \"\"\"\n        reset_path=\"{}{}{}\".format(CPLD_I2C_PATH , \"module_reset_\" , str(self.port_num))\n        val = self._api_helper.read_txt_file(reset_path)\n        \n        if val is not None:\n            return int(val, 10) == 1\n        else:\n            return False\n\n    def get_rx_los(self):\n        \"\"\"\n        Retrieves the RX LOS (lost-of-signal) status of SFP\n        Returns:\n            A Boolean, True if SFP has RX LOS, False if not.\n            Note : RX LOS status is latched until a call to get_rx_los or a reset.\n        \"\"\"\n\n        rx_los_list = []\n        dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None\n        if dom_channel_monitor_raw is not None:\n                rx_los_data = int(dom_channel_monitor_raw[0], 16)\n                rx_los_list.append(rx_los_data & 0x01 != 0)\n                rx_los_list.append(rx_los_data & 0x02 != 0)\n                rx_los_list.append(rx_los_data & 0x04 != 0)\n                rx_los_list.append(rx_los_data & 0x08 != 0)\n                return rx_los_list\n        else:\n            return [False]*4\n\n\n    def get_tx_fault(self):\n        \"\"\"\n        Retrieves the TX fault status of SFP\n        Returns:\n            A Boolean, True if SFP has TX fault, False if not\n            Note : TX fault status is lached until a call to get_tx_fault or a reset.\n        \"\"\"\n        tx_fault_list = []\n        dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None\n        if dom_channel_monitor_raw is not None:\n            tx_fault_data = int(dom_channel_monitor_raw[0], 16)\n            tx_fault_list.append(tx_fault_data & 0x01 != 0)\n            tx_fault_list.append(tx_fault_data & 0x02 != 0)\n            tx_fault_list.append(tx_fault_data & 0x04 != 0)\n            tx_fault_list.append(tx_fault_data & 0x08 != 0)\n            return tx_fault_list\n        else:\n            return [False]*4\n\n    def get_tx_disable(self):\n        \"\"\"\n        Retrieves the tx_disable status of this SFP\n        Returns:\n            A Boolean, True if tx_disable is enabled, False if disabled\n        \"\"\"\n        \n        tx_disable_list = []\n    \n        sfpd_obj = sff8436Dom()\n        if sfpd_obj is None:\n            return False\n    \n        dom_control_raw = self.__read_eeprom_specific_bytes(\n            QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n        if dom_control_raw is not None:\n            dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n            tx_disable_list.append(\n                'On' == dom_control_data['data']['TX1Disable']['value'])\n            tx_disable_list.append(\n                'On' == dom_control_data['data']['TX2Disable']['value'])\n            tx_disable_list.append(\n                'On' == dom_control_data['data']['TX3Disable']['value'])\n            tx_disable_list.append(\n                'On' == dom_control_data['data']['TX4Disable']['value'])\n            return tx_disable_list\n        else:\n            return [False]*4\n\n    def get_tx_disable_channel(self):\n        \"\"\"\n        Retrieves the TX disabled channels in this SFP\n        Returns:\n            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent\n            TX channels which have been disabled in this SFP.\n            As an example, a returned value of 0x5 indicates that channel 0\n            and channel 2 have been disabled.\n        \"\"\"\n        tx_disable_list = self.get_tx_disable()\n        if tx_disable_list is None:\n            return 0\n        tx_disabled = 0\n        for i in range(len(tx_disable_list)):\n            if tx_disable_list[i]:\n                tx_disabled |= 1 << i\n        return tx_disabled\n\n    def get_lpmode(self):\n        \"\"\"\n        Retrieves the lpmode (low power mode) status of this SFP\n        Returns:\n            A Boolean, True if lpmode is enabled, False if disabled\n        \"\"\"\n\n        power_set=self.get_power_set()\n        power_override = self.get_power_override()\n        return power_set and power_override\n\n    def get_power_set(self):\n        power_set = False\n        sfpd_obj = sff8436Dom()\n        if sfpd_obj is None:\n            return False\n        dom_control_raw = self.__read_eeprom_specific_bytes(\n            QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n        if dom_control_raw is not None:\n            dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n            power_set = (\n                'On' == dom_control_data['data']['PowerSet']['value'])\n    \n        return power_set\n\n    def get_power_override(self):\n        \"\"\"\n        Retrieves the power-override status of this SFP\n        Returns:\n            A Boolean, True if power-override is enabled, False if disabled\n        \"\"\"\n        power_override = False\n        sfpd_obj = sff8436Dom()\n        if sfpd_obj is None:\n            return False\n\n        dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n        if dom_control_raw is not None:\n            dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n            power_override = (\n                'On' == dom_control_data['data']['PowerOverride']['value'])\n\n        return power_override\n\n    def reset(self):\n        \"\"\"\n        Reset SFP and return all user module settings to their default srate.\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        reset_path = \"{}{}{}\".format(CPLD_I2C_PATH , 'module_reset_' , self.port_num)\n        ret = self._api_helper.write_txt_file(reset_path, 1)\n        if ret is not True:\n            return ret\n\n        time.sleep(0.01)\n        ret = self._api_helper.write_txt_file(reset_path, 0)\n        time.sleep(0.2)\n\n        return ret\n\n    def tx_disable(self, tx_disable):\n        \"\"\"\n        Disable SFP TX for all channels\n        Args:\n            tx_disable : A Boolean, True to enable tx_disable mode, False to disable\n                         tx_disable mode.\n        Returns:\n            A boolean, True if tx_disable is set successfully, False if not\n        \"\"\"\n        if not self.get_presence():\n            return False\n        sysfsfile_eeprom = None\n        try:\n            tx_disable_ctl = 0xf if tx_disable else 0x0\n            buffer = create_string_buffer(1)\n            if sys.version_info[0] >= 3:\n                buffer[0] = tx_disable_ctl\n            else:\n                buffer[0] = chr(tx_disable_ctl)\n            # Write to eeprom\n            sysfsfile_eeprom = open(\n                self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n            sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n            sysfsfile_eeprom.write(buffer[0])\n        except IOError as e:\n            print ('Error: unable to open file: ',str(e))\n            return False\n        finally:\n            if sysfsfile_eeprom is not None:\n                sysfsfile_eeprom.close()\n                time.sleep(0.01)\n        \n        return True\n\n    def tx_disable_channel(self, channel, disable):\n        \"\"\"\n        Sets the tx_disable for specified SFP channels\n        Args:\n            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,\n                      e.g. 0x5 for channel 0 and channel 2.\n            disable : A boolean, True to disable TX channels specified in channel,\n                      False to enable\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"        \n        if not self.get_presence():\n            return False\n\n        sysfsfile_eeprom = None\n        try:\n            channel_state = self.get_tx_disable_channel()\n            for i in range(4):\n                channel_mask = (1 << i)\n                if not (channel & channel_mask):\n                    continue\n\n                if disable:\n                    channel_state |= channel_mask\n                else:\n                    channel_state &= ~channel_mask\n\n            buffer = create_string_buffer(1)\n            if sys.version_info[0] >= 3:\n                buffer[0] = channel_state\n            else:\n                buffer[0] = chr(channel_state)\n            # Write to eeprom\n            sysfsfile_eeprom = open(\n                self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n            sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n            sysfsfile_eeprom.write(buffer[0])\n        except IOError as e:\n            print ('Error: unable to open file: ', str(e))\n            return False\n        finally:\n            if sysfsfile_eeprom is not None:\n                sysfsfile_eeprom.close()\n                time.sleep(0.01)\n\n        return True\n\n    def set_lpmode(self, lpmode):\n        \"\"\"\n        Sets the lpmode (low power mode) of SFP\n        Args:\n            lpmode: A Boolean, True to enable lpmode, False to disable it\n            Note  : lpmode can be overridden by set_power_override\n        Returns:\n            A boolean, True if lpmode is set successfully, False if not\n        \"\"\"        \n        if lpmode:\n            self.set_power_override(True, True)\n        else:\n            self.set_power_override(False, False)\n    \n        return True\n       \n    def set_power_override(self, power_override, power_set):\n        \"\"\"\n        Sets SFP power level using power_override and power_set\n        Args:\n            power_override :\n                    A Boolean, True to override set_lpmode and use power_set\n                    to control SFP power, False to disable SFP power control\n                    through power_override/power_set and use set_lpmode\n                    to control SFP power.\n            power_set :\n                    Only valid when power_override is True.\n                    A Boolean, True to set SFP to low power mode, False to set\n                    SFP to high power mode.\n        Returns:\n            A boolean, True if power-override and power_set are set successfully,\n            False if not\n        \"\"\"\n       \n        if not self.get_presence():\n            return False\n        try:\n            power_override_bit = (1 << 0) if power_override else 0\n            power_set_bit      = (1 << 1) if power_set else (1 << 3)\n    \n            buffer = create_string_buffer(1)\n            if sys.version_info[0] >= 3:\n                buffer[0] = (power_override_bit | power_set_bit)\n            else:\n                buffer[0] = chr(power_override_bit | power_set_bit)\n            # Write to eeprom\n            with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd:\n                fd.seek(QSFP_POWEROVERRIDE_OFFSET)\n                fd.write(buffer[0])\n                time.sleep(0.01)\n        except Exception:\n            print ('Error: unable to open file: ', str(e))\n            return False\n\n        return True\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        sfputil_helper = SfpUtilHelper()\n        sfputil_helper.read_porttab_mappings(\n            self.__get_path_to_port_config_file())\n        name = sfputil_helper.logical[self.index] or \"Unknown\"\n        return name\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        present_path = \"{}{}{}\".format(CPLD_I2C_PATH , '/module_present_' , self.port_num)\n        val=self._api_helper.read_txt_file(present_path)\n        if val is not None:\n            return int(val, 10)==1\n        else:\n            return False\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return self.get_presence()\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return self.port_num\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return True\n"}, "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, ", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=6 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=3 NUM_QSFP=32 PORT_START=1 PORT_END=34 QSFP_PORT_START=0 QSFP_PORT_END=31 NUM_COMPONENT=2 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"docker > /dev/null 2>&1\" class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp self.QSFP_PORT_START=QSFP_PORT_START self.QSFP_PORT_END=QSFP_PORT_END for index in range(0, PORT_END): if index in range(self.QSFP_PORT_START, self.QSFP_PORT_END +1): sfp_module=Sfp(index, 'QSFP') else: sfp_module=Sfp(index, 'SFP') self._sfp_list.append(sfp_module) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan import Fan for fant_index in range(0, NUM_FAN_TRAY): for fan_index in range(0, NUM_FAN): fan=Fan(fant_index, fan_index) self._fan_list.append(fan) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._api_helper.hwsku def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_serial_number(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp ", "sourceWithComments": "#############################################################################\n# Accton\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 6\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 3\nNUM_QSFP = 32\nPORT_START = 1\nPORT_END = 34\nQSFP_PORT_START = 0\nQSFP_PORT_END = 31\nNUM_COMPONENT = 2\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n\n        self.config_data = {}\n\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n\n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n\n        self.QSFP_PORT_START = QSFP_PORT_START\n        self.QSFP_PORT_END = QSFP_PORT_END\n        for index in range(0, PORT_END):\n            if index in range(self.QSFP_PORT_START, self.QSFP_PORT_END + 1):\n                sfp_module = Sfp(index, 'QSFP')\n            else:\n                sfp_module = Sfp(index, 'SFP')\n            self._sfp_list.append(sfp_module)\n        self.sfp_module_initialized = True\n\n    def __initialize_fan(self):\n        from sonic_platform.fan import Fan\n        for fant_index in range(0, NUM_FAN_TRAY):\n            for fan_index in range(0, NUM_FAN):\n                fan = Fan(fant_index, fan_index)\n                self._fan_list.append(fan)\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n\n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n\n        return self._api_helper.hwsku\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_serial_number(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n\n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n"}, "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 3, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()        \n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firm", "add": 0, "remove": 16, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"3-0060\" } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"BIOS\", \"Basic Input/Output System\") ] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError ", "sourceWithComments": "#############################################################################\n# Accton\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"3-0060\"\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n\n]\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()        \n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)               \n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n\n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()           \n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n"}, "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-  ", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False"], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n class Sfp(SfpBase):\n     \"\"\"Platform-specific Sfp class\"\"\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n     PLATFORM = \"x86_64-accton_as9726_32d-r0\"\n     HWSKU = \"Accton-AS9726-32D\"\n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFOR", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}]}, "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py": {"changes": [{"diff": "\n #############################################################################\n \n try:\n-    import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py", "badparts": ["    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         if self.name == \"BIOS\":\n             fw_version = self.__get_bios_version()\n         elif \"CPLD\" in self.name:\n-            cmd = \"i2cget -f -y {0} {1} 0x1\".format(self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1])\n-            status, value = subprocess.getstatusoutput(cmd)\n+            cmd = [\"i2cget\", \"-f\", \"-y\", self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1], \"0x1\"]\n+            status, value = getstatusoutput_noshell(cmd)\n             if not status:\n                 ", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py", "badparts": ["            cmd = \"i2cget -f -y {0} {1} 0x1\".format(self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1])", "            status, value = subprocess.getstatusoutput(cmd)"], "goodparts": ["            cmd = [\"i2cget\", \"-f\", \"-y\", self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1], \"0x1\"]", "            status, value = getstatusoutput_noshell(cmd)"]}], "source": "\n try: import subprocess from sonic_platform_base.component_base import ComponentBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"BIOS\", \"Basic Input/Output System\") ] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" def __init__(self, component_index): self.index=component_index self.name=self.get_name() self.cpld_mapping={ 0:['3', '0x60'] } def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cmd=\"i2cget -f -y{0}{1} 0x1\".format(self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1]) status, value=subprocess.getstatusoutput(cmd) if not status: fw_version=value.rstrip() return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError ", "sourceWithComments": "#!/usr/bin/env python\n\n#############################################################################\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the component information (such as CPLD, FPGA, BIOS etc) which are available in the platform\n#\n#############################################################################\n\ntry:\n    import subprocess\n    from sonic_platform_base.component_base import ComponentBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\n#COMPONENT_NAME_LIST = [\"CPLD1\"]\nCOMPONENT_LIST =  [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n]\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n\n    def __init__(self, component_index):\n        self.index = component_index\n        self.name = self.get_name()\n        self.cpld_mapping = {\n                0: ['3', '0x60']                \n            }\n\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n    \n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n    \n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cmd = \"i2cget -f -y {0} {1} 0x1\".format(self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1])\n            status, value = subprocess.getstatusoutput(cmd)\n            if not status:\n                fw_version = value.rstrip()\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n"}, "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py": {"changes": [{"diff": "\n     import logging.config\n     import logging.handlers\n     import time\n-    import subprocess\n     from as4630_54pe.fanutil import FanUtil\n     from as4630_54pe.thermalutil import ThermalUtil\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py", "badparts": ["    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         if temp[0] >= 70000: #LM75-48    \n             #critical case*/\n             logging.critical('Alarm-Critical for temperature critical is detected, reset DUT')\n-            cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2);\n-            status, output = subprocess.getstatusoutput(cmd_str)\n+            status, output = getstatusoutput_noshell(cmd_str)\n                 \n         #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_state, fan_pol", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py", "badparts": ["            cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\"", "            status, output = subprocess.getstatusoutput(cmd_str)"], "goodparts": ["            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]", "            status, output = getstatusoutput_noshell(cmd_str)"]}], "source": "\n try: import getopt import sys import logging import logging.config import logging.handlers import time import subprocess from as4630_54pe.fanutil import FanUtil from as4630_54pe.thermalutil import ThermalUtil except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as4630_54pe_monitor' global log_file global log_level class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False fan_policy_state=0 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0, 0] temp_test_data=0 test_temp_revert=0 class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 for i in range(0, len(policy)): if(temp > policy[i][2]): if temp <=policy[i][3]: state=i return state def manage_fans(self): global fan_policy_state global fan_fail global test_temp global test_temp_list global alarm_state global temp_test_data global test_temp_revert LEVEL_FAN_MIN=0 LEVEL_FAN_NORMAL=1 LEVEL_FAN_MID=2 LEVEL_FAN_HIGH=3 LEVEL_TEMP_CRITICAL=4 fan_policy={ LEVEL_FAN_MIN: [50, 8, 0, 140000], LEVEL_FAN_NORMAL: [62, 10, 140000, 150000], LEVEL_FAN_MID: [75, 12, 150000, 160000], LEVEL_FAN_HIGH: [88, 14, 160000, 240000], LEVEL_TEMP_CRITICAL:[100, 16, 240000, 300000], } temp=[0, 0, 0] temp_fail=0 thermal=ThermalUtil() fan=FanUtil() ori_duty_cycle=fan.get_fan_duty_cycle() new_duty_cycle=0 if test_temp==0: for i in range(0,3): temp[i]=thermal._get_thermal_val(i+1) if temp[i]==0 or temp[i]==None: temp_fail=1 logging.warning(\"Get temp-%d fail\", i); return False else: if test_temp_revert==0: temp_test_data=temp_test_data+2000 else: temp_test_data=temp_test_data-2000 for i in range(0,3): temp[i]=test_temp_list[i]+temp_test_data fan_fail=0 temp_val=0 for i in range(0,3): if temp[i]==None: break temp_val+=temp[i] for i in range(fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1): if fan.get_fan_status(i)==0: new_pwm=100 logging.warning('Fan_%d fail, set pwm to 100',i) if test_temp==0: fan_fail=1 fan.set_fan_duty_cycle(new_pwm) break else: fan_fail=0 ori_state=fan_policy_state fan_policy_state=self.get_state_from_fan_policy(temp_val, fan_policy) if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN: logging.error(\"Get error fan current_state\\n\"); return 0 if fan_fail==0 and ori_duty_cycle!=fan_policy[fan_policy_state][0]: new_duty_cycle=fan_policy[fan_policy_state][0]; fan.set_fan_duty_cycle(new_duty_cycle) if temp[0] >=70000: logging.critical('Alarm-Critical for temperature critical is detected, reset DUT') cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\" time.sleep(2); status, output=subprocess.getstatusoutput(cmd_str) if ori_state < LEVEL_FAN_HIGH: if fan_policy_state >=LEVEL_FAN_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if fan_policy_state < LEVEL_FAN_MID: if alarm_state==1: logging.info('Alarm for temperature high is cleared') alarm_state=0 return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv,'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv)!=5: print(\"temp test, need input three temp\") return 0 i=0 for x in range(2, 5): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) fan=FanUtil() fan.set_fan_duty_cycle(50) print(\"set default fan speed to 50%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(10) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python\n# -*- coding: utf-8 -*\n# Copyright (c) 2019 Edgecore Networks Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n# THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR\n# CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT\n# LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS\n# FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.\n#\n# See the Apache Version 2.0 License for specific language governing\n# permissions and limitations under the License.\n# \n# HISTORY:\n#    mm/dd/yyyy (A.D.)#   \n#    10/24/2019:Jostar create for as4630_54pe thermal plan\n# ------------------------------------------------------------------\n\ntry:\n    import getopt\n    import sys\n    import logging\n    import logging.config\n    import logging.handlers\n    import time\n    import subprocess\n    from as4630_54pe.fanutil import FanUtil\n    from as4630_54pe.thermalutil import ThermalUtil\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as4630_54pe_monitor'\n\nglobal log_file\nglobal log_level\n\n \n\n\n\n# Temperature Policy\n# If any fan fail , please set fan speed register to 16\n# The max value of fan speed register is 14\n#  LM77(48)+LM75(4B)+LM75(4A)  >  140, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  >  150, Set 12\n#  LM77(48)+LM75(4B)+LM75(4A)  >  160, Set 14\n#  LM77(48)+LM75(4B)+LM75(4A)  <  140, Set 8\n#  LM77(48)+LM75(4B)+LM75(4A)  <  150, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  <  160, Set 12\n#  Reset DUT:LM77(48)>=70C\n#\nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n \n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n     \n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args: # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\nfan_policy_state=0\nfan_fail=0\nalarm_state = 0 #0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0, 0]\ntemp_test_data=0\ntest_temp_revert=0\n# Make a class we can use to capture stdout and sterr in the log\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm=0\n    ori_pwm = 0\n    default_pwm=0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format= '[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = handler = logging.handlers.SysLogHandler(address = '/dev/log')\n        sys_handler.setLevel(logging.WARNING)       \n        logging.getLogger('').addHandler(sys_handler)\n          \n    def get_state_from_fan_policy(self, temp, policy):\n        state=0\n        for i in range(0, len(policy)):\n            if (temp > policy[i][2]): #temp_down\n                if temp <= policy[i][3]: #temp_up\n                    state =i\n                            \n        return state\n\n    def manage_fans(self):\n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list        \n        global alarm_state\n        global temp_test_data  \n        global test_temp_revert      \n        LEVEL_FAN_MIN=0\n        LEVEL_FAN_NORMAL=1   \n        LEVEL_FAN_MID=2\n        LEVEL_FAN_HIGH=3\n        LEVEL_TEMP_CRITICAL=4\n        fan_policy = {\n           LEVEL_FAN_MIN:       [50,   8, 0,      140000],\n           LEVEL_FAN_NORMAL:    [62,  10, 140000, 150000],\n           LEVEL_FAN_MID:       [75,  12, 150000, 160000],\n           LEVEL_FAN_HIGH:      [88,  14, 160000, 240000],\n           LEVEL_TEMP_CRITICAL: [100, 16, 240000, 300000],\n        }\n        temp = [0, 0 , 0]\n        temp_fail=0\n        thermal = ThermalUtil()\n        fan = FanUtil()\n        ori_duty_cycle=fan.get_fan_duty_cycle()\n        new_duty_cycle=0\n        \n        if test_temp==0:\n            for i in range(0,3):\n                temp[i]=thermal._get_thermal_val(i+1)\n                if temp[i]==0 or temp[i]==None:\n                    temp_fail=1\n                    logging.warning(\"Get temp-%d fail\", i);\n                    return False\n        else:\n            if test_temp_revert==0:\n                temp_test_data=temp_test_data+2000\n            else:            \n                temp_test_data=temp_test_data-2000\n                \n            for i in range(0,3):\n                temp[i]=test_temp_list[i]+temp_test_data\n            fan_fail=0\n\n        temp_val=0 \n        for i in range(0,3):\n            if temp[i]==None:\n                break\n            temp_val+=temp[i]\n        \n        #Check Fan status\n        for i in range (fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1):\n            if fan.get_fan_status(i)==0:\n                new_pwm=100\n                logging.warning('Fan_%d fail, set pwm to 100',i)                \n                if test_temp==0:\n                    fan_fail=1\n                    fan.set_fan_duty_cycle(new_pwm)\n                    break\n            else:\n                fan_fail=0\n        \n        ori_state=fan_policy_state        \n        fan_policy_state=self.get_state_from_fan_policy(temp_val, fan_policy)\n        \n        if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN:\n            logging.error(\"Get error fan current_state\\n\");\n            return 0\n    \n        #Decision : Decide new fan pwm percent.\n        if fan_fail==0 and ori_duty_cycle!=fan_policy[fan_policy_state][0]:\n            new_duty_cycle = fan_policy[fan_policy_state][0];\n            fan.set_fan_duty_cycle(new_duty_cycle)\n\n        if temp[0] >= 70000: #LM75-48    \n            #critical case*/\n            logging.critical('Alarm-Critical for temperature critical is detected, reset DUT')\n            cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\"\n            time.sleep(2);\n            status, output = subprocess.getstatusoutput(cmd_str)\n                \n        #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_state, fan_policy_state, temp_val)\n        \n        if ori_state < LEVEL_FAN_HIGH:            \n           if fan_policy_state >= LEVEL_FAN_HIGH:\n               if alarm_state==0:\n                   logging.warning('Alarm for temperature high is detected')\n                   alarm_state=1\n                  \n        if fan_policy_state < LEVEL_FAN_MID:\n            if alarm_state==1:\n                logging.info('Alarm for temperature high is cleared')\n                alarm_state=0\n                \n        return True\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv,'hdlt:',['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg            \n        \n        if sys.argv[1]== '-t':\n            if len(sys.argv)!=5:\n                print(\"temp test, need input three temp\")\n                return 0\n            \n            i=0\n            for x in range(2, 5):\n               test_temp_list[i]= int(sys.argv[x])*1000\n               i=i+1\n            test_temp = 1   \n            log_level = logging.DEBUG\n            print(test_temp_list)                       \n    \n    fan = FanUtil()\n    fan.set_fan_duty_cycle(50)\n    print(\"set default fan speed to 50%\")\n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(10) #10sec\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n\n"}, "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py": {"changes": [{"diff": "\n             # Critical: Either all the fans are faulty or they are removed, shutdown the system\n             logging.critical('Alarm for all fan faulty/absent is detected')\n             logging.critical(\"Alarm for all fan faulty/absent is detected, reset DUT\")\n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2)\n-            subprocess.getstatusoutput('sync; sync; sync')\n-            subprocess.getstatusoutput(cmd_str)\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell(cmd_str)\n         elif sum(fan_fail_list) != 0:\n             # Set the 100% speed only for first fan failure detection\n             logging.warning('Fan_{} failed, set remaining fan speed to 100%'.format(\n", "add": 5, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py", "badparts": ["            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"", "            subprocess.getstatusoutput('sync; sync; sync')", "            subprocess.getstatusoutput(cmd_str)"], "goodparts": ["            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell(cmd_str)"]}, {"diff": "\n             as4630_54pe_set_fan_speed(new_duty_cycle)\n             if test_temp == 1:\n                 time.sleep(3)\n-                status, output = subprocess.getstatusoutput('pddf_fanutil getspeed')\n+                status, output = getstatusoutput_noshell(['pddf_fanutil', 'getspeed'])\n                 logging.debug('\\n%s\\n', output)\n \n         if temp[0] >= 70000:  # LM77-48\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py", "badparts": ["                status, output = subprocess.getstatusoutput('pddf_fanutil getspeed')"], "goodparts": ["                status, output = getstatusoutput_noshell(['pddf_fanutil', 'getspeed'])"]}, {"diff": "\n             if status:\n                 logging.warning('Reboot cause file not updated. {}'.format(output))\n \n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n-            subprocess.getstatusoutput('sync; sync; sync')\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n             time.sleep(3)\n-            subprocess.getstatusoutput(cmd_str)\n+            getstatusoutput_noshell(cmd_str)\n \n         logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n', ori_state", "add": 5, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py", "badparts": ["            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"", "            subprocess.getstatusoutput('sync; sync; sync')", "            subprocess.getstatusoutput(cmd_str)"], "goodparts": ["            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell(cmd_str)"]}], "source": "\n try: import os import sys import getopt import subprocess import logging import logging.handlers import time from sonic_platform import platform except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as4630_54pe_pddf_monitor' class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False def as4630_54pe_set_fan_speed(pwm): if pwm < 0 or pwm > 100: print(\"Error: Wrong duty cycle value %d\" %(pwm)) platform_chassis.get_fan(0).set_speed(pwm) platform_chassis.get_fan(2).set_speed(pwm) return 0 fan_policy_state=0 fan_fail=0 fan_fail_list=[0, 0, 0] alarm_state=0 test_temp=0 simulate_temp_decline=0 test_temp_list=[0, 0, 0] temp_test_data=0 test_temp_revert=0 platform_chassis=None class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(asctime)-15s %(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 for i in range(0, len(policy)): if(temp > policy[i][2]): if temp <=policy[i][3]: state=i return state def manage_fans(self): global fan_policy_state global fan_fail global fan_fail_list global test_temp global simulate_temp_decline global test_temp_list global alarm_state global temp_test_data global test_temp_revert global platform_chassis NUM_FANS=3 LEVEL_FAN_MIN=0 LEVEL_FAN_NORMAL=1 LEVEL_FAN_MID=2 LEVEL_FAN_HIGH=3 LEVEL_TEMP_CRITICAL=4 fan_policy={ LEVEL_FAN_MIN: [50, 8, 0, 140000], LEVEL_FAN_NORMAL: [62, 10, 140000, 150000], LEVEL_FAN_MID: [75, 12, 150000, 160000], LEVEL_FAN_HIGH: [88, 14, 160000, 240000], LEVEL_TEMP_CRITICAL:[100, 16, 240000, 300000], } temp=[0, 0, 0] ori_duty_cycle=platform_chassis.get_fan(0).get_speed() new_duty_cycle=0 if test_temp==0: for i in range(0, 3): temp[i]=platform_chassis.get_thermal(i).get_temperature() if temp[i]==0.0 or temp[i] is None: logging.warning(\"Get temp-%d fail\", i) return False temp[i]=int(temp[i]*1000) else: if test_temp_revert==0: temp_test_data=temp_test_data+2000 else: if temp_test_data > 0: temp_test_data=temp_test_data-2000 else: sys.exit('Simulation Ends !') for i in range(0, 3): temp[i]=test_temp_list[i]+temp_test_data fan_fail=0 temp_val=0 for i in range(0, 3): if temp[i] is None: break temp_val +=temp[i] for i in range(NUM_FANS): if not platform_chassis.get_fan(i).get_status(): if test_temp==0: fan_fail=1 if fan_fail_list[i]==0: fan_fail_list[i]=1 else: if fan_fail_list[i]==1: fan_fail_list[i]=0 if sum(fan_fail_list)==NUM_FANS: logging.critical('Alarm for all fan faulty/absent is detected') logging.critical(\"Alarm for all fan faulty/absent is detected, reset DUT\") cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\" time.sleep(2) subprocess.getstatusoutput('sync; sync; sync') subprocess.getstatusoutput(cmd_str) elif sum(fan_fail_list) !=0: logging.warning('Fan_{} failed, set remaining fan speed to 100%'.format( ' Fan_'.join(str(item+1) for item, val in enumerate(fan_fail_list) if val==1))) new_pwm=100 as4630_54pe_set_fan_speed(new_pwm) else: fan_fail=0 ori_state=fan_policy_state fan_policy_state=self.get_state_from_fan_policy(temp_val, fan_policy) if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN: logging.error(\"Get error fan current_state\\n\") return 0 if fan_fail==0 and ori_duty_cycle !=fan_policy[fan_policy_state][0]: new_duty_cycle=fan_policy[fan_policy_state][0] as4630_54pe_set_fan_speed(new_duty_cycle) if test_temp==1: time.sleep(3) status, output=subprocess.getstatusoutput('pddf_fanutil getspeed') logging.debug('\\n%s\\n', output) if temp[0] >=70000: logging.critical('Alarm for temperature critical is detected') logging.critical(\"Alarm-Critical for temperature critical is detected, reset DUT\") status, output=subprocess.getstatusoutput( 'echo \"Thermal Overload: Other\" > /host/reboot-cause/reboot-cause.txt') status, output=subprocess.getstatusoutput( 'echo \"System rebooted because alarm for critical temperature(70 C) is detected[Time: $(eval date)]\" >> /host/reboot-cause/reboot-cause.txt') if status: logging.warning('Reboot cause file not updated.{}'.format(output)) cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\" subprocess.getstatusoutput('sync; sync; sync') time.sleep(3) subprocess.getstatusoutput(cmd_str) logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n', ori_state, fan_policy_state, temp_val) if ori_state < LEVEL_FAN_HIGH: if fan_policy_state >=LEVEL_FAN_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if simulate_temp_decline==1: logging.info('Temperature decline simulation is ON. Testing temperature will decrease now') test_temp_revert=1 if fan_policy_state < LEVEL_FAN_MID: if alarm_state==1: logging.warning('Alarm for temperature high is cleared') alarm_state=0 return True def main(argv): if not os.path.exists('/usr/share/sonic/platform/pddf_support'): print(\"PDDF mode is not enabled\") return 0 log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp global simulate_temp_decline if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv, 'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv) !=6: print(\"temp test, need input temp decline option and three temp values\") return 0 i=0 simulate_temp_decline=int(sys.argv[2]) for x in range(3, 6): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) global platform_chassis platform_chassis=platform.Platform().get_chassis() as4630_54pe_set_fan_speed(50) monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(10) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*\n# Copyright (c) 2019 Edgecore Networks Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n# THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR\n# CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT\n# LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS\n# FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.\n#\n# See the Apache Version 2.0 License for specific language governing\n# permissions and limitations under the License.\n#\n# HISTORY:\n#    mm/dd/yyyy (A.D.)#\n#    10/24/2019:Jostar create for as4630_54pe thermal plan\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import sys\n    import getopt\n    import subprocess\n    import logging\n    import logging.handlers\n    import time\n    from sonic_platform import platform\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as4630_54pe_pddf_monitor'\n\n\n\n\n\n# Temperature Policy\n# If any fan fail , please set fan speed register to 16\n# The max value of fan speed register is 14\n#  LM77(48)+LM75(4B)+LM75(4A)  >  140, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  >  150, Set 12\n#  LM77(48)+LM75(4B)+LM75(4A)  >  160, Set 14\n#  LM77(48)+LM75(4B)+LM75(4A)  <  140, Set 8\n#  LM77(48)+LM75(4B)+LM75(4A)  <  150, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  <  160, Set 12\n#  Reset DUT:LM77(48)>=70C\n#\nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n\n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n\n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args:  # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\n\ndef as4630_54pe_set_fan_speed(pwm):\n    # This platform has 2 fans controlled by one register on CPLD and 3rd fan by another register\n    # Hence, we need to change the speed for all\n    if pwm < 0 or pwm > 100:\n        print(\"Error: Wrong duty cycle value %d\" % (pwm))\n    platform_chassis.get_fan(0).set_speed(pwm)\n    platform_chassis.get_fan(2).set_speed(pwm)\n   \n    return 0\n\n\nfan_policy_state = 0\nfan_fail = 0\nfan_fail_list = [0, 0, 0]\nalarm_state = 0  # 0->default or clear, 1-->alarm detect\ntest_temp = 0\nsimulate_temp_decline = 0\ntest_temp_list = [0, 0, 0]\ntemp_test_data = 0\ntest_temp_revert = 0\nplatform_chassis = None\n# Make a class we can use to capture stdout and sterr in the log\n\n\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm = 0\n    ori_pwm = 0\n    default_pwm = 0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format='[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(asctime)-15s %(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = logging.handlers.SysLogHandler(address='/dev/log')\n        sys_handler.setLevel(logging.WARNING)\n        logging.getLogger('').addHandler(sys_handler)\n\n    def get_state_from_fan_policy(self, temp, policy):\n        state = 0\n        for i in range(0, len(policy)):\n            if (temp > policy[i][2]):  # temp_down\n                if temp <= policy[i][3]:  # temp_up\n                    state = i\n\n        return state\n\n    def manage_fans(self):\n        global fan_policy_state\n        global fan_fail\n        global fan_fail_list\n        global test_temp\n        global simulate_temp_decline\n        global test_temp_list\n        global alarm_state\n        global temp_test_data\n        global test_temp_revert\n        global platform_chassis\n        NUM_FANS = 3\n        LEVEL_FAN_MIN = 0\n        LEVEL_FAN_NORMAL = 1\n        LEVEL_FAN_MID = 2\n        LEVEL_FAN_HIGH = 3\n        LEVEL_TEMP_CRITICAL = 4\n        fan_policy = {\n            LEVEL_FAN_MIN:       [50,   8, 0,      140000],\n            LEVEL_FAN_NORMAL:    [62,  10, 140000, 150000],\n            LEVEL_FAN_MID:       [75,  12, 150000, 160000],\n            LEVEL_FAN_HIGH:      [88,  14, 160000, 240000],\n            LEVEL_TEMP_CRITICAL: [100, 16, 240000, 300000],\n        }\n        temp = [0, 0, 0]\n        \n        #thermal = ThermalUtil()\n        #fan = FanUtil()\n        # Supposedly all the fans are set with same duty cycle\n        ori_duty_cycle = platform_chassis.get_fan(0).get_speed()\n        new_duty_cycle = 0\n\n        if test_temp == 0:\n            for i in range(0, 3):\n                temp[i] = platform_chassis.get_thermal(i).get_temperature()\n                if temp[i] == 0.0 or temp[i] is None:\n                    \n                    logging.warning(\"Get temp-%d fail\", i)\n                    return False\n                temp[i] = int(temp[i]*1000)\n        else:\n            if test_temp_revert == 0:\n                temp_test_data = temp_test_data+2000\n            else:\n                if temp_test_data > 0:\n                    temp_test_data = temp_test_data-2000\n                else:\n                    # Stop the simulation\n                    sys.exit('Simulation Ends !')\n\n            for i in range(0, 3):\n                temp[i] = test_temp_list[i]+temp_test_data\n            fan_fail = 0\n\n        temp_val = 0\n        for i in range(0, 3):\n            if temp[i] is None:\n                break\n            temp_val += temp[i]\n\n        # Check Fan status\n        for i in range(NUM_FANS):\n            if not platform_chassis.get_fan(i).get_status():\n                if test_temp == 0:\n                    fan_fail = 1\n                    if fan_fail_list[i] == 0:\n                        fan_fail_list[i] = 1\n            else:\n                if fan_fail_list[i] == 1:\n                    fan_fail_list[i] = 0\n\n        if sum(fan_fail_list) == NUM_FANS:\n            # Critical: Either all the fans are faulty or they are removed, shutdown the system\n            logging.critical('Alarm for all fan faulty/absent is detected')\n            logging.critical(\"Alarm for all fan faulty/absent is detected, reset DUT\")\n            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n            time.sleep(2)\n            subprocess.getstatusoutput('sync; sync; sync')\n            subprocess.getstatusoutput(cmd_str)\n        elif sum(fan_fail_list) != 0:\n            # Set the 100% speed only for first fan failure detection\n            logging.warning('Fan_{} failed, set remaining fan speed to 100%'.format(\n                ' Fan_'.join(str(item+1) for item, val in enumerate(fan_fail_list) if val == 1)))\n            new_pwm = 100\n            as4630_54pe_set_fan_speed(new_pwm)\n        else:\n            fan_fail = 0\n\n        ori_state = fan_policy_state\n        fan_policy_state = self.get_state_from_fan_policy(temp_val, fan_policy)\n\n        if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN:\n            logging.error(\"Get error fan current_state\\n\")\n            return 0\n\n        # Decision : Decide new fan pwm percent.\n        if fan_fail == 0 and ori_duty_cycle != fan_policy[fan_policy_state][0]:\n            new_duty_cycle = fan_policy[fan_policy_state][0]\n            as4630_54pe_set_fan_speed(new_duty_cycle)\n            if test_temp == 1:\n                time.sleep(3)\n                status, output = subprocess.getstatusoutput('pddf_fanutil getspeed')\n                logging.debug('\\n%s\\n', output)\n\n        if temp[0] >= 70000:  # LM77-48\n            # critical case*/\n            logging.critical('Alarm for temperature critical is detected')\n            logging.critical(\"Alarm-Critical for temperature critical is detected, reset DUT\")\n            # Update the reboot cause file to reflect that critical temperature\n            # has been crossed. Upon next boot, the contents of this file will\n            # be used to determine the cause of the previous reboot\n            status, output = subprocess.getstatusoutput(\n                'echo \"Thermal Overload: Other\" > /host/reboot-cause/reboot-cause.txt')\n            status, output = subprocess.getstatusoutput(\n                'echo \"System rebooted because alarm for critical temperature (70 C) is detected [Time: $(eval date)]\" >> /host/reboot-cause/reboot-cause.txt')\n            if status:\n                logging.warning('Reboot cause file not updated. {}'.format(output))\n\n            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n            subprocess.getstatusoutput('sync; sync; sync')\n            time.sleep(3)\n            subprocess.getstatusoutput(cmd_str)\n\n        logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n', ori_state, fan_policy_state, temp_val)\n\n        if ori_state < LEVEL_FAN_HIGH:\n            if fan_policy_state >= LEVEL_FAN_HIGH:\n                if alarm_state == 0:\n                    logging.warning('Alarm for temperature high is detected')\n                    alarm_state = 1\n                    # Add a mechanism to decrease the test_temp values\n                    if simulate_temp_decline == 1:\n                        logging.info('Temperature decline simulation is ON. Testing temperature will decrease now')\n                        test_temp_revert = 1\n\n        if fan_policy_state < LEVEL_FAN_MID:\n            if alarm_state == 1:\n                logging.warning('Alarm for temperature high is cleared')\n                alarm_state = 0\n\n        return True\n\n\ndef main(argv):\n    # Check if PDDF mode is enabled\n    if not os.path.exists('/usr/share/sonic/platform/pddf_support'):\n        print(\"PDDF mode is not enabled\")\n        return 0\n\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    global simulate_temp_decline\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv, 'hdlt:', ['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg\n\n        if sys.argv[1] == '-t':\n            if len(sys.argv) != 6:\n                print(\"temp test, need input temp decline option and three temp values\")\n                return 0\n\n            i = 0\n            simulate_temp_decline = int(sys.argv[2])\n            for x in range(3, 6):\n                test_temp_list[i] = int(sys.argv[x])*1000\n                i = i+1\n            test_temp = 1\n            log_level = logging.DEBUG\n            print(test_temp_list)\n\n    global platform_chassis\n    platform_chassis = platform.Platform().get_chassis()\n\n    as4630_54pe_set_fan_speed(50)\n    \n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(10)  # 10sec\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n"}, "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import commands\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"clean\"])\n     if status:\n-        print \"accton_as4630_54pe_util.py clean command failed %d\"%status\n+        print(\"accton_as4630_54pe_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Stop pddf-platform-init.service along with other platform serives failed %d\"%status\n+        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status\n+        print(\"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status)\n         return False\n \n     return True\n     \n def start_platform_svc():\n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"install\"])\n     if status:\n-        print \"accton_as4630_54pe_util.py install  command failed %d\"%status\n+        print(\"accton_as4630_54pe_util.py install  command failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n \n     return True\n \n def start_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Start pddf-platform-init.service failed %d\"%status\n+        print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n+        print(\"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status)\n         return False\n     \n     return True\n \n def stop_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Stop pddf-platform-init.service failed %d\"%status\n+        print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n+        print(\"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status)\n        ", "add": 41, "remove": 41, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py", "badparts": ["import commands", "    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-fan.service\")", "        print \"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-fan.service\")", "        print \"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-psu.service\")", "        print \"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-psu.service\")", "        print \"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor.service\")", "        print \"Disable as4630-54pe-platform-monitor.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor.service\")", "        print \"Stop as4630-54pe-platform-monitor.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py clean\")", "        print \"accton_as4630_54pe_util.py clean command failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")", "        print \"Stop pddf-platform-init.service along with other platform serives failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")", "        print \"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status", "    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py install\")", "        print \"accton_as4630_54pe_util.py install  command failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-fan.service\")", "        print \"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-fan.service\")", "        print \"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-psu.service\")", "        print \"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-psu.service\")", "        print \"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor.service\")", "        print \"Enable as4630-54pe-platform-monitor.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor.service\")", "        print \"Start as4630-54pe-platform-monitor.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")", "        print \"Start pddf-platform-init.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-pddf-platform-monitor.service\")", "        print \"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")", "        print \"Stop pddf-platform-init.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")", "        print \"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-fan.service\"])", "        print(\"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-fan.service\"])", "        print(\"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-psu.service\"])", "        print(\"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-psu.service\"])", "        print(\"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor.service\"])", "        print(\"Disable as4630-54pe-platform-monitor.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor.service\"])", "        print(\"Stop as4630-54pe-platform-monitor.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"clean\"])", "        print(\"accton_as4630_54pe_util.py clean command failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])", "        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])", "        print(\"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"install\"])", "        print(\"accton_as4630_54pe_util.py install  command failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-fan.service\"])", "        print(\"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-fan.service\"])", "        print(\"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-psu.service\"])", "        print(\"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-psu.service\"])", "        print(\"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor.service\"])", "        print(\"Enable as4630-54pe-platform-monitor.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor.service\"])", "        print(\"Start as4630-54pe-platform-monitor.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])", "        print(\"Start pddf-platform-init.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-pddf-platform-monitor.service\"])", "        print(\"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])", "        print(\"Stop pddf-platform-init.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])", "        print(\"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status)"]}], "source": "\n import commands def check_pddf_support(): return True def stop_platform_svc(): status, output=commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-fan.service\") if status: print \"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-fan.service\") if status: print \"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-psu.service\") if status: print \"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-psu.service\") if status: print \"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor.service\") if status: print \"Disable as4630-54pe-platform-monitor.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor.service\") if status: print \"Stop as4630-54pe-platform-monitor.service failed %d\"%status return False status, output=commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py clean\") if status: print \"accton_as4630_54pe_util.py clean command failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print \"Stop pddf-platform-init.service along with other platform serives failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\") if status: print \"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status return False return True def start_platform_svc(): status, output=commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py install\") if status: print \"accton_as4630_54pe_util.py install command failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-fan.service\") if status: print \"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-fan.service\") if status: print \"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-psu.service\") if status: print \"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-psu.service\") if status: print \"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor.service\") if status: print \"Enable as4630-54pe-platform-monitor.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor.service\") if status: print \"Start as4630-54pe-platform-monitor.service failed %d\"%status return False return True def start_platform_pddf(): status, output=commands.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print \"Start pddf-platform-init.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl start as4630-54pe-pddf-platform-monitor.service\") if status: print \"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status return False return True def stop_platform_pddf(): status, output=commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print \"Stop pddf-platform-init.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\") if status: print \"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status return False return True def main(): pass if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services. \n# This will be used while switching the pddf->non-pddf mode and vice versa\n\nimport commands\n\ndef check_pddf_support():\n    return True\n\ndef stop_platform_svc():\n    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-fan.service\")\n    if status:\n        print \"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-fan.service\")\n    if status:\n        print \"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status\n        return False\n\n    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-psu.service\")\n    if status:\n        print \"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-psu.service\")\n    if status:\n        print \"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status\n        return False\n    \n    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor.service\")\n    if status:\n        print \"Disable as4630-54pe-platform-monitor.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor.service\")\n    if status:\n        print \"Stop as4630-54pe-platform-monitor.service failed %d\"%status\n        return False\n\n    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py clean\")\n    if status:\n        print \"accton_as4630_54pe_util.py clean command failed %d\"%status\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print \"Stop pddf-platform-init.service along with other platform serives failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n    if status:\n        print \"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status\n        return False\n\n    return True\n    \ndef start_platform_svc():\n    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py install\")\n    if status:\n        print \"accton_as4630_54pe_util.py install  command failed %d\"%status\n        return False\n\n    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-fan.service\")\n    if status:\n        print \"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-fan.service\")\n    if status:\n        print \"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status\n        return False\n\n    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-psu.service\")\n    if status:\n        print \"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-psu.service\")\n    if status:\n        print \"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status\n        return False\n\n    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor.service\")\n    if status:\n        print \"Enable as4630-54pe-platform-monitor.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor.service\")\n    if status:\n        print \"Start as4630-54pe-platform-monitor.service failed %d\"%status\n        return False\n\n    return True\n\ndef start_platform_pddf():\n    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print \"Start pddf-platform-init.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-pddf-platform-monitor.service\")\n    if status:\n        print \"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n        return False\n    \n    return True\n\ndef stop_platform_pddf():\n    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print \"Stop pddf-platform-init.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n    if status:\n        print \"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n        return False\n\n    return True\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py": {"changes": [{"diff": "\n             # critical case*/\n             logging.critical(\n                 'Alarm-Critical for temperature critical is detected, reset DUT')\n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2)\n-            return_value = os.system(cmd_str)\n+            return_value = subprocess.call(cmd_str)\n             logging.warning('Fan set: i2cset -y -f 3 0x60 0x4 0xE4, status is %d', return_value)\n \n         #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_s", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py", "badparts": ["            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"", "            return_value = os.system(cmd_str)"], "goodparts": ["            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]", "            return_value = subprocess.call(cmd_str)"]}], "source": "\n try: import os import sys import getopt import logging import logging.config import logging.handlers import time from as4630_54te.fanutil import FanUtil from as4630_54te.thermalutil import ThermalUtil except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as4630_54te_monitor' class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False fan_policy_state=0 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0, 0] temp_test_data=0 test_temp_revert=0 class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S') if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter( '%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=logging.handlers.SysLogHandler( address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 for i in range(0, len(policy)): if(temp > policy[i][2]): if temp <=policy[i][3]: state=i return state def manage_fans(self): global fan_policy_state global fan_fail global test_temp global test_temp_list global alarm_state global temp_test_data global test_temp_revert LEVEL_FAN_MIN=0 LEVEL_FAN_NORMAL=1 LEVEL_FAN_MID=2 LEVEL_FAN_HIGH=3 LEVEL_TEMP_CRITICAL=4 fan_policy={ LEVEL_FAN_MIN:[50, 8, 0, 140000], LEVEL_FAN_NORMAL:[62, 10, 140000, 150000], LEVEL_FAN_MID:[75, 12, 150000, 160000], LEVEL_FAN_HIGH:[88, 14, 160000, 240000], LEVEL_TEMP_CRITICAL:[100, 16, 240000, 300000], } temp=[0, 0, 0] thermal=ThermalUtil() fan=FanUtil() ori_duty_cycle=fan.get_fan_duty_cycle() new_duty_cycle=0 if test_temp==0: for i in range(0, 3): temp[i]=thermal._get_thermal_val(i +1) if temp[i]==0 or temp[i] is None: logging.warning(\"Get temp-%d fail\", i) return False else: if test_temp_revert==0: temp_test_data=temp_test_data +2000 else: temp_test_data=temp_test_data -2000 for i in range(0, 3): temp[i]=test_temp_list[i] +temp_test_data fan_fail=0 temp_val=0 for i in range(0, 3): if temp[i] is None: break temp_val +=temp[i] for i in range(fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD +1): if fan.get_fan_status(i)==0: new_pwm=100 logging.warning('Fan_%d fail, set pwm to 100', i) if test_temp==0: fan_fail=1 fan.set_fan_duty_cycle(new_pwm) break else: fan_fail=0 ori_state=fan_policy_state fan_policy_state=self.get_state_from_fan_policy(temp_val, fan_policy) if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN: logging.error(\"Get error fan current_state\\n\") return 0 if fan_fail==0 and ori_duty_cycle !=fan_policy[fan_policy_state][0]: new_duty_cycle=fan_policy[fan_policy_state][0] fan.set_fan_duty_cycle(new_duty_cycle) if temp[0] >=70000: logging.critical( 'Alarm-Critical for temperature critical is detected, reset DUT') cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\" time.sleep(2) return_value=os.system(cmd_str) logging.warning('Fan set: i2cset -y -f 3 0x60 0x4 0xE4, status is %d', return_value) if ori_state < LEVEL_FAN_HIGH: if fan_policy_state >=LEVEL_FAN_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if fan_policy_state < LEVEL_FAN_MID: if alarm_state==1: logging.info('Alarm for temperature high is cleared') alarm_state=0 return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv, 'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv) !=5: print(\"temp test, need input three temp\") return 0 i=0 for x in range(2, 5): test_temp_list[i]=int(sys.argv[x]) * 1000 i=i +1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) fan=FanUtil() fan.set_fan_duty_cycle(50) print(\"set default fan speed to 50%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(10) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python\n# -*- coding: utf-8 -*\n# Copyright (c) 2019 Edgecore Networks Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n# THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR\n# CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT\n# LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS\n# FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.\n#\n# See the Apache Version 2.0 License for specific language governing\n# permissions and limitations under the License.\n#\n# HISTORY:\n#    mm/dd/yyyy (A.D.)#\n#    10/24/2019:Jostar create for as4630_54te thermal plan\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import sys\n    import getopt\n    import logging\n    import logging.config\n    import logging.handlers\n    import time\n    from as4630_54te.fanutil import FanUtil\n    from as4630_54te.thermalutil import ThermalUtil\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as4630_54te_monitor'\n\n# Temperature Policy\n# If any fan fail , please set fan speed register to 16\n# The max value of fan speed register is 14\n#  LM77(48)+LM75(4B)+LM75(4A)  >  140, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  >  150, Set 12\n#  LM77(48)+LM75(4B)+LM75(4A)  >  160, Set 14\n#  LM77(48)+LM75(4B)+LM75(4A)  <  140, Set 8\n#  LM77(48)+LM75(4B)+LM75(4A)  <  150, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  <  160, Set 12\n#  Reset DUT:LM77(48)>=70C\n#\nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n\n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n\n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args:  # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\n\nfan_policy_state = 0\nfan_fail = 0\nalarm_state = 0  # 0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0, 0]\ntemp_test_data = 0\ntest_temp_revert = 0\n# Make a class we can use to capture stdout and sterr in the log\n\n\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm = 0\n    ori_pwm = 0\n    default_pwm = 0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format='[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S')\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter(\n                '%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = logging.handlers.SysLogHandler(\n            address='/dev/log')\n        sys_handler.setLevel(logging.WARNING)\n        logging.getLogger('').addHandler(sys_handler)\n\n    def get_state_from_fan_policy(self, temp, policy):\n        state = 0\n        for i in range(0, len(policy)):\n            if (temp > policy[i][2]):  # temp_down\n                if temp <= policy[i][3]:  # temp_up\n                    state = i\n\n        return state\n\n    def manage_fans(self):\n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list\n        global alarm_state\n        global temp_test_data\n        global test_temp_revert\n        LEVEL_FAN_MIN = 0\n        LEVEL_FAN_NORMAL = 1\n        LEVEL_FAN_MID = 2\n        LEVEL_FAN_HIGH = 3\n        LEVEL_TEMP_CRITICAL = 4\n        fan_policy = {\n            LEVEL_FAN_MIN: [50, 8, 0, 140000],\n            LEVEL_FAN_NORMAL: [62, 10, 140000, 150000],\n            LEVEL_FAN_MID: [75, 12, 150000, 160000],\n            LEVEL_FAN_HIGH: [88, 14, 160000, 240000],\n            LEVEL_TEMP_CRITICAL: [100, 16, 240000, 300000],\n        }\n        temp = [0, 0, 0]\n        thermal = ThermalUtil()\n        fan = FanUtil()\n        ori_duty_cycle = fan.get_fan_duty_cycle()\n        new_duty_cycle = 0\n\n        if test_temp == 0:\n            for i in range(0, 3):\n                temp[i] = thermal._get_thermal_val(i + 1)\n                if temp[i] == 0 or temp[i] is None:\n                    logging.warning(\"Get temp-%d fail\", i)\n                    return False\n        else:\n            if test_temp_revert == 0:\n                temp_test_data = temp_test_data + 2000\n            else:\n                temp_test_data = temp_test_data - 2000\n\n            for i in range(0, 3):\n                temp[i] = test_temp_list[i] + temp_test_data\n            fan_fail = 0\n\n        temp_val = 0\n        for i in range(0, 3):\n            if temp[i] is None:\n                break\n            temp_val += temp[i]\n\n        # Check Fan status\n        for i in range(fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD + 1):\n            if fan.get_fan_status(i) == 0:\n                new_pwm = 100\n                logging.warning('Fan_%d fail, set pwm to 100', i)\n                if test_temp == 0:\n                    fan_fail = 1\n                    fan.set_fan_duty_cycle(new_pwm)\n                    break\n            else:\n                fan_fail = 0\n\n        ori_state = fan_policy_state\n        fan_policy_state = self.get_state_from_fan_policy(temp_val, fan_policy)\n\n        if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN:\n            logging.error(\"Get error fan current_state\\n\")\n            return 0\n\n        # Decision : Decide new fan pwm percent.\n        if fan_fail == 0 and ori_duty_cycle != fan_policy[fan_policy_state][0]:\n            new_duty_cycle = fan_policy[fan_policy_state][0]\n            fan.set_fan_duty_cycle(new_duty_cycle)\n\n        if temp[0] >= 70000:  # LM75-48\n            # critical case*/\n            logging.critical(\n                'Alarm-Critical for temperature critical is detected, reset DUT')\n            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n            time.sleep(2)\n            return_value = os.system(cmd_str)\n            logging.warning('Fan set: i2cset -y -f 3 0x60 0x4 0xE4, status is %d', return_value)\n\n        #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_state, fan_policy_state, temp_val)\n\n        if ori_state < LEVEL_FAN_HIGH:\n            if fan_policy_state >= LEVEL_FAN_HIGH:\n                if alarm_state == 0:\n                    logging.warning('Alarm for temperature high is detected')\n                    alarm_state = 1\n\n        if fan_policy_state < LEVEL_FAN_MID:\n            if alarm_state == 1:\n                logging.info('Alarm for temperature high is cleared')\n                alarm_state = 0\n\n        return True\n\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv, 'hdlt:', ['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg\n\n        if sys.argv[1] == '-t':\n            if len(sys.argv) != 5:\n                print(\"temp test, need input three temp\")\n                return 0\n\n            i = 0\n            for x in range(2, 5):\n                test_temp_list[i] = int(sys.argv[x]) * 1000\n                i = i + 1\n            test_temp = 1\n            log_level = logging.DEBUG\n            print(test_temp_list)\n\n    fan = FanUtil()\n    fan.set_fan_duty_cycle(50)\n    print(\"set default fan speed to 50%\")\n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(10)  # 10sec\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py": {"changes": [{"diff": "\n # ------------------------------------------------------------------\n \n try:\n-    import time\n     import logging\n-    from collections import namedtuple\n-    import subprocess\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n", "add": 1, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py", "badparts": ["    import time", "    from collections import namedtuple", "    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         return \"fan{0}_{1}\".format(fan_num, self.node_postfix[node_num-1])\n     \n     def _get_fan_i2c_bus_addr(self):\n-        cmd_template = 'i2cget -f -y {} 0x{} 0'\n+        cmd_template = ['i2cget', '-f', '-y', '', '', '0']\n         for bus_no, dev_addr in self.I2CADDR_CANDIDATES:\n-            cmd = cmd_template.format(bus_no, dev_addr)\n-            if subprocess.getstatusoutput(cmd)[0] == 0:\n+            cmd_template[3] = str(bus_no)\n+            cmd_template[4] = '0x' + str(dev_addr)\n+            if getstatusoutput_noshell(cmd_template)[0] == 0:\n                 return bus_no, dev_addr\n         raise IOError('Un", "add": 4, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py", "badparts": ["        cmd_template = 'i2cget -f -y {} 0x{} 0'", "            cmd = cmd_template.format(bus_no, dev_addr)", "            if subprocess.getstatusoutput(cmd)[0] == 0:"], "goodparts": ["        cmd_template = ['i2cget', '-f', '-y', '', '', '0']", "            cmd_template[3] = str(bus_no)", "            cmd_template[4] = '0x' + str(dev_addr)", "            if getstatusoutput_noshell(cmd_template)[0] == 0:"]}], "source": "\n try: import time import logging from collections import namedtuple import subprocess except ImportError as e: raise ImportError('%s -required module not found' % str(e)) class FanUtil(object): \"\"\"Platform-specific FanUtil class\"\"\" FAN_TOTAL_NUM=5 FAN_NUM_1_IDX=1 FAN_NODE_NUM=2 FAN_FAULT_IDX=1 FAN_DIR_IDX=2 I2CADDR_CANDIDATES=((9, 66), (50, 66)) PATH_PREFIX='/sys/bus/i2c/devices/{}-00{}/' BASE_VAL_PATH='{0}' FAN_DUTY_PATH='fan{0}_pwm' \"\"\" Dictionary where key1=fan id index(integer) starting from 1 key2=fan node index(interger) starting from 1 value=path to fan device file(string) \"\"\" dev_paths={} node_postfix=[\"fault\", \"direction\"] def _get_fan_to_device_node(self, fan_num, node_num): return \"fan{0}_{1}\".format(fan_num, self.node_postfix[node_num-1]) def _get_fan_i2c_bus_addr(self): cmd_template='i2cget -f -y{} 0x{} 0' for bus_no, dev_addr in self.I2CADDR_CANDIDATES: cmd=cmd_template.format(bus_no, dev_addr) if subprocess.getstatusoutput(cmd)[0]==0: return bus_no, dev_addr raise IOError('Unable to reach fan CPLD via I2C') def _init_fnode_basepath(self): '''format BASE_VAL_PATH and FAN_DUTY_PATH ''' bus, addr=self._get_fan_i2c_bus_addr() self.PATH_PREFIX=self.PATH_PREFIX.format(bus, addr) self.BASE_VAL_PATH=self.PATH_PREFIX +self.BASE_VAL_PATH self.FAN_DUTY_PATH=self.PATH_PREFIX +self.FAN_DUTY_PATH def _get_fan_node_val(self, fan_num, node_num): if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM: self.logger.debug('GET. Parameter error. fan_num:%d', fan_num) return None if node_num < self.FAN_FAULT_IDX or node_num > self.FAN_NODE_NUM: self.logger.debug('GET. Parameter error. node_num:%d', node_num) return None device_path=self.get_fan_to_device_path(fan_num, node_num) try: val_file=open(device_path, 'r') except IOError as e: self.logger.error('GET. unable to open file: %s', str(e)) return None content=val_file.readline().rstrip() if content=='': self.logger.debug('GET. content is NULL. device_path:%s', device_path) return None try: val_file.close() except: self.logger.debug('GET. unable to close file. device_path:%s', device_path) return None return int(content) def _set_fan_node_val(self, fan_num, node_num, val): if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM: self.logger.debug('GET. Parameter error. fan_num:%d', fan_num) return None if node_num < self.FAN_FAULT_IDX or node_num > self.FAN_NODE_NUM: self.logger.debug('GET. Parameter error. node_num:%d', node_num) return None content=str(val) if content=='': self.logger.debug('GET. content is NULL. device_path:%s', device_path) return None device_path=self.get_fan_to_device_path(fan_num, node_num) try: val_file=open(device_path, 'w') except IOError as e: self.logger.error('GET. unable to open file: %s', str(e)) return None val_file.write(content) try: val_file.close() except: self.logger.debug('GET. unable to close file. device_path:%s', device_path) return None return True logger=logging.getLogger(__name__) def __init__(self, log_level=logging.DEBUG): ch=logging.StreamHandler() ch.setLevel(log_level) self.logger.addHandler(ch) self._init_fnode_basepath() fan_path=self.BASE_VAL_PATH for fan_num in range(self.FAN_NUM_1_IDX, self.FAN_TOTAL_NUM+1): for node_num in range(1, self.FAN_NODE_NUM+1): node=self._get_fan_to_device_node(fan_num, node_num) self.dev_paths[(fan_num, node_num)]=fan_path.format(node) def get_num_fans(self): return self.FAN_TOTAL_NUM def get_idx_fan_start(self): return self.FAN_NUM_1_IDX def get_num_nodes(self): return self.FAN_NODE_NUM def get_idx_node_start(self): return self.FAN_FAULT_IDX def get_size_node_map(self): return len(self.dev_paths) def get_size_path_map(self): return len(self.dev_paths) def get_fan_to_device_path(self, fan_num, node_num): return self.dev_paths[(fan_num, node_num)] def get_fan_fault(self, fan_num): return self._get_fan_node_val(fan_num, self.FAN_FAULT_IDX) def get_fan_dir(self, fan_num): return self._get_fan_node_val(fan_num, self.FAN_DIR_IDX) def get_fan_duty_cycle(self): try: val_file=open(self.FAN_DUTY_PATH.format(1)) except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False content=val_file.readline().rstrip() val_file.close() return int(content) def set_fan_duty_cycle(self, val): for fan_num in range(1, self.FAN_TOTAL_NUM+1): try: fan_file=open(self.FAN_DUTY_PATH.format(fan_num), 'r+') except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False fan_file.write(str(val)) fan_file.close() return True def get_fan_status(self, fan_num): if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM: self.logger.debug('GET. Parameter error. fan_num, %d', fan_num) return None if self.get_fan_fault(fan_num) is not None and self.get_fan_fault(fan_num) > 0: self.logger.debug('GET. FAN fault. fan_num, %d', fan_num) return False return True ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2017 Accton Technology Corporation\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    mm/dd/yyyy (A.D.)\n#    11/13/2017: Polly Hsu, Create\n#    1/10/2018: Jostar modify for as7716_32\n#    5/02/2019: Roy Lee modify for as7816_64x\n# ------------------------------------------------------------------\n\ntry:\n    import time\n    import logging\n    from collections import namedtuple\n    import subprocess\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n\nclass FanUtil(object):\n    \"\"\"Platform-specific FanUtil class\"\"\"\n\n    FAN_TOTAL_NUM = 5\n    FAN_NUM_1_IDX = 1\n\n    FAN_NODE_NUM = 2\n    FAN_FAULT_IDX = 1\n    #FAN_SPEED_IDX = 2\n    FAN_DIR_IDX = 2\n    #FAN_NODE_DUTY_IDX_OF_MAP = 4\n    #FANR_NODE_FAULT_IDX_OF_MAP = 5\n\n    I2CADDR_CANDIDATES = ((9, 66), # for R0C HW and later\n                         (50, 66)) # for R0A, R0B HW\n    PATH_PREFIX = '/sys/bus/i2c/devices/{}-00{}/'\n    BASE_VAL_PATH = '{0}'\n    FAN_DUTY_PATH = 'fan{0}_pwm'\n\n    #logfile = ''\n    #loglevel = self.logger.INFO\n\n    \"\"\" Dictionary where\n        key1 = fan id index (integer) starting from 1\n        key2 = fan node index (interger) starting from 1\n        value = path to fan device file (string) \"\"\"\n    dev_paths = {}\n    \n    node_postfix = [\"fault\", \"direction\"]\n    def _get_fan_to_device_node(self, fan_num, node_num):\n        return \"fan{0}_{1}\".format(fan_num, self.node_postfix[node_num-1])\n    \n    def _get_fan_i2c_bus_addr(self):\n        cmd_template = 'i2cget -f -y {} 0x{} 0'\n        for bus_no, dev_addr in self.I2CADDR_CANDIDATES:\n            cmd = cmd_template.format(bus_no, dev_addr)\n            if subprocess.getstatusoutput(cmd)[0] == 0:\n                return bus_no, dev_addr\n        raise IOError('Unable to reach fan CPLD via I2C')\n\n    def _init_fnode_basepath(self):\n        '''format BASE_VAL_PATH and FAN_DUTY_PATH '''\n        bus, addr = self._get_fan_i2c_bus_addr()\n        self.PATH_PREFIX = self.PATH_PREFIX.format(bus, addr)\n        self.BASE_VAL_PATH = self.PATH_PREFIX + self.BASE_VAL_PATH\n        self.FAN_DUTY_PATH = self.PATH_PREFIX + self.FAN_DUTY_PATH\n\n    def _get_fan_node_val(self, fan_num, node_num):\n        if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM:\n            self.logger.debug('GET. Parameter error. fan_num:%d', fan_num)\n            return None\n\n        if node_num < self.FAN_FAULT_IDX or node_num > self.FAN_NODE_NUM:\n            self.logger.debug('GET. Parameter error. node_num:%d', node_num)\n            return None\n\n        device_path = self.get_fan_to_device_path(fan_num, node_num)\n       \n        try:\n            val_file = open(device_path, 'r')\n        except IOError as e:\n            self.logger.error('GET. unable to open file: %s', str(e))\n            return None\n\n        content = val_file.readline().rstrip()\n        \n        if content == '':\n            self.logger.debug('GET. content is NULL. device_path:%s', device_path)\n            return None\n\n        try:\n            val_file.close()\n        except:\n            self.logger.debug('GET. unable to close file. device_path:%s', device_path)\n            return None\n\n        return int(content)\n\n    def _set_fan_node_val(self, fan_num, node_num, val):\n        if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM:\n            self.logger.debug('GET. Parameter error. fan_num:%d', fan_num)\n            return None\n\n        if node_num < self.FAN_FAULT_IDX or node_num > self.FAN_NODE_NUM:\n            self.logger.debug('GET. Parameter error. node_num:%d', node_num)\n            return None\n\n        content = str(val)\n        if content == '':\n            self.logger.debug('GET. content is NULL. device_path:%s', device_path)\n            return None\n\n        device_path = self.get_fan_to_device_path(fan_num, node_num)\n        try:\n            val_file = open(device_path, 'w')\n        except IOError as e:\n            self.logger.error('GET. unable to open file: %s', str(e))\n            return None\n\n        val_file.write(content)\n\n        try:\n            val_file.close()\n        except:\n            self.logger.debug('GET. unable to close file. device_path:%s', device_path)\n            return None\n\n        return True\n\n    logger = logging.getLogger(__name__)\n    def __init__(self, log_level=logging.DEBUG):\n        ch = logging.StreamHandler()\n        ch.setLevel(log_level)\n        self.logger.addHandler(ch)\n\n        self._init_fnode_basepath()\n        fan_path = self.BASE_VAL_PATH \n        for fan_num in range(self.FAN_NUM_1_IDX, self.FAN_TOTAL_NUM+1):\n            for node_num in range(1, self.FAN_NODE_NUM+1):\n                node = self._get_fan_to_device_node(fan_num, node_num)\n                self.dev_paths[(fan_num, node_num)] = fan_path.format(node)\n               \n    def get_num_fans(self):\n        return self.FAN_TOTAL_NUM\n\n    def get_idx_fan_start(self):\n        return self.FAN_NUM_1_IDX\n\n    def get_num_nodes(self):\n        return self.FAN_NODE_NUM\n\n    def get_idx_node_start(self):\n        return self.FAN_FAULT_IDX\n\n    def get_size_node_map(self):\n        return len(self.dev_paths)\n\n    def get_size_path_map(self):\n        return len(self.dev_paths)\n\n    def get_fan_to_device_path(self, fan_num, node_num):\n        return self.dev_paths[(fan_num, node_num)]\n\n    def get_fan_fault(self, fan_num):\n        return self._get_fan_node_val(fan_num, self.FAN_FAULT_IDX)\n\n    #def get_fan_speed(self, fan_num):\n    #    return self._get_fan_node_val(fan_num, self.FAN_SPEED_IDX)\n\n    def get_fan_dir(self, fan_num):\n        return self._get_fan_node_val(fan_num, self.FAN_DIR_IDX)\n\n    def get_fan_duty_cycle(self):\n        try:\n            val_file = open(self.FAN_DUTY_PATH.format(1))\n        except IOError as e:\n            print(\"Error: unable to open file: %s\" % str(e))          \n            return False\n\n        content = val_file.readline().rstrip()\n        val_file.close()\n        return int(content)\n\n    def set_fan_duty_cycle(self, val):\n        for fan_num in range(1, self.FAN_TOTAL_NUM+1):\n            try:\n                fan_file = open(self.FAN_DUTY_PATH.format(fan_num), 'r+')\n            except IOError as e:\n                print(\"Error: unable to open file: %s\" % str(e))          \n                return False\n            fan_file.write(str(val))\n            fan_file.close()\n        return True\n\n    def get_fan_status(self, fan_num):\n        if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM:\n            self.logger.debug('GET. Parameter error. fan_num, %d', fan_num)\n            return None\n\n        if self.get_fan_fault(fan_num) is not None and self.get_fan_fault(fan_num) > 0:\n            self.logger.debug('GET. FAN fault. fan_num, %d', fan_num)\n            return False\n\n        #if self.get_fanr_fault(fan_num) is not None and self.get_fanr_fault(fan_num) > 0:\n        #    self.logger.debug('GET. FANR fault. fan_num, %d', fan_num)\n        #   return False\n\n        return True\n\n#def main():\n#    fan = FanUtil()\n#\n#    print 'get_size_node_map : %d' % fan.get_size_node_map()\n#    print 'get_size_path_map : %d' % fan.get_size_path_map()\n#    for x in range(fan.get_idx_fan_start(), fan.get_num_fans()+1):\n#        for y in range(fan.get_idx_node_start(), fan.get_num_nodes()+1):\n#            print fan.get_fan_to_device_path(x, y)\n#\n#if __name__ == '__main__':\n#    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py": {"changes": [{"diff": "\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py", "badparts": ["               os.system('reboot')           "], "goodparts": ["               subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is clear", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}], "source": "\n try: import os import getopt import sys import logging import logging.config import logging.handlers import time from as7326_56x.fanutil import FanUtil from as7326_56x.thermalutil import ThermalUtil except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as7326_monitor' global log_file global log_level class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False fan_policy_state=1 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0, 0, 0, 0, 0] class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 logging.debug('temp=%d', temp) for i in range(0, len(policy)): if temp > policy[i][0]: if temp <=policy[i][1]: state=policy[i][2] logging.debug('temp=%d >=policy[%d][0]=%d, temp=%d < policy[%d][1]=%d', temp, i, policy[i][0], temp, i, policy[i][1]) logging.debug('fan_state=%d', state) if state==0: state=policy[0][2] logging.debug('set default state') return state def manage_fans(self): thermal_pwm_list={} LEVEL_FAN_DEF=1 LEVEL_FAN_MID=2 LEVEL_FAN_MAX=3 LEVEL_TEMP_HIGH=4 LEVEL_TEMP_CRITICAL=5 fan_policy_state_pwm_tlb={ LEVEL_FAN_DEF: [38, 0x4], LEVEL_FAN_MID: [75, 0xB], LEVEL_FAN_MAX: [100, 0xE], LEVEL_TEMP_HIGH: [100, 0xE], LEVEL_TEMP_CRITICAL: [100, 0xE], } global fan_policy_state global fan_fail global test_temp global test_temp_list global alarm_state fan_policy={ 0:[0, 39000, LEVEL_FAN_DEF], 1:[39000, 45000, LEVEL_FAN_MID], 2:[45000, 61000, LEVEL_FAN_MAX], 3:[61000, 66000, LEVEL_TEMP_HIGH], 4:[66000, 200000, LEVEL_TEMP_CRITICAL], } thermal=ThermalUtil() fan=FanUtil() ori_pwm=fan.get_fan_duty_cycle() new_pwm=0 logging.debug('test_temp=%d', test_temp) if test_temp==0: temp1=thermal._get_thermal_val(1) temp2=thermal._get_thermal_val(2) temp3=thermal._get_thermal_val(3) temp4=thermal._get_thermal_val(4) temp5=thermal._get_thermal_val(5) temp6=0 else: temp1=test_temp_list[0] temp2=test_temp_list[1] temp3=test_temp_list[2] temp4=test_temp_list[3] temp5=test_temp_list[4] temp6=0 fan_fail=0 if temp2==0: temp_get=50000 logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%') elif temp2==0: temp_get=50000 logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%') else: temp_get=(temp2 +temp4)/2 ori_state=fan_policy_state fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy) logging.debug('lm75_48=%d, lm75_49=%d, lm75_4a=%d, lm_4b=%d, cpu=%d, bcm=%d', temp1,temp2,temp3,temp4,temp5,temp6) logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state) new_pwm=fan_policy_state_pwm_tlb[fan_policy_state][0] if fan_fail==0: logging.debug('new_pwm=%d', new_pwm) if fan_fail==0: if new_pwm!=ori_pwm: fan.set_fan_duty_cycle(new_pwm) logging.info('Set fan speed from %d to %d', ori_pwm, new_pwm) for i in range(fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1): if fan.get_fan_status(i)==0: new_pwm=100 logging.debug('fan_%d fail, set pwm to 100',i) if test_temp==0: fan_fail=1 fan.set_fan_duty_cycle(new_pwm) break else: fan_fail=0 new_state=fan_policy_state if ori_state==LEVEL_FAN_DEF: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected, reboot DUT') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MID: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MAX: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if alarm_state==1: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_HIGH: if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if new_state <=LEVEL_FAN_MID: logging.warning('Alarm for temperature high is cleared') alarm_state=0 if new_state <=LEVEL_FAN_MAX: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_CRITICAL: if new_state <=LEVEL_FAN_MAX: logging.warning('Alarm for temperature critical is cleared') return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv,'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv)!=8: print(\"temp test, need input six temp\") return 0 i=0 for x in range(2, 8): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) fan=FanUtil() fan.set_fan_duty_cycle(38) print(\"set default fan speed to 37.5%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(5) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2017 Accton Technology Corporation\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    mm/dd/yyyy (A.D.)\n#    3/23/2018: Roy Lee modify for as7326_56x\n#    6/26/2018: Jostar implement by new thermal policy from HW RD\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import getopt\n    import sys\n    import logging\n    import logging.config\n    import logging.handlers\n    import time  # this is only being used as part of the example\n    from as7326_56x.fanutil import FanUtil\n    from as7326_56x.thermalutil import ThermalUtil\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as7326_monitor'\n\nglobal log_file\nglobal log_level\n\n\n#Default FAN speed: 37.5%(0x05)\n#Ori is that detect: (U45_BCM56873 + Thermal sensor_LM75_CPU:0x4B) /2 \n#New Detect: (sensor_LM75_49 + Thermal sensor_LM75_CPU_4B) /2 \n#Thermal policy: Both F2B and B2F\n#1.\t(sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 =< 39C   , Keep 37.5%(0x05) Fan speed\n#2.\t(sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 39C   , Change Fan speed from 37.5%(0x05) to % 75%(0x0B)\n#3.\t(sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 45C   , Change Fan speed from 75%(0x0B) to 100%(0x0F)\n#4.\t(sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 61C   , Send alarm message\n#5.\t(sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 66C   , Shutdown system\n#6.\tOne Fan fail      , Change Fan speed to 100%(0x0F)\n\n#fan-dev 0-11 speed 0x05     Setup fan speed 37.50%\t\t\n#fan-dev 0-11 speed 0xB      Setup fan speed 75%\t\t\n#fan-dev 0-11 speed 0xF      Setup fan speed 100.00%\t\t\n\n\nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n \n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n     \n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args: # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\n\nfan_policy_state=1\nfan_fail=0\nalarm_state = 0 #0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0, 0, 0, 0, 0]\n\n# Make a class we can use to capture stdout and sterr in the log\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm=0\n    ori_pwm = 0\n    default_pwm=0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format= '[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = handler = logging.handlers.SysLogHandler(address = '/dev/log')\n        sys_handler.setLevel(logging.WARNING)       \n        logging.getLogger('').addHandler(sys_handler)\n\n        #logging.debug('SET. logfile:%s / loglevel:%d', log_file, log_level)\n          \n    def get_state_from_fan_policy(self, temp, policy):\n        state=0\n        logging.debug('temp=%d', temp)\n        for i in range(0, len(policy)):\n            #logging.debug('policy[%d][0]=%d, policy[%d][1]=%d', i,policy[i][0],i, policy[i][1])\n            if temp > policy[i][0]:\n                if temp <= policy[i][1]:\n                    state =policy[i][2]\n                    logging.debug ('temp=%d >= policy[%d][0]=%d,  temp=%d < policy[%d][1]=%d' , temp, i, policy[i][0], temp, i, policy[i][1])\n                    logging.debug ('fan_state=%d', state)\n        if state==0:\n            state=policy[0][2] #below fan_min, set to default pwm\n            logging.debug('set default state')\n        return state\n    \n    def manage_fans(self):\n        \n        thermal_pwm_list = {} #Ori sort is lm75_48, 49, 4a, 4b, cpu, bcm\n                              # After get pwm, do sort to get max pwm.\n        LEVEL_FAN_DEF=1\n        LEVEL_FAN_MID=2       \n        LEVEL_FAN_MAX=3\n        LEVEL_TEMP_HIGH=4\n        LEVEL_TEMP_CRITICAL=5         \n        \n        fan_policy_state_pwm_tlb = {\n        LEVEL_FAN_DEF:          [38,  0x4],\n        LEVEL_FAN_MID:          [75,  0xB],     \n        LEVEL_FAN_MAX:          [100, 0xE],\n        LEVEL_TEMP_HIGH:        [100, 0xE],\n        LEVEL_TEMP_CRITICAL:    [100, 0xE],\n        }\n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list        \n        global alarm_state\n        fan_policy ={\n        0: [0,     39000,   LEVEL_FAN_DEF],  #F2B_policy, B2F_plicy, PWM, reg_val\n        1: [39000, 45000,   LEVEL_FAN_MID],  \n        2: [45000, 61000,   LEVEL_FAN_MAX],\n        3: [61000, 66000,   LEVEL_TEMP_HIGH],        \n        4: [66000, 200000,  LEVEL_TEMP_CRITICAL],        \n        }\n              \n        thermal = ThermalUtil()\n        fan = FanUtil()\n        #fan_dir=fan.get_fan_dir(1)            \n        #if fan_dir > 1:\n        #    fan_dri=1 #something wrong, set fan_dir to default val\n        #if fan_dir < 0:\n        #    fan_dri=1 #something wrong, set fan_dir to default val\n        ori_pwm=fan.get_fan_duty_cycle()\n        new_pwm=0  \n        #logging.debug('fan_dir=%d, ori_pwm=%d', fan_dir, ori_pwm)\n        logging.debug('test_temp=%d', test_temp)\n        if test_temp==0: \n            temp1 = thermal._get_thermal_val(1)\n            temp2 = thermal._get_thermal_val(2)\n            temp3 = thermal._get_thermal_val(3)\n            temp4 = thermal._get_thermal_val(4)\n            temp5 = thermal._get_thermal_val(5)\n            temp6=0\n        else:\n            temp1 = test_temp_list[0]\n            temp2 = test_temp_list[1]\n            temp3 = test_temp_list[2]\n            temp4 = test_temp_list[3]\n            temp5 = test_temp_list[4]\n            temp6=0\n            fan_fail=0\n       \n        if temp2==0:\n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%')\n        elif temp2==0:        \n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%')\n        else:    \n            temp_get= (temp2 + temp4)/2  # Use (sensor_LM75_49 + Thermal sensor_LM75_CPU_4B) /2 \n        ori_state=fan_policy_state\n        fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy)    \n        logging.debug('lm75_48=%d, lm75_49=%d, lm75_4a=%d, lm_4b=%d, cpu=%d, bcm=%d', temp1,temp2,temp3,temp4,temp5,temp6)\n        logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state)\n        new_pwm = fan_policy_state_pwm_tlb[fan_policy_state][0]\n        if fan_fail==0:\n            logging.debug('new_pwm=%d', new_pwm)\n        \n        if fan_fail==0:\n            if new_pwm!=ori_pwm:\n                fan.set_fan_duty_cycle(new_pwm)\n                logging.info('Set fan speed from %d to %d', ori_pwm, new_pwm)\n        \n        for i in range (fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1):\n            if fan.get_fan_status(i)==0:\n                new_pwm=100\n                logging.debug('fan_%d fail, set pwm to 100',i)\n                if test_temp==0:\n                    fan_fail=1\n                    fan.set_fan_duty_cycle(new_pwm)\n                    break\n            else:\n                fan_fail=0        \n       \n        new_state = fan_policy_state       \n        \n        if ori_state==LEVEL_FAN_DEF:            \n           if new_state==LEVEL_TEMP_HIGH:\n               if alarm_state==0:\n                   logging.warning('Alarm for temperature high is detected')\n               alarm_state=1\n           if new_state==LEVEL_TEMP_CRITICAL:\n               logging.critical('Alarm for temperature critical is detected, reboot DUT')\n               time.sleep(2)\n               os.system('reboot')           \n        if ori_state==LEVEL_FAN_MID:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state=1 \n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n        if ori_state==LEVEL_FAN_MAX:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected') \n                alarm_state=1\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n            if alarm_state==1:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_HIGH:\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n            if new_state <= LEVEL_FAN_MID:\n                logging.warning('Alarm for temperature high is cleared')\n                alarm_state=0\n            if new_state <= LEVEL_FAN_MAX:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_CRITICAL:            \n            if new_state <= LEVEL_FAN_MAX:\n                logging.warning('Alarm for temperature critical is cleared')\n      \n        return True\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv,'hdlt:',['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg            \n        \n        if sys.argv[1]== '-t':\n            if len(sys.argv)!=8:\n                print(\"temp test, need input six temp\")\n                return 0\n            \n            i=0\n            for x in range(2, 8):\n               test_temp_list[i]= int(sys.argv[x])*1000\n               i=i+1\n            test_temp = 1   \n            log_level = logging.DEBUG\n            print(test_temp_list)                       \n    \n    fan = FanUtil()\n    fan.set_fan_duty_cycle(38)\n    print(\"set default fan speed to 37.5%\")\n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(5)\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    \n"}, "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py": {"changes": [{"diff": "\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n         if ori_state == LEVEL_FAN_MID:\n             if new_state == LEVEL_TEMP_HIGH:\n                 if alarm_state == 0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n         if ori_state == LEVEL_FAN_MAX:\n             if new_state == LEVEL_TEMP_HIGH:\n                 if alarm_state == 0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if alarm_state == 1:\n                 if temp_get < (fan_policy[3][0] - 5000):  # below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is cleare", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}], "source": "\n try: import os import sys import getopt import logging import logging.config import logging.handlers import time from sonic_platform import platform except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='accton_as7326_56x_monitor' platform_chassis=None fan_policy_state=1 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0] temp_test_data=0 test_temp_revert=0 class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 logging.debug('temp=%d', temp) for i in range(0, len(policy)): if temp > policy[i][0]: if temp <=policy[i][1]: state=policy[i][2] logging.debug('temp=%d >=policy[%d][0]=%d, temp=%d < policy[%d][1]=%d', temp, i, policy[i][0], temp, i, policy[i][1]) logging.debug('fan_state=%d', state) if state==0: state=policy[0][2] logging.debug('set default state') return state def manage_fans(self): LEVEL_FAN_DEF=1 LEVEL_FAN_MID=2 LEVEL_FAN_MAX=3 LEVEL_TEMP_HIGH=4 LEVEL_TEMP_CRITICAL=5 FAN_NUM=2 FAN_TRAY_NUM=6 fan_policy_state_pwm_tlb={ LEVEL_FAN_DEF: [38, 0x4], LEVEL_FAN_MID: [75, 0xB], LEVEL_FAN_MAX: [100, 0xE], LEVEL_TEMP_HIGH: [100, 0xE], LEVEL_TEMP_CRITICAL: [100, 0xE], } global platform_chassis global fan_policy_state global fan_fail global test_temp global test_temp_list global temp_test_data global test_temp_revert global alarm_state fan_policy={ 0:[0, 39000, LEVEL_FAN_DEF], 1:[39000, 45000, LEVEL_FAN_MID], 2:[45000, 61000, LEVEL_FAN_MAX], 3:[61000, 66000, LEVEL_TEMP_HIGH], 4:[66000, 200000, LEVEL_TEMP_CRITICAL], } ori_perc=platform_chassis.get_fan(0).get_speed() if test_temp==0: temp2=platform_chassis.get_thermal(1).get_temperature()*1000 temp4=platform_chassis.get_thermal(3).get_temperature()*1000 else: temp2=test_temp_list[0] temp4=test_temp_list[1] if test_temp_revert==0: temp_test_data=temp_test_data+2000 else: temp_test_data=temp_test_data-2000 if temp2==0: temp_get=50000 logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%') elif temp4==0: temp_get=50000 logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%') else: temp_get=(temp2 +temp4)/2 logging.debug('Begeinning,fan_policy_state=%d', fan_policy_state) if test_temp==1: temp_get=temp_get+temp_test_data ori_state=fan_policy_state fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy) logging.debug('temp2=lm75_49=%d,temp4=lm_4b=%d, temp_get=%d, ori_state=%d', temp2, temp4, temp_get, ori_state) if fan_policy_state > ori_state: logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state) new_perc=fan_policy_state_pwm_tlb[fan_policy_state][0] if fan_fail==0: if new_perc !=ori_perc: platform_chassis.get_fan(0).set_speed(new_perc) logging.info('Set fan speed from %d to %d', ori_perc, new_perc) for i in range(FAN_TRAY_NUM * FAN_NUM): if not platform_chassis.get_fan(i).get_status() or not platform_chassis.get_fan(i).get_speed_rpm(): new_perc=100 logging.debug('fan_%d fail, set new_perc to 100', i+1) fan_fail=1 if ori_state < LEVEL_FAN_MAX: fan_policy_state=new_state=LEVEL_FAN_MAX logging.debug('fan_policy_state=%d', fan_policy_state) logging.warning('fan_policy_state is LEVEL_FAN_MAX') platform_chassis.get_fan(0).set_speed(new_perc) break else: fan_fail=0 if fan_fail==0: new_state=fan_policy_state else: if fan_policy_state > ori_state: new_state=fan_policy_state else: fan_policy_state=new_state=LEVEL_FAN_MAX if ori_state==LEVEL_FAN_DEF: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected, reboot DUT') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MID: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MAX: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if alarm_state==1: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_HIGH: if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if new_state <=LEVEL_FAN_MID: logging.warning('Alarm for temperature high is cleared') alarm_state=0 if new_state <=LEVEL_FAN_MAX: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_CRITICAL: if new_state <=LEVEL_FAN_MAX: logging.warning('Alarm for temperature critical is cleared') return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv, 'hdlt:',['lfile=']) except getopt.GetoptError: print(('Usage: %s[-d][-l <log_file>]' % sys.argv[0])) return 0 for opt, arg in opts: if opt=='-h': print(('Usage: %s[-d][-l <log_file>]' % sys.argv[0])) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv) !=4: print(\"temp test, need input four temp\") return 0 i=0 for x in range(2, 4): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) global platform_chassis platform_chassis=platform.Platform().get_chassis() platform_chassis.get_fan(0).set_speed(38) print(\"set default fan speed to 37.5%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(5) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    mm/dd/yyyy (A.D.)\n#    3/23/2018: Roy Lee modify for as7326_56x\n#    6/26/2018: Jostar implement by new thermal policy from HW RD\n#    09/18/2020: Jostar Yang, change to call PDDF API .\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import sys\n    import getopt\n    import logging\n    import logging.config\n    import logging.handlers\n    import time\n    from sonic_platform import platform\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = 'accton_as7326_56x_monitor'\n\nplatform_chassis = None\n\n# Default FAN speed: 37.5%(0x05)\n# Ori is that detect: (U45_BCM56873 + Thermal sensor_LM75_CPU:0x4B) /2\n# New Detect: (sensor_LM75_49 + Thermal sensor_LM75_CPU_4B) /2\n# Thermal policy: Both F2B and B2F\n# 1.    (sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 =< 39C   , Keep 37.5%(0x05) Fan speed\n# 2.    (sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 39C   , Change Fan speed from 37.5%(0x05) to % 75%(0x0B)\n# 3.    (sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 45C   , Change Fan speed from 75%(0x0B) to 100%(0x0F)\n# 4.    (sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 61C   , Send alarm message\n# 5.    (sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 66C   , Shutdown system\n# 6.    One Fan fail      , Change Fan speed to 100%(0x0F)\n\n# fan-dev 0-11 speed 0x05     Setup fan speed 37.50%\n# fan-dev 0-11 speed 0xB      Setup fan speed 75%\n# fan-dev 0-11 speed 0xF      Setup fan speed 100.00%\n\nfan_policy_state = 1\nfan_fail = 0\nalarm_state = 0  # 0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0]\ntemp_test_data = 0\ntest_temp_revert = 0\n\n# Make a class we can use to capture stdout and sterr in the log\n\n\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm = 0\n    ori_pwm = 0\n    default_pwm = 0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format='[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = logging.handlers.SysLogHandler(address='/dev/log')\n        sys_handler.setLevel(logging.WARNING)\n        logging.getLogger('').addHandler(sys_handler)\n\n    def get_state_from_fan_policy(self, temp, policy):\n        state = 0\n        logging.debug('temp=%d', temp)\n        for i in range(0, len(policy)):\n            #logging.debug('policy[%d][0]=%d, policy[%d][1]=%d', i,policy[i][0],i, policy[i][1])\n            if temp > policy[i][0]:\n                if temp <= policy[i][1]:\n                    state = policy[i][2]\n                    logging.debug('temp=%d >= policy[%d][0]=%d,  temp=%d < policy[%d][1]=%d',\n                                  temp, i, policy[i][0], temp, i, policy[i][1])\n                    logging.debug('fan_state=%d', state)\n        if state == 0:\n            state = policy[0][2]  # below fan_min, set to default pwm\n            logging.debug('set default state')\n        return state\n\n    def manage_fans(self):\n        LEVEL_FAN_DEF = 1\n        LEVEL_FAN_MID = 2\n        LEVEL_FAN_MAX = 3\n        LEVEL_TEMP_HIGH = 4\n        LEVEL_TEMP_CRITICAL = 5\n\n        FAN_NUM = 2\n        FAN_TRAY_NUM = 6\n\n        fan_policy_state_pwm_tlb = {\n            LEVEL_FAN_DEF:          [38,  0x4],\n            LEVEL_FAN_MID:          [75,  0xB],\n            LEVEL_FAN_MAX:          [100, 0xE],\n            LEVEL_TEMP_HIGH:        [100, 0xE],\n            LEVEL_TEMP_CRITICAL:    [100, 0xE],\n        }\n        global platform_chassis\n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list\n        global temp_test_data\n        global test_temp_revert\n        global alarm_state\n        fan_policy = {\n            0: [0,     39000,   LEVEL_FAN_DEF],  # F2B_policy, B2F_plicy, PWM, reg_val\n            1: [39000, 45000,   LEVEL_FAN_MID],\n            2: [45000, 61000,   LEVEL_FAN_MAX],\n            3: [61000, 66000,   LEVEL_TEMP_HIGH],\n            4: [66000, 200000,  LEVEL_TEMP_CRITICAL],\n        }\n        \n        ori_perc = platform_chassis.get_fan(0).get_speed()\n        #logging.debug('test_temp=%d', test_temp)\n        if test_temp == 0:\n            temp2 = platform_chassis.get_thermal(1).get_temperature()*1000\n            temp4 = platform_chassis.get_thermal(3).get_temperature()*1000\n        else:\n            temp2 = test_temp_list[0]\n            temp4 = test_temp_list[1]\n            # fan_fail=0 # When test no-fan DUT. Need to use this.\n            if test_temp_revert == 0:\n                temp_test_data = temp_test_data+2000\n            else:\n                temp_test_data = temp_test_data-2000\n\n        if temp2 == 0:\n            temp_get = 50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75%\n            logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%')\n        elif temp4 == 0:\n            temp_get = 50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75%\n            logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%')\n        else:\n            temp_get = (temp2 + temp4)/2  # Use (sensor_LM75_49 + Thermal sensor_LM75_CPU_4B) /2\n        logging.debug('Begeinning ,fan_policy_state=%d', fan_policy_state)\n        if test_temp == 1:\n            temp_get = temp_get+temp_test_data\n\n        ori_state = fan_policy_state\n        fan_policy_state = self.get_state_from_fan_policy(temp_get, fan_policy)\n        #logging.debug(\"temp2=\" + str(temp2))\n        #logging.debug(\"temp4=\" + str(temp4))\n        #logging.debug(\"temp_get=\" + str(temp_get))\n        logging.debug('temp2=lm75_49=%d,temp4=lm_4b=%d, temp_get=%d, ori_state=%d', temp2, temp4, temp_get, ori_state)\n        if fan_policy_state > ori_state:\n            logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state)\n        new_perc = fan_policy_state_pwm_tlb[fan_policy_state][0]\n\n        if fan_fail == 0:\n            if new_perc != ori_perc:\n                # fan.set_fan_duty_cycle(new_perc)\n                platform_chassis.get_fan(0).set_speed(new_perc)\n                logging.info('Set fan speed from %d to %d', ori_perc, new_perc)\n\n        # for i in range (fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1):\n        for i in range(FAN_TRAY_NUM * FAN_NUM):\n            if not platform_chassis.get_fan(i).get_status() or not platform_chassis.get_fan(i).get_speed_rpm():\n                new_perc = 100\n                logging.debug('fan_%d fail, set new_perc to 100', i+1)\n                # if test_temp==0:# When test no-fan DUT. Need to use this.\n                fan_fail = 1\n                if ori_state < LEVEL_FAN_MAX:\n                    fan_policy_state = new_state = LEVEL_FAN_MAX\n                    logging.debug('fan_policy_state=%d', fan_policy_state)\n                    logging.warning('fan_policy_state is LEVEL_FAN_MAX')\n                platform_chassis.get_fan(0).set_speed(new_perc)\n                break\n            else:\n                fan_fail = 0\n\n        if fan_fail == 0:\n            new_state = fan_policy_state\n        else:\n            if fan_policy_state > ori_state:\n                new_state = fan_policy_state\n            else:\n                fan_policy_state = new_state = LEVEL_FAN_MAX\n\n        if ori_state == LEVEL_FAN_DEF:\n            if new_state == LEVEL_TEMP_HIGH:\n                if alarm_state == 0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state = 1\n            if new_state == LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n                os.system('reboot')\n        if ori_state == LEVEL_FAN_MID:\n            if new_state == LEVEL_TEMP_HIGH:\n                if alarm_state == 0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state = 1\n            if new_state == LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n        if ori_state == LEVEL_FAN_MAX:\n            if new_state == LEVEL_TEMP_HIGH:\n                if alarm_state == 0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state = 1\n            if new_state == LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n            if alarm_state == 1:\n                if temp_get < (fan_policy[3][0] - 5000):  # below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state = 0\n        if ori_state == LEVEL_TEMP_HIGH:\n            if new_state == LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n            if new_state <= LEVEL_FAN_MID:\n                logging.warning('Alarm for temperature high is cleared')\n                alarm_state = 0\n            if new_state <= LEVEL_FAN_MAX:\n                if temp_get < (fan_policy[3][0] - 5000):  # below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state = 0\n        if ori_state == LEVEL_TEMP_CRITICAL:\n            if new_state <= LEVEL_FAN_MAX:\n                logging.warning('Alarm for temperature critical is cleared')\n\n        return True\n\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv, 'hdlt:', ['lfile='])\n        except getopt.GetoptError:\n            print(('Usage: %s [-d] [-l <log_file>]' % sys.argv[0]))\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print(('Usage: %s [-d] [-l <log_file>]' % sys.argv[0]))\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg\n\n        if sys.argv[1] == '-t':\n            if len(sys.argv) != 4:\n                print(\"temp test, need input four temp\")\n                return 0\n\n            i = 0\n            for x in range(2, 4):\n                test_temp_list[i] = int(sys.argv[x])*1000\n                i = i+1\n            test_temp = 1\n            log_level = logging.DEBUG\n            print(test_temp_list)\n\n    global platform_chassis\n    platform_chassis = platform.Platform().get_chassis()\n\n    platform_chassis.get_fan(0).set_speed(38)\n\n    print(\"set default fan speed to 37.5%\")\n    monitor = device_monitor(log_file, log_level)\n\n    while True:\n        monitor.manage_fans()\n        time.sleep(5)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py": {"changes": [{"diff": "\n \n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\n", "add": 6, "remove": 6, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py", "badparts": ["    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cdump -y 0 0x42 s 0x9a\"", "        status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]", "        status, output = getstatusoutput_noshell(cmd)"]}, {"diff": "\n     return 0\n \n def eeprom_check():\n-    cmd = \"i2cget -y -f 0 0x56\"\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cget\", \"-y\", \"-f\", \"0\", \"0x56\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     r", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py", "badparts": ["    cmd = \"i2cget -y -f 0 0x56\"", "    status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cget\", \"-y\", \"-f\", \"0\", \"0x56\"]", "    status, output = getstatusoutput_noshell(cmd)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes \"\"\" import subprocess import getopt import sys import logging import re import time import os PROJECT_NAME='as7326_56x' version='0.1.0' verbose=False DEBUG=False args=[] ALL_DEVICE={} DEVICE_NO={'led':5, 'fan':6,'thermal':4, 'psu':2, 'sfp':58} FORCE=0 if DEBUG==True: print(sys.argv[0]) print('ARGV :', sys.argv[1:]) def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print(options) print(args) print(len(sys.argv)) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': do_install() elif arg=='api': do_sonic_platform_install() elif arg=='api_clean': do_sonic_platform_clean() elif arg=='clean': do_uninstall() else: show_help() return 0 def show_help(): print(__doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]}) sys.exit(0) def dis_i2c_ir3570a(addr): cmd=\"i2cset -y 0 0x%x 0xE5 0x01\" % addr status, output=subprocess.getstatusoutput(cmd) cmd=\"i2cset -y 0 0x%x 0x12 0x02\" % addr status, output=subprocess.getstatusoutput(cmd) return status def ir3570_check(): cmd=\"i2cdump -y 0 0x42 s 0x9a\" try: status, output=subprocess.getstatusoutput(cmd) lines=output.split('\\n') hn=re.findall(r'\\w+', lines[-1]) version=int(hn[1], 16) if version==0x24: ret=dis_i2c_ir3570a(4) else: ret=0 except Exception as e: print(\"Error on ir3570_check() e:\" +str(e)) return -1 return ret def my_log(txt): if DEBUG==True: print(\"[ROY]\"+txt) return def log_os_system(cmd, show): logging.info('Run:'+cmd) status, output=subprocess.getstatusoutput(cmd) my_log(cmd +\"with result:\" +str(status)) my_log(\" output:\"+output) if status: logging.info('Failed:'+cmd) if show: print('Failed:'+cmd) return status, output def driver_check(): ret, lsmod=log_os_system(\"ls /sys/module/*accton*\", 0) logging.info('mods:'+lsmod) if ret: return False else: return True kos=[ 'modprobe i2c_dev', 'modprobe i2c_mux_pca954x', 'modprobe accton_i2c_cpld' , 'modprobe ym2651y' , 'modprobe accton_as7326_56x_fan' , 'modprobe optoe' , 'modprobe accton_as7326_56x_leds' , 'modprobe accton_as7326_56x_psu'] def driver_install(): global FORCE status, output=log_os_system('modprobe i2c_dev', 1) status, output=log_os_system(\"depmod\", 1) for i in range(0,len(kos)): status, output=log_os_system(kos[i], 1) if status: if FORCE==0: return status print(\"Done driver_install\") return 0 def driver_uninstall(): global FORCE for i in range(0,len(kos)): rm=kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\") rm=rm.replace(\"insmod\", \"rmmod\") lst=rm.split(\" \") if len(lst) > 3: del(lst[3]) rm=\" \".join(lst) status, output=log_os_system(rm, 1) if status: if FORCE==0: return status return 0 i2c_prefix='/sys/bus/i2c/devices/' ''' i2c_bus={'fan':['11-0066'] , 'thermal':['15-0048','15-0049', '15-004a', '15-004b'], 'psu':['17-0051','13-0053'], 'sfp':['-0050']} i2c_nodes={'fan':['present', 'front_speed_rpm', 'rear_speed_rpm'], 'thermal':['hwmon/hwmon*/temp1_input'], 'psu':['psu_present ', 'psu_power_good'] , 'sfp':['module_present_', 'module_tx_disable_']} ''' sfp_map=[ 42,41,44,43,47,45,46,50, 48,49,52,51,53,56,55,54, 58,57,60,59,61,63,62,64, 66,68,65,67,69,71,72,70, 74,73,76,75,77,79,78,80, 81,82,84,85,83,87,88,86, 25,26,27,28,29,30,31,32, 22,23] qsfp_start=48 qsfp_end =56 cpld_of_module={'12-0062': list(range(0,30)), \t\t '18-0060': list(range(30,58))} mknod=[ 'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-24/new_device', 'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-33/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-34/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-35/new_device', 'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-36/new_device', 'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-37/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-38/new_device', 'echo as7326_56x_fan 0x66 > /sys/bus/i2c/devices/i2c-11/new_device ', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-15/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-15/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-15/new_device', 'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-15/new_device', 'echo as7326_56x_psu1 0x51 > /sys/bus/i2c/devices/i2c-17/new_device', 'echo ym2651 0x59 > /sys/bus/i2c/devices/i2c-17/new_device', 'echo as7326_56x_psu2 0x53 > /sys/bus/i2c/devices/i2c-13/new_device', 'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-13/new_device', 'echo as7326_56x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo as7326_56x_cpld2 0x62 > /sys/bus/i2c/devices/i2c-12/new_device', 'echo as7326_56x_cpld3 0x64 > /sys/bus/i2c/devices/i2c-19/new_device'] mknod2=[ ] eeprom_mknod=[ 'echo 24c04 0x56 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-0/new_device' ] def i2c_order_check(): return 0 def eeprom_check(): cmd=\"i2cget -y -f 0 0x56\" status, output=subprocess.getstatusoutput(cmd) return status def device_install(): global FORCE order=i2c_order_check() if order: for i in range(0,len(mknod2)): if mknod2[i].find('pca954') !=-1: time.sleep(1) status, output=log_os_system(mknod2[i], 1) if status: print(output) if FORCE==0: return status else: for i in range(0,len(mknod)): if mknod[i].find('pca954') !=-1: time.sleep(1) status, output=log_os_system(mknod[i], 1) if status: print(output) if FORCE==0: return status cmd='echo -2 | tee /sys/bus/i2c/drivers/pca954x/*-00*/idle_state' status, output=log_os_system(cmd, 1) if status: print(output) if FORCE==0: return status log_os_system(\"i2cset -f -y 0 0x77 0 \", 1) ret=eeprom_check() if ret==0: log_os_system(eeprom_mknod[0], 1) time.sleep(0.2) exists=os.path.isfile('/sys/bus/i2c/devices/0-0056/eeprom') if(exists is False): subprocess.call('echo 0x56 > /sys/bus/i2c/devices/i2c-0/delete_device', shell=True) log_os_system(eeprom_mknod[1], 1) else: log_os_system(eeprom_mknod[1], 1) for i in range(0,len(sfp_map)): if i < qsfp_start or i >=qsfp_end: status, output=log_os_system(\"echo optoe2 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1) else: status, output=log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1) if status: print(output) if FORCE==0: return status print(\"Done device_install\") return def device_uninstall(): global FORCE status, output=log_os_system(\"ls /sys/bus/i2c/devices/1-0076\", 0) if status==0: I2C_ORDER=1 else: I2C_ORDER=0 for i in range(0,len(sfp_map)): target=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\" status, output=log_os_system(\"echo 0x50 > \"+target, 1) if status: print(output) if FORCE==0: return status if I2C_ORDER==0: nodelist=mknod else: nodelist=mknod2 for i in range(len(nodelist)): target=nodelist[-(i+1)] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status exists=os.path.isfile('/sys/bus/i2c/devices/0-0056/eeprom') if(exists is True): target=eeprom_mknod[0] else: target=eeprom_mknod[1] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status return def system_ready(): if driver_check()==False: return False if not device_exist(): return False return True PLATFORM_ROOT_PATH='/usr/share/sonic/device' PLATFORM_API2_WHL_FILE_PY3='sonic_platform-1.0-py3-none-any.whl' def do_sonic_platform_install(): device_path=\"{}{}{}{}\".format(PLATFORM_ROOT_PATH, '/x86_64-accton_', PROJECT_NAME, '-r0') SONIC_PLATFORM_BSP_WHL_PKG_PY3=\"/\".join([device_path, PLATFORM_API2_WHL_FILE_PY3]) status, output=log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0) if status: if os.path.exists(SONIC_PLATFORM_BSP_WHL_PKG_PY3): status, output=log_os_system(\"pip3 install \"+SONIC_PLATFORM_BSP_WHL_PKG_PY3, 1) if status: print(\"Error: Failed to install{}\".format(PLATFORM_API2_WHL_FILE_PY3)) return status else: print(\"Successfully installed{} package\".format(PLATFORM_API2_WHL_FILE_PY3)) else: print('{} is not found'.format(PLATFORM_API2_WHL_FILE_PY3)) else: print('{} has installed'.format(PLATFORM_API2_WHL_FILE_PY3)) return def do_sonic_platform_clean(): status, output=log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0) if status: print('{} does not install, not need to uninstall'.format(PLATFORM_API2_WHL_FILE_PY3)) else: status, output=log_os_system(\"pip3 uninstall sonic-platform -y\", 0) if status: print('Error: Failed to uninstall{}'.format(PLATFORM_API2_WHL_FILE_PY3)) return status else: print('{} is uninstalled'.format(PLATFORM_API2_WHL_FILE_PY3)) return def do_install(): print(\"Checking system....\") if driver_check()==False: print(\"No driver, installing....\") status=driver_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" drivers detected....\") ir3570_check() if not device_exist(): print(\"No device, installing....\") status=device_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" devices detected....\") do_sonic_platform_install() return def do_uninstall(): print(\"Checking system....\") if not device_exist(): print(PROJECT_NAME.upper() +\" has no device installed....\") else: print(\"Removing device....\") status=device_uninstall() if status: if FORCE==0: return status if driver_check()==False: print(PROJECT_NAME.upper() +\" has no driver installed....\") else: print(\"Removing installed driver....\") status=driver_uninstall() if status: if FORCE==0: return status do_sonic_platform_clean() return def device_exist(): ret1, log=log_os_system(\"ls \"+i2c_prefix+\"*0070\", 0) ret2, log=log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# Copyright (C) 2016 Accton Networks, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean\ncommand:\n    install     : install drivers and generate related sysfs nodes\n    clean       : uninstall drivers and remove related sysfs nodes\n\"\"\"\nimport subprocess\nimport getopt\nimport sys\nimport logging\nimport re\nimport time\nimport os\n\n\n\nPROJECT_NAME = 'as7326_56x'\nversion = '0.1.0'\nverbose = False\nDEBUG = False\nargs = []\nALL_DEVICE = {}\nDEVICE_NO = {'led':5, 'fan':6,'thermal':4, 'psu':2, 'sfp':58}\nFORCE = 0\n#logging.basicConfig(filename= PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG)\n#logging.basicConfig(level=logging.INFO)\n\n\nif DEBUG == True:\n    print(sys.argv[0])\n    print('ARGV      :', sys.argv[1:])\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n\n    if len(sys.argv)<2:\n        show_help()\n\n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:                \n        print(options)\n        print(args)\n        print(len(sys.argv))\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n           do_install()\n        elif arg == 'api':\n           do_sonic_platform_install()\n        elif arg == 'api_clean':\n           do_sonic_platform_clean()\n        elif arg == 'clean':\n           do_uninstall()\n        else:\n            show_help()\n    return 0\n\ndef show_help():\n    print(__doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]})\n    sys.exit(0)\n\n\n\ndef dis_i2c_ir3570a(addr):\n    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef ir3570_check():\n    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n    try:\n        status, output = subprocess.getstatusoutput(cmd)\n        lines = output.split('\\n')\n        hn = re.findall(r'\\w+', lines[-1])\n        version = int(hn[1], 16)\n        if version == 0x24:  #only for ir3570a\n            ret = dis_i2c_ir3570a(4)\n        else:\n            ret = 0\n    except Exception as e:\n        print(\"Error on ir3570_check() e:\" + str(e))\n        return -1\n    return ret\n\n\ndef my_log(txt):\n    if DEBUG == True:\n        print(\"[ROY]\"+txt)\n    return\n\ndef log_os_system(cmd, show):\n    logging.info('Run :'+cmd)\n    status, output = subprocess.getstatusoutput(cmd)\n    my_log (cmd +\"with result:\" + str(status))\n    my_log (\"      output:\"+output)\n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print('Failed :'+cmd)\n    return  status, output\n\ndef driver_check():\n    ret, lsmod = log_os_system(\"ls /sys/module/*accton*\", 0)\n    logging.info('mods:'+lsmod)\n    if ret :\n        return False\n    else :\n        return True\n\n\n\nkos = [\n'modprobe i2c_dev',\n'modprobe i2c_mux_pca954x',\n'modprobe accton_i2c_cpld'  ,\n'modprobe ym2651y'                  ,\n'modprobe accton_as7326_56x_fan'     ,\n'modprobe optoe'      ,\n'modprobe accton_as7326_56x_leds'      ,\n'modprobe accton_as7326_56x_psu' ]\n\ndef driver_install():\n    global FORCE\n    \n    status, output = log_os_system('modprobe i2c_dev', 1)\n    status, output = log_os_system(\"depmod\", 1)\n    for i in range(0,len(kos)):\n        status, output = log_os_system(kos[i], 1)\n        if status:\n            if FORCE == 0:\n                return status\n    print(\"Done driver_install\")\n    \n    return 0\n\ndef driver_uninstall():\n    global FORCE\n    for i in range(0,len(kos)):\n        rm = kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\")\n        rm = rm.replace(\"insmod\", \"rmmod\")\n        lst = rm.split(\" \")\n        if len(lst) > 3:\n            del(lst[3])\n        rm = \" \".join(lst)\n        status, output = log_os_system(rm, 1)\n        if status:\n            if FORCE == 0:\n                return status\n    return 0\n\ni2c_prefix = '/sys/bus/i2c/devices/'\n'''\ni2c_bus = {'fan': ['11-0066']                 ,\n           'thermal': ['15-0048','15-0049', '15-004a', '15-004b'] ,\n           'psu': ['17-0051','13-0053'],\n           'sfp': ['-0050']}\ni2c_nodes = {'fan': ['present', 'front_speed_rpm', 'rear_speed_rpm'] ,\n           'thermal': ['hwmon/hwmon*/temp1_input'] ,\n           'psu': ['psu_present ', 'psu_power_good']    ,\n           'sfp': ['module_present_', 'module_tx_disable_']}\n'''\nsfp_map =  [\n        42,41,44,43,47,45,46,50,\n        48,49,52,51,53,56,55,54,\n        58,57,60,59,61,63,62,64,\n        66,68,65,67,69,71,72,70,\n        74,73,76,75,77,79,78,80,\n        81,82,84,85,83,87,88,86,    #port 41~48\n        25,26,27,28,29,30,31,32,    #port 49~56 QSFP\n        22,23]                      #port 57~58 SFP+ from CPU NIF.\nqsfp_start = 48\nqsfp_end   = 56\n\n#For sideband signals of SFP/QSFP modules.\ncpld_of_module = {'12-0062': list(range(0,30)),\n\t\t  '18-0060': list(range(30,58)) }\n\n\nmknod =[\n'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-1/new_device' ,\n'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-1/new_device' ,\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-24/new_device' ,\n'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-2/new_device' ,\n'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-33/new_device',\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-34/new_device',\n'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-35/new_device',\n'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-36/new_device',\n'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-37/new_device',\n'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-38/new_device',\n\n'echo as7326_56x_fan 0x66 > /sys/bus/i2c/devices/i2c-11/new_device ',\n'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-15/new_device',\n'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-15/new_device',\n'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-15/new_device',\n'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-15/new_device',\n'echo as7326_56x_psu1 0x51 > /sys/bus/i2c/devices/i2c-17/new_device',\n'echo ym2651 0x59 > /sys/bus/i2c/devices/i2c-17/new_device',\n'echo as7326_56x_psu2 0x53 > /sys/bus/i2c/devices/i2c-13/new_device',\n'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-13/new_device',\n'echo as7326_56x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo as7326_56x_cpld2 0x62 > /sys/bus/i2c/devices/i2c-12/new_device',\n'echo as7326_56x_cpld3 0x64 > /sys/bus/i2c/devices/i2c-19/new_device']\n\nmknod2 =[\n]\n\n#EERPOM\neeprom_mknod =[\n'echo 24c04 0x56 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-0/new_device'\n]\n\n\ndef i2c_order_check():\n    # This project has only 1 i2c bus.\n    return 0\n\ndef eeprom_check():\n    cmd = \"i2cget -y -f 0 0x56\"\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef device_install():\n    global FORCE\n\n    order = i2c_order_check()\n\n    # if 0x70 is not exist @i2c-1, use reversed bus order\n    if order:\n        for i in range(0,len(mknod2)):\n            #for pca954x need times to built new i2c buses\n            if mknod2[i].find('pca954') != -1:\n               time.sleep(1)\n\n            status, output = log_os_system(mknod2[i], 1)\n            if status:\n                print(output)\n                if FORCE == 0:\n                    return status\n    else:\n        for i in range(0,len(mknod)):\n            #for pca954x need times to built new i2c buses\n            if mknod[i].find('pca954') != -1:\n               time.sleep(1)\n\n            status, output = log_os_system(mknod[i], 1)\n            if status:\n                print(output)\n                if FORCE == 0:\n                    return status\n\n    # set all pca954x idle_disconnect\n    cmd = 'echo -2 | tee /sys/bus/i2c/drivers/pca954x/*-00*/idle_state'\n    status, output = log_os_system(cmd, 1)\n    if status:\n        print(output)\n        if FORCE == 0:\n            return status\n    \n    # initiate IDPROM\n    # Close 0x77 mux to make sure if the I2C address of IDPROM is 0x56 or 0x57\n    log_os_system(\"i2cset -f -y 0 0x77 0 \", 1)\n    ret=eeprom_check()\n    if ret==0:\n        log_os_system(eeprom_mknod[0], 1) #old board, 0x56 eeprom\n        time.sleep(0.2)\n        exists = os.path.isfile('/sys/bus/i2c/devices/0-0056/eeprom')\n        if (exists is False):\n            subprocess.call('echo 0x56 > /sys/bus/i2c/devices/i2c-0/delete_device', shell=True)\n            log_os_system(eeprom_mknod[1], 1)\n    else:\n        log_os_system(eeprom_mknod[1], 1) #new board, 0x57 eeprom                \n                    \n                    \n    for i in range(0,len(sfp_map)):\n        if i < qsfp_start or i >= qsfp_end:\n            status, output =log_os_system(\"echo optoe2 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1)\n        else:\n            status, output =log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n    print(\"Done device_install\")\n    return\n\ndef device_uninstall():\n    global FORCE\n\n    status, output =log_os_system(\"ls /sys/bus/i2c/devices/1-0076\", 0)\n    if status==0:\n        I2C_ORDER=1\n    else:\n        I2C_ORDER=0\n\n    for i in range(0,len(sfp_map)):\n        target = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\"\n        status, output =log_os_system(\"echo 0x50 > \"+ target, 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    if I2C_ORDER==0:\n        nodelist = mknod\n    else:\n        nodelist = mknod2\n\n    for i in range(len(nodelist)):\n        target = nodelist[-(i+1)]\n        temp = target.split()\n        del temp[1]\n        temp[-1] = temp[-1].replace('new_device', 'delete_device')\n        status, output = log_os_system(\" \".join(temp), 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    #Deal with for del 0x56 or 0x57 sysfs device    \n    exists = os.path.isfile('/sys/bus/i2c/devices/0-0056/eeprom')\n        \n    if (exists is True):\n        target = eeprom_mknod[0] #0x56\n    else:\n        target = eeprom_mknod[1] #0x57\n    \n    temp = target.split()\n    del temp[1]\n    temp[-1] = temp[-1].replace('new_device', 'delete_device')\n    status, output = log_os_system(\" \".join(temp), 1)\n    if status:\n        print(output)\n        if FORCE == 0:\n           return status\n\n    return\n\ndef system_ready():\n    if driver_check() == False:\n        return False\n    if not device_exist():\n        return False\n    return True\nPLATFORM_ROOT_PATH = '/usr/share/sonic/device'\nPLATFORM_API2_WHL_FILE_PY3 ='sonic_platform-1.0-py3-none-any.whl'\ndef do_sonic_platform_install():\n    device_path = \"{}{}{}{}\".format(PLATFORM_ROOT_PATH, '/x86_64-accton_', PROJECT_NAME, '-r0')\n    SONIC_PLATFORM_BSP_WHL_PKG_PY3 = \"/\".join([device_path, PLATFORM_API2_WHL_FILE_PY3])\n\n    #Check API2.0 on py whl file\n    status, output = log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0)\n    if status:\n        if os.path.exists(SONIC_PLATFORM_BSP_WHL_PKG_PY3): \n            status, output = log_os_system(\"pip3 install \"+ SONIC_PLATFORM_BSP_WHL_PKG_PY3, 1)\n            if status:\n                print(\"Error: Failed to install {}\".format(PLATFORM_API2_WHL_FILE_PY3))\n                return status\n            else:\n                print(\"Successfully installed {} package\".format(PLATFORM_API2_WHL_FILE_PY3))\n        else:\n            print('{} is not found'.format(PLATFORM_API2_WHL_FILE_PY3))\n    else:        \n        print('{} has installed'.format(PLATFORM_API2_WHL_FILE_PY3))\n     \n    return \n     \ndef do_sonic_platform_clean():\n    status, output = log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0)   \n    if status:\n        print('{} does not install, not need to uninstall'.format(PLATFORM_API2_WHL_FILE_PY3))\n        \n    else:        \n        status, output = log_os_system(\"pip3 uninstall sonic-platform -y\", 0)\n        if status:\n            print('Error: Failed to uninstall {}'.format(PLATFORM_API2_WHL_FILE_PY3))\n            return status\n        else:\n            print('{} is uninstalled'.format(PLATFORM_API2_WHL_FILE_PY3))\n    \n    \n    return\n\ndef do_install():\n    print(\"Checking system....\")\n    if driver_check() == False:\n        print(\"No driver, installing....\")\n        status = driver_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print(PROJECT_NAME.upper()+\" drivers detected....\")\n\n    ir3570_check()\n\n    if not device_exist():\n        print(\"No device, installing....\")\n        status = device_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print(PROJECT_NAME.upper()+\" devices detected....\")\n\n    do_sonic_platform_install()\n        \n    return\n\ndef do_uninstall():\n    print(\"Checking system....\")\n    if not device_exist():\n        print(PROJECT_NAME.upper() +\" has no device installed....\")\n    else:\n        print(\"Removing device....\")\n        status = device_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    if driver_check()== False :\n        print(PROJECT_NAME.upper() +\" has no driver installed....\")\n    else:\n        print(\"Removing installed driver....\")\n        status = driver_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    do_sonic_platform_clean()\n\n    return\n\ndef device_exist():\n    ret1, log = log_os_system(\"ls \"+i2c_prefix+\"*0070\", 0)\n    ret2, log = log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as7326-platform-fan.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as7326-platform-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Stop as7326-platform-init.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Disable as7326-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as7326_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n", "add": 7, "remove": 7, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py", "badparts": ["import subprocess", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as7326-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py clean\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7326-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"clean\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"install\"])\n     if status:\n         print(\"accton_as7326_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Enable as7326-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as7326-platform-monitor-fan.service failed %d\"%status)\n         return False\n         \n-    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as7326-platform-monitor-psu.service failed %d\"%status)\n         return False\n", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py install\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as7326-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-psu.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"install\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7326-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-psu.service\"])"]}, {"diff": "\n     return True\n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service fa", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}], "source": "\n import subprocess def check_pddf_support(): return True def stop_platform_svc(): status, output=subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-fan.service\") if status: print(\"Stop as7326-platform-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-psu.service\") if status: print(\"Stop as7326-platform-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor.service\") if status: print(\"Stop as7326-platform-init.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl disable as7326-platform-monitor.service\") if status: print(\"Disable as7326-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py clean\") if status: print(\"accton_as7326_util.py clean command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status) return False return True def start_platform_svc(): status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py install\") if status: print(\"accton_as7326_util.py install command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl enable as7326-platform-monitor.service\") if status: print(\"Enable as7326-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-fan.service\") if status: print(\"Start as7326-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-psu.service\") if status: print(\"Start as7326-platform-monitor-psu.service failed %d\"%status) return False return True def start_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print(\"Start pddf-platform-init.service failed %d\"%status) return False return True def stop_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service failed %d\"%status) return False return True def main(): print(\"stop_platform_svc\") stop_platform_svc() print(\"stop_platform_pddf\") stop_platform_pddf() if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services. \n# This will be used while switching the pddf->non-pddf mode and vice versa\n\nimport subprocess\n\ndef check_pddf_support():\n    return True\n\ndef stop_platform_svc():\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-fan.service\")\n    if status:\n        print(\"Stop as7326-platform-fan.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-psu.service\")\n    if status:\n        print(\"Stop as7326-platform-psu.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor.service\")\n    if status:\n        print(\"Stop as7326-platform-init.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as7326-platform-monitor.service\")\n    if status:\n        print(\"Disable as7326-platform-monitor.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py clean\")\n    if status:\n        print(\"accton_as7326_util.py clean command failed %d\"%status)\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n        return False\n\n    return True\n    \ndef start_platform_svc():\n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py install\")\n    if status:\n        print(\"accton_as7326_util.py install command failed %d\"%status)\n        return False\n\n    status, output = subprocess.getstatusoutput(\"systemctl enable as7326-platform-monitor.service\")\n    if status:\n        print(\"Enable as7326-platform-monitor.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-fan.service\")\n    if status:\n        print(\"Start as7326-platform-monitor-fan.service failed %d\"%status)\n        return False\n        \n    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-psu.service\")\n    if status:\n        print(\"Start as7326-platform-monitor-psu.service failed %d\"%status)\n        return False\n\n    return True\n\ndef start_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print(\"Start pddf-platform-init.service failed %d\"%status)\n        return False\n    \n    return True\n\ndef stop_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service failed %d\"%status)\n        return False\n\n    return True\n\ndef main():\n    print(\"stop_platform_svc\")\n    stop_platform_svc()\n    #print\"start_platform_svc\"\n    #start_platform_svc()\n    #print\"start_platform_pddf\"\n    #start_platform_pddf()\n    print(\"stop_platform_pddf\")\n    stop_platform_pddf()\n    #pass\n\nif __name__ == \"__main__\":\n    main()\n\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import commands\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = commands.getstatusoutput(\"systemctl stop as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Stop as7712-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl disable as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Disable as7712-platform-init.service failed %d\"%status)\n         return False\n     \n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"clean\"])\n     if status:\n-        print(\"accton_as7712_util.py clean command failed %d\"%status)\n+        print(\"accton_as7712_util.py clean failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n", "add": 6, "remove": 6, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py", "badparts": ["import commands", "    status, output = commands.getstatusoutput(\"systemctl stop as7712-platform-init.service\")", "    status, output = commands.getstatusoutput(\"systemctl disable as7712-platform-init.service\")", "    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py clean\")", "        print(\"accton_as7712_util.py clean command failed %d\"%status)", "    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7712-platform-init.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7712-platform-init.service\"])", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"clean\"])", "        print(\"accton_as7712_util.py clean failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n     \n def start_platform_svc():\n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"install\"])\n     if status:\n-        print(\"accton_as7712_util.py install command failed %d\"%status)\n+        print(\"accton_as7712_util.py install failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Enable as7712-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Start as7712-platform-init.service failed %d\"%status)\n         return False\n", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py install\")", "        print(\"accton_as7712_util.py install command failed %d\"%status)", "    status, output = commands.getstatusoutput(\"systemctl enable as7712-platform-init.service\")", "    status, output = commands.getstatusoutput(\"systemctl start as7712-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"install\"])", "        print(\"accton_as7712_util.py install failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7712-platform-init.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7712-platform-init.service\"])"]}, {"diff": "\n     return True\n \n def start_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n \n def stop_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service f", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}], "source": "\n import commands def check_pddf_support(): return True def stop_platform_svc(): status, output=commands.getstatusoutput(\"systemctl stop as7712-platform-init.service\") if status: print(\"Stop as7712-platform-init.service failed %d\"%status) return False status, output=commands.getstatusoutput(\"systemctl disable as7712-platform-init.service\") if status: print(\"Disable as7712-platform-init.service failed %d\"%status) return False status, output=commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py clean\") if status: print(\"accton_as7712_util.py clean command failed %d\"%status) return False status, output=commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status) return False return True def start_platform_svc(): status, output=commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py install\") if status: print(\"accton_as7712_util.py install command failed %d\"%status) return False status, output=commands.getstatusoutput(\"systemctl enable as7712-platform-init.service\") if status: print(\"Enable as7712-platform-init.service failed %d\"%status) return False status, output=commands.getstatusoutput(\"systemctl start as7712-platform-init.service\") if status: print(\"Start as7712-platform-init.service failed %d\"%status) return False return True def start_platform_pddf(): status, output=commands.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print(\"Start pddf-platform-init.service failed %d\"%status) return False return True def stop_platform_pddf(): status, output=commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service failed %d\"%status) return False return True def main(): pass if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services. \n# This will be used while switching the pddf->non-pddf mode and vice versa\nimport commands\n\ndef check_pddf_support():\n    return True\n\ndef stop_platform_svc():\n    status, output = commands.getstatusoutput(\"systemctl stop as7712-platform-init.service\")\n    if status:\n        print(\"Stop as7712-platform-init.service failed %d\"%status)\n        return False\n    status, output = commands.getstatusoutput(\"systemctl disable as7712-platform-init.service\")\n    if status:\n        print(\"Disable as7712-platform-init.service failed %d\"%status)\n        return False\n    \n    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py clean\")\n    if status:\n        print(\"accton_as7712_util.py clean command failed %d\"%status)\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n        return False\n\n    return True\n    \ndef start_platform_svc():\n    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py install\")\n    if status:\n        print(\"accton_as7712_util.py install command failed %d\"%status)\n        return False\n\n    status, output = commands.getstatusoutput(\"systemctl enable as7712-platform-init.service\")\n    if status:\n        print(\"Enable as7712-platform-init.service failed %d\"%status)\n        return False\n    status, output = commands.getstatusoutput(\"systemctl start as7712-platform-init.service\")\n    if status:\n        print(\"Start as7712-platform-init.service failed %d\"%status)\n        return False\n\n    return True\n\ndef start_platform_pddf():\n    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print(\"Start pddf-platform-init.service failed %d\"%status)\n        return False\n    \n    return True\n\ndef stop_platform_pddf():\n    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service failed %d\"%status)\n        return False\n\n    return True\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py": {"changes": [{"diff": "\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', line", "add": 6, "remove": 6, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py", "badparts": ["    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cdump -y 0 0x42 s 0x9a\"", "        status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]", "        status, output = getstatusoutput_noshell(cmd)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes show : show all systen status sff : dump SFP eeprom set : change board setting with fan|led|sfp \"\"\" import subprocess import getopt import sys import logging import re import time PROJECT_NAME='as7716_32x' version='0.0.1' verbose=False DEBUG=False args=[] ALL_DEVICE={} DEVICE_NO={'led':5, 'fan1':1, 'fan2':1,'fan3':1,'fan4':1,'fan5':1,'thermal':3, 'psu':2, 'sfp':54} led_prefix='/sys/devices/platform/as7716_32x_led/leds/accton_'+PROJECT_NAME+'_led::' fan_prefix='/sys/devices/platform/as7716_32x_' hwmon_types={'led':['diag','fan','loc','psu1','psu2'], 'fan1':['fan'], 'fan2':['fan'], 'fan3':['fan'], 'fan4':['fan'], 'fan5':['fan'], } hwmon_nodes={'led':['brightness'], 'fan1':['fan_duty_cycle_percentage', 'fan1_fault', 'fan1_speed_rpm', 'fan1_direction', 'fanr1_fault', 'fanr1_speed_rpm'], 'fan2':['fan_duty_cycle_percentage','fan2_fault', 'fan2_speed_rpm', 'fan2_direction', 'fanr2_fault', 'fanr2_speed_rpm'], 'fan3':['fan_duty_cycle_percentage','fan3_fault', 'fan3_speed_rpm', 'fan3_direction', 'fanr3_fault', 'fanr3_speed_rpm'], 'fan4':['fan4_duty_cycle_percentage','fan4_fault', 'fan4_speed_rpm', 'fan4_direction', 'fanr4_fault', 'fanr4_speed_rpm'], 'fan5':['fan_duty_cycle_percentage','fan5_fault', 'fan5_speed_rpm', 'fan5_direction', 'fanr5_fault', 'fanr5_speed_rpm'], \t } hwmon_prefix={'led': led_prefix, 'fan1': fan_prefix, 'fan2': fan_prefix, 'fan3': fan_prefix, 'fan4': fan_prefix, 'fan5': fan_prefix, } i2c_prefix='/sys/bus/i2c/devices/' i2c_bus={'thermal':['10-0048','10-0049', '10-004a'], 'psu':['17-0050','18-0053'], 'sfp':['-0050']} i2c_nodes={ 'thermal':['hwmon/hwmon*/temp1_input'], 'psu':['psu_present ', 'psu_power_good'] , 'sfp':['sfp_is_present ', 'sfp_tx_disable']} sfp_map=[29, 30, 31, 32, 34, 33, 36, 35, 25, 26, 27, 28, 37, 38, 39, 40, 41, 42, 43, 44, 53, 54, 55, 56, 45, 46, 47, 48, 49, 50, 51, 52] mknod=[ 'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo as7716_32x_fan 0x66 > /sys/bus/i2c/devices/i2c-9/new_device', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-10/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-10/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-10/new_device', 'echo as7716_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-11/new_device', 'echo accton_i2c_cpld 0x62 > /sys/bus/i2c/devices/i2c-12/new_device', 'echo accton_i2c_cpld 0x64 > /sys/bus/i2c/devices/i2c-13/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo as7716_32x_psu1 0x53 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-18/new_device', 'echo as7716_32x_psu2 0x50> /sys/bus/i2c/devices/i2c-17/new_device', 'echo ym2651 0x58 > /sys/bus/i2c/devices/i2c-17/new_device', 'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-1/new_device', ] mknod2=[ 'echo as7716_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo accton_i2c_cpld 0x61 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo accton_i2c_cpld 0x62 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo as7716_32x_psu1 0x38 > /sys/bus/i2c/devices/i2c-57/new_device', 'echo cpr_4011_4mxx 0x3c > /sys/bus/i2c/devices/i2c-57/new_device', 'echo as7716_32x_psu1 0x50 > /sys/bus/i2c/devices/i2c-57/new_device', 'echo ym2401 0x58 > /sys/bus/i2c/devices/i2c-57/new_device', 'echo as7716_32x_psu2 0x3b > /sys/bus/i2c/devices/i2c-58/new_device', 'echo cpr_4011_4mxx 0x3f > /sys/bus/i2c/devices/i2c-58/new_device', 'echo as7716_32x_psu2 0x53 > /sys/bus/i2c/devices/i2c-58/new_device', 'echo ym2401 0x5b > /sys/bus/i2c/devices/i2c-58/new_device', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-61/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-62/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-63/new_device', 'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-1/new_device', ] FORCE=0 logging.basicConfig(filename=PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG) logging.basicConfig(level=logging.INFO) if DEBUG==True: print(sys.argv[0]) print('ARGV :', sys.argv[1:]) def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print(options) print(args) print(len(sys.argv)) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': do_install() elif arg=='clean': do_uninstall() elif arg=='show': device_traversal() elif arg=='sff': if len(args)!=2: show_eeprom_help() elif int(args[1])==0 or int(args[1]) > DEVICE_NO['sfp']: show_eeprom_help() else: show_eeprom(args[1]) return elif arg=='set': if len(args)<3: show_set_help() else: set_device(args[1:]) return else: show_help() return 0 def show_help(): print(__doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]}) sys.exit(0) def show_set_help(): cmd= sys.argv[0].split(\"/\")[-1]+\" \" +args[0] print(cmd +\"[led|sfp|fan]\") print(\" use \\\"\"+cmd +\" led 0-4 \\\" to set led color\") print(\" use \\\"\"+cmd +\" fan 0-100\\\" to set fan duty percetage\") print(\" use \\\"\"+cmd +\" sfp 1-32{0|1}\\\" to set sfp sys.exit(0) def dis_i2c_ir3570a(addr): cmd=\"i2cset -y 0 0x%x 0xE5 0x01\" % addr status, output=subprocess.getstatusoutput(cmd) cmd=\"i2cset -y 0 0x%x 0x12 0x02\" % addr status, output=subprocess.getstatusoutput(cmd) return status def ir3570_check(): cmd=\"i2cdump -y 0 0x42 s 0x9a\" try: status, output=subprocess.getstatusoutput(cmd) lines=output.split('\\n') hn=re.findall(r'\\w+', lines[-1]) version=int(hn[1], 16) if version==0x24: ret=dis_i2c_ir3570a(4) else: ret=0 except Exception as e: print(\"Error on ir3570_check() e:\" +str(e)) return -1 return ret def show_eeprom_help(): cmd= sys.argv[0].split(\"/\")[-1]+\" \" +args[0] print(\" use \\\"\"+cmd +\" 1-32 \\\" to dump sfp sys.exit(0) def my_log(txt): if DEBUG==True: print(\"[ACCTON DBG]: \"+txt) return def log_os_system(cmd, show): logging.info('Run:'+cmd) status=1 output=\"\" status, output=subprocess.getstatusoutput(cmd) my_log(cmd +\"with result:\" +str(status)) my_log(\"cmd:\" +cmd) my_log(\" output:\"+output) if status: logging.info('Failed:'+cmd) if show: print(('Failed:'+cmd)) return status, output def driver_inserted(): ret, lsmod=log_os_system(\"ls /sys/module/*accton*\", 0) logging.info('mods:'+lsmod) if ret: return False else: return True kos=[ 'depmod -ae', 'modprobe i2c_dev', 'modprobe i2c_mux_pca954x force_deselect_on_exit=1', 'modprobe accton_i2c_cpld', 'modprobe cpr_4011_4mxx', 'modprobe ym2651y', 'modprobe accton_as7716_32x_cpld1', 'modprobe accton_as7716_32x_fan', 'modprobe accton_as7716_32x_leds', 'modprobe accton_as7716_32x_psu'] def driver_install(): global FORCE for i in range(0,len(kos)): status, output=log_os_system(kos[i], 1) if status: if FORCE==0: return status return 0 def driver_uninstall(): global FORCE for i in range(0,len(kos)): rm=kos[-(i+1)] lst=rm.split(\" \") if len(lst) > 2: del(lst[2:]) rm=\" \".join(lst) rm=rm.replace(\"modprobe\", \"modprobe -rq\") rm=rm.replace(\"insmod\", \"rmmod\") status, output=log_os_system(rm, 1) if status: if FORCE==0: return status return 0 def i2c_order_check(): tmp=\"echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-1/new_device\" status, output=log_os_system(tmp, 0) if not device_exist(): order=1 else: order=0 tmp=\"echo 0x70 > /sys/bus/i2c/devices/i2c-1/delete_device\" status, output=log_os_system(tmp, 0) return order def device_install(): global FORCE for i in range(0,len(mknod)): if mknod[i].find('pca954') !=-1: time.sleep(2) status, output=log_os_system(mknod[i], 1) if status: print(output) if FORCE==0: return status for i in range(0,len(sfp_map)): status, output=log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1) if status: print(output) if FORCE==0: return status status, output=log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1) if status: print(output) if FORCE==0: return status return def device_uninstall(): global FORCE status, output=log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0) if status==0: I2C_ORDER=1 else: \tI2C_ORDER=0 for i in range(0,len(sfp_map)): target=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\" status, output=log_os_system(\"echo 0x50 > \"+target, 1) if status: print(output) if FORCE==0: return status if I2C_ORDER==0: nodelist=mknod else: nodelist=mknod2 for i in range(len(nodelist)): target=nodelist[-(i+1)] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status return def system_ready(): if driver_inserted()==False: return False if not device_exist(): print(\"not device_exist()\") return False return True def do_install(): if driver_inserted()==False: status=driver_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" drivers detected....\") ir3570_check() if not device_exist(): status=device_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" devices detected....\") return def do_uninstall(): if not device_exist(): print(PROJECT_NAME.upper() +\" has no device installed....\") else: print(\"Removing device....\") status=device_uninstall() if status: if FORCE==0: return status if driver_inserted()==False: print(PROJECT_NAME.upper() +\" has no driver installed....\") else: print(\"Removing installed driver....\") status=driver_uninstall() if status: if FORCE==0: return status return def devices_info(): global DEVICE_NO global ALL_DEVICE global i2c_bus, hwmon_types for key in DEVICE_NO: ALL_DEVICE[key]={} for i in range(0,DEVICE_NO[key]): ALL_DEVICE[key][key+str(i+1)]=[] for key in i2c_bus: buses=i2c_bus[key] nodes=i2c_nodes[key] for i in range(0,len(buses)): for j in range(0,len(nodes)): if 'fan'==key: for k in range(0,DEVICE_NO[key]): node=key+str(k+1) path=i2c_prefix+buses[i]+\"/fan\"+str(k+1)+\"_\"+nodes[j] my_log(node+\": \"+path) ALL_DEVICE[key][node].append(path) elif 'sfp'==key: for k in range(0,DEVICE_NO[key]): node=key+str(k+1) path=i2c_prefix+str(sfp_map[k])+buses[i]+\"/\"+nodes[j] my_log(node+\": \"+path) ALL_DEVICE[key][node].append(path) else: node=key+str(i+1) path=i2c_prefix+buses[i]+\"/\"+nodes[j] my_log(node+\": \"+path) ALL_DEVICE[key][node].append(path) for key in hwmon_types: itypes=hwmon_types[key] nodes=hwmon_nodes[key] for i in range(0,len(itypes)): for j in range(0,len(nodes)): node=key+\"_\"+itypes[i] path=hwmon_prefix[key]+itypes[i]+\"/\"+nodes[j] my_log(node+\": \"+path) ALL_DEVICE[key][ key+str(i+1)].append(path) if DEBUG==True: for i in sorted(ALL_DEVICE.keys()): print((i+\": \")) for j in sorted(ALL_DEVICE[i].keys()): print((\" \"+j)) for k in(ALL_DEVICE[i][j]): print((\" \"+\" \"+k)) return def show_eeprom(index): if system_ready()==False: print(\"System's not ready.\") print(\"Please install first!\") return if len(ALL_DEVICE)==0: devices_info() node=ALL_DEVICE['sfp']['sfp'+str(index)][0] node=node.replace(node.split(\"/\")[-1], 'sfp_eeprom') ret, log=log_os_system(\"which hexdump\", 0) ret, log2=log_os_system(\"which busybox hexdump\", 0) if len(log): hex_cmd='hexdump' elif len(log2): hex_cmd=' busybox hexdump' else: log='Failed: no hexdump cmd!!' logging.info(log) print(log) return 1 print(node +\":\") ret, log=log_os_system(\"cat \"+node+\"| \"+hex_cmd+\" -C\", 1) if ret==0: print(log) else: print(\"**********device no found**********\") return def set_device(args): global DEVICE_NO global ALL_DEVICE if system_ready()==False: print(\"System's not ready.\") print(\"Please install first!\") return if len(ALL_DEVICE)==0: devices_info() if args[0]=='led': if int(args[1])>4: show_set_help() return for i in range(0,len(ALL_DEVICE['led'])): for k in(ALL_DEVICE['led']['led'+str(i+1)]): ret, log=log_os_system(\"echo \"+args[1]+\" >\"+k, 1) if ret: return ret elif args[0]=='fan': if int(args[1])>100: show_set_help() return node=ALL_DEVICE['fan1']['fan11'][0] node=node.replace(node.split(\"/\")[-1], 'fan1_duty_cycle_percentage') ret, log=log_os_system(\"cat \"+node, 1) if ret==0: print((\"Previous fan duty: \" +log.strip() +\"%\")) ret, log=log_os_system(\"echo \"+args[1]+\" >\"+node, 1) if ret==0: print((\"Current fan duty: \" +args[1] +\"%\")) return ret elif args[0]=='sfp': if int(args[1])> DEVICE_NO[args[0]] or int(args[1])==0: show_set_help() return if len(args)<2: show_set_help() return if int(args[2])>1: show_set_help() return for i in range(0,len(ALL_DEVICE[args[0]])): for j in ALL_DEVICE[args[0]][args[0]+str(args[1])]: if j.find('tx_disable')!=-1: ret, log=log_os_system(\"echo \"+args[2]+\" >\"+j, 1) if ret: return ret return def get_value(input): digit=re.findall('\\d+', input) return int(digit[0]) def device_traversal(): if system_ready()==False: print(\"System's not ready.\") print(\"Please install first!\") return if len(ALL_DEVICE)==0: devices_info() for i in sorted(ALL_DEVICE.keys()): print(\"============================================\") print((i.upper()+\": \")) print(\"============================================\") for j in sorted(list(ALL_DEVICE[i].keys()), key=get_value): print(\" \"+j+\":\", end=' ') for k in(ALL_DEVICE[i][j]): ret, log=log_os_system(\"cat \"+k, 0) func=k.split(\"/\")[-1].strip() func=re.sub(j+'_','',func,1) func=re.sub(i.lower()+'_','',func,1) if ret==0: print(func+\"=\"+log+\" \", end=' ') else: print(func+\"=\"+\"X\"+\" \", end=' ') print() print(\"----------------------------------------------------------------\") print() return def device_exist(): ret1, log=log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0) ret2, log=log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2016 Accton Networks, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean\ncommand:\n    install     : install drivers and generate related sysfs nodes\n    clean       : uninstall drivers and remove related sysfs nodes\n    show        : show all systen status\n    sff         : dump SFP eeprom\n    set         : change board setting with fan|led|sfp\n\"\"\"\n\nimport subprocess\nimport getopt\nimport sys\nimport logging\nimport re\nimport time\n\nPROJECT_NAME = 'as7716_32x'\nversion = '0.0.1'\nverbose = False\nDEBUG = False\nargs = []\nALL_DEVICE = {}\nDEVICE_NO = {'led':5, 'fan1':1, 'fan2':1,'fan3':1,'fan4':1,'fan5':1,'thermal':3, 'psu':2, 'sfp':54}\n\n\nled_prefix ='/sys/devices/platform/as7716_32x_led/leds/accton_'+PROJECT_NAME+'_led::'\nfan_prefix ='/sys/devices/platform/as7716_32x_'\nhwmon_types = {'led': ['diag','fan','loc','psu1','psu2'],\n               'fan1': ['fan'],\n               'fan2': ['fan'],\n               'fan3': ['fan'],\n               'fan4': ['fan'],\n               'fan5': ['fan'],\n              }\nhwmon_nodes = {'led': ['brightness'] ,\n               'fan1': ['fan_duty_cycle_percentage', 'fan1_fault', 'fan1_speed_rpm', 'fan1_direction', 'fanr1_fault', 'fanr1_speed_rpm'],\n               'fan2': ['fan_duty_cycle_percentage','fan2_fault', 'fan2_speed_rpm', 'fan2_direction', 'fanr2_fault', 'fanr2_speed_rpm'],\n               'fan3': ['fan_duty_cycle_percentage','fan3_fault', 'fan3_speed_rpm', 'fan3_direction', 'fanr3_fault', 'fanr3_speed_rpm'],\n               'fan4': ['fan4_duty_cycle_percentage','fan4_fault', 'fan4_speed_rpm', 'fan4_direction', 'fanr4_fault', 'fanr4_speed_rpm'],\n               'fan5': ['fan_duty_cycle_percentage','fan5_fault', 'fan5_speed_rpm', 'fan5_direction', 'fanr5_fault', 'fanr5_speed_rpm'],\n\t      }\nhwmon_prefix ={'led': led_prefix,\n               'fan1': fan_prefix,\n               'fan2': fan_prefix,\n               'fan3': fan_prefix,\n               'fan4': fan_prefix,\n               'fan5': fan_prefix,\n              }\n\ni2c_prefix = '/sys/bus/i2c/devices/'\ni2c_bus = {'thermal': ['10-0048','10-0049', '10-004a'] ,\n           'psu': ['17-0050','18-0053'],\n           'sfp': ['-0050']}\ni2c_nodes = {\n           'thermal': ['hwmon/hwmon*/temp1_input'] ,\n           'psu': ['psu_present ', 'psu_power_good']    ,\n           'sfp': ['sfp_is_present ', 'sfp_tx_disable']}\n\nsfp_map = [29, 30, 31, 32, 34, 33, 36, 35,\n          25, 26, 27, 28, 37, 38, 39, 40, \n          41, 42, 43, 44, 53, 54, 55, 56, \n          45, 46, 47, 48, 49, 50, 51, 52]\n\nmknod =[\n'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo as7716_32x_fan 0x66 > /sys/bus/i2c/devices/i2c-9/new_device',\n\n'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-10/new_device',\n'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-10/new_device',\n'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-10/new_device',\n\n'echo as7716_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-11/new_device',\n'echo accton_i2c_cpld 0x62 > /sys/bus/i2c/devices/i2c-12/new_device',\n'echo accton_i2c_cpld 0x64 > /sys/bus/i2c/devices/i2c-13/new_device',\n\n'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-2/new_device',\n\n# PSU-1\n'echo as7716_32x_psu1 0x53 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-18/new_device',\n\n# PSU-2\n'echo as7716_32x_psu2 0x50> /sys/bus/i2c/devices/i2c-17/new_device',\n'echo ym2651 0x58 > /sys/bus/i2c/devices/i2c-17/new_device',\n\n\n\n#EERPOM\n'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-1/new_device',\n]\n\nmknod2 =[\n'echo as7716_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo accton_i2c_cpld 0x61 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo accton_i2c_cpld 0x62 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-0/new_device',\n\n# PSU-1\n'echo as7716_32x_psu1 0x38 > /sys/bus/i2c/devices/i2c-57/new_device',\n'echo cpr_4011_4mxx  0x3c > /sys/bus/i2c/devices/i2c-57/new_device',\n'echo as7716_32x_psu1 0x50 > /sys/bus/i2c/devices/i2c-57/new_device',\n'echo ym2401 0x58 > /sys/bus/i2c/devices/i2c-57/new_device',\n\n# PSU-2\n'echo as7716_32x_psu2 0x3b > /sys/bus/i2c/devices/i2c-58/new_device',\n'echo cpr_4011_4mxx 0x3f > /sys/bus/i2c/devices/i2c-58/new_device',\n'echo as7716_32x_psu2 0x53 > /sys/bus/i2c/devices/i2c-58/new_device',\n'echo ym2401 0x5b > /sys/bus/i2c/devices/i2c-58/new_device',\n\n'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-61/new_device',\n'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-62/new_device',\n'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-63/new_device',\n\n#EERPOM\n'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-1/new_device',\n]\n\nFORCE = 0\nlogging.basicConfig(filename= PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG)\nlogging.basicConfig(level=logging.INFO)\n\n\nif DEBUG == True:\n    print(sys.argv[0])\n    print('ARGV      :', sys.argv[1:])\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n\n    if len(sys.argv)<2:\n        show_help()\n\n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:\n        print(options)\n        print(args)\n        print(len(sys.argv))\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n           do_install()\n        elif arg == 'clean':\n           do_uninstall()\n        elif arg == 'show':\n           device_traversal()\n        elif arg == 'sff':\n            if len(args)!=2:\n                show_eeprom_help()\n            elif int(args[1]) ==0 or int(args[1]) > DEVICE_NO['sfp']:\n                show_eeprom_help()\n            else:\n                show_eeprom(args[1])\n            return\n        elif arg == 'set':\n            if len(args)<3:\n                show_set_help()\n            else:\n                set_device(args[1:])\n            return\n        else:\n            show_help()\n\n\n    return 0\n\ndef show_help():\n    print(__doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]})\n    sys.exit(0)\n\ndef  show_set_help():\n    cmd =  sys.argv[0].split(\"/\")[-1]+ \" \"  + args[0]\n    print(cmd +\" [led|sfp|fan]\")\n    print(\"    use \\\"\"+ cmd + \" led 0-4 \\\"  to set led color\")\n    print(\"    use \\\"\"+ cmd + \" fan 0-100\\\" to set fan duty percetage\")\n    print(\"    use \\\"\"+ cmd + \" sfp 1-32 {0|1}\\\" to set sfp# tx_disable\")\n    sys.exit(0)\n\ndef dis_i2c_ir3570a(addr):\n    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef ir3570_check():\n    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n    try:\n        status, output = subprocess.getstatusoutput(cmd)\n        lines = output.split('\\n')\n        hn = re.findall(r'\\w+', lines[-1])\n        version = int(hn[1], 16)\n        if version == 0x24:  #only for ir3570a\n            ret = dis_i2c_ir3570a(4)\n        else:\n            ret = 0\n    except Exception as e:\n        print(\"Error on ir3570_check() e:\" + str(e))\n        return -1\n    return ret\n\ndef  show_eeprom_help():\n    cmd =  sys.argv[0].split(\"/\")[-1]+ \" \"  + args[0]\n    print(\"    use \\\"\"+ cmd + \" 1-32 \\\" to dump sfp# eeprom\")\n    sys.exit(0)\n\ndef my_log(txt):\n    if DEBUG == True:\n        print(\"[ACCTON DBG]: \"+txt)\n    return\n\ndef log_os_system(cmd, show):\n    logging.info('Run :'+cmd)\n    status = 1\n    output = \"\"\n    status, output = subprocess.getstatusoutput(cmd)\n    my_log (cmd +\"with result:\" + str(status))\n    my_log (\"cmd:\" + cmd)\n    my_log (\"      output:\"+output)\n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print(('Failed :'+cmd))\n    return  status, output\n\ndef driver_inserted():\n    ret, lsmod = log_os_system(\"ls /sys/module/*accton*\", 0)\n    logging.info('mods:'+lsmod)\n    if ret :\n        return False\n    else :\n        return True\n\n#'modprobe cpr_4011_4mxx',\n\nkos = [\n'depmod -ae',\n'modprobe i2c_dev',\n'modprobe i2c_mux_pca954x force_deselect_on_exit=1',\n'modprobe accton_i2c_cpld',\n'modprobe cpr_4011_4mxx',\n'modprobe ym2651y',\n'modprobe accton_as7716_32x_cpld1',\n'modprobe accton_as7716_32x_fan',\n'modprobe accton_as7716_32x_leds',\n'modprobe accton_as7716_32x_psu']\n\ndef driver_install():\n    global FORCE\n    for i in range(0,len(kos)):\n        status, output = log_os_system(kos[i], 1)\n        if status:\n            if FORCE == 0:\n                return status\n    return 0\n\ndef driver_uninstall():\n    global FORCE\n    for i in range(0,len(kos)):\n        #remove parameter if any\n        rm = kos[-(i+1)]\n        lst = rm.split(\" \")\n        if len(lst) > 2:\n            del(lst[2:])\n        rm = \" \".join(lst)\n\n        #Change to removing commands\n        rm = rm.replace(\"modprobe\", \"modprobe -rq\")\n        rm = rm.replace(\"insmod\", \"rmmod\")\n        status, output = log_os_system(rm, 1)\n        if status:\n            if FORCE == 0:\n                return status\n    return 0\n\n\n\ndef i2c_order_check():\n    # i2c bus 0 and 1 might be installed in different order.\n    # Here check if 0x76 is exist @ i2c-0\n    tmp = \"echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-1/new_device\"\n    status, output = log_os_system(tmp, 0)\n    if not device_exist():\n        order = 1\n    else:\n        order = 0\n    tmp = \"echo 0x70 > /sys/bus/i2c/devices/i2c-1/delete_device\"\n    status, output = log_os_system(tmp, 0)\n    return order\n\ndef device_install():\n    global FORCE\n\n    for i in range(0,len(mknod)):\n        #for pca932x need times to built new i2c buses\n        if mknod[i].find('pca954') != -1:\n            time.sleep(2)\n        \n        status, output = log_os_system(mknod[i], 1)        \n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n    \n    for i in range(0,len(sfp_map)):\n        status, output =log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n        status, output =log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n    return\n\ndef device_uninstall():\n    global FORCE\n\n    status, output =log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0)\n    if status==0:\n        I2C_ORDER=1\n    else:\n    \tI2C_ORDER=0\n\n    for i in range(0,len(sfp_map)):\n        target = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\"\n        status, output =log_os_system(\"echo 0x50 > \"+ target, 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    if I2C_ORDER==0:\n        nodelist = mknod\n    else:\n        nodelist = mknod2\n\n    for i in range(len(nodelist)):\n        target = nodelist[-(i+1)]\n        temp = target.split()\n        del temp[1]\n        temp[-1] = temp[-1].replace('new_device', 'delete_device')\n        status, output = log_os_system(\" \".join(temp), 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    return\n\ndef system_ready():\n    if driver_inserted() == False:        \n        return False\n    if not device_exist():\n        print(\"not device_exist()\")\n        return False\n    return True\n\ndef do_install():\n    if driver_inserted() == False:\n        status = driver_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print(PROJECT_NAME.upper()+\" drivers detected....\")\n\n    ir3570_check()\n\n    if not device_exist():\n        status = device_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print(PROJECT_NAME.upper()+\" devices detected....\")\n    return\n\ndef do_uninstall():\n    if not device_exist():\n        print(PROJECT_NAME.upper() +\" has no device installed....\")\n    else:\n        print(\"Removing device....\")\n        status = device_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    if driver_inserted()== False :\n        print(PROJECT_NAME.upper() +\" has no driver installed....\")\n    else:\n        print(\"Removing installed driver....\")\n        status = driver_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    return\n\ndef devices_info():\n    global DEVICE_NO\n    global ALL_DEVICE\n    global i2c_bus, hwmon_types\n    for key in DEVICE_NO:\n        ALL_DEVICE[key]= {}\n        for i in range(0,DEVICE_NO[key]):\n            ALL_DEVICE[key][key+str(i+1)] = []\n\n    for key in i2c_bus:\n        buses = i2c_bus[key]\n        nodes = i2c_nodes[key]\n        for i in range(0,len(buses)):\n            for j in range(0,len(nodes)):\n                if  'fan' == key:\n                    for k in range(0,DEVICE_NO[key]):\n                        node = key+str(k+1)\n                        path = i2c_prefix+ buses[i]+\"/fan\"+str(k+1)+\"_\"+ nodes[j]\n                        my_log(node+\": \"+ path)\n                        ALL_DEVICE[key][node].append(path)\n                elif  'sfp' == key:\n                    for k in range(0,DEVICE_NO[key]):\n                        node = key+str(k+1)\n                        path = i2c_prefix+ str(sfp_map[k])+ buses[i]+\"/\"+ nodes[j]\n                        my_log(node+\": \"+ path)\n                        ALL_DEVICE[key][node].append(path)\n                else:\n                    node = key+str(i+1)\n                    path = i2c_prefix+ buses[i]+\"/\"+ nodes[j]\n                    my_log(node+\": \"+ path)\n                    ALL_DEVICE[key][node].append(path)\n\n    for key in hwmon_types:\n        itypes = hwmon_types[key]\n        nodes = hwmon_nodes[key]\n        for i in range(0,len(itypes)):\n            for j in range(0,len(nodes)):\n                node = key+\"_\"+itypes[i]\n                path = hwmon_prefix[key]+ itypes[i]+\"/\"+ nodes[j]\n                my_log(node+\": \"+ path)\n                ALL_DEVICE[key][ key+str(i+1)].append(path)\n\n    #show dict all in the order\n    if DEBUG == True:\n        for i in sorted(ALL_DEVICE.keys()):\n            print((i+\": \"))\n            for j in sorted(ALL_DEVICE[i].keys()):\n                print((\"   \"+j))\n                for k in (ALL_DEVICE[i][j]):\n                    print((\"   \"+\"   \"+k))\n    return\n\ndef show_eeprom(index):\n    if system_ready()==False:\n        print(\"System's not ready.\")\n        print(\"Please install first!\")\n        return\n\n    if len(ALL_DEVICE)==0:\n        devices_info()\n    node = ALL_DEVICE['sfp'] ['sfp'+str(index)][0]\n    node = node.replace(node.split(\"/\")[-1], 'sfp_eeprom')\n    # check if got hexdump command in current environment\n    ret, log = log_os_system(\"which hexdump\", 0)\n    ret, log2 = log_os_system(\"which busybox hexdump\", 0)\n    if len(log):\n        hex_cmd = 'hexdump'\n    elif len(log2):\n        hex_cmd = ' busybox hexdump'\n    else:\n        log = 'Failed : no hexdump cmd!!'\n        logging.info(log)\n        print(log)\n        return 1\n\n    print(node + \":\")\n    ret, log = log_os_system(\"cat \"+node+\"| \"+hex_cmd+\" -C\", 1)\n    if ret==0:\n        print(log)\n    else:\n        print(\"**********device no found**********\")\n    return\n\ndef set_device(args):\n    global DEVICE_NO\n    global ALL_DEVICE\n    if system_ready()==False:\n        print(\"System's not ready.\")\n        print(\"Please install first!\")\n        return\n\n    if len(ALL_DEVICE)==0:\n        devices_info()\n\n    if args[0]=='led':\n        if int(args[1])>4:\n            show_set_help()\n            return\n        #print  ALL_DEVICE['led']\n        for i in range(0,len(ALL_DEVICE['led'])):\n            for k in (ALL_DEVICE['led']['led'+str(i+1)]):\n                ret, log = log_os_system(\"echo \"+args[1]+\" >\"+k, 1)\n                if ret:\n                    return ret\n    elif args[0]=='fan':\n        if int(args[1])>100:\n            show_set_help()\n            return\n        #print  ALL_DEVICE['fan']\n        #fan1~6 is all fine, all fan share same setting\n        node = ALL_DEVICE['fan1'] ['fan11'][0]\n        node = node.replace(node.split(\"/\")[-1], 'fan1_duty_cycle_percentage')\n        ret, log = log_os_system(\"cat \"+ node, 1)\n        if ret==0:\n            print((\"Previous fan duty: \" + log.strip() +\"%\"))\n        ret, log = log_os_system(\"echo \"+args[1]+\" >\"+node, 1)\n        if ret==0:\n            print((\"Current fan duty: \" + args[1] +\"%\"))\n        return ret\n    elif args[0]=='sfp':\n        if int(args[1])> DEVICE_NO[args[0]] or int(args[1])==0:\n            show_set_help()\n            return\n        if len(args)<2:\n            show_set_help()\n            return\n\n        if int(args[2])>1:\n            show_set_help()\n            return\n\n        #print  ALL_DEVICE[args[0]]\n        for i in range(0,len(ALL_DEVICE[args[0]])):\n            for j in ALL_DEVICE[args[0]][args[0]+str(args[1])]:\n                if j.find('tx_disable')!= -1:\n                    ret, log = log_os_system(\"echo \"+args[2]+\" >\"+ j, 1)\n                    if ret:\n                        return ret\n\n    return\n\n#get digits inside a string.\n#Ex: 31 for \"sfp31\"\ndef get_value(input):\n    digit = re.findall('\\d+', input)\n    return int(digit[0])\n\ndef device_traversal():\n    if system_ready()==False:\n        print(\"System's not ready.\")\n        print(\"Please install first!\")\n        return\n\n    if len(ALL_DEVICE)==0:\n        devices_info()\n    for i in sorted(ALL_DEVICE.keys()):\n        print(\"============================================\")\n        print((i.upper()+\": \"))\n        print(\"============================================\")\n\n        for j in sorted(list(ALL_DEVICE[i].keys()), key=get_value):\n            print(\"   \"+j+\":\", end=' ')\n            for k in (ALL_DEVICE[i][j]):\n                ret, log = log_os_system(\"cat \"+k, 0)\n                func = k.split(\"/\")[-1].strip()\n                func = re.sub(j+'_','',func,1)\n                func = re.sub(i.lower()+'_','',func,1)\n                if ret==0:\n                    print(func+\"=\"+log+\" \", end=' ')\n                else:\n                    print(func+\"=\"+\"X\"+\" \", end=' ')\n            print()\n            print(\"----------------------------------------------------------------\")\n\n\n        print()\n    return\n\ndef device_exist():\n    ret1, log = log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0)\n    ret2, log = log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py": {"changes": [{"diff": "\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py", "badparts": ["               os.system('reboot')           "], "goodparts": ["               subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}], "source": "\n try: import os import getopt import sys import logging import logging.config import logging.handlers import time from as7726_32x.fanutil import FanUtil from as7726_32x.thermalutil import ThermalUtil except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as7726_32x_monitor' global log_file global log_level class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False fan_policy_state=1 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0, 0, 0, 0, 0] temp_test_data=0 class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 logging.debug('temp=%d', temp) for i in range(0, len(policy)): if temp > policy[i][2]: if temp <=policy[i][3]: state=i logging.debug('temp=%d >=policy[%d][2]=%d, temp=%d < policy[%d][3]=%d', temp, i, policy[i][2], temp, i, policy[i][3]) logging.debug('fan_state=%d', state) break return state def manage_fans(self): global fan_policy_state global fan_fail global test_temp global test_temp_list global alarm_state global temp_test_data LEVEL_FAN_DEF=0 LEVEL_FAN_MID=1 LEVEL_FAN_MAX=2 LEVEL_TEMP_HIGH=3 LEVEL_TEMP_CRITICAL=4 fan_policy_f2b={ LEVEL_FAN_DEF: [38, 0x4, 0, 38000], LEVEL_FAN_MID: [63, 0x6, 38000, 46000], LEVEL_FAN_MAX: [100, 0xE, 46000, 58000], LEVEL_TEMP_HIGH: [100, 0xE, 58000, 66000], LEVEL_TEMP_CRITICAL:[100, 0xE, 58000, 200000], } fan_policy_b2f={ LEVEL_FAN_DEF: [38, 0x4, 0, 34000], LEVEL_FAN_MID: [63, 0x8, 34000, 44000], LEVEL_FAN_MAX: [100, 0xE, 44000, 59000], LEVEL_TEMP_HIGH: [100, 0xE, 59000, 67000], LEVEL_TEMP_CRITICAL:[100, 0xE, 59000, 200000], } fan_policy=fan_policy_f2b thermal=ThermalUtil() fan=FanUtil() fan_dir=fan.get_fan_dir(1) if fan_dir==1: fan_dri=1 else: fan_policy=fan_policy_b2f ori_pwm=fan.get_fan_duty_cycle() new_pwm=0 logging.debug('fan_dir=%d, ori_pwm=%d', fan_dir, ori_pwm) logging.debug('test_temp=%d', test_temp) if test_temp==0: temp1=thermal._get_thermal_val(1) temp2=thermal._get_thermal_val(2) temp3=thermal._get_thermal_val(3) temp4=thermal._get_thermal_val(4) temp5=thermal._get_thermal_val(5) else: temp1=test_temp_list[0] temp2=test_temp_list[1] temp3=test_temp_list[2] temp4=test_temp_list[3] temp5=test_temp_list[4] fan_fail=0 if temp3==0: temp_get=50000 logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%') elif temp4==0: temp_get=50000 logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%') else: temp_get=(temp3 +temp4)/2 ori_state=fan_policy_state if test_temp!=0: temp_test_data=temp_test_data+1000 temp_get=temp_get +temp_test_data logging.debug('Unit test:temp_get=%d', temp_get) fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy) logging.debug('lm75_48=%d, lm75_49=%d, lm75_4a=%d, lm_4b=%d, lm_4c=%d', temp1,temp2,temp3,temp4,temp5) logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state) new_pwm=fan_policy[fan_policy_state][0] if fan_fail==0: logging.debug('new_fan_cycle=%d', new_pwm) if fan_fail==0: if new_pwm!=ori_pwm: fan.set_fan_duty_cycle(new_pwm) logging.info('Set fan speed from %d to %d', ori_pwm, new_pwm) for i in range(fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1): if fan.get_fan_status(i)==0: new_pwm=100 logging.debug('fan_%d fail, set pwm to 100',i) if test_temp==0: fan_fail=1 fan.set_fan_duty_cycle(new_pwm) break else: fan_fail=0 new_state=fan_policy_state if ori_state==LEVEL_FAN_DEF: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected, reboot DUT') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MID: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MAX: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if alarm_state==1: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_HIGH: if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if new_state <=LEVEL_FAN_MID: logging.warning('Alarm for temperature high is cleared') alarm_state=0 if new_state <=LEVEL_FAN_MAX: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_CRITICAL: if new_state <=LEVEL_FAN_MAX: logging.warning('Alarm for temperature critical is cleared') return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv,'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv)!=7: print(\"temp test, need input six temp\") return 0 i=0 for x in range(2, 7): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) fan=FanUtil() fan.set_fan_duty_cycle(38) print(\"set default fan speed to 37.5%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(5) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2017 Accton Technology Corporation\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    mm/dd/yyyy (A.D.)#   \n#    4/20/2018: Jostar modify for as7726_32x\n#    12/03/2018:Jostar modify for as7726_32x thermal plan\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import getopt\n    import sys\n    import logging\n    import logging.config\n    import logging.handlers\n    import time  # this is only being used as part of the example\n    from as7726_32x.fanutil import FanUtil\n    from as7726_32x.thermalutil import ThermalUtil\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as7726_32x_monitor'\n\nglobal log_file\nglobal log_level\n\n \n#  Air Flow Front to Back :\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 <=38C : Keep 37.5%(0x04) Fan speed\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 38C : Change Fan speed from 37.5%(0x04) to 62.5%(0x08)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 46C : Change Fan speed from 62.5%(0x08) to 100%(0x0E)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 58C : Send alarm message\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 66C : Shut down system\n#  One Fan fail : Change Fan speed to 100%(0x0E)\n\n\n#  Air Flow Back to Front :\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 <=34C : Keep 37.5%(0x04) Fan speed\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 34C : Change Fan speed from 37.5%(0x04) to 62.5%(0x08)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 44C : Change Fan speed from 62.5%(0x08) to 100%(0x0E)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 59C : Send alarm message\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 67C : Shut down system\n#  One Fan fail:  Change Fan speed to 100%(0x0E)\n#  sensor_LM75_CPU == sensor_LM75_4B\n \n     \nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n \n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n     \n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args: # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\n\nfan_policy_state=1\nfan_fail=0\nalarm_state = 0 #0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0, 0, 0, 0, 0]\ntemp_test_data=0\n# Make a class we can use to capture stdout and sterr in the log\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm=0\n    ori_pwm = 0\n    default_pwm=0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format= '[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = handler = logging.handlers.SysLogHandler(address = '/dev/log')\n        sys_handler.setLevel(logging.WARNING)       \n        logging.getLogger('').addHandler(sys_handler)\n          \n    def get_state_from_fan_policy(self, temp, policy):\n        state=0\n        \n        logging.debug('temp=%d', temp)\n        for i in range(0, len(policy)):\n            if temp > policy[i][2]:\n                if temp <= policy[i][3]:\n                    state =i\n                    logging.debug ('temp=%d >= policy[%d][2]=%d,  temp=%d < policy[%d][3]=%d' , temp, i, policy[i][2], temp, i, policy[i][3])\n                    logging.debug ('fan_state=%d', state)\n                    break\n        \n        return state\n\n    def manage_fans(self):\n       \n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list        \n        global alarm_state\n        global temp_test_data\n        \n        LEVEL_FAN_DEF=0\n        LEVEL_FAN_MID=1       \n        LEVEL_FAN_MAX=2\n        LEVEL_TEMP_HIGH=3\n        LEVEL_TEMP_CRITICAL=4\n        \n        fan_policy_f2b = {\n           LEVEL_FAN_DEF:       [38,  0x4, 0,     38000],\n           LEVEL_FAN_MID:       [63,  0x6, 38000, 46000],\n           LEVEL_FAN_MAX:       [100, 0xE, 46000, 58000],\n           LEVEL_TEMP_HIGH:     [100, 0xE, 58000, 66000],\n           LEVEL_TEMP_CRITICAL: [100, 0xE, 58000, 200000],\n        }\n        fan_policy_b2f = {\n           LEVEL_FAN_DEF:       [38,  0x4, 0,     34000],\n           LEVEL_FAN_MID:       [63,  0x8, 34000, 44000],\n           LEVEL_FAN_MAX:       [100, 0xE, 44000, 59000],\n           LEVEL_TEMP_HIGH:     [100, 0xE, 59000, 67000],\n           LEVEL_TEMP_CRITICAL: [100, 0xE, 59000, 200000],\n        }\n        \n        fan_policy = fan_policy_f2b\n        \n        thermal = ThermalUtil()\n        fan = FanUtil()\n        fan_dir=fan.get_fan_dir(1)            \n        if fan_dir == 1:\n            fan_dri=1 #something wrong, set fan_dir to default val\n        else:\n            fan_policy = fan_policy_b2f\n        \n        ori_pwm=fan.get_fan_duty_cycle()\n        new_pwm=0  \n        logging.debug('fan_dir=%d, ori_pwm=%d', fan_dir, ori_pwm)\n        logging.debug('test_temp=%d', test_temp)\n        if test_temp==0: \n            temp1 = thermal._get_thermal_val(1)\n            temp2 = thermal._get_thermal_val(2)\n            temp3 = thermal._get_thermal_val(3)\n            temp4 = thermal._get_thermal_val(4)\n            temp5 = thermal._get_thermal_val(5)            \n        else:\n            temp1 = test_temp_list[0]\n            temp2 = test_temp_list[1]\n            temp3 = test_temp_list[2]\n            temp4 = test_temp_list[3]\n            temp5 = test_temp_list[4]            \n            fan_fail=0\n       \n        if temp3==0:\n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%')\n        elif temp4==0:        \n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%')\n        else:    \n            temp_get= (temp3 + temp4)/2  # Use (sensor_LM75_4a + sensor_LM75_4b) /2 \n        ori_state=fan_policy_state\n        \n        if test_temp!=0:\n            temp_test_data=temp_test_data+1000\n            temp_get = temp_get + temp_test_data\n            logging.debug('Unit test:temp_get=%d', temp_get)\n        \n        fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy)\n                                \n        logging.debug('lm75_48=%d, lm75_49=%d, lm75_4a=%d, lm_4b=%d, lm_4c=%d', temp1,temp2,temp3,temp4,temp5)\n        logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state)\n        new_pwm = fan_policy[fan_policy_state][0]\n        if fan_fail==0:\n            logging.debug('new_fan_cycle=%d', new_pwm)\n        \n        if fan_fail==0:\n            if new_pwm!=ori_pwm:\n                fan.set_fan_duty_cycle(new_pwm)\n                logging.info('Set fan speed from %d to %d', ori_pwm, new_pwm)\n        \n        #Check Fan status\n        for i in range (fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1):\n            if fan.get_fan_status(i)==0:\n                new_pwm=100\n                logging.debug('fan_%d fail, set pwm to 100',i)                \n                if test_temp==0:\n                    fan_fail=1\n                    fan.set_fan_duty_cycle(new_pwm)\n                    break\n            else:\n                fan_fail=0\n        \n        new_state = fan_policy_state\n          \n        if ori_state==LEVEL_FAN_DEF:            \n           if new_state==LEVEL_TEMP_HIGH:\n               if alarm_state==0:\n                   logging.warning('Alarm for temperature high is detected')\n               alarm_state=1\n           if new_state==LEVEL_TEMP_CRITICAL:\n               logging.critical('Alarm for temperature critical is detected, reboot DUT')\n               time.sleep(2)\n               os.system('reboot')           \n        if ori_state==LEVEL_FAN_MID:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state=1 \n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n        if ori_state==LEVEL_FAN_MAX:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected') \n                alarm_state=1\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n            if alarm_state==1:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_HIGH:\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n            if new_state <= LEVEL_FAN_MID:\n                logging.warning('Alarm for temperature high is cleared')\n                alarm_state=0\n            if new_state <= LEVEL_FAN_MAX:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_CRITICAL:            \n            if new_state <= LEVEL_FAN_MAX:\n                logging.warning('Alarm for temperature critical is cleared')\n      \n        return True\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv,'hdlt:',['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg            \n        \n        if sys.argv[1]== '-t':\n            if len(sys.argv)!=7:\n                print(\"temp test, need input six temp\")\n                return 0\n            \n            i=0\n            for x in range(2, 7):\n               test_temp_list[i]= int(sys.argv[x])*1000\n               i=i+1\n            test_temp = 1   \n            log_level = logging.DEBUG\n            print(test_temp_list)                       \n    \n    fan = FanUtil()\n    fan.set_fan_duty_cycle(38)\n    print(\"set default fan speed to 37.5%\")\n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(5)\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    \n"}, "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py": {"changes": [{"diff": "\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py", "badparts": ["               os.system('reboot')           "], "goodparts": ["               subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high i", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}], "source": "\n try: import os import sys import getopt import logging import logging.config import logging.handlers import time from sonic_platform import platform except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as7726_32x_pddf_monitor' platform_chassis=None class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False fan_policy_state=1 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0, 0, 0, 0, 0] temp_test_data=0 class device_monitor(object): def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 logging.debug('temp=%d', temp) for i in range(0, len(policy)): if temp > policy[i][2]: if temp <=policy[i][3]: state=i logging.debug('temp=%d >=policy[%d][2]=%d, temp=%d < policy[%d][3]=%d', temp, i, policy[i][2], temp, i, policy[i][3]) logging.debug('fan_state=%d', state) break return state def manage_fans(self): global fan_policy_state global fan_fail global test_temp global test_temp_list global alarm_state global temp_test_data global platform_chassis LEVEL_FAN_DEF=0 LEVEL_FAN_MID=1 LEVEL_FAN_MAX=2 LEVEL_TEMP_HIGH=3 LEVEL_TEMP_CRITICAL=4 FAN_NUM_MAX=6 FANS_PERTRAY=2 fan_policy_f2b={ LEVEL_FAN_DEF: [38, 0x4, 0, 38000], LEVEL_FAN_MID: [63, 0x6, 38000, 46000], LEVEL_FAN_MAX: [100, 0xE, 46000, 58000], LEVEL_TEMP_HIGH: [100, 0xE, 58000, 66000], LEVEL_TEMP_CRITICAL:[100, 0xE, 58000, 200000], } fan_policy_b2f={ LEVEL_FAN_DEF: [38, 0x4, 0, 34000], LEVEL_FAN_MID: [63, 0x8, 34000, 44000], LEVEL_FAN_MAX: [100, 0xE, 44000, 59000], LEVEL_TEMP_HIGH: [100, 0xE, 59000, 67000], LEVEL_TEMP_CRITICAL:[100, 0xE, 59000, 200000], } fan_dir=platform_chassis.get_fan(0).get_direction() if fan_dir=='EXHAUST': fan_policy=fan_policy_f2b else: fan_policy=fan_policy_b2f ori_perc=platform_chassis.get_fan(0).get_speed() logging.debug('fan_dir=%s, ori_perc=%d, test_temp=%d', fan_dir, ori_perc, test_temp) if test_temp==0: temp4=platform_chassis.get_thermal(3).get_temperature()*1000 temp5=platform_chassis.get_thermal(4).get_temperature()*1000 else: temp4=test_temp_list[3] temp5=test_temp_list[4] fan_fail=0 if temp4==0: temp_get=50000 logging.debug('lm75_4a detect fail, so set temp_get=50000, let fan to 75%') elif temp5==0: temp_get=50000 logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%') else: temp_get=(temp4 +temp5)/2 ori_state=fan_policy_state if test_temp!=0: temp_test_data=temp_test_data+1000 temp_get=temp_get +temp_test_data logging.debug('Unit test:temp_get=%d', temp_get) fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy) logging.debug('lm75_4a=%d, lm_4b=%d', temp4,temp5) logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state) new_perc=fan_policy[fan_policy_state][0] if fan_fail==0: logging.debug('new_fan_cycle=%d', new_perc) if fan_fail==0: if new_perc!=ori_perc: platform_chassis.get_fan(0).set_speed(new_perc) logging.info('Set fan speed from %d to %d', ori_perc, new_perc) for i in range(FAN_NUM_MAX*FANS_PERTRAY): if not platform_chassis.get_fan(i).get_status() or not platform_chassis.get_fan(i).get_speed_rpm(): logging.debug('fan-%d status=%d, rpm=%d', i+1, platform_chassis.get_fan(i).get_status(), platform_chassis.get_fan(i).get_speed_rpm()) new_perc=100 logging.debug('fan_%d fail, set new_perc to 100',i+1) if test_temp==0: fan_fail=1 platform_chassis.get_fan(0).set_speed(new_perc) break else: fan_fail=0 new_state=fan_policy_state if ori_state==LEVEL_FAN_DEF: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected, reboot DUT') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MID: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MAX: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if alarm_state==1: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_HIGH: if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if new_state <=LEVEL_FAN_MID: logging.warning('Alarm for temperature high is cleared') alarm_state=0 if new_state <=LEVEL_FAN_MAX: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_CRITICAL: if new_state <=LEVEL_FAN_MAX: logging.warning('Alarm for temperature critical is cleared') return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv,'hdlt:',['lfile=']) except getopt.GetoptError: print(('Usage: %s[-d][-l <log_file>]' % sys.argv[0])) return 0 for opt, arg in opts: if opt=='-h': print(('Usage: %s[-d][-l <log_file>]' % sys.argv[0])) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv)!=7: print(\"temp test, need input six temp\") return 0 i=0 for x in range(2, 7): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) global platform_chassis platform_chassis=platform.Platform().get_chassis() platform_chassis.get_fan(0).set_speed(38) print(\"set default fan speed to 37.5%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(10) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2017 Accton Technology Corporation\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    mm/dd/yyyy (A.D.)#   \n#    4/20/2018: Jostar modify for as7726_32x\n#    12/03/2018:Jostar modify for as7726_32x thermal plan\n#    11/16/2020:Jostar modify for as7726_32x thermal plan based on PDDF\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import sys\n    import getopt\n    import logging\n    import logging.config\n    import logging.handlers\n    import time\n    from sonic_platform import platform\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as7726_32x_pddf_monitor'\n\nplatform_chassis = None\n \n#  Air Flow Front to Back :\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 <=38C : Keep 37.5%(0x04) Fan speed\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 38C : Change Fan speed from 37.5%(0x04) to 62.5%(0x08)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 46C : Change Fan speed from 62.5%(0x08) to 100%(0x0E)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 58C : Send alarm message\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 66C : Shut down system\n#  One Fan fail : Change Fan speed to 100%(0x0E)\n\n\n#  Air Flow Back to Front :\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 <=34C : Keep 37.5%(0x04) Fan speed\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 34C : Change Fan speed from 37.5%(0x04) to 62.5%(0x08)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 44C : Change Fan speed from 62.5%(0x08) to 100%(0x0E)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 59C : Send alarm message\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 67C : Shut down system\n#  One Fan fail:  Change Fan speed to 100%(0x0E)\n#  sensor_LM75_CPU == sensor_LM75_4B\n \n     \nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n \n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n     \n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args: # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\n\nfan_policy_state=1\nfan_fail=0\nalarm_state = 0 #0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0, 0, 0, 0, 0]\ntemp_test_data=0\n\n\n# Make a class we can use to capture stdout and sterr in the log\nclass device_monitor(object):\n        \n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format= '[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = logging.handlers.SysLogHandler(address = '/dev/log')\n        sys_handler.setLevel(logging.WARNING)       \n        logging.getLogger('').addHandler(sys_handler)\n          \n    def get_state_from_fan_policy(self, temp, policy):\n        state=0\n        \n        logging.debug('temp=%d', temp)\n        for i in range(0, len(policy)):\n            if temp > policy[i][2]:\n                if temp <= policy[i][3]:\n                    state =i\n                    logging.debug ('temp=%d >= policy[%d][2]=%d,  temp=%d < policy[%d][3]=%d' , temp, i, policy[i][2], temp, i, policy[i][3])\n                    logging.debug ('fan_state=%d', state)\n                    break\n        \n        return state\n\n    def manage_fans(self):\n       \n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list        \n        global alarm_state\n        global temp_test_data\n        global platform_chassis\n        \n        LEVEL_FAN_DEF=0\n        LEVEL_FAN_MID=1       \n        LEVEL_FAN_MAX=2\n        LEVEL_TEMP_HIGH=3\n        LEVEL_TEMP_CRITICAL=4\n        FAN_NUM_MAX = 6\n        FANS_PERTRAY=2\n        \n        fan_policy_f2b = {\n           LEVEL_FAN_DEF:       [38,  0x4, 0,     38000],\n           LEVEL_FAN_MID:       [63,  0x6, 38000, 46000],\n           LEVEL_FAN_MAX:       [100, 0xE, 46000, 58000],\n           LEVEL_TEMP_HIGH:     [100, 0xE, 58000, 66000],\n           LEVEL_TEMP_CRITICAL: [100, 0xE, 58000, 200000],\n        }\n        fan_policy_b2f = {\n           LEVEL_FAN_DEF:       [38,  0x4, 0,     34000],\n           LEVEL_FAN_MID:       [63,  0x8, 34000, 44000],\n           LEVEL_FAN_MAX:       [100, 0xE, 44000, 59000],\n           LEVEL_TEMP_HIGH:     [100, 0xE, 59000, 67000],\n           LEVEL_TEMP_CRITICAL: [100, 0xE, 59000, 200000],\n        }\n        \n        fan_dir= platform_chassis.get_fan(0).get_direction()\n        if fan_dir == 'EXHAUST':\n            fan_policy = fan_policy_f2b\n        else:\n            fan_policy = fan_policy_b2f\n        \n        ori_perc=platform_chassis.get_fan(0).get_speed()\n        #ori_perc=fan.get_fan_duty_cycle()\n        logging.debug('fan_dir=%s, ori_perc=%d, test_temp=%d', fan_dir, ori_perc, test_temp)\n        if test_temp==0:\n            temp4 = platform_chassis.get_thermal(3).get_temperature()*1000\n            temp5 = platform_chassis.get_thermal(4).get_temperature()*1000\n        else:\n            temp4 = test_temp_list[3]\n            temp5 = test_temp_list[4]            \n            fan_fail=0\n        \n        if temp4==0:\n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_4a detect fail, so set temp_get=50000, let fan to 75%')\n        elif temp5==0:        \n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%')\n        else:    \n            temp_get= (temp4 + temp5)/2  # Use (sensor_LM75_4a + sensor_LM75_4b) /2 \n            \n        ori_state=fan_policy_state\n        \n        if test_temp!=0:\n            temp_test_data=temp_test_data+1000\n            temp_get = temp_get + temp_test_data\n            logging.debug('Unit test:temp_get=%d', temp_get)\n        \n        fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy)\n                        \n        logging.debug('lm75_4a=%d, lm_4b=%d', temp4,temp5)\n        logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state)\n        new_perc = fan_policy[fan_policy_state][0]\n        if fan_fail==0:\n            logging.debug('new_fan_cycle=%d', new_perc)\n        \n        if fan_fail==0:\n            if new_perc!=ori_perc:\n                platform_chassis.get_fan(0).set_speed(new_perc)\n                logging.info('Set fan speed from %d to %d', ori_perc, new_perc)\n        \n        #Check Fan status\n        for i in range(FAN_NUM_MAX*FANS_PERTRAY):\n            if not platform_chassis.get_fan(i).get_status() or not platform_chassis.get_fan(i).get_speed_rpm():\n                logging.debug('fan-%d status=%d, rpm=%d', i+1, platform_chassis.get_fan(i).get_status(), platform_chassis.get_fan(i).get_speed_rpm())\n                new_perc=100\n                logging.debug('fan_%d fail, set new_perc to 100',i+1)                \n                if test_temp==0:\n                    fan_fail=1\n                    platform_chassis.get_fan(0).set_speed(new_perc)\n                    break\n            else:\n                fan_fail=0\n      \n        new_state = fan_policy_state\n        \n        if ori_state==LEVEL_FAN_DEF:            \n           if new_state==LEVEL_TEMP_HIGH:\n               if alarm_state==0:\n                   logging.warning('Alarm for temperature high is detected')\n               alarm_state=1\n           if new_state==LEVEL_TEMP_CRITICAL:\n               logging.critical('Alarm for temperature critical is detected, reboot DUT')\n               time.sleep(2)\n               os.system('reboot')           \n        if ori_state==LEVEL_FAN_MID:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state=1 \n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n        if ori_state==LEVEL_FAN_MAX:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected') \n                alarm_state=1\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n            if alarm_state==1:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_HIGH:\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n            if new_state <= LEVEL_FAN_MID:\n                logging.warning('Alarm for temperature high is cleared')\n                alarm_state=0\n            if new_state <= LEVEL_FAN_MAX:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_CRITICAL:            \n            if new_state <= LEVEL_FAN_MAX:\n                logging.warning('Alarm for temperature critical is cleared')\n      \n        return True\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv,'hdlt:',['lfile='])\n        except getopt.GetoptError:\n            print(('Usage: %s [-d] [-l <log_file>]' % sys.argv[0]))\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print(('Usage: %s [-d] [-l <log_file>]' % sys.argv[0]))\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg            \n        \n        if sys.argv[1]== '-t':\n            if len(sys.argv)!=7:\n                print(\"temp test, need input six temp\")\n                return 0\n            \n            i=0\n            for x in range(2, 7):\n               test_temp_list[i]= int(sys.argv[x])*1000\n               i=i+1\n            test_temp = 1   \n            log_level = logging.DEBUG\n            print(test_temp_list)\n    \n    global platform_chassis\n    platform_chassis = platform.Platform().get_chassis()\n    \n    platform_chassis.get_fan(0).set_speed(38)\n  \n    print(\"set default fan speed to 37.5%\")\n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(10)\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    \n"}, "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py": {"changes": [{"diff": "\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', l", "add": 6, "remove": 6, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py", "badparts": ["    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cdump -y 0 0x42 s 0x9a\"", "        status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]", "        status, output = getstatusoutput_noshell(cmd)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes \"\"\" import subprocess import getopt import sys import logging import re import time PROJECT_NAME='as7726_32x' version='0.0.1' verbose=False DEBUG=False args=[] ALL_DEVICE={} i2c_prefix='/sys/bus/i2c/devices/' ''' i2c_bus={'fan':['54-0066'], 'thermal':['54-004c', '55-0048','55-0049', '55-004a', '55-004b'], 'psu':['49-0050','50-0053'], 'sfp':['-0050']} i2c_nodes={'fan':['present', 'front_speed_rpm', 'rear_speed_rpm'], 'thermal':['hwmon/hwmon*/temp1_input'], 'psu':['psu_present ', 'psu_power_good'] , 'sfp':['module_present_ ', 'module_tx_disable_']} ''' sfp_map=[21, 22, 23, 24, 26, 25, 28, 27, 17, 18, 19, 20, 29, 30, 31, 32, 33, 34, 35, 36, 45, 46, 47, 48, 37, 38, 39, 40, 41, 42, 43, 44, 15, 16] mknod=[ 'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo as7726_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-11/new_device', 'echo as7726_32x_cpld2 0x62 > /sys/bus/i2c/devices/i2c-12/new_device', 'echo as7726_32x_cpld3 0x64 > /sys/bus/i2c/devices/i2c-13/new_device', 'echo as7726_32x_fan 0x66 > /sys/bus/i2c/devices/i2c-54/new_device', 'echo lm75 0x4c > /sys/bus/i2c/devices/i2c-54/new_device', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-55/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-55/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-55/new_device', 'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-55/new_device', 'echo as7726_32x_psu1 0x53 > /sys/bus/i2c/devices/i2c-50/new_device', 'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-50/new_device', 'echo as7726_32x_psu2 0x50> /sys/bus/i2c/devices/i2c-49/new_device', 'echo ym2651 0x58 > /sys/bus/i2c/devices/i2c-49/new_device', 'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-0/new_device', ] FORCE=0 logging.basicConfig(filename=PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG) logging.basicConfig(level=logging.INFO) if DEBUG==True: print((sys.argv[0])) print(('ARGV :', sys.argv[1:])) def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print(options) print(args) print((len(sys.argv))) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': do_install() elif arg=='clean': do_uninstall() else: show_help() return 0 def show_help(): print(( __doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]})) sys.exit(0) def dis_i2c_ir3570a(addr): cmd=\"i2cset -y 0 0x%x 0xE5 0x01\" % addr status, output=subprocess.getstatusoutput(cmd) cmd=\"i2cset -y 0 0x%x 0x12 0x02\" % addr status, output=subprocess.getstatusoutput(cmd) return status def ir3570_check(): cmd=\"i2cdump -y 0 0x42 s 0x9a\" try: status, output=subprocess.getstatusoutput(cmd) lines=output.split('\\n') hn=re.findall(r'\\w+', lines[-1]) version=int(hn[1], 16) if version==0x24: ret=dis_i2c_ir3570a(4) else: ret=0 except Exception as e: print(( \"Error on ir3570_check() e:\" +str(e))) return -1 return ret def my_log(txt): if DEBUG==True: print((\"[ACCTON DBG]: \",txt)) return def log_os_system(cmd, show): logging.info('Run:'+cmd) status=1 output=\"\" status, output=subprocess.getstatusoutput(cmd) my_log(cmd +\" with result:\" +str(status)) if status: logging.info('Failed:'+cmd) if show: print(('Failed:'+cmd)) return status, output def driver_inserted(): ret, lsmod=log_os_system(\"ls /sys/module/*accton*\", 0) logging.info('mods:'+lsmod) if ret: return False else: return True def cpld_reset_mac(): ret, lsmod=log_os_system(\"i2cset -y 0 0x77 0x1\", 0) ret, lsmod=log_os_system(\"i2cset -y 0 0x76 0x4\", 0) ret, lsmod=log_os_system(\"i2cset -y 0 0x60 0x8 0x77\", 0) time.sleep(1) ret, lsmod=log_os_system(\"i2cset -y 0 0x60 0x8 0xf7\", 0) return True kos=[ 'depmod -ae', 'modprobe i2c_dev', 'modprobe i2c_mux_pca954x force_deselect_on_exit=1', 'modprobe ym2651y', 'modprobe accton_as7726_32x_cpld', 'modprobe accton_as7726_32x_fan', 'modprobe accton_as7726_32x_leds', 'modprobe accton_as7726_32x_psu', 'modprobe optoe'] def driver_install(): global FORCE for i in range(0,len(kos)): status, output=log_os_system(kos[i], 1) if status: if FORCE==0: return status print(\"Done driver_install\") return 0 def driver_uninstall(): global FORCE for i in range(0,len(kos)): rm=kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\") lst=rm.split(\" \") if len(lst) > 3: del(lst[3]) rm=\" \".join(lst) status, output=log_os_system(rm, 1) if status: if FORCE==0: return status return 0 def device_install(): global FORCE for i in range(0,len(mknod)): if mknod[i].find('pca954') !=-1: time.sleep(2) status, output=log_os_system(mknod[i], 1) if status: print(output) if FORCE==0: return status for i in range(0,len(sfp_map)): status, output=log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1) if status: print(output) if FORCE==0: return status status, output=log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1) if status: print(output) if FORCE==0: return status print(\"Done device_install\") return def device_uninstall(): global FORCE status, output=log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0) if status==0: I2C_ORDER=1 else: \tI2C_ORDER=0 for i in range(0,len(sfp_map)): target=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\" status, output=log_os_system(\"echo 0x50 > \"+target, 1) if status: print(output) if FORCE==0: return status nodelist=mknod for i in range(len(nodelist)): target=nodelist[-(i+1)] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status return def system_ready(): if driver_inserted()==False: return False if not device_exist(): print(\"not device_exist()\") return False return True def do_install(): if driver_inserted()==False: status=driver_install() if status: if FORCE==0: return status else: print((PROJECT_NAME.upper()+\" drivers detected....\")) ir3570_check() if not device_exist(): status=device_install() if status: if FORCE==0: return status else: print((PROJECT_NAME.upper()+\" devices detected....\")) return def do_uninstall(): if not device_exist(): print((PROJECT_NAME.upper()+\" has no device installed....\")) else: print(\"Removing device....\") status=device_uninstall() if status: if FORCE==0: return status if driver_inserted()==False: print((PROJECT_NAME.upper()+\" has no driver installed....\")) else: print(\"Removing installed driver....\") status=driver_uninstall() if status: if FORCE==0: return status return def device_exist(): ret1, log=log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0) ret2, log=log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# Copyright (C) 2016 Accton Networks, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean\ncommand:\n    install     : install drivers and generate related sysfs nodes\n    clean       : uninstall drivers and remove related sysfs nodes\n\"\"\"\nimport subprocess\nimport getopt\nimport sys\nimport logging\nimport re\nimport time\n\nPROJECT_NAME = 'as7726_32x'\nversion = '0.0.1'\nverbose = False\nDEBUG = False\nargs = []\nALL_DEVICE = {}\n\ni2c_prefix = '/sys/bus/i2c/devices/'\n'''\ni2c_bus = {'fan': ['54-0066'],\n           'thermal': ['54-004c', '55-0048','55-0049', '55-004a', '55-004b'] ,\n           'psu': ['49-0050','50-0053'],\n           'sfp': ['-0050']}\ni2c_nodes = {'fan': ['present', 'front_speed_rpm', 'rear_speed_rpm'],\n           'thermal': ['hwmon/hwmon*/temp1_input'] ,\n           'psu': ['psu_present ', 'psu_power_good']    ,\n           'sfp': ['module_present_ ', 'module_tx_disable_']}\n'''\nsfp_map = [21, 22, 23, 24, 26, 25, 28, 27,\n             17, 18, 19, 20, 29, 30, 31, 32,\n             33, 34, 35, 36, 45, 46, 47, 48,\n             37, 38, 39, 40, 41, 42, 43, 44,\n             15, 16]\n\nmknod =[\n'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-2/new_device',\n\n'echo as7726_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-11/new_device',\n'echo as7726_32x_cpld2 0x62 > /sys/bus/i2c/devices/i2c-12/new_device',\n'echo as7726_32x_cpld3 0x64 > /sys/bus/i2c/devices/i2c-13/new_device',\n\n'echo as7726_32x_fan 0x66 > /sys/bus/i2c/devices/i2c-54/new_device',\n\n\n'echo lm75 0x4c > /sys/bus/i2c/devices/i2c-54/new_device',\n'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-55/new_device',\n'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-55/new_device',\n'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-55/new_device',\n'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-55/new_device',\n\n\n# PSU-1\n'echo as7726_32x_psu1 0x53 > /sys/bus/i2c/devices/i2c-50/new_device',\n'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-50/new_device',\n\n# PSU-2\n'echo as7726_32x_psu2 0x50> /sys/bus/i2c/devices/i2c-49/new_device',\n'echo ym2651 0x58 > /sys/bus/i2c/devices/i2c-49/new_device',\n\n#EERPOM\n'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-0/new_device',\n]\n\n\n\nFORCE = 0\nlogging.basicConfig(filename= PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG)\nlogging.basicConfig(level=logging.INFO)\n\n\nif DEBUG == True:\n    print((sys.argv[0]))\n    print(('ARGV      :', sys.argv[1:]))\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n\n    if len(sys.argv)<2:\n        show_help()\n\n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:\n        print(options)\n        print(args)\n        print((len(sys.argv)))\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n           do_install()\n        elif arg == 'clean':\n           do_uninstall()\n        else:\n            show_help()\n\n\n    return 0\n\ndef show_help():\n    print(( __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]}))\n    sys.exit(0)\n\ndef dis_i2c_ir3570a(addr):\n    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef ir3570_check():\n    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n    try:\n        status, output = subprocess.getstatusoutput(cmd)\n        lines = output.split('\\n')\n        hn = re.findall(r'\\w+', lines[-1])\n        version = int(hn[1], 16)\n        if version == 0x24:  #only for ir3570a\n            ret = dis_i2c_ir3570a(4)\n        else:\n            ret = 0\n    except Exception as e:\n        print(( \"Error on ir3570_check() e:\" + str(e)))\n        return -1\n    return ret\n\n\ndef my_log(txt):\n    if DEBUG == True:\n        print((\"[ACCTON DBG]: \",txt))\n    return\n\ndef log_os_system(cmd, show):\n    logging.info('Run :'+cmd)\n    status = 1\n    output = \"\"\n    status, output = subprocess.getstatusoutput(cmd)\n    my_log (cmd +\" with result:\" + str(status))\n    #my_log (\"cmd:\" + cmd)\n    #my_log (\"      output:\"+output)\n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print(('Failed :'+cmd))\n    return  status, output\n\ndef driver_inserted():\n    ret, lsmod = log_os_system(\"ls /sys/module/*accton*\", 0)\n    logging.info('mods:'+lsmod)\n    if ret :\n        return False\n    else :\n        return True\n\ndef cpld_reset_mac():\n    ret, lsmod = log_os_system(\"i2cset -y 0 0x77 0x1\", 0)\n    ret, lsmod = log_os_system(\"i2cset -y 0 0x76 0x4\", 0)\n    ret, lsmod = log_os_system(\"i2cset -y 0 0x60 0x8 0x77\", 0)\n    time.sleep(1)\n    ret, lsmod = log_os_system(\"i2cset -y 0 0x60 0x8 0xf7\", 0)\n    return True\n\n\n\n#'modprobe cpr_4011_4mxx',\n\nkos = [\n'depmod -ae',\n'modprobe i2c_dev',\n'modprobe i2c_mux_pca954x force_deselect_on_exit=1',\n'modprobe ym2651y',\n'modprobe accton_as7726_32x_cpld',\n'modprobe accton_as7726_32x_fan',\n'modprobe accton_as7726_32x_leds',\n'modprobe accton_as7726_32x_psu',\n'modprobe optoe']\n\ndef driver_install():\n    global FORCE\n    for i in range(0,len(kos)):\n        status, output = log_os_system(kos[i], 1)\n        if status:\n            if FORCE == 0:\n                return status\n\n    print(\"Done driver_install\")\n    \n    #status=cpld_reset_mac()\n    return 0\n\ndef driver_uninstall():\n    global FORCE\n    for i in range(0,len(kos)):\n        rm = kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\")        \n        lst = rm.split(\" \")\n\n        if len(lst) > 3:\n            del(lst[3])\n        rm = \" \".join(lst)\n        status, output = log_os_system(rm, 1)\n        if status:\n            if FORCE == 0:\n                return status\n    return 0\n\ndef device_install():\n    global FORCE\n\n    for i in range(0,len(mknod)):\n        #for pca954x need times to built new i2c buses\n        if mknod[i].find('pca954') != -1:\n            time.sleep(2)\n        \n        status, output = log_os_system(mknod[i], 1)        \n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    for i in range(0,len(sfp_map)):\n        status, output =log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n        status, output =log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    print(\"Done device_install\")\n\n    return\n\ndef device_uninstall():\n    global FORCE\n\n    status, output =log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0)\n    if status==0:\n        I2C_ORDER=1\n    else:\n    \tI2C_ORDER=0\n\n    for i in range(0,len(sfp_map)):\n        target = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\"\n        status, output =log_os_system(\"echo 0x50 > \"+ target, 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n                \n    nodelist = mknod\n\n    for i in range(len(nodelist)):\n        target = nodelist[-(i+1)]\n        temp = target.split()\n        del temp[1]\n        temp[-1] = temp[-1].replace('new_device', 'delete_device')\n        status, output = log_os_system(\" \".join(temp), 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    return\n\ndef system_ready():\n    if driver_inserted() == False:        \n        return False\n    if not device_exist():\n        print(\"not device_exist()\")\n        return False\n    return True\n\ndef do_install():\n    if driver_inserted() == False:\n        status = driver_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print((PROJECT_NAME.upper()+\" drivers detected....\"))\n\n    ir3570_check()\n\n    if not device_exist():\n        status = device_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print((PROJECT_NAME.upper()+\" devices detected....\"))\n    return\n\ndef do_uninstall():\n    if not device_exist():\n        print((PROJECT_NAME.upper()+\" has no device installed....\"))\n    else:\n        print(\"Removing device....\")\n        status = device_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    if driver_inserted()== False :\n        print((PROJECT_NAME.upper()+\" has no driver installed....\"))\n    else:\n        print(\"Removing installed driver....\")\n        status = driver_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    return\n\ndef device_exist():\n    ret1, log = log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0)\n    ret2, log = log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as7726_32x_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n", "add": 9, "remove": 9, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py", "badparts": ["import subprocess", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py clean\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py\", \"clean\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py install\"])\n     if status:\n         print(\"accton_as7726_32x_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n", "add": 7, "remove": 7, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py install\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py install\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor.service\"])"]}, {"diff": "\n     return True\n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.serv", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}], "source": "\n import subprocess def check_pddf_support(): return True def stop_platform_svc(): status, output=subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-fan.service\") if status: print(\"Stop as7726-32x-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-fan.service\") if status: print(\"Disable as7726-32x-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-psu.service\") if status: print(\"Stop as7726-32x-platform-monitor-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-psu.service\") if status: print(\"Disable as7726-32x-platform-monitor-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor.service\") if status: print(\"Stop as7726-32x-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor.service\") if status: print(\"Disable as7726-32x-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py clean\") if status: print(\"accton_as7726_32x_util.py clean command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status) return False return True def start_platform_svc(): status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py install\") if status: print(\"accton_as7726_32x_util.py install command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-fan.service\") if status: print(\"Enable as7726-32x-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-fan.service\") if status: print(\"Start as7726-32x-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-psu.service\") if status: print(\"Enable as7726-32x-platform-monitor-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-psu.service\") if status: print(\"Start as7726-32x-platform-monitor-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor.service\") if status: print(\"Enable as7726-32x-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor.service\") if status: print(\"Start as7726-32x-platform-monitor.service failed %d\"%status) return False return True def start_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print(\"Start pddf-platform-init.service failed %d\"%status) return False return True def stop_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service failed %d\"%status) return False return True def main(): pass if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services. \n# This will be used while switching the pddf->non-pddf mode and vice versa\n\nimport subprocess\n\ndef check_pddf_support():\n    return True\n\ndef stop_platform_svc():\n    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-fan.service\")\n    if status:\n        print(\"Stop as7726-32x-platform-monitor-fan.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-fan.service\")\n    if status:\n        print(\"Disable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-psu.service\")\n    if status:\n        print(\"Stop as7726-32x-platform-monitor-psu.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-psu.service\")\n    if status:\n        print(\"Disable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor.service\")\n    if status:\n        print(\"Stop as7726-32x-platform-monitor.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor.service\")\n    if status:\n        print(\"Disable as7726-32x-platform-monitor.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py clean\")\n    if status:\n        print(\"accton_as7726_32x_util.py clean command failed %d\"%status)\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n        return False\n\n    return True\n    \ndef start_platform_svc():\n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py install\")\n    if status:\n        print(\"accton_as7726_32x_util.py install command failed %d\"%status)\n        return False\n\n    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-fan.service\")\n    if status:\n        print(\"Enable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-fan.service\")\n    if status:\n        print(\"Start as7726-32x-platform-monitor-fan.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-psu.service\")\n    if status:\n        print(\"Enable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-psu.service\")\n    if status:\n        print(\"Start as7726-32x-platform-monitor-psu.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor.service\")\n    if status:\n        print(\"Enable as7726-32x-platform-monitor.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor.service\")\n    if status:\n        print(\"Start as7726-32x-platform-monitor.service failed %d\"%status)\n        return False\n\n    return True\n\ndef start_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print(\"Start pddf-platform-init.service failed %d\"%status)\n        return False\n    \n    return True\n\ndef stop_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service failed %d\"%status)\n        return False\n\n    return True\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py": {"changes": [{"diff": "\n     print( __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]})\n     sys.exit(0)\n \n-   \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+',", "add": 6, "remove": 7, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py", "badparts": ["    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cdump -y 0 0x42 s 0x9a\"", "        status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]", "        status, output = getstatusoutput_noshell(cmd)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes \"\"\" import subprocess import getopt import sys import logging import re import time import os PROJECT_NAME='as7816_64x' version='0.1.0' verbose=False DEBUG=False args=[] ALL_DEVICE={} FORCE=0 if DEBUG==True: print(sys.argv[0]) print('ARGV :', sys.argv[1:] ) def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print(options) print(args) print(len(sys.argv)) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': do_install() elif arg=='clean': do_uninstall() elif arg=='api': do_sonic_platform_install() elif arg=='api_clean': do_sonic_platform_clean() else: show_help() return 0 def show_help(): print( __doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]}) sys.exit(0) def dis_i2c_ir3570a(addr): cmd=\"i2cset -y 0 0x%x 0xE5 0x01\" % addr status, output=subprocess.getstatusoutput(cmd) cmd=\"i2cset -y 0 0x%x 0x12 0x02\" % addr status, output=subprocess.getstatusoutput(cmd) return status def ir3570_check(): cmd=\"i2cdump -y 0 0x42 s 0x9a\" try: status, output=subprocess.getstatusoutput(cmd) lines=output.split('\\n') hn=re.findall(r'\\w+', lines[-1]) version=int(hn[1], 16) if version==0x24: ret=dis_i2c_ir3570a(4) else: ret=0 except Exception as e: print(\"Error on ir3570_check() e:\" +str(e)) return -1 return ret def my_log(txt): if DEBUG==True: print(\"[ROY]\"+txt) return def log_os_system(cmd, show): logging.info('Run:'+cmd) status, output=subprocess.getstatusoutput(cmd) my_log(cmd +\"with result:\" +str(status)) my_log(\" output:\"+output) if status: logging.info('Failed:'+cmd) if show: print('Failed:'+cmd) return status, output def driver_check(): ret, lsmod=log_os_system(\"ls /sys/module/*accton*\", 0) logging.info('mods:'+lsmod) if ret: return False else: return True kos=[ 'modprobe i2c_dev', 'modprobe i2c_mux_pca954x force_deselect_on_exit=1', 'modprobe optoe', 'modprobe accton_i2c_cpld' , 'modprobe ym2651y' , 'modprobe x86-64-accton-as7816-64x-fan' , 'modprobe x86-64-accton-as7816-64x-leds' , 'modprobe x86-64-accton-as7816-64x-psu'] def driver_install(): global FORCE status, output=log_os_system(\"depmod\", 1) for i in range(0,len(kos)): status, output=log_os_system(kos[i], 1) if status: if FORCE==0: return status print(\"Done driver_install\") return 0 def driver_uninstall(): global FORCE for i in range(0,len(kos)): rm=kos[-(i+1)] lst=rm.split(\" \") if len(lst) > 2: del(lst[2:]) rm=\" \".join(lst) rm=rm.replace(\"modprobe\", \"modprobe -rq\") rm=rm.replace(\"insmod\", \"rmmod\") status, output=log_os_system(rm, 1) if status: if FORCE==0: return status return 0 i2c_prefix='/sys/bus/i2c/devices/' ''' i2c_bus={'fan':['17-0068'] , 'thermal':['18-0048','18-0049', '18-004a', '18-004b', '17-004d', '17-004e'], 'psu':['10-0053','9-0050'], 'sfp':['-0050']} i2c_nodes={'fan':['present', 'front_speed_rpm', 'rear_speed_rpm'], 'thermal':['hwmon/hwmon*/temp1_input'], 'psu':['psu_present', 'psu_power_good'] , 'sfp':['module_present']} ''' sfp_map=[37,38,39,40,42,41,44,43,33,34,35,36,45,46,47,48,49,50,51,52, 61,62,63,64,53,54,55,56,57,58,59,60,69,70,71,72,77,78,79,80,65, \t 66,67,68,73,74,75,76,85,86,87,88,31,32,29,30,81,82,83,84,25,26, 27,28] mknod=[ 'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo as7816_64x_psu1 0x53 > /sys/bus/i2c/devices/i2c-10/new_device', 'echo ym2851 0x5b > /sys/bus/i2c/devices/i2c-10/new_device', 'echo as7816_64x_psu2 0x50 > /sys/bus/i2c/devices/i2c-9/new_device', 'echo ym2851 0x58 > /sys/bus/i2c/devices/i2c-9/new_device', 'echo as7816_64x_fan 0x68 > /sys/bus/i2c/devices/i2c-17/new_device', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4d > /sys/bus/i2c/devices/i2c-17/new_device', 'echo lm75 0x4e > /sys/bus/i2c/devices/i2c-17/new_device', 'echo cpld_as7816 0x60 > /sys/bus/i2c/devices/i2c-19/new_device', 'echo cpld_plain 0x62 > /sys/bus/i2c/devices/i2c-20/new_device', 'echo cpld_plain 0x64 > /sys/bus/i2c/devices/i2c-21/new_device', 'echo cpld_plain 0x66 > /sys/bus/i2c/devices/i2c-22/new_device'] def i2c_order_check(): return 0 def device_install(): global FORCE for i in range(0,len(mknod)): if mknod[i].find('pca954') !=-1: time.sleep(1) status, output=log_os_system(mknod[i], 1) if status: print(output) if FORCE==0: return status for i in range(0,len(sfp_map)): path=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\" status, output=log_os_system(\"echo optoe1 0x50 > \" +path, 1) if status: print(output) if FORCE==0: return status print(\"Done device_install\") return def device_uninstall(): global FORCE status, output=log_os_system(\"ls /sys/bus/i2c/devices/1-0076\", 0) for i in range(0,len(sfp_map)): target=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\" status, output=log_os_system(\"echo 0x50 > \"+target, 1) if status: print(output) if FORCE==0: return status nodelist=mknod for i in range(len(nodelist)): target=nodelist[-(i+1)] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status return def system_ready(): if driver_check()==False: return False if not device_exist(): return False return True PLATFORM_ROOT_PATH='/usr/share/sonic/device' PLATFORM_API2_WHL_FILE_PY3='sonic_platform-1.0-py3-none-any.whl' def do_sonic_platform_install(): device_path=\"{}{}{}{}\".format(PLATFORM_ROOT_PATH, '/x86_64-accton_', PROJECT_NAME, '-r0') SONIC_PLATFORM_BSP_WHL_PKG_PY3=\"/\".join([device_path, PLATFORM_API2_WHL_FILE_PY3]) status, output=log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0) if status: if os.path.exists(SONIC_PLATFORM_BSP_WHL_PKG_PY3): status, output=log_os_system(\"pip3 install \"+SONIC_PLATFORM_BSP_WHL_PKG_PY3, 1) if status: print(\"Error: Failed to install{}\".format(PLATFORM_API2_WHL_FILE_PY3)) return status else: print(\"Successfully installed{} package\".format(PLATFORM_API2_WHL_FILE_PY3)) else: print('{} is not found'.format(PLATFORM_API2_WHL_FILE_PY3)) else: print('{} has installed'.format(PLATFORM_API2_WHL_FILE_PY3)) return def do_sonic_platform_clean(): status, output=log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0) if status: print('{} does not install, not need to uninstall'.format(PLATFORM_API2_WHL_FILE_PY3)) else: status, output=log_os_system(\"pip3 uninstall sonic-platform -y\", 0) if status: print('Error: Failed to uninstall{}'.format(PLATFORM_API2_WHL_FILE_PY3)) return status else: print('{} is uninstalled'.format(PLATFORM_API2_WHL_FILE_PY3)) return def do_install(): print(\"Checking system....\") if driver_check()==False: print(\"No driver, installing....\") status=driver_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" drivers detected....\") ir3570_check() if not device_exist(): print(\"No device, installing....\") status=device_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" devices detected....\") do_sonic_platform_install() return def do_uninstall(): print(\"Checking system....\") if not device_exist(): print(PROJECT_NAME.upper() +\" has no device installed....\") else: print(\"Removing device....\") status=device_uninstall() if status: if FORCE==0: return status if driver_check()==False: print(PROJECT_NAME.upper() +\" has no driver installed....\") else: print(\"Removing installed driver....\") status=driver_uninstall() if status: if FORCE==0: return status do_sonic_platform_clean() return def device_exist(): ret1, log=log_os_system(\"ls \"+i2c_prefix+\"*0076\", 0) ret2, log=log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# Copyright (C) 2016 Accton Networks, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean\ncommand:\n    install     : install drivers and generate related sysfs nodes\n    clean       : uninstall drivers and remove related sysfs nodes\n\"\"\"\nimport subprocess\nimport getopt\nimport sys\nimport logging\nimport re\nimport time\nimport os\n\n\n\nPROJECT_NAME = 'as7816_64x'\nversion = '0.1.0'\nverbose = False\nDEBUG = False\nargs = []\nALL_DEVICE = {}               \n\nFORCE = 0\n#logging.basicConfig(filename= PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG)\n#logging.basicConfig(level=logging.INFO)\n\n\nif DEBUG == True:\n    print(sys.argv[0])\n    print('ARGV      :', sys.argv[1:]   )\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n        \n    if len(sys.argv)<2:\n        show_help()\n         \n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:\n        print(options)\n        print(args)\n        print(len(sys.argv))\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n           do_install()\n        elif arg == 'clean':\n           do_uninstall()\n        elif arg == 'api':\n           do_sonic_platform_install()\n        elif arg == 'api_clean':   \n           do_sonic_platform_clean()\n        \n        else:\n            show_help()\n\n\n    return 0\n\ndef show_help():\n    print( __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]})\n    sys.exit(0)\n\n   \ndef dis_i2c_ir3570a(addr):\n    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef ir3570_check():\n    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n    try:\n        status, output = subprocess.getstatusoutput(cmd)\n        lines = output.split('\\n')\n        hn = re.findall(r'\\w+', lines[-1])\n        version = int(hn[1], 16)\n        if version == 0x24:  #only for ir3570a\n            ret = dis_i2c_ir3570a(4)\n        else:\n            ret = 0\n    except Exception as e:\n        print(\"Error on ir3570_check() e:\" + str(e))\n        return -1\n    return ret\n\ndef my_log(txt):\n    if DEBUG == True:\n        print(\"[ROY]\"+txt)\n    return\n    \ndef log_os_system(cmd, show):\n    logging.info('Run :'+cmd)  \n    status, output = subprocess.getstatusoutput(cmd)    \n    my_log (cmd +\"with result:\" + str(status))\n    my_log (\"      output:\"+output)    \n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print('Failed :'+cmd)\n    return  status, output\n            \ndef driver_check():\n    ret, lsmod = log_os_system(\"ls /sys/module/*accton*\", 0)\n    logging.info('mods:'+lsmod)\n    if ret :\n        return False\n    else :\n        return True\n\n\n\nkos = [\n'modprobe i2c_dev',\n'modprobe i2c_mux_pca954x force_deselect_on_exit=1',\n'modprobe optoe',\n'modprobe accton_i2c_cpld'  ,\n'modprobe ym2651y'                  ,\n'modprobe x86-64-accton-as7816-64x-fan'     ,\n#'modprobe x86-64-accton-as7816-64x-sfp'      ,\n'modprobe x86-64-accton-as7816-64x-leds'      ,\n'modprobe x86-64-accton-as7816-64x-psu' ]\n\ndef driver_install():\n    global FORCE\n    status, output = log_os_system(\"depmod\", 1)\n    for i in range(0,len(kos)):\n        status, output = log_os_system(kos[i], 1)\n        if status:\n            if FORCE == 0:        \n                return status              \n    \n    print(\"Done driver_install\")\n    \n    return 0\n    \ndef driver_uninstall():\n    global FORCE\n    for i in range(0,len(kos)):\n        #remove parameter if any\n        rm = kos[-(i+1)]\n        lst = rm.split(\" \")\n        if len(lst) > 2:\n            del(lst[2:])\n        rm = \" \".join(lst)\n\n        #Change to removing commands\n        rm = rm.replace(\"modprobe\", \"modprobe -rq\")\n        rm = rm.replace(\"insmod\", \"rmmod\")        \n        status, output = log_os_system(rm, 1)\n        if status:\n            if FORCE == 0:        \n                return status              \n    return 0\n\n\ni2c_prefix = '/sys/bus/i2c/devices/'\n'''\ni2c_bus = {'fan': ['17-0068']                 ,\n           'thermal': ['18-0048','18-0049', '18-004a' , '18-004b', '17-004d', '17-004e'] ,\n           'psu': ['10-0053','9-0050'], \n           'sfp': ['-0050']}\ni2c_nodes = {'fan': ['present', 'front_speed_rpm', 'rear_speed_rpm'] ,\n           'thermal': ['hwmon/hwmon*/temp1_input'] ,\n           'psu': ['psu_present', 'psu_power_good']    ,\n           'sfp': ['module_present']}\n'''                  \n\nsfp_map =  [37,38,39,40,42,41,44,43,33,34,35,36,45,46,47,48,49,50,51,52,\n           61,62,63,64,53,54,55,56,57,58,59,60,69,70,71,72,77,78,79,80,65,\n\t   66,67,68,73,74,75,76,85,86,87,88,31,32,29,30,81,82,83,84,25,26,\n           27,28]\n\n\nmknod =[   \n'echo pca9548  0x77 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo pca9548  0x71 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548  0x76 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548  0x73 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548  0x70 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x71 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x72 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x73 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x74 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x75 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x76 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo 24c02  0x56 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo as7816_64x_psu1  0x53 > /sys/bus/i2c/devices/i2c-10/new_device',\n'echo ym2851  0x5b > /sys/bus/i2c/devices/i2c-10/new_device',\n'echo as7816_64x_psu2  0x50 > /sys/bus/i2c/devices/i2c-9/new_device',\n'echo ym2851  0x58 > /sys/bus/i2c/devices/i2c-9/new_device',\n'echo as7816_64x_fan  0x68 > /sys/bus/i2c/devices/i2c-17/new_device',\n'echo lm75  0x48 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75  0x49 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75  0x4a > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75  0x4b > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75  0x4d > /sys/bus/i2c/devices/i2c-17/new_device',\n'echo lm75  0x4e > /sys/bus/i2c/devices/i2c-17/new_device',\n'echo cpld_as7816  0x60 > /sys/bus/i2c/devices/i2c-19/new_device',\n'echo cpld_plain  0x62 > /sys/bus/i2c/devices/i2c-20/new_device',\n'echo cpld_plain  0x64 > /sys/bus/i2c/devices/i2c-21/new_device',\n'echo cpld_plain  0x66 > /sys/bus/i2c/devices/i2c-22/new_device']\n       \ndef i2c_order_check():    \n    return 0\n                     \ndef device_install():\n    global FORCE\n    \n    for i in range(0,len(mknod)):\n        #for pca954x need times to built new i2c buses            \n        if mknod[i].find('pca954') != -1:\n           time.sleep(1)         \n           \n        status, output = log_os_system(mknod[i], 1)\n        if status:\n            print(output)\n            if FORCE == 0:                \n                return status  \n\n    for i in range(0,len(sfp_map)):\n        path = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\"\n        status, output =log_os_system(\"echo optoe1 0x50 > \" + path, 1)\n        if status:\n            print(output)\n            if FORCE == 0:            \n                return status                                  \n     \n    print(\"Done device_install\")\n     \n    return \n    \ndef device_uninstall():\n    global FORCE\n    \n    status, output =log_os_system(\"ls /sys/bus/i2c/devices/1-0076\", 0)\n    \n    for i in range(0,len(sfp_map)):\n        target = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\"\n        status, output =log_os_system(\"echo 0x50 > \"+ target, 1)\n        if status:\n            print(output)\n            if FORCE == 0:            \n                return status\n       \n    nodelist = mknod\n           \n    for i in range(len(nodelist)):\n        target = nodelist[-(i+1)]\n        temp = target.split()\n        del temp[1]\n        temp[-1] = temp[-1].replace('new_device', 'delete_device')\n        status, output = log_os_system(\" \".join(temp), 1)\n        if status:\n            print(output)\n            if FORCE == 0:            \n                return status  \n                                  \n    return \n        \ndef system_ready():\n    if driver_check() == False:\n        return False\n    if not device_exist(): \n        return False\n    return True\n\nPLATFORM_ROOT_PATH = '/usr/share/sonic/device'\nPLATFORM_API2_WHL_FILE_PY3 ='sonic_platform-1.0-py3-none-any.whl'\ndef do_sonic_platform_install():\n    device_path = \"{}{}{}{}\".format(PLATFORM_ROOT_PATH, '/x86_64-accton_', PROJECT_NAME, '-r0')\n    SONIC_PLATFORM_BSP_WHL_PKG_PY3 = \"/\".join([device_path, PLATFORM_API2_WHL_FILE_PY3])\n        \n    #Check API2.0 on py whl file\n    status, output = log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0)\n    if status:\n        if os.path.exists(SONIC_PLATFORM_BSP_WHL_PKG_PY3): \n            status, output = log_os_system(\"pip3 install \"+ SONIC_PLATFORM_BSP_WHL_PKG_PY3, 1)\n            if status:\n                print(\"Error: Failed to install {}\".format(PLATFORM_API2_WHL_FILE_PY3))\n                return status\n            else:\n                print(\"Successfully installed {} package\".format(PLATFORM_API2_WHL_FILE_PY3))\n        else:\n            print('{} is not found'.format(PLATFORM_API2_WHL_FILE_PY3))\n    else:        \n        print('{} has installed'.format(PLATFORM_API2_WHL_FILE_PY3))\n     \n    return \n     \ndef do_sonic_platform_clean():\n    status, output = log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0)   \n    if status:\n        print('{} does not install, not need to uninstall'.format(PLATFORM_API2_WHL_FILE_PY3))\n        \n    else:        \n        status, output = log_os_system(\"pip3 uninstall sonic-platform -y\", 0)\n        if status:\n            print('Error: Failed to uninstall {}'.format(PLATFORM_API2_WHL_FILE_PY3))\n            return status\n        else:\n            print('{} is uninstalled'.format(PLATFORM_API2_WHL_FILE_PY3))\n\n    return\ndef do_install():\n    print(\"Checking system....\")\n    if driver_check() == False:\n        print(\"No driver, installing....\")    \n        status = driver_install()\n        if status:\n            if FORCE == 0:        \n                return  status\n    else:\n        print(PROJECT_NAME.upper()+\" drivers detected....\")\n\n    ir3570_check()\n\n    if not device_exist():\n        print(\"No device, installing....\")\n        status = device_install() \n        if status:\n            if FORCE == 0:        \n                return  status        \n    else:\n        print(PROJECT_NAME.upper()+\" devices detected....\")\n    do_sonic_platform_install()\n\n    return\n    \ndef do_uninstall():\n    print(\"Checking system....\")\n    if not device_exist():\n        print(PROJECT_NAME.upper() +\" has no device installed....\")\n    else:\n        print(\"Removing device....\")\n        status = device_uninstall() \n        if status:\n            if FORCE == 0:            \n                return  status  \n                \n    if driver_check()== False :\n        print(PROJECT_NAME.upper() +\" has no driver installed....\")\n    else:\n        print(\"Removing installed driver....\")\n        status = driver_uninstall()\n        if status:\n            if FORCE == 0:        \n                return  status                          \n                    \n    do_sonic_platform_clean() \n\n    return       \n\ndef device_exist():\n    ret1, log = log_os_system(\"ls \"+i2c_prefix+\"*0076\", 0)\n    ret2, log = log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services.\n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n def check_pddf_support():\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py", "badparts": ["import subprocess"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n \n def stop_platform_svc():\n \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Stop as7816-platform-init.service failed %d\" % status))\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Disable as7816-platform-init.service failed %d\" % status))\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"clean\"])\n     if status:\n         print((\"accton_as7816_util.py clean command failed %d\" % status))\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Stop pddf-platform-init.service along with other platform serives failed %d\" % status))\n         return False\n", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl stop as7816-platform-init.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as7816-platform-init.service\")", "    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py clean\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7816-platform-init.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7816-platform-init.service\"])", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"clean\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}, {"diff": "\n \n \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"install\"])\n     if status:\n         print((\"accton_as7816_util.py install command failed %d\" % status))\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Enable as7816-platform-init.service failed %d\" % status))\n         return False\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py install\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as7816-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"install\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7816-platform-init.service\"])"]}, {"diff": "\n \n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Start pddf-platform-init.service failed %d\" % status))\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])"]}, {"diff": "\n \n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Stop pddf-platform-init.servi", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}], "source": "\n import subprocess def check_pddf_support(): return True def stop_platform_svc(): status, output=subprocess.getstatusoutput(\"systemctl stop as7816-platform-init.service\") if status: print((\"Stop as7816-platform-init.service failed %d\" % status)) return False status, output=subprocess.getstatusoutput(\"systemctl disable as7816-platform-init.service\") if status: print((\"Disable as7816-platform-init.service failed %d\" % status)) return False status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py clean\") if status: print((\"accton_as7816_util.py clean command failed %d\" % status)) return False status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print((\"Stop pddf-platform-init.service along with other platform serives failed %d\" % status)) return False return True def start_platform_svc(): status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py install\") if status: print((\"accton_as7816_util.py install command failed %d\" % status)) return False status, output=subprocess.getstatusoutput(\"systemctl enable as7816-platform-init.service\") if status: print((\"Enable as7816-platform-init.service failed %d\" % status)) return False return True def start_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print((\"Start pddf-platform-init.service failed %d\" % status)) return False return True def stop_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print((\"Stop pddf-platform-init.service failed %d\" % status)) return False return True def main(): pass if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services.\n# This will be used while switching the pddf->non-pddf mode and vice versa\nimport subprocess\n\n\ndef check_pddf_support():\n    return True\n\n\ndef stop_platform_svc():\n\n    status, output = subprocess.getstatusoutput(\"systemctl stop as7816-platform-init.service\")\n    if status:\n        print((\"Stop as7816-platform-init.service failed %d\" % status))\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as7816-platform-init.service\")\n    if status:\n        print((\"Disable as7816-platform-init.service failed %d\" % status))\n        return False\n\n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py clean\")\n    if status:\n        print((\"accton_as7816_util.py clean command failed %d\" % status))\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print((\"Stop pddf-platform-init.service along with other platform serives failed %d\" % status))\n        return False\n\n    return True\n\n\ndef start_platform_svc():\n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py install\")\n    if status:\n        print((\"accton_as7816_util.py install command failed %d\" % status))\n        return False\n\n    status, output = subprocess.getstatusoutput(\"systemctl enable as7816-platform-init.service\")\n    if status:\n        print((\"Enable as7816-platform-init.service failed %d\" % status))\n        return False\n\n    return True\n\n\ndef start_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print((\"Start pddf-platform-init.service failed %d\" % status))\n        return False\n\n    return True\n\n\ndef stop_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print((\"Stop pddf-platform-init.service failed %d\" % status))\n        return False\n\n    return True\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py": {"changes": [{"diff": "\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+", "add": 6, "remove": 6, "filename": "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py", "badparts": ["    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cdump -y 0 0x42 s 0x9a\"", "        status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]", "        status, output = getstatusoutput_noshell(cmd)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes \"\"\" import subprocess import getopt import sys import logging import re import time PROJECT_NAME='as9716_32d' version='0.0.1' verbose=False DEBUG=False args=[] ALL_DEVICE={} i2c_prefix='/sys/bus/i2c/devices/' ''' i2c_bus={'fan':['54-0066'], 'thermal':['18-0048', '18-0049','18-004a', '18-004b', '18-004c', '18-004e', '18-004f'], 'psu':['9-0058', '10-0059'], 'sfp':['-0050']} i2c_nodes={'fan':['present', 'front_speed_rpm', 'rear_speed_rpm'], 'thermal':['hwmon/hwmon*/temp1_input'], 'psu':['psu_present ', 'psu_power_good'] , 'sfp':['module_present_ ', 'module_tx_disable_']} ''' sfp_map=[25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58] mknod=[ 'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo as9716_32d_fpga 0x60 > /sys/bus/i2c/devices/i2c-19/new_device', 'echo as9716_32d_cpld1 0x61 > /sys/bus/i2c/devices/i2c-20/new_device', 'echo as9716_32d_cpld2 0x62 > /sys/bus/i2c/devices/i2c-21/new_device', 'echo as9716_32d_cpld_cpu 0x65 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo as9716_32d_fan 0x66 > /sys/bus/i2c/devices/i2c-17/new_device', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4c > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4e > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4f > /sys/bus/i2c/devices/i2c-18/new_device', 'echo as9716_32d_psu1 0x50 > /sys/bus/i2c/devices/i2c-9/new_device', 'echo acbel_fsh082 0x58 > /sys/bus/i2c/devices/i2c-9/new_device', 'echo as9716_32d_psu2 0x51 > /sys/bus/i2c/devices/i2c-10/new_device', 'echo acbel_fsh082 0x59 > /sys/bus/i2c/devices/i2c-10/new_device', ] eeprom_mknod=[ 'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-0/new_device', ] FORCE=0 logging.basicConfig(filename=PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG) logging.basicConfig(level=logging.INFO) if DEBUG==True: print((sys.argv[0])) print(('ARGV :', sys.argv[1:])) def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print(options) print(args) print((len(sys.argv))) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': do_install() elif arg=='clean': do_uninstall() else: show_help() return 0 def show_help(): print(( __doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]})) sys.exit(0) def dis_i2c_ir3570a(addr): cmd=\"i2cset -y 0 0x%x 0xE5 0x01\" % addr status, output=subprocess.getstatusoutput(cmd) cmd=\"i2cset -y 0 0x%x 0x12 0x02\" % addr status, output=subprocess.getstatusoutput(cmd) return status def ir3570_check(): cmd=\"i2cdump -y 0 0x42 s 0x9a\" try: status, output=subprocess.getstatusoutput(cmd) lines=output.split('\\n') hn=re.findall(r'\\w+', lines[-1]) version=int(hn[1], 16) if version==0x24: ret=dis_i2c_ir3570a(4) else: ret=0 except Exception as e: print(( \"Error on ir3570_check() e:\" +str(e))) return -1 return ret def my_log(txt): if DEBUG==True: print((\"[ACCTON DBG]: \"+txt)) return def log_os_system(cmd, show): logging.info('Run:'+cmd) status=1 output=\"\" status, output=subprocess.getstatusoutput(cmd) my_log(cmd +\"with result:\" +str(status)) if status: logging.info('Failed:'+cmd) if show: print(('Failed:'+cmd)) return status, output def driver_inserted(): ret, lsmod=log_os_system(\"ls /sys/module/*accton*\", 0) logging.info('mods:'+lsmod) if ret: return False else: return True kos=[ 'depmod -ae', 'modprobe i2c_dev', 'modprobe i2c_mux_pca954x force_deselect_on_exit=1', 'modprobe accton_i2c_psu', 'modprobe accton_as9716_32d_cpld', 'modprobe accton_as9716_32d_fan', 'modprobe accton_as9716_32d_leds', 'modprobe accton_as9716_32d_psu', 'modprobe optoe', 'modprobe lm75'] cpld_reset_stop='i2cset -y 0 0x65 0x3 0x0' def driver_install(): global FORCE for i in range(0,len(kos)): status, output=log_os_system(kos[i], 1) if status: if FORCE==0: return status log_os_system(cpld_reset_stop, 1) print(\"Done driver_install\") return 0 def driver_uninstall(): global FORCE for i in range(0,len(kos)): rm=kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\") lst=rm.split(\" \") if len(lst) > 3: del(lst[3]) rm=\" \".join(lst) status, output=log_os_system(rm, 1) if status: if FORCE==0: return status return 0 def eeprom_check(): cmd=\"i2cget -y -f 0 0x57\" status, output=subprocess.getstatusoutput(cmd) return status def device_install(): global FORCE global use_57_eeprom for i in range(0,len(mknod)): if mknod[i].find('pca954') !=-1: time.sleep(2) status, output=log_os_system(mknod[i], 1) if status: print(output) if FORCE==0: return status ret=eeprom_check() if ret==0: log_os_system(eeprom_mknod[0], 1) else: log_os_system(eeprom_mknod[1], 1) for i in range(0,len(sfp_map)): status, output=log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1) if status: print(output) if FORCE==0: return status status, output=log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1) if status: print(output) if FORCE==0: return status print(\"Done device_install\") return def device_uninstall(): global FORCE status, output=log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0) if status==0: I2C_ORDER=1 else: \tI2C_ORDER=0 for i in range(0,len(sfp_map)): target=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\" status, output=log_os_system(\"echo 0x50 > \"+target, 1) if status: print(output) if FORCE==0: return status nodelist=mknod for i in range(len(nodelist)): target=nodelist[-(i+1)] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status ret=eeprom_check() if ret==0: target=eeprom_mknod[0] else: target=eeprom_mknod[1] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) return def system_ready(): if driver_inserted()==False: return False if not device_exist(): print(\"not device_exist()\") return False return True def do_install(): if driver_inserted()==False: status=driver_install() if status: if FORCE==0: return status else: print((PROJECT_NAME.upper()+\" drivers detected....\")) ir3570_check() if not device_exist(): status=device_install() if status: if FORCE==0: return status else: print((PROJECT_NAME.upper()+\" devices detected....\")) return def do_uninstall(): if not device_exist(): print((PROJECT_NAME.upper()+\" has no device installed....\")) else: print(\"Removing device....\") status=device_uninstall() if status: if FORCE==0: return status if driver_inserted()==False: print((PROJECT_NAME.upper()+\" has no driver installed....\")) else: print(\"Removing installed driver....\") status=driver_uninstall() if status: if FORCE==0: return status return def device_exist(): ret1, log=log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0) ret2, log=log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# Copyright (C) 2016 Accton Networks, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean\ncommand:\n    install     : install drivers and generate related sysfs nodes\n    clean       : uninstall drivers and remove related sysfs nodes\n\"\"\"\nimport subprocess\nimport getopt\nimport sys\nimport logging\nimport re\nimport time\n\nPROJECT_NAME = 'as9716_32d'\nversion = '0.0.1'\nverbose = False\nDEBUG = False\nargs = []\nALL_DEVICE = {}\n\ni2c_prefix = '/sys/bus/i2c/devices/'\n'''\ni2c_bus = {'fan': ['54-0066'],\n           'thermal': ['18-0048', '18-0049','18-004a', '18-004b', '18-004c', '18-004e', '18-004f'] ,\n           'psu': ['9-0058', '10-0059'],\n           'sfp': ['-0050']}\ni2c_nodes = {'fan': ['present', 'front_speed_rpm', 'rear_speed_rpm'],\n           'thermal': ['hwmon/hwmon*/temp1_input'] ,\n           'psu': ['psu_present ', 'psu_power_good']    ,\n           'sfp': ['module_present_ ', 'module_tx_disable_']}\n'''\n\nsfp_map = [25, 26, 27, 28, 29, 30, 31, 32,\n           33, 34, 35, 36, 37, 38, 39, 40,\n           41, 42, 43, 44, 45, 46, 47, 48,\n           49, 50, 51, 52, 53, 54, 55, 56,\n           57, 58]\n\n#sfp_map = [25, 26]\n\nmknod =[\n'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-2/new_device',\n\n'echo as9716_32d_fpga 0x60 > /sys/bus/i2c/devices/i2c-19/new_device',\n'echo as9716_32d_cpld1 0x61 > /sys/bus/i2c/devices/i2c-20/new_device',\n'echo as9716_32d_cpld2 0x62 > /sys/bus/i2c/devices/i2c-21/new_device',\n'echo as9716_32d_cpld_cpu 0x65 > /sys/bus/i2c/devices/i2c-0/new_device',\n\n'echo as9716_32d_fan 0x66 > /sys/bus/i2c/devices/i2c-17/new_device',\n\n'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x4c > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x4e > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x4f > /sys/bus/i2c/devices/i2c-18/new_device',\n \n# PSU-1\n'echo as9716_32d_psu1 0x50 > /sys/bus/i2c/devices/i2c-9/new_device',\n'echo acbel_fsh082    0x58 > /sys/bus/i2c/devices/i2c-9/new_device',\n\n# PSU-2\n'echo as9716_32d_psu2 0x51 > /sys/bus/i2c/devices/i2c-10/new_device',\n'echo acbel_fsh082    0x59 > /sys/bus/i2c/devices/i2c-10/new_device',\n]\n\n#EERPOM\neeprom_mknod =[\n'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-0/new_device',\n]\n\nFORCE = 0\nlogging.basicConfig(filename= PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG)\nlogging.basicConfig(level=logging.INFO)\n\n\nif DEBUG == True:\n    print((sys.argv[0]))\n    print(('ARGV      :', sys.argv[1:]))\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n\n    if len(sys.argv)<2:\n        show_help()\n\n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:\n        print(options)\n        print(args)\n        print((len(sys.argv)))\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n           do_install()\n        elif arg == 'clean':\n           do_uninstall()\n        else:\n            show_help()\n\n\n    return 0\n\ndef show_help():\n    print(( __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]}))\n    sys.exit(0)\n\ndef dis_i2c_ir3570a(addr):\n    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef ir3570_check():\n    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n    try:\n        status, output = subprocess.getstatusoutput(cmd)\n        lines = output.split('\\n')\n        hn = re.findall(r'\\w+', lines[-1])\n        version = int(hn[1], 16)\n        if version == 0x24:  #only for ir3570a\n            ret = dis_i2c_ir3570a(4)\n        else:\n            ret = 0\n    except Exception as e:\n        print(( \"Error on ir3570_check() e:\" + str(e)))\n        return -1\n    return ret\n\n\ndef my_log(txt):\n    if DEBUG == True:\n        print((\"[ACCTON DBG]: \"+txt))\n    return\n\ndef log_os_system(cmd, show):\n    logging.info('Run :'+cmd)\n    status = 1\n    output = \"\"\n    status, output = subprocess.getstatusoutput(cmd)\n    my_log (cmd +\"with result:\" + str(status))\n    #my_log (\"cmd:\" + cmd)\n    #my_log (\"      output:\"+output)\n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print(('Failed :'+cmd))\n    return  status, output\n\ndef driver_inserted():\n    ret, lsmod = log_os_system(\"ls /sys/module/*accton*\", 0)\n    logging.info('mods:'+lsmod)\n    if ret :\n        return False\n    else :\n        return True\n\n\nkos = [\n'depmod -ae',\n'modprobe i2c_dev',\n'modprobe i2c_mux_pca954x force_deselect_on_exit=1',\n'modprobe accton_i2c_psu',\n'modprobe accton_as9716_32d_cpld',\n'modprobe accton_as9716_32d_fan',\n'modprobe accton_as9716_32d_leds',\n'modprobe accton_as9716_32d_psu',\n'modprobe optoe',\n'modprobe lm75']\n\ncpld_reset_stop='i2cset -y 0 0x65 0x3 0x0'\n\ndef driver_install():\n    \n    global FORCE\n    for i in range(0,len(kos)):\n        status, output = log_os_system(kos[i], 1)\n        if status:\n            if FORCE == 0:\n                return status\n    log_os_system(cpld_reset_stop, 1)\n    print(\"Done driver_install\")\n    return 0\n\ndef driver_uninstall():\n    global FORCE\n    for i in range(0,len(kos)):\n        rm = kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\")        \n        lst = rm.split(\" \")\n\n        if len(lst) > 3:\n            del(lst[3])\n        rm = \" \".join(lst)\n        status, output = log_os_system(rm, 1)\n        if status:\n            if FORCE == 0:\n                return status\n    return 0\n\ndef eeprom_check():\n    cmd = \"i2cget -y -f 0 0x57\"\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef device_install():\n    global FORCE\n    global use_57_eeprom\n\n    for i in range(0,len(mknod)):\n        #for pca954x need times to built new i2c buses\n        if mknod[i].find('pca954') != -1:\n            time.sleep(2)\n        #print(\"init i2c device instance\")\n        status, output = log_os_system(mknod[i], 1)        \n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n    \n    ret=eeprom_check()\n    if ret==0:\n        log_os_system(eeprom_mknod[0], 1) #new board, 0x57 eeprom\n    else:\n        log_os_system(eeprom_mknod[1], 1) #old board, 0x56 eeprom\n        \n    for i in range(0,len(sfp_map)):\n        status, output =log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n        status, output =log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    print(\"Done device_install\")\n\n    return\n\ndef device_uninstall():\n    global FORCE\n\n    status, output =log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0)\n    if status==0:\n        I2C_ORDER=1\n    else:\n    \tI2C_ORDER=0\n\n    for i in range(0,len(sfp_map)):\n        target = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\"\n        status, output =log_os_system(\"echo 0x50 > \"+ target, 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n                \n    nodelist = mknod\n\n    for i in range(len(nodelist)):\n        target = nodelist[-(i+1)]\n        temp = target.split()\n        del temp[1]\n        temp[-1] = temp[-1].replace('new_device', 'delete_device')\n        status, output = log_os_system(\" \".join(temp), 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    ret=eeprom_check()\n    if ret==0:\n        target = eeprom_mknod[0] #0x57\n    else:\n        target = eeprom_mknod[1] #0x56\n    \n    temp = target.split()\n    del temp[1]\n    temp[-1] = temp[-1].replace('new_device', 'delete_device')\n    status, output = log_os_system(\" \".join(temp), 1)\n   \n    return\n\ndef system_ready():\n    if driver_inserted() == False:        \n        return False\n    if not device_exist():\n        print(\"not device_exist()\")\n        return False\n    return True\n\ndef do_install():\n    if driver_inserted() == False:\n        status = driver_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print((PROJECT_NAME.upper()+\" drivers detected....\"))\n\n    ir3570_check()\n\n    if not device_exist():\n        status = device_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print((PROJECT_NAME.upper()+\" devices detected....\"))\n    return\n\ndef do_uninstall():\n    if not device_exist():\n        print((PROJECT_NAME.upper()+\" has no device installed....\"))\n    else:\n        print(\"Removing device....\")\n        status = device_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    if driver_inserted()== False :\n        print((PROJECT_NAME.upper()+\" has no driver installed....\"))\n    else:\n        print(\"Removing installed driver....\")\n        status = driver_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    return\n\ndef device_exist():\n    ret1, log = log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0)\n    ret2, log = log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-fan.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-init.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Disable as9716-32d-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as9716_32d_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n", "add": 7, "remove": 7, "filename": "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py", "badparts": ["import subprocess", "    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as9716-32d-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py clean\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as9716-32d-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"clean\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"install\"])\n     if status:\n         print(\"accton_as9716_32d_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Enable as9716-32d-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as9716-32d-platform-monitor-fan.service failed %d\"%status)\n         return False\n         \n-    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as9716-32d-platform-monitor-psu.service failed %d\"%status)\n         return False\n", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py install\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as9716-32d-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-psu.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"install\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as9716-32d-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-psu.service\"])"]}, {"diff": "\n \n def start_platform_pddf():   \n \n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])"]}, {"diff": "\n \n def stop_platform_pddf():   \n \n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}], "source": "\n import subprocess def check_pddf_support(): return True def stop_platform_svc(): status, output=subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-fan.service\") if status: print(\"Stop as9716-32d-platform-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-psu.service\") if status: print(\"Stop as9716-32d-platform-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor.service\") if status: print(\"Stop as9716-32d-platform-init.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl disable as9716-32d-platform-monitor.service\") if status: print(\"Disable as9716-32d-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py clean\") if status: print(\"accton_as9716_32d_util.py clean command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status) return False return True def start_platform_svc(): status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py install\") if status: print(\"accton_as9716_32d_util.py install command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl enable as9716-32d-platform-monitor.service\") if status: print(\"Enable as9716-32d-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-fan.service\") if status: print(\"Start as9716-32d-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-psu.service\") if status: print(\"Start as9716-32d-platform-monitor-psu.service failed %d\"%status) return False return True def start_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print(\"Start pddf-platform-init.service failed %d\"%status) return False return True def stop_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service failed %d\"%status) return False return True ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services. \n# This will be used while switching the pddf->non-pddf mode and vice versa\nimport subprocess\n\ndef check_pddf_support():\n    return True\n\ndef stop_platform_svc():\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-fan.service\")\n    if status:\n        print(\"Stop as9716-32d-platform-fan.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-psu.service\")\n    if status:\n        print(\"Stop as9716-32d-platform-psu.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor.service\")\n    if status:\n        print(\"Stop as9716-32d-platform-init.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as9716-32d-platform-monitor.service\")\n    if status:\n        print(\"Disable as9716-32d-platform-monitor.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py clean\")\n    if status:\n        print(\"accton_as9716_32d_util.py clean command failed %d\"%status)\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n        return False\n\n    return True\n    \ndef start_platform_svc():\n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py install\")\n    if status:\n        print(\"accton_as9716_32d_util.py install command failed %d\"%status)\n        return False\n\n    status, output = subprocess.getstatusoutput(\"systemctl enable as9716-32d-platform-monitor.service\")\n    if status:\n        print(\"Enable as9716-32d-platform-monitor.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-fan.service\")\n    if status:\n        print(\"Start as9716-32d-platform-monitor-fan.service failed %d\"%status)\n        return False\n        \n    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-psu.service\")\n    if status:\n        print(\"Start as9716-32d-platform-monitor-psu.service failed %d\"%status)\n        return False\n\n    return True\n\ndef start_platform_pddf():   \n\n    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print(\"Start pddf-platform-init.service failed %d\"%status)\n        return False\n    \n    return True\n\ndef stop_platform_pddf():   \n\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service failed %d\"%status)\n        return False\n\n    return True\n\n"}}, "msg": "[device/accton] Replace os.system and remove subprocess with shell=True (#11985)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\n#### Why I did it\r\n`subprocess.Popen()` and `subprocess.run()` is used with `shell=True`, which is very dangerous for shell injection.\r\n`os` - not secure against maliciously constructed input and dangerous if used to evaluate dynamic content\r\n#### How I did it\r\nReplace `os` by `subprocess`\r\nRemove unused functions"}, "2b3e884209d5028c1763b0f83cfc42b5249b4efb": {"url": "https://api.github.com/repos/sonic-net/sonic-buildimage/commits/2b3e884209d5028c1763b0f83cfc42b5249b4efb", "html_url": "https://github.com/sonic-net/sonic-buildimage/commit/2b3e884209d5028c1763b0f83cfc42b5249b4efb", "sha": "2b3e884209d5028c1763b0f83cfc42b5249b4efb", "keyword": "function injection malicious", "diff": "diff --git a/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py b/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py\nindex cbd48237cc10..12a1bbe5d2aa 100644\n--- a/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py\n+++ b/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py\n@@ -10,5 +10,7 @@ class board(eeprom_tlvinfo.TlvInfoDecoder):\n     def __init__(self, name, path, cpld_root, ro):\n         self.eeprom_path = \"/sys/class/i2c-adapter/i2c-0/0-0053/eeprom\"\n         if not os.path.exists(self.eeprom_path):\n-            os.system(\"echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device\")\n+            file = \"/sys/class/i2c-adapter/i2c-0/new_device\"\n+            with open(file, 'w') as f:\n+                f.write('24c02 0x53\\n')\n         super(board, self).__init__(self.eeprom_path, 0, '', True)\ndiff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py\nindex eb507a49ef17..008d5ba08b77 100755\n--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py\n+++ b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py\n@@ -18,6 +18,7 @@\n     from sonic_platform.thermal import Thermal\n     from sonic_platform.component import Component\n     from sonic_py_common import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -27,11 +28,6 @@\n except ImportError as e:\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n MAX_SELECT_DELAY = 3600\n COPPER_PORT_START = 1\n COPPER_PORT_END = 48\n@@ -209,7 +205,7 @@ def get_revision(self):\n             string: Revision value of chassis\n         \"\"\"\n         if smbus_present == 0:  # called from host\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x0')\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x0'])\n         else:\n             bus = smbus.SMBus(0)\n             DEVICE_ADDRESS = 0x41\n@@ -331,7 +327,7 @@ def set_status_led(self, color):\n \n         # Write sys led\n         if smbus_present == 0:  # called from host (e.g. 'show system-health')\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cset -y 0 0x41 0x7 %d' % value)\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '0', '0x41', '0x7', str(value)])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"  System LED set %s failed\" % value)\n                 return False\n@@ -353,7 +349,7 @@ def get_status_led(self):\n         \"\"\"\n         # Read sys led\n         if smbus_present == 0:  # called from host\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x7')\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x7'])\n             value = int(value, 16)\n         else:\n             bus = smbus.SMBus(0)\ndiff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py\nindex 134856ea4213..4e8863e64fde 100644\n--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py\n+++ b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py\n@@ -9,10 +9,10 @@\n \n try:\n     import os\n-    import sys\n     import subprocess\n     import ntpath\n     from sonic_platform_base.component_base import ComponentBase\n+    from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -22,11 +22,6 @@\n except ImportError as e:\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n \n class Component(ComponentBase):\n     \"\"\"Nokia platform-specific Component class\"\"\"\n@@ -35,29 +30,20 @@ class Component(ComponentBase):\n         [\"System-CPLD\", \"Used for managing SFPs, LEDs, PSUs and FANs \"],\n         [\"U-Boot\", \"Performs initialization during booting\"],\n     ]\n-    CPLD_UPDATE_COMMAND = 'cp /usr/sbin/vme /tmp; cp {} /tmp; cd /tmp; ./vme {};'\n+    CPLD_UPDATE_COMMAND1 = ['cp', '/usr/sbin/vme', '/tmp']\n+    CPLD_UPDATE_COMMAND2 = ['cp', '', '/tmp']\n+    CPLD_UPDATE_COMMAND3 = ['cd', '/tmp']\n+    CPLD_UPDATE_COMMAND4 = ['./vme', '']\n \n     def __init__(self, component_index):\n         self.index = component_index\n         self.name = self.CHASSIS_COMPONENTS[self.index][0]\n         self.description = self.CHASSIS_COMPONENTS[self.index][1]\n \n-    def _get_command_result(self, cmdline):\n-        try:\n-            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,\n-                                    stderr=subprocess.STDOUT)\n-            stdout = proc.communicate()[0]\n-            proc.wait()\n-            result = stdout.rstrip('\\n')\n-        except OSError:\n-            result = None\n-\n-        return result\n-\n     def _get_cpld_version(self, cpld_number):\n \n         if smbus_present == 0:\n-            cmdstatus, cpld_version = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x2')\n+            cmdstatus, cpld_version = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x2'])\n         else:\n             bus = smbus.SMBus(0)\n             DEVICE_ADDRESS = 0x41\n@@ -144,7 +130,10 @@ def get_firmware_version(self):\n             return self._get_cpld_version(self.index)\n \n         if self.index == 1:\n-            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -1 | cut -d\" \" -f2-4')\n+            cmd1 = ['grep', '--null-data', 'U-Boot', '/dev/mtd0ro']\n+            cmd2 = ['head', '-1']\n+            cmd3 = ['cut', '-d', ' ', '-f2-4']\n+            cmdstatus, uboot_version = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)\n             return uboot_version\n \n     def install_firmware(self, image_path):\n@@ -165,12 +154,16 @@ def install_firmware(self, image_path):\n             print(\"ERROR: the cpld image {} doesn't exist \".format(image_path))\n             return False\n \n-        cmdline = self.CPLD_UPDATE_COMMAND.format(image_path, image_name)\n+        self.CPLD_UPDATE_COMMAND2[1] = image_path\n+        self.CPLD_UPDATE_COMMAND4[1] = image_name\n \n         success_flag = False\n-\n-        try:\n-            subprocess.check_call(cmdline, stderr=subprocess.STDOUT, shell=True)\n+ \n+        try:   \n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND1, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND2, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND3, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND4, stderr=subprocess.STDOUT)\n             success_flag = True\n         except subprocess.CalledProcessError as e:\n             print(\"ERROR: Failed to upgrade CPLD: rc={}\".format(e.returncode))\ndiff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py\nindex 383eb2481f68..243b807edb74 100644\n--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py\n+++ b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py\n@@ -8,18 +8,13 @@\n \n try:\n     import os\n-    import sys\n     from sonic_platform_base.psu_base import PsuBase\n     from sonic_py_common import logger\n     from sonic_platform.eeprom import Eeprom\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n smbus_present = 1\n try:\n     import smbus\n@@ -86,7 +81,7 @@ def get_presence(self):\n         \"\"\"\n \n         if smbus_present == 0:  # if called from psuutil outside of pmon\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n@@ -150,7 +145,7 @@ def get_status(self):\n         \"\"\"\n \n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n             sonic_logger.log_warning(\"PMON psu-smbus - presence = 0 \")\n         else:\n@@ -179,7 +174,7 @@ def get_voltage(self):\n             e.g. 12.1\n         \"\"\"\n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n@@ -226,7 +221,7 @@ def get_powergood_status(self):\n         \"\"\"\n \n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus(0)\ndiff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py\nindex d95e7a522da8..9d8e7e739033 100644\n--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py\n+++ b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py\n@@ -3,8 +3,7 @@\n #\n #############################################################################\n \n-import os\n-import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.sfp_base import SfpBase\n@@ -12,14 +11,10 @@\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom\n     from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper\n     from sonic_py_common import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n smbus_present = 1\n \n try:\n@@ -118,7 +113,7 @@ class Sfp(SfpBase):\n     # Paths\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"armhf-nokia_ixs7215_52x-r0\"\n     HWSKU = \"Nokia-7215\"\n@@ -186,7 +181,7 @@ def __convert_string_to_num(self, value_str):\n             return 'N/A'\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n@@ -811,7 +806,7 @@ def tx_disable(self, tx_disable):\n             return False\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, register = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x5')\n+            cmdstatus, register = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x5'])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"sfp cmdstatus i2c get failed %s\" % register )\n                 return False\n@@ -824,13 +819,13 @@ def tx_disable(self, tx_disable):\n \n         pos = [1, 2, 4, 8]\n         mask = pos[self.index-SFP_PORT_START]\n-        if tx_disable == True:\n+        if tx_disable is True:\n             setbits = register | mask\n         else:\n             setbits = register & ~mask\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, output = cmd.getstatusoutput('sudo i2cset -y -m 0x0f 0 0x41 0x5 %d' % setbits)\n+            cmdstatus, output = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '-m', '0x0f', '0', '0x41', '0x5', str(setbits)])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"sfp cmdstatus i2c write failed %s\" % output )\n                 return False\n@@ -912,7 +907,7 @@ def get_presence(self):\n             return False\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')\n+            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])\n             sfpstatus = int(sfpstatus, 16)\n         else:\n             bus = smbus.SMBus(0)\ndiff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py\nindex fd494ca674f5..34fc2bc6ae5d 100644\n--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py\n+++ b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py\n@@ -1,9 +1,9 @@\n '''\n listen for the SFP change event and return to chassis.\n '''\n-import sys\n import time\n from sonic_py_common import logger\n+from sonic_py_common.general import getstatusoutput_noshell\n \n smbus_present = 1\n \n@@ -12,11 +12,6 @@\n except ImportError as e:\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n # system level event/error\n EVENT_ON_ALL_SFP = '-1'\n SYSTEM_NOT_READY = 'system_not_ready'\n@@ -51,7 +46,7 @@ def deinitialize(self):\n     def _get_transceiver_status(self):\n         if smbus_present == 0:\n             sonic_logger.log_info(\"  PMON - smbus ERROR - DEBUG sfp_event   \")\n-            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')\n+            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])\n             sfpstatus = int(sfpstatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n", "message": "", "files": {"/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py": {"changes": [{"diff": "\n     def __init__(self, name, path, cpld_root, ro):\n         self.eeprom_path = \"/sys/class/i2c-adapter/i2c-0/0-0053/eeprom\"\n         if not os.path.exists(self.eeprom_path):\n-            os.system(\"echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device\")\n+            file = \"/sys/class/i2c-adapter/i2c-0/new_device\"\n+            with open(file, 'w') as f:\n+                f.write('24c02 0x53\\n')\n         super(board, self).__init__(self.eeprom_path, 0, '', True)", "add": 3, "remove": 1, "filename": "/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py", "badparts": ["            os.system(\"echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device\")"], "goodparts": ["            file = \"/sys/class/i2c-adapter/i2c-0/new_device\"", "            with open(file, 'w') as f:", "                f.write('24c02 0x53\\n')"]}], "source": "\ntry: import os from sonic_eeprom import eeprom_tlvinfo except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class board(eeprom_tlvinfo.TlvInfoDecoder): def __init__(self, name, path, cpld_root, ro): self.eeprom_path=\"/sys/class/i2c-adapter/i2c-0/0-0053/eeprom\" if not os.path.exists(self.eeprom_path): os.system(\"echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device\") super(board, self).__init__(self.eeprom_path, 0, '', True) ", "sourceWithComments": "try:\n    import os\n    from sonic_eeprom import eeprom_tlvinfo\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass board(eeprom_tlvinfo.TlvInfoDecoder):\n\n    def __init__(self, name, path, cpld_root, ro):\n        self.eeprom_path = \"/sys/class/i2c-adapter/i2c-0/0-0053/eeprom\"\n        if not os.path.exists(self.eeprom_path):\n            os.system(\"echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device\")\n        super(board, self).__init__(self.eeprom_path, 0, '', True)\n"}, "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py": {"changes": [{"diff": "\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n MAX_SELECT_DELAY = 3600\n COPPER_PORT_START = 1\n COPPER_PORT_END = 48\n", "add": 0, "remove": 5, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py", "badparts": ["if sys.version_info[0] < 3:", "    import commands as cmd", "else:", "    import subprocess as cmd"], "goodparts": []}, {"diff": "\n             string: Revision value of chassis\n         \"\"\"\n         if smbus_present == 0:  # called from host\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x0')\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x0'])\n         else:\n             bus = smbus.SMBus(0)\n             DEVICE_ADDRESS = 0x41\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py", "badparts": ["            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x0')"], "goodparts": ["            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x0'])"]}, {"diff": "\n \n         # Write sys led\n         if smbus_present == 0:  # called from host (e.g. 'show system-health')\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cset -y 0 0x41 0x7 %d' % value)\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '0', '0x41', '0x7', str(value)])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"  System LED set %s failed\" % value)\n                 return False\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py", "badparts": ["            cmdstatus, value = cmd.getstatusoutput('sudo i2cset -y 0 0x41 0x7 %d' % value)"], "goodparts": ["            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '0', '0x41', '0x7', str(value)])"]}, {"diff": "\n         \"\"\"\n         # Read sys led\n         if smbus_present == 0:  # called from host\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x7')\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x7'])\n             value = int(value, 16)\n         else:\n             bus = smbus.SMBus(0", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py", "badparts": ["            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x7')"], "goodparts": ["            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x7'])"]}], "source": "\n try: import os import sys import glob from sonic_platform_base.chassis_base import ChassisBase from sonic_platform.sfp import Sfp from sonic_platform.eeprom import Eeprom from sonic_platform.fan import Fan from.fan_drawer import RealDrawer from sonic_platform.psu import Psu from sonic_platform.thermal import Thermal from sonic_platform.component import Component from sonic_py_common import logger except ImportError as e: raise ImportError(str(e) +\"-required module not found\") smbus_present=1 try: import smbus except ImportError as e: smbus_present=0 if sys.version_info[0] < 3: import commands as cmd else: import subprocess as cmd MAX_SELECT_DELAY=3600 COPPER_PORT_START=1 COPPER_PORT_END=48 SFP_PORT_START=49 SFP_PORT_END=52 PORT_END=52 MAX_7215_FAN_DRAWERS=2 MAX_7215_FANS_PER_DRAWER=1 MAX_7215_PSU=2 MAX_7215_THERMAL=6 MAX_7215_COMPONENT=2 SYSLOG_IDENTIFIER=\"chassis\" sonic_logger=logger.Logger(SYSLOG_IDENTIFIER) class Chassis(ChassisBase): \"\"\" Nokia platform-specific Chassis class Derived from Dell S6000 platform. customized for the 7215 platform. \"\"\" def __init__(self): ChassisBase.__init__(self) self.system_led_supported_color=['off', 'amber', 'green', 'amber_blink', 'green_blink'] self.COPPER_PORT_START=COPPER_PORT_START self.COPPER_PORT_END=COPPER_PORT_END self.SFP_PORT_START=SFP_PORT_START self.SFP_PORT_END=SFP_PORT_END self.PORT_END=PORT_END for index in range(self.COPPER_PORT_START, self.COPPER_PORT_END+1): sfp_node=Sfp(index, 'COPPER', 'N/A', 'N/A') self._sfp_list.append(sfp_node) eeprom_path=\"/sys/class/i2c-adapter/i2c-{0}/{0}-0050/eeprom\" mux_dev=sorted(glob.glob(\"/sys/class/i2c-adapter/i2c-0/i2c-[0-9]\")) y=0 for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1): mux_dev_num=mux_dev[y] port_i2c_map=mux_dev_num[-1] y=y +1 port_eeprom_path=eeprom_path.format(port_i2c_map) if not os.path.exists(port_eeprom_path): sonic_logger.log_info(\"path %s didnt exist\" % port_eeprom_path) sfp_node=Sfp(index, 'SFP', port_eeprom_path, port_i2c_map) self._sfp_list.append(sfp_node) self.sfp_event_initialized=False self._eeprom=Eeprom() drawer_num=MAX_7215_FAN_DRAWERS fan_num_per_drawer=MAX_7215_FANS_PER_DRAWER drawer_ctor=RealDrawer fan_index=0 for drawer_index in range(drawer_num): drawer=drawer_ctor(drawer_index) self._fan_drawer_list.append(drawer) for index in range(fan_num_per_drawer): fan=Fan(fan_index, drawer) fan_index +=1 drawer._fan_list.append(fan) self._fan_list.append(fan) for i in range(MAX_7215_PSU): psu=Psu(i) self._psu_list.append(psu) for i in range(MAX_7215_THERMAL): thermal=Thermal(i) self._thermal_list.append(thermal) for i in range(MAX_7215_COMPONENT): component=Component(i) self._component_list.append(component) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of physical SFP ports in a chassis starting from 1. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_name(self): \"\"\" Retrieves the name of the chassis Returns: string: The name of the chassis \"\"\" return self._eeprom.modelstr() def get_presence(self): \"\"\" Retrieves the presence of the chassis Returns: bool: True if chassis is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the chassis Returns: string: Model/part number of chassis \"\"\" return self._eeprom.part_number_str() def get_service_tag(self): \"\"\" Retrieves the Service Tag of the chassis Returns: string: Service Tag of chassis \"\"\" return self._eeprom.service_tag_str() def get_status(self): \"\"\" Retrieves the operational status of the chassis Returns: bool: A boolean value, True if chassis is operating properly False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.base_mac_addr() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.serial_number_str() def get_revision(self): \"\"\" Retrieves the hardware revision of the chassis Returns: string: Revision value of chassis \"\"\" if smbus_present==0: cmdstatus, value=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x0') else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0x0 value=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) return str(value) def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.system_eeprom_info() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" return(ChassisBase.REBOOT_CAUSE_NON_HARDWARE, None) def get_change_event(self, timeout=0): \"\"\" Returns a nested dictionary containing all devices which have experienced a change at chassis level Args: timeout: Timeout in milliseconds(optional). If timeout==0, this method will block until a change is detected. Returns: (bool, dict): -True if call successful, False if not; -A nested dictionary where key is a device type, value is a dictionary with key:value pairs in the format of {'device_id':'device_event'}, where device_id is the device ID for this device and device_event, status='1' represents device inserted, status='0' represents device removed. Ex.{'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}} indicates that fan 0 has been removed, fan 2 has been inserted and sfp 11 has been removed. \"\"\" if not self.sfp_event_initialized: from sonic_platform.sfp_event import sfp_event self.sfp_event=sfp_event() self.sfp_event.initialize() self.MAX_SELECT_EVENT_RETURNED=self.PORT_END self.sfp_event_initialized=True wait_for_ever=(timeout==0) port_dict={} if wait_for_ever: timeout=MAX_SELECT_DELAY while True: status=self.sfp_event.check_sfp_status(port_dict, timeout) if not port_dict=={}: break else: status=self.sfp_event.check_sfp_status(port_dict, timeout) if status: return True,{'sfp': port_dict} else: return True,{'sfp':{}} def get_thermal_manager(self): from.thermal_manager import ThermalManager return ThermalManager def initizalize_system_led(self): return True def set_status_led(self, color): \"\"\" Sets the state of the system LED Args: color: A string representing the color with which to set the system LED Returns: bool: True if system LED state is set successfully, False if not \"\"\" if color not in self.system_led_supported_color: return False if(color=='off'): value=0x00 elif(color=='amber'): value=0x01 elif(color=='green'): value=0x02 elif(color=='amber_blink'): value=0x03 elif(color=='green_blink'): value=0x04 else: return False if smbus_present==0: cmdstatus, value=cmd.getstatusoutput('sudo i2cset -y 0 0x41 0x7 %d' % value) if cmdstatus: sonic_logger.log_warning(\" System LED set %s failed\" % value) return False else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICEREG=0x7 bus.write_byte_data(DEVICE_ADDRESS, DEVICEREG, value) return True def get_status_led(self): \"\"\" Gets the state of the system LED Returns: A string, one of the valid LED color strings which could be vendor specified. \"\"\" if smbus_present==0: cmdstatus, value=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x7') value=int(value, 16) else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0x7 value=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) if value==0x00: color='off' elif value==0x01: color='amber' elif value==0x02: color='green' elif value==0x03: color='amber_blink' elif value==0x04: color='green_blink' else: return None return color def get_watchdog(self): \"\"\" Retrieves hardware watchdog device on this chassis Returns: An object derived from WatchdogBase representing the hardware watchdog device Note: We overload this method to ensure that watchdog is only initialized when it is referenced. Currently, only one daemon can open the watchdog. To initialize watchdog in the constructor causes multiple daemon try opening watchdog when loading and constructing a chassis object and fail. By doing so we can eliminate that risk. \"\"\" try: if self._watchdog is None: from sonic_platform.watchdog import WatchdogImplBase watchdog_device_path=\"/dev/watchdog0\" self._watchdog=WatchdogImplBase(watchdog_device_path) except Exception as e: sonic_logger.log_warning(\" Fail to load watchdog{}\".format(repr(e))) return self._watchdog def get_position_in_parent(self): \"\"\" \t\tRetrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned \t\tReturns: \t\t integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \t\t\"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the platform information\n#\n#############################################################################\n\ntry:\n    import os\n    import sys\n    import glob\n    from sonic_platform_base.chassis_base import ChassisBase\n    from sonic_platform.sfp import Sfp\n    from sonic_platform.eeprom import Eeprom\n    from sonic_platform.fan import Fan\n    from .fan_drawer import RealDrawer\n    from sonic_platform.psu import Psu\n    from sonic_platform.thermal import Thermal\n    from sonic_platform.component import Component\n    from sonic_py_common import logger\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nsmbus_present = 1\ntry:\n    import smbus\nexcept ImportError as e:\n    smbus_present = 0\n\nif sys.version_info[0] < 3:\n    import commands as cmd\nelse:\n    import subprocess as cmd\n\nMAX_SELECT_DELAY = 3600\nCOPPER_PORT_START = 1\nCOPPER_PORT_END = 48\nSFP_PORT_START = 49\nSFP_PORT_END = 52\nPORT_END = 52\n\n# Device counts\nMAX_7215_FAN_DRAWERS = 2\nMAX_7215_FANS_PER_DRAWER = 1\nMAX_7215_PSU = 2\nMAX_7215_THERMAL = 6\n\n# Temp - disable these to help with early debug\nMAX_7215_COMPONENT = 2\n\nSYSLOG_IDENTIFIER = \"chassis\"\nsonic_logger = logger.Logger(SYSLOG_IDENTIFIER)\n\n\nclass Chassis(ChassisBase):\n    \"\"\"\n    Nokia platform-specific Chassis class\n        Derived from Dell S6000 platform.\n        customized for the 7215 platform.\n    \"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self.system_led_supported_color = ['off', 'amber', 'green', 'amber_blink', 'green_blink']\n        # Port numbers for SFP List Initialization\n        self.COPPER_PORT_START = COPPER_PORT_START\n        self.COPPER_PORT_END = COPPER_PORT_END\n        self.SFP_PORT_START = SFP_PORT_START\n        self.SFP_PORT_END = SFP_PORT_END\n        self.PORT_END = PORT_END\n\n        # for non-sfp ports create dummy objects for copper / non-sfp ports\n        for index in range(self.COPPER_PORT_START, self.COPPER_PORT_END+1):\n            sfp_node = Sfp(index, 'COPPER', 'N/A', 'N/A')\n            self._sfp_list.append(sfp_node)\n\n        # Verify optoe2 driver SFP eeprom devices were enumerated and exist\n        # then create the sfp nodes\n        eeprom_path = \"/sys/class/i2c-adapter/i2c-{0}/{0}-0050/eeprom\"\n        mux_dev = sorted(glob.glob(\"/sys/class/i2c-adapter/i2c-0/i2c-[0-9]\"))\n        y = 0\n        for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1):\n            mux_dev_num = mux_dev[y]\n            port_i2c_map = mux_dev_num[-1]\n            y = y + 1\n            port_eeprom_path = eeprom_path.format(port_i2c_map)\n            if not os.path.exists(port_eeprom_path):\n                sonic_logger.log_info(\"path %s didnt exist\" % port_eeprom_path)\n            sfp_node = Sfp(index, 'SFP', port_eeprom_path, port_i2c_map)\n            self._sfp_list.append(sfp_node)\n        self.sfp_event_initialized = False\n\n        # Instantiate system eeprom object\n        self._eeprom = Eeprom()\n\n        # Construct lists fans, power supplies, thermals & components\n        drawer_num = MAX_7215_FAN_DRAWERS\n        fan_num_per_drawer = MAX_7215_FANS_PER_DRAWER\n        drawer_ctor = RealDrawer\n        fan_index = 0\n        for drawer_index in range(drawer_num):\n            drawer = drawer_ctor(drawer_index)\n            self._fan_drawer_list.append(drawer)\n            for index in range(fan_num_per_drawer):\n                fan = Fan(fan_index, drawer)\n                fan_index += 1\n                drawer._fan_list.append(fan)\n                self._fan_list.append(fan)\n\n        for i in range(MAX_7215_PSU):\n            psu = Psu(i)\n            self._psu_list.append(psu)\n\n        for i in range(MAX_7215_THERMAL):\n            thermal = Thermal(i)\n            self._thermal_list.append(thermal)\n\n        for i in range(MAX_7215_COMPONENT):\n            component = Component(i)\n            self._component_list.append(component)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of physical SFP ports in a\n            chassis starting from 1.\n\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the chassis\n        Returns:\n            string: The name of the chassis\n        \"\"\"\n        return self._eeprom.modelstr()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the chassis\n        Returns:\n            bool: True if chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the chassis\n        Returns:\n            string: Model/part number of chassis\n        \"\"\"\n        return self._eeprom.part_number_str()\n\n    def get_service_tag(self):\n        \"\"\"\n        Retrieves the Service Tag of the chassis\n        Returns:\n            string: Service Tag of chassis\n        \"\"\"\n        return self._eeprom.service_tag_str()\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the chassis\n        Returns:\n            bool: A boolean value, True if chassis is operating properly\n            False if not\n        \"\"\"\n        return True\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.base_mac_addr()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n\n        Returns:\n            A string containing the hardware serial number for this\n            chassis.\n        \"\"\"\n        return self._eeprom.serial_number_str()\n\n    def get_revision(self):\n        \"\"\"\n        Retrieves the hardware revision of the chassis\n\n        Returns:\n            string: Revision value of chassis\n        \"\"\"\n        if smbus_present == 0:  # called from host\n            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x0')\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0x0\n            value = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n        return str(value)\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the\n        chassis\n\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their\n            corresponding values.\n        \"\"\"\n        return self._eeprom.system_eeprom_info()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        # The ixs7215 CPLD does not have a hardware reboot cause register so\n        # the hardware portion of reboot cause can't be implemented\n\n        return (ChassisBase.REBOOT_CAUSE_NON_HARDWARE, None)\n\n    def get_change_event(self, timeout=0):\n        \"\"\"\n        Returns a nested dictionary containing all devices which have\n        experienced a change at chassis level\n\n        Args:\n            timeout: Timeout in milliseconds (optional). If timeout == 0,\n                this method will block until a change is detected.\n\n        Returns:\n            (bool, dict):\n                - True if call successful, False if not;\n                - A nested dictionary where key is a device type,\n                  value is a dictionary with key:value pairs in the format of\n                  {'device_id':'device_event'},\n                  where device_id is the device ID for this device and\n                        device_event,\n                             status='1' represents device inserted,\n                             status='0' represents device removed.\n                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}\n                      indicates that fan 0 has been removed, fan 2\n                      has been inserted and sfp 11 has been removed.\n        \"\"\"\n        # Initialize SFP event first\n        if not self.sfp_event_initialized:\n            from sonic_platform.sfp_event import sfp_event\n            self.sfp_event = sfp_event()\n            self.sfp_event.initialize()\n            self.MAX_SELECT_EVENT_RETURNED = self.PORT_END\n            self.sfp_event_initialized = True\n\n        wait_for_ever = (timeout == 0)\n        port_dict = {}\n        if wait_for_ever:\n            # xrcvd will call this monitor loop in the \"SYSTEM_READY\" state\n            timeout = MAX_SELECT_DELAY\n            while True:\n                status = self.sfp_event.check_sfp_status(port_dict, timeout)\n                if not port_dict == {}:\n                    break\n        else:\n            # At boot up and in \"INIT\" state call from xrcvd will have timeout\n            # value return true without change after timeout and will\n            # transition to \"SYSTEM_READY\"\n            status = self.sfp_event.check_sfp_status(port_dict, timeout)\n\n        if status:\n            return True, {'sfp': port_dict}\n        else:\n            return True, {'sfp': {}}\n\n    def get_thermal_manager(self):\n        from .thermal_manager import ThermalManager\n        return ThermalManager\n\n    def initizalize_system_led(self):\n        return True\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the system LED\n\n        Args:\n            color: A string representing the color with which to set the\n                   system LED\n\n        Returns:\n            bool: True if system LED state is set successfully, False if not\n        \"\"\"\n        if color not in self.system_led_supported_color:\n            return False\n\n        if (color == 'off'):\n            value = 0x00\n        elif (color == 'amber'):\n            value = 0x01\n        elif (color == 'green'):\n            value = 0x02\n        elif (color == 'amber_blink'):\n            value = 0x03\n        elif (color == 'green_blink'):\n            value = 0x04\n        else:\n            return False\n\n        # Write sys led\n        if smbus_present == 0:  # called from host (e.g. 'show system-health')\n            cmdstatus, value = cmd.getstatusoutput('sudo i2cset -y 0 0x41 0x7 %d' % value)\n            if cmdstatus:\n                sonic_logger.log_warning(\"  System LED set %s failed\" % value)\n                return False\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICEREG = 0x7\n            bus.write_byte_data(DEVICE_ADDRESS, DEVICEREG, value)\n\n        return True\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the system LED\n\n        Returns:\n            A string, one of the valid LED color strings which could be vendor\n            specified.\n        \"\"\"\n        # Read sys led\n        if smbus_present == 0:  # called from host\n            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x7')\n            value = int(value, 16)\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0x7\n            value = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n        if value == 0x00:\n            color = 'off'\n        elif value == 0x01:\n            color = 'amber'\n        elif value == 0x02:\n            color = 'green'\n        elif value == 0x03:\n            color = 'amber_blink'\n        elif value == 0x04:\n            color = 'green_blink'\n        else:\n            return None\n\n        return color\n\n    def get_watchdog(self):\n        \"\"\"\n        Retrieves hardware watchdog device on this chassis\n\n        Returns:\n            An object derived from WatchdogBase representing the hardware\n            watchdog device\n\n        Note:\n            We overload this method to ensure that watchdog is only initialized\n            when it is referenced. Currently, only one daemon can open the\n            watchdog. To initialize watchdog in the constructor causes multiple\n            daemon try opening watchdog when loading and constructing a chassis\n            object and fail. By doing so we can eliminate that risk.\n        \"\"\"\n        try:\n            if self._watchdog is None:\n                from sonic_platform.watchdog import WatchdogImplBase\n                watchdog_device_path = \"/dev/watchdog0\"\n                self._watchdog = WatchdogImplBase(watchdog_device_path)\n        except Exception as e:\n            sonic_logger.log_warning(\" Fail to load watchdog {}\".format(repr(e)))\n\n        return self._watchdog\n\n    def get_position_in_parent(self):\n        \"\"\"\n\t\tRetrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n\t\tReturns:\n\t\t    integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n\t\t\"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py": {"changes": [{"diff": "\n \n try:\n     import os\n-    import sys\n     import subprocess\n     import ntpath\n     from sonic_platform_base.component_base import ComponentBase\n+    from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py", "badparts": ["    import sys"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe"]}, {"diff": "\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n \n class Component(ComponentBase):\n     \"\"\"Nokia platform-specific Component class\"\"\"\n", "add": 0, "remove": 5, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py", "badparts": ["if sys.version_info[0] < 3:", "    import commands as cmd", "else:", "    import subprocess as cmd"], "goodparts": []}, {"diff": "\n         [\"System-CPLD\", \"Used for managing SFPs, LEDs, PSUs and FANs \"],\n         [\"U-Boot\", \"Performs initialization during booting\"],\n     ]\n-    CPLD_UPDATE_COMMAND = 'cp /usr/sbin/vme /tmp; cp {} /tmp; cd /tmp; ./vme {};'\n+    CPLD_UPDATE_COMMAND1 = ['cp', '/usr/sbin/vme', '/tmp']\n+    CPLD_UPDATE_COMMAND2 = ['cp', '', '/tmp']\n+    CPLD_UPDATE_COMMAND3 = ['cd', '/tmp']\n+    CPLD_UPDATE_COMMAND4 = ['./vme', '']\n \n     def __init__(self, component_index):\n         self.index = component_index\n         self.name = self.CHASSIS_COMPONENTS[self.index][0]\n         self.description = self.CHASSIS_COMPONENTS[self.index][1]\n \n-    def _get_command_result(self, cmdline):\n-        try:\n-            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,\n-                                    stderr=subprocess.STDOUT)\n-            stdout = proc.communicate()[0]\n-            proc.wait()\n-            result = stdout.rstrip('\\n')\n-        except OSError:\n-            result = None\n-\n-        return result\n-\n     def _get_cpld_version(self, cpld_number):\n \n         if smbus_present == 0:\n-            cmdstatus, cpld_version = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x2')\n+            cmdstatus, cpld_version = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x2'])\n         else:\n             bus = smbus.SMBus(0)\n             DEVICE_ADDRESS = 0x41\n", "add": 5, "remove": 14, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py", "badparts": ["    CPLD_UPDATE_COMMAND = 'cp /usr/sbin/vme /tmp; cp {} /tmp; cd /tmp; ./vme {};'", "    def _get_command_result(self, cmdline):", "        try:", "            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,", "                                    stderr=subprocess.STDOUT)", "            stdout = proc.communicate()[0]", "            proc.wait()", "            result = stdout.rstrip('\\n')", "        except OSError:", "            result = None", "        return result", "            cmdstatus, cpld_version = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x2')"], "goodparts": ["    CPLD_UPDATE_COMMAND1 = ['cp', '/usr/sbin/vme', '/tmp']", "    CPLD_UPDATE_COMMAND2 = ['cp', '', '/tmp']", "    CPLD_UPDATE_COMMAND3 = ['cd', '/tmp']", "    CPLD_UPDATE_COMMAND4 = ['./vme', '']", "            cmdstatus, cpld_version = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x2'])"]}, {"diff": "\n             return self._get_cpld_version(self.index)\n \n         if self.index == 1:\n-            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -1 | cut -d\" \" -f2-4')\n+            cmd1 = ['grep', '--null-data', 'U-Boot', '/dev/mtd0ro']\n+            cmd2 = ['head', '-1']\n+            cmd3 = ['cut', '-d', ' ', '-f2-4']\n+            cmdstatus, uboot_version = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)\n             return uboot_version\n \n     def install_firmware(self, image_path):\n", "add": 4, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py", "badparts": ["            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -1 | cut -d\" \" -f2-4')"], "goodparts": ["            cmd1 = ['grep', '--null-data', 'U-Boot', '/dev/mtd0ro']", "            cmd2 = ['head', '-1']", "            cmd3 = ['cut', '-d', ' ', '-f2-4']", "            cmdstatus, uboot_version = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)"]}, {"diff": "\n             print(\"ERROR: the cpld image {} doesn't exist \".format(image_path))\n             return False\n \n-        cmdline = self.CPLD_UPDATE_COMMAND.format(image_path, image_name)\n+        self.CPLD_UPDATE_COMMAND2[1] = image_path\n+        self.CPLD_UPDATE_COMMAND4[1] = image_name\n \n         success_flag = False\n-\n-        try:\n-            subprocess.check_call(cmdline, stderr=subprocess.STDOUT, shell=True)\n+ \n+        try:   \n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND1, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND2, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND3, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND4, stderr=subprocess.STDOUT)\n             success_flag = True\n         except subprocess.CalledProcessError as e:\n             print(\"ERROR: Failed to upgrade CPLD: rc={}\".format(e.returncode", "add": 8, "remove": 4, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py", "badparts": ["        cmdline = self.CPLD_UPDATE_COMMAND.format(image_path, image_name)", "        try:", "            subprocess.check_call(cmdline, stderr=subprocess.STDOUT, shell=True)"], "goodparts": ["        self.CPLD_UPDATE_COMMAND2[1] = image_path", "        self.CPLD_UPDATE_COMMAND4[1] = image_name", "        try:   ", "            subprocess.check_call(self.CPLD_UPDATE_COMMAND1, stderr=subprocess.STDOUT)", "            subprocess.check_call(self.CPLD_UPDATE_COMMAND2, stderr=subprocess.STDOUT)", "            subprocess.check_call(self.CPLD_UPDATE_COMMAND3, stderr=subprocess.STDOUT)", "            subprocess.check_call(self.CPLD_UPDATE_COMMAND4, stderr=subprocess.STDOUT)"]}], "source": "\n try: import os import sys import subprocess import ntpath from sonic_platform_base.component_base import ComponentBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") smbus_present=1 try: import smbus except ImportError as e: smbus_present=0 if sys.version_info[0] < 3: import commands as cmd else: import subprocess as cmd class Component(ComponentBase): \"\"\"Nokia platform-specific Component class\"\"\" CHASSIS_COMPONENTS=[ [\"System-CPLD\", \"Used for managing SFPs, LEDs, PSUs and FANs \"], [\"U-Boot\", \"Performs initialization during booting\"], ] CPLD_UPDATE_COMMAND='cp /usr/sbin/vme /tmp; cp{} /tmp; cd /tmp;./vme{};' def __init__(self, component_index): self.index=component_index self.name=self.CHASSIS_COMPONENTS[self.index][0] self.description=self.CHASSIS_COMPONENTS[self.index][1] def _get_command_result(self, cmdline): try: proc=subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE, stderr=subprocess.STDOUT) stdout=proc.communicate()[0] proc.wait() result=stdout.rstrip('\\n') except OSError: result=None return result def _get_cpld_version(self, cpld_number): if smbus_present==0: cmdstatus, cpld_version=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x2') else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0x2 cpld_version=str(bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)) return str(int(cpld_version, 16)) def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return self.name def get_model(self): \"\"\" Retrieves the part number of the component Returns: string: Part number of component \"\"\" return 'NA' def get_serial(self): \"\"\" Retrieves the serial number of the component Returns: string: Serial number of component \"\"\" return 'NA' def get_presence(self): \"\"\" Retrieves the presence of the component Returns: bool: True if present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the component Returns: bool: True if component is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether component is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return self.description def get_firmware_version(self): \"\"\" Retrieves the firmware version of the component Returns: A string containing the firmware version of the component \"\"\" if self.index==0: return self._get_cpld_version(self.index) if self.index==1: cmdstatus, uboot_version=cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -1 | cut -d\" \" -f2-4') return uboot_version def install_firmware(self, image_path): \"\"\" Installs firmware to the component Args: image_path: A string, path to firmware image Returns: A boolean, True if install was successful, False if not \"\"\" image_name=ntpath.basename(image_path) print(\" ixs7215 -install cpld{}\".format(image_name)) if not os.path.isfile(image_path): print(\"ERROR: the cpld image{} doesn't exist \".format(image_path)) return False cmdline=self.CPLD_UPDATE_COMMAND.format(image_path, image_name) success_flag=False try: subprocess.check_call(cmdline, stderr=subprocess.STDOUT, shell=True) success_flag=True except subprocess.CalledProcessError as e: print(\"ERROR: Failed to upgrade CPLD: rc={}\".format(e.returncode)) if success_flag: print(\"INFO: Refresh or power cycle is required to finish CPLD installation\") return success_flag ", "sourceWithComments": "########################################################################\n# NOKIA IXS7215\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Components' (e.g., BIOS, CPLD, FPGA, etc.) available in\n# the platform\n#\n########################################################################\n\ntry:\n    import os\n    import sys\n    import subprocess\n    import ntpath\n    from sonic_platform_base.component_base import ComponentBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nsmbus_present = 1\ntry:\n    import smbus\nexcept ImportError as e:\n    smbus_present = 0\n\nif sys.version_info[0] < 3:\n    import commands as cmd\nelse:\n    import subprocess as cmd\n\n\nclass Component(ComponentBase):\n    \"\"\"Nokia platform-specific Component class\"\"\"\n\n    CHASSIS_COMPONENTS = [\n        [\"System-CPLD\", \"Used for managing SFPs, LEDs, PSUs and FANs \"],\n        [\"U-Boot\", \"Performs initialization during booting\"],\n    ]\n    CPLD_UPDATE_COMMAND = 'cp /usr/sbin/vme /tmp; cp {} /tmp; cd /tmp; ./vme {};'\n\n    def __init__(self, component_index):\n        self.index = component_index\n        self.name = self.CHASSIS_COMPONENTS[self.index][0]\n        self.description = self.CHASSIS_COMPONENTS[self.index][1]\n\n    def _get_command_result(self, cmdline):\n        try:\n            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,\n                                    stderr=subprocess.STDOUT)\n            stdout = proc.communicate()[0]\n            proc.wait()\n            result = stdout.rstrip('\\n')\n        except OSError:\n            result = None\n\n        return result\n\n    def _get_cpld_version(self, cpld_number):\n\n        if smbus_present == 0:\n            cmdstatus, cpld_version = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x2')\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0x2\n            cpld_version = str(bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG))\n\n        return str(int(cpld_version, 16))\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n\n        Returns:\n            A string containing the name of the component\n        \"\"\"\n        return self.name\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the part number of the component\n        Returns:\n            string: Part number of component\n        \"\"\"\n        return 'NA'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the component\n        Returns:\n            string: Serial number of component\n        \"\"\"\n        return 'NA'\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the component\n        Returns:\n            bool: True if  present, False if not\n        \"\"\"\n        return True\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the component\n        Returns:\n            bool: True if component is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        Returns:\n            integer: The 1-based relative physical position in parent\n            device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether component is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n\n        Returns:\n            A string containing the description of the component\n        \"\"\"\n        return self.description\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of the component\n\n        Returns:\n            A string containing the firmware version of the component\n        \"\"\"\n        if self.index == 0:\n            return self._get_cpld_version(self.index)\n\n        if self.index == 1:\n            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -1 | cut -d\" \" -f2-4')\n            return uboot_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Installs firmware to the component\n\n        Args:\n            image_path: A string, path to firmware image\n\n        Returns:\n            A boolean, True if install was successful, False if not\n        \"\"\"\n        image_name = ntpath.basename(image_path)\n        print(\" ixs7215 - install cpld {}\".format(image_name))\n\n        # check whether the image file exists\n        if not os.path.isfile(image_path):\n            print(\"ERROR: the cpld image {} doesn't exist \".format(image_path))\n            return False\n\n        cmdline = self.CPLD_UPDATE_COMMAND.format(image_path, image_name)\n\n        success_flag = False\n\n        try:\n            subprocess.check_call(cmdline, stderr=subprocess.STDOUT, shell=True)\n            success_flag = True\n        except subprocess.CalledProcessError as e:\n            print(\"ERROR: Failed to upgrade CPLD: rc={}\".format(e.returncode))\n\n        if success_flag:\n            print(\"INFO: Refresh or power cycle is required to finish CPLD installation\")\n\n        return success_flag\n\n"}, "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py": {"changes": [{"diff": "\n \n try:\n     import os\n-    import sys\n     from sonic_platform_base.psu_base import PsuBase\n     from sonic_py_common import logger\n     from sonic_platform.eeprom import Eeprom\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n smbus_present = 1\n try:\n     import smbus\n", "add": 1, "remove": 6, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py", "badparts": ["    import sys", "if sys.version_info[0] < 3:", "    import commands as cmd", "else:", "    import subprocess as cmd"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         \"\"\"\n \n         if smbus_present == 0:  # if called from psuutil outside of pmon\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py", "badparts": ["            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')"], "goodparts": ["            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])"]}, {"diff": "\n         \"\"\"\n \n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n             sonic_logger.log_warning(\"PMON psu-smbus - presence = 0 \")\n         else:\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py", "badparts": ["            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')"], "goodparts": ["            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])"]}, {"diff": "\n             e.g. 12.1\n         \"\"\"\n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py", "badparts": ["            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')"], "goodparts": ["            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])"]}, {"diff": "\n         \"\"\"\n \n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py", "badparts": ["            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')"], "goodparts": ["            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])"]}], "source": "\n try: import os import sys from sonic_platform_base.psu_base import PsuBase from sonic_py_common import logger from sonic_platform.eeprom import Eeprom except ImportError as e: raise ImportError(str(e) +\"-required module not found\") if sys.version_info[0] < 3: import commands as cmd else: import subprocess as cmd smbus_present=1 try: import smbus except ImportError as e: smbus_present=0 sonic_logger=logger.Logger('psu') class Psu(PsuBase): \"\"\"Nokia platform-specific PSU class for 7215 \"\"\" def __init__(self, psu_index): PsuBase.__init__(self) self.index=psu_index +1 self._fan_list=[] self.eeprom=Eeprom(is_psu=True, psu_index=self.index) def _write_sysfs_file(self, sysfs_file, value): rv='ERR' if(not os.path.isfile(sysfs_file)): return rv try: with open(sysfs_file, 'w') as fd: rv=fd.write(str(value)) except Exception as e: rv='ERR' return rv def _read_sysfs_file(self, sysfs_file): rv='ERR' if(not os.path.isfile(sysfs_file)): return rv try: with open(sysfs_file, 'r') as fd: rv=fd.read() except Exception as e: rv='ERR' rv=rv.rstrip('\\r\\n') rv=rv.lstrip(\" \") return rv def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return \"PSU{}\".format(self.index) def get_presence(self): \"\"\" Retrieves the presence of the Power Supply Unit(PSU) Returns: bool: True if PSU is present, False if not \"\"\" if smbus_present==0: cmdstatus, psustatus=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa') psustatus=int(psustatus, 16) else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0xa psustatus=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) if self.index==1: psustatus=psustatus & 1 if psustatus==1: return False if self.index==2: psustatus=psustatus & 2 if psustatus==2: return False return True def get_model(self): \"\"\" Retrieves the part number of the PSU Returns: string: Part number of PSU \"\"\" return self.eeprom.modelstr() def get_serial(self): \"\"\" Retrieves the serial number of the PSU Returns: string: Serial number of PSU \"\"\" return self.eeprom.serial_number_str() def get_revision(self): \"\"\" Retrieves the HW revision of the PSU Returns: string: HW revision of PSU \"\"\" return self.eeprom.part_number_str() def get_part_number(self): \"\"\" Retrieves the part number of the PSU Returns: string: Part number of PSU \"\"\" return self.eeprom.part_number_str() def get_status(self): \"\"\" Retrieves the operational status of the PSU Returns: bool: True if PSU is operating properly, False if not \"\"\" if smbus_present==0: cmdstatus, psustatus=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa') psustatus=int(psustatus, 16) sonic_logger.log_warning(\"PMON psu-smbus -presence=0 \") else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0xa psustatus=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) if self.index==1: psustatus=psustatus & 4 if psustatus==4: return True if self.index==2: psustatus=psustatus & 8 if psustatus==8: return True return False def get_voltage(self): \"\"\" Retrieves current PSU voltage output Returns: A float number, the output voltage in volts, e.g. 12.1 \"\"\" if smbus_present==0: cmdstatus, psustatus=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa') psustatus=int(psustatus, 16) else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0xa psustatus=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) if self.index==1: psustatus=psustatus & 4 if psustatus==4: psu_voltage=12.0 return psu_voltage if self.index==2: psustatus=psustatus & 8 if psustatus==8: psu_voltage=12.0 return psu_voltage psu_voltage=0.0 return psu_voltage def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device Returns: integer: The 1-based relative physical position in parent device \"\"\" return self.index def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return True def get_powergood_status(self): \"\"\" Retrieves the powergood status of PSU Returns: A boolean, True if PSU has stablized its output voltages and passed all its internal self-tests, False if not. \"\"\" if smbus_present==0: cmdstatus, psustatus=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa') psustatus=int(psustatus, 16) else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0xa psustatus=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) if self.index==1: psustatus=psustatus & 4 if psustatus==4: return True if self.index==2: psustatus=psustatus & 8 if psustatus==8: return True return False def get_status_led(self): \"\"\" Gets the state of the PSU status LED Returns: A string, one of the predefined STATUS_LED_COLOR_* strings. \"\"\" if self.get_powergood_status(): return self.STATUS_LED_COLOR_GREEN else: return self.STATUS_LED_COLOR_OFF def set_status_led(self, color): \"\"\" Sets the state of the PSU status LED Args: color: A string representing the color with which to set the PSU status LED Returns: bool: True if status LED state is set successfully, False if not \"\"\" return False def get_status_master_led(self): \"\"\" Gets the state of the front panel PSU status LED Returns: A string, one of the predefined STATUS_LED_COLOR_* strings. \"\"\" if(not os.path.isfile(\"/sys/class/gpio/psuLedGreen/value\") or not os.path.isfile(\"/sys/class/gpio/psuLedAmber/value\")): return None green=self._read_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\") amber=self._read_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\") if green==\"ERR\" or amber==\"ERR\": return None if green==\"1\": return self.STATUS_LED_COLOR_GREEN elif amber==\"1\": return self.STATUS_LED_COLOR_AMBER else: return None def set_status_master_led(self, color): \"\"\" Sets the state of the front panel PSU status LED Returns: bool: True if status LED state is set successfully, False if not \"\"\" if(not os.path.isfile(\"/sys/class/gpio/psuLedGreen/value\") or not os.path.isfile(\"/sys/class/gpio/psuLedAmber/value\")): return False if color==self.STATUS_LED_COLOR_GREEN: rvg=self._write_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\", 1) if rvg !=\"ERR\": rva=self._write_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\", 0) elif color==self.STATUS_LED_COLOR_AMBER: rvg=self._write_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\", 0) if rvg !=\"ERR\": rva=self._write_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\", 1) else: return False if rvg==\"ERR\" or rva==\"ERR\": return False return True ", "sourceWithComments": "########################################################################\n# Nokia IXS7215\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the PSUs' information which are available in the platform\n#\n########################################################################\n\ntry:\n    import os\n    import sys\n    from sonic_platform_base.psu_base import PsuBase\n    from sonic_py_common import logger\n    from sonic_platform.eeprom import Eeprom\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nif sys.version_info[0] < 3:\n    import commands as cmd\nelse:\n    import subprocess as cmd\n\nsmbus_present = 1\ntry:\n    import smbus\nexcept ImportError as e:\n    smbus_present = 0\n\nsonic_logger = logger.Logger('psu')\n\nclass Psu(PsuBase):\n    \"\"\"Nokia platform-specific PSU class for 7215 \"\"\"\n\n    def __init__(self, psu_index):\n        PsuBase.__init__(self)\n        # PSU is 1-based in Nokia platforms\n        self.index = psu_index + 1\n        self._fan_list = []\n\n        # PSU eeprom\n        self.eeprom = Eeprom(is_psu=True, psu_index=self.index)\n\n    def _write_sysfs_file(self, sysfs_file, value):\n        rv = 'ERR'\n\n        if (not os.path.isfile(sysfs_file)):\n            return rv\n        try:\n            with open(sysfs_file, 'w') as fd:\n                rv = fd.write(str(value))\n        except Exception as e:\n            rv = 'ERR'\n\n        return rv\n\n    def _read_sysfs_file(self, sysfs_file):\n        rv = 'ERR'\n\n        if (not os.path.isfile(sysfs_file)):\n            return rv\n        try:\n            with open(sysfs_file, 'r') as fd:\n                rv = fd.read()\n        except Exception as e:\n            rv = 'ERR'\n\n        rv = rv.rstrip('\\r\\n')\n        rv = rv.lstrip(\" \")\n        return rv\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n\n        Returns:\n            string: The name of the device\n        \"\"\"\n        return \"PSU{}\".format(self.index)\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Power Supply Unit (PSU)\n\n        Returns:\n            bool: True if PSU is present, False if not\n        \"\"\"\n\n        if smbus_present == 0:  # if called from psuutil outside of pmon\n            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n            psustatus = int(psustatus, 16)\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0xa\n            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n        if self.index == 1:\n            psustatus = psustatus & 1\n            if psustatus == 1:\n                return False\n        if self.index == 2:\n            psustatus = psustatus & 2\n            if psustatus == 2:\n                return False\n\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the part number of the PSU\n\n        Returns:\n            string: Part number of PSU\n        \"\"\"\n        return self.eeprom.modelstr()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the PSU\n\n        Returns:\n            string: Serial number of PSU\n        \"\"\"\n        return self.eeprom.serial_number_str()\n\n    def get_revision(self):\n        \"\"\"\n        Retrieves the HW revision of the PSU\n\n        Returns:\n            string: HW revision of PSU\n        \"\"\"\n        return self.eeprom.part_number_str()\n\n    def get_part_number(self):\n        \"\"\"\n        Retrieves the part number of the PSU\n\n        Returns:\n            string: Part number of PSU\n        \"\"\"\n        return self.eeprom.part_number_str()\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the PSU\n\n        Returns:\n            bool: True if PSU is operating properly, False if not\n        \"\"\"\n\n        if smbus_present == 0:\n            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n            psustatus = int(psustatus, 16)\n            sonic_logger.log_warning(\"PMON psu-smbus - presence = 0 \")\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0xa\n            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n        if self.index == 1:\n            psustatus = psustatus & 4\n            if psustatus == 4:\n                return True\n        if self.index == 2:\n            psustatus = psustatus & 8\n            if psustatus == 8:\n                return True\n\n        return False\n\n    def get_voltage(self):\n        \"\"\"\n        Retrieves current PSU voltage output\n\n        Returns:\n            A float number, the output voltage in volts,\n            e.g. 12.1\n        \"\"\"\n        if smbus_present == 0:\n            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n            psustatus = int(psustatus, 16)\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0xa\n            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n        if self.index == 1:\n            psustatus = psustatus & 4\n            if psustatus == 4:\n                psu_voltage = 12.0\n                return psu_voltage\n        if self.index == 2:\n            psustatus = psustatus & 8\n            if psustatus == 8:\n                psu_voltage = 12.0\n                return psu_voltage\n\n        psu_voltage = 0.0\n        return psu_voltage\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device\n        Returns:\n            integer: The 1-based relative physical position in parent device\n        \"\"\"\n        return self.index\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return True\n\n    def get_powergood_status(self):\n        \"\"\"\n        Retrieves the powergood status of PSU\n        Returns:\n            A boolean, True if PSU has stablized its output voltages and\n            passed all its internal self-tests, False if not.\n        \"\"\"\n\n        if smbus_present == 0:\n            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n            psustatus = int(psustatus, 16)\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0xa\n            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n        if self.index == 1:\n            psustatus = psustatus & 4\n            if psustatus == 4:\n                return True\n        if self.index == 2:\n            psustatus = psustatus & 8\n            if psustatus == 8:\n                return True\n\n        return False\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the PSU status LED\n\n        Returns:\n            A string, one of the predefined STATUS_LED_COLOR_* strings.\n        \"\"\"\n        if self.get_powergood_status():\n            return self.STATUS_LED_COLOR_GREEN\n        else:\n            return self.STATUS_LED_COLOR_OFF\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the PSU status LED\n        Args:\n            color: A string representing the color with which to set the\n                   PSU status LED\n        Returns:\n            bool: True if status LED state is set successfully, False if\n                  not\n        \"\"\"\n        # The firmware running in the PSU controls the LED\n        # and the PSU LED state cannot be changed from CPU.\n        return False\n\n    def get_status_master_led(self):\n        \"\"\"\n        Gets the state of the front panel PSU status LED\n\n        Returns:\n            A string, one of the predefined STATUS_LED_COLOR_* strings.\n        \"\"\"\n        if (not os.path.isfile(\"/sys/class/gpio/psuLedGreen/value\") or\n            not os.path.isfile(\"/sys/class/gpio/psuLedAmber/value\")):\n            return None\n\n        green = self._read_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\")\n        amber = self._read_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\")\n        if green == \"ERR\" or amber == \"ERR\":\n            return None\n        if green == \"1\":\n            return self.STATUS_LED_COLOR_GREEN\n        elif amber == \"1\":\n            return self.STATUS_LED_COLOR_AMBER\n        else:\n            return None\n\n    def set_status_master_led(self, color):\n        \"\"\"\n        Sets the state of the front panel PSU status LED\n\n        Returns:\n            bool: True if status LED state is set successfully, False if\n                  not\n        \"\"\"\n        if (not os.path.isfile(\"/sys/class/gpio/psuLedGreen/value\") or\n            not os.path.isfile(\"/sys/class/gpio/psuLedAmber/value\")):\n            return False\n\n        if color == self.STATUS_LED_COLOR_GREEN:\n            rvg = self._write_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\", 1)\n            if rvg != \"ERR\":\n                rva = self._write_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\", 0)\n        elif color == self.STATUS_LED_COLOR_AMBER:\n            rvg = self._write_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\", 0)\n            if rvg != \"ERR\":\n                rva = self._write_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\", 1)\n        else:\n            return False\n\n        if rvg == \"ERR\" or rva == \"ERR\":\n            return False\n\n        return True\n"}, "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import os\n-import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.sfp_base import SfpBase\n", "add": 1, "remove": 2, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["import sys"], "goodparts": ["import subprocess"]}, {"diff": "\n     from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper\n     from sonic_py_common import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n smbus_present = 1\n \n try:\n", "add": 1, "remove": 5, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["if sys.version_info[0] < 3:", "    import commands as cmd", "else:", "    import subprocess as cmd"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n     # Paths\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"armhf-nokia_ixs7215_52x-r0\"\n     HWSKU = \"Nokia-7215\"\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n             return 'N/A'\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}, {"diff": "\n             return False\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, register = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x5')\n+            cmdstatus, register = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x5'])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"sfp cmdstatus i2c get failed %s\" % register )\n                 return False\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["            cmdstatus, register = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x5')"], "goodparts": ["            cmdstatus, register = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x5'])"]}, {"diff": "\n \n         pos = [1, 2, 4, 8]\n         mask = pos[self.index-SFP_PORT_START]\n-        if tx_disable == True:\n+        if tx_disable is True:\n             setbits = register | mask\n         else:\n             setbits = register & ~mask\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, output = cmd.getstatusoutput('sudo i2cset -y -m 0x0f 0 0x41 0x5 %d' % setbits)\n+            cmdstatus, output = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '-m', '0x0f', '0', '0x41', '0x5', str(setbits)])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"sfp cmdstatus i2c write failed %s\" % output )\n                 return False\n", "add": 2, "remove": 2, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["        if tx_disable == True:", "            cmdstatus, output = cmd.getstatusoutput('sudo i2cset -y -m 0x0f 0 0x41 0x5 %d' % setbits)"], "goodparts": ["        if tx_disable is True:", "            cmdstatus, output = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '-m', '0x0f', '0', '0x41', '0x5', str(setbits)])"]}, {"diff": "\n             return False\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')\n+            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])\n             sfpstatus = int(sfpstatus, 16)\n         else:\n             bus = smbus.SMBu", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')"], "goodparts": ["            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])"]}]}, "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py": {"changes": [{"diff": "\n '''\n listen for the SFP change event and return to chassis.\n '''\n-import sys\n import time\n from sonic_py_common import logger\n+from sonic_py_common.general import getstatusoutput_noshell\n \n smbus_present = 1\n \n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py", "badparts": ["import sys"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n # system level event/error\n EVENT_ON_ALL_SFP = '-1'\n SYSTEM_NOT_READY = 'system_not_ready'\n", "add": 0, "remove": 5, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py", "badparts": ["if sys.version_info[0] < 3:", "    import commands as cmd", "else:", "    import subprocess as cmd"], "goodparts": []}, {"diff": "\n     def _get_transceiver_status(self):\n         if smbus_present == 0:\n             sonic_logger.log_info(\"  PMON - smbus ERROR - DEBUG sfp_event   \")\n-            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')\n+            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])\n             sfpstatus = int(sfpstatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py", "badparts": ["            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')"], "goodparts": ["            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])"]}], "source": "\n''' listen for the SFP change event and return to chassis. ''' import sys import time from sonic_py_common import logger smbus_present=1 try: import smbus except ImportError as e: smbus_present=0 if sys.version_info[0] < 3: import commands as cmd else: import subprocess as cmd EVENT_ON_ALL_SFP='-1' SYSTEM_NOT_READY='system_not_ready' SYSTEM_READY='system_become_ready' SYSTEM_FAIL='system_fail' SFP_PORT_START=49 SFP_PORT_END=52 SYSLOG_IDENTIFIER=\"sfp_event\" sonic_logger=logger.Logger(SYSLOG_IDENTIFIER) class sfp_event: ''' Listen to plugin/plugout cable events ''' def __init__(self): self.handle=None def initialize(self): self.modprs_register=0 time.sleep(5) self.modprs_register=self._get_transceiver_status() sonic_logger.log_info(\"Initial SFP presence=%d\" % self.modprs_register) def deinitialize(self): if self.handle is None: return def _get_transceiver_status(self): if smbus_present==0: sonic_logger.log_info(\" PMON -smbus ERROR -DEBUG sfp_event \") cmdstatus, sfpstatus=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3') sfpstatus=int(sfpstatus, 16) else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0x3 sfpstatus=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) sfpstatus=~sfpstatus sfpstatus=sfpstatus & 0xF return sfpstatus def check_sfp_status(self, port_change, timeout): \"\"\" check_sfp_status called from get_change_event, this will return correct status of all 4 SFP ports if there is a change in any of them \"\"\" start_time=time.time() port=SFP_PORT_START forever=False if timeout==0: forever=True elif timeout > 0: timeout=timeout / float(1000) else: return False,{} end_time=start_time +timeout if(start_time > end_time): return False,{} while(timeout >=0): reg_value=self._get_transceiver_status() if(reg_value !=self.modprs_register): changed_ports=(self.modprs_register ^ reg_value) while(port >=SFP_PORT_START and port <=SFP_PORT_END): mask=(1 << port-SFP_PORT_START) if(changed_ports & mask): if reg_value & mask==0: port_change[port]='0' else: port_change[port]='1' port +=1 self.modprs_register=reg_value return True, port_change if forever: time.sleep(1) else: timeout=end_time -time.time() if timeout >=1: time.sleep(1) else: if timeout > 0: time.sleep(timeout) return True,{} return False,{} ", "sourceWithComments": "'''\nlisten for the SFP change event and return to chassis.\n'''\nimport sys\nimport time\nfrom sonic_py_common import logger\n\nsmbus_present = 1\n\ntry:\n    import smbus\nexcept ImportError as e:\n    smbus_present = 0\n\nif sys.version_info[0] < 3:\n    import commands as cmd\nelse:\n    import subprocess as cmd\n\n# system level event/error\nEVENT_ON_ALL_SFP = '-1'\nSYSTEM_NOT_READY = 'system_not_ready'\nSYSTEM_READY = 'system_become_ready'\nSYSTEM_FAIL = 'system_fail'\n\n# SFP PORT numbers\nSFP_PORT_START = 49\nSFP_PORT_END = 52\n\nSYSLOG_IDENTIFIER = \"sfp_event\"\nsonic_logger = logger.Logger(SYSLOG_IDENTIFIER)\n\n\nclass sfp_event:\n    ''' Listen to plugin/plugout cable events '''\n\n    def __init__(self):\n        self.handle = None\n\n    def initialize(self):\n        self.modprs_register = 0\n        # Get Transceiver status\n        time.sleep(5)\n        self.modprs_register = self._get_transceiver_status()\n        sonic_logger.log_info(\"Initial SFP presence=%d\" % self.modprs_register)\n\n    def deinitialize(self):\n        if self.handle is None:\n            return\n\n    def _get_transceiver_status(self):\n        if smbus_present == 0:\n            sonic_logger.log_info(\"  PMON - smbus ERROR - DEBUG sfp_event   \")\n            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')\n            sfpstatus = int(sfpstatus, 16)\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0x3\n            sfpstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n            sfpstatus = ~sfpstatus\n            sfpstatus = sfpstatus & 0xF\n\n        return sfpstatus\n\n    def check_sfp_status(self, port_change, timeout):\n        \"\"\"\n        check_sfp_status called from get_change_event, this will return correct\n            status of all 4 SFP ports if there is a change in any of them\n        \"\"\"\n        start_time = time.time()\n        port = SFP_PORT_START\n        forever = False\n\n        if timeout == 0:\n            forever = True\n        elif timeout > 0:\n            timeout = timeout / float(1000)  # Convert to secs\n        else:\n            return False, {}\n        end_time = start_time + timeout\n\n        if (start_time > end_time):\n            return False, {}  # Time wrap or possibly incorrect timeout\n\n        while (timeout >= 0):\n            # Check for OIR events and return updated port_change\n            reg_value = self._get_transceiver_status()\n            if (reg_value != self.modprs_register):\n                changed_ports = (self.modprs_register ^ reg_value)\n                while (port >= SFP_PORT_START and port <= SFP_PORT_END):\n                    # Mask off the bit corresponding to our port\n                    mask = (1 << port-SFP_PORT_START)\n                    if (changed_ports & mask):\n                        # ModPrsL is active high\n                        if reg_value & mask == 0:\n                            port_change[port] = '0'\n                        else:\n                            port_change[port] = '1'\n                    port += 1\n\n                # Update reg value\n                self.modprs_register = reg_value\n                return True, port_change\n\n            if forever:\n                time.sleep(1)\n            else:\n                timeout = end_time - time.time()\n                if timeout >= 1:\n                    time.sleep(1)  # We poll at 1 second granularity\n                else:\n                    if timeout > 0:\n                        time.sleep(timeout)\n                    return True, {}\n        return False, {}\n"}}, "msg": "[nokia] Replace os.system and remove subprocess with shell=True (#12100)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\nDependency: [https://github.com/sonic-net/sonic-buildimage/pull/12065](https://github.com/sonic-net/sonic-buildimage/pull/12065)\r\n#### Why I did it\r\n`subprocess.Popen()` and `subprocess.run()` is used with `shell=True`, which is very dangerous for shell injection.\r\n`os` - not secure against maliciously constructed input and dangerous if used to evaluate dynamic content\r\n`getstatusoutput` is dangerous because it contains `shell=True` in the implementation\r\n#### How I did it\r\nReplace `os` by `subprocess`, use with `shell=False`\r\nRemove unused functions"}}, "https://github.com/mohsin75/sonic-buildimage": {"5b0c4ec1e64f0bc604a3fd3e828b46d8974544d8": {"url": "https://api.github.com/repos/mohsin75/sonic-buildimage/commits/5b0c4ec1e64f0bc604a3fd3e828b46d8974544d8", "html_url": "https://github.com/mohsin75/sonic-buildimage/commit/5b0c4ec1e64f0bc604a3fd3e828b46d8974544d8", "sha": "5b0c4ec1e64f0bc604a3fd3e828b46d8974544d8", "keyword": "function injection malicious", "diff": "diff --git a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py\nindex 310d0433d8..c1192b3a2e 100644\n--- a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py\n@@ -6,8 +6,8 @@\n #\n #############################################################################\n \n-import os\n import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -27,7 +27,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n@@ -97,7 +97,7 @@ def __initialize_watchdog(self):\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py\nindex 53a01c1f14..c942a2fed9 100644\n--- a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py\n@@ -6,9 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -38,22 +35,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py\nindex b124ca29f0..b19fab85de 100644\n--- a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py\nindex c421761025..4205b17efa 100644\n--- a/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py\n@@ -6,10 +6,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -30,7 +29,7 @@ class Sfp(SfpOptoeBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as4630_54pe-r0\"\n     HWSKU = \"Accton-AS4630-54PE\"\n@@ -60,7 +59,7 @@ def get_eeprom_path(self):\n         return self.port_to_eeprom_mapping[self.port_num]\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py\nindex 7a54eee6f4..9f39c903c6 100644\n--- a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py\n@@ -6,7 +6,7 @@\n #\n #############################################################################\n \n-import os\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -26,7 +26,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n SYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n@@ -95,7 +95,7 @@ def __initialize_watchdog(self):\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py\nindex c34da70443..8137d0f3a7 100644\n--- a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py\n@@ -6,9 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -38,22 +35,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()        \n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py\nindex b124ca29f0..b19fab85de 100644\n--- a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py\nindex 4529c2f0ac..adab3d294c 100644\n--- a/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py\n@@ -8,10 +8,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -127,7 +126,7 @@ class Sfp(SfpBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-accton_as4630_54te-r0\"\n     HWSKU = \"Accton-AS4630-54TE\"\n@@ -193,7 +192,7 @@ def __write_txt_file(self, file_path, value):\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py\nindex dce9f3c150..c4a062f49a 100644\n--- a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py\n@@ -6,8 +6,8 @@\n #\n #############################################################################\n \n-import os\n import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -28,7 +28,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE= \"/sys/class/leds/as5835_54x_led::diag/brightness\"\n \n SYSLED_MODES = {\n@@ -98,7 +98,7 @@ def __initialize_watchdog(self):\n     \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py\nindex f3c9b3cee7..ef47a154e9 100644\n--- a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py\n@@ -6,10 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n-\n try:\n     from sonic_platform_base.component_base import ComponentBase\n     from .helper import APIHelper\n@@ -44,23 +40,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()\n \n-\n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py\nindex b124ca29f0..b19fab85de 100644\n--- a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py\nindex ec16e80568..39813a8772 100644\n--- a/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py\n@@ -6,10 +6,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -31,7 +30,7 @@ class Sfp(SfpOptoeBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as5835_54x-r0\"\n     HWSKU = \"Accton-AS5835-54X\"\n@@ -121,7 +120,7 @@ def __get_cpld_num(self, port_num):\n \n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess(self.HOST_CHK_CMD).returncode == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py\nindex 86ae121c6c..178f3c5626 100644\n--- a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py\n@@ -5,12 +5,7 @@\n #\n #############################################################################\n try:\n-    import sys\n-    import re\n-    import os\n     import subprocess\n-    import json\n-    import syslog\n     from sonic_platform_base.chassis_base import ChassisBase\n     from sonic_py_common.logger import Logger\n     from sonic_platform.fan import Fan\n@@ -36,7 +31,7 @@\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n COMPONENT_NAME_LIST = [\"BIOS\"]\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n@@ -71,7 +66,7 @@ def __init__(self):\n         logger.log_info(\"Chassis loaded successfully\")\n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py\nindex 15d8e9e15e..5e1e800d52 100644\n--- a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py\n@@ -3,10 +3,7 @@\n # provides the components firmware management function\n #############################################################################\n \n-import json\n import os.path\n-import shutil\n-import shlex\n import subprocess\n \n try:\n@@ -29,8 +26,7 @@ def __init__(self, component_name):\n     def __run_command(self, command):\n         # Run bash command and print output to stdout\n         try:\n-            process = subprocess.Popen(\n-                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n+            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n             while True:\n                 output = process.stdout.readline()\n                 if output == '' and process.poll() is not None:\ndiff --git a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py\nindex 6aabc14411..39c21c0d11 100644\n--- a/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py\n@@ -3,10 +3,8 @@\n # provides the sfp device status which are available in the platform\n #############################################################################\n try:\n-    import os\n     import time\n     import subprocess\n-    import syslog\n     from ctypes import create_string_buffer\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom\n@@ -173,7 +171,7 @@ class Sfp(SfpBase):\n \n     PLATFORM_ROOT_PATH = '/usr/share/sonic/device'\n     PMON_HWSKU_PATH = '/usr/share/sonic/hwsku'\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-accton_as7116_54x-r0\"\n     HWSKU = \"Accton-AS7116-54X-R0\"\n@@ -233,7 +231,7 @@ def __read_txt_file(self, file_path):\n         return \"\"\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py\nindex ceece0f9db..a1143b1125 100644\n--- a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py\n@@ -6,7 +6,7 @@\n #\n #############################################################################\n \n-import os\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -24,7 +24,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n@@ -87,7 +87,7 @@ def __initialize_watchdog(self):\n     \n     \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py\nindex 5300e1e732..2ba405f9f8 100644\n--- a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py\n@@ -6,8 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -43,22 +41,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py\nindex 4cd60ac906..2c644ecbfb 100644\n--- a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py\nindex 445b39edc7..fd6d0f8524 100644\n--- a/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py\n@@ -6,10 +6,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -125,7 +124,7 @@ class Sfp(SfpBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n         \n     PLATFORM = \"x86_64-accton_as7312_54x-r0\"\n     HWSKU = \"Accton-AS7312-54X\"\n@@ -256,7 +255,7 @@ def __write_txt_file(self, file_path, value):\n         return True\n     \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py\nindex f32f381b7c..1c97d0e878 100644\n--- a/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py\n@@ -6,8 +6,8 @@\n #\n #############################################################################\n \n-import os\n import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -27,7 +27,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE= \"/sys/class/leds/accton_as7326_56x_led::diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n@@ -93,7 +93,7 @@ def __initialize_watchdog(self):\n         self._watchdog = Watchdog()\n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py\nindex 95a54e554a..16fe60bfb6 100644\n--- a/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py\n@@ -6,10 +6,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -40,7 +39,7 @@ class Sfp(SfpOptoeBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n \n     PLATFORM = \"x86_64-accton_as7326_56x-r0\"\n     HWSKU = \"Accton-AS7326-56X\"\n@@ -144,7 +143,7 @@ def __write_txt_file(self, file_path, value):\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py\nindex 44a759045b..164da5fd61 100644\n--- a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py\n@@ -6,8 +6,8 @@\n #\n #############################################################################\n \n-import os\n import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -26,7 +26,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE = \"/sys/class/leds/as7816_64x_led::diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n@@ -96,7 +96,7 @@ def __initialize_watchdog(self):\n     \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py\nindex 6af2f6008e..d024e43e1f 100644\n--- a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py\n@@ -6,8 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -43,22 +41,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py\nindex b124ca29f0..b19fab85de 100644\n--- a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py\nindex 01e568ef3e..d8ff303b35 100644\n--- a/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py\n@@ -6,10 +6,9 @@\n #\n #############################################################################\n \n-import os\n import time\n import sys\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -31,7 +30,7 @@ class Sfp(SfpOptoeBase):\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as7816_64x-r0\"\n     HWSKU = \"Accton-AS7816-64X\"\n@@ -119,7 +118,7 @@ def get_eeprom_path(self):\n         return self.port_to_eeprom_mapping[self.port_num]\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py\nindex 7eb9601d8b..b0a573432b 100644\n--- a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py\n+++ b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py\n@@ -6,7 +6,7 @@\n #\n #############################################################################\n \n-import os\n+import subprocess\n \n try:\n     from sonic_platform_base.chassis_base import ChassisBase\n@@ -28,7 +28,7 @@\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n@@ -96,7 +96,7 @@ def __initialize_watchdog(self):\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:\ndiff --git a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py\nindex c34da70443..8137d0f3a7 100644\n--- a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py\n+++ b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py\n@@ -6,9 +6,6 @@\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -38,22 +35,6 @@ def __init__(self, component_index=0):\n         self.index = component_index\n         self.name = self.get_name()        \n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try:\ndiff --git a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py\nindex 4cd60ac906..2c644ecbfb 100644\n--- a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py\n+++ b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py\n@@ -4,7 +4,7 @@\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -14,7 +14,7 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -29,26 +29,6 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n@@ -66,52 +46,3 @@ def write_txt_file(self, file_path, value):\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\ndiff --git a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py\nindex 6cefc2a29a..5d7c03d005 100644\n--- a/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py\n+++ b/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py\n@@ -6,11 +6,10 @@\n #\n #############################################################################\n \n-import os\n import sys\n import time\n import struct\n-\n+import subprocess\n from ctypes import create_string_buffer\n \n try:\n@@ -272,7 +271,7 @@\n \n class Sfp(SfpBase):\n     \"\"\"Platform-specific Sfp class\"\"\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n     PLATFORM = \"x86_64-accton_as9726_32d-r0\"\n     HWSKU = \"Accton-AS9726-32D\"\n \n@@ -310,7 +309,7 @@ def __write_txt_file(self, file_path, value):\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py\nindex 2269634152..2659d16f1c 100644\n--- a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py\n@@ -8,8 +8,8 @@\n #############################################################################\n \n try:\n-    import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -67,8 +67,8 @@ def get_firmware_version(self):\n         if self.name == \"BIOS\":\n             fw_version = self.__get_bios_version()\n         elif \"CPLD\" in self.name:\n-            cmd = \"i2cget -f -y {0} {1} 0x1\".format(self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1])\n-            status, value = subprocess.getstatusoutput(cmd)\n+            cmd = [\"i2cget\", \"-f\", \"-y\", self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1], \"0x1\"]\n+            status, value = getstatusoutput_noshell(cmd)\n             if not status:\n                 fw_version = value.rstrip()\n \ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py\nindex b074177133..e79137785d 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py\n@@ -26,9 +26,9 @@\n     import logging.config\n     import logging.handlers\n     import time\n-    import subprocess\n     from as4630_54pe.fanutil import FanUtil\n     from as4630_54pe.thermalutil import ThermalUtil\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n@@ -198,9 +198,9 @@ def manage_fans(self):\n         if temp[0] >= 70000: #LM75-48    \n             #critical case*/\n             logging.critical('Alarm-Critical for temperature critical is detected, reset DUT')\n-            cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2);\n-            status, output = subprocess.getstatusoutput(cmd_str)\n+            status, output = getstatusoutput_noshell(cmd_str)\n                 \n         #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_state, fan_policy_state, temp_val)\n         \ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py\nindex d9299b96a3..6bbaeaa06d 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py\n@@ -28,6 +28,7 @@\n     import logging.handlers\n     import time\n     from sonic_platform import platform\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n@@ -209,10 +210,12 @@ def manage_fans(self):\n             # Critical: Either all the fans are faulty or they are removed, shutdown the system\n             logging.critical('Alarm for all fan faulty/absent is detected')\n             logging.critical(\"Alarm for all fan faulty/absent is detected, reset DUT\")\n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2)\n-            subprocess.getstatusoutput('sync; sync; sync')\n-            subprocess.getstatusoutput(cmd_str)\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell(cmd_str)\n         elif sum(fan_fail_list) != 0:\n             # Set the 100% speed only for first fan failure detection\n             logging.warning('Fan_{} failed, set remaining fan speed to 100%'.format(\n@@ -235,7 +238,7 @@ def manage_fans(self):\n             as4630_54pe_set_fan_speed(new_duty_cycle)\n             if test_temp == 1:\n                 time.sleep(3)\n-                status, output = subprocess.getstatusoutput('pddf_fanutil getspeed')\n+                status, output = getstatusoutput_noshell(['pddf_fanutil', 'getspeed'])\n                 logging.debug('\\n%s\\n', output)\n \n         if temp[0] >= 70000:  # LM77-48\n@@ -252,10 +255,12 @@ def manage_fans(self):\n             if status:\n                 logging.warning('Reboot cause file not updated. {}'.format(output))\n \n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n-            subprocess.getstatusoutput('sync; sync; sync')\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n             time.sleep(3)\n-            subprocess.getstatusoutput(cmd_str)\n+            getstatusoutput_noshell(cmd_str)\n \n         logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n', ori_state, fan_policy_state, temp_val)\n \ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py\nindex 5a505e19f1..5c00f338ba 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py\n@@ -2,111 +2,111 @@\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import commands\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"clean\"])\n     if status:\n-        print \"accton_as4630_54pe_util.py clean command failed %d\"%status\n+        print(\"accton_as4630_54pe_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Stop pddf-platform-init.service along with other platform serives failed %d\"%status\n+        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status\n+        print(\"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status)\n         return False\n \n     return True\n     \n def start_platform_svc():\n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"install\"])\n     if status:\n-        print \"accton_as4630_54pe_util.py install  command failed %d\"%status\n+        print(\"accton_as4630_54pe_util.py install  command failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n \n     return True\n \n def start_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Start pddf-platform-init.service failed %d\"%status\n+        print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n+        print(\"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status)\n         return False\n     \n     return True\n \n def stop_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Stop pddf-platform-init.service failed %d\"%status\n+        print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n+        print(\"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status)\n         return False\n \n     return True\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py\nindex d3c2b2c860..aa5076c2ca 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py\n@@ -20,7 +20,6 @@\n # ------------------------------------------------------------------\n \n try:\n-    import os\n     import sys\n     import getopt\n     import logging\n@@ -194,9 +193,9 @@ def manage_fans(self):\n             # critical case*/\n             logging.critical(\n                 'Alarm-Critical for temperature critical is detected, reset DUT')\n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2)\n-            return_value = os.system(cmd_str)\n+            return_value = subprocess.call(cmd_str)\n             logging.warning('Fan set: i2cset -y -f 3 0x60 0x4 0xE4, status is %d', return_value)\n \n         #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_state, fan_policy_state, temp_val)\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py b/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py\nindex 31697f7c64..9dc8d94ef6 100644\n--- a/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py\n@@ -24,10 +24,8 @@\n # ------------------------------------------------------------------\n \n try:\n-    import time\n     import logging\n-    from collections import namedtuple\n-    import subprocess\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n@@ -65,10 +63,11 @@ def _get_fan_to_device_node(self, fan_num, node_num):\n         return \"fan{0}_{1}\".format(fan_num, self.node_postfix[node_num-1])\n     \n     def _get_fan_i2c_bus_addr(self):\n-        cmd_template = 'i2cget -f -y {} 0x{} 0'\n+        cmd_template = ['i2cget', '-f', '-y', '', '', '0']\n         for bus_no, dev_addr in self.I2CADDR_CANDIDATES:\n-            cmd = cmd_template.format(bus_no, dev_addr)\n-            if subprocess.getstatusoutput(cmd)[0] == 0:\n+            cmd_template[3] = str(bus_no)\n+            cmd_template[4] = '0x' + str(dev_addr)\n+            if getstatusoutput_noshell(cmd_template)[0] == 0:\n                 return bus_no, dev_addr\n         raise IOError('Unable to reach fan CPLD via I2C')\n \ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py\nindex ec3a4c133c..da046335cd 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py\n@@ -23,10 +23,10 @@\n # ------------------------------------------------------------------\n \n try:\n-    import os\n     import getopt\n     import sys\n     import logging\n+    import subprocess\n     import logging.config\n     import logging.handlers\n     import time  # this is only being used as part of the example\n@@ -233,7 +233,7 @@ def manage_fans(self):\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -242,7 +242,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -251,7 +251,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n@@ -260,7 +260,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is cleared')\n                 alarm_state=0\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py\nindex faa4f7d48b..7f3add4e4d 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py\n@@ -22,10 +22,10 @@\n # ------------------------------------------------------------------\n \n try:\n-    import os\n     import sys\n     import getopt\n     import logging\n+    import subprocess\n     import logging.config\n     import logging.handlers\n     import time\n@@ -218,7 +218,7 @@ def manage_fans(self):\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n         if ori_state == LEVEL_FAN_MID:\n             if new_state == LEVEL_TEMP_HIGH:\n                 if alarm_state == 0:\n@@ -227,7 +227,7 @@ def manage_fans(self):\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n         if ori_state == LEVEL_FAN_MAX:\n             if new_state == LEVEL_TEMP_HIGH:\n                 if alarm_state == 0:\n@@ -236,7 +236,7 @@ def manage_fans(self):\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if alarm_state == 1:\n                 if temp_get < (fan_policy[3][0] - 5000):  # below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n@@ -245,7 +245,7 @@ def manage_fans(self):\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is cleared')\n                 alarm_state = 0\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py\nindex c3e1c50366..f4335bd445 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py\n@@ -33,7 +33,7 @@\n import re\n import time\n import os\n-\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n PROJECT_NAME = 'as7326_56x'\n@@ -100,16 +100,16 @@ def show_help():\n \n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\n@@ -257,8 +257,8 @@ def i2c_order_check():\n     return 0\n \n def eeprom_check():\n-    cmd = \"i2cget -y -f 0 0x56\"\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cget\", \"-y\", \"-f\", \"0\", \"0x56\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def device_install():\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py\nindex 1b5f46ef0e..f02202b210 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py\n@@ -2,39 +2,39 @@\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as7326-platform-fan.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as7326-platform-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Stop as7326-platform-init.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Disable as7326-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as7326_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n@@ -42,21 +42,21 @@ def stop_platform_svc():\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"install\"])\n     if status:\n         print(\"accton_as7326_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Enable as7326-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as7326-platform-monitor-fan.service failed %d\"%status)\n         return False\n         \n-    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as7326-platform-monitor-psu.service failed %d\"%status)\n         return False\n@@ -64,7 +64,7 @@ def start_platform_svc():\n     return True\n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n@@ -72,7 +72,7 @@ def start_platform_pddf():\n     return True\n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py\nindex 3ed3f7604e..0f6c828930 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py\n@@ -1,28 +1,28 @@\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import commands\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = commands.getstatusoutput(\"systemctl stop as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Stop as7712-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl disable as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Disable as7712-platform-init.service failed %d\"%status)\n         return False\n     \n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"clean\"])\n     if status:\n-        print(\"accton_as7712_util.py clean command failed %d\"%status)\n+        print(\"accton_as7712_util.py clean failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n@@ -30,16 +30,16 @@ def stop_platform_svc():\n     return True\n     \n def start_platform_svc():\n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"install\"])\n     if status:\n-        print(\"accton_as7712_util.py install command failed %d\"%status)\n+        print(\"accton_as7712_util.py install failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Enable as7712-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Start as7712-platform-init.service failed %d\"%status)\n         return False\n@@ -47,7 +47,7 @@ def start_platform_svc():\n     return True\n \n def start_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n@@ -55,7 +55,7 @@ def start_platform_pddf():\n     return True\n \n def stop_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py b/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py\nindex 6322aac6bb..f312d22616 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py\n@@ -36,6 +36,7 @@\n import logging\n import re\n import time\n+from sonic_py_common.general import getstatusoutput_noshell\n \n PROJECT_NAME = 'as7716_32x'\n version = '0.0.1'\n@@ -220,16 +221,16 @@ def  show_set_help():\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py\nindex f506b72f83..b889dcf712 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py\n@@ -23,10 +23,10 @@\n # ------------------------------------------------------------------\n \n try:\n-    import os\n     import getopt\n     import sys\n     import logging\n+    import subprocess\n     import logging.config\n     import logging.handlers\n     import time  # this is only being used as part of the example\n@@ -242,7 +242,7 @@ def manage_fans(self):\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -251,7 +251,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -260,7 +260,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n@@ -269,7 +269,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is cleared')\n                 alarm_state=0\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py\nindex fd283cd6cc..2b18ac646a 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py\n@@ -24,10 +24,10 @@\n # ------------------------------------------------------------------\n \n try:\n-    import os\n     import sys\n     import getopt\n     import logging\n+    import subprocess\n     import logging.config\n     import logging.handlers\n     import time\n@@ -230,7 +230,7 @@ def manage_fans(self):\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -239,7 +239,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n@@ -248,7 +248,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n@@ -257,7 +257,7 @@ def manage_fans(self):\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is cleared')\n                 alarm_state=0\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py\nindex bee413fe06..949f1230de 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py\n@@ -32,6 +32,7 @@\n import logging\n import re\n import time\n+from sonic_py_common.general import getstatusoutput_noshell\n \n PROJECT_NAME = 'as7726_32x'\n version = '0.0.1'\n@@ -147,16 +148,16 @@ def show_help():\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py\nindex 9664d21b6c..e8b42aaa1b 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py\n@@ -2,44 +2,44 @@\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as7726_32x_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n@@ -47,32 +47,32 @@ def stop_platform_svc():\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py install\"])\n     if status:\n         print(\"accton_as7726_32x_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n@@ -80,7 +80,7 @@ def start_platform_svc():\n     return True\n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n@@ -88,7 +88,7 @@ def start_platform_pddf():\n     return True\n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py b/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py\nindex 1e9314fb82..5ab3d8f20e 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py\n@@ -32,7 +32,7 @@\n import re\n import time\n import os\n-\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n PROJECT_NAME = 'as7816_64x'\n@@ -99,18 +99,17 @@ def show_help():\n     print( __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]})\n     sys.exit(0)\n \n-   \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py\nindex 98bf05eca1..166b9c12f0 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py\n@@ -1,7 +1,7 @@\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services.\n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n def check_pddf_support():\n@@ -10,22 +10,22 @@ def check_pddf_support():\n \n def stop_platform_svc():\n \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Stop as7816-platform-init.service failed %d\" % status))\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Disable as7816-platform-init.service failed %d\" % status))\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"clean\"])\n     if status:\n         print((\"accton_as7816_util.py clean command failed %d\" % status))\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Stop pddf-platform-init.service along with other platform serives failed %d\" % status))\n         return False\n@@ -34,12 +34,12 @@ def stop_platform_svc():\n \n \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"install\"])\n     if status:\n         print((\"accton_as7816_util.py install command failed %d\" % status))\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Enable as7816-platform-init.service failed %d\" % status))\n         return False\n@@ -48,7 +48,7 @@ def start_platform_svc():\n \n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Start pddf-platform-init.service failed %d\" % status))\n         return False\n@@ -57,7 +57,7 @@ def start_platform_pddf():\n \n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Stop pddf-platform-init.service failed %d\" % status))\n         return False\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py b/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py\nindex 647e26e07d..53126109f9 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py\n@@ -32,6 +32,7 @@\n import logging\n import re\n import time\n+from sonic_py_common.general import getstatusoutput_noshell\n \n PROJECT_NAME = 'as9716_32d'\n version = '0.0.1'\n@@ -153,16 +154,16 @@ def show_help():\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\ndiff --git a/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py b/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py\nindex 95e42b5c89..1d672015d5 100755\n--- a/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py\n+++ b/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py\n@@ -1,39 +1,39 @@\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-fan.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-init.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Disable as9716-32d-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as9716_32d_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n@@ -41,21 +41,21 @@ def stop_platform_svc():\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"install\"])\n     if status:\n         print(\"accton_as9716_32d_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Enable as9716-32d-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as9716-32d-platform-monitor-fan.service failed %d\"%status)\n         return False\n         \n-    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as9716-32d-platform-monitor-psu.service failed %d\"%status)\n         return False\n@@ -64,7 +64,7 @@ def start_platform_svc():\n \n def start_platform_pddf():   \n \n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n@@ -73,7 +73,7 @@ def start_platform_pddf():\n \n def stop_platform_pddf():   \n \n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\n", "message": "", "files": {"/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         try:", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os import sys try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper from.event import SfpEvent except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=3 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=3 PORT_START=49 PORT_END=54 NUM_COMPONENT=2 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" SYSLED_FNODE=\"/sys/class/leds/diag/brightness\" SYSLED_MODES={ \"0\": \"STATUS_LED_COLOR_OFF\", \"1\": \"STATUS_LED_COLOR_GREEN\", \"2\": \"STATUS_LED_COLOR_AMBER\", \"5\": \"STATUS_LED_COLOR_GREEN_BLINK\" } class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(0, PORT_END): sfp=Sfp(index) self._sfp_list.append(sfp) self._sfpevent=SfpEvent(self._sfp_list) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for fant_index in range(NUM_FAN_TRAY): fandrawer=FanDrawer(fant_index) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._eeprom.get_product_name() def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_change_event(self, timeout=0): if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfpevent.get_sfp_event(timeout) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def initizalize_system_led(self): return True def get_status_led(self): val=self._api_helper.read_txt_file(SYSLED_FNODE) return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\" def set_status_led(self, color): mode=None for key, val in SYSLED_MODES.items(): if val==color: mode=key break if mode is None: return False else: return self._api_helper.write_txt_file(SYSLED_FNODE, mode) ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\nimport sys\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\n    from .event import SfpEvent\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 3\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 3\nPORT_START = 49\nPORT_END = 54\nNUM_COMPONENT = 2\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\nSYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\nSYSLED_MODES = {\n    \"0\" : \"STATUS_LED_COLOR_OFF\",\n    \"1\" : \"STATUS_LED_COLOR_GREEN\",\n    \"2\" : \"STATUS_LED_COLOR_AMBER\",\n    \"5\" : \"STATUS_LED_COLOR_GREEN_BLINK\"\n}\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n        \n        self.config_data = {}\n        \n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n    \n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(0, PORT_END):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self._sfpevent = SfpEvent(self._sfp_list)\n        self.sfp_module_initialized = True\n\n    def __initialize_fan(self):\n       from sonic_platform.fan_drawer import FanDrawer\n       for fant_index in range(NUM_FAN_TRAY):\n           fandrawer = FanDrawer(fant_index)\n           self._fan_drawer_list.append(fandrawer)\n           self._fan_list.extend(fandrawer._fan_list)\n               \n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n    \n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n    \n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n\n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        \n        return self._eeprom.get_product_name()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n\n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_change_event(self, timeout=0):\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return self._sfpevent.get_sfp_event(timeout)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n\n    def initizalize_system_led(self):\n        return True\n\n    def get_status_led(self):\n        val = self._api_helper.read_txt_file(SYSLED_FNODE)\n        return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\"\n\n    def set_status_led(self, color):\n        mode = None\n        for key, val in SYSLED_MODES.items():\n            if val == color:\n                mode = key\n                break\n        if mode is None:\n            return False\n        else:\n            return self._api_helper.write_txt_file(SYSLED_FNODE, mode)\n\n"}, "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 3, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n         try", "add": 0, "remove": 16, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"3-0060\" } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"BIOS\", \"Basic Input/Output System\") ] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return 'N/A' def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return 'N/A' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is'0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"3-0060\"\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n   \n]\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)\n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n        \n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n        \n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of\n        entPhysicalContainedIn is'0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device\n            or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, resu", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, resu"], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r', errors='replace') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r', errors='replace') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as4630_54pe-r0\"\n     HWSKU = \"Accton-AS4630-54PE\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n         return self.port_to_eeprom_mapping[self.port_num]\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFOR", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54pe-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}], "source": "\n import os import time import sys from ctypes import create_string_buffer try: from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_I2C_PATH=\"/sys/bus/i2c/devices/3-0060/\" class Sfp(SfpOptoeBase): \"\"\"Platform-specific Sfp class\"\"\" PORT_START=49 PORT_END=54 PLATFORM_ROOT_PATH=\"/usr/share/sonic/device\" PMON_HWSKU_PATH=\"/usr/share/sonic/hwsku\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" PLATFORM=\"x86_64-accton_as4630_54pe-r0\" HWSKU=\"Accton-AS4630-54PE\" _port_to_i2c_mapping={ 49: 18, 50: 19, 51: 20, 52: 21, 53: 22, 54: 23, } def __init__(self, sfp_index=0): SfpOptoeBase.__init__(self) self._api_helper=APIHelper() self.index=sfp_index self.port_num=self.index +1 eeprom_path='/sys/bus/i2c/devices/{0}-0050/eeprom' self.port_to_eeprom_mapping={} for x in range(self.PORT_START, self.PORT_END +1): self.port_to_eeprom_mapping[x]=eeprom_path.format(self._port_to_i2c_mapping[x]) def get_eeprom_path(self): return self.port_to_eeprom_mapping[self.port_num] def __is_host(self): return os.system(self.HOST_CHK_CMD)==0 def __get_path_to_port_config_file(self): platform_path=\"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM]) hwsku_path=\"/\".join([platform_path, self.HWSKU] ) if self.__is_host() else self.PMON_HWSKU_PATH return \"/\".join([hwsku_path, \"port_config.ini\"]) def __read_eeprom_specific_bytes(self, offset, num_bytes): sysfsfile_eeprom=None eeprom_raw=[] for i in range(0, num_bytes): eeprom_raw.append(\"0x00\") sysfs_sfp_i2c_client_eeprom_path=self.port_to_eeprom_mapping[self.port_num] try: sysfsfile_eeprom=open( sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0) sysfsfile_eeprom.seek(offset) raw=sysfsfile_eeprom.read(num_bytes) if sys.version_info[0] >=3: for n in range(0, num_bytes): eeprom_raw[n]=hex(raw[n])[2:].zfill(2) else: for n in range(0, num_bytes): eeprom_raw[n]=hex(ord(raw[n]))[2:].zfill(2) except Exception: pass finally: if sysfsfile_eeprom: sysfsfile_eeprom.close() return eeprom_raw def get_reset_status(self): \"\"\" Retrieves the reset status of SFP Returns: A Boolean, True if reset enabled, False if disabled \"\"\" if self.port_num < 53: return False reset_path=\"{}{}{}\".format(CPLD_I2C_PATH, \"module_reset_\", str(self.port_num)) val=self._api_helper.read_txt_file(reset_path) if val is not None: return int(val, 10)==1 else: return False def get_rx_los(self): \"\"\" Retrieves the RX LOS(lost-of-signal) status of SFP Returns: A Boolean, True if SFP has RX LOS, False if not. Note: RX LOS status is latched until a call to get_rx_los or a reset. \"\"\" rx_los=False if self.port_num < 49: return False if self.port_num < 53: rx_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_rx_los_', self.port_num) rx_los=self._api_helper.read_txt_file(rx_path) if rx_los is None: return False else: rx_los_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: rx_los_data=int(dom_channel_monitor_raw[0], 16) rx_los_list.append(rx_los_data & 0x01 !=0) rx_los_list.append(rx_los_data & 0x02 !=0) rx_los_list.append(rx_los_data & 0x04 !=0) rx_los_list.append(rx_los_data & 0x08 !=0) rx_los=rx_los_list[0] and rx_los_list[1] and rx_los_list[2] and rx_los_list[3] return rx_los def get_tx_fault(self): \"\"\" Retrieves the TX fault status of SFP Returns: A Boolean, True if SFP has TX fault, False if not Note: TX fault status is lached until a call to get_tx_fault or a reset. \"\"\" tx_fault=False if self.port_num < 49: return False if self.port_num < 53: tx_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_fault_', self.port_num) tx_fault=self._api_helper.read_txt_file(tx_path) if tx_fault is None: return False else: tx_fault_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: tx_fault_data=int(dom_channel_monitor_raw[0], 16) tx_fault_list.append(tx_fault_data & 0x01 !=0) tx_fault_list.append(tx_fault_data & 0x02 !=0) tx_fault_list.append(tx_fault_data & 0x04 !=0) tx_fault_list.append(tx_fault_data & 0x08 !=0) tx_fault=tx_fault_list[0] and tx_fault_list[1] and tx_fault_list[2] and tx_fault_list[3] return tx_fault def get_tx_disable(self): \"\"\" Retrieves the tx_disable status of this SFP Returns: A Boolean, True if tx_disable is enabled, False if disabled \"\"\" if self.port_num < 49: return False if self.port_num < 53: tx_disable=False tx_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_disable_', self.port_num) tx_disable=self._api_helper.read_txt_file(tx_path) if tx_disable is not None: return tx_disable else: return False else: tx_disable_list=[] sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) tx_disable_list.append( 'On'==dom_control_data['data']['TX1Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX2Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX3Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX4Disable']['value']) return tx_disable_list def get_tx_disable_channel(self): \"\"\" Retrieves the TX disabled channels in this SFP Returns: A hex of 4 bits(bit 0 to bit 3 as channel 0 to channel 3) to represent TX channels which have been disabled in this SFP. As an example, a returned value of 0x5 indicates that channel 0 and channel 2 have been disabled. \"\"\" if self.port_num < 53: return False else: tx_disable_list=self.get_tx_disable() if tx_disable_list is None: return 0 tx_disabled=0 for i in range(len(tx_disable_list)): if tx_disable_list[i]: tx_disabled |=1 << i return tx_disabled def get_lpmode(self): \"\"\" Retrieves the lpmode(low power mode) status of this SFP Returns: A Boolean, True if lpmode is enabled, False if disabled \"\"\" if self.port_num < 53: return False else: power_set=self.get_power_set() power_override=self.get_power_override() return power_set and power_override def reset(self): \"\"\" Reset SFP and return all user module settings to their default srate. Returns: A boolean, True if successful, False if not \"\"\" if self.port_num < 53: return False reset_path=\"{}{}{}\".format(CPLD_I2C_PATH, 'module_reset_', self.port_num) ret=self._api_helper.write_txt_file(reset_path, 1) if ret is not True: return ret time.sleep(0.01) ret=self._api_helper.write_txt_file(reset_path, 0) time.sleep(0.2) return ret def tx_disable(self, tx_disable): \"\"\" Disable SFP TX for all channels Args: tx_disable: A Boolean, True to enable tx_disable mode, False to disable tx_disable mode. Returns: A boolean, True if tx_disable is set successfully, False if not \"\"\" if self.port_num < 49: return False if self.port_num < 53: tx_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_disable_', self.port_num) ret=self._api_helper.write_txt_file(tx_path, 1 if tx_disable else 0) if ret is not None: time.sleep(0.01) return ret else: return False else: if not self.get_presence(): return False sysfsfile_eeprom=None try: tx_disable_ctl=0xf if tx_disable else 0x0 buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=tx_disable_ctl else: buffer[0]=chr(tx_disable_ctl) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ',str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def tx_disable_channel(self, channel, disable): \"\"\" Sets the tx_disable for specified SFP channels Args: channel: A hex of 4 bits(bit 0 to bit 3) which represent channel 0 to 3, e.g. 0x5 for channel 0 and channel 2. disable: A boolean, True to disable TX channels specified in channel, False to enable Returns: A boolean, True if successful, False if not \"\"\" if self.port_num < 53: return False else: if not self.get_presence(): return False sysfsfile_eeprom=None try: channel_state=self.get_tx_disable_channel() for i in range(4): channel_mask=(1 << i) if not(channel & channel_mask): continue if disable: channel_state |=channel_mask else: channel_state &=~channel_mask buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=channel_state else: buffer[0]=chr(channel_state) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ', str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def set_lpmode(self, lpmode): \"\"\" Sets the lpmode(low power mode) of SFP Args: lpmode: A Boolean, True to enable lpmode, False to disable it Note : lpmode can be overridden by set_power_override Returns: A boolean, True if lpmode is set successfully, False if not \"\"\" if self.port_num < 53: return False else: if lpmode is True: self.set_power_override(True, True) else: self.set_power_override(False, False) return True def set_power_override(self, power_override, power_set): \"\"\" Sets SFP power level using power_override and power_set Args: power_override: A Boolean, True to override set_lpmode and use power_set to control SFP power, False to disable SFP power control through power_override/power_set and use set_lpmode to control SFP power. power_set: Only valid when power_override is True. A Boolean, True to set SFP to low power mode, False to set SFP to high power mode. Returns: A boolean, True if power-override and power_set are set successfully, False if not \"\"\" if self.port_num < 53: return False else: if not self.get_presence(): return False try: power_override_bit=(1 << 0) if power_override else 0 power_set_bit =(1 << 1) if power_set else(1 << 3) buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=(power_override_bit | power_set_bit) else: buffer[0]=chr(power_override_bit | power_set_bit) with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd: fd.seek(QSFP_POWEROVERRIDE_OFFSET) fd.write(buffer[0]) time.sleep(0.01) except IOError as e: print('Error: unable to open file: ', str(e)) return False return True def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" name=None sfputil_helper=SfpUtilHelper() sfputil_helper.read_porttab_mappings( self.__get_path_to_port_config_file()) name=sfputil_helper.logical[self.index] or \"Unknown\" return name def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" if self.port_num < 49: return False present_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_present_', self.port_num) val=self._api_helper.read_txt_file(present_path) if val is not None: return int(val, 10)==1 else: return False def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return self.get_presence() def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return self.port_num def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return True ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Sfp contains an implementation of SONiC Platform Base API and\n# provides the sfp device status which are available in the platform\n#\n#############################################################################\n\nimport os\nimport time\nimport sys\n\nfrom ctypes import create_string_buffer\n\ntry:\n    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_I2C_PATH = \"/sys/bus/i2c/devices/3-0060/\"\n\nclass Sfp(SfpOptoeBase):\n    \"\"\"Platform-specific Sfp class\"\"\"\n\n    # Port number\n    PORT_START = 49\n    PORT_END = 54\n\n    # Path to sysfs\n    PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n    PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n        \n    PLATFORM = \"x86_64-accton_as4630_54pe-r0\"\n    HWSKU = \"Accton-AS4630-54PE\"\n\n    _port_to_i2c_mapping = {\n           49: 18,\n           50: 19,\n           51: 20,\n           52: 21,\n           53: 22,\n           54: 23,\n    }\n\n    def __init__(self, sfp_index=0):\n        SfpOptoeBase.__init__(self)\n        self._api_helper=APIHelper()\n        # Init index\n        self.index = sfp_index\n        self.port_num = self.index + 1\n        # Init eeprom path\n        eeprom_path = '/sys/bus/i2c/devices/{0}-0050/eeprom'\n        self.port_to_eeprom_mapping = {}\n        for x in range(self.PORT_START, self.PORT_END + 1):\n            self.port_to_eeprom_mapping[x] = eeprom_path.format(self._port_to_i2c_mapping[x])\n\n    def get_eeprom_path(self):\n        return self.port_to_eeprom_mapping[self.port_num]\n\n    def __is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def __get_path_to_port_config_file(self):\n        platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n        hwsku_path = \"/\".join([platform_path, self.HWSKU]\n                              ) if self.__is_host() else self.PMON_HWSKU_PATH\n        return \"/\".join([hwsku_path, \"port_config.ini\"])\n\n    def __read_eeprom_specific_bytes(self, offset, num_bytes):\n        sysfsfile_eeprom = None\n        eeprom_raw = []\n        for i in range(0, num_bytes):\n            eeprom_raw.append(\"0x00\")\n\n        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]\n        try:\n            sysfsfile_eeprom = open(\n                sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0)\n            sysfsfile_eeprom.seek(offset)\n            raw = sysfsfile_eeprom.read(num_bytes)\n            if sys.version_info[0] >= 3:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(raw[n])[2:].zfill(2)\n            else:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(ord(raw[n]))[2:].zfill(2)\n        except Exception:\n            pass\n        finally:\n            if sysfsfile_eeprom:\n                sysfsfile_eeprom.close()\n\n        return eeprom_raw\n\n    def get_reset_status(self):\n        \"\"\"\n        Retrieves the reset status of SFP\n        Returns:\n            A Boolean, True if reset enabled, False if disabled\n        \"\"\"\n        if self.port_num < 53: #Copper port and sfp ports are suported.\n            return False\n\n        reset_path=\"{}{}{}\".format(CPLD_I2C_PATH , \"module_reset_\" , str(self.port_num))\n        val = self._api_helper.read_txt_file(reset_path)\n        \n        if val is not None:\n            return int(val, 10) == 1\n        else:        \n            return False\n\n    def get_rx_los(self):\n        \"\"\"\n        Retrieves the RX LOS (lost-of-signal) status of SFP\n        Returns:\n            A Boolean, True if SFP has RX LOS, False if not.\n            Note : RX LOS status is latched until a call to get_rx_los or a reset.\n        \"\"\"\n        rx_los = False\n        \n        if self.port_num < 49: #Copper port, no sysfs\n            return False\n            \n        if self.port_num < 53:\n            rx_path = \"{}{}{}\".format(CPLD_I2C_PATH, '/module_rx_los_', self.port_num)\n            rx_los=self._api_helper.read_txt_file(rx_path)\n            if rx_los is None:\n                return False\n        else:\n            rx_los_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None\n            if dom_channel_monitor_raw is not None:\n                rx_los_data = int(dom_channel_monitor_raw[0], 16)\n                rx_los_list.append(rx_los_data & 0x01 != 0)\n                rx_los_list.append(rx_los_data & 0x02 != 0)\n                rx_los_list.append(rx_los_data & 0x04 != 0)\n                rx_los_list.append(rx_los_data & 0x08 != 0)\n                rx_los = rx_los_list[0] and rx_los_list[1] and rx_los_list[2] and rx_los_list[3]\n        return rx_los\n\n    def get_tx_fault(self):\n        \"\"\"\n        Retrieves the TX fault status of SFP\n        Returns:\n            A Boolean, True if SFP has TX fault, False if not\n            Note : TX fault status is lached until a call to get_tx_fault or a reset.\n        \"\"\"\n        tx_fault = False\n        if self.port_num < 49: #Copper port, no sysfs\n            return False\n        \n        if self.port_num < 53:\n            tx_path = \"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_fault_', self.port_num)\n            tx_fault=self._api_helper.read_txt_file(tx_path)\n            if tx_fault is None:\n                return False\n        else:\n            tx_fault_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None\n            if dom_channel_monitor_raw is not None:\n                tx_fault_data = int(dom_channel_monitor_raw[0], 16)\n                tx_fault_list.append(tx_fault_data & 0x01 != 0)\n                tx_fault_list.append(tx_fault_data & 0x02 != 0)\n                tx_fault_list.append(tx_fault_data & 0x04 != 0)\n                tx_fault_list.append(tx_fault_data & 0x08 != 0)\n                tx_fault = tx_fault_list[0] and tx_fault_list[1] and tx_fault_list[2] and tx_fault_list[3]\n\n        return tx_fault\n\n    def get_tx_disable(self):\n        \"\"\"\n        Retrieves the tx_disable status of this SFP\n        Returns:\n            A Boolean, True if tx_disable is enabled, False if disabled\n        \"\"\"\n        if self.port_num < 49: #Copper port, no sysfs\n            return False\n        \n        if self.port_num < 53: \n            tx_disable = False            \n                \n            tx_path = \"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_disable_', self.port_num)\n            tx_disable=self._api_helper.read_txt_file(tx_path)\n            \n            if tx_disable is not None:\n                return tx_disable \n            else:\n                return False\n                   \n        else:\n            tx_disable_list = []\n    \n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n    \n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX1Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX2Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX3Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX4Disable']['value'])\n    \n            return tx_disable_list\n\n    def get_tx_disable_channel(self):\n        \"\"\"\n        Retrieves the TX disabled channels in this SFP\n        Returns:\n            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent\n            TX channels which have been disabled in this SFP.\n            As an example, a returned value of 0x5 indicates that channel 0\n            and channel 2 have been disabled.\n        \"\"\"\n        if self.port_num < 53: \n            # SFP doesn't support this feature\n            return False\n        else:\n            tx_disable_list = self.get_tx_disable()\n            if tx_disable_list is None:\n                return 0\n            tx_disabled = 0\n            for i in range(len(tx_disable_list)):\n                if tx_disable_list[i]:\n                    tx_disabled |= 1 << i\n            return tx_disabled\n\n    def get_lpmode(self):\n        \"\"\"\n        Retrieves the lpmode (low power mode) status of this SFP\n        Returns:\n            A Boolean, True if lpmode is enabled, False if disabled\n        \"\"\"\n        if self.port_num < 53: \n            # SFP doesn't support this feature\n            return False\n        else:\n            power_set=self.get_power_set()\n            power_override = self.get_power_override()\n            return power_set and power_override\n      \n    \n    def reset(self):\n        \"\"\"\n        Reset SFP and return all user module settings to their default srate.\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        # Check for invalid port_num\n        if self.port_num < 53: #Copper port and  sfp ports are not supported.\n            return False\n\n        reset_path = \"{}{}{}\".format(CPLD_I2C_PATH, 'module_reset_', self.port_num)\n        ret = self._api_helper.write_txt_file(reset_path, 1)\n        if ret is not True:\n            return ret\n        \n        time.sleep(0.01)\n        ret = self._api_helper.write_txt_file(reset_path, 0)\n        time.sleep(0.2)\n        \n        return ret\n        \n    def tx_disable(self, tx_disable):\n        \"\"\"\n        Disable SFP TX for all channels\n        Args:\n            tx_disable : A Boolean, True to enable tx_disable mode, False to disable\n                         tx_disable mode.\n        Returns:\n            A boolean, True if tx_disable is set successfully, False if not\n        \"\"\"\n        if self.port_num < 49: #Copper port, no sysfs\n            return False\n        \n        if self.port_num < 53:\n            tx_path = \"{}{}{}\".format(CPLD_I2C_PATH, '/module_tx_disable_', self.port_num)      \n            ret = self._api_helper.write_txt_file(tx_path,  1 if tx_disable else 0)\n            if ret is not None:\n                time.sleep(0.01)\n                return ret\n            else:\n                return False\n        \n        else:\n            if not self.get_presence():\n                return False\n            sysfsfile_eeprom = None\n            try:\n                tx_disable_ctl = 0xf if tx_disable else 0x0\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = tx_disable_ctl\n                else:\n                    buffer[0] = chr(tx_disable_ctl)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print ('Error: unable to open file: ',str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n        return True\n\n    def tx_disable_channel(self, channel, disable):\n        \"\"\"\n        Sets the tx_disable for specified SFP channels\n        Args:\n            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,\n                      e.g. 0x5 for channel 0 and channel 2.\n            disable : A boolean, True to disable TX channels specified in channel,\n                      False to enable\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        \n        if self.port_num < 53:\n            return False # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n\n            sysfsfile_eeprom = None\n            try:\n                channel_state = self.get_tx_disable_channel()\n\n                for i in range(4):\n                    channel_mask = (1 << i)\n                    if not (channel & channel_mask):\n                        continue\n\n                    if disable:\n                        channel_state |= channel_mask\n                    else:\n                        channel_state &= ~channel_mask\n\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = channel_state\n                else:\n                    buffer[0] = chr(channel_state)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print ('Error: unable to open file: ', str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n            return True\n\n    def set_lpmode(self, lpmode):\n        \"\"\"\n        Sets the lpmode (low power mode) of SFP\n        Args:\n            lpmode: A Boolean, True to enable lpmode, False to disable it\n            Note  : lpmode can be overridden by set_power_override\n        Returns:\n            A boolean, True if lpmode is set successfully, False if not\n        \"\"\"\n        if self.port_num < 53:\n            return False # SFP doesn't support this feature\n        else:\n            if lpmode is True:\n                self.set_power_override(True, True)\n            else:\n                self.set_power_override(False, False)\n    \n            return True\n       \n    def set_power_override(self, power_override, power_set):\n        \"\"\"\n        Sets SFP power level using power_override and power_set\n        Args:\n            power_override :\n                    A Boolean, True to override set_lpmode and use power_set\n                    to control SFP power, False to disable SFP power control\n                    through power_override/power_set and use set_lpmode\n                    to control SFP power.\n            power_set :\n                    Only valid when power_override is True.\n                    A Boolean, True to set SFP to low power mode, False to set\n                    SFP to high power mode.\n        Returns:\n            A boolean, True if power-override and power_set are set successfully,\n            False if not\n        \"\"\"\n        if self.port_num < 53:\n            return False # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n            try:\n                power_override_bit = (1 << 0) if power_override else 0\n                power_set_bit      = (1 << 1) if power_set else (1 << 3)\n    \n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = (power_override_bit | power_set_bit)\n                else:\n                    buffer[0] = chr(power_override_bit | power_set_bit)\n                # Write to eeprom\n                with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd:\n                    fd.seek(QSFP_POWEROVERRIDE_OFFSET)\n                    fd.write(buffer[0])\n                    time.sleep(0.01)\n            except IOError as e:\n                print ('Error: unable to open file: ', str(e))\n                return False\n            return True\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        name = None\n        sfputil_helper = SfpUtilHelper()\n        sfputil_helper.read_porttab_mappings(\n            self.__get_path_to_port_config_file())\n        name = sfputil_helper.logical[self.index] or \"Unknown\"\n        return name\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        if self.port_num < 49: #Copper port, no sysfs\n            return False\n            \n        present_path = \"{}{}{}\".format(CPLD_I2C_PATH, '/module_present_', self.port_num)\n        val=self._api_helper.read_txt_file(present_path)\n        if val is not None:\n            return int(val, 10)==1\n        else:\n            return False\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return self.get_presence()\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return self.port_num\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return True\n"}, "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n SYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n         ", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=3 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=3 NUM_QSFP=6 PORT_START=49 PORT_END=54 NUM_COMPONENT=2 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"docker > /dev/null 2>&1\" SYSLED_FNODE=\"/sys/class/leds/diag/brightness\" SYSLED_MODES={ \"0\": \"STATUS_LED_COLOR_OFF\", \"1\": \"STATUS_LED_COLOR_GREEN\", \"2\": \"STATUS_LED_COLOR_AMBER\", \"5\": \"STATUS_LED_COLOR_GREEN_BLINK\" } class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(0, PORT_END): sfp=Sfp(index) self._sfp_list.append(sfp) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for fant_index in range(NUM_FAN_TRAY): fandrawer=FanDrawer(fant_index) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._api_helper.hwsku def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_serial_number(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def initizalize_system_led(self): return True def get_status_led(self): val=self._api_helper.read_txt_file(SYSLED_FNODE) return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\" def set_status_led(self, color): mode=None for key, val in SYSLED_MODES.items(): if val==color: mode=key break if mode is None: return False else: return self._api_helper.write_txt_file(SYSLED_FNODE, mode) ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 3\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 3\nNUM_QSFP = 6\nPORT_START = 49\nPORT_END = 54\nNUM_COMPONENT = 2\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nSYSLED_FNODE = \"/sys/class/leds/diag/brightness\"\nSYSLED_MODES = {\n    \"0\" : \"STATUS_LED_COLOR_OFF\",\n    \"1\" : \"STATUS_LED_COLOR_GREEN\",\n    \"2\" : \"STATUS_LED_COLOR_AMBER\",\n    \"5\" : \"STATUS_LED_COLOR_GREEN_BLINK\"\n}\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n\n        self.config_data = {}\n\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n\n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(0, PORT_END):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self.sfp_module_initialized = True\n\n    def __initialize_fan(self):\n        from sonic_platform.fan_drawer import FanDrawer\n        for fant_index in range(NUM_FAN_TRAY):\n            fandrawer = FanDrawer(fant_index)\n            self._fan_drawer_list.append(fandrawer)\n            self._fan_list.extend(fandrawer._fan_list)\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n\n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n\n        return self._api_helper.hwsku\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_serial_number(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n\n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n\n    def initizalize_system_led(self):\n        return True\n\n    def get_status_led(self):\n        val = self._api_helper.read_txt_file(SYSLED_FNODE)\n        return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\"\n\n    def set_status_led(self, color):\n        mode = None\n        for key, val in SYSLED_MODES.items():\n            if val == color:\n                mode = key\n                break\n        if mode is None:\n            return False\n        else:\n            return self._api_helper.write_txt_file(SYSLED_FNODE, mode)\n"}, "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 3, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()        \n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n        ", "add": 0, "remove": 16, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"3-0060\" } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"BIOS\", \"Basic Input/Output System\") ] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError ", "sourceWithComments": "#############################################################################\n# Accton\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"3-0060\"\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n\n]\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()        \n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)               \n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n\n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()           \n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n"}, "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, ", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, "], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r', errors='replace') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r', errors='replace') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-accton_as4630_54te-r0\"\n     HWSKU = \"Accton-AS4630-54TE\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLA", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as4630_54te-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}]}, "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE= \"/sys/class/leds/as5835_54x_led::diag/brightness\"\n \n SYSLED_MODES = {\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n     \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n     ", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os import sys try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper from.event import SfpEvent except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=5 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=4 NUM_QSFP=54 PORT_START=1 PORT_END=54 NUM_COMPONENT=4 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" SYSLED_FNODE=\"/sys/class/leds/as5835_54x_led::diag/brightness\" SYSLED_MODES={ \"0\": \"STATUS_LED_COLOR_OFF\", \"1\": \"STATUS_LED_COLOR_GREEN\", \"3\": \"STATUS_LED_COLOR_AMBER\" } class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(0, PORT_END): sfp=Sfp(index) self._sfp_list.append(sfp) self._sfpevent=SfpEvent(self._sfp_list) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for fant_index in range(NUM_FAN_TRAY): fandrawer=FanDrawer(fant_index) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._eeprom.get_product_name() def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_change_event(self, timeout=0): if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfpevent.get_sfp_event(timeout) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def initizalize_system_led(self): return True def get_status_led(self): val=self._api_helper.read_txt_file(SYSLED_FNODE) return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\" def set_status_led(self, color): mode=None for key, val in SYSLED_MODES.items(): if val==color: mode=key break if mode is None: return False else: return self._api_helper.write_txt_file(SYSLED_FNODE, mode) ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\nimport sys\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\n    from .event import SfpEvent\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 5\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 4\nNUM_QSFP = 54\nPORT_START = 1\nPORT_END = 54\nNUM_COMPONENT = 4\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\nSYSLED_FNODE= \"/sys/class/leds/as5835_54x_led::diag/brightness\"\n\nSYSLED_MODES = {\n    \"0\" : \"STATUS_LED_COLOR_OFF\",\n    \"1\" : \"STATUS_LED_COLOR_GREEN\",\n    \"3\" : \"STATUS_LED_COLOR_AMBER\"\n}\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n        \n        self.config_data = {}\n        \n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n    \n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(0, PORT_END):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self._sfpevent = SfpEvent(self._sfp_list)\n        self.sfp_module_initialized = True\n        \n    def __initialize_fan(self):\n       from sonic_platform.fan_drawer import FanDrawer\n       for fant_index in range(NUM_FAN_TRAY):\n           fandrawer = FanDrawer(fant_index)\n           self._fan_drawer_list.append(fandrawer)\n           self._fan_list.extend(fandrawer._fan_list)\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n    \n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n    \n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n    \n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return self._eeprom.get_product_name()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n    \n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n    \n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n        \n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n\n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_change_event(self, timeout=0):\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n        return self._sfpevent.get_sfp_event(timeout)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n        \n    def initizalize_system_led(self):\n        return True\n\n    def get_status_led(self):\n        val = self._api_helper.read_txt_file(SYSLED_FNODE)\n        return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\"\n\n    def set_status_led(self, color):\n        mode = None\n        for key, val in SYSLED_MODES.items():\n            if val == color:\n                mode = key\n                break\n        if mode is None:\n            return False\n        else:\n            return self._api_helper.write_txt_file(SYSLED_FNODE, mode)\n            \n"}, "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n-\n try:\n     from sonic_platform_base.component_base import ComponentBase\n     from .helper import APIHelper\n", "add": 0, "remove": 4, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()\n \n-\n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware version\n    ", "add": 0, "remove": 17, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"3-0060\", \"CPLD2\": \"3-0061\", \"CPLD3\": \"3-0062\", } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"CPLD2\", \"CPLD 2\"), (\"CPLD3\", \"CPLD 3\"), (\"BIOS\", \"Basic Input/Output System\") ] COMPONENT_DES_LIST=[\"CPLD\",\"Basic Input/Output System\"] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: print('Get exception when read bios') return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return 'N/A' def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return 'N/A' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is'0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"3-0060\",\n    \"CPLD2\": \"3-0061\",\n    \"CPLD3\": \"3-0062\",\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"CPLD2\", \"CPLD 2\"),\n   (\"CPLD3\", \"CPLD 3\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n   \n]\nCOMPONENT_DES_LIST = [\"CPLD\",\"Basic Input/Output System\"]\n\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            print('Get exception when read bios')\n        return None\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)\n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n        \n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n        #return \"testhwsku\"\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of\n        entPhysicalContainedIn is'0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device\n            or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return stat", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return stat"], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r', errors='replace') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r', errors='replace') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as5835_54x-r0\"\n     HWSKU = \"Accton-AS5835-54X\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n \n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess(self.HOST_CHK_CMD).returncode == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as5835_54x-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess(self.HOST_CHK_CMD).returncode == 0"]}], "source": "\n import os import time import sys from ctypes import create_string_buffer try: from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_I2C_PATH=\"/sys/bus/i2c/devices/\" class Sfp(SfpOptoeBase): \"\"\"Platform-specific Sfp class\"\"\" PORT_START=1 PORT_END=54 QSFP_PORT_START=49 PLATFORM_ROOT_PATH=\"/usr/share/sonic/device\" PMON_HWSKU_PATH=\"/usr/share/sonic/hwsku\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" PLATFORM=\"x86_64-accton_as5835_54x-r0\" HWSKU=\"Accton-AS5835-54X\" _cpld_mapping={ 0: \"3-0060\", 1: \"3-0061\", 2: \"3-0062\", } _port_to_i2c_mapping={ 1: 42, 2: 43, 3: 44, 4: 45, 5: 46, 6: 47, 7: 48, 8: 49, 9: 50, 10: 51, 11: 52, 12: 53, 13: 54, 14: 55, 15: 56, 16: 57, 17: 58, 18: 59, 19: 60, 20: 61, 21: 62, 22: 63, 23: 64, 24: 65, 25: 66, 26: 67, 27: 68, 28: 69, 29: 70, 30: 71, 31: 72, 32: 73, 33: 74, 34: 75, 35: 76, 36: 77, 37: 78, 38: 79, 39: 80, 40: 81, 41: 82, 42: 83, 43: 84, 44: 85, 45: 86, 46: 87, 47: 88, 48: 89, 49: 28, 50: 29, 51: 26, 52: 30, 53: 31, 54: 27, } def __init__(self, sfp_index=0): SfpOptoeBase.__init__(self) self._api_helper=APIHelper() self.index=sfp_index self.port_num=self.index +1 eeprom_path='/sys/bus/i2c/devices/{0}-0050/eeprom' self.port_to_eeprom_mapping={} for x in range(self.PORT_START, self.PORT_END +1): self.port_to_eeprom_mapping[x]=eeprom_path.format(self._port_to_i2c_mapping[x]) def get_eeprom_path(self): return self.port_to_eeprom_mapping[self.port_num] def __get_cpld_num(self, port_num): return 1 if(port_num < 39) else 2 def __is_host(self): return os.system(self.HOST_CHK_CMD)==0 def __get_path_to_port_config_file(self): platform_path=\"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM]) hwsku_path=\"/\".join([platform_path, self.HWSKU] ) if self.__is_host() else self.PMON_HWSKU_PATH return \"/\".join([hwsku_path, \"port_config.ini\"]) def __read_eeprom_specific_bytes(self, offset, num_bytes): sysfsfile_eeprom=None eeprom_raw=[] for i in range(0, num_bytes): eeprom_raw.append(\"0x00\") sysfs_sfp_i2c_client_eeprom_path=self.port_to_eeprom_mapping[self.port_num] try: sysfsfile_eeprom=open( sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0) sysfsfile_eeprom.seek(offset) raw=sysfsfile_eeprom.read(num_bytes) if sys.version_info[0] >=3: for n in range(0, num_bytes): eeprom_raw[n]=hex(raw[n])[2:].zfill(2) else: for n in range(0, num_bytes): eeprom_raw[n]=hex(ord(raw[n]))[2:].zfill(2) except Exception: pass finally: if sysfsfile_eeprom: sysfsfile_eeprom.close() return eeprom_raw def get_reset_status(self): \"\"\" Retrieves the reset status of SFP Returns: A Boolean, True if reset enabled, False if disabled \"\"\" if self.port_num <49: return False cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] reset_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_reset_', self.port_num) val=self._api_helper.read_txt_file(reset_path) if val is not None: return int(val, 10)==1 else: return False def get_rx_los(self): \"\"\" Retrieves the RX LOS(lost-of-signal) status of SFP Returns: A Boolean, True if SFP has RX LOS, False if not. Note: RX LOS status is latched until a call to get_rx_los or a reset. \"\"\" rx_los=False if self.port_num < 49: cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] rx_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_rx_los_', self.port_num) rx_los=self._api_helper.read_txt_file(rx_path) if int(rx_los, 10)==1: return[True] else: return[False] else: rx_los_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: rx_los_data=int(dom_channel_monitor_raw[0], 16) rx_los_list.append(rx_los_data & 0x01 !=0) rx_los_list.append(rx_los_data & 0x02 !=0) rx_los_list.append(rx_los_data & 0x04 !=0) rx_los_list.append(rx_los_data & 0x08 !=0) return rx_los_list else: return[False]*4 def get_tx_fault(self): \"\"\" Retrieves the TX fault status of SFP Returns: A list of boolean values, representing the TX fault status of each available channel, value is True if SFP channel has TX fault, False if not. E.g., for a tranceiver with four channels:[False, False, True, False] Note: TX fault status is lached until a call to get_tx_fault or a reset. \"\"\" tx_fault=False if self.port_num < 49: cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] tx_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_fault_', self.port_num) tx_fault=self._api_helper.read_txt_file(tx_path) if int(tx_fault, 10)==1: return[True] else: return[False] else: tx_fault_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: tx_fault_data=int(dom_channel_monitor_raw[0], 16) tx_fault_list.append(tx_fault_data & 0x01 !=0) tx_fault_list.append(tx_fault_data & 0x02 !=0) tx_fault_list.append(tx_fault_data & 0x04 !=0) tx_fault_list.append(tx_fault_data & 0x08 !=0) return tx_fault_list else: return[False]*4 def get_tx_disable(self): \"\"\" Retrieves the tx_disable status of this SFP Returns: A list of boolean values, representing the TX disable status of each available channel, value is True if SFP channel is TX disabled, False if not. E.g., for a tranceiver with four channels:[False, False, True, False] \"\"\" if self.port_num < 49: tx_disable=False cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] tx_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_disable_', self.port_num) tx_disable=self._api_helper.read_txt_file(tx_path) if int(tx_disable, 10)==0: return[False] else: return[True] else: tx_disable_list=[] sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) tx_disable_list.append( 'On'==dom_control_data['data']['TX1Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX2Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX3Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX4Disable']['value']) return tx_disable_list else: return[False]*4 def get_tx_disable_channel(self): \"\"\" Retrieves the TX disabled channels in this SFP Returns: A hex of 4 bits(bit 0 to bit 3 as channel 0 to channel 3) to represent TX channels which have been disabled in this SFP. As an example, a returned value of 0x5 indicates that channel 0 and channel 2 have been disabled. \"\"\" tx_disable_list=self.get_tx_disable() if tx_disable_list is None: return 0 tx_disabled=0 for i in range(len(tx_disable_list)): if tx_disable_list[i]: tx_disabled |=1 << i return tx_disabled def get_lpmode(self): \"\"\" Retrieves the lpmode(low power mode) status of this SFP Returns: A Boolean, True if lpmode is enabled, False if disabled \"\"\" if self.port_num < 49: return False else: power_set=self.get_power_set() power_override=self.get_power_override() return power_set and power_override def get_power_set(self): if self.port_num < 49: return False else: power_set=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) power_set=( 'On'==dom_control_data['data']['PowerSet']['value']) return power_set def get_power_override(self): \"\"\" Retrieves the power-override status of this SFP Returns: A Boolean, True if power-override is enabled, False if disabled \"\"\" if self.port_num < 49: return False else: power_override=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) power_override=( 'On'==dom_control_data['data']['PowerOverride']['value']) return power_override def reset(self): \"\"\" Reset SFP and return all user module settings to their default srate. Returns: A boolean, True if successful, False if not \"\"\" if self.port_num <49: return False cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] reset_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_reset_', self.port_num) ret=self._api_helper.write_txt_file(reset_path, 1) if ret is not True: return ret time.sleep(0.01) ret=self._api_helper.write_txt_file(reset_path, 0) time.sleep(0.2) return ret def tx_disable(self, tx_disable): \"\"\" Disable SFP TX for all channels Args: tx_disable: A Boolean, True to enable tx_disable mode, False to disable tx_disable mode. Returns: A boolean, True if tx_disable is set successfully, False if not \"\"\" if self.port_num < 49: cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] tx_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_disable_', self.port_num) ret=self._api_helper.write_txt_file(tx_path, 1 if tx_disable else 0) if ret is not None: time.sleep(0.01) return ret else: return False else: if not self.get_presence(): return False sysfsfile_eeprom=None try: tx_disable_ctl=0xf if tx_disable else 0x0 buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=tx_disable_ctl else: buffer[0]=chr(tx_disable_ctl) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ',str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def tx_disable_channel(self, channel, disable): \"\"\" Sets the tx_disable for specified SFP channels Args: channel: A hex of 4 bits(bit 0 to bit 3) which represent channel 0 to 3, e.g. 0x5 for channel 0 and channel 2. disable: A boolean, True to disable TX channels specified in channel, False to enable Returns: A boolean, True if successful, False if not \"\"\" if self.port_num < 49: return False else: if not self.get_presence(): return False sysfsfile_eeprom=None try: channel_state=self.get_tx_disable_channel() for i in range(4): channel_mask=(1 << i) if not(channel & channel_mask): continue if disable: channel_state |=channel_mask else: channel_state &=~channel_mask buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=channel_state else: buffer[0]=chr(channel_state) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ', str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def set_lpmode(self, lpmode): \"\"\" Sets the lpmode(low power mode) of SFP Args: lpmode: A Boolean, True to enable lpmode, False to disable it Note : lpmode can be overridden by set_power_override Returns: A boolean, True if lpmode is set successfully, False if not \"\"\" if self.port_num < 49: return False else: if lpmode: self.set_power_override(True, True) else: self.set_power_override(False, False) return True def set_power_override(self, power_override, power_set): \"\"\" Sets SFP power level using power_override and power_set Args: power_override: A Boolean, True to override set_lpmode and use power_set to control SFP power, False to disable SFP power control through power_override/power_set and use set_lpmode to control SFP power. power_set: Only valid when power_override is True. A Boolean, True to set SFP to low power mode, False to set SFP to high power mode. Returns: A boolean, True if power-override and power_set are set successfully, False if not \"\"\" if self.port_num < 49: return False else: if not self.get_presence(): return False try: power_override_bit=(1 << 0) if power_override else 0 power_set_bit =(1 << 1) if power_set else(1 << 3) buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=(power_override_bit | power_set_bit) else: buffer[0]=chr(power_override_bit | power_set_bit) with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd: fd.seek(QSFP_POWEROVERRIDE_OFFSET) fd.write(buffer[0]) time.sleep(0.01) except Exception: print('Error: unable to open file: ', str(e)) return False return True def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" sfputil_helper=SfpUtilHelper() sfputil_helper.read_porttab_mappings( self.__get_path_to_port_config_file()) name=sfputil_helper.logical[self.index] or \"Unknown\" return name def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" cpld_i=self.__get_cpld_num(self.port_num) cpld_path=self._cpld_mapping[cpld_i] present_path=\"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_present_', self.port_num) val=self._api_helper.read_txt_file(present_path) if val is not None: return int(val, 10)==1 else: return False def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return self.get_presence() def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return self.port_num def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return True ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Sfp contains an implementation of SONiC Platform Base API and\n# provides the sfp device status which are available in the platform\n#\n#############################################################################\n\nimport os\nimport time\nimport sys\n\nfrom ctypes import create_string_buffer\n\ntry:\n    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_I2C_PATH = \"/sys/bus/i2c/devices/\"\n\nclass Sfp(SfpOptoeBase):\n    \"\"\"Platform-specific Sfp class\"\"\"\n\n    # Port number\n    PORT_START = 1\n    PORT_END = 54\n    QSFP_PORT_START = 49\n\n    # Path to sysfs\n    PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n    PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n        \n    PLATFORM = \"x86_64-accton_as5835_54x-r0\"\n    HWSKU = \"Accton-AS5835-54X\"\n\n    _cpld_mapping = {\n        0:  \"3-0060\",\n        1:  \"3-0061\",\n        2:  \"3-0062\",\n    }\n    _port_to_i2c_mapping = {\n        1:  42,\n        2:  43,\n        3:  44,\n        4:  45,\n        5:  46,\n        6:  47,\n        7:  48,\n        8:  49,\n        9:  50,\n        10: 51,\n        11: 52,\n        12: 53,\n        13: 54,\n        14: 55,\n        15: 56,\n        16: 57,\n        17: 58,\n        18: 59,\n        19: 60,\n        20: 61,\n        21: 62,\n        22: 63,\n        23: 64,\n        24: 65,\n        25: 66,\n        26: 67,\n        27: 68,\n        28: 69,\n        29: 70,\n        30: 71,\n        31: 72,\n        32: 73,\n        33: 74,\n        34: 75,\n        35: 76,\n        36: 77,\n        37: 78,\n        38: 79,\n        39: 80,\n        40: 81,\n        41: 82,\n        42: 83,\n        43: 84,\n        44: 85,\n        45: 86,\n        46: 87,\n        47: 88,\n        48: 89,\n        49: 28,  # QSFP49\n        50: 29,  # QSFP50\n        51: 26,  # QSFP51\n        52: 30,  # QSFP52\n        53: 31,  # QSFP53\n        54: 27,  # QSFP54\n        \n    }\n\n    def __init__(self, sfp_index=0):\n        SfpOptoeBase.__init__(self)\n        self._api_helper=APIHelper()\n        # Init index\n        self.index = sfp_index\n        self.port_num = self.index + 1\n\n        # Init eeprom path\n        eeprom_path = '/sys/bus/i2c/devices/{0}-0050/eeprom'\n        self.port_to_eeprom_mapping = {}\n        for x in range(self.PORT_START, self.PORT_END + 1):\n            self.port_to_eeprom_mapping[x] = eeprom_path.format(self._port_to_i2c_mapping[x])\n\n    def get_eeprom_path(self):\n        return self.port_to_eeprom_mapping[self.port_num]\n        \n    # For cage 1~38 are at cpld2, others are at cpld3.\n    def __get_cpld_num(self, port_num):\n        return 1 if (port_num < 39) else 2\n\n\n    def __is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def __get_path_to_port_config_file(self):\n        platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n        hwsku_path = \"/\".join([platform_path, self.HWSKU]\n                              ) if self.__is_host() else self.PMON_HWSKU_PATH\n        return \"/\".join([hwsku_path, \"port_config.ini\"])\n\n    def __read_eeprom_specific_bytes(self, offset, num_bytes):\n        sysfsfile_eeprom = None\n        eeprom_raw = []\n        for i in range(0, num_bytes):\n            eeprom_raw.append(\"0x00\")\n\n        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]\n        try:\n            sysfsfile_eeprom = open(\n                sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0)\n            sysfsfile_eeprom.seek(offset)\n            raw = sysfsfile_eeprom.read(num_bytes)\n            if sys.version_info[0] >= 3:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(raw[n])[2:].zfill(2)\n            else:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(ord(raw[n]))[2:].zfill(2)\n        except Exception:\n            pass\n        finally:\n            if sysfsfile_eeprom:\n                sysfsfile_eeprom.close()\n\n        return eeprom_raw\n\n    def get_reset_status(self):\n        \"\"\"\n        Retrieves the reset status of SFP\n        Returns:\n            A Boolean, True if reset enabled, False if disabled\n        \"\"\"\n        if self.port_num <49:\n            return False # SPF port doesn't support this feature\n          \n        cpld_i = self.__get_cpld_num(self.port_num)\n        cpld_path = self._cpld_mapping[cpld_i]        \n        reset_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_reset_', self.port_num)\n        val=self._api_helper.read_txt_file(reset_path)\n        if val is not None:\n            return int(val, 10)==1\n        else:\n            return False\n\n    def get_rx_los(self):\n        \"\"\"\n        Retrieves the RX LOS (lost-of-signal) status of SFP\n        Returns:\n            A Boolean, True if SFP has RX LOS, False if not.\n            Note : RX LOS status is latched until a call to get_rx_los or a reset.\n        \"\"\"\n        rx_los = False\n        if self.port_num < 49:\n            cpld_i = self.__get_cpld_num(self.port_num)\n            cpld_path = self._cpld_mapping[cpld_i]        \n            rx_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_rx_los_', self.port_num)\n\n            rx_los=self._api_helper.read_txt_file(rx_path)\n            if int(rx_los, 10) == 1:\n                return [True]\n            else:\n                return [False]\n            #status_control_raw = self.__read_eeprom_specific_bytes(\n            #    SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            #if status_control_raw:\n            #    data = int(status_control_raw[0], 16)\n            #    rx_los = (sffbase().test_bit(data, 1) != 0)\n            \n        else:\n            rx_los_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None\n            if dom_channel_monitor_raw is not None:\n                rx_los_data = int(dom_channel_monitor_raw[0], 16)\n                rx_los_list.append(rx_los_data & 0x01 != 0)\n                rx_los_list.append(rx_los_data & 0x02 != 0)\n                rx_los_list.append(rx_los_data & 0x04 != 0)\n                rx_los_list.append(rx_los_data & 0x08 != 0)\n                return rx_los_list\n            else:\n                return [False]*4\n\n    def get_tx_fault(self):\n        \"\"\"\n        Retrieves the TX fault status of SFP\n        Returns:\n            A list of boolean values, representing the TX fault status\n            of each available channel, value is True if SFP channel\n            has TX fault, False if not.\n            E.g., for a tranceiver with four channels: [False, False, True, False]\n            Note : TX fault status is lached until a call to get_tx_fault or a reset.\n        \"\"\"\n        tx_fault = False\n        if self.port_num < 49:\n            cpld_i = self.__get_cpld_num(self.port_num)\n            cpld_path = self._cpld_mapping[cpld_i]        \n            tx_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_fault_', self.port_num)\n\n            tx_fault=self._api_helper.read_txt_file(tx_path)\n            if int(tx_fault, 10) == 1:\n                return [True]\n            else:\n                return [False]\n            #status_control_raw = self.__read_eeprom_specific_bytes(\n            #    SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            #if status_control_raw:\n            #    data = int(status_control_raw[0], 16)\n            #    tx_fault = (sffbase().test_bit(data, 2) != 0)\n        else:\n            tx_fault_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None\n            if dom_channel_monitor_raw is not None:\n                tx_fault_data = int(dom_channel_monitor_raw[0], 16)\n                tx_fault_list.append(tx_fault_data & 0x01 != 0)\n                tx_fault_list.append(tx_fault_data & 0x02 != 0)\n                tx_fault_list.append(tx_fault_data & 0x04 != 0)\n                tx_fault_list.append(tx_fault_data & 0x08 != 0)\n                return tx_fault_list\n            else:\n                return [False]*4\n\n\n    def get_tx_disable(self):\n        \"\"\"\n        Retrieves the tx_disable status of this SFP\n        Returns:\n            A list of boolean values, representing the TX disable status\n            of each available channel, value is True if SFP channel\n            is TX disabled, False if not.\n            E.g., for a tranceiver with four channels: [False, False, True, False]\n        \"\"\"\n        if self.port_num < 49: \n            tx_disable = False\n            \n            cpld_i = self.__get_cpld_num(self.port_num)\n            cpld_path = self._cpld_mapping[cpld_i]        \n            tx_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_disable_', self.port_num)\n\n            tx_disable=self._api_helper.read_txt_file(tx_path)\n            \n            #status_control_raw = self.__read_eeprom_specific_bytes(\n            #    SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            #if status_control_raw:\n            #    data = int(status_control_raw[0], 16)\n            #    tx_disable_hard = (sffbase().test_bit(\n            #        data, SFP_TX_DISABLE_HARD_BIT) != 0)\n            #    tx_disable_soft = (sffbase().test_bit(\n            #        data, SFP_TX_DISABLE_SOFT_BIT) != 0)\n            #    tx_disable = tx_disable_hard | tx_disable_soft\n            if int(tx_disable, 10)==0:\n                return [False]\n            else:\n                return [True]\n\n        else:\n            tx_disable_list = []\n    \n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n    \n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX1Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX2Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX3Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX4Disable']['value'])\n                return tx_disable_list\n            else:\n                return [False]*4\n\n    def get_tx_disable_channel(self):\n        \"\"\"\n        Retrieves the TX disabled channels in this SFP\n        Returns:\n            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent\n            TX channels which have been disabled in this SFP.\n            As an example, a returned value of 0x5 indicates that channel 0\n            and channel 2 have been disabled.\n        \"\"\"\n        tx_disable_list = self.get_tx_disable()\n        if tx_disable_list is None:\n            return 0\n        tx_disabled = 0\n        for i in range(len(tx_disable_list)):\n            if tx_disable_list[i]:\n                tx_disabled |= 1 << i\n        return tx_disabled\n\n    def get_lpmode(self):\n        \"\"\"\n        Retrieves the lpmode (low power mode) status of this SFP\n        Returns:\n            A Boolean, True if lpmode is enabled, False if disabled\n        \"\"\"\n        if self.port_num < 49: \n            # SFP doesn't support this feature\n            return False\n        else:\n            power_set=self.get_power_set()\n            power_override = self.get_power_override()\n            return power_set and power_override\n       \n    \n    def get_power_set(self):\n        \n        if self.port_num < 49: \n            # SFP doesn't support this feature\n            return False\n        else:\n            power_set = False\n            \n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n    \n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n                power_set = (\n                    'On' == dom_control_data['data']['PowerSet']['value'])\n    \n            return power_set\n\n    def get_power_override(self):\n        \"\"\"\n        Retrieves the power-override status of this SFP\n        Returns:\n            A Boolean, True if power-override is enabled, False if disabled\n        \"\"\"\n        if self.port_num < 49:\n            return False # SFP doesn't support this feature\n        else:\n            power_override = False\n    \n            \n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n    \n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n                power_override = (\n                    'On' == dom_control_data['data']['PowerOverride']['value'])\n    \n            return power_override\n\n    def reset(self):\n        \"\"\"\n        Reset SFP and return all user module settings to their default srate.\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        if self.port_num <49:\n            return False # SFP doesn't support this feature\n          \n        cpld_i = self.__get_cpld_num(self.port_num)\n        cpld_path = self._cpld_mapping[cpld_i]        \n        reset_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_reset_', self.port_num)      \n        ret = self._api_helper.write_txt_file(reset_path, 1)\n\n        if ret is not True:\n            return ret\n\n        time.sleep(0.01)\n        ret = self._api_helper.write_txt_file(reset_path, 0)\n        time.sleep(0.2)\n        \n        return ret\n      \n    def tx_disable(self, tx_disable):\n        \"\"\"\n        Disable SFP TX for all channels\n        Args:\n            tx_disable : A Boolean, True to enable tx_disable mode, False to disable\n                         tx_disable mode.\n        Returns:\n            A boolean, True if tx_disable is set successfully, False if not\n        \"\"\"\n        if self.port_num < 49:\n            cpld_i = self.__get_cpld_num(self.port_num)\n            cpld_path = self._cpld_mapping[cpld_i]        \n            tx_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_tx_disable_', self.port_num)      \n            ret = self._api_helper.write_txt_file(tx_path,  1 if tx_disable else 0)\n\n            if ret is not None:\n                time.sleep(0.01)\n                return ret\n            else:\n                return False\n        \n        else:\n            if not self.get_presence():\n                return False\n            sysfsfile_eeprom = None\n            try:\n                tx_disable_ctl = 0xf if tx_disable else 0x0\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = tx_disable_ctl\n                else:\n                    buffer[0] = chr(tx_disable_ctl)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print ('Error: unable to open file: ',str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n        return True\n\n    def tx_disable_channel(self, channel, disable):\n        \"\"\"\n        Sets the tx_disable for specified SFP channels\n        Args:\n            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,\n                      e.g. 0x5 for channel 0 and channel 2.\n            disable : A boolean, True to disable TX channels specified in channel,\n                      False to enable\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        \n        if self.port_num < 49:\n            return False # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n\n            sysfsfile_eeprom = None\n            try:\n                channel_state = self.get_tx_disable_channel()\n\n                for i in range(4):\n                    channel_mask = (1 << i)\n                    if not (channel & channel_mask):\n                        continue\n\n                    if disable:\n                        channel_state |= channel_mask\n                    else:\n                        channel_state &= ~channel_mask\n\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = channel_state\n                else:\n                    buffer[0] = chr(channel_state)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print ('Error: unable to open file: ', str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n            return True\n\n    def set_lpmode(self, lpmode):\n        \"\"\"\n        Sets the lpmode (low power mode) of SFP\n        Args:\n            lpmode: A Boolean, True to enable lpmode, False to disable it\n            Note  : lpmode can be overridden by set_power_override\n        Returns:\n            A boolean, True if lpmode is set successfully, False if not\n        \"\"\"\n        if self.port_num < 49:\n            return False # SFP doesn't support this feature\n        else:\n            if lpmode:\n                self.set_power_override(True, True)\n            else:\n                self.set_power_override(False, False)\n    \n            return True\n       \n    def set_power_override(self, power_override, power_set):\n        \"\"\"\n        Sets SFP power level using power_override and power_set\n        Args:\n            power_override :\n                    A Boolean, True to override set_lpmode and use power_set\n                    to control SFP power, False to disable SFP power control\n                    through power_override/power_set and use set_lpmode\n                    to control SFP power.\n            power_set :\n                    Only valid when power_override is True.\n                    A Boolean, True to set SFP to low power mode, False to set\n                    SFP to high power mode.\n        Returns:\n            A boolean, True if power-override and power_set are set successfully,\n            False if not\n        \"\"\"\n        if self.port_num < 49:\n            return False # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n            try:\n                power_override_bit = (1 << 0) if power_override else 0\n                power_set_bit      = (1 << 1) if power_set else (1 << 3)\n    \n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = (power_override_bit | power_set_bit)\n                else:\n                    buffer[0] = chr(power_override_bit | power_set_bit)\n                # Write to eeprom\n                with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd:\n                    fd.seek(QSFP_POWEROVERRIDE_OFFSET)\n                    fd.write(buffer[0])\n                    time.sleep(0.01)\n            except Exception:\n                print ('Error: unable to open file: ', str(e))\n                return False\n            return True\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        sfputil_helper = SfpUtilHelper()\n        sfputil_helper.read_porttab_mappings(\n            self.__get_path_to_port_config_file())\n        name = sfputil_helper.logical[self.index] or \"Unknown\"\n        return name\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        cpld_i = self.__get_cpld_num(self.port_num)\n        cpld_path = self._cpld_mapping[cpld_i]          \n        present_path = \"{}{}{}{}\".format(CPLD_I2C_PATH, cpld_path, '/module_present_', self.port_num)\n        val=self._api_helper.read_txt_file(present_path)\n        if val is not None:\n            return int(val, 10)==1\n        else:\n            return False\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return self.get_presence()\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return self.port_num\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return True\n"}, "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n #\n #############################################################################\n try:\n-    import sys\n-    import re\n-    import os\n     import subprocess\n-    import json\n-    import syslog\n     from sonic_platform_base.chassis_base import ChassisBase\n     from sonic_py_common.logger import Logger\n     from sonic_platform.fan import Fan\n", "add": 0, "remove": 5, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py", "badparts": ["    import sys", "    import re", "    import json", "    import syslog"], "goodparts": []}, {"diff": "\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n COMPONENT_NAME_LIST = [\"BIOS\"]\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         logger.log_info(\"Chassis loaded successfully\")\n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path):\n ", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n try: import sys import re import os import subprocess import json import syslog from sonic_platform_base.chassis_base import ChassisBase from sonic_py_common.logger import Logger from sonic_platform.fan import Fan from sonic_platform.psu import Psu from sonic_platform.component import Component from sonic_platform.thermal import Thermal from sonic_platform.sfp import Sfp from sonic_platform.eeprom import Tlv except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=5 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=4 NUM_SFP=54 SFP_PORT_START=0 QSFP_PORT_START=48 SFP_PORT_END=47 QSFP_PORT_END=53 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" COMPONENT_NAME_LIST=[\"BIOS\"] HOST_CHK_CMD=\"docker > /dev/null 2>&1\" class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): super(Chassis, self).__init__() for fantray_index in range(0, NUM_FAN_TRAY): for fan_index in range(0, NUM_FAN): fan=Fan(fantray_index, fan_index) self._fan_list.append(fan) for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) self.PORT_START=SFP_PORT_START self.QSFP_PORT_START=QSFP_PORT_START self.PORT_END=QSFP_PORT_END for index in range(0, NUM_SFP): if index in range(self.QSFP_PORT_START, self.QSPORT_END +1): sfp_module=Sfp(index, 'QSFP') else: sfp_module=Sfp(index, 'SFP') self._sfp_list.append(sfp_module) self._component_name_list=COMPONENT_NAME_LIST self._watchdog=Watchdog() self._eeprom=Tlv() logger.log_info(\"Chassis loaded successfully\") def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_firmware_version(self, component_name): \"\"\" Retrieves platform-specific hardware/firmware versions for chassis componenets such as BIOS, CPLD, FPGA, etc. Args: type: A string, component name Returns: A string containing platform-specific component versions \"\"\" self.component=Component(component_name) if component_name not in self._component_name_list: return None return self.component.get_firmware_version() def install_component_firmware(self, component_name, image_path): \"\"\" Install firmware to module Args: type: A string, component name. image_path: A string, path to firmware image. Returns: A boolean, True if install successfully, False if not \"\"\" self.component=Component(component_name) if component_name not in self._component_name_list: return False return self.component.upgrade_firmware(image_path) def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" description='None' reboot_cause=self.REBOOT_CAUSE_HARDWARE_OTHER reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) if self.__is_host( ) else PMON_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE prev_reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +PREV_REBOOT_CAUSE_FILE) if self.__is_host( ) else PMON_REBOOT_CAUSE_PATH +PREV_REBOOT_CAUSE_FILE sw_reboot_cause=self.__read_txt_file( reboot_cause_path) or \"Unknown\" prev_sw_reboot_cause=self.__read_txt_file( prev_reboot_cause_path) or \"Unknown\" if sw_reboot_cause !=\"Unknown\": reboot_cause=self.REBOOT_CAUSE_NON_HARDWARE description=sw_reboot_cause else: reboot_cause=self.REBOOT_CAUSE_HARDWARE_OTHER description='Unknown reason' return(reboot_cause, description) ", "sourceWithComments": "#############################################################################\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\ntry:\n    import sys\n    import re\n    import os\n    import subprocess\n    import json\n    import syslog\n    from sonic_platform_base.chassis_base import ChassisBase\n    from sonic_py_common.logger import Logger\n    from sonic_platform.fan import Fan\n    from sonic_platform.psu import Psu\n    from sonic_platform.component import Component\n    from sonic_platform.thermal import Thermal\n    from sonic_platform.sfp import Sfp\n    from sonic_platform.eeprom import Tlv\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 5\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 4\nNUM_SFP = 54\nSFP_PORT_START = 0\nQSFP_PORT_START = 48\nSFP_PORT_END = 47\nQSFP_PORT_END = 53\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nCOMPONENT_NAME_LIST = [\"BIOS\"]\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        super(Chassis, self).__init__()\n\n        for fantray_index in range(0, NUM_FAN_TRAY):\n            for fan_index in range(0, NUM_FAN):\n                fan = Fan(fantray_index, fan_index)\n                self._fan_list.append(fan)\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n\n        self.PORT_START = SFP_PORT_START\n        self.QSFP_PORT_START = QSFP_PORT_START\n        self.PORT_END = QSFP_PORT_END\n        for index in range(0, NUM_SFP):\n            if index in range(self.QSFP_PORT_START, self.QSPORT_END + 1):\n                sfp_module = Sfp(index, 'QSFP')\n            else:\n                sfp_module = Sfp(index, 'SFP')\n            self._sfp_list.append(sfp_module)\n        self._component_name_list = COMPONENT_NAME_LIST\n        self._watchdog = Watchdog()\n        self._eeprom = Tlv()\n        logger.log_info(\"Chassis loaded successfully\")\n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_firmware_version(self, component_name):\n        \"\"\"\n        Retrieves platform-specific hardware/firmware versions for chassis\n        componenets such as BIOS, CPLD, FPGA, etc.\n        Args:\n            type: A string, component name\n\n        Returns:\n            A string containing platform-specific component versions\n        \"\"\"\n        self.component = Component(component_name)\n        if component_name not in self._component_name_list:\n            return None\n        return self.component.get_firmware_version()\n\n    def install_component_firmware(self, component_name, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            type: A string, component name.\n            image_path: A string, path to firmware image.\n\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        self.component = Component(component_name)\n        if component_name not in self._component_name_list:\n            return False\n        return self.component.upgrade_firmware(image_path)\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        description = 'None'\n        reboot_cause = self.REBOOT_CAUSE_HARDWARE_OTHER\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE) if self.__is_host(\n        ) else PMON_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE\n        prev_reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + PREV_REBOOT_CAUSE_FILE) if self.__is_host(\n        ) else PMON_REBOOT_CAUSE_PATH + PREV_REBOOT_CAUSE_FILE\n        sw_reboot_cause = self.__read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n        prev_sw_reboot_cause = self.__read_txt_file(\n            prev_reboot_cause_path) or \"Unknown\"\n\n        if sw_reboot_cause != \"Unknown\":\n            reboot_cause = self.REBOOT_CAUSE_NON_HARDWARE\n            description = sw_reboot_cause\n        else:\n            reboot_cause = self.REBOOT_CAUSE_HARDWARE_OTHER\n            description = 'Unknown reason'\n\n        return (reboot_cause, description)\n"}, "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py": {"changes": [{"diff": "\n # provides the components firmware management function\n #############################################################################\n \n-import json\n import os.path\n-import shutil\n-import shlex\n import subprocess\n \n try:\n", "add": 0, "remove": 3, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py", "badparts": ["import json", "import shutil", "import shlex"], "goodparts": []}, {"diff": "\n     def __run_command(self, command):\n         # Run bash command and print output to stdout\n         try:\n-            process = subprocess.Popen(\n-                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n+            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n             while True:\n                 output = process.stdout.readline()\n                 if output == '' and process.poll()", "add": 1, "remove": 2, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/component.py", "badparts": ["            process = subprocess.Popen(", "                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)"], "goodparts": ["            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)"]}], "source": "\n import json import os.path import shutil import shlex import subprocess try: from sonic_platform_base.device_base import DeviceBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" class Component(DeviceBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_name): DeviceBase.__init__(self) self.name=component_name.upper() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() return fw_version def upgrade_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" if not os.path.isfile(image_path): return False if self.name==\"BIOS\": print(\"Not supported\") return False return self.__run_command(install_command) ", "sourceWithComments": "#############################################################################\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#############################################################################\n\nimport json\nimport os.path\nimport shutil\nimport shlex\nimport subprocess\n\ntry:\n    from sonic_platform_base.device_base import DeviceBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\n\n\nclass Component(DeviceBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_name):\n        DeviceBase.__init__(self)\n        self.name = component_name.upper()\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n\n        return fw_version\n\n    def upgrade_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        if not os.path.isfile(image_path):\n            return False\n\n        if self.name == \"BIOS\":\n            print(\"Not supported\")\n            return False\n\n        return self.__run_command(install_command)\n"}, "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n # provides the sfp device status which are available in the platform\n #############################################################################\n try:\n-    import os\n     import time\n     import subprocess\n-    import syslog\n     from ctypes import create_string_buffer\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom\n", "add": 0, "remove": 2, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py", "badparts": ["    import syslog"], "goodparts": []}, {"diff": "\n \n     PLATFORM_ROOT_PATH = '/usr/share/sonic/device'\n     PMON_HWSKU_PATH = '/usr/share/sonic/hwsku'\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-accton_as7116_54x-r0\"\n     HWSKU = \"Accton-AS7116-54X-R0\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         return \"\"\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, s", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7116_54x-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}]}, "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n     \n     \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_path)", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=6 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=4 PORT_END=54 NUM_COMPONENT=4 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"docker > /dev/null 2>&1\" class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(0, PORT_END): sfp=Sfp(index) self._sfp_list.append(sfp) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan import Fan for fant_index in range(0, NUM_FAN_TRAY): for fan_index in range(0, NUM_FAN): fan=Fan(fant_index, fan_index) self._fan_list.append(fan) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._api_helper.hwsku def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_serial_number(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 6\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 4\nPORT_END = 54\nNUM_COMPONENT = 4\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n        \n        self.config_data = {}\n        \n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n    \n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(0, PORT_END):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self.sfp_module_initialized = True\n        \n    def __initialize_fan(self):\n        from sonic_platform.fan import Fan\n        for fant_index in range(0, NUM_FAN_TRAY):\n            for fan_index in range(0, NUM_FAN):\n                fan = Fan(fant_index, fan_index)\n                self._fan_list.append(fan)\n                \n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n    \n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n    \n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n    \n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n    \n    \n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        \n        return self._api_helper.hwsku\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n    \n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n    \n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_serial_number(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()   \n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        \n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n         \n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n"}, "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 2, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware versi", "add": 0, "remove": 16, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"4-0060\", \"CPLD2\": \"5-0062\", \"CPLD3\": \"6-0064\", } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"CPLD2\", \"CPLD 2\"), (\"CPLD3\", \"CPLD 3\"), (\"BIOS\", \"Basic Input/Output System\") ] COMPONENT_DES_LIST=[\"CPLD\",\"Basic Input/Output System\"] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"4-0060\",\n    \"CPLD2\": \"5-0062\",\n    \"CPLD3\": \"6-0064\",\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"CPLD2\", \"CPLD 2\"),\n   (\"CPLD3\", \"CPLD 3\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n   \n]\nCOMPONENT_DES_LIST = [\"CPLD\",\"Basic Input/Output System\"]\n\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n   \n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)\n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n        \n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n        #return \"testhwsku\"\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n"}, "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        retu", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        retu"], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n         \n     PLATFORM = \"x86_64-accton_as7312_54x-r0\"\n     HWSKU = \"Accton-AS7312-54X\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         return True\n     \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PAT", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7312_54x-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}]}, "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE= \"/sys/class/leds/accton_as7326_56x_led::diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n         self._watchdog = Watchdog()\n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file_p", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os import sys try: from sonic_platform_base.chassis_base import ChassisBase from.event import SfpEvent from sonic_py_common import device_info except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=6 NUM_PSU=2 NUM_THERMAL=4 NUM_PORT=58 NUM_COMPONENT=4 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" SYSLED_FNODE=\"/sys/class/leds/accton_as7326_56x_led::diag/brightness\" SYSLED_MODES={ \"0\": \"STATUS_LED_COLOR_OFF\", \"1\": \"STATUS_LED_COLOR_GREEN\", \"3\": \"STATUS_LED_COLOR_RED\", \"5\": \"STATUS_LED_COLOR_GREEN_BLINK\" } class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self.config_data={} (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(NUM_PORT): sfp=Sfp(index) self._sfp_list.append(sfp) self._sfpevent=SfpEvent(self._sfp_list) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for fant_index in range(NUM_FAN_TRAY): fandrawer=FanDrawer(fant_index) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: return fd.read().strip() except IOError: pass return None def __write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except Exception: return False return True def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._eeprom.get_product_name() def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" description='None' reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) if self.__is_host( ) else(PMON_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) prev_reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +PREV_REBOOT_CAUSE_FILE) if self.__is_host( ) else(PMON_REBOOT_CAUSE_PATH +PREV_REBOOT_CAUSE_FILE) sw_reboot_cause =self.__read_txt_file(reboot_cause_path) or \"Unknown\" prev_sw_reboot_cause=self.__read_txt_file(prev_reboot_cause_path) or \"Unknown\" if sw_reboot_cause !=\"Unknown\": reboot_cause=self.REBOOT_CAUSE_NON_HARDWARE description=sw_reboot_cause elif prev_reboot_cause_path !=\"Unknown\": reboot_cause=self.REBOOT_CAUSE_NON_HARDWARE description=prev_sw_reboot_cause return(reboot_cause, description) def get_change_event(self, timeout=0): if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfpevent.get_sfp_event(timeout) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def initizalize_system_led(self): return True def get_status_led(self): val=self.__read_txt_file(SYSLED_FNODE) return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\" def set_status_led(self, color): mode=None for key, val in SYSLED_MODES.items(): if val==color: mode=key break if mode is None: return False else: return self.__write_txt_file(SYSLED_FNODE, mode) ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\nimport sys\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .event import SfpEvent\n    from sonic_py_common import device_info\n\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 6\nNUM_PSU = 2\nNUM_THERMAL = 4\nNUM_PORT = 58\nNUM_COMPONENT = 4\n\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\nSYSLED_FNODE= \"/sys/class/leds/accton_as7326_56x_led::diag/brightness\"\nSYSLED_MODES = {\n    \"0\" : \"STATUS_LED_COLOR_OFF\",\n    \"1\" : \"STATUS_LED_COLOR_GREEN\",\n    \"3\" : \"STATUS_LED_COLOR_RED\",\n    \"5\" : \"STATUS_LED_COLOR_GREEN_BLINK\"\n}\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self.config_data = {}\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n\n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(NUM_PORT):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self._sfpevent = SfpEvent(self._sfp_list)\n        self.sfp_module_initialized = True\n\n    def __initialize_fan(self):\n        from sonic_platform.fan_drawer import FanDrawer\n        for fant_index in range(NUM_FAN_TRAY):\n            fandrawer = FanDrawer(fant_index)\n            self._fan_drawer_list.append(fandrawer)\n            self._fan_list.extend(fandrawer._fan_list)\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        self._watchdog = Watchdog()\n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                return fd.read().strip()\n        except IOError:\n            pass\n        return None\n\n    def __write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except Exception:\n            return False\n        return True\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return self._eeprom.get_product_name()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        description = 'None'\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE) if self.__is_host(\n        ) else (PMON_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        prev_reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + PREV_REBOOT_CAUSE_FILE) if self.__is_host(\n        ) else (PMON_REBOOT_CAUSE_PATH + PREV_REBOOT_CAUSE_FILE)\n\n        sw_reboot_cause      = self.__read_txt_file(reboot_cause_path) or \"Unknown\"\n        prev_sw_reboot_cause = self.__read_txt_file(prev_reboot_cause_path) or \"Unknown\"\n\n        if sw_reboot_cause != \"Unknown\":\n            reboot_cause = self.REBOOT_CAUSE_NON_HARDWARE\n            description = sw_reboot_cause\n        elif prev_reboot_cause_path != \"Unknown\":\n            reboot_cause = self.REBOOT_CAUSE_NON_HARDWARE\n            description = prev_sw_reboot_cause\n\n        return (reboot_cause, description)\n\n    def get_change_event(self, timeout=0):\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n        return self._sfpevent.get_sfp_event(timeout)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n\n    def initizalize_system_led(self):\n        return True\n\n    def get_status_led(self):\n        val = self.__read_txt_file(SYSLED_FNODE)\n        return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\"\n\n    def set_status_led(self, color):\n        mode = None\n        for key, val in SYSLED_MODES.items():\n            if val == color:\n                mode = key\n                break\n        if mode is None:\n            return False\n        else:\n            return self.__write_txt_file(SYSLED_FNODE, mode)\n"}, "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n \n     PLATFORM = \"x86_64-accton_as7326_56x-r0\"\n     HWSKU = \"Accton-AS7326-56X\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_P", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7326_56x-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}], "source": "\n import os import time import sys from ctypes import create_string_buffer try: from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ 0:{ \"bus\": 18, \"addr\": \"60\" }, 1:{ \"bus\": 12, \"addr\": \"62\" }, } CPLD_I2C_PATH=\"/sys/bus/i2c/devices/{}-00{}/\" class Sfp(SfpOptoeBase): \"\"\"Platform-specific Sfp class\"\"\" PORT_START=1 PORT_END=58 PLATFORM_ROOT_PATH=\"/usr/share/sonic/device\" PMON_HWSKU_PATH=\"/usr/share/sonic/hwsku\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" PLATFORM=\"x86_64-accton_as7326_56x-r0\" HWSKU=\"Accton-AS7326-56X\" _port_to_i2c_mapping={ 1:[42], 2:[41], 3:[44], 4:[43], 5:[47], 6:[45], 7:[46], 8:[50], 9:[48], 10:[49], 11:[52], 12:[51], 13:[53], 14:[56], 15:[55], 16:[54], 17:[58], 18:[57], 19:[60], 20:[59], 21:[61], 22:[63], 23:[62], 24:[64], 25:[66], 26:[68], 27:[65], 28:[67], 29:[69], 30:[71], 31:[72], 32:[70], 33:[74], 34:[73], 35:[76], 36:[75], 37:[77], 38:[79], 39:[78], 40:[80], 41:[81], 42:[82], 43:[84], 44:[85], 45:[83], 46:[87], 47:[88], 48:[86], 49:[25], 50:[26], 51:[27], 52:[28], 53:[29], 54:[30], 55:[31], 56:[32], 57:[22], 58:[23] } def __init__(self, sfp_index=0): SfpOptoeBase.__init__(self) self.index=sfp_index self.port_num=self.index +1 cpld_idx=0 if self.port_num > 30 else 1 bus=CPLD_ADDR_MAPPING[cpld_idx][\"bus\"] addr=CPLD_ADDR_MAPPING[cpld_idx][\"addr\"] self.cpld_path=CPLD_I2C_PATH.format(bus, addr) eeprom_path='/sys/bus/i2c/devices/{0}-0050/eeprom' self.port_to_eeprom_mapping={} for x in range(self.PORT_START, self.PORT_END +1): self.port_to_eeprom_mapping[x]=eeprom_path.format( self._port_to_i2c_mapping[x][0]) def get_eeprom_path(self): return self.port_to_eeprom_mapping[self.port_num] def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: return fd.read().strip() except IOError: pass return \"\" def __write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except Exception: return False return True def __is_host(self): return os.system(self.HOST_CHK_CMD)==0 def __get_path_to_port_config_file(self): platform_path=\"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM]) hwsku_path=\"/\".join( [platform_path, self.HWSKU]) if self.__is_host() else self.PMON_HWSKU_PATH return \"/\".join([hwsku_path, \"port_config.ini\"]) def __read_eeprom_specific_bytes(self, offset, num_bytes): sysfsfile_eeprom=None eeprom_raw=[] for i in range(0, num_bytes): eeprom_raw.append(\"0x00\") sysfs_sfp_i2c_client_eeprom_path=self.port_to_eeprom_mapping[ self.port_num] try: sysfsfile_eeprom=open( sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0) sysfsfile_eeprom.seek(offset) raw=sysfsfile_eeprom.read(num_bytes) for n in range(0, num_bytes): if sys.version_info[0] >=3: eeprom_raw[n]=hex(raw[n])[2:].zfill(2) else: eeprom_raw[n]=hex(ord(raw[n]))[2:].zfill(2) except Exception: pass finally: if sysfsfile_eeprom: sysfsfile_eeprom.close() return eeprom_raw def get_reset_status(self): \"\"\" Retrieves the reset status of SFP Returns: A Boolean, True if reset enabled, False if disabled \"\"\" if self.port_num <=48 or self.port_num >=57: return False val=self.__read_txt_file( self.cpld_path +\"module_reset_\" +str(self.port_num)) return int(val, 10)==1 def get_rx_los(self): \"\"\" Retrieves the RX LOS(lost-of-signal) status of SFP Returns: A Boolean, True if SFP has RX LOS, False if not. Note: RX LOS status is latched until a call to get_rx_los or a reset. \"\"\" if self.port_num <=48 or self.port_num >=57: rx_los=self.__read_txt_file( self.cpld_path +\"module_rx_los_\" +str(self.port_num)) if int(rx_los, 10)==1: return[True] else: return[False] else: rx_los_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence( ) else None if dom_channel_monitor_raw is not None: rx_los_data=int(dom_channel_monitor_raw[0], 16) rx_los_list.append(rx_los_data & 0x01 !=0) rx_los_list.append(rx_los_data & 0x02 !=0) rx_los_list.append(rx_los_data & 0x04 !=0) rx_los_list.append(rx_los_data & 0x08 !=0) return rx_los_list else: return[False]*4 def get_tx_fault(self): \"\"\" Retrieves the TX fault status of SFP Returns: A list of boolean values, representing the TX fault status of each available channel, value is True if SFP channel has TX fault, False if not. E.g., for a tranceiver with four channels:[False, False, True, False] Note: TX fault status is lached until a call to get_tx_fault or a reset. \"\"\" tx_fault=False if self.port_num <=48 or self.port_num >=57: tx_fault=self.__read_txt_file( self.cpld_path +\"module_tx_fault_\" +str(self.port_num)) if int(tx_fault, 10)==1: return[True] else: return[False] else: tx_fault_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence( ) else None if dom_channel_monitor_raw is not None: tx_fault_data=int(dom_channel_monitor_raw[0], 16) tx_fault_list.append(tx_fault_data & 0x01 !=0) tx_fault_list.append(tx_fault_data & 0x02 !=0) tx_fault_list.append(tx_fault_data & 0x04 !=0) tx_fault_list.append(tx_fault_data & 0x08 !=0) return tx_fault_list else: return[False]*4 def get_tx_disable(self): \"\"\" Retrieves the tx_disable status of this SFP Returns: A list of boolean values, representing the TX disable status of each available channel, value is True if SFP channel is TX disabled, False if not. E.g., for a tranceiver with four channels:[False, False, True, False] \"\"\" if self.port_num <=48 or self.port_num >=57: tx_disable=False status_control_raw=self.__read_eeprom_specific_bytes( SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH) if status_control_raw: cpld_val=self.__read_txt_file( self.cpld_path +\"module_tx_disable_\" +str(self.port_num)) tx_disable_hard=(int(cpld_val, 10)==1) data=int(status_control_raw[0], 16) tx_disable_soft=(sffbase().test_bit( data, SFP_TX_DISABLE_SOFT_BIT) !=0) tx_disable=tx_disable_hard | tx_disable_soft if tx_disable==0: return[False] else: return[True] else: return[False] else: tx_disable_list=[] sfpd_obj=sff8436Dom() if sfpd_obj is None: return[False] dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes( dom_control_raw, 0) tx_disable_list.append( 'On'==dom_control_data['data']['TX1Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX2Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX3Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX4Disable']['value']) return tx_disable_list else: return[False]*4 def get_tx_disable_channel(self): \"\"\" Retrieves the TX disabled channels in this SFP Returns: A hex of 4 bits(bit 0 to bit 3 as channel 0 to channel 3) to represent TX channels which have been disabled in this SFP. As an example, a returned value of 0x5 indicates that channel 0 and channel 2 have been disabled. \"\"\" tx_disable_list=self.get_tx_disable() if tx_disable_list is None: return 0 tx_disabled=0 for i in range(len(tx_disable_list)): if tx_disable_list[i]: tx_disabled |=1 << i return tx_disabled def get_lpmode(self): \"\"\" Retrieves the lpmode(low power mode) status of this SFP Returns: A Boolean, True if lpmode is enabled, False if disabled \"\"\" if self.port_num <=48 or self.port_num >=57: return False power_set=self.get_power_set() power_override=self.get_power_override() return power_set and power_override def get_power_set(self): if self.port_num <=48 or self.port_num >=57: return False else: power_set=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes( dom_control_raw, 0) power_set=( 'On'==dom_control_data['data']['PowerSet']['value']) return power_set def get_power_override(self): \"\"\" Retrieves the power-override status of this SFP Returns: A Boolean, True if power-override is enabled, False if disabled \"\"\" if self.port_num <=48 or self.port_num >=57: return False else: power_override=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes( dom_control_raw, 0) power_override=( 'On'==dom_control_data['data']['PowerOverride']['value']) return power_override def reset(self): \"\"\" Reset SFP and return all user module settings to their default srate. Returns: A boolean, True if successful, False if not \"\"\" if self.port_num <=48 or self.port_num >=57: return False ret=self.__write_txt_file( self.cpld_path +\"module_reset_\" +str(self.port_num), 1) if ret is not True: return ret time.sleep(0.01) ret=self.__write_txt_file( self.cpld_path +\"module_reset_\" +str(self.port_num), 0) time.sleep(0.2) return ret def tx_disable(self, tx_disable): \"\"\" Disable SFP TX for all channels Args: tx_disable: A Boolean, True to enable tx_disable mode, False to disable tx_disable mode. Returns: A boolean, True if tx_disable is set successfully, False if not \"\"\" if self.port_num <=48 or self.port_num >=57: ret=self.__write_txt_file( self.cpld_path +\"module_tx_disable_\" +str(self.port_num), 1 if tx_disable else 0) time.sleep(0.01) return ret else: if not self.get_presence(): return False sysfsfile_eeprom=None try: tx_disable_ctl=0xf if tx_disable else 0x0 buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=tx_disable_ctl else: buffer[0]=chr(tx_disable_ctl) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def tx_disable_channel(self, channel, disable): \"\"\" Sets the tx_disable for specified SFP channels Args: channel: A hex of 4 bits(bit 0 to bit 3) which represent channel 0 to 3, e.g. 0x5 for channel 0 and channel 2. disable: A boolean, True to disable TX channels specified in channel, False to enable Returns: A boolean, True if successful, False if not \"\"\" if self.port_num <=48 or self.port_num >=57: return False else: if not self.get_presence(): return False sysfsfile_eeprom=None try: channel_state=self.get_tx_disable_channel() for i in range(4): channel_mask=(1 << i) if not(channel & channel_mask): continue if disable: channel_state |=channel_mask else: channel_state &=~channel_mask buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=channel_state else: buffer[0]=chr(channel_state) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def set_lpmode(self, lpmode): \"\"\" Sets the lpmode(low power mode) of SFP Args: lpmode: A Boolean, True to enable lpmode, False to disable it Note : lpmode can be overridden by set_power_override Returns: A boolean, True if lpmode is set successfully, False if not \"\"\" if self.port_num <=48 or self.port_num >=57: return False if lpmode: return self.set_power_override(True, True) else: return self.set_power_override(True, False) def set_power_override(self, power_override, power_set): \"\"\" Sets SFP power level using power_override and power_set Args: power_override: A Boolean, True to override set_lpmode and use power_set to control SFP power, False to disable SFP power control through power_override/power_set and use set_lpmode to control SFP power. power_set: Only valid when power_override is True. A Boolean, True to set SFP to low power mode, False to set SFP to high power mode. Returns: A boolean, True if power-override and power_set are set successfully, False if not \"\"\" if self.port_num <=48 or self.port_num >=57: return False else: if not self.get_presence(): return False try: power_override_bit=(1 << 0) if power_override else 0 power_set_bit=(1 << 1) if power_set else(1 << 3) buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=(power_override_bit | power_set_bit) else: buffer[0]=chr(power_override_bit | power_set_bit) with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd: fd.seek(QSFP_POWEROVERRIDE_OFFSET) fd.write(buffer[0]) time.sleep(0.01) except Exception: print(\"Error: unable to open file: %s\" % str(e)) return False return True def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" sfputil_helper=SfpUtilHelper() sfputil_helper.read_porttab_mappings( self.__get_path_to_port_config_file()) name=sfputil_helper.logical[self.index] or \"Unknown\" return name def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" val=self.__read_txt_file( self.cpld_path +\"module_present_\" +str(self.port_num)) return val=='1' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return self.get_presence() def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return self.port_num def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return True ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Sfp contains an implementation of SONiC Platform Base API and\n# provides the sfp device status which are available in the platform\n#\n#############################################################################\n\nimport os\nimport time\nimport sys\n\nfrom ctypes import create_string_buffer\n\ntry:\n    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase\n    from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    0: {\n        \"bus\": 18,\n        \"addr\": \"60\"\n    },  # port 31-56\n    1: {\n        \"bus\": 12,\n        \"addr\": \"62\"\n    },  # port  1-30\n}\nCPLD_I2C_PATH = \"/sys/bus/i2c/devices/{}-00{}/\"\n\nclass Sfp(SfpOptoeBase):\n    \"\"\"Platform-specific Sfp class\"\"\"\n\n    # Port number\n    PORT_START = 1\n    PORT_END = 58\n\n    # Path to sysfs\n    PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n    PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n\n    PLATFORM = \"x86_64-accton_as7326_56x-r0\"\n    HWSKU = \"Accton-AS7326-56X\"\n\n    _port_to_i2c_mapping = {\n        1: [42],\n        2: [41],\n        3: [44],\n        4: [43],\n        5: [47],\n        6: [45],\n        7: [46],\n        8: [50],\n        9: [48],\n        10: [49],\n        11: [52],\n        12: [51],\n        13: [53],\n        14: [56],\n        15: [55],\n        16: [54],\n        17: [58],\n        18: [57],\n        19: [60],\n        20: [59],\n        21: [61],\n        22: [63],\n        23: [62],\n        24: [64],\n        25: [66],\n        26: [68],\n        27: [65],\n        28: [67],\n        29: [69],\n        30: [71],\n        31: [72],\n        32: [70],\n        33: [74],\n        34: [73],\n        35: [76],\n        36: [75],\n        37: [77],\n        38: [79],\n        39: [78],\n        40: [80],\n        41: [81],\n        42: [82],\n        43: [84],\n        44: [85],\n        45: [83],\n        46: [87],\n        47: [88],\n        48: [86],\n        49: [25],\n        50: [26],\n        51: [27],\n        52: [28],\n        53: [29],\n        54: [30],\n        55: [31],\n        56: [32],\n        57: [22],\n        58: [23]\n    }\n\n    def __init__(self, sfp_index=0):\n        SfpOptoeBase.__init__(self)\n        # Init index\n        self.index = sfp_index\n        self.port_num = self.index + 1\n\n        cpld_idx = 0 if self.port_num > 30 else 1\n        bus = CPLD_ADDR_MAPPING[cpld_idx][\"bus\"]\n        addr = CPLD_ADDR_MAPPING[cpld_idx][\"addr\"]\n        self.cpld_path = CPLD_I2C_PATH.format(bus, addr)\n\n        # Init eeprom path\n        eeprom_path = '/sys/bus/i2c/devices/{0}-0050/eeprom'\n        self.port_to_eeprom_mapping = {}\n        for x in range(self.PORT_START, self.PORT_END + 1):\n            self.port_to_eeprom_mapping[x] = eeprom_path.format(\n                self._port_to_i2c_mapping[x][0])\n\n    def get_eeprom_path(self):\n        return self.port_to_eeprom_mapping[self.port_num]\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                return fd.read().strip()\n        except IOError:\n            pass\n        return \"\"\n\n    def __write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except Exception:\n            return False\n        return True\n\n    def __is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def __get_path_to_port_config_file(self):\n        platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n        hwsku_path = \"/\".join(\n            [platform_path,\n             self.HWSKU]) if self.__is_host() else self.PMON_HWSKU_PATH\n        return \"/\".join([hwsku_path, \"port_config.ini\"])\n\n    def __read_eeprom_specific_bytes(self, offset, num_bytes):\n        sysfsfile_eeprom = None\n        eeprom_raw = []\n        for i in range(0, num_bytes):\n            eeprom_raw.append(\"0x00\")\n\n        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[\n            self.port_num]\n        try:\n            sysfsfile_eeprom = open(\n                sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0)\n            sysfsfile_eeprom.seek(offset)\n            raw = sysfsfile_eeprom.read(num_bytes)\n            for n in range(0, num_bytes):\n                if sys.version_info[0] >= 3:\n                    eeprom_raw[n] = hex(raw[n])[2:].zfill(2)\n                else:\n                    eeprom_raw[n] = hex(ord(raw[n]))[2:].zfill(2)\n        except Exception:\n            pass\n        finally:\n            if sysfsfile_eeprom:\n                sysfsfile_eeprom.close()\n\n        return eeprom_raw\n\n    def get_reset_status(self):\n        \"\"\"\n        Retrieves the reset status of SFP\n        Returns:\n            A Boolean, True if reset enabled, False if disabled\n        \"\"\"\n        if self.port_num <= 48  or self.port_num >=57:\n            return False  # SPF port doesn't support this feature\n\n        val = self.__read_txt_file(\n            self.cpld_path + \"module_reset_\" + str(self.port_num))\n        return int(val, 10) == 1\n\n    def get_rx_los(self):\n        \"\"\"\n        Retrieves the RX LOS (lost-of-signal) status of SFP\n        Returns:\n            A Boolean, True if SFP has RX LOS, False if not.\n            Note : RX LOS status is latched until a call to get_rx_los or a reset.\n        \"\"\"\n        if self.port_num <= 48  or self.port_num >=57:\n            rx_los = self.__read_txt_file(\n                self.cpld_path + \"module_rx_los_\" + str(self.port_num))\n            if int(rx_los, 10) == 1:\n                return [True]\n            else:\n                return [False]\n            #status_control_raw = self.__read_eeprom_specific_bytes(\n            #    SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            #if status_control_raw:\n            #    data = int(status_control_raw[0], 16)\n            #    rx_los = (sffbase().test_bit(data, 1) != 0)\n        else:\n            rx_los_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_RX_LOS_STATUS_OFFSET,\n                QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence(\n                ) else None\n            if dom_channel_monitor_raw is not None:\n                rx_los_data = int(dom_channel_monitor_raw[0], 16)\n                rx_los_list.append(rx_los_data & 0x01 != 0)\n                rx_los_list.append(rx_los_data & 0x02 != 0)\n                rx_los_list.append(rx_los_data & 0x04 != 0)\n                rx_los_list.append(rx_los_data & 0x08 != 0)\n                return rx_los_list\n            else:\n                return [False]*4\n\n    def get_tx_fault(self):\n        \"\"\"\n        Retrieves the TX fault status of SFP\n        \n        Returns:\n            A list of boolean values, representing the TX fault status\n            of each available channel, value is True if SFP channel\n            has TX fault, False if not.\n            E.g., for a tranceiver with four channels: [False, False, True, False]\n            Note : TX fault status is lached until a call to get_tx_fault or a reset.\n        \"\"\"\n        tx_fault = False\n        if self.port_num <= 48  or self.port_num >=57:\n            tx_fault = self.__read_txt_file(\n                self.cpld_path + \"module_tx_fault_\" + str(self.port_num))\n            if int(tx_fault, 10) == 1:\n                return [True]\n            else:\n                return [False]\n            #status_control_raw = self.__read_eeprom_specific_bytes(\n            #    SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            #if status_control_raw:\n            #    data = int(status_control_raw[0], 16)\n            #    tx_fault = (sffbase().test_bit(data, 2) != 0)\n        else:\n            tx_fault_list = []\n            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_TX_FAULT_STATUS_OFFSET,\n                QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence(\n                ) else None\n            if dom_channel_monitor_raw is not None:\n                tx_fault_data = int(dom_channel_monitor_raw[0], 16)\n                tx_fault_list.append(tx_fault_data & 0x01 != 0)\n                tx_fault_list.append(tx_fault_data & 0x02 != 0)\n                tx_fault_list.append(tx_fault_data & 0x04 != 0)\n                tx_fault_list.append(tx_fault_data & 0x08 != 0)\n                return tx_fault_list\n            else:\n                return [False]*4\n\n\n    def get_tx_disable(self):\n        \"\"\"\n        Retrieves the tx_disable status of this SFP\n        Returns:\n            A list of boolean values, representing the TX disable status\n            of each available channel, value is True if SFP channel\n            is TX disabled, False if not.\n            E.g., for a tranceiver with four channels: [False, False, True, False]\n        \"\"\"\n        if self.port_num <= 48 or self.port_num >=57:\n            tx_disable = False\n\n            status_control_raw = self.__read_eeprom_specific_bytes(\n                SFP_STATUS_CONTROL_OFFSET, SFP_STATUS_CONTROL_WIDTH)\n            if status_control_raw:\n                cpld_val = self.__read_txt_file(\n                    self.cpld_path + \"module_tx_disable_\" + str(self.port_num))\n                tx_disable_hard = (int(cpld_val, 10) == 1)\n                data = int(status_control_raw[0], 16)\n                #tx_disable_hard = (sffbase().test_bit(\n                #    data, SFP_TX_DISABLE_HARD_BIT) != 0)\n                tx_disable_soft = (sffbase().test_bit(\n                    data, SFP_TX_DISABLE_SOFT_BIT) != 0)\n                tx_disable = tx_disable_hard | tx_disable_soft\n                if tx_disable==0:\n                    return [False]\n                else:\n                    return [True]\n                \n            else:\n                return [False]\n\n        else:\n            tx_disable_list = []\n\n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return [False]\n\n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET,\n                QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(\n                    dom_control_raw, 0)\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX1Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX2Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX3Disable']['value'])\n                tx_disable_list.append(\n                    'On' == dom_control_data['data']['TX4Disable']['value'])\n                return tx_disable_list\n            else:\n                return [False]*4\n\n    def get_tx_disable_channel(self):\n        \"\"\"\n        Retrieves the TX disabled channels in this SFP\n        Returns:\n            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent\n            TX channels which have been disabled in this SFP.\n            As an example, a returned value of 0x5 indicates that channel 0\n            and channel 2 have been disabled.\n        \"\"\"\n        tx_disable_list = self.get_tx_disable()\n        if tx_disable_list is None:\n            return 0\n        tx_disabled = 0\n        for i in range(len(tx_disable_list)):\n            if tx_disable_list[i]:\n                tx_disabled |= 1 << i\n        return tx_disabled\n\n    def get_lpmode(self):\n        \"\"\"\n        Retrieves the lpmode (low power mode) status of this SFP\n        Returns:\n            A Boolean, True if lpmode is enabled, False if disabled\n        \"\"\"\n        if self.port_num <= 48 or self.port_num >= 57:\n            # SFP doesn't support this feature\n            return False\n\n        power_set = self.get_power_set()\n        power_override = self.get_power_override()\n        return power_set and power_override\n\n    def get_power_set(self):\n\n        if self.port_num <= 48 or self.port_num >= 57:\n            # SFP doesn't support this feature\n            return False\n        else:\n            power_set = False\n\n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n\n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET,\n                QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(\n                    dom_control_raw, 0)\n                power_set = (\n                    'On' == dom_control_data['data']['PowerSet']['value'])\n\n            return power_set\n\n    def get_power_override(self):\n        \"\"\"\n        Retrieves the power-override status of this SFP\n        Returns:\n            A Boolean, True if power-override is enabled, False if disabled\n        \"\"\"\n        if self.port_num <= 48 or self.port_num >= 57:\n            return False  # SFP doesn't support this feature\n        else:\n            power_override = False\n\n            sfpd_obj = sff8436Dom()\n            if sfpd_obj is None:\n                return False\n\n            dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET,\n                QSFP_CONTROL_WIDTH) if self.get_presence() else None\n            if dom_control_raw is not None:\n                dom_control_data = sfpd_obj.parse_control_bytes(\n                    dom_control_raw, 0)\n                power_override = (\n                    'On' == dom_control_data['data']['PowerOverride']['value'])\n\n            return power_override\n\n    def reset(self):\n        \"\"\"\n        Reset SFP and return all user module settings to their default srate.\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        # Check for invalid port_num\n        if self.port_num <= 48  or self.port_num >=57:\n            return False  # SFP doesn't support this feature\n\n        ret = self.__write_txt_file(\n            self.cpld_path + \"module_reset_\" + str(self.port_num), 1)\n        if ret is not True:\n            return ret\n\n        time.sleep(0.01)\n        ret = self.__write_txt_file(\n            self.cpld_path + \"module_reset_\" + str(self.port_num), 0)\n        time.sleep(0.2)\n        return ret\n\n    def tx_disable(self, tx_disable):\n        \"\"\"\n        Disable SFP TX for all channels\n        Args:\n            tx_disable : A Boolean, True to enable tx_disable mode, False to disable\n                         tx_disable mode.\n        Returns:\n            A boolean, True if tx_disable is set successfully, False if not\n        \"\"\"\n        if self.port_num <= 48  or self.port_num >=57:\n            ret = self.__write_txt_file(\n                self.cpld_path + \"module_tx_disable_\" + str(self.port_num), 1\n                if tx_disable else 0)\n            time.sleep(0.01)\n            return ret\n        else:\n            if not self.get_presence():\n                return False\n\n            sysfsfile_eeprom = None\n            try:\n                tx_disable_ctl = 0xf if tx_disable else 0x0\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = tx_disable_ctl\n                else:\n                    buffer[0] = chr(tx_disable_ctl)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print(\"Error: unable to open file: %s\" % str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n        return True\n\n    def tx_disable_channel(self, channel, disable):\n        \"\"\"\n        Sets the tx_disable for specified SFP channels\n        Args:\n            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,\n                      e.g. 0x5 for channel 0 and channel 2.\n            disable : A boolean, True to disable TX channels specified in channel,\n                      False to enable\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n\n        if self.port_num <= 48  or self.port_num >=57:\n            return False  # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n\n            sysfsfile_eeprom = None\n            try:\n                channel_state = self.get_tx_disable_channel()\n\n                for i in range(4):\n                    channel_mask = (1 << i)\n                    if not (channel & channel_mask):\n                        continue\n\n                    if disable:\n                        channel_state |= channel_mask\n                    else:\n                        channel_state &= ~channel_mask\n\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = channel_state\n                else:\n                    buffer[0] = chr(channel_state)\n                # Write to eeprom\n                sysfsfile_eeprom = open(\n                    self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n                sysfsfile_eeprom.write(buffer[0])\n            except IOError as e:\n                print(\"Error: unable to open file: %s\" % str(e))\n                return False\n            finally:\n                if sysfsfile_eeprom is not None:\n                    sysfsfile_eeprom.close()\n                    time.sleep(0.01)\n            return True\n\n    def set_lpmode(self, lpmode):\n        \"\"\"\n        Sets the lpmode (low power mode) of SFP\n        Args:\n            lpmode: A Boolean, True to enable lpmode, False to disable it\n            Note  : lpmode can be overridden by set_power_override\n        Returns:\n            A boolean, True if lpmode is set successfully, False if not\n        \"\"\"\n        if self.port_num <= 48  or self.port_num >=57:\n            return False  # SFP doesn't support this feature\n\n        if lpmode:\n            return self.set_power_override(True, True)\n        else:\n            return self.set_power_override(True, False)\n\n    def set_power_override(self, power_override, power_set):\n        \"\"\"\n        Sets SFP power level using power_override and power_set\n        Args:\n            power_override :\n                    A Boolean, True to override set_lpmode and use power_set\n                    to control SFP power, False to disable SFP power control\n                    through power_override/power_set and use set_lpmode\n                    to control SFP power.\n            power_set :\n                    Only valid when power_override is True.\n                    A Boolean, True to set SFP to low power mode, False to set\n                    SFP to high power mode.\n        Returns:\n            A boolean, True if power-override and power_set are set successfully,\n            False if not\n        \"\"\"\n        if self.port_num <= 48  or self.port_num >=57:\n            return False  # SFP doesn't support this feature\n        else:\n            if not self.get_presence():\n                return False\n            try:\n                power_override_bit = (1 << 0) if power_override else 0\n                power_set_bit = (1 << 1) if power_set else (1 << 3)\n\n                buffer = create_string_buffer(1)\n                if sys.version_info[0] >= 3:\n                    buffer[0] = (power_override_bit | power_set_bit)\n                else:\n                    buffer[0] = chr(power_override_bit | power_set_bit)\n                # Write to eeprom\n                with open(self.port_to_eeprom_mapping[self.port_num],\n                          \"r+b\") as fd:\n                    fd.seek(QSFP_POWEROVERRIDE_OFFSET)\n                    fd.write(buffer[0])\n                    time.sleep(0.01)\n            except Exception:\n                print(\"Error: unable to open file: %s\" % str(e))\n                return False\n            return True\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        sfputil_helper = SfpUtilHelper()\n        sfputil_helper.read_porttab_mappings(\n            self.__get_path_to_port_config_file())\n        name = sfputil_helper.logical[self.index] or \"Unknown\"\n        return name\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        val = self.__read_txt_file(\n            self.cpld_path + \"module_present_\" + str(self.port_num))\n        return val == '1'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return self.get_presence()\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return self.port_num\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return True\n"}, "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"which\", \"systemctl\"]\n SYSLED_FNODE = \"/sys/class/leds/as7816_64x_led::diag/brightness\"\n SYSLED_MODES = {\n     \"0\" : \"STATUS_LED_COLOR_OFF\",\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n     \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, file", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os import sys try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper from.event import SfpEvent except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=4 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=6 NUM_PORT=64 NUM_COMPONENT=5 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" SYSLED_FNODE=\"/sys/class/leds/as7816_64x_led::diag/brightness\" SYSLED_MODES={ \"0\": \"STATUS_LED_COLOR_OFF\", \"16\": \"STATUS_LED_COLOR_GREEN\", \"10\": \"STATUS_LED_COLOR_RED\" } class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp for index in range(0, NUM_PORT): sfp=Sfp(index) self._sfp_list.append(sfp) self._sfpevent=SfpEvent(self._sfp_list) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for fant_index in range(NUM_FAN_TRAY): fandrawer=FanDrawer(fant_index) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._eeprom.get_product_name() def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_change_event(self, timeout=0): if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfpevent.get_sfp_event(timeout) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def initizalize_system_led(self): return True def get_status_led(self): val=self._api_helper.read_txt_file(SYSLED_FNODE) return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\" def set_status_led(self, color): mode=None for key, val in SYSLED_MODES.items(): if val==color: mode=key break if mode is None: return False else: return self._api_helper.write_txt_file(SYSLED_FNODE, mode) ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\nimport sys\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\n    from .event import SfpEvent\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 4\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 6\nNUM_PORT = 64\nNUM_COMPONENT = 5\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\nSYSLED_FNODE = \"/sys/class/leds/as7816_64x_led::diag/brightness\"\nSYSLED_MODES = {\n    \"0\" : \"STATUS_LED_COLOR_OFF\",\n    \"16\" : \"STATUS_LED_COLOR_GREEN\",\n    \"10\" : \"STATUS_LED_COLOR_RED\"\n\n}\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n        \n        self.config_data = {}\n\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n\n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n        for index in range(0, NUM_PORT):\n            sfp = Sfp(index)\n            self._sfp_list.append(sfp)\n        self._sfpevent = SfpEvent(self._sfp_list)\n        self.sfp_module_initialized = True\n\n    def __initialize_fan(self):\n        from sonic_platform.fan_drawer import FanDrawer\n        for fant_index in range(NUM_FAN_TRAY):\n            fandrawer = FanDrawer(fant_index)\n            self._fan_drawer_list.append(fandrawer)\n            self._fan_list.extend(fandrawer._fan_list)\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n    \n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return self._eeprom.get_product_name()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n    \n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n    \n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n        \n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n      \n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n\n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_change_event(self, timeout=0):\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n        return self._sfpevent.get_sfp_event(timeout)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n        \n    def initizalize_system_led(self):\n        return True\n\n    def get_status_led(self):\n        val = self._api_helper.read_txt_file(SYSLED_FNODE)\n        return SYSLED_MODES[val] if val in SYSLED_MODES else \"UNKNOWN\"\n\n    def set_status_led(self, color):\n        mode = None\n        for key, val in SYSLED_MODES.items():\n            if val == color:\n                mode = key\n                break\n        if mode is None:\n            return False\n        else:\n            return self._api_helper.write_txt_file(SYSLED_FNODE, mode)\n"}, "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 2, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()\n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firmware", "add": 0, "remove": 16, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"19-0060\", \"CPLD2\": \"20-0062\", \"CPLD3\": \"21-0064\", \"CPLD4\": \"22-0066\", } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"CPLD2\", \"CPLD 2\"), (\"CPLD3\", \"CPLD 3\"), (\"CPLD4\", \"CPLD 4\"), (\"BIOS\", \"Basic Input/Output System\") ] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return 'N/A' def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return 'N/A' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is'0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"19-0060\",\n    \"CPLD2\": \"20-0062\",\n    \"CPLD3\": \"21-0064\",\n    \"CPLD4\": \"22-0066\",\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"CPLD2\", \"CPLD 2\"),\n   (\"CPLD3\", \"CPLD 3\"),\n   (\"CPLD4\", \"CPLD 4\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n   \n]\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)\n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n        \n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of\n        entPhysicalContainedIn is'0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device\n            or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r', errors='replace') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-      ", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False"], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r', errors='replace') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r', errors='replace') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"which\", \"systemctl\"]\n         \n     PLATFORM = \"x86_64-accton_as7816_64x-r0\"\n     HWSKU = \"Accton-AS7816-64X\"\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"which\", \"systemctl\"]"]}, {"diff": "\n         return self.port_to_eeprom_mapping[self.port_num]\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_RO", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as7816_64x-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}], "source": "\n import os import time import sys from ctypes import create_string_buffer try: from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_I2C_PATH=\"/sys/bus/i2c/devices/19-0060/\" class Sfp(SfpOptoeBase): \"\"\"Platform-specific Sfp class\"\"\" PORT_START=1 PORT_END=64 PLATFORM_ROOT_PATH=\"/usr/share/sonic/device\" PMON_HWSKU_PATH=\"/usr/share/sonic/hwsku\" HOST_CHK_CMD=\"which systemctl > /dev/null 2>&1\" PLATFORM=\"x86_64-accton_as7816_64x-r0\" HWSKU=\"Accton-AS7816-64X\" _port_to_i2c_mapping={ 61: 25, 62: 26, 63: 27, 64: 28, 55: 29, 56: 30, 53: 31, 54: 32, 9: 33, 10: 34, 11: 35, 12: 36, 1: 37, 2: 38, 3: 39, 4: 40, 6: 41, 5: 42, 8: 43, 7: 44, 13: 45, 14: 46, 15: 47, 16: 48, 17: 49, 18: 50, 19: 51, 20: 52, 25: 53, 26: 54, 27: 55, 28: 56, 29: 57, 30: 58, 31: 59, 32: 60, 21: 61, 22: 62, 23: 63, 24: 64, 41: 65, 42: 66, 43: 67, 44: 68, 33: 69, 34: 70, 35: 71, 36: 72, 45: 73, 46: 74, 47: 75, 48: 76, 37: 77, 38: 78, 39: 79, 40: 80, 57: 81, 58: 82, 59: 83, 60: 84, 49: 85, 50: 86, 51: 87, 52: 88 } def __init__(self, sfp_index=0): SfpOptoeBase.__init__(self) self._api_helper=APIHelper() self.index=sfp_index self.port_num=self.index +1 eeprom_path='/sys/bus/i2c/devices/{0}-0050/eeprom' self.port_to_eeprom_mapping={} for x in range(self.PORT_START, self.PORT_END +1): self.port_to_eeprom_mapping[x]=eeprom_path.format(self._port_to_i2c_mapping[x]) def get_eeprom_path(self): return self.port_to_eeprom_mapping[self.port_num] def __is_host(self): return os.system(self.HOST_CHK_CMD)==0 def __get_path_to_port_config_file(self): platform_path=\"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM]) hwsku_path=\"/\".join([platform_path, self.HWSKU] ) if self.__is_host() else self.PMON_HWSKU_PATH return \"/\".join([hwsku_path, \"port_config.ini\"]) def __read_eeprom_specific_bytes(self, offset, num_bytes): sysfsfile_eeprom=None eeprom_raw=[] for i in range(0, num_bytes): eeprom_raw.append(\"0x00\") sysfs_sfp_i2c_client_eeprom_path=self.port_to_eeprom_mapping[self.port_num] try: sysfsfile_eeprom=open( sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0) sysfsfile_eeprom.seek(offset) raw=sysfsfile_eeprom.read(num_bytes) if sys.version_info[0] >=3: for n in range(0, num_bytes): eeprom_raw[n]=hex(raw[n])[2:].zfill(2) else: for n in range(0, num_bytes): eeprom_raw[n]=hex(ord(raw[n]))[2:].zfill(2) except Exception: pass finally: if sysfsfile_eeprom: sysfsfile_eeprom.close() return eeprom_raw def get_reset_status(self): \"\"\" Retrieves the reset status of SFP Returns: A Boolean, True if reset enabled, False if disabled \"\"\" reset_path=\"{}{}{}\".format(CPLD_I2C_PATH, \"module_reset_\", str(self.port_num)) val=self._api_helper.read_txt_file(reset_path) if val is not None: return int(val, 10)==1 else: return False def get_rx_los(self): \"\"\" Retrieves the RX LOS(lost-of-signal) status of SFP Returns: A Boolean, True if SFP has RX LOS, False if not. Note: RX LOS status is latched until a call to get_rx_los or a reset. \"\"\" rx_los_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: rx_los_data=int(dom_channel_monitor_raw[0], 16) rx_los_list.append(rx_los_data & 0x01 !=0) rx_los_list.append(rx_los_data & 0x02 !=0) rx_los_list.append(rx_los_data & 0x04 !=0) rx_los_list.append(rx_los_data & 0x08 !=0) return rx_los_list else: return[False]*4 def get_tx_fault(self): \"\"\" Retrieves the TX fault status of SFP Returns: A Boolean, True if SFP has TX fault, False if not Note: TX fault status is lached until a call to get_tx_fault or a reset. \"\"\" tx_fault_list=[] dom_channel_monitor_raw=self.__read_eeprom_specific_bytes( QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None if dom_channel_monitor_raw is not None: tx_fault_data=int(dom_channel_monitor_raw[0], 16) tx_fault_list.append(tx_fault_data & 0x01 !=0) tx_fault_list.append(tx_fault_data & 0x02 !=0) tx_fault_list.append(tx_fault_data & 0x04 !=0) tx_fault_list.append(tx_fault_data & 0x08 !=0) return tx_fault_list else: return[False]*4 def get_tx_disable(self): \"\"\" Retrieves the tx_disable status of this SFP Returns: A Boolean, True if tx_disable is enabled, False if disabled \"\"\" tx_disable_list=[] sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) tx_disable_list.append( 'On'==dom_control_data['data']['TX1Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX2Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX3Disable']['value']) tx_disable_list.append( 'On'==dom_control_data['data']['TX4Disable']['value']) return tx_disable_list else: return[False]*4 def get_tx_disable_channel(self): \"\"\" Retrieves the TX disabled channels in this SFP Returns: A hex of 4 bits(bit 0 to bit 3 as channel 0 to channel 3) to represent TX channels which have been disabled in this SFP. As an example, a returned value of 0x5 indicates that channel 0 and channel 2 have been disabled. \"\"\" tx_disable_list=self.get_tx_disable() if tx_disable_list is None: return 0 tx_disabled=0 for i in range(len(tx_disable_list)): if tx_disable_list[i]: tx_disabled |=1 << i return tx_disabled def get_lpmode(self): \"\"\" Retrieves the lpmode(low power mode) status of this SFP Returns: A Boolean, True if lpmode is enabled, False if disabled \"\"\" power_set=self.get_power_set() power_override=self.get_power_override() return power_set and power_override def get_power_set(self): power_set=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) power_set=( 'On'==dom_control_data['data']['PowerSet']['value']) return power_set def get_power_override(self): \"\"\" Retrieves the power-override status of this SFP Returns: A Boolean, True if power-override is enabled, False if disabled \"\"\" power_override=False sfpd_obj=sff8436Dom() if sfpd_obj is None: return False dom_control_raw=self.__read_eeprom_specific_bytes( QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None if dom_control_raw is not None: dom_control_data=sfpd_obj.parse_control_bytes(dom_control_raw, 0) power_override=( 'On'==dom_control_data['data']['PowerOverride']['value']) return power_override def reset(self): \"\"\" Reset SFP and return all user module settings to their default srate. Returns: A boolean, True if successful, False if not \"\"\" reset_path=\"{}{}{}\".format(CPLD_I2C_PATH, 'module_reset_', self.port_num) ret=self._api_helper.write_txt_file(reset_path, 1) if ret is not True: return ret time.sleep(0.01) ret=self._api_helper.write_txt_file(reset_path, 0) time.sleep(0.2) return ret def tx_disable(self, tx_disable): \"\"\" Disable SFP TX for all channels Args: tx_disable: A Boolean, True to enable tx_disable mode, False to disable tx_disable mode. Returns: A boolean, True if tx_disable is set successfully, False if not \"\"\" if not self.get_presence(): return False sysfsfile_eeprom=None try: tx_disable_ctl=0xf if tx_disable else 0x0 buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=tx_disable_ctl else: buffer[0]=chr(tx_disable_ctl) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ',str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def tx_disable_channel(self, channel, disable): \"\"\" Sets the tx_disable for specified SFP channels Args: channel: A hex of 4 bits(bit 0 to bit 3) which represent channel 0 to 3, e.g. 0x5 for channel 0 and channel 2. disable: A boolean, True to disable TX channels specified in channel, False to enable Returns: A boolean, True if successful, False if not \"\"\" if not self.get_presence(): return False sysfsfile_eeprom=None try: channel_state=self.get_tx_disable_channel() for i in range(4): channel_mask=(1 << i) if not(channel & channel_mask): continue if disable: channel_state |=channel_mask else: channel_state &=~channel_mask buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=channel_state else: buffer[0]=chr(channel_state) sysfsfile_eeprom=open( self.port_to_eeprom_mapping[self.port_num], \"r+b\") sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET) sysfsfile_eeprom.write(buffer[0]) except IOError as e: print('Error: unable to open file: ', str(e)) return False finally: if sysfsfile_eeprom is not None: sysfsfile_eeprom.close() time.sleep(0.01) return True def set_lpmode(self, lpmode): \"\"\" Sets the lpmode(low power mode) of SFP Args: lpmode: A Boolean, True to enable lpmode, False to disable it Note : lpmode can be overridden by set_power_override Returns: A boolean, True if lpmode is set successfully, False if not \"\"\" if lpmode: self.set_power_override(True, True) else: self.set_power_override(False, False) return True def set_power_override(self, power_override, power_set): \"\"\" Sets SFP power level using power_override and power_set Args: power_override: A Boolean, True to override set_lpmode and use power_set to control SFP power, False to disable SFP power control through power_override/power_set and use set_lpmode to control SFP power. power_set: Only valid when power_override is True. A Boolean, True to set SFP to low power mode, False to set SFP to high power mode. Returns: A boolean, True if power-override and power_set are set successfully, False if not \"\"\" if not self.get_presence(): return False try: power_override_bit=(1 << 0) if power_override else 0 power_set_bit =(1 << 1) if power_set else(1 << 3) buffer=create_string_buffer(1) if sys.version_info[0] >=3: buffer[0]=(power_override_bit | power_set_bit) else: buffer[0]=chr(power_override_bit | power_set_bit) with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd: fd.seek(QSFP_POWEROVERRIDE_OFFSET) fd.write(buffer[0]) time.sleep(0.01) except Exception: print('Error: unable to open file: ', str(e)) return False return True def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" sfputil_helper=SfpUtilHelper() sfputil_helper.read_porttab_mappings( self.__get_path_to_port_config_file()) name=sfputil_helper.logical[self.index] or \"Unknown\" return name def get_presence(self): \"\"\" Retrieves the presence of the device Returns: bool: True if device is present, False if not \"\"\" present_path=\"{}{}{}\".format(CPLD_I2C_PATH, '/module_present_', self.port_num) val=self._api_helper.read_txt_file(present_path) if val is not None: return int(val, 10)==1 else: return False def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return self.get_presence() def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return self.port_num def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return True ", "sourceWithComments": "#############################################################################\n# Edgecore\n#\n# Sfp contains an implementation of SONiC Platform Base API and\n# provides the sfp device status which are available in the platform\n#\n#############################################################################\n\nimport os\nimport time\nimport sys\n\nfrom ctypes import create_string_buffer\n\ntry:\n    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_I2C_PATH = \"/sys/bus/i2c/devices/19-0060/\"\n\n\nclass Sfp(SfpOptoeBase):\n    \"\"\"Platform-specific Sfp class\"\"\"\n\n    # Port number\n    PORT_START = 1\n    PORT_END = 64\n\n    # Path to sysfs\n    PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n    PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n    HOST_CHK_CMD = \"which systemctl > /dev/null 2>&1\"\n        \n    PLATFORM = \"x86_64-accton_as7816_64x-r0\"\n    HWSKU = \"Accton-AS7816-64X\"\n\n    _port_to_i2c_mapping = {\n        61: 25,\n        62: 26,\n        63: 27,\n        64: 28,\n        55: 29,\n        56: 30,\n        53: 31,\n        54: 32,\n        9:  33,\n        10: 34,\n        11: 35,\n        12: 36,\n        1:  37,\n        2:  38,\n        3:  39,\n        4:  40,\n        6:  41,\n        5:  42,\n        8:  43,\n        7:  44,\n        13: 45,\n        14: 46,\n        15: 47,\n        16: 48,\n        17: 49,\n        18: 50,\n        19: 51,\n        20: 52,\n        25: 53,\n        26: 54,\n        27: 55,\n        28: 56,\n        29: 57,\n        30: 58,\n        31: 59,\n        32: 60,\n        21: 61,\n        22: 62,\n        23: 63,\n        24: 64,\n        41: 65,\n        42: 66,\n        43: 67,\n        44: 68,\n        33: 69,\n        34: 70,\n        35: 71,\n        36: 72,\n        45: 73,\n        46: 74,\n        47: 75,\n        48: 76,\n        37: 77,\n        38: 78,\n        39: 79,\n        40: 80,\n        57: 81,\n        58: 82,\n        59: 83,\n        60: 84,\n        49: 85,\n        50: 86,\n        51: 87,\n        52: 88 \n    }\n\n    def __init__(self, sfp_index=0):\n        SfpOptoeBase.__init__(self)\n        self._api_helper=APIHelper()\n        # Init index\n        self.index = sfp_index\n        self.port_num = self.index + 1\n        # Init eeprom path\n        eeprom_path = '/sys/bus/i2c/devices/{0}-0050/eeprom'\n        self.port_to_eeprom_mapping = {}\n        for x in range(self.PORT_START, self.PORT_END + 1):\n            self.port_to_eeprom_mapping[x] = eeprom_path.format(self._port_to_i2c_mapping[x])\n        \n    def get_eeprom_path(self):\n        return self.port_to_eeprom_mapping[self.port_num]\n\n    def __is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def __get_path_to_port_config_file(self):\n        platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n        hwsku_path = \"/\".join([platform_path, self.HWSKU]\n                              ) if self.__is_host() else self.PMON_HWSKU_PATH\n        return \"/\".join([hwsku_path, \"port_config.ini\"])\n\n    def __read_eeprom_specific_bytes(self, offset, num_bytes):\n        sysfsfile_eeprom = None\n        eeprom_raw = []\n        for i in range(0, num_bytes):\n            eeprom_raw.append(\"0x00\")\n\n        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]\n        try:\n            sysfsfile_eeprom = open(\n                sysfs_sfp_i2c_client_eeprom_path, mode=\"rb\", buffering=0)\n            sysfsfile_eeprom.seek(offset)\n            raw = sysfsfile_eeprom.read(num_bytes)\n            if sys.version_info[0] >= 3:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(raw[n])[2:].zfill(2)\n            else:\n                for n in range(0, num_bytes):\n                    eeprom_raw[n] = hex(ord(raw[n]))[2:].zfill(2)\n        except Exception:\n            pass\n        finally:\n            if sysfsfile_eeprom:\n                sysfsfile_eeprom.close()\n\n        return eeprom_raw\n\n    def get_reset_status(self):\n        \"\"\"\n        Retrieves the reset status of SFP\n        Returns:\n            A Boolean, True if reset enabled, False if disabled\n        \"\"\"\n        reset_path=\"{}{}{}\".format(CPLD_I2C_PATH , \"module_reset_\" , str(self.port_num))\n        val = self._api_helper.read_txt_file(reset_path)\n        \n        if val is not None:\n            return int(val, 10) == 1\n        else:\n            return False\n\n    def get_rx_los(self):\n        \"\"\"\n        Retrieves the RX LOS (lost-of-signal) status of SFP\n        Returns:\n            A Boolean, True if SFP has RX LOS, False if not.\n            Note : RX LOS status is latched until a call to get_rx_los or a reset.\n        \"\"\"\n\n        rx_los_list = []\n        dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_RX_LOS_STATUS_OFFSET, QSFP_CHANNL_RX_LOS_STATUS_WIDTH) if self.get_presence() else None\n        if dom_channel_monitor_raw is not None:\n                rx_los_data = int(dom_channel_monitor_raw[0], 16)\n                rx_los_list.append(rx_los_data & 0x01 != 0)\n                rx_los_list.append(rx_los_data & 0x02 != 0)\n                rx_los_list.append(rx_los_data & 0x04 != 0)\n                rx_los_list.append(rx_los_data & 0x08 != 0)\n                return rx_los_list\n        else:\n            return [False]*4\n\n\n    def get_tx_fault(self):\n        \"\"\"\n        Retrieves the TX fault status of SFP\n        Returns:\n            A Boolean, True if SFP has TX fault, False if not\n            Note : TX fault status is lached until a call to get_tx_fault or a reset.\n        \"\"\"\n        tx_fault_list = []\n        dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CHANNL_TX_FAULT_STATUS_OFFSET, QSFP_CHANNL_TX_FAULT_STATUS_WIDTH) if self.get_presence() else None\n        if dom_channel_monitor_raw is not None:\n            tx_fault_data = int(dom_channel_monitor_raw[0], 16)\n            tx_fault_list.append(tx_fault_data & 0x01 != 0)\n            tx_fault_list.append(tx_fault_data & 0x02 != 0)\n            tx_fault_list.append(tx_fault_data & 0x04 != 0)\n            tx_fault_list.append(tx_fault_data & 0x08 != 0)\n            return tx_fault_list\n        else:\n            return [False]*4\n\n    def get_tx_disable(self):\n        \"\"\"\n        Retrieves the tx_disable status of this SFP\n        Returns:\n            A Boolean, True if tx_disable is enabled, False if disabled\n        \"\"\"\n        \n        tx_disable_list = []\n    \n        sfpd_obj = sff8436Dom()\n        if sfpd_obj is None:\n            return False\n    \n        dom_control_raw = self.__read_eeprom_specific_bytes(\n            QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n        if dom_control_raw is not None:\n            dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n            tx_disable_list.append(\n                'On' == dom_control_data['data']['TX1Disable']['value'])\n            tx_disable_list.append(\n                'On' == dom_control_data['data']['TX2Disable']['value'])\n            tx_disable_list.append(\n                'On' == dom_control_data['data']['TX3Disable']['value'])\n            tx_disable_list.append(\n                'On' == dom_control_data['data']['TX4Disable']['value'])\n            return tx_disable_list\n        else:\n            return [False]*4\n\n    def get_tx_disable_channel(self):\n        \"\"\"\n        Retrieves the TX disabled channels in this SFP\n        Returns:\n            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent\n            TX channels which have been disabled in this SFP.\n            As an example, a returned value of 0x5 indicates that channel 0\n            and channel 2 have been disabled.\n        \"\"\"\n        tx_disable_list = self.get_tx_disable()\n        if tx_disable_list is None:\n            return 0\n        tx_disabled = 0\n        for i in range(len(tx_disable_list)):\n            if tx_disable_list[i]:\n                tx_disabled |= 1 << i\n        return tx_disabled\n\n    def get_lpmode(self):\n        \"\"\"\n        Retrieves the lpmode (low power mode) status of this SFP\n        Returns:\n            A Boolean, True if lpmode is enabled, False if disabled\n        \"\"\"\n\n        power_set=self.get_power_set()\n        power_override = self.get_power_override()\n        return power_set and power_override\n\n    def get_power_set(self):\n        power_set = False\n        sfpd_obj = sff8436Dom()\n        if sfpd_obj is None:\n            return False\n        dom_control_raw = self.__read_eeprom_specific_bytes(\n            QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n        if dom_control_raw is not None:\n            dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n            power_set = (\n                'On' == dom_control_data['data']['PowerSet']['value'])\n    \n        return power_set\n\n    def get_power_override(self):\n        \"\"\"\n        Retrieves the power-override status of this SFP\n        Returns:\n            A Boolean, True if power-override is enabled, False if disabled\n        \"\"\"\n        power_override = False\n        sfpd_obj = sff8436Dom()\n        if sfpd_obj is None:\n            return False\n\n        dom_control_raw = self.__read_eeprom_specific_bytes(\n                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None\n        if dom_control_raw is not None:\n            dom_control_data = sfpd_obj.parse_control_bytes(dom_control_raw, 0)\n            power_override = (\n                'On' == dom_control_data['data']['PowerOverride']['value'])\n\n        return power_override\n\n    def reset(self):\n        \"\"\"\n        Reset SFP and return all user module settings to their default srate.\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"\n        reset_path = \"{}{}{}\".format(CPLD_I2C_PATH , 'module_reset_' , self.port_num)\n        ret = self._api_helper.write_txt_file(reset_path, 1)\n        if ret is not True:\n            return ret\n\n        time.sleep(0.01)\n        ret = self._api_helper.write_txt_file(reset_path, 0)\n        time.sleep(0.2)\n\n        return ret\n\n    def tx_disable(self, tx_disable):\n        \"\"\"\n        Disable SFP TX for all channels\n        Args:\n            tx_disable : A Boolean, True to enable tx_disable mode, False to disable\n                         tx_disable mode.\n        Returns:\n            A boolean, True if tx_disable is set successfully, False if not\n        \"\"\"\n        if not self.get_presence():\n            return False\n        sysfsfile_eeprom = None\n        try:\n            tx_disable_ctl = 0xf if tx_disable else 0x0\n            buffer = create_string_buffer(1)\n            if sys.version_info[0] >= 3:\n                buffer[0] = tx_disable_ctl\n            else:\n                buffer[0] = chr(tx_disable_ctl)\n            # Write to eeprom\n            sysfsfile_eeprom = open(\n                self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n            sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n            sysfsfile_eeprom.write(buffer[0])\n        except IOError as e:\n            print ('Error: unable to open file: ',str(e))\n            return False\n        finally:\n            if sysfsfile_eeprom is not None:\n                sysfsfile_eeprom.close()\n                time.sleep(0.01)\n        \n        return True\n\n    def tx_disable_channel(self, channel, disable):\n        \"\"\"\n        Sets the tx_disable for specified SFP channels\n        Args:\n            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,\n                      e.g. 0x5 for channel 0 and channel 2.\n            disable : A boolean, True to disable TX channels specified in channel,\n                      False to enable\n        Returns:\n            A boolean, True if successful, False if not\n        \"\"\"        \n        if not self.get_presence():\n            return False\n\n        sysfsfile_eeprom = None\n        try:\n            channel_state = self.get_tx_disable_channel()\n            for i in range(4):\n                channel_mask = (1 << i)\n                if not (channel & channel_mask):\n                    continue\n\n                if disable:\n                    channel_state |= channel_mask\n                else:\n                    channel_state &= ~channel_mask\n\n            buffer = create_string_buffer(1)\n            if sys.version_info[0] >= 3:\n                buffer[0] = channel_state\n            else:\n                buffer[0] = chr(channel_state)\n            # Write to eeprom\n            sysfsfile_eeprom = open(\n                self.port_to_eeprom_mapping[self.port_num], \"r+b\")\n            sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)\n            sysfsfile_eeprom.write(buffer[0])\n        except IOError as e:\n            print ('Error: unable to open file: ', str(e))\n            return False\n        finally:\n            if sysfsfile_eeprom is not None:\n                sysfsfile_eeprom.close()\n                time.sleep(0.01)\n\n        return True\n\n    def set_lpmode(self, lpmode):\n        \"\"\"\n        Sets the lpmode (low power mode) of SFP\n        Args:\n            lpmode: A Boolean, True to enable lpmode, False to disable it\n            Note  : lpmode can be overridden by set_power_override\n        Returns:\n            A boolean, True if lpmode is set successfully, False if not\n        \"\"\"        \n        if lpmode:\n            self.set_power_override(True, True)\n        else:\n            self.set_power_override(False, False)\n    \n        return True\n       \n    def set_power_override(self, power_override, power_set):\n        \"\"\"\n        Sets SFP power level using power_override and power_set\n        Args:\n            power_override :\n                    A Boolean, True to override set_lpmode and use power_set\n                    to control SFP power, False to disable SFP power control\n                    through power_override/power_set and use set_lpmode\n                    to control SFP power.\n            power_set :\n                    Only valid when power_override is True.\n                    A Boolean, True to set SFP to low power mode, False to set\n                    SFP to high power mode.\n        Returns:\n            A boolean, True if power-override and power_set are set successfully,\n            False if not\n        \"\"\"\n       \n        if not self.get_presence():\n            return False\n        try:\n            power_override_bit = (1 << 0) if power_override else 0\n            power_set_bit      = (1 << 1) if power_set else (1 << 3)\n    \n            buffer = create_string_buffer(1)\n            if sys.version_info[0] >= 3:\n                buffer[0] = (power_override_bit | power_set_bit)\n            else:\n                buffer[0] = chr(power_override_bit | power_set_bit)\n            # Write to eeprom\n            with open(self.port_to_eeprom_mapping[self.port_num], \"r+b\") as fd:\n                fd.seek(QSFP_POWEROVERRIDE_OFFSET)\n                fd.write(buffer[0])\n                time.sleep(0.01)\n        except Exception:\n            print ('Error: unable to open file: ', str(e))\n            return False\n\n        return True\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        sfputil_helper = SfpUtilHelper()\n        sfputil_helper.read_porttab_mappings(\n            self.__get_path_to_port_config_file())\n        name = sfputil_helper.logical[self.index] or \"Unknown\"\n        return name\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the device\n        Returns:\n            bool: True if device is present, False if not\n        \"\"\"\n        present_path = \"{}{}{}\".format(CPLD_I2C_PATH , '/module_present_' , self.port_num)\n        val=self._api_helper.read_txt_file(present_path)\n        if val is not None:\n            return int(val, 10)==1\n        else:\n            return False\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return self.get_presence()\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return self.port_num\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return True\n"}, "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n \n \n class Chassis(ChassisBase):\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n \n \n     def __is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def __read_txt_file(self, ", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/chassis.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}], "source": "\n import os try: from sonic_platform_base.chassis_base import ChassisBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=6 NUM_FAN=2 NUM_PSU=2 NUM_THERMAL=3 NUM_QSFP=32 PORT_START=1 PORT_END=34 QSFP_PORT_START=0 QSFP_PORT_END=31 NUM_COMPONENT=2 HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" HOST_CHK_CMD=\"docker > /dev/null 2>&1\" class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self.is_host=self._api_helper.is_host() self.config_data={} self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.__initialize_sfp() self.__initialize_eeprom() def __initialize_sfp(self): from sonic_platform.sfp import Sfp self.QSFP_PORT_START=QSFP_PORT_START self.QSFP_PORT_END=QSFP_PORT_END for index in range(0, PORT_END): if index in range(self.QSFP_PORT_START, self.QSFP_PORT_END +1): sfp_module=Sfp(index, 'QSFP') else: sfp_module=Sfp(index, 'SFP') self._sfp_list.append(sfp_module) self.sfp_module_initialized=True def __initialize_fan(self): from sonic_platform.fan import Fan for fant_index in range(0, NUM_FAN_TRAY): for fan_index in range(0, NUM_FAN): fan=Fan(fant_index, fan_index) self._fan_list.append(fan) def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal for index in range(0, NUM_THERMAL): thermal=Thermal(index) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __initialize_watchdog(self): from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() def __is_host(self): return os.system(HOST_CHK_CMD)==0 def __read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._api_helper.hwsku def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_serial_number(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" return('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp ", "sourceWithComments": "#############################################################################\n# Accton\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\nimport os\n\ntry:\n    from sonic_platform_base.chassis_base import ChassisBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 6\nNUM_FAN = 2\nNUM_PSU = 2\nNUM_THERMAL = 3\nNUM_QSFP = 32\nPORT_START = 1\nPORT_END = 34\nQSFP_PORT_START = 0\nQSFP_PORT_END = 31\nNUM_COMPONENT = 2\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self.is_host = self._api_helper.is_host()\n\n        self.config_data = {}\n\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n        self.__initialize_sfp()\n        self.__initialize_eeprom()\n\n    def __initialize_sfp(self):\n        from sonic_platform.sfp import Sfp\n\n        self.QSFP_PORT_START = QSFP_PORT_START\n        self.QSFP_PORT_END = QSFP_PORT_END\n        for index in range(0, PORT_END):\n            if index in range(self.QSFP_PORT_START, self.QSFP_PORT_END + 1):\n                sfp_module = Sfp(index, 'QSFP')\n            else:\n                sfp_module = Sfp(index, 'SFP')\n            self._sfp_list.append(sfp_module)\n        self.sfp_module_initialized = True\n\n    def __initialize_fan(self):\n        from sonic_platform.fan import Fan\n        for fant_index in range(0, NUM_FAN_TRAY):\n            for fan_index in range(0, NUM_FAN):\n                fan = Fan(fant_index, fan_index)\n                self._fan_list.append(fan)\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __initialize_watchdog(self):\n        from sonic_platform.watchdog import Watchdog\n        self._watchdog = Watchdog()\n\n\n    def __is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def __read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n\n        return self._api_helper.hwsku\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_serial_number(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n\n\n        return ('REBOOT_CAUSE_NON_HARDWARE', sw_reboot_cause)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n"}, "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import shlex\n-import subprocess\n-\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 3, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py", "badparts": ["import shlex", "import subprocess"], "goodparts": []}, {"diff": "\n         self.index = component_index\n         self.name = self.get_name()        \n \n-    def __run_command(self, command):\n-        # Run bash command and print output to stdout\n-        try:\n-            process = subprocess.Popen(\n-                shlex.split(command), stdout=subprocess.PIPE)\n-            while True:\n-                output = process.stdout.readline()\n-                if output == '' and process.poll() is not None:\n-                    break\n-            rc = process.poll()\n-            if rc != 0:\n-                return False\n-        except Exception:\n-            return False\n-        return True\n-\n     def __get_bios_version(self):\n         # Retrieves the BIOS firm", "add": 0, "remove": 16, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/component.py", "badparts": ["    def __run_command(self, command):", "        try:", "            process = subprocess.Popen(", "                shlex.split(command), stdout=subprocess.PIPE)", "            while True:", "                output = process.stdout.readline()", "                if output == '' and process.poll() is not None:", "                    break", "            rc = process.poll()", "            if rc != 0:", "                return False", "        except Exception:", "            return False", "        return True"], "goodparts": []}], "source": "\n import shlex import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"3-0060\" } SYSFS_PATH=\"/sys/bus/i2c/devices/\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"BIOS\", \"Basic Input/Output System\") ] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index=0): self._api_helper=APIHelper() ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_path=\"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version') cpld_version_raw=self._api_helper.read_txt_file(cpld_path) cpld_version[cpld_name]=\"{}\".format(int(cpld_version_raw,16)) except Exception as e: print('Get exception when read cpld') cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError ", "sourceWithComments": "#############################################################################\n# Accton\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport shlex\nimport subprocess\n\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"3-0060\"\n}\nSYSFS_PATH = \"/sys/bus/i2c/devices/\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_LIST= [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n\n]\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index=0):\n        self._api_helper=APIHelper()\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()        \n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_path = \"{}{}{}\".format(SYSFS_PATH, CPLD_ADDR_MAPPING[cpld_name], '/version')\n                cpld_version_raw= self._api_helper.read_txt_file(cpld_path)               \n                cpld_version[cpld_name] = \"{}\".format(int(cpld_version_raw,16))\n            except Exception as e:\n                print('Get exception when read cpld')\n                cpld_version[cpld_name] = 'None'\n\n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()           \n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n"}, "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n from mmap import *\n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        return subprocess.call(HOST_CHK_CMD) == 0\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(HOST_CHK_CMD) == 0"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except Exception:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n", "add": 0, "remove": 20, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "        status = True", "        result = \"\"", "        try:", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except Exception:", "            status = False", "        return status, result", "    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except Exception:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n             return False\n         return True\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except Exception:\n-            status = False\n-  ", "add": 0, "remove": 49, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/helper.py", "badparts": ["    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except Exception:", "            status = False"], "goodparts": []}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except Exception: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except Exception: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except Exception: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except IOError: return False return True def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except Exception: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except Exception:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except Exception:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except Exception:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except IOError:\n            return False\n        return True\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except Exception:\n            status = False\n        return status, result\n"}, "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n class Sfp(SfpBase):\n     \"\"\"Platform-specific Sfp class\"\"\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n     PLATFORM = \"x86_64-accton_as9726_32d-r0\"\n     HWSKU = \"Accton-AS9726-32D\"\n \n", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         return True\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFOR", "add": 1, "remove": 1, "filename": "/device/accton/x86_64-accton_as9726_32d-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}]}, "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py": {"changes": [{"diff": "\n #############################################################################\n \n try:\n-    import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py", "badparts": ["    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         if self.name == \"BIOS\":\n             fw_version = self.__get_bios_version()\n         elif \"CPLD\" in self.name:\n-            cmd = \"i2cget -f -y {0} {1} 0x1\".format(self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1])\n-            status, value = subprocess.getstatusoutput(cmd)\n+            cmd = [\"i2cget\", \"-f\", \"-y\", self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1], \"0x1\"]\n+            status, value = getstatusoutput_noshell(cmd)\n             if not status:\n                 ", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/sonic_platform/component.py", "badparts": ["            cmd = \"i2cget -f -y {0} {1} 0x1\".format(self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1])", "            status, value = subprocess.getstatusoutput(cmd)"], "goodparts": ["            cmd = [\"i2cget\", \"-f\", \"-y\", self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1], \"0x1\"]", "            status, value = getstatusoutput_noshell(cmd)"]}], "source": "\n try: import subprocess from sonic_platform_base.component_base import ComponentBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_LIST=[ (\"CPLD1\", \"CPLD 1\"), (\"BIOS\", \"Basic Input/Output System\") ] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" def __init__(self, component_index): self.index=component_index self.name=self.get_name() self.cpld_mapping={ 0:['3', '0x60'] } def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cmd=\"i2cget -f -y{0}{1} 0x1\".format(self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1]) status, value=subprocess.getstatusoutput(cmd) if not status: fw_version=value.rstrip() return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" raise NotImplementedError ", "sourceWithComments": "#!/usr/bin/env python\n\n#############################################################################\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the component information (such as CPLD, FPGA, BIOS etc) which are available in the platform\n#\n#############################################################################\n\ntry:\n    import subprocess\n    from sonic_platform_base.component_base import ComponentBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\n#COMPONENT_NAME_LIST = [\"CPLD1\"]\nCOMPONENT_LIST =  [\n   (\"CPLD1\", \"CPLD 1\"),\n   (\"BIOS\", \"Basic Input/Output System\")\n]\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n\n    def __init__(self, component_index):\n        self.index = component_index\n        self.name = self.get_name()\n        self.cpld_mapping = {\n                0: ['3', '0x60']                \n            }\n\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n    \n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n    \n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cmd = \"i2cget -f -y {0} {1} 0x1\".format(self.cpld_mapping[self.index][0], self.cpld_mapping[self.index][1])\n            status, value = subprocess.getstatusoutput(cmd)\n            if not status:\n                fw_version = value.rstrip()\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        raise NotImplementedError\n"}, "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py": {"changes": [{"diff": "\n     import logging.config\n     import logging.handlers\n     import time\n-    import subprocess\n     from as4630_54pe.fanutil import FanUtil\n     from as4630_54pe.thermalutil import ThermalUtil\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py", "badparts": ["    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         if temp[0] >= 70000: #LM75-48    \n             #critical case*/\n             logging.critical('Alarm-Critical for temperature critical is detected, reset DUT')\n-            cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2);\n-            status, output = subprocess.getstatusoutput(cmd_str)\n+            status, output = getstatusoutput_noshell(cmd_str)\n                 \n         #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_state, fan_pol", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_monitor.py", "badparts": ["            cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\"", "            status, output = subprocess.getstatusoutput(cmd_str)"], "goodparts": ["            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]", "            status, output = getstatusoutput_noshell(cmd_str)"]}], "source": "\n try: import getopt import sys import logging import logging.config import logging.handlers import time import subprocess from as4630_54pe.fanutil import FanUtil from as4630_54pe.thermalutil import ThermalUtil except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as4630_54pe_monitor' global log_file global log_level class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False fan_policy_state=0 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0, 0] temp_test_data=0 test_temp_revert=0 class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 for i in range(0, len(policy)): if(temp > policy[i][2]): if temp <=policy[i][3]: state=i return state def manage_fans(self): global fan_policy_state global fan_fail global test_temp global test_temp_list global alarm_state global temp_test_data global test_temp_revert LEVEL_FAN_MIN=0 LEVEL_FAN_NORMAL=1 LEVEL_FAN_MID=2 LEVEL_FAN_HIGH=3 LEVEL_TEMP_CRITICAL=4 fan_policy={ LEVEL_FAN_MIN: [50, 8, 0, 140000], LEVEL_FAN_NORMAL: [62, 10, 140000, 150000], LEVEL_FAN_MID: [75, 12, 150000, 160000], LEVEL_FAN_HIGH: [88, 14, 160000, 240000], LEVEL_TEMP_CRITICAL:[100, 16, 240000, 300000], } temp=[0, 0, 0] temp_fail=0 thermal=ThermalUtil() fan=FanUtil() ori_duty_cycle=fan.get_fan_duty_cycle() new_duty_cycle=0 if test_temp==0: for i in range(0,3): temp[i]=thermal._get_thermal_val(i+1) if temp[i]==0 or temp[i]==None: temp_fail=1 logging.warning(\"Get temp-%d fail\", i); return False else: if test_temp_revert==0: temp_test_data=temp_test_data+2000 else: temp_test_data=temp_test_data-2000 for i in range(0,3): temp[i]=test_temp_list[i]+temp_test_data fan_fail=0 temp_val=0 for i in range(0,3): if temp[i]==None: break temp_val+=temp[i] for i in range(fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1): if fan.get_fan_status(i)==0: new_pwm=100 logging.warning('Fan_%d fail, set pwm to 100',i) if test_temp==0: fan_fail=1 fan.set_fan_duty_cycle(new_pwm) break else: fan_fail=0 ori_state=fan_policy_state fan_policy_state=self.get_state_from_fan_policy(temp_val, fan_policy) if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN: logging.error(\"Get error fan current_state\\n\"); return 0 if fan_fail==0 and ori_duty_cycle!=fan_policy[fan_policy_state][0]: new_duty_cycle=fan_policy[fan_policy_state][0]; fan.set_fan_duty_cycle(new_duty_cycle) if temp[0] >=70000: logging.critical('Alarm-Critical for temperature critical is detected, reset DUT') cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\" time.sleep(2); status, output=subprocess.getstatusoutput(cmd_str) if ori_state < LEVEL_FAN_HIGH: if fan_policy_state >=LEVEL_FAN_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if fan_policy_state < LEVEL_FAN_MID: if alarm_state==1: logging.info('Alarm for temperature high is cleared') alarm_state=0 return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv,'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv)!=5: print(\"temp test, need input three temp\") return 0 i=0 for x in range(2, 5): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) fan=FanUtil() fan.set_fan_duty_cycle(50) print(\"set default fan speed to 50%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(10) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python\n# -*- coding: utf-8 -*\n# Copyright (c) 2019 Edgecore Networks Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n# THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR\n# CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT\n# LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS\n# FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.\n#\n# See the Apache Version 2.0 License for specific language governing\n# permissions and limitations under the License.\n# \n# HISTORY:\n#    mm/dd/yyyy (A.D.)#   \n#    10/24/2019:Jostar create for as4630_54pe thermal plan\n# ------------------------------------------------------------------\n\ntry:\n    import getopt\n    import sys\n    import logging\n    import logging.config\n    import logging.handlers\n    import time\n    import subprocess\n    from as4630_54pe.fanutil import FanUtil\n    from as4630_54pe.thermalutil import ThermalUtil\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as4630_54pe_monitor'\n\nglobal log_file\nglobal log_level\n\n \n\n\n\n# Temperature Policy\n# If any fan fail , please set fan speed register to 16\n# The max value of fan speed register is 14\n#  LM77(48)+LM75(4B)+LM75(4A)  >  140, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  >  150, Set 12\n#  LM77(48)+LM75(4B)+LM75(4A)  >  160, Set 14\n#  LM77(48)+LM75(4B)+LM75(4A)  <  140, Set 8\n#  LM77(48)+LM75(4B)+LM75(4A)  <  150, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  <  160, Set 12\n#  Reset DUT:LM77(48)>=70C\n#\nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n \n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n     \n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args: # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\nfan_policy_state=0\nfan_fail=0\nalarm_state = 0 #0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0, 0]\ntemp_test_data=0\ntest_temp_revert=0\n# Make a class we can use to capture stdout and sterr in the log\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm=0\n    ori_pwm = 0\n    default_pwm=0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format= '[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = handler = logging.handlers.SysLogHandler(address = '/dev/log')\n        sys_handler.setLevel(logging.WARNING)       \n        logging.getLogger('').addHandler(sys_handler)\n          \n    def get_state_from_fan_policy(self, temp, policy):\n        state=0\n        for i in range(0, len(policy)):\n            if (temp > policy[i][2]): #temp_down\n                if temp <= policy[i][3]: #temp_up\n                    state =i\n                            \n        return state\n\n    def manage_fans(self):\n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list        \n        global alarm_state\n        global temp_test_data  \n        global test_temp_revert      \n        LEVEL_FAN_MIN=0\n        LEVEL_FAN_NORMAL=1   \n        LEVEL_FAN_MID=2\n        LEVEL_FAN_HIGH=3\n        LEVEL_TEMP_CRITICAL=4\n        fan_policy = {\n           LEVEL_FAN_MIN:       [50,   8, 0,      140000],\n           LEVEL_FAN_NORMAL:    [62,  10, 140000, 150000],\n           LEVEL_FAN_MID:       [75,  12, 150000, 160000],\n           LEVEL_FAN_HIGH:      [88,  14, 160000, 240000],\n           LEVEL_TEMP_CRITICAL: [100, 16, 240000, 300000],\n        }\n        temp = [0, 0 , 0]\n        temp_fail=0\n        thermal = ThermalUtil()\n        fan = FanUtil()\n        ori_duty_cycle=fan.get_fan_duty_cycle()\n        new_duty_cycle=0\n        \n        if test_temp==0:\n            for i in range(0,3):\n                temp[i]=thermal._get_thermal_val(i+1)\n                if temp[i]==0 or temp[i]==None:\n                    temp_fail=1\n                    logging.warning(\"Get temp-%d fail\", i);\n                    return False\n        else:\n            if test_temp_revert==0:\n                temp_test_data=temp_test_data+2000\n            else:            \n                temp_test_data=temp_test_data-2000\n                \n            for i in range(0,3):\n                temp[i]=test_temp_list[i]+temp_test_data\n            fan_fail=0\n\n        temp_val=0 \n        for i in range(0,3):\n            if temp[i]==None:\n                break\n            temp_val+=temp[i]\n        \n        #Check Fan status\n        for i in range (fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1):\n            if fan.get_fan_status(i)==0:\n                new_pwm=100\n                logging.warning('Fan_%d fail, set pwm to 100',i)                \n                if test_temp==0:\n                    fan_fail=1\n                    fan.set_fan_duty_cycle(new_pwm)\n                    break\n            else:\n                fan_fail=0\n        \n        ori_state=fan_policy_state        \n        fan_policy_state=self.get_state_from_fan_policy(temp_val, fan_policy)\n        \n        if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN:\n            logging.error(\"Get error fan current_state\\n\");\n            return 0\n    \n        #Decision : Decide new fan pwm percent.\n        if fan_fail==0 and ori_duty_cycle!=fan_policy[fan_policy_state][0]:\n            new_duty_cycle = fan_policy[fan_policy_state][0];\n            fan.set_fan_duty_cycle(new_duty_cycle)\n\n        if temp[0] >= 70000: #LM75-48    \n            #critical case*/\n            logging.critical('Alarm-Critical for temperature critical is detected, reset DUT')\n            cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\"\n            time.sleep(2);\n            status, output = subprocess.getstatusoutput(cmd_str)\n                \n        #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_state, fan_policy_state, temp_val)\n        \n        if ori_state < LEVEL_FAN_HIGH:            \n           if fan_policy_state >= LEVEL_FAN_HIGH:\n               if alarm_state==0:\n                   logging.warning('Alarm for temperature high is detected')\n                   alarm_state=1\n                  \n        if fan_policy_state < LEVEL_FAN_MID:\n            if alarm_state==1:\n                logging.info('Alarm for temperature high is cleared')\n                alarm_state=0\n                \n        return True\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv,'hdlt:',['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg            \n        \n        if sys.argv[1]== '-t':\n            if len(sys.argv)!=5:\n                print(\"temp test, need input three temp\")\n                return 0\n            \n            i=0\n            for x in range(2, 5):\n               test_temp_list[i]= int(sys.argv[x])*1000\n               i=i+1\n            test_temp = 1   \n            log_level = logging.DEBUG\n            print(test_temp_list)                       \n    \n    fan = FanUtil()\n    fan.set_fan_duty_cycle(50)\n    print(\"set default fan speed to 50%\")\n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(10) #10sec\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n\n"}, "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py": {"changes": [{"diff": "\n             # Critical: Either all the fans are faulty or they are removed, shutdown the system\n             logging.critical('Alarm for all fan faulty/absent is detected')\n             logging.critical(\"Alarm for all fan faulty/absent is detected, reset DUT\")\n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2)\n-            subprocess.getstatusoutput('sync; sync; sync')\n-            subprocess.getstatusoutput(cmd_str)\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell(cmd_str)\n         elif sum(fan_fail_list) != 0:\n             # Set the 100% speed only for first fan failure detection\n             logging.warning('Fan_{} failed, set remaining fan speed to 100%'.format(\n", "add": 5, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py", "badparts": ["            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"", "            subprocess.getstatusoutput('sync; sync; sync')", "            subprocess.getstatusoutput(cmd_str)"], "goodparts": ["            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell(cmd_str)"]}, {"diff": "\n             as4630_54pe_set_fan_speed(new_duty_cycle)\n             if test_temp == 1:\n                 time.sleep(3)\n-                status, output = subprocess.getstatusoutput('pddf_fanutil getspeed')\n+                status, output = getstatusoutput_noshell(['pddf_fanutil', 'getspeed'])\n                 logging.debug('\\n%s\\n', output)\n \n         if temp[0] >= 70000:  # LM77-48\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py", "badparts": ["                status, output = subprocess.getstatusoutput('pddf_fanutil getspeed')"], "goodparts": ["                status, output = getstatusoutput_noshell(['pddf_fanutil', 'getspeed'])"]}, {"diff": "\n             if status:\n                 logging.warning('Reboot cause file not updated. {}'.format(output))\n \n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n-            subprocess.getstatusoutput('sync; sync; sync')\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n+            getstatusoutput_noshell('sync')\n             time.sleep(3)\n-            subprocess.getstatusoutput(cmd_str)\n+            getstatusoutput_noshell(cmd_str)\n \n         logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n', ori_state", "add": 5, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/accton_as4630_54pe_pddf_monitor.py", "badparts": ["            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"", "            subprocess.getstatusoutput('sync; sync; sync')", "            subprocess.getstatusoutput(cmd_str)"], "goodparts": ["            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell('sync')", "            getstatusoutput_noshell(cmd_str)"]}], "source": "\n try: import os import sys import getopt import subprocess import logging import logging.handlers import time from sonic_platform import platform except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as4630_54pe_pddf_monitor' class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False def as4630_54pe_set_fan_speed(pwm): if pwm < 0 or pwm > 100: print(\"Error: Wrong duty cycle value %d\" %(pwm)) platform_chassis.get_fan(0).set_speed(pwm) platform_chassis.get_fan(2).set_speed(pwm) return 0 fan_policy_state=0 fan_fail=0 fan_fail_list=[0, 0, 0] alarm_state=0 test_temp=0 simulate_temp_decline=0 test_temp_list=[0, 0, 0] temp_test_data=0 test_temp_revert=0 platform_chassis=None class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(asctime)-15s %(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 for i in range(0, len(policy)): if(temp > policy[i][2]): if temp <=policy[i][3]: state=i return state def manage_fans(self): global fan_policy_state global fan_fail global fan_fail_list global test_temp global simulate_temp_decline global test_temp_list global alarm_state global temp_test_data global test_temp_revert global platform_chassis NUM_FANS=3 LEVEL_FAN_MIN=0 LEVEL_FAN_NORMAL=1 LEVEL_FAN_MID=2 LEVEL_FAN_HIGH=3 LEVEL_TEMP_CRITICAL=4 fan_policy={ LEVEL_FAN_MIN: [50, 8, 0, 140000], LEVEL_FAN_NORMAL: [62, 10, 140000, 150000], LEVEL_FAN_MID: [75, 12, 150000, 160000], LEVEL_FAN_HIGH: [88, 14, 160000, 240000], LEVEL_TEMP_CRITICAL:[100, 16, 240000, 300000], } temp=[0, 0, 0] ori_duty_cycle=platform_chassis.get_fan(0).get_speed() new_duty_cycle=0 if test_temp==0: for i in range(0, 3): temp[i]=platform_chassis.get_thermal(i).get_temperature() if temp[i]==0.0 or temp[i] is None: logging.warning(\"Get temp-%d fail\", i) return False temp[i]=int(temp[i]*1000) else: if test_temp_revert==0: temp_test_data=temp_test_data+2000 else: if temp_test_data > 0: temp_test_data=temp_test_data-2000 else: sys.exit('Simulation Ends !') for i in range(0, 3): temp[i]=test_temp_list[i]+temp_test_data fan_fail=0 temp_val=0 for i in range(0, 3): if temp[i] is None: break temp_val +=temp[i] for i in range(NUM_FANS): if not platform_chassis.get_fan(i).get_status(): if test_temp==0: fan_fail=1 if fan_fail_list[i]==0: fan_fail_list[i]=1 else: if fan_fail_list[i]==1: fan_fail_list[i]=0 if sum(fan_fail_list)==NUM_FANS: logging.critical('Alarm for all fan faulty/absent is detected') logging.critical(\"Alarm for all fan faulty/absent is detected, reset DUT\") cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\" time.sleep(2) subprocess.getstatusoutput('sync; sync; sync') subprocess.getstatusoutput(cmd_str) elif sum(fan_fail_list) !=0: logging.warning('Fan_{} failed, set remaining fan speed to 100%'.format( ' Fan_'.join(str(item+1) for item, val in enumerate(fan_fail_list) if val==1))) new_pwm=100 as4630_54pe_set_fan_speed(new_pwm) else: fan_fail=0 ori_state=fan_policy_state fan_policy_state=self.get_state_from_fan_policy(temp_val, fan_policy) if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN: logging.error(\"Get error fan current_state\\n\") return 0 if fan_fail==0 and ori_duty_cycle !=fan_policy[fan_policy_state][0]: new_duty_cycle=fan_policy[fan_policy_state][0] as4630_54pe_set_fan_speed(new_duty_cycle) if test_temp==1: time.sleep(3) status, output=subprocess.getstatusoutput('pddf_fanutil getspeed') logging.debug('\\n%s\\n', output) if temp[0] >=70000: logging.critical('Alarm for temperature critical is detected') logging.critical(\"Alarm-Critical for temperature critical is detected, reset DUT\") status, output=subprocess.getstatusoutput( 'echo \"Thermal Overload: Other\" > /host/reboot-cause/reboot-cause.txt') status, output=subprocess.getstatusoutput( 'echo \"System rebooted because alarm for critical temperature(70 C) is detected[Time: $(eval date)]\" >> /host/reboot-cause/reboot-cause.txt') if status: logging.warning('Reboot cause file not updated.{}'.format(output)) cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\" subprocess.getstatusoutput('sync; sync; sync') time.sleep(3) subprocess.getstatusoutput(cmd_str) logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n', ori_state, fan_policy_state, temp_val) if ori_state < LEVEL_FAN_HIGH: if fan_policy_state >=LEVEL_FAN_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if simulate_temp_decline==1: logging.info('Temperature decline simulation is ON. Testing temperature will decrease now') test_temp_revert=1 if fan_policy_state < LEVEL_FAN_MID: if alarm_state==1: logging.warning('Alarm for temperature high is cleared') alarm_state=0 return True def main(argv): if not os.path.exists('/usr/share/sonic/platform/pddf_support'): print(\"PDDF mode is not enabled\") return 0 log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp global simulate_temp_decline if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv, 'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv) !=6: print(\"temp test, need input temp decline option and three temp values\") return 0 i=0 simulate_temp_decline=int(sys.argv[2]) for x in range(3, 6): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) global platform_chassis platform_chassis=platform.Platform().get_chassis() as4630_54pe_set_fan_speed(50) monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(10) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*\n# Copyright (c) 2019 Edgecore Networks Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n# THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR\n# CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT\n# LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS\n# FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.\n#\n# See the Apache Version 2.0 License for specific language governing\n# permissions and limitations under the License.\n#\n# HISTORY:\n#    mm/dd/yyyy (A.D.)#\n#    10/24/2019:Jostar create for as4630_54pe thermal plan\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import sys\n    import getopt\n    import subprocess\n    import logging\n    import logging.handlers\n    import time\n    from sonic_platform import platform\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as4630_54pe_pddf_monitor'\n\n\n\n\n\n# Temperature Policy\n# If any fan fail , please set fan speed register to 16\n# The max value of fan speed register is 14\n#  LM77(48)+LM75(4B)+LM75(4A)  >  140, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  >  150, Set 12\n#  LM77(48)+LM75(4B)+LM75(4A)  >  160, Set 14\n#  LM77(48)+LM75(4B)+LM75(4A)  <  140, Set 8\n#  LM77(48)+LM75(4B)+LM75(4A)  <  150, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  <  160, Set 12\n#  Reset DUT:LM77(48)>=70C\n#\nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n\n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n\n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args:  # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\n\ndef as4630_54pe_set_fan_speed(pwm):\n    # This platform has 2 fans controlled by one register on CPLD and 3rd fan by another register\n    # Hence, we need to change the speed for all\n    if pwm < 0 or pwm > 100:\n        print(\"Error: Wrong duty cycle value %d\" % (pwm))\n    platform_chassis.get_fan(0).set_speed(pwm)\n    platform_chassis.get_fan(2).set_speed(pwm)\n   \n    return 0\n\n\nfan_policy_state = 0\nfan_fail = 0\nfan_fail_list = [0, 0, 0]\nalarm_state = 0  # 0->default or clear, 1-->alarm detect\ntest_temp = 0\nsimulate_temp_decline = 0\ntest_temp_list = [0, 0, 0]\ntemp_test_data = 0\ntest_temp_revert = 0\nplatform_chassis = None\n# Make a class we can use to capture stdout and sterr in the log\n\n\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm = 0\n    ori_pwm = 0\n    default_pwm = 0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format='[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(asctime)-15s %(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = logging.handlers.SysLogHandler(address='/dev/log')\n        sys_handler.setLevel(logging.WARNING)\n        logging.getLogger('').addHandler(sys_handler)\n\n    def get_state_from_fan_policy(self, temp, policy):\n        state = 0\n        for i in range(0, len(policy)):\n            if (temp > policy[i][2]):  # temp_down\n                if temp <= policy[i][3]:  # temp_up\n                    state = i\n\n        return state\n\n    def manage_fans(self):\n        global fan_policy_state\n        global fan_fail\n        global fan_fail_list\n        global test_temp\n        global simulate_temp_decline\n        global test_temp_list\n        global alarm_state\n        global temp_test_data\n        global test_temp_revert\n        global platform_chassis\n        NUM_FANS = 3\n        LEVEL_FAN_MIN = 0\n        LEVEL_FAN_NORMAL = 1\n        LEVEL_FAN_MID = 2\n        LEVEL_FAN_HIGH = 3\n        LEVEL_TEMP_CRITICAL = 4\n        fan_policy = {\n            LEVEL_FAN_MIN:       [50,   8, 0,      140000],\n            LEVEL_FAN_NORMAL:    [62,  10, 140000, 150000],\n            LEVEL_FAN_MID:       [75,  12, 150000, 160000],\n            LEVEL_FAN_HIGH:      [88,  14, 160000, 240000],\n            LEVEL_TEMP_CRITICAL: [100, 16, 240000, 300000],\n        }\n        temp = [0, 0, 0]\n        \n        #thermal = ThermalUtil()\n        #fan = FanUtil()\n        # Supposedly all the fans are set with same duty cycle\n        ori_duty_cycle = platform_chassis.get_fan(0).get_speed()\n        new_duty_cycle = 0\n\n        if test_temp == 0:\n            for i in range(0, 3):\n                temp[i] = platform_chassis.get_thermal(i).get_temperature()\n                if temp[i] == 0.0 or temp[i] is None:\n                    \n                    logging.warning(\"Get temp-%d fail\", i)\n                    return False\n                temp[i] = int(temp[i]*1000)\n        else:\n            if test_temp_revert == 0:\n                temp_test_data = temp_test_data+2000\n            else:\n                if temp_test_data > 0:\n                    temp_test_data = temp_test_data-2000\n                else:\n                    # Stop the simulation\n                    sys.exit('Simulation Ends !')\n\n            for i in range(0, 3):\n                temp[i] = test_temp_list[i]+temp_test_data\n            fan_fail = 0\n\n        temp_val = 0\n        for i in range(0, 3):\n            if temp[i] is None:\n                break\n            temp_val += temp[i]\n\n        # Check Fan status\n        for i in range(NUM_FANS):\n            if not platform_chassis.get_fan(i).get_status():\n                if test_temp == 0:\n                    fan_fail = 1\n                    if fan_fail_list[i] == 0:\n                        fan_fail_list[i] = 1\n            else:\n                if fan_fail_list[i] == 1:\n                    fan_fail_list[i] = 0\n\n        if sum(fan_fail_list) == NUM_FANS:\n            # Critical: Either all the fans are faulty or they are removed, shutdown the system\n            logging.critical('Alarm for all fan faulty/absent is detected')\n            logging.critical(\"Alarm for all fan faulty/absent is detected, reset DUT\")\n            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n            time.sleep(2)\n            subprocess.getstatusoutput('sync; sync; sync')\n            subprocess.getstatusoutput(cmd_str)\n        elif sum(fan_fail_list) != 0:\n            # Set the 100% speed only for first fan failure detection\n            logging.warning('Fan_{} failed, set remaining fan speed to 100%'.format(\n                ' Fan_'.join(str(item+1) for item, val in enumerate(fan_fail_list) if val == 1)))\n            new_pwm = 100\n            as4630_54pe_set_fan_speed(new_pwm)\n        else:\n            fan_fail = 0\n\n        ori_state = fan_policy_state\n        fan_policy_state = self.get_state_from_fan_policy(temp_val, fan_policy)\n\n        if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN:\n            logging.error(\"Get error fan current_state\\n\")\n            return 0\n\n        # Decision : Decide new fan pwm percent.\n        if fan_fail == 0 and ori_duty_cycle != fan_policy[fan_policy_state][0]:\n            new_duty_cycle = fan_policy[fan_policy_state][0]\n            as4630_54pe_set_fan_speed(new_duty_cycle)\n            if test_temp == 1:\n                time.sleep(3)\n                status, output = subprocess.getstatusoutput('pddf_fanutil getspeed')\n                logging.debug('\\n%s\\n', output)\n\n        if temp[0] >= 70000:  # LM77-48\n            # critical case*/\n            logging.critical('Alarm for temperature critical is detected')\n            logging.critical(\"Alarm-Critical for temperature critical is detected, reset DUT\")\n            # Update the reboot cause file to reflect that critical temperature\n            # has been crossed. Upon next boot, the contents of this file will\n            # be used to determine the cause of the previous reboot\n            status, output = subprocess.getstatusoutput(\n                'echo \"Thermal Overload: Other\" > /host/reboot-cause/reboot-cause.txt')\n            status, output = subprocess.getstatusoutput(\n                'echo \"System rebooted because alarm for critical temperature (70 C) is detected [Time: $(eval date)]\" >> /host/reboot-cause/reboot-cause.txt')\n            if status:\n                logging.warning('Reboot cause file not updated. {}'.format(output))\n\n            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n            subprocess.getstatusoutput('sync; sync; sync')\n            time.sleep(3)\n            subprocess.getstatusoutput(cmd_str)\n\n        logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n', ori_state, fan_policy_state, temp_val)\n\n        if ori_state < LEVEL_FAN_HIGH:\n            if fan_policy_state >= LEVEL_FAN_HIGH:\n                if alarm_state == 0:\n                    logging.warning('Alarm for temperature high is detected')\n                    alarm_state = 1\n                    # Add a mechanism to decrease the test_temp values\n                    if simulate_temp_decline == 1:\n                        logging.info('Temperature decline simulation is ON. Testing temperature will decrease now')\n                        test_temp_revert = 1\n\n        if fan_policy_state < LEVEL_FAN_MID:\n            if alarm_state == 1:\n                logging.warning('Alarm for temperature high is cleared')\n                alarm_state = 0\n\n        return True\n\n\ndef main(argv):\n    # Check if PDDF mode is enabled\n    if not os.path.exists('/usr/share/sonic/platform/pddf_support'):\n        print(\"PDDF mode is not enabled\")\n        return 0\n\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    global simulate_temp_decline\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv, 'hdlt:', ['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg\n\n        if sys.argv[1] == '-t':\n            if len(sys.argv) != 6:\n                print(\"temp test, need input temp decline option and three temp values\")\n                return 0\n\n            i = 0\n            simulate_temp_decline = int(sys.argv[2])\n            for x in range(3, 6):\n                test_temp_list[i] = int(sys.argv[x])*1000\n                i = i+1\n            test_temp = 1\n            log_level = logging.DEBUG\n            print(test_temp_list)\n\n    global platform_chassis\n    platform_chassis = platform.Platform().get_chassis()\n\n    as4630_54pe_set_fan_speed(50)\n    \n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(10)  # 10sec\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n"}, "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import commands\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Disable as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Disable as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Stop as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"clean\"])\n     if status:\n-        print \"accton_as4630_54pe_util.py clean command failed %d\"%status\n+        print(\"accton_as4630_54pe_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Stop pddf-platform-init.service along with other platform serives failed %d\"%status\n+        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status\n+        print(\"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status)\n         return False\n \n     return True\n     \n def start_platform_svc():\n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"install\"])\n     if status:\n-        print \"accton_as4630_54pe_util.py install  command failed %d\"%status\n+        print(\"accton_as4630_54pe_util.py install  command failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-fan.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-psu.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Enable as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Enable as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor.service\"])\n     if status:\n-        print \"Start as4630-54pe-platform-monitor.service failed %d\"%status\n+        print(\"Start as4630-54pe-platform-monitor.service failed %d\"%status)\n         return False\n \n     return True\n \n def start_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Start pddf-platform-init.service failed %d\"%status\n+        print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n+        print(\"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status)\n         return False\n     \n     return True\n \n def stop_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n-        print \"Stop pddf-platform-init.service failed %d\"%status\n+        print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])\n     if status:\n-        print \"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n+        print(\"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status)\n        ", "add": 41, "remove": 41, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54pe/utils/pddf_switch_svc.py", "badparts": ["import commands", "    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-fan.service\")", "        print \"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-fan.service\")", "        print \"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-psu.service\")", "        print \"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-psu.service\")", "        print \"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor.service\")", "        print \"Disable as4630-54pe-platform-monitor.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor.service\")", "        print \"Stop as4630-54pe-platform-monitor.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py clean\")", "        print \"accton_as4630_54pe_util.py clean command failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")", "        print \"Stop pddf-platform-init.service along with other platform serives failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")", "        print \"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status", "    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py install\")", "        print \"accton_as4630_54pe_util.py install  command failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-fan.service\")", "        print \"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-fan.service\")", "        print \"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-psu.service\")", "        print \"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-psu.service\")", "        print \"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor.service\")", "        print \"Enable as4630-54pe-platform-monitor.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor.service\")", "        print \"Start as4630-54pe-platform-monitor.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")", "        print \"Start pddf-platform-init.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-pddf-platform-monitor.service\")", "        print \"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")", "        print \"Stop pddf-platform-init.service failed %d\"%status", "    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")", "        print \"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-fan.service\"])", "        print(\"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-fan.service\"])", "        print(\"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor-psu.service\"])", "        print(\"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor-psu.service\"])", "        print(\"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as4630-54pe-platform-monitor.service\"])", "        print(\"Disable as4630-54pe-platform-monitor.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-platform-monitor.service\"])", "        print(\"Stop as4630-54pe-platform-monitor.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"clean\"])", "        print(\"accton_as4630_54pe_util.py clean command failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])", "        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])", "        print(\"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as4630_54pe_util.py\", \"install\"])", "        print(\"accton_as4630_54pe_util.py install  command failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-fan.service\"])", "        print(\"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-fan.service\"])", "        print(\"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor-psu.service\"])", "        print(\"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor-psu.service\"])", "        print(\"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as4630-54pe-platform-monitor.service\"])", "        print(\"Enable as4630-54pe-platform-monitor.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-platform-monitor.service\"])", "        print(\"Start as4630-54pe-platform-monitor.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])", "        print(\"Start pddf-platform-init.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as4630-54pe-pddf-platform-monitor.service\"])", "        print(\"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])", "        print(\"Stop pddf-platform-init.service failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as4630-54pe-pddf-platform-monitor.service\"])", "        print(\"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status)"]}], "source": "\n import commands def check_pddf_support(): return True def stop_platform_svc(): status, output=commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-fan.service\") if status: print \"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-fan.service\") if status: print \"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-psu.service\") if status: print \"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-psu.service\") if status: print \"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor.service\") if status: print \"Disable as4630-54pe-platform-monitor.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor.service\") if status: print \"Stop as4630-54pe-platform-monitor.service failed %d\"%status return False status, output=commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py clean\") if status: print \"accton_as4630_54pe_util.py clean command failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print \"Stop pddf-platform-init.service along with other platform serives failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\") if status: print \"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status return False return True def start_platform_svc(): status, output=commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py install\") if status: print \"accton_as4630_54pe_util.py install command failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-fan.service\") if status: print \"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-fan.service\") if status: print \"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-psu.service\") if status: print \"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-psu.service\") if status: print \"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor.service\") if status: print \"Enable as4630-54pe-platform-monitor.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor.service\") if status: print \"Start as4630-54pe-platform-monitor.service failed %d\"%status return False return True def start_platform_pddf(): status, output=commands.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print \"Start pddf-platform-init.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl start as4630-54pe-pddf-platform-monitor.service\") if status: print \"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status return False return True def stop_platform_pddf(): status, output=commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print \"Stop pddf-platform-init.service failed %d\"%status return False status, output=commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\") if status: print \"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status return False return True def main(): pass if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services. \n# This will be used while switching the pddf->non-pddf mode and vice versa\n\nimport commands\n\ndef check_pddf_support():\n    return True\n\ndef stop_platform_svc():\n    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-fan.service\")\n    if status:\n        print \"Disable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-fan.service\")\n    if status:\n        print \"Stop as4630-54pe-platform-monitor-fan.service failed %d\"%status\n        return False\n\n    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor-psu.service\")\n    if status:\n        print \"Disable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor-psu.service\")\n    if status:\n        print \"Stop as4630-54pe-platform-monitor-psu.service failed %d\"%status\n        return False\n    \n    status, output = commands.getstatusoutput(\"systemctl disable as4630-54pe-platform-monitor.service\")\n    if status:\n        print \"Disable as4630-54pe-platform-monitor.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-platform-monitor.service\")\n    if status:\n        print \"Stop as4630-54pe-platform-monitor.service failed %d\"%status\n        return False\n\n    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py clean\")\n    if status:\n        print \"accton_as4630_54pe_util.py clean command failed %d\"%status\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print \"Stop pddf-platform-init.service along with other platform serives failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n    if status:\n        print \"Stop as4630-54pe-pddf-platform-monitor.service along with other platform serives failed %d\"%status\n        return False\n\n    return True\n    \ndef start_platform_svc():\n    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as4630_54pe_util.py install\")\n    if status:\n        print \"accton_as4630_54pe_util.py install  command failed %d\"%status\n        return False\n\n    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-fan.service\")\n    if status:\n        print \"Enable as4630-54pe-platform-monitor-fan.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-fan.service\")\n    if status:\n        print \"Start as4630-54pe-platform-monitor-fan.service failed %d\"%status\n        return False\n\n    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor-psu.service\")\n    if status:\n        print \"Enable as4630-54pe-platform-monitor-psu.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor-psu.service\")\n    if status:\n        print \"Start as4630-54pe-platform-monitor-psu.service failed %d\"%status\n        return False\n\n    status, output = commands.getstatusoutput(\"systemctl enable as4630-54pe-platform-monitor.service\")\n    if status:\n        print \"Enable as4630-54pe-platform-monitor.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-platform-monitor.service\")\n    if status:\n        print \"Start as4630-54pe-platform-monitor.service failed %d\"%status\n        return False\n\n    return True\n\ndef start_platform_pddf():\n    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print \"Start pddf-platform-init.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl start as4630-54pe-pddf-platform-monitor.service\")\n    if status:\n        print \"Start as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n        return False\n    \n    return True\n\ndef stop_platform_pddf():\n    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print \"Stop pddf-platform-init.service failed %d\"%status\n        return False\n    status, output = commands.getstatusoutput(\"systemctl stop as4630-54pe-pddf-platform-monitor.service\")\n    if status:\n        print \"Stop as4630-54pe-pddf-platform-monitor.service failed %d\"%status\n        return False\n\n    return True\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py": {"changes": [{"diff": "\n             # critical case*/\n             logging.critical(\n                 'Alarm-Critical for temperature critical is detected, reset DUT')\n-            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n+            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]\n             time.sleep(2)\n-            return_value = os.system(cmd_str)\n+            return_value = subprocess.call(cmd_str)\n             logging.warning('Fan set: i2cset -y -f 3 0x60 0x4 0xE4, status is %d', return_value)\n \n         #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_s", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-accton/as4630-54te/utils/accton_as4630_54te_monitor.py", "badparts": ["            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"", "            return_value = os.system(cmd_str)"], "goodparts": ["            cmd_str = [\"i2cset\", \"-y\", \"-f\", \"3\", \"0x60\", \"0x4\", \"0xE4\"]", "            return_value = subprocess.call(cmd_str)"]}], "source": "\n try: import os import sys import getopt import logging import logging.config import logging.handlers import time from as4630_54te.fanutil import FanUtil from as4630_54te.thermalutil import ThermalUtil except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as4630_54te_monitor' class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False fan_policy_state=0 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0, 0] temp_test_data=0 test_temp_revert=0 class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S') if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter( '%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=logging.handlers.SysLogHandler( address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 for i in range(0, len(policy)): if(temp > policy[i][2]): if temp <=policy[i][3]: state=i return state def manage_fans(self): global fan_policy_state global fan_fail global test_temp global test_temp_list global alarm_state global temp_test_data global test_temp_revert LEVEL_FAN_MIN=0 LEVEL_FAN_NORMAL=1 LEVEL_FAN_MID=2 LEVEL_FAN_HIGH=3 LEVEL_TEMP_CRITICAL=4 fan_policy={ LEVEL_FAN_MIN:[50, 8, 0, 140000], LEVEL_FAN_NORMAL:[62, 10, 140000, 150000], LEVEL_FAN_MID:[75, 12, 150000, 160000], LEVEL_FAN_HIGH:[88, 14, 160000, 240000], LEVEL_TEMP_CRITICAL:[100, 16, 240000, 300000], } temp=[0, 0, 0] thermal=ThermalUtil() fan=FanUtil() ori_duty_cycle=fan.get_fan_duty_cycle() new_duty_cycle=0 if test_temp==0: for i in range(0, 3): temp[i]=thermal._get_thermal_val(i +1) if temp[i]==0 or temp[i] is None: logging.warning(\"Get temp-%d fail\", i) return False else: if test_temp_revert==0: temp_test_data=temp_test_data +2000 else: temp_test_data=temp_test_data -2000 for i in range(0, 3): temp[i]=test_temp_list[i] +temp_test_data fan_fail=0 temp_val=0 for i in range(0, 3): if temp[i] is None: break temp_val +=temp[i] for i in range(fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD +1): if fan.get_fan_status(i)==0: new_pwm=100 logging.warning('Fan_%d fail, set pwm to 100', i) if test_temp==0: fan_fail=1 fan.set_fan_duty_cycle(new_pwm) break else: fan_fail=0 ori_state=fan_policy_state fan_policy_state=self.get_state_from_fan_policy(temp_val, fan_policy) if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN: logging.error(\"Get error fan current_state\\n\") return 0 if fan_fail==0 and ori_duty_cycle !=fan_policy[fan_policy_state][0]: new_duty_cycle=fan_policy[fan_policy_state][0] fan.set_fan_duty_cycle(new_duty_cycle) if temp[0] >=70000: logging.critical( 'Alarm-Critical for temperature critical is detected, reset DUT') cmd_str=\"i2cset -y -f 3 0x60 0x4 0xE4\" time.sleep(2) return_value=os.system(cmd_str) logging.warning('Fan set: i2cset -y -f 3 0x60 0x4 0xE4, status is %d', return_value) if ori_state < LEVEL_FAN_HIGH: if fan_policy_state >=LEVEL_FAN_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if fan_policy_state < LEVEL_FAN_MID: if alarm_state==1: logging.info('Alarm for temperature high is cleared') alarm_state=0 return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv, 'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv) !=5: print(\"temp test, need input three temp\") return 0 i=0 for x in range(2, 5): test_temp_list[i]=int(sys.argv[x]) * 1000 i=i +1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) fan=FanUtil() fan.set_fan_duty_cycle(50) print(\"set default fan speed to 50%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(10) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python\n# -*- coding: utf-8 -*\n# Copyright (c) 2019 Edgecore Networks Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n# THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR\n# CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT\n# LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS\n# FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.\n#\n# See the Apache Version 2.0 License for specific language governing\n# permissions and limitations under the License.\n#\n# HISTORY:\n#    mm/dd/yyyy (A.D.)#\n#    10/24/2019:Jostar create for as4630_54te thermal plan\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import sys\n    import getopt\n    import logging\n    import logging.config\n    import logging.handlers\n    import time\n    from as4630_54te.fanutil import FanUtil\n    from as4630_54te.thermalutil import ThermalUtil\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as4630_54te_monitor'\n\n# Temperature Policy\n# If any fan fail , please set fan speed register to 16\n# The max value of fan speed register is 14\n#  LM77(48)+LM75(4B)+LM75(4A)  >  140, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  >  150, Set 12\n#  LM77(48)+LM75(4B)+LM75(4A)  >  160, Set 14\n#  LM77(48)+LM75(4B)+LM75(4A)  <  140, Set 8\n#  LM77(48)+LM75(4B)+LM75(4A)  <  150, Set 10\n#  LM77(48)+LM75(4B)+LM75(4A)  <  160, Set 12\n#  Reset DUT:LM77(48)>=70C\n#\nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n\n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n\n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args:  # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\n\nfan_policy_state = 0\nfan_fail = 0\nalarm_state = 0  # 0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0, 0]\ntemp_test_data = 0\ntest_temp_revert = 0\n# Make a class we can use to capture stdout and sterr in the log\n\n\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm = 0\n    ori_pwm = 0\n    default_pwm = 0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format='[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S')\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter(\n                '%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = logging.handlers.SysLogHandler(\n            address='/dev/log')\n        sys_handler.setLevel(logging.WARNING)\n        logging.getLogger('').addHandler(sys_handler)\n\n    def get_state_from_fan_policy(self, temp, policy):\n        state = 0\n        for i in range(0, len(policy)):\n            if (temp > policy[i][2]):  # temp_down\n                if temp <= policy[i][3]:  # temp_up\n                    state = i\n\n        return state\n\n    def manage_fans(self):\n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list\n        global alarm_state\n        global temp_test_data\n        global test_temp_revert\n        LEVEL_FAN_MIN = 0\n        LEVEL_FAN_NORMAL = 1\n        LEVEL_FAN_MID = 2\n        LEVEL_FAN_HIGH = 3\n        LEVEL_TEMP_CRITICAL = 4\n        fan_policy = {\n            LEVEL_FAN_MIN: [50, 8, 0, 140000],\n            LEVEL_FAN_NORMAL: [62, 10, 140000, 150000],\n            LEVEL_FAN_MID: [75, 12, 150000, 160000],\n            LEVEL_FAN_HIGH: [88, 14, 160000, 240000],\n            LEVEL_TEMP_CRITICAL: [100, 16, 240000, 300000],\n        }\n        temp = [0, 0, 0]\n        thermal = ThermalUtil()\n        fan = FanUtil()\n        ori_duty_cycle = fan.get_fan_duty_cycle()\n        new_duty_cycle = 0\n\n        if test_temp == 0:\n            for i in range(0, 3):\n                temp[i] = thermal._get_thermal_val(i + 1)\n                if temp[i] == 0 or temp[i] is None:\n                    logging.warning(\"Get temp-%d fail\", i)\n                    return False\n        else:\n            if test_temp_revert == 0:\n                temp_test_data = temp_test_data + 2000\n            else:\n                temp_test_data = temp_test_data - 2000\n\n            for i in range(0, 3):\n                temp[i] = test_temp_list[i] + temp_test_data\n            fan_fail = 0\n\n        temp_val = 0\n        for i in range(0, 3):\n            if temp[i] is None:\n                break\n            temp_val += temp[i]\n\n        # Check Fan status\n        for i in range(fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD + 1):\n            if fan.get_fan_status(i) == 0:\n                new_pwm = 100\n                logging.warning('Fan_%d fail, set pwm to 100', i)\n                if test_temp == 0:\n                    fan_fail = 1\n                    fan.set_fan_duty_cycle(new_pwm)\n                    break\n            else:\n                fan_fail = 0\n\n        ori_state = fan_policy_state\n        fan_policy_state = self.get_state_from_fan_policy(temp_val, fan_policy)\n\n        if fan_policy_state > LEVEL_TEMP_CRITICAL or fan_policy_state < LEVEL_FAN_MIN:\n            logging.error(\"Get error fan current_state\\n\")\n            return 0\n\n        # Decision : Decide new fan pwm percent.\n        if fan_fail == 0 and ori_duty_cycle != fan_policy[fan_policy_state][0]:\n            new_duty_cycle = fan_policy[fan_policy_state][0]\n            fan.set_fan_duty_cycle(new_duty_cycle)\n\n        if temp[0] >= 70000:  # LM75-48\n            # critical case*/\n            logging.critical(\n                'Alarm-Critical for temperature critical is detected, reset DUT')\n            cmd_str = \"i2cset -y -f 3 0x60 0x4 0xE4\"\n            time.sleep(2)\n            return_value = os.system(cmd_str)\n            logging.warning('Fan set: i2cset -y -f 3 0x60 0x4 0xE4, status is %d', return_value)\n\n        #logging.debug('ori_state=%d, current_state=%d, temp_val=%d\\n\\n',ori_state, fan_policy_state, temp_val)\n\n        if ori_state < LEVEL_FAN_HIGH:\n            if fan_policy_state >= LEVEL_FAN_HIGH:\n                if alarm_state == 0:\n                    logging.warning('Alarm for temperature high is detected')\n                    alarm_state = 1\n\n        if fan_policy_state < LEVEL_FAN_MID:\n            if alarm_state == 1:\n                logging.info('Alarm for temperature high is cleared')\n                alarm_state = 0\n\n        return True\n\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv, 'hdlt:', ['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg\n\n        if sys.argv[1] == '-t':\n            if len(sys.argv) != 5:\n                print(\"temp test, need input three temp\")\n                return 0\n\n            i = 0\n            for x in range(2, 5):\n                test_temp_list[i] = int(sys.argv[x]) * 1000\n                i = i + 1\n            test_temp = 1\n            log_level = logging.DEBUG\n            print(test_temp_list)\n\n    fan = FanUtil()\n    fan.set_fan_duty_cycle(50)\n    print(\"set default fan speed to 50%\")\n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(10)  # 10sec\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py": {"changes": [{"diff": "\n # ------------------------------------------------------------------\n \n try:\n-    import time\n     import logging\n-    from collections import namedtuple\n-    import subprocess\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n", "add": 1, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py", "badparts": ["    import time", "    from collections import namedtuple", "    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         return \"fan{0}_{1}\".format(fan_num, self.node_postfix[node_num-1])\n     \n     def _get_fan_i2c_bus_addr(self):\n-        cmd_template = 'i2cget -f -y {} 0x{} 0'\n+        cmd_template = ['i2cget', '-f', '-y', '', '', '0']\n         for bus_no, dev_addr in self.I2CADDR_CANDIDATES:\n-            cmd = cmd_template.format(bus_no, dev_addr)\n-            if subprocess.getstatusoutput(cmd)[0] == 0:\n+            cmd_template[3] = str(bus_no)\n+            cmd_template[4] = '0x' + str(dev_addr)\n+            if getstatusoutput_noshell(cmd_template)[0] == 0:\n                 return bus_no, dev_addr\n         raise IOError('Un", "add": 4, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7315-27xb/classes/fanutil.py", "badparts": ["        cmd_template = 'i2cget -f -y {} 0x{} 0'", "            cmd = cmd_template.format(bus_no, dev_addr)", "            if subprocess.getstatusoutput(cmd)[0] == 0:"], "goodparts": ["        cmd_template = ['i2cget', '-f', '-y', '', '', '0']", "            cmd_template[3] = str(bus_no)", "            cmd_template[4] = '0x' + str(dev_addr)", "            if getstatusoutput_noshell(cmd_template)[0] == 0:"]}], "source": "\n try: import time import logging from collections import namedtuple import subprocess except ImportError as e: raise ImportError('%s -required module not found' % str(e)) class FanUtil(object): \"\"\"Platform-specific FanUtil class\"\"\" FAN_TOTAL_NUM=5 FAN_NUM_1_IDX=1 FAN_NODE_NUM=2 FAN_FAULT_IDX=1 FAN_DIR_IDX=2 I2CADDR_CANDIDATES=((9, 66), (50, 66)) PATH_PREFIX='/sys/bus/i2c/devices/{}-00{}/' BASE_VAL_PATH='{0}' FAN_DUTY_PATH='fan{0}_pwm' \"\"\" Dictionary where key1=fan id index(integer) starting from 1 key2=fan node index(interger) starting from 1 value=path to fan device file(string) \"\"\" dev_paths={} node_postfix=[\"fault\", \"direction\"] def _get_fan_to_device_node(self, fan_num, node_num): return \"fan{0}_{1}\".format(fan_num, self.node_postfix[node_num-1]) def _get_fan_i2c_bus_addr(self): cmd_template='i2cget -f -y{} 0x{} 0' for bus_no, dev_addr in self.I2CADDR_CANDIDATES: cmd=cmd_template.format(bus_no, dev_addr) if subprocess.getstatusoutput(cmd)[0]==0: return bus_no, dev_addr raise IOError('Unable to reach fan CPLD via I2C') def _init_fnode_basepath(self): '''format BASE_VAL_PATH and FAN_DUTY_PATH ''' bus, addr=self._get_fan_i2c_bus_addr() self.PATH_PREFIX=self.PATH_PREFIX.format(bus, addr) self.BASE_VAL_PATH=self.PATH_PREFIX +self.BASE_VAL_PATH self.FAN_DUTY_PATH=self.PATH_PREFIX +self.FAN_DUTY_PATH def _get_fan_node_val(self, fan_num, node_num): if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM: self.logger.debug('GET. Parameter error. fan_num:%d', fan_num) return None if node_num < self.FAN_FAULT_IDX or node_num > self.FAN_NODE_NUM: self.logger.debug('GET. Parameter error. node_num:%d', node_num) return None device_path=self.get_fan_to_device_path(fan_num, node_num) try: val_file=open(device_path, 'r') except IOError as e: self.logger.error('GET. unable to open file: %s', str(e)) return None content=val_file.readline().rstrip() if content=='': self.logger.debug('GET. content is NULL. device_path:%s', device_path) return None try: val_file.close() except: self.logger.debug('GET. unable to close file. device_path:%s', device_path) return None return int(content) def _set_fan_node_val(self, fan_num, node_num, val): if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM: self.logger.debug('GET. Parameter error. fan_num:%d', fan_num) return None if node_num < self.FAN_FAULT_IDX or node_num > self.FAN_NODE_NUM: self.logger.debug('GET. Parameter error. node_num:%d', node_num) return None content=str(val) if content=='': self.logger.debug('GET. content is NULL. device_path:%s', device_path) return None device_path=self.get_fan_to_device_path(fan_num, node_num) try: val_file=open(device_path, 'w') except IOError as e: self.logger.error('GET. unable to open file: %s', str(e)) return None val_file.write(content) try: val_file.close() except: self.logger.debug('GET. unable to close file. device_path:%s', device_path) return None return True logger=logging.getLogger(__name__) def __init__(self, log_level=logging.DEBUG): ch=logging.StreamHandler() ch.setLevel(log_level) self.logger.addHandler(ch) self._init_fnode_basepath() fan_path=self.BASE_VAL_PATH for fan_num in range(self.FAN_NUM_1_IDX, self.FAN_TOTAL_NUM+1): for node_num in range(1, self.FAN_NODE_NUM+1): node=self._get_fan_to_device_node(fan_num, node_num) self.dev_paths[(fan_num, node_num)]=fan_path.format(node) def get_num_fans(self): return self.FAN_TOTAL_NUM def get_idx_fan_start(self): return self.FAN_NUM_1_IDX def get_num_nodes(self): return self.FAN_NODE_NUM def get_idx_node_start(self): return self.FAN_FAULT_IDX def get_size_node_map(self): return len(self.dev_paths) def get_size_path_map(self): return len(self.dev_paths) def get_fan_to_device_path(self, fan_num, node_num): return self.dev_paths[(fan_num, node_num)] def get_fan_fault(self, fan_num): return self._get_fan_node_val(fan_num, self.FAN_FAULT_IDX) def get_fan_dir(self, fan_num): return self._get_fan_node_val(fan_num, self.FAN_DIR_IDX) def get_fan_duty_cycle(self): try: val_file=open(self.FAN_DUTY_PATH.format(1)) except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False content=val_file.readline().rstrip() val_file.close() return int(content) def set_fan_duty_cycle(self, val): for fan_num in range(1, self.FAN_TOTAL_NUM+1): try: fan_file=open(self.FAN_DUTY_PATH.format(fan_num), 'r+') except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False fan_file.write(str(val)) fan_file.close() return True def get_fan_status(self, fan_num): if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM: self.logger.debug('GET. Parameter error. fan_num, %d', fan_num) return None if self.get_fan_fault(fan_num) is not None and self.get_fan_fault(fan_num) > 0: self.logger.debug('GET. FAN fault. fan_num, %d', fan_num) return False return True ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2017 Accton Technology Corporation\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    mm/dd/yyyy (A.D.)\n#    11/13/2017: Polly Hsu, Create\n#    1/10/2018: Jostar modify for as7716_32\n#    5/02/2019: Roy Lee modify for as7816_64x\n# ------------------------------------------------------------------\n\ntry:\n    import time\n    import logging\n    from collections import namedtuple\n    import subprocess\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n\nclass FanUtil(object):\n    \"\"\"Platform-specific FanUtil class\"\"\"\n\n    FAN_TOTAL_NUM = 5\n    FAN_NUM_1_IDX = 1\n\n    FAN_NODE_NUM = 2\n    FAN_FAULT_IDX = 1\n    #FAN_SPEED_IDX = 2\n    FAN_DIR_IDX = 2\n    #FAN_NODE_DUTY_IDX_OF_MAP = 4\n    #FANR_NODE_FAULT_IDX_OF_MAP = 5\n\n    I2CADDR_CANDIDATES = ((9, 66), # for R0C HW and later\n                         (50, 66)) # for R0A, R0B HW\n    PATH_PREFIX = '/sys/bus/i2c/devices/{}-00{}/'\n    BASE_VAL_PATH = '{0}'\n    FAN_DUTY_PATH = 'fan{0}_pwm'\n\n    #logfile = ''\n    #loglevel = self.logger.INFO\n\n    \"\"\" Dictionary where\n        key1 = fan id index (integer) starting from 1\n        key2 = fan node index (interger) starting from 1\n        value = path to fan device file (string) \"\"\"\n    dev_paths = {}\n    \n    node_postfix = [\"fault\", \"direction\"]\n    def _get_fan_to_device_node(self, fan_num, node_num):\n        return \"fan{0}_{1}\".format(fan_num, self.node_postfix[node_num-1])\n    \n    def _get_fan_i2c_bus_addr(self):\n        cmd_template = 'i2cget -f -y {} 0x{} 0'\n        for bus_no, dev_addr in self.I2CADDR_CANDIDATES:\n            cmd = cmd_template.format(bus_no, dev_addr)\n            if subprocess.getstatusoutput(cmd)[0] == 0:\n                return bus_no, dev_addr\n        raise IOError('Unable to reach fan CPLD via I2C')\n\n    def _init_fnode_basepath(self):\n        '''format BASE_VAL_PATH and FAN_DUTY_PATH '''\n        bus, addr = self._get_fan_i2c_bus_addr()\n        self.PATH_PREFIX = self.PATH_PREFIX.format(bus, addr)\n        self.BASE_VAL_PATH = self.PATH_PREFIX + self.BASE_VAL_PATH\n        self.FAN_DUTY_PATH = self.PATH_PREFIX + self.FAN_DUTY_PATH\n\n    def _get_fan_node_val(self, fan_num, node_num):\n        if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM:\n            self.logger.debug('GET. Parameter error. fan_num:%d', fan_num)\n            return None\n\n        if node_num < self.FAN_FAULT_IDX or node_num > self.FAN_NODE_NUM:\n            self.logger.debug('GET. Parameter error. node_num:%d', node_num)\n            return None\n\n        device_path = self.get_fan_to_device_path(fan_num, node_num)\n       \n        try:\n            val_file = open(device_path, 'r')\n        except IOError as e:\n            self.logger.error('GET. unable to open file: %s', str(e))\n            return None\n\n        content = val_file.readline().rstrip()\n        \n        if content == '':\n            self.logger.debug('GET. content is NULL. device_path:%s', device_path)\n            return None\n\n        try:\n            val_file.close()\n        except:\n            self.logger.debug('GET. unable to close file. device_path:%s', device_path)\n            return None\n\n        return int(content)\n\n    def _set_fan_node_val(self, fan_num, node_num, val):\n        if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM:\n            self.logger.debug('GET. Parameter error. fan_num:%d', fan_num)\n            return None\n\n        if node_num < self.FAN_FAULT_IDX or node_num > self.FAN_NODE_NUM:\n            self.logger.debug('GET. Parameter error. node_num:%d', node_num)\n            return None\n\n        content = str(val)\n        if content == '':\n            self.logger.debug('GET. content is NULL. device_path:%s', device_path)\n            return None\n\n        device_path = self.get_fan_to_device_path(fan_num, node_num)\n        try:\n            val_file = open(device_path, 'w')\n        except IOError as e:\n            self.logger.error('GET. unable to open file: %s', str(e))\n            return None\n\n        val_file.write(content)\n\n        try:\n            val_file.close()\n        except:\n            self.logger.debug('GET. unable to close file. device_path:%s', device_path)\n            return None\n\n        return True\n\n    logger = logging.getLogger(__name__)\n    def __init__(self, log_level=logging.DEBUG):\n        ch = logging.StreamHandler()\n        ch.setLevel(log_level)\n        self.logger.addHandler(ch)\n\n        self._init_fnode_basepath()\n        fan_path = self.BASE_VAL_PATH \n        for fan_num in range(self.FAN_NUM_1_IDX, self.FAN_TOTAL_NUM+1):\n            for node_num in range(1, self.FAN_NODE_NUM+1):\n                node = self._get_fan_to_device_node(fan_num, node_num)\n                self.dev_paths[(fan_num, node_num)] = fan_path.format(node)\n               \n    def get_num_fans(self):\n        return self.FAN_TOTAL_NUM\n\n    def get_idx_fan_start(self):\n        return self.FAN_NUM_1_IDX\n\n    def get_num_nodes(self):\n        return self.FAN_NODE_NUM\n\n    def get_idx_node_start(self):\n        return self.FAN_FAULT_IDX\n\n    def get_size_node_map(self):\n        return len(self.dev_paths)\n\n    def get_size_path_map(self):\n        return len(self.dev_paths)\n\n    def get_fan_to_device_path(self, fan_num, node_num):\n        return self.dev_paths[(fan_num, node_num)]\n\n    def get_fan_fault(self, fan_num):\n        return self._get_fan_node_val(fan_num, self.FAN_FAULT_IDX)\n\n    #def get_fan_speed(self, fan_num):\n    #    return self._get_fan_node_val(fan_num, self.FAN_SPEED_IDX)\n\n    def get_fan_dir(self, fan_num):\n        return self._get_fan_node_val(fan_num, self.FAN_DIR_IDX)\n\n    def get_fan_duty_cycle(self):\n        try:\n            val_file = open(self.FAN_DUTY_PATH.format(1))\n        except IOError as e:\n            print(\"Error: unable to open file: %s\" % str(e))          \n            return False\n\n        content = val_file.readline().rstrip()\n        val_file.close()\n        return int(content)\n\n    def set_fan_duty_cycle(self, val):\n        for fan_num in range(1, self.FAN_TOTAL_NUM+1):\n            try:\n                fan_file = open(self.FAN_DUTY_PATH.format(fan_num), 'r+')\n            except IOError as e:\n                print(\"Error: unable to open file: %s\" % str(e))          \n                return False\n            fan_file.write(str(val))\n            fan_file.close()\n        return True\n\n    def get_fan_status(self, fan_num):\n        if fan_num < self.FAN_NUM_1_IDX or fan_num > self.FAN_TOTAL_NUM:\n            self.logger.debug('GET. Parameter error. fan_num, %d', fan_num)\n            return None\n\n        if self.get_fan_fault(fan_num) is not None and self.get_fan_fault(fan_num) > 0:\n            self.logger.debug('GET. FAN fault. fan_num, %d', fan_num)\n            return False\n\n        #if self.get_fanr_fault(fan_num) is not None and self.get_fanr_fault(fan_num) > 0:\n        #    self.logger.debug('GET. FANR fault. fan_num, %d', fan_num)\n        #   return False\n\n        return True\n\n#def main():\n#    fan = FanUtil()\n#\n#    print 'get_size_node_map : %d' % fan.get_size_node_map()\n#    print 'get_size_path_map : %d' % fan.get_size_path_map()\n#    for x in range(fan.get_idx_fan_start(), fan.get_num_fans()+1):\n#        for y in range(fan.get_idx_node_start(), fan.get_num_nodes()+1):\n#            print fan.get_fan_to_device_path(x, y)\n#\n#if __name__ == '__main__':\n#    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py": {"changes": [{"diff": "\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py", "badparts": ["               os.system('reboot')           "], "goodparts": ["               subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is clear", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}], "source": "\n try: import os import getopt import sys import logging import logging.config import logging.handlers import time from as7326_56x.fanutil import FanUtil from as7326_56x.thermalutil import ThermalUtil except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as7326_monitor' global log_file global log_level class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False fan_policy_state=1 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0, 0, 0, 0, 0] class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 logging.debug('temp=%d', temp) for i in range(0, len(policy)): if temp > policy[i][0]: if temp <=policy[i][1]: state=policy[i][2] logging.debug('temp=%d >=policy[%d][0]=%d, temp=%d < policy[%d][1]=%d', temp, i, policy[i][0], temp, i, policy[i][1]) logging.debug('fan_state=%d', state) if state==0: state=policy[0][2] logging.debug('set default state') return state def manage_fans(self): thermal_pwm_list={} LEVEL_FAN_DEF=1 LEVEL_FAN_MID=2 LEVEL_FAN_MAX=3 LEVEL_TEMP_HIGH=4 LEVEL_TEMP_CRITICAL=5 fan_policy_state_pwm_tlb={ LEVEL_FAN_DEF: [38, 0x4], LEVEL_FAN_MID: [75, 0xB], LEVEL_FAN_MAX: [100, 0xE], LEVEL_TEMP_HIGH: [100, 0xE], LEVEL_TEMP_CRITICAL: [100, 0xE], } global fan_policy_state global fan_fail global test_temp global test_temp_list global alarm_state fan_policy={ 0:[0, 39000, LEVEL_FAN_DEF], 1:[39000, 45000, LEVEL_FAN_MID], 2:[45000, 61000, LEVEL_FAN_MAX], 3:[61000, 66000, LEVEL_TEMP_HIGH], 4:[66000, 200000, LEVEL_TEMP_CRITICAL], } thermal=ThermalUtil() fan=FanUtil() ori_pwm=fan.get_fan_duty_cycle() new_pwm=0 logging.debug('test_temp=%d', test_temp) if test_temp==0: temp1=thermal._get_thermal_val(1) temp2=thermal._get_thermal_val(2) temp3=thermal._get_thermal_val(3) temp4=thermal._get_thermal_val(4) temp5=thermal._get_thermal_val(5) temp6=0 else: temp1=test_temp_list[0] temp2=test_temp_list[1] temp3=test_temp_list[2] temp4=test_temp_list[3] temp5=test_temp_list[4] temp6=0 fan_fail=0 if temp2==0: temp_get=50000 logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%') elif temp2==0: temp_get=50000 logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%') else: temp_get=(temp2 +temp4)/2 ori_state=fan_policy_state fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy) logging.debug('lm75_48=%d, lm75_49=%d, lm75_4a=%d, lm_4b=%d, cpu=%d, bcm=%d', temp1,temp2,temp3,temp4,temp5,temp6) logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state) new_pwm=fan_policy_state_pwm_tlb[fan_policy_state][0] if fan_fail==0: logging.debug('new_pwm=%d', new_pwm) if fan_fail==0: if new_pwm!=ori_pwm: fan.set_fan_duty_cycle(new_pwm) logging.info('Set fan speed from %d to %d', ori_pwm, new_pwm) for i in range(fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1): if fan.get_fan_status(i)==0: new_pwm=100 logging.debug('fan_%d fail, set pwm to 100',i) if test_temp==0: fan_fail=1 fan.set_fan_duty_cycle(new_pwm) break else: fan_fail=0 new_state=fan_policy_state if ori_state==LEVEL_FAN_DEF: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected, reboot DUT') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MID: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MAX: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if alarm_state==1: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_HIGH: if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if new_state <=LEVEL_FAN_MID: logging.warning('Alarm for temperature high is cleared') alarm_state=0 if new_state <=LEVEL_FAN_MAX: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_CRITICAL: if new_state <=LEVEL_FAN_MAX: logging.warning('Alarm for temperature critical is cleared') return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv,'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv)!=8: print(\"temp test, need input six temp\") return 0 i=0 for x in range(2, 8): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) fan=FanUtil() fan.set_fan_duty_cycle(38) print(\"set default fan speed to 37.5%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(5) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2017 Accton Technology Corporation\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    mm/dd/yyyy (A.D.)\n#    3/23/2018: Roy Lee modify for as7326_56x\n#    6/26/2018: Jostar implement by new thermal policy from HW RD\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import getopt\n    import sys\n    import logging\n    import logging.config\n    import logging.handlers\n    import time  # this is only being used as part of the example\n    from as7326_56x.fanutil import FanUtil\n    from as7326_56x.thermalutil import ThermalUtil\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as7326_monitor'\n\nglobal log_file\nglobal log_level\n\n\n#Default FAN speed: 37.5%(0x05)\n#Ori is that detect: (U45_BCM56873 + Thermal sensor_LM75_CPU:0x4B) /2 \n#New Detect: (sensor_LM75_49 + Thermal sensor_LM75_CPU_4B) /2 \n#Thermal policy: Both F2B and B2F\n#1.\t(sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 =< 39C   , Keep 37.5%(0x05) Fan speed\n#2.\t(sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 39C   , Change Fan speed from 37.5%(0x05) to % 75%(0x0B)\n#3.\t(sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 45C   , Change Fan speed from 75%(0x0B) to 100%(0x0F)\n#4.\t(sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 61C   , Send alarm message\n#5.\t(sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 66C   , Shutdown system\n#6.\tOne Fan fail      , Change Fan speed to 100%(0x0F)\n\n#fan-dev 0-11 speed 0x05     Setup fan speed 37.50%\t\t\n#fan-dev 0-11 speed 0xB      Setup fan speed 75%\t\t\n#fan-dev 0-11 speed 0xF      Setup fan speed 100.00%\t\t\n\n\nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n \n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n     \n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args: # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\n\nfan_policy_state=1\nfan_fail=0\nalarm_state = 0 #0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0, 0, 0, 0, 0]\n\n# Make a class we can use to capture stdout and sterr in the log\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm=0\n    ori_pwm = 0\n    default_pwm=0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format= '[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = handler = logging.handlers.SysLogHandler(address = '/dev/log')\n        sys_handler.setLevel(logging.WARNING)       \n        logging.getLogger('').addHandler(sys_handler)\n\n        #logging.debug('SET. logfile:%s / loglevel:%d', log_file, log_level)\n          \n    def get_state_from_fan_policy(self, temp, policy):\n        state=0\n        logging.debug('temp=%d', temp)\n        for i in range(0, len(policy)):\n            #logging.debug('policy[%d][0]=%d, policy[%d][1]=%d', i,policy[i][0],i, policy[i][1])\n            if temp > policy[i][0]:\n                if temp <= policy[i][1]:\n                    state =policy[i][2]\n                    logging.debug ('temp=%d >= policy[%d][0]=%d,  temp=%d < policy[%d][1]=%d' , temp, i, policy[i][0], temp, i, policy[i][1])\n                    logging.debug ('fan_state=%d', state)\n        if state==0:\n            state=policy[0][2] #below fan_min, set to default pwm\n            logging.debug('set default state')\n        return state\n    \n    def manage_fans(self):\n        \n        thermal_pwm_list = {} #Ori sort is lm75_48, 49, 4a, 4b, cpu, bcm\n                              # After get pwm, do sort to get max pwm.\n        LEVEL_FAN_DEF=1\n        LEVEL_FAN_MID=2       \n        LEVEL_FAN_MAX=3\n        LEVEL_TEMP_HIGH=4\n        LEVEL_TEMP_CRITICAL=5         \n        \n        fan_policy_state_pwm_tlb = {\n        LEVEL_FAN_DEF:          [38,  0x4],\n        LEVEL_FAN_MID:          [75,  0xB],     \n        LEVEL_FAN_MAX:          [100, 0xE],\n        LEVEL_TEMP_HIGH:        [100, 0xE],\n        LEVEL_TEMP_CRITICAL:    [100, 0xE],\n        }\n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list        \n        global alarm_state\n        fan_policy ={\n        0: [0,     39000,   LEVEL_FAN_DEF],  #F2B_policy, B2F_plicy, PWM, reg_val\n        1: [39000, 45000,   LEVEL_FAN_MID],  \n        2: [45000, 61000,   LEVEL_FAN_MAX],\n        3: [61000, 66000,   LEVEL_TEMP_HIGH],        \n        4: [66000, 200000,  LEVEL_TEMP_CRITICAL],        \n        }\n              \n        thermal = ThermalUtil()\n        fan = FanUtil()\n        #fan_dir=fan.get_fan_dir(1)            \n        #if fan_dir > 1:\n        #    fan_dri=1 #something wrong, set fan_dir to default val\n        #if fan_dir < 0:\n        #    fan_dri=1 #something wrong, set fan_dir to default val\n        ori_pwm=fan.get_fan_duty_cycle()\n        new_pwm=0  \n        #logging.debug('fan_dir=%d, ori_pwm=%d', fan_dir, ori_pwm)\n        logging.debug('test_temp=%d', test_temp)\n        if test_temp==0: \n            temp1 = thermal._get_thermal_val(1)\n            temp2 = thermal._get_thermal_val(2)\n            temp3 = thermal._get_thermal_val(3)\n            temp4 = thermal._get_thermal_val(4)\n            temp5 = thermal._get_thermal_val(5)\n            temp6=0\n        else:\n            temp1 = test_temp_list[0]\n            temp2 = test_temp_list[1]\n            temp3 = test_temp_list[2]\n            temp4 = test_temp_list[3]\n            temp5 = test_temp_list[4]\n            temp6=0\n            fan_fail=0\n       \n        if temp2==0:\n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%')\n        elif temp2==0:        \n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%')\n        else:    \n            temp_get= (temp2 + temp4)/2  # Use (sensor_LM75_49 + Thermal sensor_LM75_CPU_4B) /2 \n        ori_state=fan_policy_state\n        fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy)    \n        logging.debug('lm75_48=%d, lm75_49=%d, lm75_4a=%d, lm_4b=%d, cpu=%d, bcm=%d', temp1,temp2,temp3,temp4,temp5,temp6)\n        logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state)\n        new_pwm = fan_policy_state_pwm_tlb[fan_policy_state][0]\n        if fan_fail==0:\n            logging.debug('new_pwm=%d', new_pwm)\n        \n        if fan_fail==0:\n            if new_pwm!=ori_pwm:\n                fan.set_fan_duty_cycle(new_pwm)\n                logging.info('Set fan speed from %d to %d', ori_pwm, new_pwm)\n        \n        for i in range (fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1):\n            if fan.get_fan_status(i)==0:\n                new_pwm=100\n                logging.debug('fan_%d fail, set pwm to 100',i)\n                if test_temp==0:\n                    fan_fail=1\n                    fan.set_fan_duty_cycle(new_pwm)\n                    break\n            else:\n                fan_fail=0        \n       \n        new_state = fan_policy_state       \n        \n        if ori_state==LEVEL_FAN_DEF:            \n           if new_state==LEVEL_TEMP_HIGH:\n               if alarm_state==0:\n                   logging.warning('Alarm for temperature high is detected')\n               alarm_state=1\n           if new_state==LEVEL_TEMP_CRITICAL:\n               logging.critical('Alarm for temperature critical is detected, reboot DUT')\n               time.sleep(2)\n               os.system('reboot')           \n        if ori_state==LEVEL_FAN_MID:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state=1 \n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n        if ori_state==LEVEL_FAN_MAX:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected') \n                alarm_state=1\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n            if alarm_state==1:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_HIGH:\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n            if new_state <= LEVEL_FAN_MID:\n                logging.warning('Alarm for temperature high is cleared')\n                alarm_state=0\n            if new_state <= LEVEL_FAN_MAX:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_CRITICAL:            \n            if new_state <= LEVEL_FAN_MAX:\n                logging.warning('Alarm for temperature critical is cleared')\n      \n        return True\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv,'hdlt:',['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg            \n        \n        if sys.argv[1]== '-t':\n            if len(sys.argv)!=8:\n                print(\"temp test, need input six temp\")\n                return 0\n            \n            i=0\n            for x in range(2, 8):\n               test_temp_list[i]= int(sys.argv[x])*1000\n               i=i+1\n            test_temp = 1   \n            log_level = logging.DEBUG\n            print(test_temp_list)                       \n    \n    fan = FanUtil()\n    fan.set_fan_duty_cycle(38)\n    print(\"set default fan speed to 37.5%\")\n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(5)\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    \n"}, "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py": {"changes": [{"diff": "\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n         if ori_state == LEVEL_FAN_MID:\n             if new_state == LEVEL_TEMP_HIGH:\n                 if alarm_state == 0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n         if ori_state == LEVEL_FAN_MAX:\n             if new_state == LEVEL_TEMP_HIGH:\n                 if alarm_state == 0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if alarm_state == 1:\n                 if temp_get < (fan_policy[3][0] - 5000):  # below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state == LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is cleare", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_pddf_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}], "source": "\n try: import os import sys import getopt import logging import logging.config import logging.handlers import time from sonic_platform import platform except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='accton_as7326_56x_monitor' platform_chassis=None fan_policy_state=1 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0] temp_test_data=0 test_temp_revert=0 class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 logging.debug('temp=%d', temp) for i in range(0, len(policy)): if temp > policy[i][0]: if temp <=policy[i][1]: state=policy[i][2] logging.debug('temp=%d >=policy[%d][0]=%d, temp=%d < policy[%d][1]=%d', temp, i, policy[i][0], temp, i, policy[i][1]) logging.debug('fan_state=%d', state) if state==0: state=policy[0][2] logging.debug('set default state') return state def manage_fans(self): LEVEL_FAN_DEF=1 LEVEL_FAN_MID=2 LEVEL_FAN_MAX=3 LEVEL_TEMP_HIGH=4 LEVEL_TEMP_CRITICAL=5 FAN_NUM=2 FAN_TRAY_NUM=6 fan_policy_state_pwm_tlb={ LEVEL_FAN_DEF: [38, 0x4], LEVEL_FAN_MID: [75, 0xB], LEVEL_FAN_MAX: [100, 0xE], LEVEL_TEMP_HIGH: [100, 0xE], LEVEL_TEMP_CRITICAL: [100, 0xE], } global platform_chassis global fan_policy_state global fan_fail global test_temp global test_temp_list global temp_test_data global test_temp_revert global alarm_state fan_policy={ 0:[0, 39000, LEVEL_FAN_DEF], 1:[39000, 45000, LEVEL_FAN_MID], 2:[45000, 61000, LEVEL_FAN_MAX], 3:[61000, 66000, LEVEL_TEMP_HIGH], 4:[66000, 200000, LEVEL_TEMP_CRITICAL], } ori_perc=platform_chassis.get_fan(0).get_speed() if test_temp==0: temp2=platform_chassis.get_thermal(1).get_temperature()*1000 temp4=platform_chassis.get_thermal(3).get_temperature()*1000 else: temp2=test_temp_list[0] temp4=test_temp_list[1] if test_temp_revert==0: temp_test_data=temp_test_data+2000 else: temp_test_data=temp_test_data-2000 if temp2==0: temp_get=50000 logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%') elif temp4==0: temp_get=50000 logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%') else: temp_get=(temp2 +temp4)/2 logging.debug('Begeinning,fan_policy_state=%d', fan_policy_state) if test_temp==1: temp_get=temp_get+temp_test_data ori_state=fan_policy_state fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy) logging.debug('temp2=lm75_49=%d,temp4=lm_4b=%d, temp_get=%d, ori_state=%d', temp2, temp4, temp_get, ori_state) if fan_policy_state > ori_state: logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state) new_perc=fan_policy_state_pwm_tlb[fan_policy_state][0] if fan_fail==0: if new_perc !=ori_perc: platform_chassis.get_fan(0).set_speed(new_perc) logging.info('Set fan speed from %d to %d', ori_perc, new_perc) for i in range(FAN_TRAY_NUM * FAN_NUM): if not platform_chassis.get_fan(i).get_status() or not platform_chassis.get_fan(i).get_speed_rpm(): new_perc=100 logging.debug('fan_%d fail, set new_perc to 100', i+1) fan_fail=1 if ori_state < LEVEL_FAN_MAX: fan_policy_state=new_state=LEVEL_FAN_MAX logging.debug('fan_policy_state=%d', fan_policy_state) logging.warning('fan_policy_state is LEVEL_FAN_MAX') platform_chassis.get_fan(0).set_speed(new_perc) break else: fan_fail=0 if fan_fail==0: new_state=fan_policy_state else: if fan_policy_state > ori_state: new_state=fan_policy_state else: fan_policy_state=new_state=LEVEL_FAN_MAX if ori_state==LEVEL_FAN_DEF: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected, reboot DUT') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MID: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MAX: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if alarm_state==1: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_HIGH: if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if new_state <=LEVEL_FAN_MID: logging.warning('Alarm for temperature high is cleared') alarm_state=0 if new_state <=LEVEL_FAN_MAX: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_CRITICAL: if new_state <=LEVEL_FAN_MAX: logging.warning('Alarm for temperature critical is cleared') return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv, 'hdlt:',['lfile=']) except getopt.GetoptError: print(('Usage: %s[-d][-l <log_file>]' % sys.argv[0])) return 0 for opt, arg in opts: if opt=='-h': print(('Usage: %s[-d][-l <log_file>]' % sys.argv[0])) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv) !=4: print(\"temp test, need input four temp\") return 0 i=0 for x in range(2, 4): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) global platform_chassis platform_chassis=platform.Platform().get_chassis() platform_chassis.get_fan(0).set_speed(38) print(\"set default fan speed to 37.5%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(5) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    mm/dd/yyyy (A.D.)\n#    3/23/2018: Roy Lee modify for as7326_56x\n#    6/26/2018: Jostar implement by new thermal policy from HW RD\n#    09/18/2020: Jostar Yang, change to call PDDF API .\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import sys\n    import getopt\n    import logging\n    import logging.config\n    import logging.handlers\n    import time\n    from sonic_platform import platform\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = 'accton_as7326_56x_monitor'\n\nplatform_chassis = None\n\n# Default FAN speed: 37.5%(0x05)\n# Ori is that detect: (U45_BCM56873 + Thermal sensor_LM75_CPU:0x4B) /2\n# New Detect: (sensor_LM75_49 + Thermal sensor_LM75_CPU_4B) /2\n# Thermal policy: Both F2B and B2F\n# 1.    (sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 =< 39C   , Keep 37.5%(0x05) Fan speed\n# 2.    (sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 39C   , Change Fan speed from 37.5%(0x05) to % 75%(0x0B)\n# 3.    (sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 45C   , Change Fan speed from 75%(0x0B) to 100%(0x0F)\n# 4.    (sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 61C   , Send alarm message\n# 5.    (sensor_LM75_49 + Thermal sensor_LM75_CPU) /2 > 66C   , Shutdown system\n# 6.    One Fan fail      , Change Fan speed to 100%(0x0F)\n\n# fan-dev 0-11 speed 0x05     Setup fan speed 37.50%\n# fan-dev 0-11 speed 0xB      Setup fan speed 75%\n# fan-dev 0-11 speed 0xF      Setup fan speed 100.00%\n\nfan_policy_state = 1\nfan_fail = 0\nalarm_state = 0  # 0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0]\ntemp_test_data = 0\ntest_temp_revert = 0\n\n# Make a class we can use to capture stdout and sterr in the log\n\n\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm = 0\n    ori_pwm = 0\n    default_pwm = 0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format='[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = logging.handlers.SysLogHandler(address='/dev/log')\n        sys_handler.setLevel(logging.WARNING)\n        logging.getLogger('').addHandler(sys_handler)\n\n    def get_state_from_fan_policy(self, temp, policy):\n        state = 0\n        logging.debug('temp=%d', temp)\n        for i in range(0, len(policy)):\n            #logging.debug('policy[%d][0]=%d, policy[%d][1]=%d', i,policy[i][0],i, policy[i][1])\n            if temp > policy[i][0]:\n                if temp <= policy[i][1]:\n                    state = policy[i][2]\n                    logging.debug('temp=%d >= policy[%d][0]=%d,  temp=%d < policy[%d][1]=%d',\n                                  temp, i, policy[i][0], temp, i, policy[i][1])\n                    logging.debug('fan_state=%d', state)\n        if state == 0:\n            state = policy[0][2]  # below fan_min, set to default pwm\n            logging.debug('set default state')\n        return state\n\n    def manage_fans(self):\n        LEVEL_FAN_DEF = 1\n        LEVEL_FAN_MID = 2\n        LEVEL_FAN_MAX = 3\n        LEVEL_TEMP_HIGH = 4\n        LEVEL_TEMP_CRITICAL = 5\n\n        FAN_NUM = 2\n        FAN_TRAY_NUM = 6\n\n        fan_policy_state_pwm_tlb = {\n            LEVEL_FAN_DEF:          [38,  0x4],\n            LEVEL_FAN_MID:          [75,  0xB],\n            LEVEL_FAN_MAX:          [100, 0xE],\n            LEVEL_TEMP_HIGH:        [100, 0xE],\n            LEVEL_TEMP_CRITICAL:    [100, 0xE],\n        }\n        global platform_chassis\n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list\n        global temp_test_data\n        global test_temp_revert\n        global alarm_state\n        fan_policy = {\n            0: [0,     39000,   LEVEL_FAN_DEF],  # F2B_policy, B2F_plicy, PWM, reg_val\n            1: [39000, 45000,   LEVEL_FAN_MID],\n            2: [45000, 61000,   LEVEL_FAN_MAX],\n            3: [61000, 66000,   LEVEL_TEMP_HIGH],\n            4: [66000, 200000,  LEVEL_TEMP_CRITICAL],\n        }\n        \n        ori_perc = platform_chassis.get_fan(0).get_speed()\n        #logging.debug('test_temp=%d', test_temp)\n        if test_temp == 0:\n            temp2 = platform_chassis.get_thermal(1).get_temperature()*1000\n            temp4 = platform_chassis.get_thermal(3).get_temperature()*1000\n        else:\n            temp2 = test_temp_list[0]\n            temp4 = test_temp_list[1]\n            # fan_fail=0 # When test no-fan DUT. Need to use this.\n            if test_temp_revert == 0:\n                temp_test_data = temp_test_data+2000\n            else:\n                temp_test_data = temp_test_data-2000\n\n        if temp2 == 0:\n            temp_get = 50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75%\n            logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%')\n        elif temp4 == 0:\n            temp_get = 50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75%\n            logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%')\n        else:\n            temp_get = (temp2 + temp4)/2  # Use (sensor_LM75_49 + Thermal sensor_LM75_CPU_4B) /2\n        logging.debug('Begeinning ,fan_policy_state=%d', fan_policy_state)\n        if test_temp == 1:\n            temp_get = temp_get+temp_test_data\n\n        ori_state = fan_policy_state\n        fan_policy_state = self.get_state_from_fan_policy(temp_get, fan_policy)\n        #logging.debug(\"temp2=\" + str(temp2))\n        #logging.debug(\"temp4=\" + str(temp4))\n        #logging.debug(\"temp_get=\" + str(temp_get))\n        logging.debug('temp2=lm75_49=%d,temp4=lm_4b=%d, temp_get=%d, ori_state=%d', temp2, temp4, temp_get, ori_state)\n        if fan_policy_state > ori_state:\n            logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state)\n        new_perc = fan_policy_state_pwm_tlb[fan_policy_state][0]\n\n        if fan_fail == 0:\n            if new_perc != ori_perc:\n                # fan.set_fan_duty_cycle(new_perc)\n                platform_chassis.get_fan(0).set_speed(new_perc)\n                logging.info('Set fan speed from %d to %d', ori_perc, new_perc)\n\n        # for i in range (fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1):\n        for i in range(FAN_TRAY_NUM * FAN_NUM):\n            if not platform_chassis.get_fan(i).get_status() or not platform_chassis.get_fan(i).get_speed_rpm():\n                new_perc = 100\n                logging.debug('fan_%d fail, set new_perc to 100', i+1)\n                # if test_temp==0:# When test no-fan DUT. Need to use this.\n                fan_fail = 1\n                if ori_state < LEVEL_FAN_MAX:\n                    fan_policy_state = new_state = LEVEL_FAN_MAX\n                    logging.debug('fan_policy_state=%d', fan_policy_state)\n                    logging.warning('fan_policy_state is LEVEL_FAN_MAX')\n                platform_chassis.get_fan(0).set_speed(new_perc)\n                break\n            else:\n                fan_fail = 0\n\n        if fan_fail == 0:\n            new_state = fan_policy_state\n        else:\n            if fan_policy_state > ori_state:\n                new_state = fan_policy_state\n            else:\n                fan_policy_state = new_state = LEVEL_FAN_MAX\n\n        if ori_state == LEVEL_FAN_DEF:\n            if new_state == LEVEL_TEMP_HIGH:\n                if alarm_state == 0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state = 1\n            if new_state == LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n                os.system('reboot')\n        if ori_state == LEVEL_FAN_MID:\n            if new_state == LEVEL_TEMP_HIGH:\n                if alarm_state == 0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state = 1\n            if new_state == LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n        if ori_state == LEVEL_FAN_MAX:\n            if new_state == LEVEL_TEMP_HIGH:\n                if alarm_state == 0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state = 1\n            if new_state == LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n            if alarm_state == 1:\n                if temp_get < (fan_policy[3][0] - 5000):  # below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state = 0\n        if ori_state == LEVEL_TEMP_HIGH:\n            if new_state == LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n            if new_state <= LEVEL_FAN_MID:\n                logging.warning('Alarm for temperature high is cleared')\n                alarm_state = 0\n            if new_state <= LEVEL_FAN_MAX:\n                if temp_get < (fan_policy[3][0] - 5000):  # below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state = 0\n        if ori_state == LEVEL_TEMP_CRITICAL:\n            if new_state <= LEVEL_FAN_MAX:\n                logging.warning('Alarm for temperature critical is cleared')\n\n        return True\n\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv, 'hdlt:', ['lfile='])\n        except getopt.GetoptError:\n            print(('Usage: %s [-d] [-l <log_file>]' % sys.argv[0]))\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print(('Usage: %s [-d] [-l <log_file>]' % sys.argv[0]))\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg\n\n        if sys.argv[1] == '-t':\n            if len(sys.argv) != 4:\n                print(\"temp test, need input four temp\")\n                return 0\n\n            i = 0\n            for x in range(2, 4):\n                test_temp_list[i] = int(sys.argv[x])*1000\n                i = i+1\n            test_temp = 1\n            log_level = logging.DEBUG\n            print(test_temp_list)\n\n    global platform_chassis\n    platform_chassis = platform.Platform().get_chassis()\n\n    platform_chassis.get_fan(0).set_speed(38)\n\n    print(\"set default fan speed to 37.5%\")\n    monitor = device_monitor(log_file, log_level)\n\n    while True:\n        monitor.manage_fans()\n        time.sleep(5)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py": {"changes": [{"diff": "\n \n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', lines[-1])\n         version = int(hn[1], 16)\n", "add": 6, "remove": 6, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py", "badparts": ["    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cdump -y 0 0x42 s 0x9a\"", "        status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]", "        status, output = getstatusoutput_noshell(cmd)"]}, {"diff": "\n     return 0\n \n def eeprom_check():\n-    cmd = \"i2cget -y -f 0 0x56\"\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cget\", \"-y\", \"-f\", \"0\", \"0x56\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     r", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/accton_as7326_util.py", "badparts": ["    cmd = \"i2cget -y -f 0 0x56\"", "    status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cget\", \"-y\", \"-f\", \"0\", \"0x56\"]", "    status, output = getstatusoutput_noshell(cmd)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes \"\"\" import subprocess import getopt import sys import logging import re import time import os PROJECT_NAME='as7326_56x' version='0.1.0' verbose=False DEBUG=False args=[] ALL_DEVICE={} DEVICE_NO={'led':5, 'fan':6,'thermal':4, 'psu':2, 'sfp':58} FORCE=0 if DEBUG==True: print(sys.argv[0]) print('ARGV :', sys.argv[1:]) def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print(options) print(args) print(len(sys.argv)) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': do_install() elif arg=='api': do_sonic_platform_install() elif arg=='api_clean': do_sonic_platform_clean() elif arg=='clean': do_uninstall() else: show_help() return 0 def show_help(): print(__doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]}) sys.exit(0) def dis_i2c_ir3570a(addr): cmd=\"i2cset -y 0 0x%x 0xE5 0x01\" % addr status, output=subprocess.getstatusoutput(cmd) cmd=\"i2cset -y 0 0x%x 0x12 0x02\" % addr status, output=subprocess.getstatusoutput(cmd) return status def ir3570_check(): cmd=\"i2cdump -y 0 0x42 s 0x9a\" try: status, output=subprocess.getstatusoutput(cmd) lines=output.split('\\n') hn=re.findall(r'\\w+', lines[-1]) version=int(hn[1], 16) if version==0x24: ret=dis_i2c_ir3570a(4) else: ret=0 except Exception as e: print(\"Error on ir3570_check() e:\" +str(e)) return -1 return ret def my_log(txt): if DEBUG==True: print(\"[ROY]\"+txt) return def log_os_system(cmd, show): logging.info('Run:'+cmd) status, output=subprocess.getstatusoutput(cmd) my_log(cmd +\"with result:\" +str(status)) my_log(\" output:\"+output) if status: logging.info('Failed:'+cmd) if show: print('Failed:'+cmd) return status, output def driver_check(): ret, lsmod=log_os_system(\"ls /sys/module/*accton*\", 0) logging.info('mods:'+lsmod) if ret: return False else: return True kos=[ 'modprobe i2c_dev', 'modprobe i2c_mux_pca954x', 'modprobe accton_i2c_cpld' , 'modprobe ym2651y' , 'modprobe accton_as7326_56x_fan' , 'modprobe optoe' , 'modprobe accton_as7326_56x_leds' , 'modprobe accton_as7326_56x_psu'] def driver_install(): global FORCE status, output=log_os_system('modprobe i2c_dev', 1) status, output=log_os_system(\"depmod\", 1) for i in range(0,len(kos)): status, output=log_os_system(kos[i], 1) if status: if FORCE==0: return status print(\"Done driver_install\") return 0 def driver_uninstall(): global FORCE for i in range(0,len(kos)): rm=kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\") rm=rm.replace(\"insmod\", \"rmmod\") lst=rm.split(\" \") if len(lst) > 3: del(lst[3]) rm=\" \".join(lst) status, output=log_os_system(rm, 1) if status: if FORCE==0: return status return 0 i2c_prefix='/sys/bus/i2c/devices/' ''' i2c_bus={'fan':['11-0066'] , 'thermal':['15-0048','15-0049', '15-004a', '15-004b'], 'psu':['17-0051','13-0053'], 'sfp':['-0050']} i2c_nodes={'fan':['present', 'front_speed_rpm', 'rear_speed_rpm'], 'thermal':['hwmon/hwmon*/temp1_input'], 'psu':['psu_present ', 'psu_power_good'] , 'sfp':['module_present_', 'module_tx_disable_']} ''' sfp_map=[ 42,41,44,43,47,45,46,50, 48,49,52,51,53,56,55,54, 58,57,60,59,61,63,62,64, 66,68,65,67,69,71,72,70, 74,73,76,75,77,79,78,80, 81,82,84,85,83,87,88,86, 25,26,27,28,29,30,31,32, 22,23] qsfp_start=48 qsfp_end =56 cpld_of_module={'12-0062': list(range(0,30)), \t\t '18-0060': list(range(30,58))} mknod=[ 'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-24/new_device', 'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-33/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-34/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-35/new_device', 'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-36/new_device', 'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-37/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-38/new_device', 'echo as7326_56x_fan 0x66 > /sys/bus/i2c/devices/i2c-11/new_device ', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-15/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-15/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-15/new_device', 'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-15/new_device', 'echo as7326_56x_psu1 0x51 > /sys/bus/i2c/devices/i2c-17/new_device', 'echo ym2651 0x59 > /sys/bus/i2c/devices/i2c-17/new_device', 'echo as7326_56x_psu2 0x53 > /sys/bus/i2c/devices/i2c-13/new_device', 'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-13/new_device', 'echo as7326_56x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo as7326_56x_cpld2 0x62 > /sys/bus/i2c/devices/i2c-12/new_device', 'echo as7326_56x_cpld3 0x64 > /sys/bus/i2c/devices/i2c-19/new_device'] mknod2=[ ] eeprom_mknod=[ 'echo 24c04 0x56 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-0/new_device' ] def i2c_order_check(): return 0 def eeprom_check(): cmd=\"i2cget -y -f 0 0x56\" status, output=subprocess.getstatusoutput(cmd) return status def device_install(): global FORCE order=i2c_order_check() if order: for i in range(0,len(mknod2)): if mknod2[i].find('pca954') !=-1: time.sleep(1) status, output=log_os_system(mknod2[i], 1) if status: print(output) if FORCE==0: return status else: for i in range(0,len(mknod)): if mknod[i].find('pca954') !=-1: time.sleep(1) status, output=log_os_system(mknod[i], 1) if status: print(output) if FORCE==0: return status cmd='echo -2 | tee /sys/bus/i2c/drivers/pca954x/*-00*/idle_state' status, output=log_os_system(cmd, 1) if status: print(output) if FORCE==0: return status log_os_system(\"i2cset -f -y 0 0x77 0 \", 1) ret=eeprom_check() if ret==0: log_os_system(eeprom_mknod[0], 1) time.sleep(0.2) exists=os.path.isfile('/sys/bus/i2c/devices/0-0056/eeprom') if(exists is False): subprocess.call('echo 0x56 > /sys/bus/i2c/devices/i2c-0/delete_device', shell=True) log_os_system(eeprom_mknod[1], 1) else: log_os_system(eeprom_mknod[1], 1) for i in range(0,len(sfp_map)): if i < qsfp_start or i >=qsfp_end: status, output=log_os_system(\"echo optoe2 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1) else: status, output=log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1) if status: print(output) if FORCE==0: return status print(\"Done device_install\") return def device_uninstall(): global FORCE status, output=log_os_system(\"ls /sys/bus/i2c/devices/1-0076\", 0) if status==0: I2C_ORDER=1 else: I2C_ORDER=0 for i in range(0,len(sfp_map)): target=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\" status, output=log_os_system(\"echo 0x50 > \"+target, 1) if status: print(output) if FORCE==0: return status if I2C_ORDER==0: nodelist=mknod else: nodelist=mknod2 for i in range(len(nodelist)): target=nodelist[-(i+1)] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status exists=os.path.isfile('/sys/bus/i2c/devices/0-0056/eeprom') if(exists is True): target=eeprom_mknod[0] else: target=eeprom_mknod[1] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status return def system_ready(): if driver_check()==False: return False if not device_exist(): return False return True PLATFORM_ROOT_PATH='/usr/share/sonic/device' PLATFORM_API2_WHL_FILE_PY3='sonic_platform-1.0-py3-none-any.whl' def do_sonic_platform_install(): device_path=\"{}{}{}{}\".format(PLATFORM_ROOT_PATH, '/x86_64-accton_', PROJECT_NAME, '-r0') SONIC_PLATFORM_BSP_WHL_PKG_PY3=\"/\".join([device_path, PLATFORM_API2_WHL_FILE_PY3]) status, output=log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0) if status: if os.path.exists(SONIC_PLATFORM_BSP_WHL_PKG_PY3): status, output=log_os_system(\"pip3 install \"+SONIC_PLATFORM_BSP_WHL_PKG_PY3, 1) if status: print(\"Error: Failed to install{}\".format(PLATFORM_API2_WHL_FILE_PY3)) return status else: print(\"Successfully installed{} package\".format(PLATFORM_API2_WHL_FILE_PY3)) else: print('{} is not found'.format(PLATFORM_API2_WHL_FILE_PY3)) else: print('{} has installed'.format(PLATFORM_API2_WHL_FILE_PY3)) return def do_sonic_platform_clean(): status, output=log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0) if status: print('{} does not install, not need to uninstall'.format(PLATFORM_API2_WHL_FILE_PY3)) else: status, output=log_os_system(\"pip3 uninstall sonic-platform -y\", 0) if status: print('Error: Failed to uninstall{}'.format(PLATFORM_API2_WHL_FILE_PY3)) return status else: print('{} is uninstalled'.format(PLATFORM_API2_WHL_FILE_PY3)) return def do_install(): print(\"Checking system....\") if driver_check()==False: print(\"No driver, installing....\") status=driver_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" drivers detected....\") ir3570_check() if not device_exist(): print(\"No device, installing....\") status=device_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" devices detected....\") do_sonic_platform_install() return def do_uninstall(): print(\"Checking system....\") if not device_exist(): print(PROJECT_NAME.upper() +\" has no device installed....\") else: print(\"Removing device....\") status=device_uninstall() if status: if FORCE==0: return status if driver_check()==False: print(PROJECT_NAME.upper() +\" has no driver installed....\") else: print(\"Removing installed driver....\") status=driver_uninstall() if status: if FORCE==0: return status do_sonic_platform_clean() return def device_exist(): ret1, log=log_os_system(\"ls \"+i2c_prefix+\"*0070\", 0) ret2, log=log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# Copyright (C) 2016 Accton Networks, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean\ncommand:\n    install     : install drivers and generate related sysfs nodes\n    clean       : uninstall drivers and remove related sysfs nodes\n\"\"\"\nimport subprocess\nimport getopt\nimport sys\nimport logging\nimport re\nimport time\nimport os\n\n\n\nPROJECT_NAME = 'as7326_56x'\nversion = '0.1.0'\nverbose = False\nDEBUG = False\nargs = []\nALL_DEVICE = {}\nDEVICE_NO = {'led':5, 'fan':6,'thermal':4, 'psu':2, 'sfp':58}\nFORCE = 0\n#logging.basicConfig(filename= PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG)\n#logging.basicConfig(level=logging.INFO)\n\n\nif DEBUG == True:\n    print(sys.argv[0])\n    print('ARGV      :', sys.argv[1:])\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n\n    if len(sys.argv)<2:\n        show_help()\n\n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:                \n        print(options)\n        print(args)\n        print(len(sys.argv))\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n           do_install()\n        elif arg == 'api':\n           do_sonic_platform_install()\n        elif arg == 'api_clean':\n           do_sonic_platform_clean()\n        elif arg == 'clean':\n           do_uninstall()\n        else:\n            show_help()\n    return 0\n\ndef show_help():\n    print(__doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]})\n    sys.exit(0)\n\n\n\ndef dis_i2c_ir3570a(addr):\n    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef ir3570_check():\n    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n    try:\n        status, output = subprocess.getstatusoutput(cmd)\n        lines = output.split('\\n')\n        hn = re.findall(r'\\w+', lines[-1])\n        version = int(hn[1], 16)\n        if version == 0x24:  #only for ir3570a\n            ret = dis_i2c_ir3570a(4)\n        else:\n            ret = 0\n    except Exception as e:\n        print(\"Error on ir3570_check() e:\" + str(e))\n        return -1\n    return ret\n\n\ndef my_log(txt):\n    if DEBUG == True:\n        print(\"[ROY]\"+txt)\n    return\n\ndef log_os_system(cmd, show):\n    logging.info('Run :'+cmd)\n    status, output = subprocess.getstatusoutput(cmd)\n    my_log (cmd +\"with result:\" + str(status))\n    my_log (\"      output:\"+output)\n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print('Failed :'+cmd)\n    return  status, output\n\ndef driver_check():\n    ret, lsmod = log_os_system(\"ls /sys/module/*accton*\", 0)\n    logging.info('mods:'+lsmod)\n    if ret :\n        return False\n    else :\n        return True\n\n\n\nkos = [\n'modprobe i2c_dev',\n'modprobe i2c_mux_pca954x',\n'modprobe accton_i2c_cpld'  ,\n'modprobe ym2651y'                  ,\n'modprobe accton_as7326_56x_fan'     ,\n'modprobe optoe'      ,\n'modprobe accton_as7326_56x_leds'      ,\n'modprobe accton_as7326_56x_psu' ]\n\ndef driver_install():\n    global FORCE\n    \n    status, output = log_os_system('modprobe i2c_dev', 1)\n    status, output = log_os_system(\"depmod\", 1)\n    for i in range(0,len(kos)):\n        status, output = log_os_system(kos[i], 1)\n        if status:\n            if FORCE == 0:\n                return status\n    print(\"Done driver_install\")\n    \n    return 0\n\ndef driver_uninstall():\n    global FORCE\n    for i in range(0,len(kos)):\n        rm = kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\")\n        rm = rm.replace(\"insmod\", \"rmmod\")\n        lst = rm.split(\" \")\n        if len(lst) > 3:\n            del(lst[3])\n        rm = \" \".join(lst)\n        status, output = log_os_system(rm, 1)\n        if status:\n            if FORCE == 0:\n                return status\n    return 0\n\ni2c_prefix = '/sys/bus/i2c/devices/'\n'''\ni2c_bus = {'fan': ['11-0066']                 ,\n           'thermal': ['15-0048','15-0049', '15-004a', '15-004b'] ,\n           'psu': ['17-0051','13-0053'],\n           'sfp': ['-0050']}\ni2c_nodes = {'fan': ['present', 'front_speed_rpm', 'rear_speed_rpm'] ,\n           'thermal': ['hwmon/hwmon*/temp1_input'] ,\n           'psu': ['psu_present ', 'psu_power_good']    ,\n           'sfp': ['module_present_', 'module_tx_disable_']}\n'''\nsfp_map =  [\n        42,41,44,43,47,45,46,50,\n        48,49,52,51,53,56,55,54,\n        58,57,60,59,61,63,62,64,\n        66,68,65,67,69,71,72,70,\n        74,73,76,75,77,79,78,80,\n        81,82,84,85,83,87,88,86,    #port 41~48\n        25,26,27,28,29,30,31,32,    #port 49~56 QSFP\n        22,23]                      #port 57~58 SFP+ from CPU NIF.\nqsfp_start = 48\nqsfp_end   = 56\n\n#For sideband signals of SFP/QSFP modules.\ncpld_of_module = {'12-0062': list(range(0,30)),\n\t\t  '18-0060': list(range(30,58)) }\n\n\nmknod =[\n'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-1/new_device' ,\n'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-1/new_device' ,\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-24/new_device' ,\n'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-2/new_device' ,\n'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-33/new_device',\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-34/new_device',\n'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-35/new_device',\n'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-36/new_device',\n'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-37/new_device',\n'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-38/new_device',\n\n'echo as7326_56x_fan 0x66 > /sys/bus/i2c/devices/i2c-11/new_device ',\n'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-15/new_device',\n'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-15/new_device',\n'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-15/new_device',\n'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-15/new_device',\n'echo as7326_56x_psu1 0x51 > /sys/bus/i2c/devices/i2c-17/new_device',\n'echo ym2651 0x59 > /sys/bus/i2c/devices/i2c-17/new_device',\n'echo as7326_56x_psu2 0x53 > /sys/bus/i2c/devices/i2c-13/new_device',\n'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-13/new_device',\n'echo as7326_56x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo as7326_56x_cpld2 0x62 > /sys/bus/i2c/devices/i2c-12/new_device',\n'echo as7326_56x_cpld3 0x64 > /sys/bus/i2c/devices/i2c-19/new_device']\n\nmknod2 =[\n]\n\n#EERPOM\neeprom_mknod =[\n'echo 24c04 0x56 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-0/new_device'\n]\n\n\ndef i2c_order_check():\n    # This project has only 1 i2c bus.\n    return 0\n\ndef eeprom_check():\n    cmd = \"i2cget -y -f 0 0x56\"\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef device_install():\n    global FORCE\n\n    order = i2c_order_check()\n\n    # if 0x70 is not exist @i2c-1, use reversed bus order\n    if order:\n        for i in range(0,len(mknod2)):\n            #for pca954x need times to built new i2c buses\n            if mknod2[i].find('pca954') != -1:\n               time.sleep(1)\n\n            status, output = log_os_system(mknod2[i], 1)\n            if status:\n                print(output)\n                if FORCE == 0:\n                    return status\n    else:\n        for i in range(0,len(mknod)):\n            #for pca954x need times to built new i2c buses\n            if mknod[i].find('pca954') != -1:\n               time.sleep(1)\n\n            status, output = log_os_system(mknod[i], 1)\n            if status:\n                print(output)\n                if FORCE == 0:\n                    return status\n\n    # set all pca954x idle_disconnect\n    cmd = 'echo -2 | tee /sys/bus/i2c/drivers/pca954x/*-00*/idle_state'\n    status, output = log_os_system(cmd, 1)\n    if status:\n        print(output)\n        if FORCE == 0:\n            return status\n    \n    # initiate IDPROM\n    # Close 0x77 mux to make sure if the I2C address of IDPROM is 0x56 or 0x57\n    log_os_system(\"i2cset -f -y 0 0x77 0 \", 1)\n    ret=eeprom_check()\n    if ret==0:\n        log_os_system(eeprom_mknod[0], 1) #old board, 0x56 eeprom\n        time.sleep(0.2)\n        exists = os.path.isfile('/sys/bus/i2c/devices/0-0056/eeprom')\n        if (exists is False):\n            subprocess.call('echo 0x56 > /sys/bus/i2c/devices/i2c-0/delete_device', shell=True)\n            log_os_system(eeprom_mknod[1], 1)\n    else:\n        log_os_system(eeprom_mknod[1], 1) #new board, 0x57 eeprom                \n                    \n                    \n    for i in range(0,len(sfp_map)):\n        if i < qsfp_start or i >= qsfp_end:\n            status, output =log_os_system(\"echo optoe2 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1)\n        else:\n            status, output =log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n    print(\"Done device_install\")\n    return\n\ndef device_uninstall():\n    global FORCE\n\n    status, output =log_os_system(\"ls /sys/bus/i2c/devices/1-0076\", 0)\n    if status==0:\n        I2C_ORDER=1\n    else:\n        I2C_ORDER=0\n\n    for i in range(0,len(sfp_map)):\n        target = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\"\n        status, output =log_os_system(\"echo 0x50 > \"+ target, 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    if I2C_ORDER==0:\n        nodelist = mknod\n    else:\n        nodelist = mknod2\n\n    for i in range(len(nodelist)):\n        target = nodelist[-(i+1)]\n        temp = target.split()\n        del temp[1]\n        temp[-1] = temp[-1].replace('new_device', 'delete_device')\n        status, output = log_os_system(\" \".join(temp), 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    #Deal with for del 0x56 or 0x57 sysfs device    \n    exists = os.path.isfile('/sys/bus/i2c/devices/0-0056/eeprom')\n        \n    if (exists is True):\n        target = eeprom_mknod[0] #0x56\n    else:\n        target = eeprom_mknod[1] #0x57\n    \n    temp = target.split()\n    del temp[1]\n    temp[-1] = temp[-1].replace('new_device', 'delete_device')\n    status, output = log_os_system(\" \".join(temp), 1)\n    if status:\n        print(output)\n        if FORCE == 0:\n           return status\n\n    return\n\ndef system_ready():\n    if driver_check() == False:\n        return False\n    if not device_exist():\n        return False\n    return True\nPLATFORM_ROOT_PATH = '/usr/share/sonic/device'\nPLATFORM_API2_WHL_FILE_PY3 ='sonic_platform-1.0-py3-none-any.whl'\ndef do_sonic_platform_install():\n    device_path = \"{}{}{}{}\".format(PLATFORM_ROOT_PATH, '/x86_64-accton_', PROJECT_NAME, '-r0')\n    SONIC_PLATFORM_BSP_WHL_PKG_PY3 = \"/\".join([device_path, PLATFORM_API2_WHL_FILE_PY3])\n\n    #Check API2.0 on py whl file\n    status, output = log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0)\n    if status:\n        if os.path.exists(SONIC_PLATFORM_BSP_WHL_PKG_PY3): \n            status, output = log_os_system(\"pip3 install \"+ SONIC_PLATFORM_BSP_WHL_PKG_PY3, 1)\n            if status:\n                print(\"Error: Failed to install {}\".format(PLATFORM_API2_WHL_FILE_PY3))\n                return status\n            else:\n                print(\"Successfully installed {} package\".format(PLATFORM_API2_WHL_FILE_PY3))\n        else:\n            print('{} is not found'.format(PLATFORM_API2_WHL_FILE_PY3))\n    else:        \n        print('{} has installed'.format(PLATFORM_API2_WHL_FILE_PY3))\n     \n    return \n     \ndef do_sonic_platform_clean():\n    status, output = log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0)   \n    if status:\n        print('{} does not install, not need to uninstall'.format(PLATFORM_API2_WHL_FILE_PY3))\n        \n    else:        \n        status, output = log_os_system(\"pip3 uninstall sonic-platform -y\", 0)\n        if status:\n            print('Error: Failed to uninstall {}'.format(PLATFORM_API2_WHL_FILE_PY3))\n            return status\n        else:\n            print('{} is uninstalled'.format(PLATFORM_API2_WHL_FILE_PY3))\n    \n    \n    return\n\ndef do_install():\n    print(\"Checking system....\")\n    if driver_check() == False:\n        print(\"No driver, installing....\")\n        status = driver_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print(PROJECT_NAME.upper()+\" drivers detected....\")\n\n    ir3570_check()\n\n    if not device_exist():\n        print(\"No device, installing....\")\n        status = device_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print(PROJECT_NAME.upper()+\" devices detected....\")\n\n    do_sonic_platform_install()\n        \n    return\n\ndef do_uninstall():\n    print(\"Checking system....\")\n    if not device_exist():\n        print(PROJECT_NAME.upper() +\" has no device installed....\")\n    else:\n        print(\"Removing device....\")\n        status = device_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    if driver_check()== False :\n        print(PROJECT_NAME.upper() +\" has no driver installed....\")\n    else:\n        print(\"Removing installed driver....\")\n        status = driver_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    do_sonic_platform_clean()\n\n    return\n\ndef device_exist():\n    ret1, log = log_os_system(\"ls \"+i2c_prefix+\"*0070\", 0)\n    ret2, log = log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as7326-platform-fan.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as7326-platform-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Stop as7326-platform-init.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Disable as7326-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as7326_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n", "add": 7, "remove": 7, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py", "badparts": ["import subprocess", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as7326-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py clean\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7326-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7326-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"clean\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"install\"])\n     if status:\n         print(\"accton_as7326_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7326-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7326-platform-monitor.service\"])\n     if status:\n         print(\"Enable as7326-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as7326-platform-monitor-fan.service failed %d\"%status)\n         return False\n         \n-    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as7326-platform-monitor-psu.service failed %d\"%status)\n         return False\n", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py install\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as7326-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-psu.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7326_util.py\", \"install\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7326-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7326-platform-monitor-psu.service\"])"]}, {"diff": "\n     return True\n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service fa", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7326-56x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}], "source": "\n import subprocess def check_pddf_support(): return True def stop_platform_svc(): status, output=subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-fan.service\") if status: print(\"Stop as7326-platform-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-psu.service\") if status: print(\"Stop as7326-platform-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor.service\") if status: print(\"Stop as7326-platform-init.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl disable as7326-platform-monitor.service\") if status: print(\"Disable as7326-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py clean\") if status: print(\"accton_as7326_util.py clean command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status) return False return True def start_platform_svc(): status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py install\") if status: print(\"accton_as7326_util.py install command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl enable as7326-platform-monitor.service\") if status: print(\"Enable as7326-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-fan.service\") if status: print(\"Start as7326-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-psu.service\") if status: print(\"Start as7326-platform-monitor-psu.service failed %d\"%status) return False return True def start_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print(\"Start pddf-platform-init.service failed %d\"%status) return False return True def stop_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service failed %d\"%status) return False return True def main(): print(\"stop_platform_svc\") stop_platform_svc() print(\"stop_platform_pddf\") stop_platform_pddf() if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services. \n# This will be used while switching the pddf->non-pddf mode and vice versa\n\nimport subprocess\n\ndef check_pddf_support():\n    return True\n\ndef stop_platform_svc():\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-fan.service\")\n    if status:\n        print(\"Stop as7326-platform-fan.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor-psu.service\")\n    if status:\n        print(\"Stop as7326-platform-psu.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as7326-platform-monitor.service\")\n    if status:\n        print(\"Stop as7326-platform-init.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as7326-platform-monitor.service\")\n    if status:\n        print(\"Disable as7326-platform-monitor.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py clean\")\n    if status:\n        print(\"accton_as7326_util.py clean command failed %d\"%status)\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n        return False\n\n    return True\n    \ndef start_platform_svc():\n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7326_util.py install\")\n    if status:\n        print(\"accton_as7326_util.py install command failed %d\"%status)\n        return False\n\n    status, output = subprocess.getstatusoutput(\"systemctl enable as7326-platform-monitor.service\")\n    if status:\n        print(\"Enable as7326-platform-monitor.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-fan.service\")\n    if status:\n        print(\"Start as7326-platform-monitor-fan.service failed %d\"%status)\n        return False\n        \n    status, output = subprocess.getstatusoutput(\"systemctl start as7326-platform-monitor-psu.service\")\n    if status:\n        print(\"Start as7326-platform-monitor-psu.service failed %d\"%status)\n        return False\n\n    return True\n\ndef start_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print(\"Start pddf-platform-init.service failed %d\"%status)\n        return False\n    \n    return True\n\ndef stop_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service failed %d\"%status)\n        return False\n\n    return True\n\ndef main():\n    print(\"stop_platform_svc\")\n    stop_platform_svc()\n    #print\"start_platform_svc\"\n    #start_platform_svc()\n    #print\"start_platform_pddf\"\n    #start_platform_pddf()\n    print(\"stop_platform_pddf\")\n    stop_platform_pddf()\n    #pass\n\nif __name__ == \"__main__\":\n    main()\n\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import commands\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = commands.getstatusoutput(\"systemctl stop as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Stop as7712-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl disable as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Disable as7712-platform-init.service failed %d\"%status)\n         return False\n     \n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"clean\"])\n     if status:\n-        print(\"accton_as7712_util.py clean command failed %d\"%status)\n+        print(\"accton_as7712_util.py clean failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n", "add": 6, "remove": 6, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py", "badparts": ["import commands", "    status, output = commands.getstatusoutput(\"systemctl stop as7712-platform-init.service\")", "    status, output = commands.getstatusoutput(\"systemctl disable as7712-platform-init.service\")", "    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py clean\")", "        print(\"accton_as7712_util.py clean command failed %d\"%status)", "    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7712-platform-init.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7712-platform-init.service\"])", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"clean\"])", "        print(\"accton_as7712_util.py clean failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n     \n def start_platform_svc():\n-    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"install\"])\n     if status:\n-        print(\"accton_as7712_util.py install command failed %d\"%status)\n+        print(\"accton_as7712_util.py install failed %d\"%status)\n         return False\n \n-    status, output = commands.getstatusoutput(\"systemctl enable as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Enable as7712-platform-init.service failed %d\"%status)\n         return False\n-    status, output = commands.getstatusoutput(\"systemctl start as7712-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7712-platform-init.service\"])\n     if status:\n         print(\"Start as7712-platform-init.service failed %d\"%status)\n         return False\n", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py install\")", "        print(\"accton_as7712_util.py install command failed %d\"%status)", "    status, output = commands.getstatusoutput(\"systemctl enable as7712-platform-init.service\")", "    status, output = commands.getstatusoutput(\"systemctl start as7712-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7712_util.py\", \"install\"])", "        print(\"accton_as7712_util.py install failed %d\"%status)", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7712-platform-init.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7712-platform-init.service\"])"]}, {"diff": "\n     return True\n \n def start_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n \n def stop_platform_pddf():\n-    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service f", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7712-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}], "source": "\n import commands def check_pddf_support(): return True def stop_platform_svc(): status, output=commands.getstatusoutput(\"systemctl stop as7712-platform-init.service\") if status: print(\"Stop as7712-platform-init.service failed %d\"%status) return False status, output=commands.getstatusoutput(\"systemctl disable as7712-platform-init.service\") if status: print(\"Disable as7712-platform-init.service failed %d\"%status) return False status, output=commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py clean\") if status: print(\"accton_as7712_util.py clean command failed %d\"%status) return False status, output=commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status) return False return True def start_platform_svc(): status, output=commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py install\") if status: print(\"accton_as7712_util.py install command failed %d\"%status) return False status, output=commands.getstatusoutput(\"systemctl enable as7712-platform-init.service\") if status: print(\"Enable as7712-platform-init.service failed %d\"%status) return False status, output=commands.getstatusoutput(\"systemctl start as7712-platform-init.service\") if status: print(\"Start as7712-platform-init.service failed %d\"%status) return False return True def start_platform_pddf(): status, output=commands.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print(\"Start pddf-platform-init.service failed %d\"%status) return False return True def stop_platform_pddf(): status, output=commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service failed %d\"%status) return False return True def main(): pass if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services. \n# This will be used while switching the pddf->non-pddf mode and vice versa\nimport commands\n\ndef check_pddf_support():\n    return True\n\ndef stop_platform_svc():\n    status, output = commands.getstatusoutput(\"systemctl stop as7712-platform-init.service\")\n    if status:\n        print(\"Stop as7712-platform-init.service failed %d\"%status)\n        return False\n    status, output = commands.getstatusoutput(\"systemctl disable as7712-platform-init.service\")\n    if status:\n        print(\"Disable as7712-platform-init.service failed %d\"%status)\n        return False\n    \n    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py clean\")\n    if status:\n        print(\"accton_as7712_util.py clean command failed %d\"%status)\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n        return False\n\n    return True\n    \ndef start_platform_svc():\n    status, output = commands.getstatusoutput(\"/usr/local/bin/accton_as7712_util.py install\")\n    if status:\n        print(\"accton_as7712_util.py install command failed %d\"%status)\n        return False\n\n    status, output = commands.getstatusoutput(\"systemctl enable as7712-platform-init.service\")\n    if status:\n        print(\"Enable as7712-platform-init.service failed %d\"%status)\n        return False\n    status, output = commands.getstatusoutput(\"systemctl start as7712-platform-init.service\")\n    if status:\n        print(\"Start as7712-platform-init.service failed %d\"%status)\n        return False\n\n    return True\n\ndef start_platform_pddf():\n    status, output = commands.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print(\"Start pddf-platform-init.service failed %d\"%status)\n        return False\n    \n    return True\n\ndef stop_platform_pddf():\n    status, output = commands.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service failed %d\"%status)\n        return False\n\n    return True\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py": {"changes": [{"diff": "\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', line", "add": 6, "remove": 6, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7716-32x/utils/accton_as7716_util.py", "badparts": ["    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cdump -y 0 0x42 s 0x9a\"", "        status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]", "        status, output = getstatusoutput_noshell(cmd)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes show : show all systen status sff : dump SFP eeprom set : change board setting with fan|led|sfp \"\"\" import subprocess import getopt import sys import logging import re import time PROJECT_NAME='as7716_32x' version='0.0.1' verbose=False DEBUG=False args=[] ALL_DEVICE={} DEVICE_NO={'led':5, 'fan1':1, 'fan2':1,'fan3':1,'fan4':1,'fan5':1,'thermal':3, 'psu':2, 'sfp':54} led_prefix='/sys/devices/platform/as7716_32x_led/leds/accton_'+PROJECT_NAME+'_led::' fan_prefix='/sys/devices/platform/as7716_32x_' hwmon_types={'led':['diag','fan','loc','psu1','psu2'], 'fan1':['fan'], 'fan2':['fan'], 'fan3':['fan'], 'fan4':['fan'], 'fan5':['fan'], } hwmon_nodes={'led':['brightness'], 'fan1':['fan_duty_cycle_percentage', 'fan1_fault', 'fan1_speed_rpm', 'fan1_direction', 'fanr1_fault', 'fanr1_speed_rpm'], 'fan2':['fan_duty_cycle_percentage','fan2_fault', 'fan2_speed_rpm', 'fan2_direction', 'fanr2_fault', 'fanr2_speed_rpm'], 'fan3':['fan_duty_cycle_percentage','fan3_fault', 'fan3_speed_rpm', 'fan3_direction', 'fanr3_fault', 'fanr3_speed_rpm'], 'fan4':['fan4_duty_cycle_percentage','fan4_fault', 'fan4_speed_rpm', 'fan4_direction', 'fanr4_fault', 'fanr4_speed_rpm'], 'fan5':['fan_duty_cycle_percentage','fan5_fault', 'fan5_speed_rpm', 'fan5_direction', 'fanr5_fault', 'fanr5_speed_rpm'], \t } hwmon_prefix={'led': led_prefix, 'fan1': fan_prefix, 'fan2': fan_prefix, 'fan3': fan_prefix, 'fan4': fan_prefix, 'fan5': fan_prefix, } i2c_prefix='/sys/bus/i2c/devices/' i2c_bus={'thermal':['10-0048','10-0049', '10-004a'], 'psu':['17-0050','18-0053'], 'sfp':['-0050']} i2c_nodes={ 'thermal':['hwmon/hwmon*/temp1_input'], 'psu':['psu_present ', 'psu_power_good'] , 'sfp':['sfp_is_present ', 'sfp_tx_disable']} sfp_map=[29, 30, 31, 32, 34, 33, 36, 35, 25, 26, 27, 28, 37, 38, 39, 40, 41, 42, 43, 44, 53, 54, 55, 56, 45, 46, 47, 48, 49, 50, 51, 52] mknod=[ 'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo as7716_32x_fan 0x66 > /sys/bus/i2c/devices/i2c-9/new_device', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-10/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-10/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-10/new_device', 'echo as7716_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-11/new_device', 'echo accton_i2c_cpld 0x62 > /sys/bus/i2c/devices/i2c-12/new_device', 'echo accton_i2c_cpld 0x64 > /sys/bus/i2c/devices/i2c-13/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo as7716_32x_psu1 0x53 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-18/new_device', 'echo as7716_32x_psu2 0x50> /sys/bus/i2c/devices/i2c-17/new_device', 'echo ym2651 0x58 > /sys/bus/i2c/devices/i2c-17/new_device', 'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-1/new_device', ] mknod2=[ 'echo as7716_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo accton_i2c_cpld 0x61 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo accton_i2c_cpld 0x62 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo as7716_32x_psu1 0x38 > /sys/bus/i2c/devices/i2c-57/new_device', 'echo cpr_4011_4mxx 0x3c > /sys/bus/i2c/devices/i2c-57/new_device', 'echo as7716_32x_psu1 0x50 > /sys/bus/i2c/devices/i2c-57/new_device', 'echo ym2401 0x58 > /sys/bus/i2c/devices/i2c-57/new_device', 'echo as7716_32x_psu2 0x3b > /sys/bus/i2c/devices/i2c-58/new_device', 'echo cpr_4011_4mxx 0x3f > /sys/bus/i2c/devices/i2c-58/new_device', 'echo as7716_32x_psu2 0x53 > /sys/bus/i2c/devices/i2c-58/new_device', 'echo ym2401 0x5b > /sys/bus/i2c/devices/i2c-58/new_device', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-61/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-62/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-63/new_device', 'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-1/new_device', ] FORCE=0 logging.basicConfig(filename=PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG) logging.basicConfig(level=logging.INFO) if DEBUG==True: print(sys.argv[0]) print('ARGV :', sys.argv[1:]) def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print(options) print(args) print(len(sys.argv)) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': do_install() elif arg=='clean': do_uninstall() elif arg=='show': device_traversal() elif arg=='sff': if len(args)!=2: show_eeprom_help() elif int(args[1])==0 or int(args[1]) > DEVICE_NO['sfp']: show_eeprom_help() else: show_eeprom(args[1]) return elif arg=='set': if len(args)<3: show_set_help() else: set_device(args[1:]) return else: show_help() return 0 def show_help(): print(__doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]}) sys.exit(0) def show_set_help(): cmd= sys.argv[0].split(\"/\")[-1]+\" \" +args[0] print(cmd +\"[led|sfp|fan]\") print(\" use \\\"\"+cmd +\" led 0-4 \\\" to set led color\") print(\" use \\\"\"+cmd +\" fan 0-100\\\" to set fan duty percetage\") print(\" use \\\"\"+cmd +\" sfp 1-32{0|1}\\\" to set sfp sys.exit(0) def dis_i2c_ir3570a(addr): cmd=\"i2cset -y 0 0x%x 0xE5 0x01\" % addr status, output=subprocess.getstatusoutput(cmd) cmd=\"i2cset -y 0 0x%x 0x12 0x02\" % addr status, output=subprocess.getstatusoutput(cmd) return status def ir3570_check(): cmd=\"i2cdump -y 0 0x42 s 0x9a\" try: status, output=subprocess.getstatusoutput(cmd) lines=output.split('\\n') hn=re.findall(r'\\w+', lines[-1]) version=int(hn[1], 16) if version==0x24: ret=dis_i2c_ir3570a(4) else: ret=0 except Exception as e: print(\"Error on ir3570_check() e:\" +str(e)) return -1 return ret def show_eeprom_help(): cmd= sys.argv[0].split(\"/\")[-1]+\" \" +args[0] print(\" use \\\"\"+cmd +\" 1-32 \\\" to dump sfp sys.exit(0) def my_log(txt): if DEBUG==True: print(\"[ACCTON DBG]: \"+txt) return def log_os_system(cmd, show): logging.info('Run:'+cmd) status=1 output=\"\" status, output=subprocess.getstatusoutput(cmd) my_log(cmd +\"with result:\" +str(status)) my_log(\"cmd:\" +cmd) my_log(\" output:\"+output) if status: logging.info('Failed:'+cmd) if show: print(('Failed:'+cmd)) return status, output def driver_inserted(): ret, lsmod=log_os_system(\"ls /sys/module/*accton*\", 0) logging.info('mods:'+lsmod) if ret: return False else: return True kos=[ 'depmod -ae', 'modprobe i2c_dev', 'modprobe i2c_mux_pca954x force_deselect_on_exit=1', 'modprobe accton_i2c_cpld', 'modprobe cpr_4011_4mxx', 'modprobe ym2651y', 'modprobe accton_as7716_32x_cpld1', 'modprobe accton_as7716_32x_fan', 'modprobe accton_as7716_32x_leds', 'modprobe accton_as7716_32x_psu'] def driver_install(): global FORCE for i in range(0,len(kos)): status, output=log_os_system(kos[i], 1) if status: if FORCE==0: return status return 0 def driver_uninstall(): global FORCE for i in range(0,len(kos)): rm=kos[-(i+1)] lst=rm.split(\" \") if len(lst) > 2: del(lst[2:]) rm=\" \".join(lst) rm=rm.replace(\"modprobe\", \"modprobe -rq\") rm=rm.replace(\"insmod\", \"rmmod\") status, output=log_os_system(rm, 1) if status: if FORCE==0: return status return 0 def i2c_order_check(): tmp=\"echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-1/new_device\" status, output=log_os_system(tmp, 0) if not device_exist(): order=1 else: order=0 tmp=\"echo 0x70 > /sys/bus/i2c/devices/i2c-1/delete_device\" status, output=log_os_system(tmp, 0) return order def device_install(): global FORCE for i in range(0,len(mknod)): if mknod[i].find('pca954') !=-1: time.sleep(2) status, output=log_os_system(mknod[i], 1) if status: print(output) if FORCE==0: return status for i in range(0,len(sfp_map)): status, output=log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1) if status: print(output) if FORCE==0: return status status, output=log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1) if status: print(output) if FORCE==0: return status return def device_uninstall(): global FORCE status, output=log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0) if status==0: I2C_ORDER=1 else: \tI2C_ORDER=0 for i in range(0,len(sfp_map)): target=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\" status, output=log_os_system(\"echo 0x50 > \"+target, 1) if status: print(output) if FORCE==0: return status if I2C_ORDER==0: nodelist=mknod else: nodelist=mknod2 for i in range(len(nodelist)): target=nodelist[-(i+1)] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status return def system_ready(): if driver_inserted()==False: return False if not device_exist(): print(\"not device_exist()\") return False return True def do_install(): if driver_inserted()==False: status=driver_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" drivers detected....\") ir3570_check() if not device_exist(): status=device_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" devices detected....\") return def do_uninstall(): if not device_exist(): print(PROJECT_NAME.upper() +\" has no device installed....\") else: print(\"Removing device....\") status=device_uninstall() if status: if FORCE==0: return status if driver_inserted()==False: print(PROJECT_NAME.upper() +\" has no driver installed....\") else: print(\"Removing installed driver....\") status=driver_uninstall() if status: if FORCE==0: return status return def devices_info(): global DEVICE_NO global ALL_DEVICE global i2c_bus, hwmon_types for key in DEVICE_NO: ALL_DEVICE[key]={} for i in range(0,DEVICE_NO[key]): ALL_DEVICE[key][key+str(i+1)]=[] for key in i2c_bus: buses=i2c_bus[key] nodes=i2c_nodes[key] for i in range(0,len(buses)): for j in range(0,len(nodes)): if 'fan'==key: for k in range(0,DEVICE_NO[key]): node=key+str(k+1) path=i2c_prefix+buses[i]+\"/fan\"+str(k+1)+\"_\"+nodes[j] my_log(node+\": \"+path) ALL_DEVICE[key][node].append(path) elif 'sfp'==key: for k in range(0,DEVICE_NO[key]): node=key+str(k+1) path=i2c_prefix+str(sfp_map[k])+buses[i]+\"/\"+nodes[j] my_log(node+\": \"+path) ALL_DEVICE[key][node].append(path) else: node=key+str(i+1) path=i2c_prefix+buses[i]+\"/\"+nodes[j] my_log(node+\": \"+path) ALL_DEVICE[key][node].append(path) for key in hwmon_types: itypes=hwmon_types[key] nodes=hwmon_nodes[key] for i in range(0,len(itypes)): for j in range(0,len(nodes)): node=key+\"_\"+itypes[i] path=hwmon_prefix[key]+itypes[i]+\"/\"+nodes[j] my_log(node+\": \"+path) ALL_DEVICE[key][ key+str(i+1)].append(path) if DEBUG==True: for i in sorted(ALL_DEVICE.keys()): print((i+\": \")) for j in sorted(ALL_DEVICE[i].keys()): print((\" \"+j)) for k in(ALL_DEVICE[i][j]): print((\" \"+\" \"+k)) return def show_eeprom(index): if system_ready()==False: print(\"System's not ready.\") print(\"Please install first!\") return if len(ALL_DEVICE)==0: devices_info() node=ALL_DEVICE['sfp']['sfp'+str(index)][0] node=node.replace(node.split(\"/\")[-1], 'sfp_eeprom') ret, log=log_os_system(\"which hexdump\", 0) ret, log2=log_os_system(\"which busybox hexdump\", 0) if len(log): hex_cmd='hexdump' elif len(log2): hex_cmd=' busybox hexdump' else: log='Failed: no hexdump cmd!!' logging.info(log) print(log) return 1 print(node +\":\") ret, log=log_os_system(\"cat \"+node+\"| \"+hex_cmd+\" -C\", 1) if ret==0: print(log) else: print(\"**********device no found**********\") return def set_device(args): global DEVICE_NO global ALL_DEVICE if system_ready()==False: print(\"System's not ready.\") print(\"Please install first!\") return if len(ALL_DEVICE)==0: devices_info() if args[0]=='led': if int(args[1])>4: show_set_help() return for i in range(0,len(ALL_DEVICE['led'])): for k in(ALL_DEVICE['led']['led'+str(i+1)]): ret, log=log_os_system(\"echo \"+args[1]+\" >\"+k, 1) if ret: return ret elif args[0]=='fan': if int(args[1])>100: show_set_help() return node=ALL_DEVICE['fan1']['fan11'][0] node=node.replace(node.split(\"/\")[-1], 'fan1_duty_cycle_percentage') ret, log=log_os_system(\"cat \"+node, 1) if ret==0: print((\"Previous fan duty: \" +log.strip() +\"%\")) ret, log=log_os_system(\"echo \"+args[1]+\" >\"+node, 1) if ret==0: print((\"Current fan duty: \" +args[1] +\"%\")) return ret elif args[0]=='sfp': if int(args[1])> DEVICE_NO[args[0]] or int(args[1])==0: show_set_help() return if len(args)<2: show_set_help() return if int(args[2])>1: show_set_help() return for i in range(0,len(ALL_DEVICE[args[0]])): for j in ALL_DEVICE[args[0]][args[0]+str(args[1])]: if j.find('tx_disable')!=-1: ret, log=log_os_system(\"echo \"+args[2]+\" >\"+j, 1) if ret: return ret return def get_value(input): digit=re.findall('\\d+', input) return int(digit[0]) def device_traversal(): if system_ready()==False: print(\"System's not ready.\") print(\"Please install first!\") return if len(ALL_DEVICE)==0: devices_info() for i in sorted(ALL_DEVICE.keys()): print(\"============================================\") print((i.upper()+\": \")) print(\"============================================\") for j in sorted(list(ALL_DEVICE[i].keys()), key=get_value): print(\" \"+j+\":\", end=' ') for k in(ALL_DEVICE[i][j]): ret, log=log_os_system(\"cat \"+k, 0) func=k.split(\"/\")[-1].strip() func=re.sub(j+'_','',func,1) func=re.sub(i.lower()+'_','',func,1) if ret==0: print(func+\"=\"+log+\" \", end=' ') else: print(func+\"=\"+\"X\"+\" \", end=' ') print() print(\"----------------------------------------------------------------\") print() return def device_exist(): ret1, log=log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0) ret2, log=log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2016 Accton Networks, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean\ncommand:\n    install     : install drivers and generate related sysfs nodes\n    clean       : uninstall drivers and remove related sysfs nodes\n    show        : show all systen status\n    sff         : dump SFP eeprom\n    set         : change board setting with fan|led|sfp\n\"\"\"\n\nimport subprocess\nimport getopt\nimport sys\nimport logging\nimport re\nimport time\n\nPROJECT_NAME = 'as7716_32x'\nversion = '0.0.1'\nverbose = False\nDEBUG = False\nargs = []\nALL_DEVICE = {}\nDEVICE_NO = {'led':5, 'fan1':1, 'fan2':1,'fan3':1,'fan4':1,'fan5':1,'thermal':3, 'psu':2, 'sfp':54}\n\n\nled_prefix ='/sys/devices/platform/as7716_32x_led/leds/accton_'+PROJECT_NAME+'_led::'\nfan_prefix ='/sys/devices/platform/as7716_32x_'\nhwmon_types = {'led': ['diag','fan','loc','psu1','psu2'],\n               'fan1': ['fan'],\n               'fan2': ['fan'],\n               'fan3': ['fan'],\n               'fan4': ['fan'],\n               'fan5': ['fan'],\n              }\nhwmon_nodes = {'led': ['brightness'] ,\n               'fan1': ['fan_duty_cycle_percentage', 'fan1_fault', 'fan1_speed_rpm', 'fan1_direction', 'fanr1_fault', 'fanr1_speed_rpm'],\n               'fan2': ['fan_duty_cycle_percentage','fan2_fault', 'fan2_speed_rpm', 'fan2_direction', 'fanr2_fault', 'fanr2_speed_rpm'],\n               'fan3': ['fan_duty_cycle_percentage','fan3_fault', 'fan3_speed_rpm', 'fan3_direction', 'fanr3_fault', 'fanr3_speed_rpm'],\n               'fan4': ['fan4_duty_cycle_percentage','fan4_fault', 'fan4_speed_rpm', 'fan4_direction', 'fanr4_fault', 'fanr4_speed_rpm'],\n               'fan5': ['fan_duty_cycle_percentage','fan5_fault', 'fan5_speed_rpm', 'fan5_direction', 'fanr5_fault', 'fanr5_speed_rpm'],\n\t      }\nhwmon_prefix ={'led': led_prefix,\n               'fan1': fan_prefix,\n               'fan2': fan_prefix,\n               'fan3': fan_prefix,\n               'fan4': fan_prefix,\n               'fan5': fan_prefix,\n              }\n\ni2c_prefix = '/sys/bus/i2c/devices/'\ni2c_bus = {'thermal': ['10-0048','10-0049', '10-004a'] ,\n           'psu': ['17-0050','18-0053'],\n           'sfp': ['-0050']}\ni2c_nodes = {\n           'thermal': ['hwmon/hwmon*/temp1_input'] ,\n           'psu': ['psu_present ', 'psu_power_good']    ,\n           'sfp': ['sfp_is_present ', 'sfp_tx_disable']}\n\nsfp_map = [29, 30, 31, 32, 34, 33, 36, 35,\n          25, 26, 27, 28, 37, 38, 39, 40, \n          41, 42, 43, 44, 53, 54, 55, 56, \n          45, 46, 47, 48, 49, 50, 51, 52]\n\nmknod =[\n'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo as7716_32x_fan 0x66 > /sys/bus/i2c/devices/i2c-9/new_device',\n\n'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-10/new_device',\n'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-10/new_device',\n'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-10/new_device',\n\n'echo as7716_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-11/new_device',\n'echo accton_i2c_cpld 0x62 > /sys/bus/i2c/devices/i2c-12/new_device',\n'echo accton_i2c_cpld 0x64 > /sys/bus/i2c/devices/i2c-13/new_device',\n\n'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-2/new_device',\n\n# PSU-1\n'echo as7716_32x_psu1 0x53 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-18/new_device',\n\n# PSU-2\n'echo as7716_32x_psu2 0x50> /sys/bus/i2c/devices/i2c-17/new_device',\n'echo ym2651 0x58 > /sys/bus/i2c/devices/i2c-17/new_device',\n\n\n\n#EERPOM\n'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-1/new_device',\n]\n\nmknod2 =[\n'echo as7716_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo accton_i2c_cpld 0x61 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo accton_i2c_cpld 0x62 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-0/new_device',\n\n# PSU-1\n'echo as7716_32x_psu1 0x38 > /sys/bus/i2c/devices/i2c-57/new_device',\n'echo cpr_4011_4mxx  0x3c > /sys/bus/i2c/devices/i2c-57/new_device',\n'echo as7716_32x_psu1 0x50 > /sys/bus/i2c/devices/i2c-57/new_device',\n'echo ym2401 0x58 > /sys/bus/i2c/devices/i2c-57/new_device',\n\n# PSU-2\n'echo as7716_32x_psu2 0x3b > /sys/bus/i2c/devices/i2c-58/new_device',\n'echo cpr_4011_4mxx 0x3f > /sys/bus/i2c/devices/i2c-58/new_device',\n'echo as7716_32x_psu2 0x53 > /sys/bus/i2c/devices/i2c-58/new_device',\n'echo ym2401 0x5b > /sys/bus/i2c/devices/i2c-58/new_device',\n\n'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-61/new_device',\n'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-62/new_device',\n'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-63/new_device',\n\n#EERPOM\n'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-1/new_device',\n]\n\nFORCE = 0\nlogging.basicConfig(filename= PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG)\nlogging.basicConfig(level=logging.INFO)\n\n\nif DEBUG == True:\n    print(sys.argv[0])\n    print('ARGV      :', sys.argv[1:])\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n\n    if len(sys.argv)<2:\n        show_help()\n\n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:\n        print(options)\n        print(args)\n        print(len(sys.argv))\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n           do_install()\n        elif arg == 'clean':\n           do_uninstall()\n        elif arg == 'show':\n           device_traversal()\n        elif arg == 'sff':\n            if len(args)!=2:\n                show_eeprom_help()\n            elif int(args[1]) ==0 or int(args[1]) > DEVICE_NO['sfp']:\n                show_eeprom_help()\n            else:\n                show_eeprom(args[1])\n            return\n        elif arg == 'set':\n            if len(args)<3:\n                show_set_help()\n            else:\n                set_device(args[1:])\n            return\n        else:\n            show_help()\n\n\n    return 0\n\ndef show_help():\n    print(__doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]})\n    sys.exit(0)\n\ndef  show_set_help():\n    cmd =  sys.argv[0].split(\"/\")[-1]+ \" \"  + args[0]\n    print(cmd +\" [led|sfp|fan]\")\n    print(\"    use \\\"\"+ cmd + \" led 0-4 \\\"  to set led color\")\n    print(\"    use \\\"\"+ cmd + \" fan 0-100\\\" to set fan duty percetage\")\n    print(\"    use \\\"\"+ cmd + \" sfp 1-32 {0|1}\\\" to set sfp# tx_disable\")\n    sys.exit(0)\n\ndef dis_i2c_ir3570a(addr):\n    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef ir3570_check():\n    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n    try:\n        status, output = subprocess.getstatusoutput(cmd)\n        lines = output.split('\\n')\n        hn = re.findall(r'\\w+', lines[-1])\n        version = int(hn[1], 16)\n        if version == 0x24:  #only for ir3570a\n            ret = dis_i2c_ir3570a(4)\n        else:\n            ret = 0\n    except Exception as e:\n        print(\"Error on ir3570_check() e:\" + str(e))\n        return -1\n    return ret\n\ndef  show_eeprom_help():\n    cmd =  sys.argv[0].split(\"/\")[-1]+ \" \"  + args[0]\n    print(\"    use \\\"\"+ cmd + \" 1-32 \\\" to dump sfp# eeprom\")\n    sys.exit(0)\n\ndef my_log(txt):\n    if DEBUG == True:\n        print(\"[ACCTON DBG]: \"+txt)\n    return\n\ndef log_os_system(cmd, show):\n    logging.info('Run :'+cmd)\n    status = 1\n    output = \"\"\n    status, output = subprocess.getstatusoutput(cmd)\n    my_log (cmd +\"with result:\" + str(status))\n    my_log (\"cmd:\" + cmd)\n    my_log (\"      output:\"+output)\n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print(('Failed :'+cmd))\n    return  status, output\n\ndef driver_inserted():\n    ret, lsmod = log_os_system(\"ls /sys/module/*accton*\", 0)\n    logging.info('mods:'+lsmod)\n    if ret :\n        return False\n    else :\n        return True\n\n#'modprobe cpr_4011_4mxx',\n\nkos = [\n'depmod -ae',\n'modprobe i2c_dev',\n'modprobe i2c_mux_pca954x force_deselect_on_exit=1',\n'modprobe accton_i2c_cpld',\n'modprobe cpr_4011_4mxx',\n'modprobe ym2651y',\n'modprobe accton_as7716_32x_cpld1',\n'modprobe accton_as7716_32x_fan',\n'modprobe accton_as7716_32x_leds',\n'modprobe accton_as7716_32x_psu']\n\ndef driver_install():\n    global FORCE\n    for i in range(0,len(kos)):\n        status, output = log_os_system(kos[i], 1)\n        if status:\n            if FORCE == 0:\n                return status\n    return 0\n\ndef driver_uninstall():\n    global FORCE\n    for i in range(0,len(kos)):\n        #remove parameter if any\n        rm = kos[-(i+1)]\n        lst = rm.split(\" \")\n        if len(lst) > 2:\n            del(lst[2:])\n        rm = \" \".join(lst)\n\n        #Change to removing commands\n        rm = rm.replace(\"modprobe\", \"modprobe -rq\")\n        rm = rm.replace(\"insmod\", \"rmmod\")\n        status, output = log_os_system(rm, 1)\n        if status:\n            if FORCE == 0:\n                return status\n    return 0\n\n\n\ndef i2c_order_check():\n    # i2c bus 0 and 1 might be installed in different order.\n    # Here check if 0x76 is exist @ i2c-0\n    tmp = \"echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-1/new_device\"\n    status, output = log_os_system(tmp, 0)\n    if not device_exist():\n        order = 1\n    else:\n        order = 0\n    tmp = \"echo 0x70 > /sys/bus/i2c/devices/i2c-1/delete_device\"\n    status, output = log_os_system(tmp, 0)\n    return order\n\ndef device_install():\n    global FORCE\n\n    for i in range(0,len(mknod)):\n        #for pca932x need times to built new i2c buses\n        if mknod[i].find('pca954') != -1:\n            time.sleep(2)\n        \n        status, output = log_os_system(mknod[i], 1)        \n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n    \n    for i in range(0,len(sfp_map)):\n        status, output =log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n        status, output =log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n    return\n\ndef device_uninstall():\n    global FORCE\n\n    status, output =log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0)\n    if status==0:\n        I2C_ORDER=1\n    else:\n    \tI2C_ORDER=0\n\n    for i in range(0,len(sfp_map)):\n        target = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\"\n        status, output =log_os_system(\"echo 0x50 > \"+ target, 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    if I2C_ORDER==0:\n        nodelist = mknod\n    else:\n        nodelist = mknod2\n\n    for i in range(len(nodelist)):\n        target = nodelist[-(i+1)]\n        temp = target.split()\n        del temp[1]\n        temp[-1] = temp[-1].replace('new_device', 'delete_device')\n        status, output = log_os_system(\" \".join(temp), 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    return\n\ndef system_ready():\n    if driver_inserted() == False:        \n        return False\n    if not device_exist():\n        print(\"not device_exist()\")\n        return False\n    return True\n\ndef do_install():\n    if driver_inserted() == False:\n        status = driver_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print(PROJECT_NAME.upper()+\" drivers detected....\")\n\n    ir3570_check()\n\n    if not device_exist():\n        status = device_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print(PROJECT_NAME.upper()+\" devices detected....\")\n    return\n\ndef do_uninstall():\n    if not device_exist():\n        print(PROJECT_NAME.upper() +\" has no device installed....\")\n    else:\n        print(\"Removing device....\")\n        status = device_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    if driver_inserted()== False :\n        print(PROJECT_NAME.upper() +\" has no driver installed....\")\n    else:\n        print(\"Removing installed driver....\")\n        status = driver_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    return\n\ndef devices_info():\n    global DEVICE_NO\n    global ALL_DEVICE\n    global i2c_bus, hwmon_types\n    for key in DEVICE_NO:\n        ALL_DEVICE[key]= {}\n        for i in range(0,DEVICE_NO[key]):\n            ALL_DEVICE[key][key+str(i+1)] = []\n\n    for key in i2c_bus:\n        buses = i2c_bus[key]\n        nodes = i2c_nodes[key]\n        for i in range(0,len(buses)):\n            for j in range(0,len(nodes)):\n                if  'fan' == key:\n                    for k in range(0,DEVICE_NO[key]):\n                        node = key+str(k+1)\n                        path = i2c_prefix+ buses[i]+\"/fan\"+str(k+1)+\"_\"+ nodes[j]\n                        my_log(node+\": \"+ path)\n                        ALL_DEVICE[key][node].append(path)\n                elif  'sfp' == key:\n                    for k in range(0,DEVICE_NO[key]):\n                        node = key+str(k+1)\n                        path = i2c_prefix+ str(sfp_map[k])+ buses[i]+\"/\"+ nodes[j]\n                        my_log(node+\": \"+ path)\n                        ALL_DEVICE[key][node].append(path)\n                else:\n                    node = key+str(i+1)\n                    path = i2c_prefix+ buses[i]+\"/\"+ nodes[j]\n                    my_log(node+\": \"+ path)\n                    ALL_DEVICE[key][node].append(path)\n\n    for key in hwmon_types:\n        itypes = hwmon_types[key]\n        nodes = hwmon_nodes[key]\n        for i in range(0,len(itypes)):\n            for j in range(0,len(nodes)):\n                node = key+\"_\"+itypes[i]\n                path = hwmon_prefix[key]+ itypes[i]+\"/\"+ nodes[j]\n                my_log(node+\": \"+ path)\n                ALL_DEVICE[key][ key+str(i+1)].append(path)\n\n    #show dict all in the order\n    if DEBUG == True:\n        for i in sorted(ALL_DEVICE.keys()):\n            print((i+\": \"))\n            for j in sorted(ALL_DEVICE[i].keys()):\n                print((\"   \"+j))\n                for k in (ALL_DEVICE[i][j]):\n                    print((\"   \"+\"   \"+k))\n    return\n\ndef show_eeprom(index):\n    if system_ready()==False:\n        print(\"System's not ready.\")\n        print(\"Please install first!\")\n        return\n\n    if len(ALL_DEVICE)==0:\n        devices_info()\n    node = ALL_DEVICE['sfp'] ['sfp'+str(index)][0]\n    node = node.replace(node.split(\"/\")[-1], 'sfp_eeprom')\n    # check if got hexdump command in current environment\n    ret, log = log_os_system(\"which hexdump\", 0)\n    ret, log2 = log_os_system(\"which busybox hexdump\", 0)\n    if len(log):\n        hex_cmd = 'hexdump'\n    elif len(log2):\n        hex_cmd = ' busybox hexdump'\n    else:\n        log = 'Failed : no hexdump cmd!!'\n        logging.info(log)\n        print(log)\n        return 1\n\n    print(node + \":\")\n    ret, log = log_os_system(\"cat \"+node+\"| \"+hex_cmd+\" -C\", 1)\n    if ret==0:\n        print(log)\n    else:\n        print(\"**********device no found**********\")\n    return\n\ndef set_device(args):\n    global DEVICE_NO\n    global ALL_DEVICE\n    if system_ready()==False:\n        print(\"System's not ready.\")\n        print(\"Please install first!\")\n        return\n\n    if len(ALL_DEVICE)==0:\n        devices_info()\n\n    if args[0]=='led':\n        if int(args[1])>4:\n            show_set_help()\n            return\n        #print  ALL_DEVICE['led']\n        for i in range(0,len(ALL_DEVICE['led'])):\n            for k in (ALL_DEVICE['led']['led'+str(i+1)]):\n                ret, log = log_os_system(\"echo \"+args[1]+\" >\"+k, 1)\n                if ret:\n                    return ret\n    elif args[0]=='fan':\n        if int(args[1])>100:\n            show_set_help()\n            return\n        #print  ALL_DEVICE['fan']\n        #fan1~6 is all fine, all fan share same setting\n        node = ALL_DEVICE['fan1'] ['fan11'][0]\n        node = node.replace(node.split(\"/\")[-1], 'fan1_duty_cycle_percentage')\n        ret, log = log_os_system(\"cat \"+ node, 1)\n        if ret==0:\n            print((\"Previous fan duty: \" + log.strip() +\"%\"))\n        ret, log = log_os_system(\"echo \"+args[1]+\" >\"+node, 1)\n        if ret==0:\n            print((\"Current fan duty: \" + args[1] +\"%\"))\n        return ret\n    elif args[0]=='sfp':\n        if int(args[1])> DEVICE_NO[args[0]] or int(args[1])==0:\n            show_set_help()\n            return\n        if len(args)<2:\n            show_set_help()\n            return\n\n        if int(args[2])>1:\n            show_set_help()\n            return\n\n        #print  ALL_DEVICE[args[0]]\n        for i in range(0,len(ALL_DEVICE[args[0]])):\n            for j in ALL_DEVICE[args[0]][args[0]+str(args[1])]:\n                if j.find('tx_disable')!= -1:\n                    ret, log = log_os_system(\"echo \"+args[2]+\" >\"+ j, 1)\n                    if ret:\n                        return ret\n\n    return\n\n#get digits inside a string.\n#Ex: 31 for \"sfp31\"\ndef get_value(input):\n    digit = re.findall('\\d+', input)\n    return int(digit[0])\n\ndef device_traversal():\n    if system_ready()==False:\n        print(\"System's not ready.\")\n        print(\"Please install first!\")\n        return\n\n    if len(ALL_DEVICE)==0:\n        devices_info()\n    for i in sorted(ALL_DEVICE.keys()):\n        print(\"============================================\")\n        print((i.upper()+\": \"))\n        print(\"============================================\")\n\n        for j in sorted(list(ALL_DEVICE[i].keys()), key=get_value):\n            print(\"   \"+j+\":\", end=' ')\n            for k in (ALL_DEVICE[i][j]):\n                ret, log = log_os_system(\"cat \"+k, 0)\n                func = k.split(\"/\")[-1].strip()\n                func = re.sub(j+'_','',func,1)\n                func = re.sub(i.lower()+'_','',func,1)\n                if ret==0:\n                    print(func+\"=\"+log+\" \", end=' ')\n                else:\n                    print(func+\"=\"+\"X\"+\" \", end=' ')\n            print()\n            print(\"----------------------------------------------------------------\")\n\n\n        print()\n    return\n\ndef device_exist():\n    ret1, log = log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0)\n    ret2, log = log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py": {"changes": [{"diff": "\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py", "badparts": ["               os.system('reboot')           "], "goodparts": ["               subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high is", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}], "source": "\n try: import os import getopt import sys import logging import logging.config import logging.handlers import time from as7726_32x.fanutil import FanUtil from as7726_32x.thermalutil import ThermalUtil except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as7726_32x_monitor' global log_file global log_level class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False fan_policy_state=1 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0, 0, 0, 0, 0] temp_test_data=0 class device_monitor(object): temp=0 new_pwm=0 pwm=0 ori_pwm=0 default_pwm=0x4 def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 logging.debug('temp=%d', temp) for i in range(0, len(policy)): if temp > policy[i][2]: if temp <=policy[i][3]: state=i logging.debug('temp=%d >=policy[%d][2]=%d, temp=%d < policy[%d][3]=%d', temp, i, policy[i][2], temp, i, policy[i][3]) logging.debug('fan_state=%d', state) break return state def manage_fans(self): global fan_policy_state global fan_fail global test_temp global test_temp_list global alarm_state global temp_test_data LEVEL_FAN_DEF=0 LEVEL_FAN_MID=1 LEVEL_FAN_MAX=2 LEVEL_TEMP_HIGH=3 LEVEL_TEMP_CRITICAL=4 fan_policy_f2b={ LEVEL_FAN_DEF: [38, 0x4, 0, 38000], LEVEL_FAN_MID: [63, 0x6, 38000, 46000], LEVEL_FAN_MAX: [100, 0xE, 46000, 58000], LEVEL_TEMP_HIGH: [100, 0xE, 58000, 66000], LEVEL_TEMP_CRITICAL:[100, 0xE, 58000, 200000], } fan_policy_b2f={ LEVEL_FAN_DEF: [38, 0x4, 0, 34000], LEVEL_FAN_MID: [63, 0x8, 34000, 44000], LEVEL_FAN_MAX: [100, 0xE, 44000, 59000], LEVEL_TEMP_HIGH: [100, 0xE, 59000, 67000], LEVEL_TEMP_CRITICAL:[100, 0xE, 59000, 200000], } fan_policy=fan_policy_f2b thermal=ThermalUtil() fan=FanUtil() fan_dir=fan.get_fan_dir(1) if fan_dir==1: fan_dri=1 else: fan_policy=fan_policy_b2f ori_pwm=fan.get_fan_duty_cycle() new_pwm=0 logging.debug('fan_dir=%d, ori_pwm=%d', fan_dir, ori_pwm) logging.debug('test_temp=%d', test_temp) if test_temp==0: temp1=thermal._get_thermal_val(1) temp2=thermal._get_thermal_val(2) temp3=thermal._get_thermal_val(3) temp4=thermal._get_thermal_val(4) temp5=thermal._get_thermal_val(5) else: temp1=test_temp_list[0] temp2=test_temp_list[1] temp3=test_temp_list[2] temp4=test_temp_list[3] temp5=test_temp_list[4] fan_fail=0 if temp3==0: temp_get=50000 logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%') elif temp4==0: temp_get=50000 logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%') else: temp_get=(temp3 +temp4)/2 ori_state=fan_policy_state if test_temp!=0: temp_test_data=temp_test_data+1000 temp_get=temp_get +temp_test_data logging.debug('Unit test:temp_get=%d', temp_get) fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy) logging.debug('lm75_48=%d, lm75_49=%d, lm75_4a=%d, lm_4b=%d, lm_4c=%d', temp1,temp2,temp3,temp4,temp5) logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state) new_pwm=fan_policy[fan_policy_state][0] if fan_fail==0: logging.debug('new_fan_cycle=%d', new_pwm) if fan_fail==0: if new_pwm!=ori_pwm: fan.set_fan_duty_cycle(new_pwm) logging.info('Set fan speed from %d to %d', ori_pwm, new_pwm) for i in range(fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1): if fan.get_fan_status(i)==0: new_pwm=100 logging.debug('fan_%d fail, set pwm to 100',i) if test_temp==0: fan_fail=1 fan.set_fan_duty_cycle(new_pwm) break else: fan_fail=0 new_state=fan_policy_state if ori_state==LEVEL_FAN_DEF: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected, reboot DUT') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MID: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MAX: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if alarm_state==1: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_HIGH: if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if new_state <=LEVEL_FAN_MID: logging.warning('Alarm for temperature high is cleared') alarm_state=0 if new_state <=LEVEL_FAN_MAX: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_CRITICAL: if new_state <=LEVEL_FAN_MAX: logging.warning('Alarm for temperature critical is cleared') return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv,'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv)!=7: print(\"temp test, need input six temp\") return 0 i=0 for x in range(2, 7): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) fan=FanUtil() fan.set_fan_duty_cycle(38) print(\"set default fan speed to 37.5%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(5) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2017 Accton Technology Corporation\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    mm/dd/yyyy (A.D.)#   \n#    4/20/2018: Jostar modify for as7726_32x\n#    12/03/2018:Jostar modify for as7726_32x thermal plan\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import getopt\n    import sys\n    import logging\n    import logging.config\n    import logging.handlers\n    import time  # this is only being used as part of the example\n    from as7726_32x.fanutil import FanUtil\n    from as7726_32x.thermalutil import ThermalUtil\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as7726_32x_monitor'\n\nglobal log_file\nglobal log_level\n\n \n#  Air Flow Front to Back :\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 <=38C : Keep 37.5%(0x04) Fan speed\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 38C : Change Fan speed from 37.5%(0x04) to 62.5%(0x08)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 46C : Change Fan speed from 62.5%(0x08) to 100%(0x0E)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 58C : Send alarm message\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 66C : Shut down system\n#  One Fan fail : Change Fan speed to 100%(0x0E)\n\n\n#  Air Flow Back to Front :\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 <=34C : Keep 37.5%(0x04) Fan speed\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 34C : Change Fan speed from 37.5%(0x04) to 62.5%(0x08)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 44C : Change Fan speed from 62.5%(0x08) to 100%(0x0E)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 59C : Send alarm message\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 67C : Shut down system\n#  One Fan fail:  Change Fan speed to 100%(0x0E)\n#  sensor_LM75_CPU == sensor_LM75_4B\n \n     \nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n \n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n     \n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args: # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\n\nfan_policy_state=1\nfan_fail=0\nalarm_state = 0 #0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0, 0, 0, 0, 0]\ntemp_test_data=0\n# Make a class we can use to capture stdout and sterr in the log\nclass device_monitor(object):\n    # static temp var\n    temp = 0\n    new_pwm = 0\n    pwm=0\n    ori_pwm = 0\n    default_pwm=0x4\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format= '[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = handler = logging.handlers.SysLogHandler(address = '/dev/log')\n        sys_handler.setLevel(logging.WARNING)       \n        logging.getLogger('').addHandler(sys_handler)\n          \n    def get_state_from_fan_policy(self, temp, policy):\n        state=0\n        \n        logging.debug('temp=%d', temp)\n        for i in range(0, len(policy)):\n            if temp > policy[i][2]:\n                if temp <= policy[i][3]:\n                    state =i\n                    logging.debug ('temp=%d >= policy[%d][2]=%d,  temp=%d < policy[%d][3]=%d' , temp, i, policy[i][2], temp, i, policy[i][3])\n                    logging.debug ('fan_state=%d', state)\n                    break\n        \n        return state\n\n    def manage_fans(self):\n       \n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list        \n        global alarm_state\n        global temp_test_data\n        \n        LEVEL_FAN_DEF=0\n        LEVEL_FAN_MID=1       \n        LEVEL_FAN_MAX=2\n        LEVEL_TEMP_HIGH=3\n        LEVEL_TEMP_CRITICAL=4\n        \n        fan_policy_f2b = {\n           LEVEL_FAN_DEF:       [38,  0x4, 0,     38000],\n           LEVEL_FAN_MID:       [63,  0x6, 38000, 46000],\n           LEVEL_FAN_MAX:       [100, 0xE, 46000, 58000],\n           LEVEL_TEMP_HIGH:     [100, 0xE, 58000, 66000],\n           LEVEL_TEMP_CRITICAL: [100, 0xE, 58000, 200000],\n        }\n        fan_policy_b2f = {\n           LEVEL_FAN_DEF:       [38,  0x4, 0,     34000],\n           LEVEL_FAN_MID:       [63,  0x8, 34000, 44000],\n           LEVEL_FAN_MAX:       [100, 0xE, 44000, 59000],\n           LEVEL_TEMP_HIGH:     [100, 0xE, 59000, 67000],\n           LEVEL_TEMP_CRITICAL: [100, 0xE, 59000, 200000],\n        }\n        \n        fan_policy = fan_policy_f2b\n        \n        thermal = ThermalUtil()\n        fan = FanUtil()\n        fan_dir=fan.get_fan_dir(1)            \n        if fan_dir == 1:\n            fan_dri=1 #something wrong, set fan_dir to default val\n        else:\n            fan_policy = fan_policy_b2f\n        \n        ori_pwm=fan.get_fan_duty_cycle()\n        new_pwm=0  \n        logging.debug('fan_dir=%d, ori_pwm=%d', fan_dir, ori_pwm)\n        logging.debug('test_temp=%d', test_temp)\n        if test_temp==0: \n            temp1 = thermal._get_thermal_val(1)\n            temp2 = thermal._get_thermal_val(2)\n            temp3 = thermal._get_thermal_val(3)\n            temp4 = thermal._get_thermal_val(4)\n            temp5 = thermal._get_thermal_val(5)            \n        else:\n            temp1 = test_temp_list[0]\n            temp2 = test_temp_list[1]\n            temp3 = test_temp_list[2]\n            temp4 = test_temp_list[3]\n            temp5 = test_temp_list[4]            \n            fan_fail=0\n       \n        if temp3==0:\n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_49 detect fail, so set temp_get=50000, let fan to 75%')\n        elif temp4==0:        \n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%')\n        else:    \n            temp_get= (temp3 + temp4)/2  # Use (sensor_LM75_4a + sensor_LM75_4b) /2 \n        ori_state=fan_policy_state\n        \n        if test_temp!=0:\n            temp_test_data=temp_test_data+1000\n            temp_get = temp_get + temp_test_data\n            logging.debug('Unit test:temp_get=%d', temp_get)\n        \n        fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy)\n                                \n        logging.debug('lm75_48=%d, lm75_49=%d, lm75_4a=%d, lm_4b=%d, lm_4c=%d', temp1,temp2,temp3,temp4,temp5)\n        logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state)\n        new_pwm = fan_policy[fan_policy_state][0]\n        if fan_fail==0:\n            logging.debug('new_fan_cycle=%d', new_pwm)\n        \n        if fan_fail==0:\n            if new_pwm!=ori_pwm:\n                fan.set_fan_duty_cycle(new_pwm)\n                logging.info('Set fan speed from %d to %d', ori_pwm, new_pwm)\n        \n        #Check Fan status\n        for i in range (fan.FAN_NUM_1_IDX, fan.FAN_NUM_ON_MAIN_BROAD+1):\n            if fan.get_fan_status(i)==0:\n                new_pwm=100\n                logging.debug('fan_%d fail, set pwm to 100',i)                \n                if test_temp==0:\n                    fan_fail=1\n                    fan.set_fan_duty_cycle(new_pwm)\n                    break\n            else:\n                fan_fail=0\n        \n        new_state = fan_policy_state\n          \n        if ori_state==LEVEL_FAN_DEF:            \n           if new_state==LEVEL_TEMP_HIGH:\n               if alarm_state==0:\n                   logging.warning('Alarm for temperature high is detected')\n               alarm_state=1\n           if new_state==LEVEL_TEMP_CRITICAL:\n               logging.critical('Alarm for temperature critical is detected, reboot DUT')\n               time.sleep(2)\n               os.system('reboot')           \n        if ori_state==LEVEL_FAN_MID:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state=1 \n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n        if ori_state==LEVEL_FAN_MAX:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected') \n                alarm_state=1\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n            if alarm_state==1:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_HIGH:\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n            if new_state <= LEVEL_FAN_MID:\n                logging.warning('Alarm for temperature high is cleared')\n                alarm_state=0\n            if new_state <= LEVEL_FAN_MAX:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_CRITICAL:            \n            if new_state <= LEVEL_FAN_MAX:\n                logging.warning('Alarm for temperature critical is cleared')\n      \n        return True\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv,'hdlt:',['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg            \n        \n        if sys.argv[1]== '-t':\n            if len(sys.argv)!=7:\n                print(\"temp test, need input six temp\")\n                return 0\n            \n            i=0\n            for x in range(2, 7):\n               test_temp_list[i]= int(sys.argv[x])*1000\n               i=i+1\n            test_temp = 1   \n            log_level = logging.DEBUG\n            print(test_temp_list)                       \n    \n    fan = FanUtil()\n    fan.set_fan_duty_cycle(38)\n    print(\"set default fan speed to 37.5%\")\n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(5)\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    \n"}, "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py": {"changes": [{"diff": "\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected, reboot DUT')\n                time.sleep(2)\n-               os.system('reboot')           \n+               subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MID:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py", "badparts": ["               os.system('reboot')           "], "goodparts": ["               subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n         if ori_state==LEVEL_FAN_MAX:\n             if new_state==LEVEL_TEMP_HIGH:\n                 if alarm_state==0:\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot') \n+                subprocess.call(['reboot'])\n             if alarm_state==1:\n                 if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                     logging.warning('Alarm for temperature high is cleared')\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py", "badparts": ["                os.system('reboot') "], "goodparts": ["                subprocess.call(['reboot'])"]}, {"diff": "\n             if new_state==LEVEL_TEMP_CRITICAL:\n                 logging.critical('Alarm for temperature critical is detected')\n                 time.sleep(2)\n-                os.system('reboot')\n+                subprocess.call(['reboot'])\n             if new_state <= LEVEL_FAN_MID:\n                 logging.warning('Alarm for temperature high i", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_pddf_monitor.py", "badparts": ["                os.system('reboot')"], "goodparts": ["                subprocess.call(['reboot'])"]}], "source": "\n try: import os import sys import getopt import logging import logging.config import logging.handlers import time from sonic_platform import platform except ImportError as e: raise ImportError('%s -required module not found' % str(e)) VERSION='1.0' FUNCTION_NAME='/usr/local/bin/accton_as7726_32x_pddf_monitor' platform_chassis=None class switch(object): def __init__(self, value): self.value=value self.fall=False def __iter__(self): \"\"\"Return the match method once, then stop\"\"\" yield self.match raise StopIteration def match(self, *args): \"\"\"Indicate whether or not to enter a case suite\"\"\" if self.fall or not args: return True elif self.value in args: self.fall=True return True else: return False fan_policy_state=1 fan_fail=0 alarm_state=0 test_temp=0 test_temp_list=[0, 0, 0, 0, 0, 0] temp_test_data=0 class device_monitor(object): def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) sys_handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setLevel(logging.WARNING) logging.getLogger('').addHandler(sys_handler) def get_state_from_fan_policy(self, temp, policy): state=0 logging.debug('temp=%d', temp) for i in range(0, len(policy)): if temp > policy[i][2]: if temp <=policy[i][3]: state=i logging.debug('temp=%d >=policy[%d][2]=%d, temp=%d < policy[%d][3]=%d', temp, i, policy[i][2], temp, i, policy[i][3]) logging.debug('fan_state=%d', state) break return state def manage_fans(self): global fan_policy_state global fan_fail global test_temp global test_temp_list global alarm_state global temp_test_data global platform_chassis LEVEL_FAN_DEF=0 LEVEL_FAN_MID=1 LEVEL_FAN_MAX=2 LEVEL_TEMP_HIGH=3 LEVEL_TEMP_CRITICAL=4 FAN_NUM_MAX=6 FANS_PERTRAY=2 fan_policy_f2b={ LEVEL_FAN_DEF: [38, 0x4, 0, 38000], LEVEL_FAN_MID: [63, 0x6, 38000, 46000], LEVEL_FAN_MAX: [100, 0xE, 46000, 58000], LEVEL_TEMP_HIGH: [100, 0xE, 58000, 66000], LEVEL_TEMP_CRITICAL:[100, 0xE, 58000, 200000], } fan_policy_b2f={ LEVEL_FAN_DEF: [38, 0x4, 0, 34000], LEVEL_FAN_MID: [63, 0x8, 34000, 44000], LEVEL_FAN_MAX: [100, 0xE, 44000, 59000], LEVEL_TEMP_HIGH: [100, 0xE, 59000, 67000], LEVEL_TEMP_CRITICAL:[100, 0xE, 59000, 200000], } fan_dir=platform_chassis.get_fan(0).get_direction() if fan_dir=='EXHAUST': fan_policy=fan_policy_f2b else: fan_policy=fan_policy_b2f ori_perc=platform_chassis.get_fan(0).get_speed() logging.debug('fan_dir=%s, ori_perc=%d, test_temp=%d', fan_dir, ori_perc, test_temp) if test_temp==0: temp4=platform_chassis.get_thermal(3).get_temperature()*1000 temp5=platform_chassis.get_thermal(4).get_temperature()*1000 else: temp4=test_temp_list[3] temp5=test_temp_list[4] fan_fail=0 if temp4==0: temp_get=50000 logging.debug('lm75_4a detect fail, so set temp_get=50000, let fan to 75%') elif temp5==0: temp_get=50000 logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%') else: temp_get=(temp4 +temp5)/2 ori_state=fan_policy_state if test_temp!=0: temp_test_data=temp_test_data+1000 temp_get=temp_get +temp_test_data logging.debug('Unit test:temp_get=%d', temp_get) fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy) logging.debug('lm75_4a=%d, lm_4b=%d', temp4,temp5) logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state) new_perc=fan_policy[fan_policy_state][0] if fan_fail==0: logging.debug('new_fan_cycle=%d', new_perc) if fan_fail==0: if new_perc!=ori_perc: platform_chassis.get_fan(0).set_speed(new_perc) logging.info('Set fan speed from %d to %d', ori_perc, new_perc) for i in range(FAN_NUM_MAX*FANS_PERTRAY): if not platform_chassis.get_fan(i).get_status() or not platform_chassis.get_fan(i).get_speed_rpm(): logging.debug('fan-%d status=%d, rpm=%d', i+1, platform_chassis.get_fan(i).get_status(), platform_chassis.get_fan(i).get_speed_rpm()) new_perc=100 logging.debug('fan_%d fail, set new_perc to 100',i+1) if test_temp==0: fan_fail=1 platform_chassis.get_fan(0).set_speed(new_perc) break else: fan_fail=0 new_state=fan_policy_state if ori_state==LEVEL_FAN_DEF: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected, reboot DUT') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MID: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if ori_state==LEVEL_FAN_MAX: if new_state==LEVEL_TEMP_HIGH: if alarm_state==0: logging.warning('Alarm for temperature high is detected') alarm_state=1 if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if alarm_state==1: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_HIGH: if new_state==LEVEL_TEMP_CRITICAL: logging.critical('Alarm for temperature critical is detected') time.sleep(2) os.system('reboot') if new_state <=LEVEL_FAN_MID: logging.warning('Alarm for temperature high is cleared') alarm_state=0 if new_state <=LEVEL_FAN_MAX: if temp_get <(fan_policy[3][0] -5000): logging.warning('Alarm for temperature high is cleared') alarm_state=0 if ori_state==LEVEL_TEMP_CRITICAL: if new_state <=LEVEL_FAN_MAX: logging.warning('Alarm for temperature critical is cleared') return True def main(argv): log_file='%s.log' % FUNCTION_NAME log_level=logging.INFO global test_temp if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv,'hdlt:',['lfile=']) except getopt.GetoptError: print(('Usage: %s[-d][-l <log_file>]' % sys.argv[0])) return 0 for opt, arg in opts: if opt=='-h': print(('Usage: %s[-d][-l <log_file>]' % sys.argv[0])) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv)!=7: print(\"temp test, need input six temp\") return 0 i=0 for x in range(2, 7): test_temp_list[i]=int(sys.argv[x])*1000 i=i+1 test_temp=1 log_level=logging.DEBUG print(test_temp_list) global platform_chassis platform_chassis=platform.Platform().get_chassis() platform_chassis.get_fan(0).set_speed(38) print(\"set default fan speed to 37.5%\") monitor=device_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(10) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2017 Accton Technology Corporation\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    mm/dd/yyyy (A.D.)#   \n#    4/20/2018: Jostar modify for as7726_32x\n#    12/03/2018:Jostar modify for as7726_32x thermal plan\n#    11/16/2020:Jostar modify for as7726_32x thermal plan based on PDDF\n# ------------------------------------------------------------------\n\ntry:\n    import os\n    import sys\n    import getopt\n    import logging\n    import logging.config\n    import logging.handlers\n    import time\n    from sonic_platform import platform\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nVERSION = '1.0'\nFUNCTION_NAME = '/usr/local/bin/accton_as7726_32x_pddf_monitor'\n\nplatform_chassis = None\n \n#  Air Flow Front to Back :\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 <=38C : Keep 37.5%(0x04) Fan speed\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 38C : Change Fan speed from 37.5%(0x04) to 62.5%(0x08)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 46C : Change Fan speed from 62.5%(0x08) to 100%(0x0E)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 58C : Send alarm message\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 66C : Shut down system\n#  One Fan fail : Change Fan speed to 100%(0x0E)\n\n\n#  Air Flow Back to Front :\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 <=34C : Keep 37.5%(0x04) Fan speed\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 34C : Change Fan speed from 37.5%(0x04) to 62.5%(0x08)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 44C : Change Fan speed from 62.5%(0x08) to 100%(0x0E)\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 59C : Send alarm message\n#  (Thermal sensor_LM75_4A + Thermal sensor_LM75_CPU) /2 > 67C : Shut down system\n#  One Fan fail:  Change Fan speed to 100%(0x0E)\n#  sensor_LM75_CPU == sensor_LM75_4B\n \n     \nclass switch(object):\n    def __init__(self, value):\n        self.value = value\n        self.fall = False\n \n    def __iter__(self):\n        \"\"\"Return the match method once, then stop\"\"\"\n        yield self.match\n        raise StopIteration\n     \n    def match(self, *args):\n        \"\"\"Indicate whether or not to enter a case suite\"\"\"\n        if self.fall or not args:\n            return True\n        elif self.value in args: # changed for v1.5, see below\n            self.fall = True\n            return True\n        else:\n            return False\n\n\nfan_policy_state=1\nfan_fail=0\nalarm_state = 0 #0->default or clear, 1-->alarm detect\ntest_temp = 0\ntest_temp_list = [0, 0, 0, 0, 0, 0]\ntemp_test_data=0\n\n\n# Make a class we can use to capture stdout and sterr in the log\nclass device_monitor(object):\n        \n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format= '[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n\n        sys_handler = logging.handlers.SysLogHandler(address = '/dev/log')\n        sys_handler.setLevel(logging.WARNING)       \n        logging.getLogger('').addHandler(sys_handler)\n          \n    def get_state_from_fan_policy(self, temp, policy):\n        state=0\n        \n        logging.debug('temp=%d', temp)\n        for i in range(0, len(policy)):\n            if temp > policy[i][2]:\n                if temp <= policy[i][3]:\n                    state =i\n                    logging.debug ('temp=%d >= policy[%d][2]=%d,  temp=%d < policy[%d][3]=%d' , temp, i, policy[i][2], temp, i, policy[i][3])\n                    logging.debug ('fan_state=%d', state)\n                    break\n        \n        return state\n\n    def manage_fans(self):\n       \n        global fan_policy_state\n        global fan_fail\n        global test_temp\n        global test_temp_list        \n        global alarm_state\n        global temp_test_data\n        global platform_chassis\n        \n        LEVEL_FAN_DEF=0\n        LEVEL_FAN_MID=1       \n        LEVEL_FAN_MAX=2\n        LEVEL_TEMP_HIGH=3\n        LEVEL_TEMP_CRITICAL=4\n        FAN_NUM_MAX = 6\n        FANS_PERTRAY=2\n        \n        fan_policy_f2b = {\n           LEVEL_FAN_DEF:       [38,  0x4, 0,     38000],\n           LEVEL_FAN_MID:       [63,  0x6, 38000, 46000],\n           LEVEL_FAN_MAX:       [100, 0xE, 46000, 58000],\n           LEVEL_TEMP_HIGH:     [100, 0xE, 58000, 66000],\n           LEVEL_TEMP_CRITICAL: [100, 0xE, 58000, 200000],\n        }\n        fan_policy_b2f = {\n           LEVEL_FAN_DEF:       [38,  0x4, 0,     34000],\n           LEVEL_FAN_MID:       [63,  0x8, 34000, 44000],\n           LEVEL_FAN_MAX:       [100, 0xE, 44000, 59000],\n           LEVEL_TEMP_HIGH:     [100, 0xE, 59000, 67000],\n           LEVEL_TEMP_CRITICAL: [100, 0xE, 59000, 200000],\n        }\n        \n        fan_dir= platform_chassis.get_fan(0).get_direction()\n        if fan_dir == 'EXHAUST':\n            fan_policy = fan_policy_f2b\n        else:\n            fan_policy = fan_policy_b2f\n        \n        ori_perc=platform_chassis.get_fan(0).get_speed()\n        #ori_perc=fan.get_fan_duty_cycle()\n        logging.debug('fan_dir=%s, ori_perc=%d, test_temp=%d', fan_dir, ori_perc, test_temp)\n        if test_temp==0:\n            temp4 = platform_chassis.get_thermal(3).get_temperature()*1000\n            temp5 = platform_chassis.get_thermal(4).get_temperature()*1000\n        else:\n            temp4 = test_temp_list[3]\n            temp5 = test_temp_list[4]            \n            fan_fail=0\n        \n        if temp4==0:\n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_4a detect fail, so set temp_get=50000, let fan to 75%')\n        elif temp5==0:        \n            temp_get=50000  # if one detect sensor is fail or zero, assign temp=50000, let fan to 75% \n            logging.debug('lm75_4b detect fail, so set temp_get=50000, let fan to 75%')\n        else:    \n            temp_get= (temp4 + temp5)/2  # Use (sensor_LM75_4a + sensor_LM75_4b) /2 \n            \n        ori_state=fan_policy_state\n        \n        if test_temp!=0:\n            temp_test_data=temp_test_data+1000\n            temp_get = temp_get + temp_test_data\n            logging.debug('Unit test:temp_get=%d', temp_get)\n        \n        fan_policy_state=self.get_state_from_fan_policy(temp_get, fan_policy)\n                        \n        logging.debug('lm75_4a=%d, lm_4b=%d', temp4,temp5)\n        logging.debug('ori_state=%d, fan_policy_state=%d', ori_state, fan_policy_state)\n        new_perc = fan_policy[fan_policy_state][0]\n        if fan_fail==0:\n            logging.debug('new_fan_cycle=%d', new_perc)\n        \n        if fan_fail==0:\n            if new_perc!=ori_perc:\n                platform_chassis.get_fan(0).set_speed(new_perc)\n                logging.info('Set fan speed from %d to %d', ori_perc, new_perc)\n        \n        #Check Fan status\n        for i in range(FAN_NUM_MAX*FANS_PERTRAY):\n            if not platform_chassis.get_fan(i).get_status() or not platform_chassis.get_fan(i).get_speed_rpm():\n                logging.debug('fan-%d status=%d, rpm=%d', i+1, platform_chassis.get_fan(i).get_status(), platform_chassis.get_fan(i).get_speed_rpm())\n                new_perc=100\n                logging.debug('fan_%d fail, set new_perc to 100',i+1)                \n                if test_temp==0:\n                    fan_fail=1\n                    platform_chassis.get_fan(0).set_speed(new_perc)\n                    break\n            else:\n                fan_fail=0\n      \n        new_state = fan_policy_state\n        \n        if ori_state==LEVEL_FAN_DEF:            \n           if new_state==LEVEL_TEMP_HIGH:\n               if alarm_state==0:\n                   logging.warning('Alarm for temperature high is detected')\n               alarm_state=1\n           if new_state==LEVEL_TEMP_CRITICAL:\n               logging.critical('Alarm for temperature critical is detected, reboot DUT')\n               time.sleep(2)\n               os.system('reboot')           \n        if ori_state==LEVEL_FAN_MID:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected')\n                alarm_state=1 \n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n        if ori_state==LEVEL_FAN_MAX:\n            if new_state==LEVEL_TEMP_HIGH:\n                if alarm_state==0:\n                    logging.warning('Alarm for temperature high is detected') \n                alarm_state=1\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot') \n            if alarm_state==1:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_HIGH:\n            if new_state==LEVEL_TEMP_CRITICAL:\n                logging.critical('Alarm for temperature critical is detected')\n                time.sleep(2)\n                os.system('reboot')\n            if new_state <= LEVEL_FAN_MID:\n                logging.warning('Alarm for temperature high is cleared')\n                alarm_state=0\n            if new_state <= LEVEL_FAN_MAX:\n                if temp_get < (fan_policy[3][0] - 5000):  #below 65 C, clear alarm\n                    logging.warning('Alarm for temperature high is cleared')\n                    alarm_state=0\n        if ori_state==LEVEL_TEMP_CRITICAL:            \n            if new_state <= LEVEL_FAN_MAX:\n                logging.warning('Alarm for temperature critical is cleared')\n      \n        return True\n\ndef main(argv):\n    log_file = '%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    global test_temp\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv,'hdlt:',['lfile='])\n        except getopt.GetoptError:\n            print(('Usage: %s [-d] [-l <log_file>]' % sys.argv[0]))\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print(('Usage: %s [-d] [-l <log_file>]' % sys.argv[0]))\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg            \n        \n        if sys.argv[1]== '-t':\n            if len(sys.argv)!=7:\n                print(\"temp test, need input six temp\")\n                return 0\n            \n            i=0\n            for x in range(2, 7):\n               test_temp_list[i]= int(sys.argv[x])*1000\n               i=i+1\n            test_temp = 1   \n            log_level = logging.DEBUG\n            print(test_temp_list)\n    \n    global platform_chassis\n    platform_chassis = platform.Platform().get_chassis()\n    \n    platform_chassis.get_fan(0).set_speed(38)\n  \n    print(\"set default fan speed to 37.5%\")\n    monitor = device_monitor(log_file, log_level)\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(10)\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    \n"}, "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py": {"changes": [{"diff": "\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+', l", "add": 6, "remove": 6, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/accton_as7726_32x_util.py", "badparts": ["    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cdump -y 0 0x42 s 0x9a\"", "        status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]", "        status, output = getstatusoutput_noshell(cmd)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes \"\"\" import subprocess import getopt import sys import logging import re import time PROJECT_NAME='as7726_32x' version='0.0.1' verbose=False DEBUG=False args=[] ALL_DEVICE={} i2c_prefix='/sys/bus/i2c/devices/' ''' i2c_bus={'fan':['54-0066'], 'thermal':['54-004c', '55-0048','55-0049', '55-004a', '55-004b'], 'psu':['49-0050','50-0053'], 'sfp':['-0050']} i2c_nodes={'fan':['present', 'front_speed_rpm', 'rear_speed_rpm'], 'thermal':['hwmon/hwmon*/temp1_input'], 'psu':['psu_present ', 'psu_power_good'] , 'sfp':['module_present_ ', 'module_tx_disable_']} ''' sfp_map=[21, 22, 23, 24, 26, 25, 28, 27, 17, 18, 19, 20, 29, 30, 31, 32, 33, 34, 35, 36, 45, 46, 47, 48, 37, 38, 39, 40, 41, 42, 43, 44, 15, 16] mknod=[ 'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo as7726_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-11/new_device', 'echo as7726_32x_cpld2 0x62 > /sys/bus/i2c/devices/i2c-12/new_device', 'echo as7726_32x_cpld3 0x64 > /sys/bus/i2c/devices/i2c-13/new_device', 'echo as7726_32x_fan 0x66 > /sys/bus/i2c/devices/i2c-54/new_device', 'echo lm75 0x4c > /sys/bus/i2c/devices/i2c-54/new_device', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-55/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-55/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-55/new_device', 'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-55/new_device', 'echo as7726_32x_psu1 0x53 > /sys/bus/i2c/devices/i2c-50/new_device', 'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-50/new_device', 'echo as7726_32x_psu2 0x50> /sys/bus/i2c/devices/i2c-49/new_device', 'echo ym2651 0x58 > /sys/bus/i2c/devices/i2c-49/new_device', 'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-0/new_device', ] FORCE=0 logging.basicConfig(filename=PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG) logging.basicConfig(level=logging.INFO) if DEBUG==True: print((sys.argv[0])) print(('ARGV :', sys.argv[1:])) def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print(options) print(args) print((len(sys.argv))) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': do_install() elif arg=='clean': do_uninstall() else: show_help() return 0 def show_help(): print(( __doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]})) sys.exit(0) def dis_i2c_ir3570a(addr): cmd=\"i2cset -y 0 0x%x 0xE5 0x01\" % addr status, output=subprocess.getstatusoutput(cmd) cmd=\"i2cset -y 0 0x%x 0x12 0x02\" % addr status, output=subprocess.getstatusoutput(cmd) return status def ir3570_check(): cmd=\"i2cdump -y 0 0x42 s 0x9a\" try: status, output=subprocess.getstatusoutput(cmd) lines=output.split('\\n') hn=re.findall(r'\\w+', lines[-1]) version=int(hn[1], 16) if version==0x24: ret=dis_i2c_ir3570a(4) else: ret=0 except Exception as e: print(( \"Error on ir3570_check() e:\" +str(e))) return -1 return ret def my_log(txt): if DEBUG==True: print((\"[ACCTON DBG]: \",txt)) return def log_os_system(cmd, show): logging.info('Run:'+cmd) status=1 output=\"\" status, output=subprocess.getstatusoutput(cmd) my_log(cmd +\" with result:\" +str(status)) if status: logging.info('Failed:'+cmd) if show: print(('Failed:'+cmd)) return status, output def driver_inserted(): ret, lsmod=log_os_system(\"ls /sys/module/*accton*\", 0) logging.info('mods:'+lsmod) if ret: return False else: return True def cpld_reset_mac(): ret, lsmod=log_os_system(\"i2cset -y 0 0x77 0x1\", 0) ret, lsmod=log_os_system(\"i2cset -y 0 0x76 0x4\", 0) ret, lsmod=log_os_system(\"i2cset -y 0 0x60 0x8 0x77\", 0) time.sleep(1) ret, lsmod=log_os_system(\"i2cset -y 0 0x60 0x8 0xf7\", 0) return True kos=[ 'depmod -ae', 'modprobe i2c_dev', 'modprobe i2c_mux_pca954x force_deselect_on_exit=1', 'modprobe ym2651y', 'modprobe accton_as7726_32x_cpld', 'modprobe accton_as7726_32x_fan', 'modprobe accton_as7726_32x_leds', 'modprobe accton_as7726_32x_psu', 'modprobe optoe'] def driver_install(): global FORCE for i in range(0,len(kos)): status, output=log_os_system(kos[i], 1) if status: if FORCE==0: return status print(\"Done driver_install\") return 0 def driver_uninstall(): global FORCE for i in range(0,len(kos)): rm=kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\") lst=rm.split(\" \") if len(lst) > 3: del(lst[3]) rm=\" \".join(lst) status, output=log_os_system(rm, 1) if status: if FORCE==0: return status return 0 def device_install(): global FORCE for i in range(0,len(mknod)): if mknod[i].find('pca954') !=-1: time.sleep(2) status, output=log_os_system(mknod[i], 1) if status: print(output) if FORCE==0: return status for i in range(0,len(sfp_map)): status, output=log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1) if status: print(output) if FORCE==0: return status status, output=log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1) if status: print(output) if FORCE==0: return status print(\"Done device_install\") return def device_uninstall(): global FORCE status, output=log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0) if status==0: I2C_ORDER=1 else: \tI2C_ORDER=0 for i in range(0,len(sfp_map)): target=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\" status, output=log_os_system(\"echo 0x50 > \"+target, 1) if status: print(output) if FORCE==0: return status nodelist=mknod for i in range(len(nodelist)): target=nodelist[-(i+1)] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status return def system_ready(): if driver_inserted()==False: return False if not device_exist(): print(\"not device_exist()\") return False return True def do_install(): if driver_inserted()==False: status=driver_install() if status: if FORCE==0: return status else: print((PROJECT_NAME.upper()+\" drivers detected....\")) ir3570_check() if not device_exist(): status=device_install() if status: if FORCE==0: return status else: print((PROJECT_NAME.upper()+\" devices detected....\")) return def do_uninstall(): if not device_exist(): print((PROJECT_NAME.upper()+\" has no device installed....\")) else: print(\"Removing device....\") status=device_uninstall() if status: if FORCE==0: return status if driver_inserted()==False: print((PROJECT_NAME.upper()+\" has no driver installed....\")) else: print(\"Removing installed driver....\") status=driver_uninstall() if status: if FORCE==0: return status return def device_exist(): ret1, log=log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0) ret2, log=log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# Copyright (C) 2016 Accton Networks, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean\ncommand:\n    install     : install drivers and generate related sysfs nodes\n    clean       : uninstall drivers and remove related sysfs nodes\n\"\"\"\nimport subprocess\nimport getopt\nimport sys\nimport logging\nimport re\nimport time\n\nPROJECT_NAME = 'as7726_32x'\nversion = '0.0.1'\nverbose = False\nDEBUG = False\nargs = []\nALL_DEVICE = {}\n\ni2c_prefix = '/sys/bus/i2c/devices/'\n'''\ni2c_bus = {'fan': ['54-0066'],\n           'thermal': ['54-004c', '55-0048','55-0049', '55-004a', '55-004b'] ,\n           'psu': ['49-0050','50-0053'],\n           'sfp': ['-0050']}\ni2c_nodes = {'fan': ['present', 'front_speed_rpm', 'rear_speed_rpm'],\n           'thermal': ['hwmon/hwmon*/temp1_input'] ,\n           'psu': ['psu_present ', 'psu_power_good']    ,\n           'sfp': ['module_present_ ', 'module_tx_disable_']}\n'''\nsfp_map = [21, 22, 23, 24, 26, 25, 28, 27,\n             17, 18, 19, 20, 29, 30, 31, 32,\n             33, 34, 35, 36, 45, 46, 47, 48,\n             37, 38, 39, 40, 41, 42, 43, 44,\n             15, 16]\n\nmknod =[\n'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-2/new_device',\n\n'echo as7726_32x_cpld1 0x60 > /sys/bus/i2c/devices/i2c-11/new_device',\n'echo as7726_32x_cpld2 0x62 > /sys/bus/i2c/devices/i2c-12/new_device',\n'echo as7726_32x_cpld3 0x64 > /sys/bus/i2c/devices/i2c-13/new_device',\n\n'echo as7726_32x_fan 0x66 > /sys/bus/i2c/devices/i2c-54/new_device',\n\n\n'echo lm75 0x4c > /sys/bus/i2c/devices/i2c-54/new_device',\n'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-55/new_device',\n'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-55/new_device',\n'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-55/new_device',\n'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-55/new_device',\n\n\n# PSU-1\n'echo as7726_32x_psu1 0x53 > /sys/bus/i2c/devices/i2c-50/new_device',\n'echo ym2651 0x5b > /sys/bus/i2c/devices/i2c-50/new_device',\n\n# PSU-2\n'echo as7726_32x_psu2 0x50> /sys/bus/i2c/devices/i2c-49/new_device',\n'echo ym2651 0x58 > /sys/bus/i2c/devices/i2c-49/new_device',\n\n#EERPOM\n'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-0/new_device',\n]\n\n\n\nFORCE = 0\nlogging.basicConfig(filename= PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG)\nlogging.basicConfig(level=logging.INFO)\n\n\nif DEBUG == True:\n    print((sys.argv[0]))\n    print(('ARGV      :', sys.argv[1:]))\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n\n    if len(sys.argv)<2:\n        show_help()\n\n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:\n        print(options)\n        print(args)\n        print((len(sys.argv)))\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n           do_install()\n        elif arg == 'clean':\n           do_uninstall()\n        else:\n            show_help()\n\n\n    return 0\n\ndef show_help():\n    print(( __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]}))\n    sys.exit(0)\n\ndef dis_i2c_ir3570a(addr):\n    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef ir3570_check():\n    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n    try:\n        status, output = subprocess.getstatusoutput(cmd)\n        lines = output.split('\\n')\n        hn = re.findall(r'\\w+', lines[-1])\n        version = int(hn[1], 16)\n        if version == 0x24:  #only for ir3570a\n            ret = dis_i2c_ir3570a(4)\n        else:\n            ret = 0\n    except Exception as e:\n        print(( \"Error on ir3570_check() e:\" + str(e)))\n        return -1\n    return ret\n\n\ndef my_log(txt):\n    if DEBUG == True:\n        print((\"[ACCTON DBG]: \",txt))\n    return\n\ndef log_os_system(cmd, show):\n    logging.info('Run :'+cmd)\n    status = 1\n    output = \"\"\n    status, output = subprocess.getstatusoutput(cmd)\n    my_log (cmd +\" with result:\" + str(status))\n    #my_log (\"cmd:\" + cmd)\n    #my_log (\"      output:\"+output)\n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print(('Failed :'+cmd))\n    return  status, output\n\ndef driver_inserted():\n    ret, lsmod = log_os_system(\"ls /sys/module/*accton*\", 0)\n    logging.info('mods:'+lsmod)\n    if ret :\n        return False\n    else :\n        return True\n\ndef cpld_reset_mac():\n    ret, lsmod = log_os_system(\"i2cset -y 0 0x77 0x1\", 0)\n    ret, lsmod = log_os_system(\"i2cset -y 0 0x76 0x4\", 0)\n    ret, lsmod = log_os_system(\"i2cset -y 0 0x60 0x8 0x77\", 0)\n    time.sleep(1)\n    ret, lsmod = log_os_system(\"i2cset -y 0 0x60 0x8 0xf7\", 0)\n    return True\n\n\n\n#'modprobe cpr_4011_4mxx',\n\nkos = [\n'depmod -ae',\n'modprobe i2c_dev',\n'modprobe i2c_mux_pca954x force_deselect_on_exit=1',\n'modprobe ym2651y',\n'modprobe accton_as7726_32x_cpld',\n'modprobe accton_as7726_32x_fan',\n'modprobe accton_as7726_32x_leds',\n'modprobe accton_as7726_32x_psu',\n'modprobe optoe']\n\ndef driver_install():\n    global FORCE\n    for i in range(0,len(kos)):\n        status, output = log_os_system(kos[i], 1)\n        if status:\n            if FORCE == 0:\n                return status\n\n    print(\"Done driver_install\")\n    \n    #status=cpld_reset_mac()\n    return 0\n\ndef driver_uninstall():\n    global FORCE\n    for i in range(0,len(kos)):\n        rm = kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\")        \n        lst = rm.split(\" \")\n\n        if len(lst) > 3:\n            del(lst[3])\n        rm = \" \".join(lst)\n        status, output = log_os_system(rm, 1)\n        if status:\n            if FORCE == 0:\n                return status\n    return 0\n\ndef device_install():\n    global FORCE\n\n    for i in range(0,len(mknod)):\n        #for pca954x need times to built new i2c buses\n        if mknod[i].find('pca954') != -1:\n            time.sleep(2)\n        \n        status, output = log_os_system(mknod[i], 1)        \n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    for i in range(0,len(sfp_map)):\n        status, output =log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n        status, output =log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    print(\"Done device_install\")\n\n    return\n\ndef device_uninstall():\n    global FORCE\n\n    status, output =log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0)\n    if status==0:\n        I2C_ORDER=1\n    else:\n    \tI2C_ORDER=0\n\n    for i in range(0,len(sfp_map)):\n        target = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\"\n        status, output =log_os_system(\"echo 0x50 > \"+ target, 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n                \n    nodelist = mknod\n\n    for i in range(len(nodelist)):\n        target = nodelist[-(i+1)]\n        temp = target.split()\n        del temp[1]\n        temp[-1] = temp[-1].replace('new_device', 'delete_device')\n        status, output = log_os_system(\" \".join(temp), 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    return\n\ndef system_ready():\n    if driver_inserted() == False:        \n        return False\n    if not device_exist():\n        print(\"not device_exist()\")\n        return False\n    return True\n\ndef do_install():\n    if driver_inserted() == False:\n        status = driver_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print((PROJECT_NAME.upper()+\" drivers detected....\"))\n\n    ir3570_check()\n\n    if not device_exist():\n        status = device_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print((PROJECT_NAME.upper()+\" devices detected....\"))\n    return\n\ndef do_uninstall():\n    if not device_exist():\n        print((PROJECT_NAME.upper()+\" has no device installed....\"))\n    else:\n        print(\"Removing device....\")\n        status = device_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    if driver_inserted()== False :\n        print((PROJECT_NAME.upper()+\" has no driver installed....\"))\n    else:\n        print(\"Removing installed driver....\")\n        status = driver_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    return\n\ndef device_exist():\n    ret1, log = log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0)\n    ret2, log = log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n \n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Stop as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Disable as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as7726_32x_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n", "add": 9, "remove": 9, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py", "badparts": ["import subprocess", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py clean\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7726-32x-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7726-32x-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py\", \"clean\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py install\"])\n     if status:\n         print(\"accton_as7726_32x_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor-fan.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor-psu.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Enable as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor.service\"])\n     if status:\n         print(\"Start as7726-32x-platform-monitor.service failed %d\"%status)\n         return False\n", "add": 7, "remove": 7, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py install\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7726_32x_util.py install\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7726-32x-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as7726-32x-platform-monitor.service\"])"]}, {"diff": "\n     return True\n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.serv", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7726-32x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}], "source": "\n import subprocess def check_pddf_support(): return True def stop_platform_svc(): status, output=subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-fan.service\") if status: print(\"Stop as7726-32x-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-fan.service\") if status: print(\"Disable as7726-32x-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-psu.service\") if status: print(\"Stop as7726-32x-platform-monitor-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-psu.service\") if status: print(\"Disable as7726-32x-platform-monitor-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor.service\") if status: print(\"Stop as7726-32x-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor.service\") if status: print(\"Disable as7726-32x-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py clean\") if status: print(\"accton_as7726_32x_util.py clean command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status) return False return True def start_platform_svc(): status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py install\") if status: print(\"accton_as7726_32x_util.py install command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-fan.service\") if status: print(\"Enable as7726-32x-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-fan.service\") if status: print(\"Start as7726-32x-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-psu.service\") if status: print(\"Enable as7726-32x-platform-monitor-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-psu.service\") if status: print(\"Start as7726-32x-platform-monitor-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor.service\") if status: print(\"Enable as7726-32x-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor.service\") if status: print(\"Start as7726-32x-platform-monitor.service failed %d\"%status) return False return True def start_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print(\"Start pddf-platform-init.service failed %d\"%status) return False return True def stop_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service failed %d\"%status) return False return True def main(): pass if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services. \n# This will be used while switching the pddf->non-pddf mode and vice versa\n\nimport subprocess\n\ndef check_pddf_support():\n    return True\n\ndef stop_platform_svc():\n    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-fan.service\")\n    if status:\n        print(\"Stop as7726-32x-platform-monitor-fan.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-fan.service\")\n    if status:\n        print(\"Disable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor-psu.service\")\n    if status:\n        print(\"Stop as7726-32x-platform-monitor-psu.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor-psu.service\")\n    if status:\n        print(\"Disable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl stop as7726-32x-platform-monitor.service\")\n    if status:\n        print(\"Stop as7726-32x-platform-monitor.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as7726-32x-platform-monitor.service\")\n    if status:\n        print(\"Disable as7726-32x-platform-monitor.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py clean\")\n    if status:\n        print(\"accton_as7726_32x_util.py clean command failed %d\"%status)\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n        return False\n\n    return True\n    \ndef start_platform_svc():\n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7726_32x_util.py install\")\n    if status:\n        print(\"accton_as7726_32x_util.py install command failed %d\"%status)\n        return False\n\n    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-fan.service\")\n    if status:\n        print(\"Enable as7726-32x-platform-monitor-fan.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-fan.service\")\n    if status:\n        print(\"Start as7726-32x-platform-monitor-fan.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor-psu.service\")\n    if status:\n        print(\"Enable as7726-32x-platform-monitor-psu.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor-psu.service\")\n    if status:\n        print(\"Start as7726-32x-platform-monitor-psu.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl enable as7726-32x-platform-monitor.service\")\n    if status:\n        print(\"Enable as7726-32x-platform-monitor.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl start as7726-32x-platform-monitor.service\")\n    if status:\n        print(\"Start as7726-32x-platform-monitor.service failed %d\"%status)\n        return False\n\n    return True\n\ndef start_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print(\"Start pddf-platform-init.service failed %d\"%status)\n        return False\n    \n    return True\n\ndef stop_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service failed %d\"%status)\n        return False\n\n    return True\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py": {"changes": [{"diff": "\n     print( __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]})\n     sys.exit(0)\n \n-   \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+',", "add": 6, "remove": 7, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/accton_as7816_64x_util.py", "badparts": ["    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cdump -y 0 0x42 s 0x9a\"", "        status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]", "        status, output = getstatusoutput_noshell(cmd)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes \"\"\" import subprocess import getopt import sys import logging import re import time import os PROJECT_NAME='as7816_64x' version='0.1.0' verbose=False DEBUG=False args=[] ALL_DEVICE={} FORCE=0 if DEBUG==True: print(sys.argv[0]) print('ARGV :', sys.argv[1:] ) def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print(options) print(args) print(len(sys.argv)) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': do_install() elif arg=='clean': do_uninstall() elif arg=='api': do_sonic_platform_install() elif arg=='api_clean': do_sonic_platform_clean() else: show_help() return 0 def show_help(): print( __doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]}) sys.exit(0) def dis_i2c_ir3570a(addr): cmd=\"i2cset -y 0 0x%x 0xE5 0x01\" % addr status, output=subprocess.getstatusoutput(cmd) cmd=\"i2cset -y 0 0x%x 0x12 0x02\" % addr status, output=subprocess.getstatusoutput(cmd) return status def ir3570_check(): cmd=\"i2cdump -y 0 0x42 s 0x9a\" try: status, output=subprocess.getstatusoutput(cmd) lines=output.split('\\n') hn=re.findall(r'\\w+', lines[-1]) version=int(hn[1], 16) if version==0x24: ret=dis_i2c_ir3570a(4) else: ret=0 except Exception as e: print(\"Error on ir3570_check() e:\" +str(e)) return -1 return ret def my_log(txt): if DEBUG==True: print(\"[ROY]\"+txt) return def log_os_system(cmd, show): logging.info('Run:'+cmd) status, output=subprocess.getstatusoutput(cmd) my_log(cmd +\"with result:\" +str(status)) my_log(\" output:\"+output) if status: logging.info('Failed:'+cmd) if show: print('Failed:'+cmd) return status, output def driver_check(): ret, lsmod=log_os_system(\"ls /sys/module/*accton*\", 0) logging.info('mods:'+lsmod) if ret: return False else: return True kos=[ 'modprobe i2c_dev', 'modprobe i2c_mux_pca954x force_deselect_on_exit=1', 'modprobe optoe', 'modprobe accton_i2c_cpld' , 'modprobe ym2651y' , 'modprobe x86-64-accton-as7816-64x-fan' , 'modprobe x86-64-accton-as7816-64x-leds' , 'modprobe x86-64-accton-as7816-64x-psu'] def driver_install(): global FORCE status, output=log_os_system(\"depmod\", 1) for i in range(0,len(kos)): status, output=log_os_system(kos[i], 1) if status: if FORCE==0: return status print(\"Done driver_install\") return 0 def driver_uninstall(): global FORCE for i in range(0,len(kos)): rm=kos[-(i+1)] lst=rm.split(\" \") if len(lst) > 2: del(lst[2:]) rm=\" \".join(lst) rm=rm.replace(\"modprobe\", \"modprobe -rq\") rm=rm.replace(\"insmod\", \"rmmod\") status, output=log_os_system(rm, 1) if status: if FORCE==0: return status return 0 i2c_prefix='/sys/bus/i2c/devices/' ''' i2c_bus={'fan':['17-0068'] , 'thermal':['18-0048','18-0049', '18-004a', '18-004b', '17-004d', '17-004e'], 'psu':['10-0053','9-0050'], 'sfp':['-0050']} i2c_nodes={'fan':['present', 'front_speed_rpm', 'rear_speed_rpm'], 'thermal':['hwmon/hwmon*/temp1_input'], 'psu':['psu_present', 'psu_power_good'] , 'sfp':['module_present']} ''' sfp_map=[37,38,39,40,42,41,44,43,33,34,35,36,45,46,47,48,49,50,51,52, 61,62,63,64,53,54,55,56,57,58,59,60,69,70,71,72,77,78,79,80,65, \t 66,67,68,73,74,75,76,85,86,87,88,31,32,29,30,81,82,83,84,25,26, 27,28] mknod=[ 'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x70 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x71 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo as7816_64x_psu1 0x53 > /sys/bus/i2c/devices/i2c-10/new_device', 'echo ym2851 0x5b > /sys/bus/i2c/devices/i2c-10/new_device', 'echo as7816_64x_psu2 0x50 > /sys/bus/i2c/devices/i2c-9/new_device', 'echo ym2851 0x58 > /sys/bus/i2c/devices/i2c-9/new_device', 'echo as7816_64x_fan 0x68 > /sys/bus/i2c/devices/i2c-17/new_device', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4d > /sys/bus/i2c/devices/i2c-17/new_device', 'echo lm75 0x4e > /sys/bus/i2c/devices/i2c-17/new_device', 'echo cpld_as7816 0x60 > /sys/bus/i2c/devices/i2c-19/new_device', 'echo cpld_plain 0x62 > /sys/bus/i2c/devices/i2c-20/new_device', 'echo cpld_plain 0x64 > /sys/bus/i2c/devices/i2c-21/new_device', 'echo cpld_plain 0x66 > /sys/bus/i2c/devices/i2c-22/new_device'] def i2c_order_check(): return 0 def device_install(): global FORCE for i in range(0,len(mknod)): if mknod[i].find('pca954') !=-1: time.sleep(1) status, output=log_os_system(mknod[i], 1) if status: print(output) if FORCE==0: return status for i in range(0,len(sfp_map)): path=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\" status, output=log_os_system(\"echo optoe1 0x50 > \" +path, 1) if status: print(output) if FORCE==0: return status print(\"Done device_install\") return def device_uninstall(): global FORCE status, output=log_os_system(\"ls /sys/bus/i2c/devices/1-0076\", 0) for i in range(0,len(sfp_map)): target=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\" status, output=log_os_system(\"echo 0x50 > \"+target, 1) if status: print(output) if FORCE==0: return status nodelist=mknod for i in range(len(nodelist)): target=nodelist[-(i+1)] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status return def system_ready(): if driver_check()==False: return False if not device_exist(): return False return True PLATFORM_ROOT_PATH='/usr/share/sonic/device' PLATFORM_API2_WHL_FILE_PY3='sonic_platform-1.0-py3-none-any.whl' def do_sonic_platform_install(): device_path=\"{}{}{}{}\".format(PLATFORM_ROOT_PATH, '/x86_64-accton_', PROJECT_NAME, '-r0') SONIC_PLATFORM_BSP_WHL_PKG_PY3=\"/\".join([device_path, PLATFORM_API2_WHL_FILE_PY3]) status, output=log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0) if status: if os.path.exists(SONIC_PLATFORM_BSP_WHL_PKG_PY3): status, output=log_os_system(\"pip3 install \"+SONIC_PLATFORM_BSP_WHL_PKG_PY3, 1) if status: print(\"Error: Failed to install{}\".format(PLATFORM_API2_WHL_FILE_PY3)) return status else: print(\"Successfully installed{} package\".format(PLATFORM_API2_WHL_FILE_PY3)) else: print('{} is not found'.format(PLATFORM_API2_WHL_FILE_PY3)) else: print('{} has installed'.format(PLATFORM_API2_WHL_FILE_PY3)) return def do_sonic_platform_clean(): status, output=log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0) if status: print('{} does not install, not need to uninstall'.format(PLATFORM_API2_WHL_FILE_PY3)) else: status, output=log_os_system(\"pip3 uninstall sonic-platform -y\", 0) if status: print('Error: Failed to uninstall{}'.format(PLATFORM_API2_WHL_FILE_PY3)) return status else: print('{} is uninstalled'.format(PLATFORM_API2_WHL_FILE_PY3)) return def do_install(): print(\"Checking system....\") if driver_check()==False: print(\"No driver, installing....\") status=driver_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" drivers detected....\") ir3570_check() if not device_exist(): print(\"No device, installing....\") status=device_install() if status: if FORCE==0: return status else: print(PROJECT_NAME.upper()+\" devices detected....\") do_sonic_platform_install() return def do_uninstall(): print(\"Checking system....\") if not device_exist(): print(PROJECT_NAME.upper() +\" has no device installed....\") else: print(\"Removing device....\") status=device_uninstall() if status: if FORCE==0: return status if driver_check()==False: print(PROJECT_NAME.upper() +\" has no driver installed....\") else: print(\"Removing installed driver....\") status=driver_uninstall() if status: if FORCE==0: return status do_sonic_platform_clean() return def device_exist(): ret1, log=log_os_system(\"ls \"+i2c_prefix+\"*0076\", 0) ret2, log=log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# Copyright (C) 2016 Accton Networks, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean\ncommand:\n    install     : install drivers and generate related sysfs nodes\n    clean       : uninstall drivers and remove related sysfs nodes\n\"\"\"\nimport subprocess\nimport getopt\nimport sys\nimport logging\nimport re\nimport time\nimport os\n\n\n\nPROJECT_NAME = 'as7816_64x'\nversion = '0.1.0'\nverbose = False\nDEBUG = False\nargs = []\nALL_DEVICE = {}               \n\nFORCE = 0\n#logging.basicConfig(filename= PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG)\n#logging.basicConfig(level=logging.INFO)\n\n\nif DEBUG == True:\n    print(sys.argv[0])\n    print('ARGV      :', sys.argv[1:]   )\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n        \n    if len(sys.argv)<2:\n        show_help()\n         \n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:\n        print(options)\n        print(args)\n        print(len(sys.argv))\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n           do_install()\n        elif arg == 'clean':\n           do_uninstall()\n        elif arg == 'api':\n           do_sonic_platform_install()\n        elif arg == 'api_clean':   \n           do_sonic_platform_clean()\n        \n        else:\n            show_help()\n\n\n    return 0\n\ndef show_help():\n    print( __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]})\n    sys.exit(0)\n\n   \ndef dis_i2c_ir3570a(addr):\n    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef ir3570_check():\n    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n    try:\n        status, output = subprocess.getstatusoutput(cmd)\n        lines = output.split('\\n')\n        hn = re.findall(r'\\w+', lines[-1])\n        version = int(hn[1], 16)\n        if version == 0x24:  #only for ir3570a\n            ret = dis_i2c_ir3570a(4)\n        else:\n            ret = 0\n    except Exception as e:\n        print(\"Error on ir3570_check() e:\" + str(e))\n        return -1\n    return ret\n\ndef my_log(txt):\n    if DEBUG == True:\n        print(\"[ROY]\"+txt)\n    return\n    \ndef log_os_system(cmd, show):\n    logging.info('Run :'+cmd)  \n    status, output = subprocess.getstatusoutput(cmd)    \n    my_log (cmd +\"with result:\" + str(status))\n    my_log (\"      output:\"+output)    \n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print('Failed :'+cmd)\n    return  status, output\n            \ndef driver_check():\n    ret, lsmod = log_os_system(\"ls /sys/module/*accton*\", 0)\n    logging.info('mods:'+lsmod)\n    if ret :\n        return False\n    else :\n        return True\n\n\n\nkos = [\n'modprobe i2c_dev',\n'modprobe i2c_mux_pca954x force_deselect_on_exit=1',\n'modprobe optoe',\n'modprobe accton_i2c_cpld'  ,\n'modprobe ym2651y'                  ,\n'modprobe x86-64-accton-as7816-64x-fan'     ,\n#'modprobe x86-64-accton-as7816-64x-sfp'      ,\n'modprobe x86-64-accton-as7816-64x-leds'      ,\n'modprobe x86-64-accton-as7816-64x-psu' ]\n\ndef driver_install():\n    global FORCE\n    status, output = log_os_system(\"depmod\", 1)\n    for i in range(0,len(kos)):\n        status, output = log_os_system(kos[i], 1)\n        if status:\n            if FORCE == 0:        \n                return status              \n    \n    print(\"Done driver_install\")\n    \n    return 0\n    \ndef driver_uninstall():\n    global FORCE\n    for i in range(0,len(kos)):\n        #remove parameter if any\n        rm = kos[-(i+1)]\n        lst = rm.split(\" \")\n        if len(lst) > 2:\n            del(lst[2:])\n        rm = \" \".join(lst)\n\n        #Change to removing commands\n        rm = rm.replace(\"modprobe\", \"modprobe -rq\")\n        rm = rm.replace(\"insmod\", \"rmmod\")        \n        status, output = log_os_system(rm, 1)\n        if status:\n            if FORCE == 0:        \n                return status              \n    return 0\n\n\ni2c_prefix = '/sys/bus/i2c/devices/'\n'''\ni2c_bus = {'fan': ['17-0068']                 ,\n           'thermal': ['18-0048','18-0049', '18-004a' , '18-004b', '17-004d', '17-004e'] ,\n           'psu': ['10-0053','9-0050'], \n           'sfp': ['-0050']}\ni2c_nodes = {'fan': ['present', 'front_speed_rpm', 'rear_speed_rpm'] ,\n           'thermal': ['hwmon/hwmon*/temp1_input'] ,\n           'psu': ['psu_present', 'psu_power_good']    ,\n           'sfp': ['module_present']}\n'''                  \n\nsfp_map =  [37,38,39,40,42,41,44,43,33,34,35,36,45,46,47,48,49,50,51,52,\n           61,62,63,64,53,54,55,56,57,58,59,60,69,70,71,72,77,78,79,80,65,\n\t   66,67,68,73,74,75,76,85,86,87,88,31,32,29,30,81,82,83,84,25,26,\n           27,28]\n\n\nmknod =[   \n'echo pca9548  0x77 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo pca9548  0x71 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548  0x76 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548  0x73 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548  0x70 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x71 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x72 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x73 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x74 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x75 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548  0x76 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo 24c02  0x56 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo as7816_64x_psu1  0x53 > /sys/bus/i2c/devices/i2c-10/new_device',\n'echo ym2851  0x5b > /sys/bus/i2c/devices/i2c-10/new_device',\n'echo as7816_64x_psu2  0x50 > /sys/bus/i2c/devices/i2c-9/new_device',\n'echo ym2851  0x58 > /sys/bus/i2c/devices/i2c-9/new_device',\n'echo as7816_64x_fan  0x68 > /sys/bus/i2c/devices/i2c-17/new_device',\n'echo lm75  0x48 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75  0x49 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75  0x4a > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75  0x4b > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75  0x4d > /sys/bus/i2c/devices/i2c-17/new_device',\n'echo lm75  0x4e > /sys/bus/i2c/devices/i2c-17/new_device',\n'echo cpld_as7816  0x60 > /sys/bus/i2c/devices/i2c-19/new_device',\n'echo cpld_plain  0x62 > /sys/bus/i2c/devices/i2c-20/new_device',\n'echo cpld_plain  0x64 > /sys/bus/i2c/devices/i2c-21/new_device',\n'echo cpld_plain  0x66 > /sys/bus/i2c/devices/i2c-22/new_device']\n       \ndef i2c_order_check():    \n    return 0\n                     \ndef device_install():\n    global FORCE\n    \n    for i in range(0,len(mknod)):\n        #for pca954x need times to built new i2c buses            \n        if mknod[i].find('pca954') != -1:\n           time.sleep(1)         \n           \n        status, output = log_os_system(mknod[i], 1)\n        if status:\n            print(output)\n            if FORCE == 0:                \n                return status  \n\n    for i in range(0,len(sfp_map)):\n        path = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\"\n        status, output =log_os_system(\"echo optoe1 0x50 > \" + path, 1)\n        if status:\n            print(output)\n            if FORCE == 0:            \n                return status                                  \n     \n    print(\"Done device_install\")\n     \n    return \n    \ndef device_uninstall():\n    global FORCE\n    \n    status, output =log_os_system(\"ls /sys/bus/i2c/devices/1-0076\", 0)\n    \n    for i in range(0,len(sfp_map)):\n        target = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\"\n        status, output =log_os_system(\"echo 0x50 > \"+ target, 1)\n        if status:\n            print(output)\n            if FORCE == 0:            \n                return status\n       \n    nodelist = mknod\n           \n    for i in range(len(nodelist)):\n        target = nodelist[-(i+1)]\n        temp = target.split()\n        del temp[1]\n        temp[-1] = temp[-1].replace('new_device', 'delete_device')\n        status, output = log_os_system(\" \".join(temp), 1)\n        if status:\n            print(output)\n            if FORCE == 0:            \n                return status  \n                                  \n    return \n        \ndef system_ready():\n    if driver_check() == False:\n        return False\n    if not device_exist(): \n        return False\n    return True\n\nPLATFORM_ROOT_PATH = '/usr/share/sonic/device'\nPLATFORM_API2_WHL_FILE_PY3 ='sonic_platform-1.0-py3-none-any.whl'\ndef do_sonic_platform_install():\n    device_path = \"{}{}{}{}\".format(PLATFORM_ROOT_PATH, '/x86_64-accton_', PROJECT_NAME, '-r0')\n    SONIC_PLATFORM_BSP_WHL_PKG_PY3 = \"/\".join([device_path, PLATFORM_API2_WHL_FILE_PY3])\n        \n    #Check API2.0 on py whl file\n    status, output = log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0)\n    if status:\n        if os.path.exists(SONIC_PLATFORM_BSP_WHL_PKG_PY3): \n            status, output = log_os_system(\"pip3 install \"+ SONIC_PLATFORM_BSP_WHL_PKG_PY3, 1)\n            if status:\n                print(\"Error: Failed to install {}\".format(PLATFORM_API2_WHL_FILE_PY3))\n                return status\n            else:\n                print(\"Successfully installed {} package\".format(PLATFORM_API2_WHL_FILE_PY3))\n        else:\n            print('{} is not found'.format(PLATFORM_API2_WHL_FILE_PY3))\n    else:        \n        print('{} has installed'.format(PLATFORM_API2_WHL_FILE_PY3))\n     \n    return \n     \ndef do_sonic_platform_clean():\n    status, output = log_os_system(\"pip3 show sonic-platform > /dev/null 2>&1\", 0)   \n    if status:\n        print('{} does not install, not need to uninstall'.format(PLATFORM_API2_WHL_FILE_PY3))\n        \n    else:        \n        status, output = log_os_system(\"pip3 uninstall sonic-platform -y\", 0)\n        if status:\n            print('Error: Failed to uninstall {}'.format(PLATFORM_API2_WHL_FILE_PY3))\n            return status\n        else:\n            print('{} is uninstalled'.format(PLATFORM_API2_WHL_FILE_PY3))\n\n    return\ndef do_install():\n    print(\"Checking system....\")\n    if driver_check() == False:\n        print(\"No driver, installing....\")    \n        status = driver_install()\n        if status:\n            if FORCE == 0:        \n                return  status\n    else:\n        print(PROJECT_NAME.upper()+\" drivers detected....\")\n\n    ir3570_check()\n\n    if not device_exist():\n        print(\"No device, installing....\")\n        status = device_install() \n        if status:\n            if FORCE == 0:        \n                return  status        \n    else:\n        print(PROJECT_NAME.upper()+\" devices detected....\")\n    do_sonic_platform_install()\n\n    return\n    \ndef do_uninstall():\n    print(\"Checking system....\")\n    if not device_exist():\n        print(PROJECT_NAME.upper() +\" has no device installed....\")\n    else:\n        print(\"Removing device....\")\n        status = device_uninstall() \n        if status:\n            if FORCE == 0:            \n                return  status  \n                \n    if driver_check()== False :\n        print(PROJECT_NAME.upper() +\" has no driver installed....\")\n    else:\n        print(\"Removing installed driver....\")\n        status = driver_uninstall()\n        if status:\n            if FORCE == 0:        \n                return  status                          \n                    \n    do_sonic_platform_clean() \n\n    return       \n\ndef device_exist():\n    ret1, log = log_os_system(\"ls \"+i2c_prefix+\"*0076\", 0)\n    ret2, log = log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services.\n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n def check_pddf_support():\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py", "badparts": ["import subprocess"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n \n def stop_platform_svc():\n \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Stop as7816-platform-init.service failed %d\" % status))\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Disable as7816-platform-init.service failed %d\" % status))\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"clean\"])\n     if status:\n         print((\"accton_as7816_util.py clean command failed %d\" % status))\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Stop pddf-platform-init.service along with other platform serives failed %d\" % status))\n         return False\n", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl stop as7816-platform-init.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as7816-platform-init.service\")", "    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py clean\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as7816-platform-init.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as7816-platform-init.service\"])", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"clean\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}, {"diff": "\n \n \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"install\"])\n     if status:\n         print((\"accton_as7816_util.py install command failed %d\" % status))\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as7816-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7816-platform-init.service\"])\n     if status:\n         print((\"Enable as7816-platform-init.service failed %d\" % status))\n         return False\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py install\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as7816-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as7816_util.py\", \"install\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as7816-platform-init.service\"])"]}, {"diff": "\n \n \n def start_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Start pddf-platform-init.service failed %d\" % status))\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])"]}, {"diff": "\n \n \n def stop_platform_pddf():\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print((\"Stop pddf-platform-init.servi", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as7816-64x/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}], "source": "\n import subprocess def check_pddf_support(): return True def stop_platform_svc(): status, output=subprocess.getstatusoutput(\"systemctl stop as7816-platform-init.service\") if status: print((\"Stop as7816-platform-init.service failed %d\" % status)) return False status, output=subprocess.getstatusoutput(\"systemctl disable as7816-platform-init.service\") if status: print((\"Disable as7816-platform-init.service failed %d\" % status)) return False status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py clean\") if status: print((\"accton_as7816_util.py clean command failed %d\" % status)) return False status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print((\"Stop pddf-platform-init.service along with other platform serives failed %d\" % status)) return False return True def start_platform_svc(): status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py install\") if status: print((\"accton_as7816_util.py install command failed %d\" % status)) return False status, output=subprocess.getstatusoutput(\"systemctl enable as7816-platform-init.service\") if status: print((\"Enable as7816-platform-init.service failed %d\" % status)) return False return True def start_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print((\"Start pddf-platform-init.service failed %d\" % status)) return False return True def stop_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print((\"Stop pddf-platform-init.service failed %d\" % status)) return False return True def main(): pass if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services.\n# This will be used while switching the pddf->non-pddf mode and vice versa\nimport subprocess\n\n\ndef check_pddf_support():\n    return True\n\n\ndef stop_platform_svc():\n\n    status, output = subprocess.getstatusoutput(\"systemctl stop as7816-platform-init.service\")\n    if status:\n        print((\"Stop as7816-platform-init.service failed %d\" % status))\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as7816-platform-init.service\")\n    if status:\n        print((\"Disable as7816-platform-init.service failed %d\" % status))\n        return False\n\n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py clean\")\n    if status:\n        print((\"accton_as7816_util.py clean command failed %d\" % status))\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print((\"Stop pddf-platform-init.service along with other platform serives failed %d\" % status))\n        return False\n\n    return True\n\n\ndef start_platform_svc():\n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as7816_util.py install\")\n    if status:\n        print((\"accton_as7816_util.py install command failed %d\" % status))\n        return False\n\n    status, output = subprocess.getstatusoutput(\"systemctl enable as7816-platform-init.service\")\n    if status:\n        print((\"Enable as7816-platform-init.service failed %d\" % status))\n        return False\n\n    return True\n\n\ndef start_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print((\"Start pddf-platform-init.service failed %d\" % status))\n        return False\n\n    return True\n\n\ndef stop_platform_pddf():\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print((\"Stop pddf-platform-init.service failed %d\" % status))\n        return False\n\n    return True\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py": {"changes": [{"diff": "\n     sys.exit(0)\n \n def dis_i2c_ir3570a(addr):\n-    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n-    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n-    status, output = subprocess.getstatusoutput(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]\n+    status, output = getstatusoutput_noshell(cmd)\n+    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]\n+    status, output = getstatusoutput_noshell(cmd)\n     return status\n \n def ir3570_check():\n-    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n+    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]\n     try:\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         lines = output.split('\\n')\n         hn = re.findall(r'\\w+", "add": 6, "remove": 6, "filename": "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/accton_as9716_32d_util.py", "badparts": ["    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr", "    status, output = subprocess.getstatusoutput(cmd)", "    cmd = \"i2cdump -y 0 0x42 s 0x9a\"", "        status, output = subprocess.getstatusoutput(cmd)"], "goodparts": ["    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0xE5\", \"0x01\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cset\", \"-y\", \"0\", \"0x\"+\"%x\"%addr, \"0x12\", \"0x02\"]", "    status, output = getstatusoutput_noshell(cmd)", "    cmd = [\"i2cdump\", \"-y\", \"0\", \"0x42\", \"s\", \"0x9a\"]", "        status, output = getstatusoutput_noshell(cmd)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes \"\"\" import subprocess import getopt import sys import logging import re import time PROJECT_NAME='as9716_32d' version='0.0.1' verbose=False DEBUG=False args=[] ALL_DEVICE={} i2c_prefix='/sys/bus/i2c/devices/' ''' i2c_bus={'fan':['54-0066'], 'thermal':['18-0048', '18-0049','18-004a', '18-004b', '18-004c', '18-004e', '18-004f'], 'psu':['9-0058', '10-0059'], 'sfp':['-0050']} i2c_nodes={'fan':['present', 'front_speed_rpm', 'rear_speed_rpm'], 'thermal':['hwmon/hwmon*/temp1_input'], 'psu':['psu_present ', 'psu_power_good'] , 'sfp':['module_present_ ', 'module_tx_disable_']} ''' sfp_map=[25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58] mknod=[ 'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device', 'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-2/new_device', 'echo as9716_32d_fpga 0x60 > /sys/bus/i2c/devices/i2c-19/new_device', 'echo as9716_32d_cpld1 0x61 > /sys/bus/i2c/devices/i2c-20/new_device', 'echo as9716_32d_cpld2 0x62 > /sys/bus/i2c/devices/i2c-21/new_device', 'echo as9716_32d_cpld_cpu 0x65 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo as9716_32d_fan 0x66 > /sys/bus/i2c/devices/i2c-17/new_device', 'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4c > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4e > /sys/bus/i2c/devices/i2c-18/new_device', 'echo lm75 0x4f > /sys/bus/i2c/devices/i2c-18/new_device', 'echo as9716_32d_psu1 0x50 > /sys/bus/i2c/devices/i2c-9/new_device', 'echo acbel_fsh082 0x58 > /sys/bus/i2c/devices/i2c-9/new_device', 'echo as9716_32d_psu2 0x51 > /sys/bus/i2c/devices/i2c-10/new_device', 'echo acbel_fsh082 0x59 > /sys/bus/i2c/devices/i2c-10/new_device', ] eeprom_mknod=[ 'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-0/new_device', 'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-0/new_device', ] FORCE=0 logging.basicConfig(filename=PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG) logging.basicConfig(level=logging.INFO) if DEBUG==True: print((sys.argv[0])) print(('ARGV :', sys.argv[1:])) def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print(options) print(args) print((len(sys.argv))) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': do_install() elif arg=='clean': do_uninstall() else: show_help() return 0 def show_help(): print(( __doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]})) sys.exit(0) def dis_i2c_ir3570a(addr): cmd=\"i2cset -y 0 0x%x 0xE5 0x01\" % addr status, output=subprocess.getstatusoutput(cmd) cmd=\"i2cset -y 0 0x%x 0x12 0x02\" % addr status, output=subprocess.getstatusoutput(cmd) return status def ir3570_check(): cmd=\"i2cdump -y 0 0x42 s 0x9a\" try: status, output=subprocess.getstatusoutput(cmd) lines=output.split('\\n') hn=re.findall(r'\\w+', lines[-1]) version=int(hn[1], 16) if version==0x24: ret=dis_i2c_ir3570a(4) else: ret=0 except Exception as e: print(( \"Error on ir3570_check() e:\" +str(e))) return -1 return ret def my_log(txt): if DEBUG==True: print((\"[ACCTON DBG]: \"+txt)) return def log_os_system(cmd, show): logging.info('Run:'+cmd) status=1 output=\"\" status, output=subprocess.getstatusoutput(cmd) my_log(cmd +\"with result:\" +str(status)) if status: logging.info('Failed:'+cmd) if show: print(('Failed:'+cmd)) return status, output def driver_inserted(): ret, lsmod=log_os_system(\"ls /sys/module/*accton*\", 0) logging.info('mods:'+lsmod) if ret: return False else: return True kos=[ 'depmod -ae', 'modprobe i2c_dev', 'modprobe i2c_mux_pca954x force_deselect_on_exit=1', 'modprobe accton_i2c_psu', 'modprobe accton_as9716_32d_cpld', 'modprobe accton_as9716_32d_fan', 'modprobe accton_as9716_32d_leds', 'modprobe accton_as9716_32d_psu', 'modprobe optoe', 'modprobe lm75'] cpld_reset_stop='i2cset -y 0 0x65 0x3 0x0' def driver_install(): global FORCE for i in range(0,len(kos)): status, output=log_os_system(kos[i], 1) if status: if FORCE==0: return status log_os_system(cpld_reset_stop, 1) print(\"Done driver_install\") return 0 def driver_uninstall(): global FORCE for i in range(0,len(kos)): rm=kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\") lst=rm.split(\" \") if len(lst) > 3: del(lst[3]) rm=\" \".join(lst) status, output=log_os_system(rm, 1) if status: if FORCE==0: return status return 0 def eeprom_check(): cmd=\"i2cget -y -f 0 0x57\" status, output=subprocess.getstatusoutput(cmd) return status def device_install(): global FORCE global use_57_eeprom for i in range(0,len(mknod)): if mknod[i].find('pca954') !=-1: time.sleep(2) status, output=log_os_system(mknod[i], 1) if status: print(output) if FORCE==0: return status ret=eeprom_check() if ret==0: log_os_system(eeprom_mknod[0], 1) else: log_os_system(eeprom_mknod[1], 1) for i in range(0,len(sfp_map)): status, output=log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1) if status: print(output) if FORCE==0: return status status, output=log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1) if status: print(output) if FORCE==0: return status print(\"Done device_install\") return def device_uninstall(): global FORCE status, output=log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0) if status==0: I2C_ORDER=1 else: \tI2C_ORDER=0 for i in range(0,len(sfp_map)): target=\"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\" status, output=log_os_system(\"echo 0x50 > \"+target, 1) if status: print(output) if FORCE==0: return status nodelist=mknod for i in range(len(nodelist)): target=nodelist[-(i+1)] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) if status: print(output) if FORCE==0: return status ret=eeprom_check() if ret==0: target=eeprom_mknod[0] else: target=eeprom_mknod[1] temp=target.split() del temp[1] temp[-1]=temp[-1].replace('new_device', 'delete_device') status, output=log_os_system(\" \".join(temp), 1) return def system_ready(): if driver_inserted()==False: return False if not device_exist(): print(\"not device_exist()\") return False return True def do_install(): if driver_inserted()==False: status=driver_install() if status: if FORCE==0: return status else: print((PROJECT_NAME.upper()+\" drivers detected....\")) ir3570_check() if not device_exist(): status=device_install() if status: if FORCE==0: return status else: print((PROJECT_NAME.upper()+\" devices detected....\")) return def do_uninstall(): if not device_exist(): print((PROJECT_NAME.upper()+\" has no device installed....\")) else: print(\"Removing device....\") status=device_uninstall() if status: if FORCE==0: return status if driver_inserted()==False: print((PROJECT_NAME.upper()+\" has no driver installed....\")) else: print(\"Removing installed driver....\") status=driver_uninstall() if status: if FORCE==0: return status return def device_exist(): ret1, log=log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0) ret2, log=log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# Copyright (C) 2016 Accton Networks, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean\ncommand:\n    install     : install drivers and generate related sysfs nodes\n    clean       : uninstall drivers and remove related sysfs nodes\n\"\"\"\nimport subprocess\nimport getopt\nimport sys\nimport logging\nimport re\nimport time\n\nPROJECT_NAME = 'as9716_32d'\nversion = '0.0.1'\nverbose = False\nDEBUG = False\nargs = []\nALL_DEVICE = {}\n\ni2c_prefix = '/sys/bus/i2c/devices/'\n'''\ni2c_bus = {'fan': ['54-0066'],\n           'thermal': ['18-0048', '18-0049','18-004a', '18-004b', '18-004c', '18-004e', '18-004f'] ,\n           'psu': ['9-0058', '10-0059'],\n           'sfp': ['-0050']}\ni2c_nodes = {'fan': ['present', 'front_speed_rpm', 'rear_speed_rpm'],\n           'thermal': ['hwmon/hwmon*/temp1_input'] ,\n           'psu': ['psu_present ', 'psu_power_good']    ,\n           'sfp': ['module_present_ ', 'module_tx_disable_']}\n'''\n\nsfp_map = [25, 26, 27, 28, 29, 30, 31, 32,\n           33, 34, 35, 36, 37, 38, 39, 40,\n           41, 42, 43, 44, 45, 46, 47, 48,\n           49, 50, 51, 52, 53, 54, 55, 56,\n           57, 58]\n\n#sfp_map = [25, 26]\n\nmknod =[\n'echo pca9548 0x77 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-1/new_device',\n'echo pca9548 0x72 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x73 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x74 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x75 > /sys/bus/i2c/devices/i2c-2/new_device',\n'echo pca9548 0x76 > /sys/bus/i2c/devices/i2c-2/new_device',\n\n'echo as9716_32d_fpga 0x60 > /sys/bus/i2c/devices/i2c-19/new_device',\n'echo as9716_32d_cpld1 0x61 > /sys/bus/i2c/devices/i2c-20/new_device',\n'echo as9716_32d_cpld2 0x62 > /sys/bus/i2c/devices/i2c-21/new_device',\n'echo as9716_32d_cpld_cpu 0x65 > /sys/bus/i2c/devices/i2c-0/new_device',\n\n'echo as9716_32d_fan 0x66 > /sys/bus/i2c/devices/i2c-17/new_device',\n\n'echo lm75 0x48 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x49 > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x4a > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x4b > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x4c > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x4e > /sys/bus/i2c/devices/i2c-18/new_device',\n'echo lm75 0x4f > /sys/bus/i2c/devices/i2c-18/new_device',\n \n# PSU-1\n'echo as9716_32d_psu1 0x50 > /sys/bus/i2c/devices/i2c-9/new_device',\n'echo acbel_fsh082    0x58 > /sys/bus/i2c/devices/i2c-9/new_device',\n\n# PSU-2\n'echo as9716_32d_psu2 0x51 > /sys/bus/i2c/devices/i2c-10/new_device',\n'echo acbel_fsh082    0x59 > /sys/bus/i2c/devices/i2c-10/new_device',\n]\n\n#EERPOM\neeprom_mknod =[\n'echo 24c02 0x57 > /sys/bus/i2c/devices/i2c-0/new_device',\n'echo 24c02 0x56 > /sys/bus/i2c/devices/i2c-0/new_device',\n]\n\nFORCE = 0\nlogging.basicConfig(filename= PROJECT_NAME+'.log', filemode='w',level=logging.DEBUG)\nlogging.basicConfig(level=logging.INFO)\n\n\nif DEBUG == True:\n    print((sys.argv[0]))\n    print(('ARGV      :', sys.argv[1:]))\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n\n    if len(sys.argv)<2:\n        show_help()\n\n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:\n        print(options)\n        print(args)\n        print((len(sys.argv)))\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n           do_install()\n        elif arg == 'clean':\n           do_uninstall()\n        else:\n            show_help()\n\n\n    return 0\n\ndef show_help():\n    print(( __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]}))\n    sys.exit(0)\n\ndef dis_i2c_ir3570a(addr):\n    cmd = \"i2cset -y 0 0x%x 0xE5 0x01\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    cmd = \"i2cset -y 0 0x%x 0x12 0x02\" % addr\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef ir3570_check():\n    cmd = \"i2cdump -y 0 0x42 s 0x9a\"\n    try:\n        status, output = subprocess.getstatusoutput(cmd)\n        lines = output.split('\\n')\n        hn = re.findall(r'\\w+', lines[-1])\n        version = int(hn[1], 16)\n        if version == 0x24:  #only for ir3570a\n            ret = dis_i2c_ir3570a(4)\n        else:\n            ret = 0\n    except Exception as e:\n        print(( \"Error on ir3570_check() e:\" + str(e)))\n        return -1\n    return ret\n\n\ndef my_log(txt):\n    if DEBUG == True:\n        print((\"[ACCTON DBG]: \"+txt))\n    return\n\ndef log_os_system(cmd, show):\n    logging.info('Run :'+cmd)\n    status = 1\n    output = \"\"\n    status, output = subprocess.getstatusoutput(cmd)\n    my_log (cmd +\"with result:\" + str(status))\n    #my_log (\"cmd:\" + cmd)\n    #my_log (\"      output:\"+output)\n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print(('Failed :'+cmd))\n    return  status, output\n\ndef driver_inserted():\n    ret, lsmod = log_os_system(\"ls /sys/module/*accton*\", 0)\n    logging.info('mods:'+lsmod)\n    if ret :\n        return False\n    else :\n        return True\n\n\nkos = [\n'depmod -ae',\n'modprobe i2c_dev',\n'modprobe i2c_mux_pca954x force_deselect_on_exit=1',\n'modprobe accton_i2c_psu',\n'modprobe accton_as9716_32d_cpld',\n'modprobe accton_as9716_32d_fan',\n'modprobe accton_as9716_32d_leds',\n'modprobe accton_as9716_32d_psu',\n'modprobe optoe',\n'modprobe lm75']\n\ncpld_reset_stop='i2cset -y 0 0x65 0x3 0x0'\n\ndef driver_install():\n    \n    global FORCE\n    for i in range(0,len(kos)):\n        status, output = log_os_system(kos[i], 1)\n        if status:\n            if FORCE == 0:\n                return status\n    log_os_system(cpld_reset_stop, 1)\n    print(\"Done driver_install\")\n    return 0\n\ndef driver_uninstall():\n    global FORCE\n    for i in range(0,len(kos)):\n        rm = kos[-(i+1)].replace(\"modprobe\", \"modprobe -rq\")        \n        lst = rm.split(\" \")\n\n        if len(lst) > 3:\n            del(lst[3])\n        rm = \" \".join(lst)\n        status, output = log_os_system(rm, 1)\n        if status:\n            if FORCE == 0:\n                return status\n    return 0\n\ndef eeprom_check():\n    cmd = \"i2cget -y -f 0 0x57\"\n    status, output = subprocess.getstatusoutput(cmd)\n    return status\n\ndef device_install():\n    global FORCE\n    global use_57_eeprom\n\n    for i in range(0,len(mknod)):\n        #for pca954x need times to built new i2c buses\n        if mknod[i].find('pca954') != -1:\n            time.sleep(2)\n        #print(\"init i2c device instance\")\n        status, output = log_os_system(mknod[i], 1)        \n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n    \n    ret=eeprom_check()\n    if ret==0:\n        log_os_system(eeprom_mknod[0], 1) #new board, 0x57 eeprom\n    else:\n        log_os_system(eeprom_mknod[1], 1) #old board, 0x56 eeprom\n        \n    for i in range(0,len(sfp_map)):\n        status, output =log_os_system(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/new_device\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n        status, output =log_os_system(\"echo port\"+str(i)+\" > /sys/bus/i2c/devices/\"+str(sfp_map[i])+\"-0050/port_name\", 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    print(\"Done device_install\")\n\n    return\n\ndef device_uninstall():\n    global FORCE\n\n    status, output =log_os_system(\"ls /sys/bus/i2c/devices/0-0070\", 0)\n    if status==0:\n        I2C_ORDER=1\n    else:\n    \tI2C_ORDER=0\n\n    for i in range(0,len(sfp_map)):\n        target = \"/sys/bus/i2c/devices/i2c-\"+str(sfp_map[i])+\"/delete_device\"\n        status, output =log_os_system(\"echo 0x50 > \"+ target, 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n                \n    nodelist = mknod\n\n    for i in range(len(nodelist)):\n        target = nodelist[-(i+1)]\n        temp = target.split()\n        del temp[1]\n        temp[-1] = temp[-1].replace('new_device', 'delete_device')\n        status, output = log_os_system(\" \".join(temp), 1)\n        if status:\n            print(output)\n            if FORCE == 0:\n                return status\n\n    ret=eeprom_check()\n    if ret==0:\n        target = eeprom_mknod[0] #0x57\n    else:\n        target = eeprom_mknod[1] #0x56\n    \n    temp = target.split()\n    del temp[1]\n    temp[-1] = temp[-1].replace('new_device', 'delete_device')\n    status, output = log_os_system(\" \".join(temp), 1)\n   \n    return\n\ndef system_ready():\n    if driver_inserted() == False:        \n        return False\n    if not device_exist():\n        print(\"not device_exist()\")\n        return False\n    return True\n\ndef do_install():\n    if driver_inserted() == False:\n        status = driver_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print((PROJECT_NAME.upper()+\" drivers detected....\"))\n\n    ir3570_check()\n\n    if not device_exist():\n        status = device_install()\n        if status:\n            if FORCE == 0:\n                return  status\n    else:\n        print((PROJECT_NAME.upper()+\" devices detected....\"))\n    return\n\ndef do_uninstall():\n    if not device_exist():\n        print((PROJECT_NAME.upper()+\" has no device installed....\"))\n    else:\n        print(\"Removing device....\")\n        status = device_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    if driver_inserted()== False :\n        print((PROJECT_NAME.upper()+\" has no driver installed....\"))\n    else:\n        print(\"Removing installed driver....\")\n        status = driver_uninstall()\n        if status:\n            if FORCE == 0:\n                return  status\n\n    return\n\ndef device_exist():\n    ret1, log = log_os_system(\"ls \"+i2c_prefix+\"*0077\", 0)\n    ret2, log = log_os_system(\"ls \"+i2c_prefix+\"i2c-2\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py": {"changes": [{"diff": "\n #!/usr/bin/env python\n # Script to stop and start the respective platforms default services. \n # This will be used while switching the pddf->non-pddf mode and vice versa\n-import subprocess\n+from sonic_py_common.general import getstatusoutput_noshell\n \n def check_pddf_support():\n     return True\n \n def stop_platform_svc():\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-fan.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-fan.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-psu.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-psu.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Stop as9716-32d-platform-init.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl disable as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Disable as9716-32d-platform-monitor.service failed %d\"%status)\n         return False\n     \n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py clean\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"clean\"])\n     if status:\n         print(\"accton_as9716_32d_util.py clean command failed %d\"%status)\n         return False\n \n     # HACK , stop the pddf-platform-init service if it is active\n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n         return False\n", "add": 7, "remove": 7, "filename": "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py", "badparts": ["import subprocess", "    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-psu.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl disable as9716-32d-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py clean\")", "    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor-psu.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"as9716-32d-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"disable\", \"as9716-32d-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"clean\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}, {"diff": "\n     return True\n     \n def start_platform_svc():\n-    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py install\")\n+    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"install\"])\n     if status:\n         print(\"accton_as9716_32d_util.py install command failed %d\"%status)\n         return False\n \n-    status, output = subprocess.getstatusoutput(\"systemctl enable as9716-32d-platform-monitor.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as9716-32d-platform-monitor.service\"])\n     if status:\n         print(\"Enable as9716-32d-platform-monitor.service failed %d\"%status)\n         return False\n-    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-fan.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-fan.service\"])\n     if status:\n         print(\"Start as9716-32d-platform-monitor-fan.service failed %d\"%status)\n         return False\n         \n-    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-psu.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-psu.service\"])\n     if status:\n         print(\"Start as9716-32d-platform-monitor-psu.service failed %d\"%status)\n         return False\n", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py install\")", "    status, output = subprocess.getstatusoutput(\"systemctl enable as9716-32d-platform-monitor.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-fan.service\")", "    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-psu.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"/usr/local/bin/accton_as9716_32d_util.py\", \"install\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"enable\", \"as9716-32d-platform-monitor.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-fan.service\"])", "    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"as9716-32d-platform-monitor-psu.service\"])"]}, {"diff": "\n \n def start_platform_pddf():   \n \n-    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Start pddf-platform-init.service failed %d\"%status)\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"start\", \"pddf-platform-init.service\"])"]}, {"diff": "\n \n def stop_platform_pddf():   \n \n-    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n+    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])\n     if status:\n         print(\"Stop pddf-platform-init.service failed %d\"%status)\n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-accton/as9716-32d/utils/pddf_switch_svc.py", "badparts": ["    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")"], "goodparts": ["    status, output = getstatusoutput_noshell([\"systemctl\", \"stop\", \"pddf-platform-init.service\"])"]}], "source": "\n import subprocess def check_pddf_support(): return True def stop_platform_svc(): status, output=subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-fan.service\") if status: print(\"Stop as9716-32d-platform-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-psu.service\") if status: print(\"Stop as9716-32d-platform-psu.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor.service\") if status: print(\"Stop as9716-32d-platform-init.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl disable as9716-32d-platform-monitor.service\") if status: print(\"Disable as9716-32d-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py clean\") if status: print(\"accton_as9716_32d_util.py clean command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status) return False return True def start_platform_svc(): status, output=subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py install\") if status: print(\"accton_as9716_32d_util.py install command failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl enable as9716-32d-platform-monitor.service\") if status: print(\"Enable as9716-32d-platform-monitor.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-fan.service\") if status: print(\"Start as9716-32d-platform-monitor-fan.service failed %d\"%status) return False status, output=subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-psu.service\") if status: print(\"Start as9716-32d-platform-monitor-psu.service failed %d\"%status) return False return True def start_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\") if status: print(\"Start pddf-platform-init.service failed %d\"%status) return False return True def stop_platform_pddf(): status, output=subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\") if status: print(\"Stop pddf-platform-init.service failed %d\"%status) return False return True ", "sourceWithComments": "#!/usr/bin/env python\n# Script to stop and start the respective platforms default services. \n# This will be used while switching the pddf->non-pddf mode and vice versa\nimport subprocess\n\ndef check_pddf_support():\n    return True\n\ndef stop_platform_svc():\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-fan.service\")\n    if status:\n        print(\"Stop as9716-32d-platform-fan.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor-psu.service\")\n    if status:\n        print(\"Stop as9716-32d-platform-psu.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"systemctl stop as9716-32d-platform-monitor.service\")\n    if status:\n        print(\"Stop as9716-32d-platform-init.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl disable as9716-32d-platform-monitor.service\")\n    if status:\n        print(\"Disable as9716-32d-platform-monitor.service failed %d\"%status)\n        return False\n    \n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py clean\")\n    if status:\n        print(\"accton_as9716_32d_util.py clean command failed %d\"%status)\n        return False\n\n    # HACK , stop the pddf-platform-init service if it is active\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service along with other platform serives failed %d\"%status)\n        return False\n\n    return True\n    \ndef start_platform_svc():\n    status, output = subprocess.getstatusoutput(\"/usr/local/bin/accton_as9716_32d_util.py install\")\n    if status:\n        print(\"accton_as9716_32d_util.py install command failed %d\"%status)\n        return False\n\n    status, output = subprocess.getstatusoutput(\"systemctl enable as9716-32d-platform-monitor.service\")\n    if status:\n        print(\"Enable as9716-32d-platform-monitor.service failed %d\"%status)\n        return False\n    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-fan.service\")\n    if status:\n        print(\"Start as9716-32d-platform-monitor-fan.service failed %d\"%status)\n        return False\n        \n    status, output = subprocess.getstatusoutput(\"systemctl start as9716-32d-platform-monitor-psu.service\")\n    if status:\n        print(\"Start as9716-32d-platform-monitor-psu.service failed %d\"%status)\n        return False\n\n    return True\n\ndef start_platform_pddf():   \n\n    status, output = subprocess.getstatusoutput(\"systemctl start pddf-platform-init.service\")\n    if status:\n        print(\"Start pddf-platform-init.service failed %d\"%status)\n        return False\n    \n    return True\n\ndef stop_platform_pddf():   \n\n    status, output = subprocess.getstatusoutput(\"systemctl stop pddf-platform-init.service\")\n    if status:\n        print(\"Stop pddf-platform-init.service failed %d\"%status)\n        return False\n\n    return True\n\n"}}, "msg": "[device/accton] Replace os.system and remove subprocess with shell=True (#11985)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\n#### Why I did it\r\n`subprocess.Popen()` and `subprocess.run()` is used with `shell=True`, which is very dangerous for shell injection.\r\n`os` - not secure against maliciously constructed input and dangerous if used to evaluate dynamic content\r\n#### How I did it\r\nReplace `os` by `subprocess`\r\nRemove unused functions"}, "2b3e884209d5028c1763b0f83cfc42b5249b4efb": {"url": "https://api.github.com/repos/mohsin75/sonic-buildimage/commits/2b3e884209d5028c1763b0f83cfc42b5249b4efb", "html_url": "https://github.com/mohsin75/sonic-buildimage/commit/2b3e884209d5028c1763b0f83cfc42b5249b4efb", "sha": "2b3e884209d5028c1763b0f83cfc42b5249b4efb", "keyword": "function injection malicious", "diff": "diff --git a/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py b/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py\nindex cbd48237cc..12a1bbe5d2 100644\n--- a/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py\n+++ b/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py\n@@ -10,5 +10,7 @@ class board(eeprom_tlvinfo.TlvInfoDecoder):\n     def __init__(self, name, path, cpld_root, ro):\n         self.eeprom_path = \"/sys/class/i2c-adapter/i2c-0/0-0053/eeprom\"\n         if not os.path.exists(self.eeprom_path):\n-            os.system(\"echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device\")\n+            file = \"/sys/class/i2c-adapter/i2c-0/new_device\"\n+            with open(file, 'w') as f:\n+                f.write('24c02 0x53\\n')\n         super(board, self).__init__(self.eeprom_path, 0, '', True)\ndiff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py\nindex eb507a49ef..008d5ba08b 100755\n--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py\n+++ b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py\n@@ -18,6 +18,7 @@\n     from sonic_platform.thermal import Thermal\n     from sonic_platform.component import Component\n     from sonic_py_common import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -27,11 +28,6 @@\n except ImportError as e:\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n MAX_SELECT_DELAY = 3600\n COPPER_PORT_START = 1\n COPPER_PORT_END = 48\n@@ -209,7 +205,7 @@ def get_revision(self):\n             string: Revision value of chassis\n         \"\"\"\n         if smbus_present == 0:  # called from host\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x0')\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x0'])\n         else:\n             bus = smbus.SMBus(0)\n             DEVICE_ADDRESS = 0x41\n@@ -331,7 +327,7 @@ def set_status_led(self, color):\n \n         # Write sys led\n         if smbus_present == 0:  # called from host (e.g. 'show system-health')\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cset -y 0 0x41 0x7 %d' % value)\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '0', '0x41', '0x7', str(value)])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"  System LED set %s failed\" % value)\n                 return False\n@@ -353,7 +349,7 @@ def get_status_led(self):\n         \"\"\"\n         # Read sys led\n         if smbus_present == 0:  # called from host\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x7')\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x7'])\n             value = int(value, 16)\n         else:\n             bus = smbus.SMBus(0)\ndiff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py\nindex 134856ea42..4e8863e64f 100644\n--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py\n+++ b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py\n@@ -9,10 +9,10 @@\n \n try:\n     import os\n-    import sys\n     import subprocess\n     import ntpath\n     from sonic_platform_base.component_base import ComponentBase\n+    from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -22,11 +22,6 @@\n except ImportError as e:\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n \n class Component(ComponentBase):\n     \"\"\"Nokia platform-specific Component class\"\"\"\n@@ -35,29 +30,20 @@ class Component(ComponentBase):\n         [\"System-CPLD\", \"Used for managing SFPs, LEDs, PSUs and FANs \"],\n         [\"U-Boot\", \"Performs initialization during booting\"],\n     ]\n-    CPLD_UPDATE_COMMAND = 'cp /usr/sbin/vme /tmp; cp {} /tmp; cd /tmp; ./vme {};'\n+    CPLD_UPDATE_COMMAND1 = ['cp', '/usr/sbin/vme', '/tmp']\n+    CPLD_UPDATE_COMMAND2 = ['cp', '', '/tmp']\n+    CPLD_UPDATE_COMMAND3 = ['cd', '/tmp']\n+    CPLD_UPDATE_COMMAND4 = ['./vme', '']\n \n     def __init__(self, component_index):\n         self.index = component_index\n         self.name = self.CHASSIS_COMPONENTS[self.index][0]\n         self.description = self.CHASSIS_COMPONENTS[self.index][1]\n \n-    def _get_command_result(self, cmdline):\n-        try:\n-            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,\n-                                    stderr=subprocess.STDOUT)\n-            stdout = proc.communicate()[0]\n-            proc.wait()\n-            result = stdout.rstrip('\\n')\n-        except OSError:\n-            result = None\n-\n-        return result\n-\n     def _get_cpld_version(self, cpld_number):\n \n         if smbus_present == 0:\n-            cmdstatus, cpld_version = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x2')\n+            cmdstatus, cpld_version = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x2'])\n         else:\n             bus = smbus.SMBus(0)\n             DEVICE_ADDRESS = 0x41\n@@ -144,7 +130,10 @@ def get_firmware_version(self):\n             return self._get_cpld_version(self.index)\n \n         if self.index == 1:\n-            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -1 | cut -d\" \" -f2-4')\n+            cmd1 = ['grep', '--null-data', 'U-Boot', '/dev/mtd0ro']\n+            cmd2 = ['head', '-1']\n+            cmd3 = ['cut', '-d', ' ', '-f2-4']\n+            cmdstatus, uboot_version = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)\n             return uboot_version\n \n     def install_firmware(self, image_path):\n@@ -165,12 +154,16 @@ def install_firmware(self, image_path):\n             print(\"ERROR: the cpld image {} doesn't exist \".format(image_path))\n             return False\n \n-        cmdline = self.CPLD_UPDATE_COMMAND.format(image_path, image_name)\n+        self.CPLD_UPDATE_COMMAND2[1] = image_path\n+        self.CPLD_UPDATE_COMMAND4[1] = image_name\n \n         success_flag = False\n-\n-        try:\n-            subprocess.check_call(cmdline, stderr=subprocess.STDOUT, shell=True)\n+ \n+        try:   \n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND1, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND2, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND3, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND4, stderr=subprocess.STDOUT)\n             success_flag = True\n         except subprocess.CalledProcessError as e:\n             print(\"ERROR: Failed to upgrade CPLD: rc={}\".format(e.returncode))\ndiff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py\nindex 383eb2481f..243b807edb 100644\n--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py\n+++ b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py\n@@ -8,18 +8,13 @@\n \n try:\n     import os\n-    import sys\n     from sonic_platform_base.psu_base import PsuBase\n     from sonic_py_common import logger\n     from sonic_platform.eeprom import Eeprom\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n smbus_present = 1\n try:\n     import smbus\n@@ -86,7 +81,7 @@ def get_presence(self):\n         \"\"\"\n \n         if smbus_present == 0:  # if called from psuutil outside of pmon\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n@@ -150,7 +145,7 @@ def get_status(self):\n         \"\"\"\n \n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n             sonic_logger.log_warning(\"PMON psu-smbus - presence = 0 \")\n         else:\n@@ -179,7 +174,7 @@ def get_voltage(self):\n             e.g. 12.1\n         \"\"\"\n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n@@ -226,7 +221,7 @@ def get_powergood_status(self):\n         \"\"\"\n \n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus(0)\ndiff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py\nindex d95e7a522d..9d8e7e7390 100644\n--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py\n+++ b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py\n@@ -3,8 +3,7 @@\n #\n #############################################################################\n \n-import os\n-import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.sfp_base import SfpBase\n@@ -12,14 +11,10 @@\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom\n     from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper\n     from sonic_py_common import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n smbus_present = 1\n \n try:\n@@ -118,7 +113,7 @@ class Sfp(SfpBase):\n     # Paths\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"armhf-nokia_ixs7215_52x-r0\"\n     HWSKU = \"Nokia-7215\"\n@@ -186,7 +181,7 @@ def __convert_string_to_num(self, value_str):\n             return 'N/A'\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n@@ -811,7 +806,7 @@ def tx_disable(self, tx_disable):\n             return False\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, register = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x5')\n+            cmdstatus, register = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x5'])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"sfp cmdstatus i2c get failed %s\" % register )\n                 return False\n@@ -824,13 +819,13 @@ def tx_disable(self, tx_disable):\n \n         pos = [1, 2, 4, 8]\n         mask = pos[self.index-SFP_PORT_START]\n-        if tx_disable == True:\n+        if tx_disable is True:\n             setbits = register | mask\n         else:\n             setbits = register & ~mask\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, output = cmd.getstatusoutput('sudo i2cset -y -m 0x0f 0 0x41 0x5 %d' % setbits)\n+            cmdstatus, output = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '-m', '0x0f', '0', '0x41', '0x5', str(setbits)])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"sfp cmdstatus i2c write failed %s\" % output )\n                 return False\n@@ -912,7 +907,7 @@ def get_presence(self):\n             return False\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')\n+            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])\n             sfpstatus = int(sfpstatus, 16)\n         else:\n             bus = smbus.SMBus(0)\ndiff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py\nindex fd494ca674..34fc2bc6ae 100644\n--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py\n+++ b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py\n@@ -1,9 +1,9 @@\n '''\n listen for the SFP change event and return to chassis.\n '''\n-import sys\n import time\n from sonic_py_common import logger\n+from sonic_py_common.general import getstatusoutput_noshell\n \n smbus_present = 1\n \n@@ -12,11 +12,6 @@\n except ImportError as e:\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n # system level event/error\n EVENT_ON_ALL_SFP = '-1'\n SYSTEM_NOT_READY = 'system_not_ready'\n@@ -51,7 +46,7 @@ def deinitialize(self):\n     def _get_transceiver_status(self):\n         if smbus_present == 0:\n             sonic_logger.log_info(\"  PMON - smbus ERROR - DEBUG sfp_event   \")\n-            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')\n+            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])\n             sfpstatus = int(sfpstatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n", "message": "", "files": {"/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py": {"changes": [{"diff": "\n     def __init__(self, name, path, cpld_root, ro):\n         self.eeprom_path = \"/sys/class/i2c-adapter/i2c-0/0-0053/eeprom\"\n         if not os.path.exists(self.eeprom_path):\n-            os.system(\"echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device\")\n+            file = \"/sys/class/i2c-adapter/i2c-0/new_device\"\n+            with open(file, 'w') as f:\n+                f.write('24c02 0x53\\n')\n         super(board, self).__init__(self.eeprom_path, 0, '', True)", "add": 3, "remove": 1, "filename": "/device/nokia/armhf-nokia_ixs7215_52x-r0/plugins/eeprom.py", "badparts": ["            os.system(\"echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device\")"], "goodparts": ["            file = \"/sys/class/i2c-adapter/i2c-0/new_device\"", "            with open(file, 'w') as f:", "                f.write('24c02 0x53\\n')"]}], "source": "\ntry: import os from sonic_eeprom import eeprom_tlvinfo except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class board(eeprom_tlvinfo.TlvInfoDecoder): def __init__(self, name, path, cpld_root, ro): self.eeprom_path=\"/sys/class/i2c-adapter/i2c-0/0-0053/eeprom\" if not os.path.exists(self.eeprom_path): os.system(\"echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device\") super(board, self).__init__(self.eeprom_path, 0, '', True) ", "sourceWithComments": "try:\n    import os\n    from sonic_eeprom import eeprom_tlvinfo\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass board(eeprom_tlvinfo.TlvInfoDecoder):\n\n    def __init__(self, name, path, cpld_root, ro):\n        self.eeprom_path = \"/sys/class/i2c-adapter/i2c-0/0-0053/eeprom\"\n        if not os.path.exists(self.eeprom_path):\n            os.system(\"echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device\")\n        super(board, self).__init__(self.eeprom_path, 0, '', True)\n"}, "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py": {"changes": [{"diff": "\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n MAX_SELECT_DELAY = 3600\n COPPER_PORT_START = 1\n COPPER_PORT_END = 48\n", "add": 0, "remove": 5, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py", "badparts": ["if sys.version_info[0] < 3:", "    import commands as cmd", "else:", "    import subprocess as cmd"], "goodparts": []}, {"diff": "\n             string: Revision value of chassis\n         \"\"\"\n         if smbus_present == 0:  # called from host\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x0')\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x0'])\n         else:\n             bus = smbus.SMBus(0)\n             DEVICE_ADDRESS = 0x41\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py", "badparts": ["            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x0')"], "goodparts": ["            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x0'])"]}, {"diff": "\n \n         # Write sys led\n         if smbus_present == 0:  # called from host (e.g. 'show system-health')\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cset -y 0 0x41 0x7 %d' % value)\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '0', '0x41', '0x7', str(value)])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"  System LED set %s failed\" % value)\n                 return False\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py", "badparts": ["            cmdstatus, value = cmd.getstatusoutput('sudo i2cset -y 0 0x41 0x7 %d' % value)"], "goodparts": ["            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '0', '0x41', '0x7', str(value)])"]}, {"diff": "\n         \"\"\"\n         # Read sys led\n         if smbus_present == 0:  # called from host\n-            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x7')\n+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x7'])\n             value = int(value, 16)\n         else:\n             bus = smbus.SMBus(0", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py", "badparts": ["            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x7')"], "goodparts": ["            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x7'])"]}], "source": "\n try: import os import sys import glob from sonic_platform_base.chassis_base import ChassisBase from sonic_platform.sfp import Sfp from sonic_platform.eeprom import Eeprom from sonic_platform.fan import Fan from.fan_drawer import RealDrawer from sonic_platform.psu import Psu from sonic_platform.thermal import Thermal from sonic_platform.component import Component from sonic_py_common import logger except ImportError as e: raise ImportError(str(e) +\"-required module not found\") smbus_present=1 try: import smbus except ImportError as e: smbus_present=0 if sys.version_info[0] < 3: import commands as cmd else: import subprocess as cmd MAX_SELECT_DELAY=3600 COPPER_PORT_START=1 COPPER_PORT_END=48 SFP_PORT_START=49 SFP_PORT_END=52 PORT_END=52 MAX_7215_FAN_DRAWERS=2 MAX_7215_FANS_PER_DRAWER=1 MAX_7215_PSU=2 MAX_7215_THERMAL=6 MAX_7215_COMPONENT=2 SYSLOG_IDENTIFIER=\"chassis\" sonic_logger=logger.Logger(SYSLOG_IDENTIFIER) class Chassis(ChassisBase): \"\"\" Nokia platform-specific Chassis class Derived from Dell S6000 platform. customized for the 7215 platform. \"\"\" def __init__(self): ChassisBase.__init__(self) self.system_led_supported_color=['off', 'amber', 'green', 'amber_blink', 'green_blink'] self.COPPER_PORT_START=COPPER_PORT_START self.COPPER_PORT_END=COPPER_PORT_END self.SFP_PORT_START=SFP_PORT_START self.SFP_PORT_END=SFP_PORT_END self.PORT_END=PORT_END for index in range(self.COPPER_PORT_START, self.COPPER_PORT_END+1): sfp_node=Sfp(index, 'COPPER', 'N/A', 'N/A') self._sfp_list.append(sfp_node) eeprom_path=\"/sys/class/i2c-adapter/i2c-{0}/{0}-0050/eeprom\" mux_dev=sorted(glob.glob(\"/sys/class/i2c-adapter/i2c-0/i2c-[0-9]\")) y=0 for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1): mux_dev_num=mux_dev[y] port_i2c_map=mux_dev_num[-1] y=y +1 port_eeprom_path=eeprom_path.format(port_i2c_map) if not os.path.exists(port_eeprom_path): sonic_logger.log_info(\"path %s didnt exist\" % port_eeprom_path) sfp_node=Sfp(index, 'SFP', port_eeprom_path, port_i2c_map) self._sfp_list.append(sfp_node) self.sfp_event_initialized=False self._eeprom=Eeprom() drawer_num=MAX_7215_FAN_DRAWERS fan_num_per_drawer=MAX_7215_FANS_PER_DRAWER drawer_ctor=RealDrawer fan_index=0 for drawer_index in range(drawer_num): drawer=drawer_ctor(drawer_index) self._fan_drawer_list.append(drawer) for index in range(fan_num_per_drawer): fan=Fan(fan_index, drawer) fan_index +=1 drawer._fan_list.append(fan) self._fan_list.append(fan) for i in range(MAX_7215_PSU): psu=Psu(i) self._psu_list.append(psu) for i in range(MAX_7215_THERMAL): thermal=Thermal(i) self._thermal_list.append(thermal) for i in range(MAX_7215_COMPONENT): component=Component(i) self._component_list.append(component) def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of physical SFP ports in a chassis starting from 1. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None try: sfp=self._sfp_list[index-1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_name(self): \"\"\" Retrieves the name of the chassis Returns: string: The name of the chassis \"\"\" return self._eeprom.modelstr() def get_presence(self): \"\"\" Retrieves the presence of the chassis Returns: bool: True if chassis is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the chassis Returns: string: Model/part number of chassis \"\"\" return self._eeprom.part_number_str() def get_service_tag(self): \"\"\" Retrieves the Service Tag of the chassis Returns: string: Service Tag of chassis \"\"\" return self._eeprom.service_tag_str() def get_status(self): \"\"\" Retrieves the operational status of the chassis Returns: bool: A boolean value, True if chassis is operating properly False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.base_mac_addr() def get_serial(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.serial_number_str() def get_revision(self): \"\"\" Retrieves the hardware revision of the chassis Returns: string: Revision value of chassis \"\"\" if smbus_present==0: cmdstatus, value=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x0') else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0x0 value=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) return str(value) def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.system_eeprom_info() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" return(ChassisBase.REBOOT_CAUSE_NON_HARDWARE, None) def get_change_event(self, timeout=0): \"\"\" Returns a nested dictionary containing all devices which have experienced a change at chassis level Args: timeout: Timeout in milliseconds(optional). If timeout==0, this method will block until a change is detected. Returns: (bool, dict): -True if call successful, False if not; -A nested dictionary where key is a device type, value is a dictionary with key:value pairs in the format of {'device_id':'device_event'}, where device_id is the device ID for this device and device_event, status='1' represents device inserted, status='0' represents device removed. Ex.{'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}} indicates that fan 0 has been removed, fan 2 has been inserted and sfp 11 has been removed. \"\"\" if not self.sfp_event_initialized: from sonic_platform.sfp_event import sfp_event self.sfp_event=sfp_event() self.sfp_event.initialize() self.MAX_SELECT_EVENT_RETURNED=self.PORT_END self.sfp_event_initialized=True wait_for_ever=(timeout==0) port_dict={} if wait_for_ever: timeout=MAX_SELECT_DELAY while True: status=self.sfp_event.check_sfp_status(port_dict, timeout) if not port_dict=={}: break else: status=self.sfp_event.check_sfp_status(port_dict, timeout) if status: return True,{'sfp': port_dict} else: return True,{'sfp':{}} def get_thermal_manager(self): from.thermal_manager import ThermalManager return ThermalManager def initizalize_system_led(self): return True def set_status_led(self, color): \"\"\" Sets the state of the system LED Args: color: A string representing the color with which to set the system LED Returns: bool: True if system LED state is set successfully, False if not \"\"\" if color not in self.system_led_supported_color: return False if(color=='off'): value=0x00 elif(color=='amber'): value=0x01 elif(color=='green'): value=0x02 elif(color=='amber_blink'): value=0x03 elif(color=='green_blink'): value=0x04 else: return False if smbus_present==0: cmdstatus, value=cmd.getstatusoutput('sudo i2cset -y 0 0x41 0x7 %d' % value) if cmdstatus: sonic_logger.log_warning(\" System LED set %s failed\" % value) return False else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICEREG=0x7 bus.write_byte_data(DEVICE_ADDRESS, DEVICEREG, value) return True def get_status_led(self): \"\"\" Gets the state of the system LED Returns: A string, one of the valid LED color strings which could be vendor specified. \"\"\" if smbus_present==0: cmdstatus, value=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x7') value=int(value, 16) else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0x7 value=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) if value==0x00: color='off' elif value==0x01: color='amber' elif value==0x02: color='green' elif value==0x03: color='amber_blink' elif value==0x04: color='green_blink' else: return None return color def get_watchdog(self): \"\"\" Retrieves hardware watchdog device on this chassis Returns: An object derived from WatchdogBase representing the hardware watchdog device Note: We overload this method to ensure that watchdog is only initialized when it is referenced. Currently, only one daemon can open the watchdog. To initialize watchdog in the constructor causes multiple daemon try opening watchdog when loading and constructing a chassis object and fail. By doing so we can eliminate that risk. \"\"\" try: if self._watchdog is None: from sonic_platform.watchdog import WatchdogImplBase watchdog_device_path=\"/dev/watchdog0\" self._watchdog=WatchdogImplBase(watchdog_device_path) except Exception as e: sonic_logger.log_warning(\" Fail to load watchdog{}\".format(repr(e))) return self._watchdog def get_position_in_parent(self): \"\"\" \t\tRetrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned \t\tReturns: \t\t integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \t\t\"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the platform information\n#\n#############################################################################\n\ntry:\n    import os\n    import sys\n    import glob\n    from sonic_platform_base.chassis_base import ChassisBase\n    from sonic_platform.sfp import Sfp\n    from sonic_platform.eeprom import Eeprom\n    from sonic_platform.fan import Fan\n    from .fan_drawer import RealDrawer\n    from sonic_platform.psu import Psu\n    from sonic_platform.thermal import Thermal\n    from sonic_platform.component import Component\n    from sonic_py_common import logger\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nsmbus_present = 1\ntry:\n    import smbus\nexcept ImportError as e:\n    smbus_present = 0\n\nif sys.version_info[0] < 3:\n    import commands as cmd\nelse:\n    import subprocess as cmd\n\nMAX_SELECT_DELAY = 3600\nCOPPER_PORT_START = 1\nCOPPER_PORT_END = 48\nSFP_PORT_START = 49\nSFP_PORT_END = 52\nPORT_END = 52\n\n# Device counts\nMAX_7215_FAN_DRAWERS = 2\nMAX_7215_FANS_PER_DRAWER = 1\nMAX_7215_PSU = 2\nMAX_7215_THERMAL = 6\n\n# Temp - disable these to help with early debug\nMAX_7215_COMPONENT = 2\n\nSYSLOG_IDENTIFIER = \"chassis\"\nsonic_logger = logger.Logger(SYSLOG_IDENTIFIER)\n\n\nclass Chassis(ChassisBase):\n    \"\"\"\n    Nokia platform-specific Chassis class\n        Derived from Dell S6000 platform.\n        customized for the 7215 platform.\n    \"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self.system_led_supported_color = ['off', 'amber', 'green', 'amber_blink', 'green_blink']\n        # Port numbers for SFP List Initialization\n        self.COPPER_PORT_START = COPPER_PORT_START\n        self.COPPER_PORT_END = COPPER_PORT_END\n        self.SFP_PORT_START = SFP_PORT_START\n        self.SFP_PORT_END = SFP_PORT_END\n        self.PORT_END = PORT_END\n\n        # for non-sfp ports create dummy objects for copper / non-sfp ports\n        for index in range(self.COPPER_PORT_START, self.COPPER_PORT_END+1):\n            sfp_node = Sfp(index, 'COPPER', 'N/A', 'N/A')\n            self._sfp_list.append(sfp_node)\n\n        # Verify optoe2 driver SFP eeprom devices were enumerated and exist\n        # then create the sfp nodes\n        eeprom_path = \"/sys/class/i2c-adapter/i2c-{0}/{0}-0050/eeprom\"\n        mux_dev = sorted(glob.glob(\"/sys/class/i2c-adapter/i2c-0/i2c-[0-9]\"))\n        y = 0\n        for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1):\n            mux_dev_num = mux_dev[y]\n            port_i2c_map = mux_dev_num[-1]\n            y = y + 1\n            port_eeprom_path = eeprom_path.format(port_i2c_map)\n            if not os.path.exists(port_eeprom_path):\n                sonic_logger.log_info(\"path %s didnt exist\" % port_eeprom_path)\n            sfp_node = Sfp(index, 'SFP', port_eeprom_path, port_i2c_map)\n            self._sfp_list.append(sfp_node)\n        self.sfp_event_initialized = False\n\n        # Instantiate system eeprom object\n        self._eeprom = Eeprom()\n\n        # Construct lists fans, power supplies, thermals & components\n        drawer_num = MAX_7215_FAN_DRAWERS\n        fan_num_per_drawer = MAX_7215_FANS_PER_DRAWER\n        drawer_ctor = RealDrawer\n        fan_index = 0\n        for drawer_index in range(drawer_num):\n            drawer = drawer_ctor(drawer_index)\n            self._fan_drawer_list.append(drawer)\n            for index in range(fan_num_per_drawer):\n                fan = Fan(fan_index, drawer)\n                fan_index += 1\n                drawer._fan_list.append(fan)\n                self._fan_list.append(fan)\n\n        for i in range(MAX_7215_PSU):\n            psu = Psu(i)\n            self._psu_list.append(psu)\n\n        for i in range(MAX_7215_THERMAL):\n            thermal = Thermal(i)\n            self._thermal_list.append(thermal)\n\n        for i in range(MAX_7215_COMPONENT):\n            component = Component(i)\n            self._component_list.append(component)\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of physical SFP ports in a\n            chassis starting from 1.\n\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index-1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the chassis\n        Returns:\n            string: The name of the chassis\n        \"\"\"\n        return self._eeprom.modelstr()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the chassis\n        Returns:\n            bool: True if chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the chassis\n        Returns:\n            string: Model/part number of chassis\n        \"\"\"\n        return self._eeprom.part_number_str()\n\n    def get_service_tag(self):\n        \"\"\"\n        Retrieves the Service Tag of the chassis\n        Returns:\n            string: Service Tag of chassis\n        \"\"\"\n        return self._eeprom.service_tag_str()\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the chassis\n        Returns:\n            bool: A boolean value, True if chassis is operating properly\n            False if not\n        \"\"\"\n        return True\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.base_mac_addr()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n\n        Returns:\n            A string containing the hardware serial number for this\n            chassis.\n        \"\"\"\n        return self._eeprom.serial_number_str()\n\n    def get_revision(self):\n        \"\"\"\n        Retrieves the hardware revision of the chassis\n\n        Returns:\n            string: Revision value of chassis\n        \"\"\"\n        if smbus_present == 0:  # called from host\n            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x0')\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0x0\n            value = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n        return str(value)\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the\n        chassis\n\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their\n            corresponding values.\n        \"\"\"\n        return self._eeprom.system_eeprom_info()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        # The ixs7215 CPLD does not have a hardware reboot cause register so\n        # the hardware portion of reboot cause can't be implemented\n\n        return (ChassisBase.REBOOT_CAUSE_NON_HARDWARE, None)\n\n    def get_change_event(self, timeout=0):\n        \"\"\"\n        Returns a nested dictionary containing all devices which have\n        experienced a change at chassis level\n\n        Args:\n            timeout: Timeout in milliseconds (optional). If timeout == 0,\n                this method will block until a change is detected.\n\n        Returns:\n            (bool, dict):\n                - True if call successful, False if not;\n                - A nested dictionary where key is a device type,\n                  value is a dictionary with key:value pairs in the format of\n                  {'device_id':'device_event'},\n                  where device_id is the device ID for this device and\n                        device_event,\n                             status='1' represents device inserted,\n                             status='0' represents device removed.\n                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}\n                      indicates that fan 0 has been removed, fan 2\n                      has been inserted and sfp 11 has been removed.\n        \"\"\"\n        # Initialize SFP event first\n        if not self.sfp_event_initialized:\n            from sonic_platform.sfp_event import sfp_event\n            self.sfp_event = sfp_event()\n            self.sfp_event.initialize()\n            self.MAX_SELECT_EVENT_RETURNED = self.PORT_END\n            self.sfp_event_initialized = True\n\n        wait_for_ever = (timeout == 0)\n        port_dict = {}\n        if wait_for_ever:\n            # xrcvd will call this monitor loop in the \"SYSTEM_READY\" state\n            timeout = MAX_SELECT_DELAY\n            while True:\n                status = self.sfp_event.check_sfp_status(port_dict, timeout)\n                if not port_dict == {}:\n                    break\n        else:\n            # At boot up and in \"INIT\" state call from xrcvd will have timeout\n            # value return true without change after timeout and will\n            # transition to \"SYSTEM_READY\"\n            status = self.sfp_event.check_sfp_status(port_dict, timeout)\n\n        if status:\n            return True, {'sfp': port_dict}\n        else:\n            return True, {'sfp': {}}\n\n    def get_thermal_manager(self):\n        from .thermal_manager import ThermalManager\n        return ThermalManager\n\n    def initizalize_system_led(self):\n        return True\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the system LED\n\n        Args:\n            color: A string representing the color with which to set the\n                   system LED\n\n        Returns:\n            bool: True if system LED state is set successfully, False if not\n        \"\"\"\n        if color not in self.system_led_supported_color:\n            return False\n\n        if (color == 'off'):\n            value = 0x00\n        elif (color == 'amber'):\n            value = 0x01\n        elif (color == 'green'):\n            value = 0x02\n        elif (color == 'amber_blink'):\n            value = 0x03\n        elif (color == 'green_blink'):\n            value = 0x04\n        else:\n            return False\n\n        # Write sys led\n        if smbus_present == 0:  # called from host (e.g. 'show system-health')\n            cmdstatus, value = cmd.getstatusoutput('sudo i2cset -y 0 0x41 0x7 %d' % value)\n            if cmdstatus:\n                sonic_logger.log_warning(\"  System LED set %s failed\" % value)\n                return False\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICEREG = 0x7\n            bus.write_byte_data(DEVICE_ADDRESS, DEVICEREG, value)\n\n        return True\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the system LED\n\n        Returns:\n            A string, one of the valid LED color strings which could be vendor\n            specified.\n        \"\"\"\n        # Read sys led\n        if smbus_present == 0:  # called from host\n            cmdstatus, value = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x7')\n            value = int(value, 16)\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0x7\n            value = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n        if value == 0x00:\n            color = 'off'\n        elif value == 0x01:\n            color = 'amber'\n        elif value == 0x02:\n            color = 'green'\n        elif value == 0x03:\n            color = 'amber_blink'\n        elif value == 0x04:\n            color = 'green_blink'\n        else:\n            return None\n\n        return color\n\n    def get_watchdog(self):\n        \"\"\"\n        Retrieves hardware watchdog device on this chassis\n\n        Returns:\n            An object derived from WatchdogBase representing the hardware\n            watchdog device\n\n        Note:\n            We overload this method to ensure that watchdog is only initialized\n            when it is referenced. Currently, only one daemon can open the\n            watchdog. To initialize watchdog in the constructor causes multiple\n            daemon try opening watchdog when loading and constructing a chassis\n            object and fail. By doing so we can eliminate that risk.\n        \"\"\"\n        try:\n            if self._watchdog is None:\n                from sonic_platform.watchdog import WatchdogImplBase\n                watchdog_device_path = \"/dev/watchdog0\"\n                self._watchdog = WatchdogImplBase(watchdog_device_path)\n        except Exception as e:\n            sonic_logger.log_warning(\" Fail to load watchdog {}\".format(repr(e)))\n\n        return self._watchdog\n\n    def get_position_in_parent(self):\n        \"\"\"\n\t\tRetrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n\t\tReturns:\n\t\t    integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n\t\t\"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py": {"changes": [{"diff": "\n \n try:\n     import os\n-    import sys\n     import subprocess\n     import ntpath\n     from sonic_platform_base.component_base import ComponentBase\n+    from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py", "badparts": ["    import sys"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe"]}, {"diff": "\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n \n class Component(ComponentBase):\n     \"\"\"Nokia platform-specific Component class\"\"\"\n", "add": 0, "remove": 5, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py", "badparts": ["if sys.version_info[0] < 3:", "    import commands as cmd", "else:", "    import subprocess as cmd"], "goodparts": []}, {"diff": "\n         [\"System-CPLD\", \"Used for managing SFPs, LEDs, PSUs and FANs \"],\n         [\"U-Boot\", \"Performs initialization during booting\"],\n     ]\n-    CPLD_UPDATE_COMMAND = 'cp /usr/sbin/vme /tmp; cp {} /tmp; cd /tmp; ./vme {};'\n+    CPLD_UPDATE_COMMAND1 = ['cp', '/usr/sbin/vme', '/tmp']\n+    CPLD_UPDATE_COMMAND2 = ['cp', '', '/tmp']\n+    CPLD_UPDATE_COMMAND3 = ['cd', '/tmp']\n+    CPLD_UPDATE_COMMAND4 = ['./vme', '']\n \n     def __init__(self, component_index):\n         self.index = component_index\n         self.name = self.CHASSIS_COMPONENTS[self.index][0]\n         self.description = self.CHASSIS_COMPONENTS[self.index][1]\n \n-    def _get_command_result(self, cmdline):\n-        try:\n-            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,\n-                                    stderr=subprocess.STDOUT)\n-            stdout = proc.communicate()[0]\n-            proc.wait()\n-            result = stdout.rstrip('\\n')\n-        except OSError:\n-            result = None\n-\n-        return result\n-\n     def _get_cpld_version(self, cpld_number):\n \n         if smbus_present == 0:\n-            cmdstatus, cpld_version = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x2')\n+            cmdstatus, cpld_version = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x2'])\n         else:\n             bus = smbus.SMBus(0)\n             DEVICE_ADDRESS = 0x41\n", "add": 5, "remove": 14, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py", "badparts": ["    CPLD_UPDATE_COMMAND = 'cp /usr/sbin/vme /tmp; cp {} /tmp; cd /tmp; ./vme {};'", "    def _get_command_result(self, cmdline):", "        try:", "            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,", "                                    stderr=subprocess.STDOUT)", "            stdout = proc.communicate()[0]", "            proc.wait()", "            result = stdout.rstrip('\\n')", "        except OSError:", "            result = None", "        return result", "            cmdstatus, cpld_version = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x2')"], "goodparts": ["    CPLD_UPDATE_COMMAND1 = ['cp', '/usr/sbin/vme', '/tmp']", "    CPLD_UPDATE_COMMAND2 = ['cp', '', '/tmp']", "    CPLD_UPDATE_COMMAND3 = ['cd', '/tmp']", "    CPLD_UPDATE_COMMAND4 = ['./vme', '']", "            cmdstatus, cpld_version = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x2'])"]}, {"diff": "\n             return self._get_cpld_version(self.index)\n \n         if self.index == 1:\n-            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -1 | cut -d\" \" -f2-4')\n+            cmd1 = ['grep', '--null-data', 'U-Boot', '/dev/mtd0ro']\n+            cmd2 = ['head', '-1']\n+            cmd3 = ['cut', '-d', ' ', '-f2-4']\n+            cmdstatus, uboot_version = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)\n             return uboot_version\n \n     def install_firmware(self, image_path):\n", "add": 4, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py", "badparts": ["            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -1 | cut -d\" \" -f2-4')"], "goodparts": ["            cmd1 = ['grep', '--null-data', 'U-Boot', '/dev/mtd0ro']", "            cmd2 = ['head', '-1']", "            cmd3 = ['cut', '-d', ' ', '-f2-4']", "            cmdstatus, uboot_version = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)"]}, {"diff": "\n             print(\"ERROR: the cpld image {} doesn't exist \".format(image_path))\n             return False\n \n-        cmdline = self.CPLD_UPDATE_COMMAND.format(image_path, image_name)\n+        self.CPLD_UPDATE_COMMAND2[1] = image_path\n+        self.CPLD_UPDATE_COMMAND4[1] = image_name\n \n         success_flag = False\n-\n-        try:\n-            subprocess.check_call(cmdline, stderr=subprocess.STDOUT, shell=True)\n+ \n+        try:   \n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND1, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND2, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND3, stderr=subprocess.STDOUT)\n+            subprocess.check_call(self.CPLD_UPDATE_COMMAND4, stderr=subprocess.STDOUT)\n             success_flag = True\n         except subprocess.CalledProcessError as e:\n             print(\"ERROR: Failed to upgrade CPLD: rc={}\".format(e.returncode", "add": 8, "remove": 4, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py", "badparts": ["        cmdline = self.CPLD_UPDATE_COMMAND.format(image_path, image_name)", "        try:", "            subprocess.check_call(cmdline, stderr=subprocess.STDOUT, shell=True)"], "goodparts": ["        self.CPLD_UPDATE_COMMAND2[1] = image_path", "        self.CPLD_UPDATE_COMMAND4[1] = image_name", "        try:   ", "            subprocess.check_call(self.CPLD_UPDATE_COMMAND1, stderr=subprocess.STDOUT)", "            subprocess.check_call(self.CPLD_UPDATE_COMMAND2, stderr=subprocess.STDOUT)", "            subprocess.check_call(self.CPLD_UPDATE_COMMAND3, stderr=subprocess.STDOUT)", "            subprocess.check_call(self.CPLD_UPDATE_COMMAND4, stderr=subprocess.STDOUT)"]}], "source": "\n try: import os import sys import subprocess import ntpath from sonic_platform_base.component_base import ComponentBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") smbus_present=1 try: import smbus except ImportError as e: smbus_present=0 if sys.version_info[0] < 3: import commands as cmd else: import subprocess as cmd class Component(ComponentBase): \"\"\"Nokia platform-specific Component class\"\"\" CHASSIS_COMPONENTS=[ [\"System-CPLD\", \"Used for managing SFPs, LEDs, PSUs and FANs \"], [\"U-Boot\", \"Performs initialization during booting\"], ] CPLD_UPDATE_COMMAND='cp /usr/sbin/vme /tmp; cp{} /tmp; cd /tmp;./vme{};' def __init__(self, component_index): self.index=component_index self.name=self.CHASSIS_COMPONENTS[self.index][0] self.description=self.CHASSIS_COMPONENTS[self.index][1] def _get_command_result(self, cmdline): try: proc=subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE, stderr=subprocess.STDOUT) stdout=proc.communicate()[0] proc.wait() result=stdout.rstrip('\\n') except OSError: result=None return result def _get_cpld_version(self, cpld_number): if smbus_present==0: cmdstatus, cpld_version=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x2') else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0x2 cpld_version=str(bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)) return str(int(cpld_version, 16)) def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return self.name def get_model(self): \"\"\" Retrieves the part number of the component Returns: string: Part number of component \"\"\" return 'NA' def get_serial(self): \"\"\" Retrieves the serial number of the component Returns: string: Serial number of component \"\"\" return 'NA' def get_presence(self): \"\"\" Retrieves the presence of the component Returns: bool: True if present, False if not \"\"\" return True def get_status(self): \"\"\" Retrieves the operational status of the component Returns: bool: True if component is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether component is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return self.description def get_firmware_version(self): \"\"\" Retrieves the firmware version of the component Returns: A string containing the firmware version of the component \"\"\" if self.index==0: return self._get_cpld_version(self.index) if self.index==1: cmdstatus, uboot_version=cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -1 | cut -d\" \" -f2-4') return uboot_version def install_firmware(self, image_path): \"\"\" Installs firmware to the component Args: image_path: A string, path to firmware image Returns: A boolean, True if install was successful, False if not \"\"\" image_name=ntpath.basename(image_path) print(\" ixs7215 -install cpld{}\".format(image_name)) if not os.path.isfile(image_path): print(\"ERROR: the cpld image{} doesn't exist \".format(image_path)) return False cmdline=self.CPLD_UPDATE_COMMAND.format(image_path, image_name) success_flag=False try: subprocess.check_call(cmdline, stderr=subprocess.STDOUT, shell=True) success_flag=True except subprocess.CalledProcessError as e: print(\"ERROR: Failed to upgrade CPLD: rc={}\".format(e.returncode)) if success_flag: print(\"INFO: Refresh or power cycle is required to finish CPLD installation\") return success_flag ", "sourceWithComments": "########################################################################\n# NOKIA IXS7215\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Components' (e.g., BIOS, CPLD, FPGA, etc.) available in\n# the platform\n#\n########################################################################\n\ntry:\n    import os\n    import sys\n    import subprocess\n    import ntpath\n    from sonic_platform_base.component_base import ComponentBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nsmbus_present = 1\ntry:\n    import smbus\nexcept ImportError as e:\n    smbus_present = 0\n\nif sys.version_info[0] < 3:\n    import commands as cmd\nelse:\n    import subprocess as cmd\n\n\nclass Component(ComponentBase):\n    \"\"\"Nokia platform-specific Component class\"\"\"\n\n    CHASSIS_COMPONENTS = [\n        [\"System-CPLD\", \"Used for managing SFPs, LEDs, PSUs and FANs \"],\n        [\"U-Boot\", \"Performs initialization during booting\"],\n    ]\n    CPLD_UPDATE_COMMAND = 'cp /usr/sbin/vme /tmp; cp {} /tmp; cd /tmp; ./vme {};'\n\n    def __init__(self, component_index):\n        self.index = component_index\n        self.name = self.CHASSIS_COMPONENTS[self.index][0]\n        self.description = self.CHASSIS_COMPONENTS[self.index][1]\n\n    def _get_command_result(self, cmdline):\n        try:\n            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,\n                                    stderr=subprocess.STDOUT)\n            stdout = proc.communicate()[0]\n            proc.wait()\n            result = stdout.rstrip('\\n')\n        except OSError:\n            result = None\n\n        return result\n\n    def _get_cpld_version(self, cpld_number):\n\n        if smbus_present == 0:\n            cmdstatus, cpld_version = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x2')\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0x2\n            cpld_version = str(bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG))\n\n        return str(int(cpld_version, 16))\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n\n        Returns:\n            A string containing the name of the component\n        \"\"\"\n        return self.name\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the part number of the component\n        Returns:\n            string: Part number of component\n        \"\"\"\n        return 'NA'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the component\n        Returns:\n            string: Serial number of component\n        \"\"\"\n        return 'NA'\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the component\n        Returns:\n            bool: True if  present, False if not\n        \"\"\"\n        return True\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the component\n        Returns:\n            bool: True if component is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        Returns:\n            integer: The 1-based relative physical position in parent\n            device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether component is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n\n        Returns:\n            A string containing the description of the component\n        \"\"\"\n        return self.description\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of the component\n\n        Returns:\n            A string containing the firmware version of the component\n        \"\"\"\n        if self.index == 0:\n            return self._get_cpld_version(self.index)\n\n        if self.index == 1:\n            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -1 | cut -d\" \" -f2-4')\n            return uboot_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Installs firmware to the component\n\n        Args:\n            image_path: A string, path to firmware image\n\n        Returns:\n            A boolean, True if install was successful, False if not\n        \"\"\"\n        image_name = ntpath.basename(image_path)\n        print(\" ixs7215 - install cpld {}\".format(image_name))\n\n        # check whether the image file exists\n        if not os.path.isfile(image_path):\n            print(\"ERROR: the cpld image {} doesn't exist \".format(image_path))\n            return False\n\n        cmdline = self.CPLD_UPDATE_COMMAND.format(image_path, image_name)\n\n        success_flag = False\n\n        try:\n            subprocess.check_call(cmdline, stderr=subprocess.STDOUT, shell=True)\n            success_flag = True\n        except subprocess.CalledProcessError as e:\n            print(\"ERROR: Failed to upgrade CPLD: rc={}\".format(e.returncode))\n\n        if success_flag:\n            print(\"INFO: Refresh or power cycle is required to finish CPLD installation\")\n\n        return success_flag\n\n"}, "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py": {"changes": [{"diff": "\n \n try:\n     import os\n-    import sys\n     from sonic_platform_base.psu_base import PsuBase\n     from sonic_py_common import logger\n     from sonic_platform.eeprom import Eeprom\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n smbus_present = 1\n try:\n     import smbus\n", "add": 1, "remove": 6, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py", "badparts": ["    import sys", "if sys.version_info[0] < 3:", "    import commands as cmd", "else:", "    import subprocess as cmd"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         \"\"\"\n \n         if smbus_present == 0:  # if called from psuutil outside of pmon\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py", "badparts": ["            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')"], "goodparts": ["            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])"]}, {"diff": "\n         \"\"\"\n \n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n             sonic_logger.log_warning(\"PMON psu-smbus - presence = 0 \")\n         else:\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py", "badparts": ["            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')"], "goodparts": ["            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])"]}, {"diff": "\n             e.g. 12.1\n         \"\"\"\n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py", "badparts": ["            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')"], "goodparts": ["            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])"]}, {"diff": "\n         \"\"\"\n \n         if smbus_present == 0:\n-            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])\n             psustatus = int(psustatus, 16)\n         else:\n             bus = smbus.SMBus", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py", "badparts": ["            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')"], "goodparts": ["            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])"]}], "source": "\n try: import os import sys from sonic_platform_base.psu_base import PsuBase from sonic_py_common import logger from sonic_platform.eeprom import Eeprom except ImportError as e: raise ImportError(str(e) +\"-required module not found\") if sys.version_info[0] < 3: import commands as cmd else: import subprocess as cmd smbus_present=1 try: import smbus except ImportError as e: smbus_present=0 sonic_logger=logger.Logger('psu') class Psu(PsuBase): \"\"\"Nokia platform-specific PSU class for 7215 \"\"\" def __init__(self, psu_index): PsuBase.__init__(self) self.index=psu_index +1 self._fan_list=[] self.eeprom=Eeprom(is_psu=True, psu_index=self.index) def _write_sysfs_file(self, sysfs_file, value): rv='ERR' if(not os.path.isfile(sysfs_file)): return rv try: with open(sysfs_file, 'w') as fd: rv=fd.write(str(value)) except Exception as e: rv='ERR' return rv def _read_sysfs_file(self, sysfs_file): rv='ERR' if(not os.path.isfile(sysfs_file)): return rv try: with open(sysfs_file, 'r') as fd: rv=fd.read() except Exception as e: rv='ERR' rv=rv.rstrip('\\r\\n') rv=rv.lstrip(\" \") return rv def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return \"PSU{}\".format(self.index) def get_presence(self): \"\"\" Retrieves the presence of the Power Supply Unit(PSU) Returns: bool: True if PSU is present, False if not \"\"\" if smbus_present==0: cmdstatus, psustatus=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa') psustatus=int(psustatus, 16) else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0xa psustatus=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) if self.index==1: psustatus=psustatus & 1 if psustatus==1: return False if self.index==2: psustatus=psustatus & 2 if psustatus==2: return False return True def get_model(self): \"\"\" Retrieves the part number of the PSU Returns: string: Part number of PSU \"\"\" return self.eeprom.modelstr() def get_serial(self): \"\"\" Retrieves the serial number of the PSU Returns: string: Serial number of PSU \"\"\" return self.eeprom.serial_number_str() def get_revision(self): \"\"\" Retrieves the HW revision of the PSU Returns: string: HW revision of PSU \"\"\" return self.eeprom.part_number_str() def get_part_number(self): \"\"\" Retrieves the part number of the PSU Returns: string: Part number of PSU \"\"\" return self.eeprom.part_number_str() def get_status(self): \"\"\" Retrieves the operational status of the PSU Returns: bool: True if PSU is operating properly, False if not \"\"\" if smbus_present==0: cmdstatus, psustatus=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa') psustatus=int(psustatus, 16) sonic_logger.log_warning(\"PMON psu-smbus -presence=0 \") else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0xa psustatus=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) if self.index==1: psustatus=psustatus & 4 if psustatus==4: return True if self.index==2: psustatus=psustatus & 8 if psustatus==8: return True return False def get_voltage(self): \"\"\" Retrieves current PSU voltage output Returns: A float number, the output voltage in volts, e.g. 12.1 \"\"\" if smbus_present==0: cmdstatus, psustatus=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa') psustatus=int(psustatus, 16) else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0xa psustatus=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) if self.index==1: psustatus=psustatus & 4 if psustatus==4: psu_voltage=12.0 return psu_voltage if self.index==2: psustatus=psustatus & 8 if psustatus==8: psu_voltage=12.0 return psu_voltage psu_voltage=0.0 return psu_voltage def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device Returns: integer: The 1-based relative physical position in parent device \"\"\" return self.index def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return True def get_powergood_status(self): \"\"\" Retrieves the powergood status of PSU Returns: A boolean, True if PSU has stablized its output voltages and passed all its internal self-tests, False if not. \"\"\" if smbus_present==0: cmdstatus, psustatus=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa') psustatus=int(psustatus, 16) else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0xa psustatus=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) if self.index==1: psustatus=psustatus & 4 if psustatus==4: return True if self.index==2: psustatus=psustatus & 8 if psustatus==8: return True return False def get_status_led(self): \"\"\" Gets the state of the PSU status LED Returns: A string, one of the predefined STATUS_LED_COLOR_* strings. \"\"\" if self.get_powergood_status(): return self.STATUS_LED_COLOR_GREEN else: return self.STATUS_LED_COLOR_OFF def set_status_led(self, color): \"\"\" Sets the state of the PSU status LED Args: color: A string representing the color with which to set the PSU status LED Returns: bool: True if status LED state is set successfully, False if not \"\"\" return False def get_status_master_led(self): \"\"\" Gets the state of the front panel PSU status LED Returns: A string, one of the predefined STATUS_LED_COLOR_* strings. \"\"\" if(not os.path.isfile(\"/sys/class/gpio/psuLedGreen/value\") or not os.path.isfile(\"/sys/class/gpio/psuLedAmber/value\")): return None green=self._read_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\") amber=self._read_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\") if green==\"ERR\" or amber==\"ERR\": return None if green==\"1\": return self.STATUS_LED_COLOR_GREEN elif amber==\"1\": return self.STATUS_LED_COLOR_AMBER else: return None def set_status_master_led(self, color): \"\"\" Sets the state of the front panel PSU status LED Returns: bool: True if status LED state is set successfully, False if not \"\"\" if(not os.path.isfile(\"/sys/class/gpio/psuLedGreen/value\") or not os.path.isfile(\"/sys/class/gpio/psuLedAmber/value\")): return False if color==self.STATUS_LED_COLOR_GREEN: rvg=self._write_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\", 1) if rvg !=\"ERR\": rva=self._write_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\", 0) elif color==self.STATUS_LED_COLOR_AMBER: rvg=self._write_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\", 0) if rvg !=\"ERR\": rva=self._write_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\", 1) else: return False if rvg==\"ERR\" or rva==\"ERR\": return False return True ", "sourceWithComments": "########################################################################\n# Nokia IXS7215\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the PSUs' information which are available in the platform\n#\n########################################################################\n\ntry:\n    import os\n    import sys\n    from sonic_platform_base.psu_base import PsuBase\n    from sonic_py_common import logger\n    from sonic_platform.eeprom import Eeprom\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nif sys.version_info[0] < 3:\n    import commands as cmd\nelse:\n    import subprocess as cmd\n\nsmbus_present = 1\ntry:\n    import smbus\nexcept ImportError as e:\n    smbus_present = 0\n\nsonic_logger = logger.Logger('psu')\n\nclass Psu(PsuBase):\n    \"\"\"Nokia platform-specific PSU class for 7215 \"\"\"\n\n    def __init__(self, psu_index):\n        PsuBase.__init__(self)\n        # PSU is 1-based in Nokia platforms\n        self.index = psu_index + 1\n        self._fan_list = []\n\n        # PSU eeprom\n        self.eeprom = Eeprom(is_psu=True, psu_index=self.index)\n\n    def _write_sysfs_file(self, sysfs_file, value):\n        rv = 'ERR'\n\n        if (not os.path.isfile(sysfs_file)):\n            return rv\n        try:\n            with open(sysfs_file, 'w') as fd:\n                rv = fd.write(str(value))\n        except Exception as e:\n            rv = 'ERR'\n\n        return rv\n\n    def _read_sysfs_file(self, sysfs_file):\n        rv = 'ERR'\n\n        if (not os.path.isfile(sysfs_file)):\n            return rv\n        try:\n            with open(sysfs_file, 'r') as fd:\n                rv = fd.read()\n        except Exception as e:\n            rv = 'ERR'\n\n        rv = rv.rstrip('\\r\\n')\n        rv = rv.lstrip(\" \")\n        return rv\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n\n        Returns:\n            string: The name of the device\n        \"\"\"\n        return \"PSU{}\".format(self.index)\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Power Supply Unit (PSU)\n\n        Returns:\n            bool: True if PSU is present, False if not\n        \"\"\"\n\n        if smbus_present == 0:  # if called from psuutil outside of pmon\n            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n            psustatus = int(psustatus, 16)\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0xa\n            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n        if self.index == 1:\n            psustatus = psustatus & 1\n            if psustatus == 1:\n                return False\n        if self.index == 2:\n            psustatus = psustatus & 2\n            if psustatus == 2:\n                return False\n\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the part number of the PSU\n\n        Returns:\n            string: Part number of PSU\n        \"\"\"\n        return self.eeprom.modelstr()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the PSU\n\n        Returns:\n            string: Serial number of PSU\n        \"\"\"\n        return self.eeprom.serial_number_str()\n\n    def get_revision(self):\n        \"\"\"\n        Retrieves the HW revision of the PSU\n\n        Returns:\n            string: HW revision of PSU\n        \"\"\"\n        return self.eeprom.part_number_str()\n\n    def get_part_number(self):\n        \"\"\"\n        Retrieves the part number of the PSU\n\n        Returns:\n            string: Part number of PSU\n        \"\"\"\n        return self.eeprom.part_number_str()\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the PSU\n\n        Returns:\n            bool: True if PSU is operating properly, False if not\n        \"\"\"\n\n        if smbus_present == 0:\n            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n            psustatus = int(psustatus, 16)\n            sonic_logger.log_warning(\"PMON psu-smbus - presence = 0 \")\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0xa\n            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n        if self.index == 1:\n            psustatus = psustatus & 4\n            if psustatus == 4:\n                return True\n        if self.index == 2:\n            psustatus = psustatus & 8\n            if psustatus == 8:\n                return True\n\n        return False\n\n    def get_voltage(self):\n        \"\"\"\n        Retrieves current PSU voltage output\n\n        Returns:\n            A float number, the output voltage in volts,\n            e.g. 12.1\n        \"\"\"\n        if smbus_present == 0:\n            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n            psustatus = int(psustatus, 16)\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0xa\n            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n        if self.index == 1:\n            psustatus = psustatus & 4\n            if psustatus == 4:\n                psu_voltage = 12.0\n                return psu_voltage\n        if self.index == 2:\n            psustatus = psustatus & 8\n            if psustatus == 8:\n                psu_voltage = 12.0\n                return psu_voltage\n\n        psu_voltage = 0.0\n        return psu_voltage\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device\n        Returns:\n            integer: The 1-based relative physical position in parent device\n        \"\"\"\n        return self.index\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return True\n\n    def get_powergood_status(self):\n        \"\"\"\n        Retrieves the powergood status of PSU\n        Returns:\n            A boolean, True if PSU has stablized its output voltages and\n            passed all its internal self-tests, False if not.\n        \"\"\"\n\n        if smbus_present == 0:\n            cmdstatus, psustatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0xa')\n            psustatus = int(psustatus, 16)\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0xa\n            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n        if self.index == 1:\n            psustatus = psustatus & 4\n            if psustatus == 4:\n                return True\n        if self.index == 2:\n            psustatus = psustatus & 8\n            if psustatus == 8:\n                return True\n\n        return False\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the PSU status LED\n\n        Returns:\n            A string, one of the predefined STATUS_LED_COLOR_* strings.\n        \"\"\"\n        if self.get_powergood_status():\n            return self.STATUS_LED_COLOR_GREEN\n        else:\n            return self.STATUS_LED_COLOR_OFF\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the PSU status LED\n        Args:\n            color: A string representing the color with which to set the\n                   PSU status LED\n        Returns:\n            bool: True if status LED state is set successfully, False if\n                  not\n        \"\"\"\n        # The firmware running in the PSU controls the LED\n        # and the PSU LED state cannot be changed from CPU.\n        return False\n\n    def get_status_master_led(self):\n        \"\"\"\n        Gets the state of the front panel PSU status LED\n\n        Returns:\n            A string, one of the predefined STATUS_LED_COLOR_* strings.\n        \"\"\"\n        if (not os.path.isfile(\"/sys/class/gpio/psuLedGreen/value\") or\n            not os.path.isfile(\"/sys/class/gpio/psuLedAmber/value\")):\n            return None\n\n        green = self._read_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\")\n        amber = self._read_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\")\n        if green == \"ERR\" or amber == \"ERR\":\n            return None\n        if green == \"1\":\n            return self.STATUS_LED_COLOR_GREEN\n        elif amber == \"1\":\n            return self.STATUS_LED_COLOR_AMBER\n        else:\n            return None\n\n    def set_status_master_led(self, color):\n        \"\"\"\n        Sets the state of the front panel PSU status LED\n\n        Returns:\n            bool: True if status LED state is set successfully, False if\n                  not\n        \"\"\"\n        if (not os.path.isfile(\"/sys/class/gpio/psuLedGreen/value\") or\n            not os.path.isfile(\"/sys/class/gpio/psuLedAmber/value\")):\n            return False\n\n        if color == self.STATUS_LED_COLOR_GREEN:\n            rvg = self._write_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\", 1)\n            if rvg != \"ERR\":\n                rva = self._write_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\", 0)\n        elif color == self.STATUS_LED_COLOR_AMBER:\n            rvg = self._write_sysfs_file(\"/sys/class/gpio/psuLedGreen/value\", 0)\n            if rvg != \"ERR\":\n                rva = self._write_sysfs_file(\"/sys/class/gpio/psuLedAmber/value\", 1)\n        else:\n            return False\n\n        if rvg == \"ERR\" or rva == \"ERR\":\n            return False\n\n        return True\n"}, "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import os\n-import sys\n+import subprocess\n \n try:\n     from sonic_platform_base.sfp_base import SfpBase\n", "add": 1, "remove": 2, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["import sys"], "goodparts": ["import subprocess"]}, {"diff": "\n     from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper\n     from sonic_py_common import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n smbus_present = 1\n \n try:\n", "add": 1, "remove": 5, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["if sys.version_info[0] < 3:", "    import commands as cmd", "else:", "    import subprocess as cmd"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n     # Paths\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"armhf-nokia_ixs7215_52x-r0\"\n     HWSKU = \"Nokia-7215\"\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n             return 'N/A'\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}, {"diff": "\n             return False\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, register = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x5')\n+            cmdstatus, register = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x5'])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"sfp cmdstatus i2c get failed %s\" % register )\n                 return False\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["            cmdstatus, register = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x5')"], "goodparts": ["            cmdstatus, register = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x5'])"]}, {"diff": "\n \n         pos = [1, 2, 4, 8]\n         mask = pos[self.index-SFP_PORT_START]\n-        if tx_disable == True:\n+        if tx_disable is True:\n             setbits = register | mask\n         else:\n             setbits = register & ~mask\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, output = cmd.getstatusoutput('sudo i2cset -y -m 0x0f 0 0x41 0x5 %d' % setbits)\n+            cmdstatus, output = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '-m', '0x0f', '0', '0x41', '0x5', str(setbits)])\n             if cmdstatus:\n                 sonic_logger.log_warning(\"sfp cmdstatus i2c write failed %s\" % output )\n                 return False\n", "add": 2, "remove": 2, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["        if tx_disable == True:", "            cmdstatus, output = cmd.getstatusoutput('sudo i2cset -y -m 0x0f 0 0x41 0x5 %d' % setbits)"], "goodparts": ["        if tx_disable is True:", "            cmdstatus, output = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '-m', '0x0f', '0', '0x41', '0x5', str(setbits)])"]}, {"diff": "\n             return False\n \n         if smbus_present == 0:  # if called from sfputil outside of pmon\n-            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')\n+            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])\n             sfpstatus = int(sfpstatus, 16)\n         else:\n             bus = smbus.SMBu", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py", "badparts": ["            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')"], "goodparts": ["            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])"]}]}, "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py": {"changes": [{"diff": "\n '''\n listen for the SFP change event and return to chassis.\n '''\n-import sys\n import time\n from sonic_py_common import logger\n+from sonic_py_common.general import getstatusoutput_noshell\n \n smbus_present = 1\n \n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py", "badparts": ["import sys"], "goodparts": ["from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n     smbus_present = 0\n \n-if sys.version_info[0] < 3:\n-    import commands as cmd\n-else:\n-    import subprocess as cmd\n-\n # system level event/error\n EVENT_ON_ALL_SFP = '-1'\n SYSTEM_NOT_READY = 'system_not_ready'\n", "add": 0, "remove": 5, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py", "badparts": ["if sys.version_info[0] < 3:", "    import commands as cmd", "else:", "    import subprocess as cmd"], "goodparts": []}, {"diff": "\n     def _get_transceiver_status(self):\n         if smbus_present == 0:\n             sonic_logger.log_info(\"  PMON - smbus ERROR - DEBUG sfp_event   \")\n-            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')\n+            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])\n             sfpstatus = int(sfpstatus, 16)\n         else:\n             bus = smbus.SMBus(0)\n", "add": 1, "remove": 1, "filename": "/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py", "badparts": ["            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')"], "goodparts": ["            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])"]}], "source": "\n''' listen for the SFP change event and return to chassis. ''' import sys import time from sonic_py_common import logger smbus_present=1 try: import smbus except ImportError as e: smbus_present=0 if sys.version_info[0] < 3: import commands as cmd else: import subprocess as cmd EVENT_ON_ALL_SFP='-1' SYSTEM_NOT_READY='system_not_ready' SYSTEM_READY='system_become_ready' SYSTEM_FAIL='system_fail' SFP_PORT_START=49 SFP_PORT_END=52 SYSLOG_IDENTIFIER=\"sfp_event\" sonic_logger=logger.Logger(SYSLOG_IDENTIFIER) class sfp_event: ''' Listen to plugin/plugout cable events ''' def __init__(self): self.handle=None def initialize(self): self.modprs_register=0 time.sleep(5) self.modprs_register=self._get_transceiver_status() sonic_logger.log_info(\"Initial SFP presence=%d\" % self.modprs_register) def deinitialize(self): if self.handle is None: return def _get_transceiver_status(self): if smbus_present==0: sonic_logger.log_info(\" PMON -smbus ERROR -DEBUG sfp_event \") cmdstatus, sfpstatus=cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3') sfpstatus=int(sfpstatus, 16) else: bus=smbus.SMBus(0) DEVICE_ADDRESS=0x41 DEVICE_REG=0x3 sfpstatus=bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG) sfpstatus=~sfpstatus sfpstatus=sfpstatus & 0xF return sfpstatus def check_sfp_status(self, port_change, timeout): \"\"\" check_sfp_status called from get_change_event, this will return correct status of all 4 SFP ports if there is a change in any of them \"\"\" start_time=time.time() port=SFP_PORT_START forever=False if timeout==0: forever=True elif timeout > 0: timeout=timeout / float(1000) else: return False,{} end_time=start_time +timeout if(start_time > end_time): return False,{} while(timeout >=0): reg_value=self._get_transceiver_status() if(reg_value !=self.modprs_register): changed_ports=(self.modprs_register ^ reg_value) while(port >=SFP_PORT_START and port <=SFP_PORT_END): mask=(1 << port-SFP_PORT_START) if(changed_ports & mask): if reg_value & mask==0: port_change[port]='0' else: port_change[port]='1' port +=1 self.modprs_register=reg_value return True, port_change if forever: time.sleep(1) else: timeout=end_time -time.time() if timeout >=1: time.sleep(1) else: if timeout > 0: time.sleep(timeout) return True,{} return False,{} ", "sourceWithComments": "'''\nlisten for the SFP change event and return to chassis.\n'''\nimport sys\nimport time\nfrom sonic_py_common import logger\n\nsmbus_present = 1\n\ntry:\n    import smbus\nexcept ImportError as e:\n    smbus_present = 0\n\nif sys.version_info[0] < 3:\n    import commands as cmd\nelse:\n    import subprocess as cmd\n\n# system level event/error\nEVENT_ON_ALL_SFP = '-1'\nSYSTEM_NOT_READY = 'system_not_ready'\nSYSTEM_READY = 'system_become_ready'\nSYSTEM_FAIL = 'system_fail'\n\n# SFP PORT numbers\nSFP_PORT_START = 49\nSFP_PORT_END = 52\n\nSYSLOG_IDENTIFIER = \"sfp_event\"\nsonic_logger = logger.Logger(SYSLOG_IDENTIFIER)\n\n\nclass sfp_event:\n    ''' Listen to plugin/plugout cable events '''\n\n    def __init__(self):\n        self.handle = None\n\n    def initialize(self):\n        self.modprs_register = 0\n        # Get Transceiver status\n        time.sleep(5)\n        self.modprs_register = self._get_transceiver_status()\n        sonic_logger.log_info(\"Initial SFP presence=%d\" % self.modprs_register)\n\n    def deinitialize(self):\n        if self.handle is None:\n            return\n\n    def _get_transceiver_status(self):\n        if smbus_present == 0:\n            sonic_logger.log_info(\"  PMON - smbus ERROR - DEBUG sfp_event   \")\n            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')\n            sfpstatus = int(sfpstatus, 16)\n        else:\n            bus = smbus.SMBus(0)\n            DEVICE_ADDRESS = 0x41\n            DEVICE_REG = 0x3\n            sfpstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)\n\n            sfpstatus = ~sfpstatus\n            sfpstatus = sfpstatus & 0xF\n\n        return sfpstatus\n\n    def check_sfp_status(self, port_change, timeout):\n        \"\"\"\n        check_sfp_status called from get_change_event, this will return correct\n            status of all 4 SFP ports if there is a change in any of them\n        \"\"\"\n        start_time = time.time()\n        port = SFP_PORT_START\n        forever = False\n\n        if timeout == 0:\n            forever = True\n        elif timeout > 0:\n            timeout = timeout / float(1000)  # Convert to secs\n        else:\n            return False, {}\n        end_time = start_time + timeout\n\n        if (start_time > end_time):\n            return False, {}  # Time wrap or possibly incorrect timeout\n\n        while (timeout >= 0):\n            # Check for OIR events and return updated port_change\n            reg_value = self._get_transceiver_status()\n            if (reg_value != self.modprs_register):\n                changed_ports = (self.modprs_register ^ reg_value)\n                while (port >= SFP_PORT_START and port <= SFP_PORT_END):\n                    # Mask off the bit corresponding to our port\n                    mask = (1 << port-SFP_PORT_START)\n                    if (changed_ports & mask):\n                        # ModPrsL is active high\n                        if reg_value & mask == 0:\n                            port_change[port] = '0'\n                        else:\n                            port_change[port] = '1'\n                    port += 1\n\n                # Update reg value\n                self.modprs_register = reg_value\n                return True, port_change\n\n            if forever:\n                time.sleep(1)\n            else:\n                timeout = end_time - time.time()\n                if timeout >= 1:\n                    time.sleep(1)  # We poll at 1 second granularity\n                else:\n                    if timeout > 0:\n                        time.sleep(timeout)\n                    return True, {}\n        return False, {}\n"}}, "msg": "[nokia] Replace os.system and remove subprocess with shell=True (#12100)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\nDependency: [https://github.com/sonic-net/sonic-buildimage/pull/12065](https://github.com/sonic-net/sonic-buildimage/pull/12065)\r\n#### Why I did it\r\n`subprocess.Popen()` and `subprocess.run()` is used with `shell=True`, which is very dangerous for shell injection.\r\n`os` - not secure against maliciously constructed input and dangerous if used to evaluate dynamic content\r\n`getstatusoutput` is dangerous because it contains `shell=True` in the implementation\r\n#### How I did it\r\nReplace `os` by `subprocess`, use with `shell=False`\r\nRemove unused functions"}}}