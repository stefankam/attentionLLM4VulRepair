{"https://github.com/dsheffie/riscv-llvm": {"c981c533055e14302e7bff5d6898c9308065f665": {"url": "https://api.github.com/repos/dsheffie/riscv-llvm/commits/c981c533055e14302e7bff5d6898c9308065f665", "html_url": "https://github.com/dsheffie/riscv-llvm/commit/c981c533055e14302e7bff5d6898c9308065f665", "sha": "c981c533055e14302e7bff5d6898c9308065f665", "keyword": "execution after redirect correct", "diff": "diff --git a/libcxx/utils/libcxx/test/dsl.py b/libcxx/utils/libcxx/test/dsl.py\nindex 847cebf5962f..4c2217ec3142 100644\n--- a/libcxx/utils/libcxx/test/dsl.py\n+++ b/libcxx/utils/libcxx/test/dsl.py\n@@ -180,7 +180,7 @@ def programOutput(config, program, args=None):\n                 \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n             )\n \n-        return libcxx.test.format._parseLitOutput(out)\n+        return out\n \n \n @_memoizeExpensiveOperation(\ndiff --git a/libcxx/utils/libcxx/test/format.py b/libcxx/utils/libcxx/test/format.py\nindex ddd88f25646e..2be42d293280 100644\n--- a/libcxx/utils/libcxx/test/format.py\n+++ b/libcxx/utils/libcxx/test/format.py\n@@ -35,39 +35,6 @@ def _checkBaseSubstitutions(substitutions):\n     for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n         assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n \n-def _parseLitOutput(fullOutput):\n-    \"\"\"\n-    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n-\n-    This takes output of the form\n-\n-        $ \":\" \"RUN: at line 11\"\n-        $ \"echo\" \"OUTPUT1\"\n-        # command output:\n-        OUTPUT1\n-\n-        $ \":\" \"RUN: at line 12\"\n-        $ \"echo\" \"OUTPUT2\"\n-        # command output:\n-        OUTPUT2\n-\n-    and returns a string containing\n-\n-        OUTPUT1\n-        OUTPUT2\n-\n-    as-if the commands had been run directly. This is a workaround for the fact\n-    that Lit doesn't let us execute ShTest and retrieve the raw output without\n-    injecting additional Lit output around it.\n-    \"\"\"\n-    parsed = ''\n-    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n-        if output: # skip blank lines\n-            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n-            if commandOutput:\n-                parsed += commandOutput.group(1)\n-    return parsed\n-\n def _executeScriptInternal(test, litConfig, commands):\n     \"\"\"\n     Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n@@ -79,21 +46,12 @@ def _executeScriptInternal(test, litConfig, commands):\n     _, tmpBase = _getTempPaths(test)\n     execDir = os.path.dirname(test.getExecPath())\n     res = lit.TestRunner.executeScriptInternal(\n-        test, litConfig, tmpBase, parsedCommands, execDir\n+        test, litConfig, tmpBase, parsedCommands, execDir, debug=False\n     )\n     if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n         res = (\"\", res.output, 127, None)\n     (out, err, exitCode, timeoutInfo) = res\n \n-    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n-    #       split any stderr output that is included in stdout. It shouldn't be there, but\n-    #       the Lit internal shell conflates stderr and stdout.\n-    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n-    if conflatedErrorOutput:\n-        conflatedErrorOutput = conflatedErrorOutput.group(0)\n-        out = out[: -len(conflatedErrorOutput)]\n-        err += conflatedErrorOutput\n-\n     return (out, err, exitCode, timeoutInfo, parsedCommands)\n \n \n@@ -400,8 +358,7 @@ def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig):\n             raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n \n         # Split the generated output into multiple files and generate one test for each file\n-        parsed = _parseLitOutput(out)\n-        for (subfile, content) in self._splitFile(parsed):\n+        for (subfile, content) in self._splitFile(out):\n             generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n             os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n             with open(generatedFile, 'w') as f:\ndiff --git a/llvm/utils/lit/lit/TestRunner.py b/llvm/utils/lit/lit/TestRunner.py\nindex 0629eca42049..461cf63d6b96 100644\n--- a/llvm/utils/lit/lit/TestRunner.py\n+++ b/llvm/utils/lit/lit/TestRunner.py\n@@ -8,6 +8,7 @@\n import stat\n import pathlib\n import platform\n+import shlex\n import shutil\n import tempfile\n import threading\n@@ -57,6 +58,14 @@ def __init__(self, command, message):\n kPdbgRegex = \"%dbg\\\\(([^)'\\\"]*)\\\\)(.*)\"\n \n \n+def buildPdbgCommand(msg, cmd):\n+    res = f\"%dbg({msg}) {cmd}\"\n+    assert re.match(\n+        kPdbgRegex, res\n+    ), f\"kPdbgRegex expected to match actual %dbg usage: {res}\"\n+    return res\n+\n+\n class ShellEnvironment(object):\n \n     \"\"\"Mutable shell environment containing things like CWD and env vars.\n@@ -340,12 +349,12 @@ def executeBuiltinExport(cmd, shenv):\n \n \n def executeBuiltinEcho(cmd, shenv):\n-    \"\"\"Interpret a redirected echo command\"\"\"\n+    \"\"\"Interpret a redirected echo or @echo command\"\"\"\n     opened_files = []\n     stdin, stdout, stderr = processRedirects(cmd, subprocess.PIPE, shenv, opened_files)\n     if stdin != subprocess.PIPE or stderr != subprocess.PIPE:\n         raise InternalShellError(\n-            cmd, \"stdin and stderr redirects not supported for echo\"\n+            cmd, f\"stdin and stderr redirects not supported for {cmd.args[0]}\"\n         )\n \n     # Some tests have un-redirected echo commands to help debug test failures.\n@@ -692,6 +701,7 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n         \"cd\": executeBuiltinCd,\n         \"export\": executeBuiltinExport,\n         \"echo\": executeBuiltinEcho,\n+        \"@echo\": executeBuiltinEcho,\n         \"mkdir\": executeBuiltinMkdir,\n         \"popd\": executeBuiltinPopd,\n         \"pushd\": executeBuiltinPushd,\n@@ -919,7 +929,7 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n         if res == -signal.SIGINT:\n             raise KeyboardInterrupt\n         if proc_not_counts[i] % 2:\n-            res = not res\n+            res = 1 if res == 0 else 0\n         elif proc_not_counts[i] > 1:\n             res = 1 if res != 0 else 0\n \n@@ -982,19 +992,58 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n     return exitCode\n \n \n-def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n+def formatOutput(title, data, limit=None):\n+    if not data.strip():\n+        return \"\"\n+    if not limit is None and len(data) > limit:\n+        data = data[:limit] + \"\\n...\\n\"\n+        msg = \"data was truncated\"\n+    else:\n+        msg = \"\"\n+    ndashes = 30\n+    out =  f\"# .---{title}{'-' * (ndashes - 4 - len(title))}\\n\"\n+    out += f\"# | \" + \"\\n# | \".join(data.splitlines()) + \"\\n\"\n+    out += f\"# `---{msg}{'-' * (ndashes - 4 - len(msg))}\\n\"\n+    return out\n+\n+# Normally returns out, err, exitCode, timeoutInfo.\n+#\n+# If debug is True (the normal lit behavior), err is empty, and out contains an\n+# execution trace, including stdout and stderr shown per command executed.\n+#\n+# If debug is False (set by some custom lit test formats that call this\n+# function), out contains only stdout from the script, err contains only stderr\n+# from the script, and there is no execution trace.\n+def executeScriptInternal(test, litConfig, tmpBase, commands, cwd,\n+                          debug=True):\n     cmds = []\n     for i, ln in enumerate(commands):\n+        # Within lit, we try to always add '%dbg(...)' to command lines in order\n+        # to maximize debuggability.  However, custom lit test formats might not\n+        # always add it, so add a generic debug message in that case.\n         match = re.match(kPdbgRegex, ln)\n         if match:\n+            dbg = match.group(1)\n             command = match.group(2)\n-            ln = commands[i] = match.expand(\": '\\\\1'; \\\\2\" if command else \": '\\\\1'\")\n+        else:\n+            dbg = \"command line\"\n+            command = ln\n+        if debug:\n+            ln = f\"@echo '# {dbg}' \"\n+            if command:\n+                ln += f\"&& @echo {shlex.quote(command.lstrip())} && {command}\"\n+            else:\n+                ln += \"has no command after substitutions\"\n+        else:\n+            ln = command\n         try:\n             cmds.append(\n                 ShUtil.ShParser(ln, litConfig.isWindows, test.config.pipefail).parse()\n             )\n         except:\n-            return lit.Test.Result(Test.FAIL, \"shell parser error on: %r\" % ln)\n+            return lit.Test.Result(\n+                Test.FAIL, f\"shell parser error on {dbg}: {command.lstrip()}\\n\"\n+            )\n \n     cmd = cmds[0]\n     for c in cmds[1:]:\n@@ -1014,8 +1063,42 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n \n     out = err = \"\"\n     for i, result in enumerate(results):\n-        # Write the command line run.\n-        out += \"$ %s\\n\" % (\" \".join('\"%s\"' % s for s in result.command.args),)\n+        if not debug:\n+            out += result.stdout\n+            err += result.stderr\n+            continue\n+\n+        # The purpose of an \"@echo\" command is merely to add a debugging message\n+        # directly to lit's output.  It is used internally by lit's internal\n+        # shell and is not currently documented for use in lit tests.  However,\n+        # if someone misuses it (e.g., both \"echo\" and \"@echo\" complain about\n+        # stdin redirection), produce the normal execution trace to facilitate\n+        # debugging.\n+        if (\n+            result.command.args[0] == \"@echo\"\n+            and result.exitCode == 0\n+            and not result.stderr\n+            and not result.outputFiles\n+            and not result.timeoutReached\n+        ):\n+            out += result.stdout\n+            continue\n+\n+        # Write the command line that was run.  Properly quote it.  Leading\n+        # \"!\" commands should not be quoted as that would indicate they are not\n+        # the builtins.\n+        out += \"# executed command: \"\n+        nLeadingBangs = next(\n+            (i for i, cmd in enumerate(result.command.args) if cmd != \"!\"),\n+            len(result.command.args),\n+        )\n+        out += \"! \" * nLeadingBangs\n+        out += \" \".join(\n+            shlex.quote(str(s))\n+            for i, s in enumerate(result.command.args)\n+            if i >= nLeadingBangs\n+        )\n+        out += \"\\n\"\n \n         # If nothing interesting happened, move on.\n         if (\n@@ -1030,22 +1113,16 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n \n         # Add the command output, if redirected.\n         for (name, path, data) in result.outputFiles:\n-            if data.strip():\n-                out += \"# redirected output from %r:\\n\" % (name,)\n-                data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n-                if len(data) > 1024:\n-                    out += data[:1024] + \"\\n...\\n\"\n-                    out += \"note: data was truncated\\n\"\n-                else:\n-                    out += data\n-                out += \"\\n\"\n-\n+            data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n+            out += formatOutput(\n+                f\"redirected output from '{name}'\", data, limit=1024\n+            )\n         if result.stdout.strip():\n-            out += \"# command output:\\n%s\\n\" % (result.stdout,)\n+            out += formatOutput(\"command stdout\", result.stdout)\n         if result.stderr.strip():\n-            out += \"# command stderr:\\n%s\\n\" % (result.stderr,)\n+            out += formatOutput(\"command stderr\", result.stderr)\n         if not result.stdout.strip() and not result.stderr.strip():\n-            out += \"note: command had no output on stdout or stderr\\n\"\n+            out += \"# note: command had no output on stdout or stderr\\n\"\n \n         # Show the error conditions:\n         if result.exitCode != 0:\n@@ -1055,9 +1132,9 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n                 codeStr = hex(int(result.exitCode & 0xFFFFFFFF)).rstrip(\"L\")\n             else:\n                 codeStr = str(result.exitCode)\n-            out += \"error: command failed with exit status: %s\\n\" % (codeStr,)\n+            out += \"# error: command failed with exit status: %s\\n\" % (codeStr,)\n         if litConfig.maxIndividualTestTime > 0 and result.timeoutReached:\n-            out += \"error: command reached timeout: %s\\n\" % (\n+            out += \"# error: command reached timeout: %s\\n\" % (\n                 str(result.timeoutReached),\n             )\n \n@@ -1833,13 +1910,7 @@ def _handleCommand(cls, line_number, line, output, keyword):\n         if not output or not output[-1].add_continuation(line_number, keyword, line):\n             if output is None:\n                 output = []\n-            pdbg = \"%dbg({keyword} at line {line_number})\".format(\n-                keyword=keyword, line_number=line_number\n-            )\n-            assert re.match(\n-                kPdbgRegex + \"$\", pdbg\n-            ), \"kPdbgRegex expected to match actual %dbg usage\"\n-            line = \"{pdbg} {real_command}\".format(pdbg=pdbg, real_command=line)\n+            line = buildPdbgCommand(f\"{keyword} at line {line_number}\", line)\n             output.append(CommandDirective(line_number, line_number, keyword, line))\n         return output\n \n@@ -2104,6 +2175,8 @@ def executeShTest(\n         return lit.Test.Result(Test.UNSUPPORTED, \"Test is unsupported\")\n \n     script = list(preamble_commands)\n+    script = [buildPdbgCommand(f\"preamble command line\", ln) for ln in script]\n+\n     parsed = parseIntegratedTestScript(test, require_script=not script)\n     if isinstance(parsed, lit.Test.Result):\n         return parsed\ndiff --git a/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg b/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\nindex cf1a4f1ba1ec..301208c25bdc 100644\n--- a/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\n+++ b/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\n@@ -5,4 +5,4 @@ config.suffixes = [\".txt\"]\n config.test_format = lit.formats.ShTest()\n config.test_source_root = None\n config.test_exec_root = None\n-config.substitutions.append((\"%var\", lit_config.params.get(\"var\", \"\")))\n+config.substitutions.append((\"%var\", lit_config.params.get(\"var\", \"default\")))\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt b/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\nindex 6dd9b16304e0..1d94c1213723 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\n@@ -14,21 +14,21 @@\n ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0 -fopenmp-simd\n ; REDEFINE: %{fcflags} = -check-prefix=SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu -fopenmp-simd\n ; REDEFINE: %{fcflags} = -check-prefix=SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0\n ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu\n ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n \n ; CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt b/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\nindex 3bf057151afb..23c0a6d50753 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\n@@ -7,7 +7,7 @@\n #\n # REDEFINE: %{global:greeting}=Hello\n # RUN: %{global:echo}\n-# CHECK: GLOBAL: Hello World\n+# CHECK:# | GLOBAL: Hello World\n \n # We can redefine the test suite config's substitutions multiple times.  Again,\n # the expansion order remains the same (%{global:echo} before %{global:greeting}\n@@ -17,7 +17,7 @@\n # REDEFINE: %{global:greeting}=Goodbye %{global:what}\n # REDEFINE: %{global:what}=Sleep\n # RUN: %{global:echo}\n-# CHECK: GLOBAL: Goodbye Sleep Sleep\n+# CHECK:# | GLOBAL: Goodbye Sleep Sleep\n \n # A new local substitution is prepended to the substitution list so that it can\n # depend on all substitutions that were defined previously, including those from\n@@ -26,7 +26,7 @@\n # DEFINE: %{local:greeting}=Hey %{global:what}\n # DEFINE: %{local:echo}=echo \"LOCAL: %{local:greeting} %{global:what}\"\n # RUN: %{local:echo}\n-# CHECK: LOCAL: Hey Sleep Sleep\n+# CHECK:# | LOCAL: Hey Sleep Sleep\n \n # As for substitutions from the test suite config, redefining local\n # substitutions should not change the expansion order.  Again, the expansion\n@@ -36,6 +36,6 @@\n # REDEFINE: %{local:greeting}=So Long %{global:what}\n # REDEFINE: %{global:what}=World\n # RUN: %{local:echo}\n-# CHECK: LOCAL: So Long World World\n+# CHECK:# | LOCAL: So Long World World\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt b/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\nindex 65f90792ff7b..5a1d7f2e1987 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\n@@ -1,19 +1,19 @@\n # Does it work as expected directly in RUN lines?\n # RUN: echo %(line), %(line-1), %(line+2)\n-# CHECK: [[#@LINE-1]], [[#@LINE-2]], [[#@LINE+1]]\n+# CHECK:# | [[#@LINE-1]], [[#@LINE-2]], [[#@LINE+1]]\n \n # %(line) substitutions refer to the original DEFINE/REDEFINE line not the RUN\n # line they eventually appear within.\n #\n # DEFINE: %{lines} = %(line)\n # RUN: echo '%{lines}'\n-# CHECK: [[#@LINE-2]]\n+# CHECK:# | [[#@LINE-2]]\n #\n # REDEFINE: %{lines} = %(line),                                                \\\n # REDEFINE:            %(line),                                                \\\n # REDEFINE:            %(line)\n # RUN: echo '%{lines}'\n-# CHECK: [[#@LINE-4]], [[#@LINE-3]], [[#@LINE-2]]\n+# CHECK:# | [[#@LINE-4]], [[#@LINE-3]], [[#@LINE-2]]\n \n # %(line+N) and %{line-N) should work too.\n #\n@@ -21,12 +21,12 @@\n # DEFINE:                %(line),                                              \\\n # DEFINE:                %(line-1)\n # RUN: echo '%{lines-rel}'\n-# CHECK: [[#@LINE-3]], [[#@LINE-3]], [[#@LINE-3]]\n+# CHECK:# | [[#@LINE-3]], [[#@LINE-3]], [[#@LINE-3]]\n #\n # REDEFINE: %{lines-rel} = %(line+5),                                          \\\n # REDEFINE:                %(line+0),                                          \\\n # REDEFINE:                %(line-10)\n # RUN: echo '%{lines-rel}'\n-# CHECK: [[#@LINE+1]], [[#@LINE-3]], [[#@LINE-12]]\n+# CHECK:# | [[#@LINE+1]], [[#@LINE-3]], [[#@LINE-12]]\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt b/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\nindex 18a27cdd72fa..d27fda2e2fe6 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\n@@ -1,25 +1,25 @@\n # DEFINE: %{abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789} = ok\n # RUN: echo '%{abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789}'\n-# CHECK: ok\n+# CHECK:# | ok\n \n # DEFINE: %{FooBar} = ok at %(line)\n # RUN: echo '%{FooBar}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{fooBar} = ok at %(line)\n # RUN: echo '%{fooBar}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{foo-bar-} = ok at %(line)\n # RUN: echo '%{foo-bar-}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{foo:bar:} = ok at %(line)\n # RUN: echo '%{foo:bar:}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{_foo_bar_} = ok at %(line)\n # RUN: echo '%{_foo_bar_}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt b/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\nindex eb5f0b918fd1..e504b822ace8 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\n@@ -6,7 +6,7 @@\n \n # RUN: echo '%{outer}'\n \n-# CHECK-NON-RECUR:%{inner}\n-# CHECK-RECUR:expanded\n+# CHECK-NON-RECUR:# | %{inner}\n+# CHECK-RECUR:# | expanded\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt b/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\nindex 9d2e7197fb3a..c1bdfef30b1a 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\n@@ -2,21 +2,21 @@\n \n # DEFINE: %{equals} = FileCheck -check-prefixes=FOO,BAR\n # RUN: echo '%{equals}'\n-# CHECK: FileCheck -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -check-prefixes=FOO,BAR\n #\n # REDEFINE: %{equals} == == =\n # RUN: echo '%{equals}'\n-# CHECK: = == =\n+# CHECK:# | = == =\n \n # DEFINE: %{continue-equals} = FileCheck -strict-whitespace -match-full-lines \\\n # DEFINE:                      -check-prefixes=FOO,BAR\n # RUN: echo '%{continue-equals}'\n-# CHECK: FileCheck -strict-whitespace -match-full-lines -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -strict-whitespace -match-full-lines -check-prefixes=FOO,BAR\n #\n # REDEFINE: %{continue-equals} = FileCheck -input-file=test.txt                \\\n # REDEFINE:                      -implicit-check-not=foobar                    \\\n # REDEFINE:                      -check-prefixes=FOO,BAR\n # RUN: echo '%{continue-equals}'\n-# CHECK: FileCheck -input-file=test.txt -implicit-check-not=foobar -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -input-file=test.txt -implicit-check-not=foobar -check-prefixes=FOO,BAR\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt b/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\nindex 58d5c1a34ce8..9143796edd32 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\n@@ -6,11 +6,11 @@\n \n # DEFINE: %{escape} = \\g<0>\\n\n # RUN: echo '%{escape}'\n-# CHECK: {{\\\\?}}\\g<0>{{\\\\?}}\\n\n+# CHECK:# | {{\\\\?}}\\g<0>{{\\\\?}}\\n\n \n # REDEFINE: %{escape} = \\n                                                     \\\n # REDEFINE:             \\g<param>\n # RUN: echo '%{escape}'\n-# CHECK: {{\\\\?}}\\n {{\\\\?}}\\g<param>\n+# CHECK:# | {{\\\\?}}\\n {{\\\\?}}\\g<param>\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt b/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\nindex 1259e511ba70..3e4db1b15d92 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\n@@ -3,33 +3,33 @@\n #\n # DEFINE: %{empty}=\n # RUN: echo \"'%{empty}'\"\n-# CHECK:''\n+# CHECK:# | ''\n #\n # REDEFINE: %{empty}=\n # RUN: echo \"'%{empty}'\"\n-# CHECK:''\n+# CHECK:# | ''\n \n # A value consisting only of whitespace is trimmed to the empty string.\n #\n #               v~~ intentional whitespace\n # DEFINE: %{ws}=   \n # RUN: echo \"'%{ws}'\"\n-# CHECK:''\n+# CHECK:# | ''\n #\n #                 v intentional whitespace\n # REDEFINE: %{ws}= \n # RUN: echo \"'%{ws}'\"\n-# CHECK:''\n+# CHECK:# | ''\n \n # Whitespace is not required around the name or value.\n #\n # DEFINE:%{no-whitespace}=abc\n # RUN: echo \"'%{no-whitespace}'\"\n-# CHECK:'abc'\n+# CHECK:# | 'abc'\n #\n # REDEFINE:%{no-whitespace}=HelloWorld\n # RUN: echo \"'%{no-whitespace}'\"\n-# CHECK:'HelloWorld'\n+# CHECK:# | 'HelloWorld'\n \n # Whitespace is not required between substitutions in a value.\n #\n@@ -37,11 +37,11 @@\n # DEFINE: %{adjacent1} = bar\n # DEFINE: %{has-adjacent-substs} = %{adjacent0}%{adjacent1}\n # RUN: echo \"'%{has-adjacent-substs}'\"\n-# CHECK:'foobar'\n+# CHECK:# | 'foobar'\n #\n # REDEFINE: %{has-adjacent-substs} = %{adjacent0}%{adjacent1}%{adjacent0}\n # RUN: echo \"'%{has-adjacent-substs}'\"\n-# CHECK:'foobarfoo'\n+# CHECK:# | 'foobarfoo'\n \n # Exact whitespace is preserved within the value, but whitespace enclosing the\n # name or value is discarded.  ('%{' and '}' are part of the name, and\n@@ -50,11 +50,11 @@\n #                                       v~~ intentional whitespace\n # DEFINE:   %{whitespace}  =  abc    def   \n # RUN: echo \"'%{whitespace}'\"\n-# CHECK:'abc    def'\n+# CHECK:# | 'abc    def'\n #                                      v intentional whitespace\n # REDEFINE: %{whitespace} = Hello World \n # RUN: echo \"'%{whitespace}'\"\n-# CHECK:'Hello World'\n+# CHECK:# | 'Hello World'\n \n # Line continuations in the value are permitted and collapse whitespace.\n #\n@@ -66,12 +66,12 @@\n # DEFINE:  pqr \n #             ^ intentional whitespace\n # RUN: echo \"'%{continue}'\"\n-# CHECK:'abc def ghi jkl mno pqr'\n+# CHECK:# | 'abc def ghi jkl mno pqr'\n #\n # REDEFINE: %{continue} =  abc  \\\n # REDEFINE: def\n # RUN: echo \"'%{continue}'\"\n-# CHECK:'abc def'\n+# CHECK:# | 'abc def'\n \n # Whitespace at the end of the line after a '\\' is ignored, and it's treated as\n # a line continuation.  Otherwise, the behavior would be hard to understand\n@@ -83,7 +83,7 @@\n #                                   ^ intentional whitespace\n # DEFINE: baz\n # RUN: echo \"'%{ws-after-continue}'\"\n-# CHECK:'foo bar baz'\n+# CHECK:# | 'foo bar baz'\n #\n #                                     v intentional whitespace\n # REDEFINE: %{ws-after-continue}=foo \\ \n@@ -91,7 +91,7 @@\n #                                     ^~~~~~~~~~~~ intentional whitespace\n # REDEFINE: baz\n # RUN: echo \"'%{ws-after-continue}'\"\n-# CHECK:'foo bar baz'\n+# CHECK:# | 'foo bar baz'\n \n # A line continuation is recognized anywhere.  It should be used only where\n # whitespace is permitted because it reduces to a single space.\n@@ -107,7 +107,7 @@\n # DEFINE:\\\n # DEFINE:a\n # RUN: echo \"'%{blank-lines}'\"\n-# CHECK:'a'\n+# CHECK:# | 'a'\n #\n # REDEFINE:                  \\\n # REDEFINE: %{blank-lines}   \\\n@@ -120,7 +120,7 @@\n # REDEFINE:                  \\\n # REDEFINE:      c\n # RUN: echo \"'%{blank-lines}'\"\n-# CHECK:'a b c'\n+# CHECK:# | 'a b c'\n \n # The fourth DEFINE line is deceptive because it looks like a new substitution,\n # but it's actually a continuation of the previous value.\n@@ -130,6 +130,6 @@\n # DEFINE: %{deceptive-continue}=echo \\\n # DEFINE: %{name}=%{value}\n # RUN: %{deceptive-continue}\n-# CHECK:x=3\n+# CHECK:# | x=3\n \n # CHECK:{{ *}}Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt b/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\nindex b0a7cfd97941..b5fc1b49fcc5 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\n@@ -1,46 +1,34 @@\n-#       CHECK: -- Testing:{{.*}}\n-#  CHECK-NEXT: PASS: shtest-if-else :: test.txt (1 of 1)\n-#  CHECK-NEXT: Exit Code: 0\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: Command Output (stdout):\n-#  CHECK-NEXT: --\n+# CHECK: -- Testing:{{.*}}\n+# CHECK-NEXT: PASS: shtest-if-else :: test.txt (1 of 1)\n+#      CHECK: Command Output (stdout):\n+# CHECK-NEXT: --\n \n # RUN: %if feature %{ echo \"test-1\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-1\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-1\"\n \n # If %else is not present it is treated like %else %{%}. Empty commands\n # are ignored.\n #\n # RUN: %if nofeature %{ echo \"fail\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#   CHECK-NOT: fail\n+#     CHECK: # {{RUN}}: at line [[#@LINE-1]] has no command after substitutions\n+# CHECK-NOT: fail\n \n # RUN: %if nofeature %{ echo \"fail\" %} %else %{ echo \"test-2\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-2\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-2\"\n \n # Spaces inside curly braces are not ignored\n #\n # RUN: echo test-%if feature %{ 3 %} %else %{ fail %}-test\n # RUN: echo test-%if feature %{ 4 4 %} %else %{ fail %}-test\n # RUN: echo test-%if nofeature %{ fail %} %else %{ 5 5 %}-test\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 3 -test\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 4 4 -test\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 5 5 -test\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo test- 3 -test\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo test- 4 4 -test\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo test- 5 5 -test\n \n # Escape line breaks for multi-line expressions\n #\n@@ -48,42 +36,32 @@\n # RUN:   %{ echo     \\\n # RUN:     \"test-5\" \\\n # RUN:   %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-4]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-5\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-5\"\n \n # RUN: %if nofeature       \\\n # RUN:   %{ echo \"fail\" %}   \\\n # RUN: %else               \\\n # RUN:   %{ echo \"test-6\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-4]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-6\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-6\"\n \n # RUN: echo \"test%if feature %{%} %else %{%}-7\"\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-7\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-7\"\n \n # Escape %if. Without %if..%else context '%{' and '%}' are treated\n # literally.\n #\n # RUN: echo %%if feature %{ echo \"test-8\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: %if feature %{ echo test-8 %}\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo %if feature %{ echo \"test-8\" %}\n \n # Nested expressions are supported:\n #\n # RUN: echo %if feature %{ %if feature %{ %if nofeature %{\"fail\"%} %else %{\"test-9\"%} %} %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-9\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-9\"\n \n # Binary expression evaluation and regex match can be used as\n # conditions.\n@@ -91,18 +69,12 @@\n # RUN: echo %if feature && !nofeature %{ \"test-10\" %}\n # RUN: echo %if feature && nofeature %{ \"fail\" %} %else %{ \"test-11\" %}\n # RUN: echo %if {{fea.+}} %{ \"test-12\" %} %else %{ \"fail\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-10\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-11\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-12\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo \"test-10\"\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-11\"\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo \"test-12\"\n \n # Spaces between %if and %else are ignored. If there is no %else -\n # space after %if %{...%} is not ignored.\n@@ -110,39 +82,27 @@\n # RUN: echo XX %if feature %{YY%} ZZ\n # RUN: echo AA %if feature %{BB%} %else %{CC%} DD\n # RUN: echo AA %if nofeature %{BB%} %else %{CC%} DD\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: XX YY ZZ\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: AA BB DD\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: AA CC DD\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo XX YY ZZ\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo AA BB DD\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo AA CC DD\n \n # '{' and '}' can be used without escaping\n #\n # RUN: %if feature %{echo {}%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: {}\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo {}\n \n # Spaces are not required\n #\n # RUN: echo %if feature%{\"ok\"%}%else%{\"fail\"%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: ok\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"ok\"\n \n # Substitutions with braces are handled correctly\n #\n # RUN: echo %{sub} %if feature%{test-%{sub}%}%else%{\"fail\"%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: ok test-ok\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo ok test-ok\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt b/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\nindex fb3a3e000789..5ff0c891450b 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\n@@ -1,3 +1,4 @@\n # RUN: true\n # RUN: echo hi\n-# RUN: not not wc missing-file &> %t.out\n+# RUN: not not wc missing-file &> %t.out || true\n+# RUN: not %{python} %S/write-a-lot.py &> %t.out\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg b/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\nindex b872854d21e6..c53fd157b6ae 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\n@@ -2,4 +2,5 @@ import lit.formats\n \n config.name = \"shtest-output-printing\"\n config.suffixes = [\".txt\"]\n+config.substitutions.append((\"%{python}\", sys.executable))\n config.test_format = lit.formats.ShTest(execute_external=False)\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py b/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py\nnew file mode 100644\nindex 000000000000..ffcba7d517cd\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py\n@@ -0,0 +1,6 @@\n+#!/usr/bin/env python\n+\n+import sys\n+\n+sys.stdout.write(\"All work and no play makes Jack a dull boy.\\n\" * 1000);\n+sys.stdout.flush()\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt\nnew file mode 100644\nindex 000000000000..15a87aee46a3\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt\n@@ -0,0 +1 @@\n+RUN: @echo 2> %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt\nnew file mode 100644\nindex 000000000000..27fd0c4209fd\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt\n@@ -0,0 +1,2 @@\n+RUN: touch %t\n+RUN: @echo < %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt\nnew file mode 100644\nindex 000000000000..9611918f7e12\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt\n@@ -0,0 +1 @@\n+RUN: echo 2> %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt\nnew file mode 100644\nindex 000000000000..bc771be6b22a\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt\n@@ -0,0 +1,2 @@\n+RUN: touch %t\n+RUN: echo < %t\ndiff --git a/llvm/utils/lit/tests/allow-retries.py b/llvm/utils/lit/tests/allow-retries.py\nindex b8abe0ba4fee..ef548534f082 100644\n--- a/llvm/utils/lit/tests/allow-retries.py\n+++ b/llvm/utils/lit/tests/allow-retries.py\n@@ -15,9 +15,28 @@\n \n # This test does not succeed within the allowed retry limit\n #\n-# RUN: not %{lit} %{inputs}/allow-retries/does-not-succeed-within-limit.py | FileCheck --check-prefix=CHECK-TEST3 %s\n-# CHECK-TEST3: Failed Tests (1):\n-# CHECK-TEST3: allow-retries :: does-not-succeed-within-limit.py\n+# Check that the execution trace isn't corrupt due to reprocessing the script\n+# multiple times (e.g., '%dbg(...)' processing used to accumulate across\n+# retries).\n+#\n+# RUN: not %{lit} %{inputs}/allow-retries/does-not-succeed-within-limit.py -v |\\\n+# RUN:   FileCheck --check-prefix=CHECK-TEST3 -match-full-lines %s\n+#\n+#       CHECK-TEST3: FAIL: allow-retries :: does-not-succeed-within-limit.py (1 of 1)\n+#  CHECK-TEST3-NEXT: {{\\**}} TEST 'allow-retries :: does-not-succeed-within-limit.py' FAILED {{\\**}}\n+#  CHECK-TEST3-NEXT: Exit Code: 1\n+# CHECK-TEST3-EMPTY:\n+#  CHECK-TEST3-NEXT: Command Output (stdout):\n+#  CHECK-TEST3-NEXT: --\n+#  CHECK-TEST3-NEXT: # {{RUN}}: at line 3\n+#  CHECK-TEST3-NEXT: false\n+#  CHECK-TEST3-NEXT: # executed command: false\n+#  CHECK-TEST3-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-TEST3-NEXT: # error: command failed with exit status: 1\n+# CHECK-TEST3-EMPTY:\n+#  CHECK-TEST3-NEXT: --\n+#       CHECK-TEST3: Failed Tests (1):\n+#       CHECK-TEST3: allow-retries :: does-not-succeed-within-limit.py\n \n # This test should be UNRESOLVED since it has more than one ALLOW_RETRIES\n # lines, and that is not allowed.\ndiff --git a/llvm/utils/lit/tests/lit-opts.py b/llvm/utils/lit/tests/lit-opts.py\nindex d292ca74f3b9..a533a59d9d12 100644\n--- a/llvm/utils/lit/tests/lit-opts.py\n+++ b/llvm/utils/lit/tests/lit-opts.py\n@@ -8,7 +8,7 @@\n #\n # RUN: env LIT_OPTS=-a \\\n # RUN: %{lit} -s %{inputs}/lit-opts \\\n-# RUN: | FileCheck -check-prefix=SHOW-ALL -DVAR= %s\n+# RUN: | FileCheck -check-prefix=SHOW-ALL -DVAR=default %s\n \n # Check that LIT_OPTS understands multiple options with arbitrary spacing.\n #\n@@ -28,6 +28,6 @@\n \n # SHOW-ALL:     Testing: 1 tests\n # SHOW-ALL:     PASS: lit-opts :: test.txt (1 of 1)\n-# SHOW-ALL:     {{^}}[[VAR]]\n+# SHOW-ALL:     echo [[VAR]]\n # SHOW-ALL-NOT: PASS\n # SHOW-ALL:     Passed: 1\ndiff --git a/llvm/utils/lit/tests/shtest-define.py b/llvm/utils/lit/tests/shtest-define.py\nindex 1d0997bbbaf8..8c9309804cce 100644\n--- a/llvm/utils/lit/tests/shtest-define.py\n+++ b/llvm/utils/lit/tests/shtest-define.py\n@@ -136,15 +136,15 @@\n # RUN: %{lit} -va %{my-inputs}/shared-substs-*.txt 2>&1 |                      \\\n # RUN:   FileCheck -check-prefix=SHARED-SUBSTS -match-full-lines %s\n #\n-# SHARED-SUBSTS: shared-substs-0.txt\n-# SHARED-SUBSTS: GLOBAL: World\n-# SHARED-SUBSTS: LOCAL0: LOCAL0:Hello LOCAL0:World\n-# SHARED-SUBSTS: LOCAL0: subst\n+# SHARED-SUBSTS:# | shared-substs-0.txt\n+# SHARED-SUBSTS:# | GLOBAL: World\n+# SHARED-SUBSTS:# | LOCAL0: LOCAL0:Hello LOCAL0:World\n+# SHARED-SUBSTS:# | LOCAL0: subst\n #\n-# SHARED-SUBSTS: shared-substs-1.txt\n-# SHARED-SUBSTS: GLOBAL: World\n-# SHARED-SUBSTS: LOCAL1: LOCAL1:Hello LOCAL1:World\n-# SHARED-SUBSTS: LOCAL1: subst\n+# SHARED-SUBSTS:# | shared-substs-1.txt\n+# SHARED-SUBSTS:# | GLOBAL: World\n+# SHARED-SUBSTS:# | LOCAL1: LOCAL1:Hello LOCAL1:World\n+# SHARED-SUBSTS:# | LOCAL1: subst\n #\n # REDEFINE: %{test} = shared-substs-0.txt\n # RUN: %{record-test}\ndiff --git a/llvm/utils/lit/tests/shtest-env.py b/llvm/utils/lit/tests/shtest-env.py\nindex f2e8216f7f4a..a4775ac6688d 100644\n--- a/llvm/utils/lit/tests/shtest-env.py\n+++ b/llvm/utils/lit/tests/shtest-env.py\n@@ -10,88 +10,115 @@\n # CHECK: -- Testing: 16 tests{{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-assign.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"FOO=1\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env FOO=1\n+# CHECK: # executed command: env FOO=1\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-u-arg.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO\n+# CHECK: # executed command: env -u FOO\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-u.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u\n+# CHECK: # executed command: env -u\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-nested-none.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"env\" \"env\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env env env\n+# CHECK: # executed command: env env env\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-none.txt ({{[^)]*}})\n-# CHECK: $ \"env\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env\n+# CHECK: # executed command: env\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-cd.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"cd\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'cd'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 cd foobar\n+# CHECK: # executed command: env -u FOO BAR=3 cd foobar\n+# CHECK: # | Error: 'env' cannot call 'cd'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-colon.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \":\"\n-# CHECK: Error: 'env' cannot call ':'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 :\n+# CHECK: # executed command: env -u FOO BAR=3 :\n+# CHECK: # | Error: 'env' cannot call ':'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-echo.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"echo\" \"hello\" \"world\"\n-# CHECK: Error: 'env' cannot call 'echo'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 echo hello world\n+# CHECK: # executed command: env -u FOO BAR=3 echo hello world\n+# CHECK: # | Error: 'env' cannot call 'echo'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: PASS: shtest-env :: env-calls-env.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"env\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"FOO=2\" \"env\" \"BAR=1\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"env\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=1\" \"env\" \"-u\" \"BAR\" \"FOO=2\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=1\" \"env\" \"-u\" \"BAR\" \"FOO=2\" \"env\" \"BAZ=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env env [[PYTHON:.+]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env env [[PYTHON_BARE:.+]] print_environment.py\n+# CHECK: env FOO=2 env BAR=1 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env FOO=2 env BAR=1 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO env -u BAR [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO env -u BAR [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO BAR=1 env -u BAR FOO=2 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO BAR=1 env -u BAR FOO=2 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO BAR=1 env -u BAR FOO=2 env BAZ=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO BAR=1 env -u BAR FOO=2 env BAZ=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: FAIL: shtest-env :: env-calls-export.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"export\" \"BAZ=3\"\n-# CHECK: Error: 'env' cannot call 'export'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 export BAZ=3\n+# CHECK: # executed command: env -u FOO BAR=3 export BAZ=3\n+# CHECK: # | Error: 'env' cannot call 'export'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-mkdir.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"mkdir\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'mkdir'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 mkdir foobar\n+# CHECK: # executed command: env -u FOO BAR=3 mkdir foobar\n+# CHECK: # | Error: 'env' cannot call 'mkdir'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-not-builtin.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"not\" \"rm\" \"{{.*}}.no-such-file\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 not rm {{.+}}.no-such-file\n+# CHECK: # executed command: env -u FOO BAR=3 not rm {{.+}}.no-such-file\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-rm.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"rm\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 rm foobar\n+# CHECK: # executed command: env -u FOO BAR=3 rm foobar\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: PASS: shtest-env :: env-u.txt ({{[^)]*}})\n-# CHECK: $ \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: env -u FOO [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO -u BAR [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO -u BAR [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: PASS: shtest-env :: env.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"A_FOO=999\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"A_FOO=1\" \"B_BAR=2\" \"C_OOF=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env A_FOO=999 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=999 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env A_FOO=1 B_BAR=2 C_OOF=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=1 B_BAR=2 C_OOF=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: PASS: shtest-env :: mixed.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"A_FOO=999\" \"-u\" \"FOO\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"A_FOO=1\" \"-u\" \"FOO\" \"B_BAR=2\" \"-u\" \"BAR\" \"C_OOF=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env A_FOO=999 -u FOO [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=999 -u FOO [[PYTHON_BARE]] print_environment.py\n+# CHECK: env A_FOO=1 -u FOO B_BAR=2 -u BAR C_OOF=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=1 -u FOO B_BAR=2 -u BAR C_OOF=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: Passed:  4\n # CHECK: Failed: 12\ndiff --git a/llvm/utils/lit/tests/shtest-format.py b/llvm/utils/lit/tests/shtest-format.py\nindex 621776ab7bc2..4a3d65b7bce4 100644\n--- a/llvm/utils/lit/tests/shtest-format.py\n+++ b/llvm/utils/lit/tests/shtest-format.py\n@@ -43,13 +43,21 @@\n # CHECK-EMPTY:\n #  CHECK-NEXT: Command Output (stdout):\n #  CHECK-NEXT: --\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-#  CHECK-NEXT: $ \"printf\"\n-#  CHECK-NEXT: # command output:\n-#  CHECK-NEXT: line 1: failed test output on stdout\n-#  CHECK-NEXT: line 2: failed test output on stdout\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-#  CHECK-NEXT: $ \"false\"\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: printf \"line 1: failed test output on stdout\\nline 2: failed test output on stdout\"\n+#  CHECK-NEXT: executed command: printf 'line 1: failed test output on stdout\\nline 2: failed test output on stdout'\n+#  CHECK-NEXT: # .---command stdout------------\n+#  CHECK-NEXT: # | line 1: failed test output on stdout\n+#  CHECK-NEXT: # | line 2: failed test output on stdout\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # RUN: at line 2\n+#  CHECK-NEXT: false\n+#  CHECK-NEXT: # executed command: false\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: --\n+\n \n # CHECK: UNRESOLVED: shtest-format :: no-test-line.txt\n # CHECK: PASS: shtest-format :: pass.txt\n@@ -73,8 +81,11 @@\n # CHECK-EMPTY:\n #  CHECK-NEXT: Command Output (stdout):\n #  CHECK-NEXT: --\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-#  CHECK-NEXT: $ \"true\"\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: true\n+#  CHECK-NEXT: # executed command: true\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: --\n \n # CHECK: Failed Tests (4)\n # CHECK: shtest-format :: external_shell/fail.txt\ndiff --git a/llvm/utils/lit/tests/shtest-if-else.py b/llvm/utils/lit/tests/shtest-if-else.py\nindex aaf94a6e2437..c18da4abbcca 100644\n--- a/llvm/utils/lit/tests/shtest-if-else.py\n+++ b/llvm/utils/lit/tests/shtest-if-else.py\n@@ -1,5 +1,6 @@\n # RUN: %{lit} -v --show-all %{inputs}/shtest-if-else/test.txt \\\n-# RUN:    | FileCheck %{inputs}/shtest-if-else/test.txt --match-full-lines\n+# RUN:    | FileCheck %{inputs}/shtest-if-else/test.txt --match-full-lines \\\n+# RUN:                --implicit-check-not='RUN:'\n \n # RUN: not %{lit} -v --show-all %{inputs}/shtest-if-else/test-neg1.txt 2>&1 \\\n # RUN:    | FileCheck %{inputs}/shtest-if-else/test-neg1.txt\ndiff --git a/llvm/utils/lit/tests/shtest-inject.py b/llvm/utils/lit/tests/shtest-inject.py\nindex 17e293ea1a12..3d34eb7161d4 100644\n--- a/llvm/utils/lit/tests/shtest-inject.py\n+++ b/llvm/utils/lit/tests/shtest-inject.py\n@@ -1,9 +1,26 @@\n-# Check that we can inject commands at the beginning of a ShTest.\n+# Check that we can inject preamble commands at the beginning of a ShTest.\n+#\n+# For one case, check the execution trace as these preamble commands have\n+# \"preamble command\" instead of the usual \"{{RUN}}: at line N\".\n \n # RUN: %{lit} %{inputs}/shtest-inject/test-empty.txt --show-all | FileCheck --check-prefix=CHECK-TEST1 %s\n #\n-# CHECK-TEST1: THIS WAS\n-# CHECK-TEST1: INJECTED\n+#       CHECK-TEST1: Command Output (stdout):\n+#  CHECK-TEST1-NEXT: --\n+#  CHECK-TEST1-NEXT: # preamble command line\n+#  CHECK-TEST1-NEXT: echo \"THIS WAS\"\n+#  CHECK-TEST1-NEXT: # executed command: echo 'THIS WAS'\n+#  CHECK-TEST1-NEXT: # .---command stdout{{-*}}\n+#  CHECK-TEST1-NEXT: # | THIS WAS\n+#  CHECK-TEST1-NEXT: # `---{{-*}}\n+#  CHECK-TEST1-NEXT: # preamble command line\n+#  CHECK-TEST1-NEXT: echo \"INJECTED\"\n+#  CHECK-TEST1-NEXT: # executed command: echo INJECTED\n+#  CHECK-TEST1-NEXT: # .---command stdout{{-*}}\n+#  CHECK-TEST1-NEXT: # | INJECTED\n+#  CHECK-TEST1-NEXT: # `---{{-*}}\n+# CHECK-TEST1-EMPTY:\n+#  CHECK-TEST1-NEXT: --\n #\n # CHECK-TEST1: Passed: 1\n \ndiff --git a/llvm/utils/lit/tests/shtest-not.py b/llvm/utils/lit/tests/shtest-not.py\nindex d23c9d0cffaf..4590b9664b84 100644\n--- a/llvm/utils/lit/tests/shtest-not.py\n+++ b/llvm/utils/lit/tests/shtest-not.py\n@@ -10,112 +10,158 @@\n # CHECK: -- Testing: 17 tests{{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-args-nested-none.txt {{.*}}\n-# CHECK: $ \"!\" \"!\" \"!\"\n-# CHECK: Error: '!' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: ! ! !\n+# CHECK: # executed command: ! ! !\n+# CHECK: # | Error: '!' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-args-none.txt {{.*}}\n-# CHECK: $ \"!\"\n-# CHECK: Error: '!' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: !\n+# CHECK: # executed command: !\n+# CHECK: # | Error: '!' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-calls-external.txt {{.*}}\n \n-# CHECK: $ \"!\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"!\" \"!\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"!\" \"!\" \"!\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"!\" \"!\" \"!\" \"!\" \"{{[^\"]*}}\" \"pass.py\"\n+# CHECK: ! [[PYTHON:.*]] fail.py\n+# CHECK: # executed command: ! [[PYTHON_BARE:.*]] fail.py\n+# CHECK: ! ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! ! [[PYTHON_BARE]] pass.py\n+# CHECK: ! ! ! [[PYTHON]] fail.py\n+# CHECK: # executed command: ! ! ! [[PYTHON_BARE]] fail.py\n+# CHECK: ! ! ! ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! ! ! ! [[PYTHON_BARE]] pass.py\n \n-# CHECK: $ \"!\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! [[PYTHON_BARE]] pass.py\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-last-is-crash.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not --crash\n+# CHECK: # executed command: not --crash\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-nested-none.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not not\n+# CHECK: # executed command: not not not\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-none.txt {{.*}}\n-# CHECK: $ \"not\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not\n+# CHECK: # executed command: not\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-cd.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"cd\" \"foobar\"\n-# CHECK: $ \"not\" \"--crash\" \"cd\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'cd'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not cd foobar\n+# CHECK: # executed command: not not cd foobar\n+# CHECK: not --crash cd foobar\n+# CHECK: # executed command: not --crash cd foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'cd'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-colon.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \":\" \"foobar\"\n-# CHECK: $ \"not\" \"--crash\" \":\"\n-# CHECK: Error: 'not --crash' cannot call ':'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not : foobar\n+# CHECK: # executed command: not not : foobar\n+# CHECK: not --crash :\n+# CHECK: # executed command: not --crash :\n+# CHECK: # | Error: 'not --crash' cannot call ':'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-diff-with-crash.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"diff\" \"-u\" {{.*}}\n-# CHECK-NOT: \"$\"\n+# CHECK: not --crash diff -u {{.*}}\n+# CHECK: # executed command: not --crash diff -u {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n # CHECK-NOT: {{[Ee]rror}}\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: # error: command failed with exit status: {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n # CHECK-NOT: {{[Ee]rror}}\n-# CHECK-NOT: \"$\"\n \n # CHECK: FAIL: shtest-not :: not-calls-diff.txt {{.*}}\n-# CHECK: $ \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"diff\" {{.*}}\n-# CHECK-NOT: \"$\"\n+# CHECK: not diff {{.*}}\n+# CHECK: # executed command: not diff {{.*}}\n+# CHECK: not not not diff {{.*}}\n+# CHECK: # executed command: not not not diff {{.*}}\n+# CHECK: not not not not not diff {{.*}}\n+# CHECK: # executed command: not not not not not diff {{.*}}\n+# CHECK: diff {{.*}}\n+# CHECK: # executed command: diff {{.*}}\n+# CHECK: not not diff {{.*}}\n+# CHECK: # executed command: not not diff {{.*}}\n+# CHECK: not not not not diff {{.*}}\n+# CHECK: # executed command: not not not not diff {{.*}}\n+# CHECK: not diff {{.*}}\n+# CHECK: # executed command: not diff {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-echo.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"echo\" \"hello\" \"world\"\n-# CHECK: $ \"not\" \"--crash\" \"echo\" \"hello\" \"world\"\n-# CHECK: Error: 'not --crash' cannot call 'echo'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not echo hello world\n+# CHECK: # executed command: not not echo hello world\n+# CHECK: not --crash echo hello world\n+# CHECK: # executed command: not --crash echo hello world\n+# CHECK: # | Error: 'not --crash' cannot call 'echo'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-env-builtin.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"env\" \"-u\" \"FOO\" \"BAR=3\" \"rm\" \"{{.*}}.no-such-file\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not --crash env -u FOO BAR=3 rm {{.*}}.no-such-file\n+# CHECK: # executed command: not --crash env -u FOO BAR=3 rm {{.*}}.no-such-file\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-export.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"export\" \"FOO=1\"\n-# CHECK: $ \"not\" \"--crash\" \"export\" \"BAZ=3\"\n-# CHECK: Error: 'not --crash' cannot call 'export'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not export FOO=1\n+# CHECK: # executed command: not not export FOO=1\n+# CHECK: not --crash export BAZ=3\n+# CHECK: # executed command: not --crash export BAZ=3\n+# CHECK: # | Error: 'not --crash' cannot call 'export'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n \n # CHECK: PASS: shtest-not :: not-calls-external.txt {{.*}}\n \n-# CHECK: $ \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-\n-# CHECK: $ \"env\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"env\" \"-u\" \"FOO\" \"BAR=2\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"env\" \"-u\" \"FOO\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"env\" \"FOO=1\" \"env\" \"FOO=2\" \"BAR=1\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"-u\" \"BAR\" \"env\" \"-u\" \"FOO\" \"BAR=1\" \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"env\" \"FOO=2\" \"BAR=2\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"env\" \"-u\" \"BAR\" \"not\" \"env\" \"-u\" \"FOO\" \"BAR=1\" \"{{[^\"]*}}\" \"pass.py\"\n+# CHECK: not [[PYTHON]] fail.py\n+# CHECK: # executed command: not [[PYTHON_BARE]] fail.py\n+# CHECK: not not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not [[PYTHON_BARE]] pass.py\n+# CHECK: not not not [[PYTHON]] fail.py\n+# CHECK: # executed command: not not not [[PYTHON_BARE]] fail.py\n+# CHECK: not not not not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not not not [[PYTHON_BARE]] pass.py\n+\n+# CHECK: not not --crash [[PYTHON]] pass.py\n+# CHECK: # executed command: not not --crash [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash [[PYTHON]] fail.py\n+# CHECK: # executed command: not not --crash [[PYTHON_BARE]] fail.py\n+# CHECK: not not --crash not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not --crash not [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash not [[PYTHON]] fail.py\n+# CHECK: # executed command: not not --crash not [[PYTHON_BARE]] fail.py\n+\n+# CHECK: env not [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env not [[PYTHON_BARE]] fail.py\n+# CHECK: not env [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: not env [[PYTHON_BARE]] fail.py\n+# CHECK: env FOO=1 not [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 not [[PYTHON_BARE]] fail.py\n+# CHECK: not env FOO=1 BAR=1 [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 [[PYTHON_BARE]] fail.py\n+# CHECK: env FOO=1 BAR=1 not env -u FOO BAR=2 [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 BAR=1 not env -u FOO BAR=2 [[PYTHON_BARE]] fail.py\n+# CHECK: not env FOO=1 BAR=1 not env -u FOO -u BAR [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 not env -u FOO -u BAR [[PYTHON_BARE]] pass.py\n+# CHECK: not not env FOO=1 env FOO=2 BAR=1 [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not not env FOO=1 env FOO=2 BAR=1 [[PYTHON_BARE]] pass.py\n+# CHECK: env FOO=1 -u BAR env -u FOO BAR=1 not not [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 -u BAR env -u FOO BAR=1 not not [[PYTHON_BARE]] pass.py\n+\n+# CHECK: not env FOO=1 BAR=1 env FOO=2 BAR=2 not --crash [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 env FOO=2 BAR=2 not --crash [[PYTHON_BARE]] pass.py\n+# CHECK: not env FOO=1 BAR=1 not --crash not [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 not --crash not [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash env -u BAR not env -u FOO BAR=1 [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not not --crash env -u BAR not env -u FOO BAR=1 [[PYTHON_BARE]] pass.py\n \n \n # CHECK: FAIL: shtest-not :: not-calls-fail2.txt {{.*}}\n@@ -123,16 +169,20 @@\n # CHECK-NEXT: Exit Code: 1\n \n # CHECK: FAIL: shtest-not :: not-calls-mkdir.txt {{.*}}\n-# CHECK: $ \"not\" \"mkdir\" {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"mkdir\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'mkdir'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not mkdir {{.*}}\n+# CHECK: # executed command: not mkdir {{.*}}\n+# CHECK: not --crash mkdir foobar\n+# CHECK: # executed command: not --crash mkdir foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'mkdir'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-rm.txt {{.*}}\n-# CHECK: $ \"not\" \"rm\" {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"rm\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not rm {{.*}}\n+# CHECK: # executed command: not rm {{.*}}\n+# CHECK: not --crash rm foobar\n+# CHECK: # executed command: not --crash rm foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: Passed:  1\n # CHECK: Failed: 16\ndiff --git a/llvm/utils/lit/tests/shtest-output-printing.py b/llvm/utils/lit/tests/shtest-output-printing.py\nindex 7cd975ba8d3c..3e49197520a9 100644\n--- a/llvm/utils/lit/tests/shtest-output-printing.py\n+++ b/llvm/utils/lit/tests/shtest-output-printing.py\n@@ -1,28 +1,45 @@\n # Check the various features of the ShTest format.\n #\n # RUN: not %{lit} -v %{inputs}/shtest-output-printing > %t.out\n-# RUN: FileCheck --input-file %t.out %s\n+# RUN: FileCheck --input-file %t.out --match-full-lines %s\n #\n # END.\n \n-# CHECK: -- Testing:\n-\n-# CHECK: FAIL: shtest-output-printing :: basic.txt\n-# CHECK-NEXT: *** TEST 'shtest-output-printing :: basic.txt' FAILED ***\n-# CHECK-NEXT: Exit Code: 1\n-#\n-# CHECK:      Command Output\n-# CHECK-NEXT: --\n-# CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \"true\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-# CHECK-NEXT: $ \"echo\" \"hi\"\n-# CHECK-NEXT: # command output:\n-# CHECK-NEXT: hi\n-#\n-# CHECK:      $ \":\" \"RUN: at line 3\"\n-# CHECK-NEXT: $ \"not\" \"not\" \"wc\" \"missing-file\"\n-# CHECK-NEXT: # redirected output from '{{.*(/|\\\\\\\\)}}basic.txt.tmp.out':\n-# CHECK-NEXT: {{cannot open missing-file|missing-file.* No such file or directory}}\n-# CHECK:      note: command had no output on stdout or stderr\n-# CHECK-NEXT: error: command failed with exit status: 1\n+#       CHECK: -- Testing: {{.*}}\n+#       CHECK: FAIL: shtest-output-printing :: basic.txt {{.*}}\n+#  CHECK-NEXT: ***{{\\**}} TEST 'shtest-output-printing :: basic.txt' FAILED ***{{\\**}}\n+#  CHECK-NEXT: Exit Code: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: Command Output (stdout):\n+#  CHECK-NEXT: --\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: true\n+#  CHECK-NEXT: # executed command: true\n+#  CHECK-NEXT: # RUN: at line 2\n+#  CHECK-NEXT: echo hi\n+#  CHECK-NEXT: # executed command: echo hi\n+#  CHECK-NEXT: # .---command stdout------------\n+#  CHECK-NEXT: # | hi\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # RUN: at line 3\n+#  CHECK-NEXT: not not wc missing-file &> [[FILE:.*]] || true\n+#  CHECK-NEXT: # executed command: not not wc missing-file\n+#  CHECK-NEXT: # .---redirected output from '[[FILE]]'\n+#  CHECK-NEXT: # | wc: {{cannot open missing-file|missing-file.* No such file or directory}}\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+#  CHECK-NEXT: # executed command: true\n+#  CHECK-NEXT: # RUN: at line 4\n+#  CHECK-NEXT: not {{.*}}/python{{.*}} {{.*}}/write-a-lot.py &> [[FILE:.*]]\n+#  CHECK-NEXT: # executed command: not {{.*}}/python{{.*}} {{.*}}/write-a-lot.py\n+#  CHECK-NEXT: # .---redirected output from '[[FILE]]'\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#       CHECK: # | ...\n+#  CHECK-NEXT: # `---data was truncated--------\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT:--\ndiff --git a/llvm/utils/lit/tests/shtest-pushd-popd.py b/llvm/utils/lit/tests/shtest-pushd-popd.py\nindex 26296a7ffcf5..6d7e93c74a05 100644\n--- a/llvm/utils/lit/tests/shtest-pushd-popd.py\n+++ b/llvm/utils/lit/tests/shtest-pushd-popd.py\n@@ -8,16 +8,16 @@\n # CHECK: -- Testing: 4 tests{{.*}}\n \n # CHECK: FAIL: shtest-pushd-popd :: popd-args.txt ({{[^)]*}})\n-# CHECK: $ \"popd\" \"invalid\"\n-# CHECK: 'popd' does not support arguments\n+# CHECK: popd invalid\n+# CHECK: # | 'popd' does not support arguments\n \n # CHECK: FAIL: shtest-pushd-popd :: popd-no-stack.txt ({{[^)]*}})\n-# CHECK: $ \"popd\"\n-# CHECK: popd: directory stack empty\n+# CHECK: popd\n+# CHECK: # | popd: directory stack empty\n \n # CHECK: FAIL: shtest-pushd-popd :: pushd-too-many-args.txt ({{[^)]*}})\n-# CHECK: $ \"pushd\" \"a\" \"b\"\n-# CHECK: 'pushd' supports only one argument\n+# CHECK: pushd a b\n+# CHECK: # | 'pushd' supports only one argument\n \n # CHECK: Passed:  1\n # CHECK: Failed:  3\ndiff --git a/llvm/utils/lit/tests/shtest-recursive-substitution.py b/llvm/utils/lit/tests/shtest-recursive-substitution.py\nindex 48f4b5b12491..65c177e65a3c 100644\n--- a/llvm/utils/lit/tests/shtest-recursive-substitution.py\n+++ b/llvm/utils/lit/tests/shtest-recursive-substitution.py\n@@ -3,7 +3,7 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/substitutes-within-limit --show-all | FileCheck --check-prefix=CHECK-TEST1 %s\n # CHECK-TEST1: PASS: substitutes-within-limit :: test.py\n-# CHECK-TEST1: $ \"echo\" \"STOP\"\n+# CHECK-TEST1: echo STOP\n \n # RUN: not %{lit} %{inputs}/shtest-recursive-substitution/does-not-substitute-within-limit --show-all | FileCheck --check-prefix=CHECK-TEST2 %s\n # CHECK-TEST2: UNRESOLVED: does-not-substitute-within-limit :: test.py\n@@ -11,7 +11,7 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/does-not-substitute-no-limit --show-all | FileCheck --check-prefix=CHECK-TEST3 %s\n # CHECK-TEST3: PASS: does-not-substitute-no-limit :: test.py\n-# CHECK-TEST3: $ \"echo\" \"%rec4\"\n+# CHECK-TEST3: echo %rec4\n \n # RUN: not %{lit} %{inputs}/shtest-recursive-substitution/not-an-integer --show-all 2>&1 | FileCheck --check-prefix=CHECK-TEST4 %s\n # CHECK-TEST4: recursiveExpansionLimit must be either None or an integer\n@@ -24,4 +24,4 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/escaping --show-all | FileCheck --check-prefix=CHECK-TEST7 %s\n # CHECK-TEST7: PASS: escaping :: test.py\n-# CHECK-TEST7: $ \"echo\" \"%s\" \"%s\" \"%%s\"\n+# CHECK-TEST7: echo %s %s %%s\ndiff --git a/llvm/utils/lit/tests/shtest-run-at-line.py b/llvm/utils/lit/tests/shtest-run-at-line.py\nindex 879cd64ebf6e..a0626f872c4c 100644\n--- a/llvm/utils/lit/tests/shtest-run-at-line.py\n+++ b/llvm/utils/lit/tests/shtest-run-at-line.py\n@@ -28,21 +28,28 @@\n # CHECK-LABEL: FAIL: shtest-run-at-line :: internal-shell/basic.txt\n \n # CHECK:      Command Output (stdout)\n-# CHECK:      $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \"true\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-# CHECK-NEXT: $ \"false\"\n+# CHECK-NEXT: --\n+# CHECK-NEXT: # RUN: at line 1\n+# CHECK-NEXT: true\n+# CHECK-NEXT: # executed command: true\n+# CHECK-NEXT: # RUN: at line 2\n+# CHECK-NEXT: false\n+# CHECK-NEXT: # executed command: false\n # CHECK-NOT:  RUN\n \n # CHECK-LABEL: FAIL: shtest-run-at-line :: internal-shell/line-continuation.txt\n \n # CHECK:      Command Output (stdout)\n-# CHECK:      $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \":\" \"first\" \"line\" \"continued\" \"to\" \"second\" \"line\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 3\"\n-# CHECK-NEXT: $ \"echo\" \"foo bar\"\n-# CHECK-NEXT: $ \"FileCheck\" \"{{.*}}\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 5\"\n-# CHECK-NEXT: $ \"echo\" \"foo baz\"\n-# CHECK-NEXT: $ \"FileCheck\" \"{{.*}}\"\n+# CHECK-NEXT: --\n+# CHECK-NEXT: # RUN: at line 1\n+# CHECK-NEXT: : first line continued to second line\n+# CHECK-NEXT: # executed command: : first line continued to second line\n+# CHECK-NEXT: # RUN: at line 3\n+# CHECK-NEXT: echo 'foo bar' | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: echo 'foo bar'\n+# CHECK-NEXT: # executed command: FileCheck {{.*}}\n+# CHECK-NEXT: # RUN: at line 5\n+# CHECK-NEXT: echo 'foo baz' | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: echo 'foo baz'\n+# CHECK-NEXT: # executed command: FileCheck {{.*}}\n # CHECK-NOT:  RUN\ndiff --git a/llvm/utils/lit/tests/shtest-shell.py b/llvm/utils/lit/tests/shtest-shell.py\nindex 93f05dbd35d0..8ce71296c144 100644\n--- a/llvm/utils/lit/tests/shtest-shell.py\n+++ b/llvm/utils/lit/tests/shtest-shell.py\n@@ -20,202 +20,212 @@\n \n # CHECK: FAIL: shtest-shell :: cat-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: cat-error-0.txt' FAILED ***\n-# CHECK: $ \"cat\" \"-b\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'cat':  option -b not recognized\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: cat -b temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'cat':  option -b not recognized\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: cat-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: cat-error-1.txt' FAILED ***\n-# CHECK: $ \"cat\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: [Errno 2] No such file or directory: 'temp1.txt'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: cat temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | [Errno 2] No such file or directory: 'temp1.txt'\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: colon-error.txt\n # CHECK: *** TEST 'shtest-shell :: colon-error.txt' FAILED ***\n-# CHECK: $ \":\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: ':' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: :\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: ':' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: PASS: shtest-shell :: continuations.txt\n \n # CHECK: PASS: shtest-shell :: dev-null.txt\n \n-# CHECK: FAIL: shtest-shell :: diff-b.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-b.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-b\" \"{{[^\"]*}}.0\" \"{{[^\"]*}}.1\"\n-# CHECK: # command output:\n-# CHECK: 1,2\n-# CHECK-NEXT: {{^  }}f o o\n-# CHECK-NEXT: ! b a r\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: {{^  }}f o o\n-# CHECK-NEXT: ! bar\n-# CHECK-EMPTY:\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-b.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-b.txt' FAILED ***\n+#      CHECK: diff -b {{[^\"]*}}.0 {{[^\"]*}}.1\n+#      CHECK: # .---command stdout{{-*}}\n+#      CHECK: # | {{.*}}1,2\n+# CHECK-NEXT: # |   f o o\n+# CHECK-NEXT: # | ! b a r\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # |   f o o\n+# CHECK-NEXT: # | ! bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+#      CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-encodings.txt\n # CHECK: *** TEST 'shtest-shell :: diff-encodings.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"diff-in.bin\"\n+#      CHECK: diff -u diff-in.bin diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.bin diff-in.bin\n+#  CHECK-NOT: error\n+\n+#      CHECK: diff -u diff-in.utf16 diff-in.bin && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf16 diff-in.bin\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.utf8 diff-in.bin && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf8 diff-in.bin\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | -baz\n+# CHECK-NEXT: # | {{\\+.f.o.o.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{\\+.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.bin diff-in.utf8 && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.bin diff-in.utf8\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{-.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.}}\n+# CHECK-NEXT: # | {{-.b.a.z.$}}\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # | +baz\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#     CHECK: cat diff-in.bin | diff -u - diff-in.bin\n # CHECK-NOT: error\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf16\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^ .f.o.o.$}}\n-# CHECK-NEXT: {{^-.b.a.r.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^ .b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf8\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: -baz\n-# CHECK-NEXT: {{^\\+.f.o.o.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^\\+.b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"diff-in.utf8\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^\\-.f.o.o.$}}\n-# CHECK-NEXT: {{^\\-.b.a.r.}}\n-# CHECK-NEXT: {{^\\-.b.a.z.$}}\n-# CHECK-NEXT: +foo\n-# CHECK-NEXT: +bar\n-# CHECK-NEXT: +baz\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"-\"\n-# CHECK-NOT: error\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf16\" \"-\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^ .f.o.o.$}}\n-# CHECK-NEXT: {{^-.b.a.r.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^ .b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n+#     CHECK: cat diff-in.bin | diff -u diff-in.bin -\n # CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf8\" \"-\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: -baz\n-# CHECK-NEXT: {{^\\+.f.o.o.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^\\+.b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"diff-in.utf8\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^\\-.f.o.o.$}}\n-# CHECK-NEXT: {{^\\-.b.a.r.}}\n-# CHECK-NEXT: {{^\\-.b.a.z.$}}\n-# CHECK-NEXT: +foo\n-# CHECK-NEXT: +bar\n-# CHECK-NEXT: +baz\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n \n-# CHECK: $ \"false\"\n+#      CHECK: cat diff-in.bin | diff -u diff-in.utf16 - && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf16 -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat diff-in.bin | diff -u diff-in.utf8 - && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf8 -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | -baz\n+# CHECK-NEXT: # | {{\\+.f.o.o.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{\\+.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat diff-in.bin | diff -u - diff-in.utf8 && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u - diff-in.utf8\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{-.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.}}\n+# CHECK-NEXT: # | {{-.b.a.z.$}}\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # | +baz\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-1.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-B\" \"temp1.txt\" \"temp2.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'diff': option -B not recognized\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -B temp1.txt temp2.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'diff': option -B not recognized\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-2.txt' FAILED ***\n-# CHECK: $ \"diff\" \"temp.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff temp.txt \n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-3.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-3.txt' FAILED ***\n-# CHECK: $ \"diff\" \"temp.txt\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'diff' command failed\n+# CHECK: diff temp.txt temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'diff' command failed\n # CHECK: error: command failed with exit status: 1\n # CHECK: ***\n \n-# CHECK: FAIL: shtest-shell :: diff-error-4.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-error-4.txt' FAILED ***\n-# CHECK: Exit Code: 1\n-# CHECK: # command output:\n-# CHECK: diff-error-4.txt.tmp\n-# CHECK: diff-error-4.txt.tmp1\n-# CHECK: *** 1 ****\n-# CHECK: ! hello-first\n-# CHECK: --- 1 ----\n-# CHECK: ! hello-second\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-error-4.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-error-4.txt' FAILED ***\n+#      CHECK: Exit Code: 1\n+#      CHECK: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | {{.*}}diff-error-4.txt.tmp\n+# CHECK-NEXT: # | {{.*}}diff-error-4.txt.tmp1\n+# CHECK-NEXT: # | {{\\*+}}\n+# CHECK-NEXT: # | *** 1 ****\n+# CHECK-NEXT: # | ! hello-first\n+# CHECK-NEXT: # | --- 1 ----\n+# CHECK-NEXT: # | ! hello-second\n+# CHECK-NEXT: # `---{{-*}}\n+#      CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-5.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-5.txt' FAILED ***\n-# CHECK: $ \"diff\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-6.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-6.txt' FAILED ***\n-# CHECK: $ \"diff\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n \n@@ -223,137 +233,130 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-pipes.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.foo\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"FileCheck\"\n+# CHECK: diff {{[^ ]*}}.foo {{.*}}.foo | FileCheck {{.*}}\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: note: command had no output on stdout or stderr\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"FileCheck\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"true\"\n+#      CHECK: diff -u {{.*}}.foo {{.*}}.bar | FileCheck {{.*}} && false || true\n+# CHECK-NEXT: # executed command: diff -u {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # note: command had no output on stdout or stderr\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: FileCheck\n+# CHECK-NEXT: # executed command: true\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"{{[^\"]*}}.foo\"\n+#     CHECK: cat {{.*}}.foo | diff -u - {{.*}}.foo\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n+#     CHECK: cat {{.*}}.foo | diff -u {{.*}}.foo -\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: +bar\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"{{[^\"]*}}.foo\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: +foo\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-\" \"{{[^\"]*}}.foo\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"FileCheck\"\n+#      CHECK: cat {{.*}}.bar | diff -u {{.*}}.foo - && false || true\n+# CHECK-NEXT: # executed command: cat {{.*}}.bar\n+# CHECK-NEXT: # executed command: diff -u {{.*}}.foo -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat {{.*}}.bar | diff -u - {{.*}}.foo && false || true\n+# CHECK-NEXT: # executed command: cat {{.*}}.bar\n+# CHECK-NEXT: # executed command: diff -u - {{.*}}.foo\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#     CHECK: cat {{.*}}.foo | diff - {{.*}}.foo | FileCheck {{.*}}\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n-# CHECK: note: command had no output on stdout or stderr\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"FileCheck\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"true\"\n+#      CHECK: cat {{.*}}.bar | diff -u {{.*}}.foo - | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: cat {{.*}}.bar\n+# CHECK-NEXT: # executed command: diff -u {{.*}}.foo -\n+# CHECK-NEXT: note: command had no output on stdout or stderr\n+# CHECK-NEXT: error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: FileCheck\n+# CHECK-NEXT: # executed command: true\n \n-# CHECK: $ \"false\"\n+# CHECK: false\n \n # CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-r-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-0.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: dir1unique\n-# CHECK: Only in {{.*}}dir2: dir2unique\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: dir1unique\n+# CHECK: # | Only in {{.*}}dir2: dir2unique\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-1.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: *** {{.*}}dir1{{.*}}subdir{{.*}}f01\n-# CHECK: --- {{.*}}dir2{{.*}}subdir{{.*}}f01\n-# CHECK: 12345\n-# CHECK: 00000\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | *** {{.*}}dir1{{.*}}subdir{{.*}}f01\n+# CHECK: # | --- {{.*}}dir2{{.*}}subdir{{.*}}f01\n+# CHECK: # | ! 12345\n+# CHECK: # | ! 00000\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-2.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir2: extrafile\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir2: extrafile\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-3.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-3.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: extra_subdir\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: extra_subdir\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-4.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-4.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: File {{.*}}dir1{{.*}}extra_subdir is a directory while file {{.*}}dir2{{.*}}extra_subdir is a regular file\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | File {{.*}}dir1{{.*}}extra_subdir is a directory while file {{.*}}dir2{{.*}}extra_subdir is a regular file\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-5.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-5.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: extra_subdir\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: extra_subdir\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-6.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-6.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: File {{.*}}dir1{{.*}}extra_file is a regular empty file while file {{.*}}dir2{{.*}}extra_file is a directory\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | File {{.*}}dir1{{.*}}extra_file is a regular empty file while file {{.*}}dir2{{.*}}extra_file is a directory\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-7.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-7.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\" \"-\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: cannot recursively compare '-'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r - {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: cannot recursively compare '-'\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-8.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-8.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\" \"{{[^\"]*}}\" \"-\"\n-# CHECK: # command stderr:\n-# CHECK: Error: cannot recursively compare '-'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r {{.*}} -\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: cannot recursively compare '-'\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: PASS: shtest-shell :: diff-r.txt\n \n@@ -362,51 +365,59 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-strip-trailing-cr.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.dos\" \"diff-in.unix\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -In this file, the\n-# CHECK-NEXT: -sequence \"\\r\\n\"\n-# CHECK-NEXT: -terminates lines.\n-# CHECK-NEXT: +In this file, the\n-# CHECK-NEXT: +sequence \"\\n\"\n-# CHECK-NEXT: +terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.unix\" \"diff-in.dos\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -In this file, the\n-# CHECK-NEXT: -sequence \"\\n\"\n-# CHECK-NEXT: -terminates lines.\n-# CHECK-NEXT: +In this file, the\n-# CHECK-NEXT: +sequence \"\\r\\n\"\n-# CHECK-NEXT: +terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"--strip-trailing-cr\" \"diff-in.dos\" \"diff-in.unix\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT:  In this file, the\n-# CHECK-NEXT: -sequence \"\\r\\n\"\n-# CHECK-NEXT: +sequence \"\\n\"\n-# CHECK-NEXT:  terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"--strip-trailing-cr\" \"diff-in.unix\" \"diff-in.dos\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT:  In this file, the\n-# CHECK-NEXT: -sequence \"\\n\"\n-# CHECK-NEXT: +sequence \"\\r\\n\"\n-# CHECK-NEXT:  terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"false\"\n+#      CHECK: diff -u diff-in.dos diff-in.unix && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.dos diff-in.unix\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -In this file, the\n+# CHECK-NEXT: # | -sequence \"\\r\\n\"\n+# CHECK-NEXT: # | -terminates lines.\n+# CHECK-NEXT: # | +In this file, the\n+# CHECK-NEXT: # | +sequence \"\\n\"\n+# CHECK-NEXT: # | +terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.unix diff-in.dos && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.unix diff-in.dos\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -In this file, the\n+# CHECK-NEXT: # | -sequence \"\\n\"\n+# CHECK-NEXT: # | -terminates lines.\n+# CHECK-NEXT: # | +In this file, the\n+# CHECK-NEXT: # | +sequence \"\\r\\n\"\n+# CHECK-NEXT: # | +terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u --strip-trailing-cr diff-in.dos diff-in.unix && false || true\n+# CHECK-NEXT: executed command: diff -u --strip-trailing-cr diff-in.dos diff-in.unix\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # |  In this file, the\n+# CHECK-NEXT: # | -sequence \"\\r\\n\"\n+# CHECK-NEXT: # | +sequence \"\\n\"\n+# CHECK-NEXT: # |  terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u --strip-trailing-cr diff-in.unix diff-in.dos && false || true\n+# CHECK-NEXT: # executed command: diff -u --strip-trailing-cr diff-in.unix diff-in.dos\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # |  In this file, the\n+# CHECK-NEXT: # | -sequence \"\\n\"\n+# CHECK-NEXT: # | +sequence \"\\r\\n\"\n+# CHECK-NEXT: # |  terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n@@ -415,106 +426,144 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-unified.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 3\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-NEXT: 9\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U\" \"2\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U4\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 2\n-# CHECK-NEXT: 3\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-NEXT: 9\n-# CHECK-NEXT: 10\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U0\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U\" \"30.1\" \"{{[^\"]*}}\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: invalid '-U' argument: 30.1\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U-1\" \"{{[^\"]*}}\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: invalid '-U' argument: -1\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"false\"\n+#      CHECK: diff -u {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -u {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 3\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # | 9\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U 2 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U 2 {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U4 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U4 {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 2\n+# CHECK-NEXT: # | 3\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # | 9\n+# CHECK-NEXT: # | 10\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U0 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: diff -U0 {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: diff -U 30.1 {{.*}} {{.*}} && false || true\n+# CHECK: # executed command: diff -U 30.1 {{.*}} {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: invalid '-U' argument: 30.1\n+# CHECK: # error: command failed with exit status: 1\n+# CHECK: # executed command: true\n+\n+# CHECK: diff -U-1 {{.*}} {{.*}} && false || true\n+# CHECK: # executed command: diff -U-1 {{.*}} {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: invalid '-U' argument: -1\n+# CHECK: # error: command failed with exit status: 1\n+# CHECK: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n \n-# CHECK: FAIL: shtest-shell :: diff-w.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-w.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-w\" \"{{[^\"]*}}.0\" \"{{[^\"]*}}.1\"\n-# CHECK: # command output:\n-# CHECK: 1,3\n-# CHECK-NEXT: {{^  }}foo\n-# CHECK-NEXT: {{^  }}bar\n-# CHECK-NEXT: ! baz\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: {{^  }}foo\n-# CHECK-NEXT: {{^  }}bar\n-# CHECK-NEXT: ! bat\n-# CHECK-EMPTY:\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-w.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-w.txt' FAILED ***\n+#      CHECK: diff -w {{.*}}.0 {{.*}}.1\n+#      CHECK: # .---command stdout{{-*}}\n+#      CHECK: # | {{\\*+}} 1,3\n+# CHECK-NEXT: # |   foo\n+# CHECK-NEXT: # |   bar\n+# CHECK-NEXT: # | ! baz\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # |   foo\n+# CHECK-NEXT: # |   bar\n+# CHECK-NEXT: # | ! bat\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+#      CHECK: ***\n+\n+# CHECK: FAIL: shtest-shell :: echo-at-redirect-stderr.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-at-redirect-stderr.txt' FAILED ***\n+# CHECK: @echo 2> {{.*}}\n+# CHECK: # executed command: @echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for @echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-at-redirect-stdin.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-at-redirect-stdin.txt' FAILED ***\n+# CHECK: @echo < {{.*}}\n+# CHECK: # executed command: @echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for @echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-redirect-stderr.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-redirect-stderr.txt' FAILED ***\n+# CHECK: echo 2> {{.*}}\n+# CHECK: # executed command: echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-redirect-stdin.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-redirect-stdin.txt' FAILED ***\n+# CHECK: echo < {{.*}}\n+# CHECK: # executed command: echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for echo\n+# CHECK: error: command failed with exit status:\n \n # CHECK: FAIL: shtest-shell :: error-0.txt\n # CHECK: *** TEST 'shtest-shell :: error-0.txt' FAILED ***\n-# CHECK: $ \"not-a-real-command\"\n-# CHECK: # command stderr:\n-# CHECK: 'not-a-real-command': command not found\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: not-a-real-command\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | 'not-a-real-command': command not found\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # FIXME: The output here sucks.\n #\n # CHECK: FAIL: shtest-shell :: error-1.txt\n # CHECK: *** TEST 'shtest-shell :: error-1.txt' FAILED ***\n-# CHECK: shell parser error on: ': \\'RUN: at line 3\\'; echo \"missing quote'\n+# CHECK: shell parser error on RUN: at line 3: echo \"missing quote\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: error-2.txt\n@@ -524,52 +573,52 @@\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-0.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'mkdir' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p temp | rm -rf temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'mkdir' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-1.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\" \"-m\" \"777\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'mkdir': option -m not recognized\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p -m 777 temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'mkdir': option -m not recognized\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-2.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'mkdir' is missing an operand\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'mkdir' is missing an operand\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: PASS: shtest-shell :: redirects.txt\n \n # CHECK: FAIL: shtest-shell :: rm-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-0.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-rf\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'rm' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: rm -rf temp | echo \"hello\"\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'rm' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-1.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-f\" \"-v\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'rm': option -v not recognized\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: rm -f -v temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'rm': option -v not recognized\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-2.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-r\" \"hello\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'rm' command failed\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: rm -r hello\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'rm' command failed\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-3.txt\n@@ -581,16 +630,17 @@\n # CHECK: PASS: shtest-shell :: sequencing-0.txt\n # CHECK: XFAIL: shtest-shell :: sequencing-1.txt\n \n-# CHECK: FAIL: shtest-shell :: stdout-encoding.txt\n-# CHECK: *** TEST 'shtest-shell :: stdout-encoding.txt' FAILED ***\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: {{^.f.o.o.$}}\n-# CHECK-NEXT: {{^.b.a.r.}}\n-# CHECK-NEXT: {{^.b.a.z.$}}\n-# CHECK-NOT: error\n-# CHECK: $ \"false\"\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: stdout-encoding.txt\n+#      CHECK: *** TEST 'shtest-shell :: stdout-encoding.txt' FAILED ***\n+#      CHECK: cat diff-in.bin\n+#      CHECK: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+#  CHECK-NOT: error\n+#      CHECK: false\n+#      CHECK: ***\n \n # CHECK: PASS: shtest-shell :: valid-shell.txt\n-# CHECK: Failed Tests (35)\n+# CHECK: Failed Tests (39)\n", "message": "", "files": {"/libcxx/utils/libcxx/test/dsl.py": {"changes": [{"diff": "\n                 \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n             )\n \n-        return libcxx.test.format._parseLitOutput(out)\n+        return out\n \n \n @_memoizeExpensiveOperation(", "add": 1, "remove": 1, "filename": "/libcxx/utils/libcxx/test/dsl.py", "badparts": ["        return libcxx.test.format._parseLitOutput(out)"], "goodparts": ["        return out"]}], "source": "\n import os import pickle import pipes import platform import re import shutil import subprocess import tempfile import libcxx.test.format import lit import lit.LitConfig import lit.Test import lit.TestRunner import lit.util class ConfigurationError(Exception): pass class ConfigurationCompilationError(ConfigurationError): pass class ConfigurationRuntimeError(ConfigurationError): pass def _memoizeExpensiveOperation(extractCacheKey): \"\"\" Allows memoizing a very expensive operation. We pickle the cache key to make sure we store an immutable representation of it. If we stored an object and the object was referenced elsewhere, it could be changed from under our feet, which would break the cache. We also store the cache for a given function persistently across invocations of Lit. This dramatically speeds up the configuration of the test suite when invoking Lit repeatedly, which is important for developer workflow. However, with the current implementation that does not synchronize updates to the persistent cache, this also means that one should not call a memoized operation from multiple threads. This should normally not be a problem since Lit configuration is single-threaded. \"\"\" def decorator(function): def f(config, *args, **kwargs): cacheRoot=os.path.join(config.test_exec_root, \"__config_cache__\") persistentCache=os.path.join(cacheRoot, function.__name__) if not os.path.exists(cacheRoot): os.makedirs(cacheRoot) cache={} if os.path.exists(persistentCache): with open(persistentCache, \"rb\") as cacheFile: cache=pickle.load(cacheFile) cacheKey=pickle.dumps(extractCacheKey(config, *args, **kwargs)) if cacheKey not in cache: cache[cacheKey]=function(config, *args, **kwargs) with open(persistentCache, \"wb\") as cacheFile: pickle.dump(cache, cacheFile) return cache[cacheKey] return f return decorator def _executeWithFakeConfig(test, commands): \"\"\" Returns(stdout, stderr, exitCode, timeoutInfo, parsedCommands) \"\"\" litConfig=lit.LitConfig.LitConfig( progname=\"lit\", path=[], quiet=False, useValgrind=False, valgrindLeakCheck=False, valgrindArgs=[], noExecute=False, debug=False, isWindows=platform.system()==\"Windows\", order=\"smart\", params={}, ) return libcxx.test.format._executeScriptInternal(test, litConfig, commands) def _makeConfigTest(config): sourceRoot=os.path.join(config.test_exec_root, \"__config_src__\") execRoot=os.path.join(config.test_exec_root, \"__config_exec__\") for supportDir in(sourceRoot, execRoot): if not os.path.exists(supportDir): os.makedirs(supportDir) suite=lit.Test.TestSuite(\"__config__\", sourceRoot, execRoot, config) tmp=tempfile.NamedTemporaryFile(dir=sourceRoot, delete=False, suffix=\".cpp\") tmp.close() pathInSuite=[os.path.relpath(tmp.name, sourceRoot)] class TestWrapper(lit.Test.Test): def __enter__(self): testDir, _=libcxx.test.format._getTempPaths(self) os.makedirs(testDir) return self def __exit__(self, *args): testDir, _=libcxx.test.format._getTempPaths(self) shutil.rmtree(testDir) os.remove(tmp.name) return TestWrapper(suite, pathInSuite, config) @_memoizeExpensiveOperation(lambda c, s, f=[]:(c.substitutions, c.environment, s, f)) def sourceBuilds(config, source, additionalFlags=[]): \"\"\" Return whether the program in the given string builds successfully. This is done by compiling and linking a program that consists of the given source with the %{cxx} substitution, and seeing whether that succeeds. If any additional flags are passed, they are appended to the compiler invocation. \"\"\" with _makeConfigTest(config) as test: with open(test.getSourcePath(), \"w\") as sourceFile: sourceFile.write(source) _, _, exitCode, _, _=_executeWithFakeConfig( test,[\"%{{build}}{}\".format(\" \".join(additionalFlags))] ) return exitCode==0 @_memoizeExpensiveOperation( lambda c, p, args=None:(c.substitutions, c.environment, p, args) ) def programOutput(config, program, args=None): \"\"\" Compiles a program for the test target, run it on the test target and return the output. Note that execution of the program is done through the %{exec} substitution, which means that the program may be run on a remote host depending on what %{exec} does. \"\"\" if args is None: args=[] with _makeConfigTest(config) as test: with open(test.getSourcePath(), \"w\") as source: source.write(program) _, err, exitCode, _, buildcmd=_executeWithFakeConfig(test,[\"%{build}\"]) if exitCode !=0: raise ConfigurationCompilationError( \"Failed to build program, cmd:\\n{}\\nstderr is:\\n{}\".format( buildcmd, err ) ) out, err, exitCode, _, runcmd=_executeWithFakeConfig( test,[\"%{{run}}{}\".format(\" \".join(args))] ) if exitCode !=0: raise ConfigurationRuntimeError( \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err) ) return libcxx.test.format._parseLitOutput(out) @_memoizeExpensiveOperation( lambda c, p, args=None:(c.substitutions, c.environment, p, args) ) def programSucceeds(config, program, args=None): \"\"\" Compiles a program for the test target, run it on the test target and return whether it completed successfully. Note that execution of the program is done through the %{exec} substitution, which means that the program may be run on a remote host depending on what %{exec} does. \"\"\" try: programOutput(config, program, args) except ConfigurationRuntimeError: return False return True @_memoizeExpensiveOperation(lambda c, f:(c.substitutions, c.environment, f)) def hasCompileFlag(config, flag): \"\"\" Return whether the compiler in the configuration supports a given compiler flag. This is done by executing the %{cxx} substitution with the given flag and checking whether that succeeds. \"\"\" with _makeConfigTest(config) as test: out, err, exitCode, timeoutInfo, _=_executeWithFakeConfig( test, [ \"%{{cxx}} -xc++{} -Werror -fsyntax-only %{{flags}} %{{compile_flags}}{}\".format( os.devnull, flag ) ], ) return exitCode==0 @_memoizeExpensiveOperation(lambda c, s:(c.substitutions, c.environment, s)) def runScriptExitCode(config, script): \"\"\" Runs the given script as a Lit test, and returns the exit code of the execution. The script must be a list of commands, each of which being something that could appear on the right-hand-side of a `RUN:` keyword. \"\"\" with _makeConfigTest(config) as test: _, _, exitCode, _, _=_executeWithFakeConfig(test, script) return exitCode @_memoizeExpensiveOperation(lambda c, s:(c.substitutions, c.environment, s)) def commandOutput(config, command): \"\"\" Runs the given script as a Lit test, and returns the output. If the exit code isn't 0 an exception is raised. The script must be a list of commands, each of which being something that could appear on the right-hand-side of a `RUN:` keyword. \"\"\" with _makeConfigTest(config) as test: out, err, exitCode, _, cmd=_executeWithFakeConfig(test, command) if exitCode !=0: raise ConfigurationRuntimeError( \"Failed to run command:{}\\nstderr is:\\n{}\".format(cmd, err) ) return out @_memoizeExpensiveOperation(lambda c, l:(c.substitutions, c.environment, l)) def hasAnyLocale(config, locales): \"\"\" Return whether the runtime execution environment supports a given locale. Different systems may use different names for a locale, so this function checks whether any of the passed locale names is supported by setlocale() and returns true if one of them works. This is done by executing a program that tries to set the given locale using %{exec} --this means that the command may be executed on a remote host depending on the %{exec} substitution. \"\"\" program=\"\"\" int main(int, char**){ return 1;} int main(int argc, char** argv){ for(int i=1; i < argc; i++){ if(::setlocale(LC_ALL, argv[i]) !=NULL){ return 0; } } return 1; } \"\"\" return programSucceeds(config, program, args=[pipes.quote(l) for l in locales]) @_memoizeExpensiveOperation(lambda c, flags=\"\":(c.substitutions, c.environment, flags)) def compilerMacros(config, flags=\"\"): \"\"\" Return a dictionary of predefined compiler macros. The keys are strings representing macros, and the values are strings representing what each macro is defined to. If the optional `flags` argument(a string) is provided, these flags will be added to the compiler invocation when generating the macros. \"\"\" with _makeConfigTest(config) as test: with open(test.getSourcePath(), \"w\") as sourceFile: sourceFile.write( \"\"\" \"\"\" ) unparsedOutput, err, exitCode, _, cmd=_executeWithFakeConfig( test,[\"%{{cxx}} %s -dM -E %{{flags}} %{{compile_flags}}{}\".format(flags)] ) if exitCode !=0: raise ConfigurationCompilationError( \"Failed to retrieve compiler macros, compiler invocation is:\\n{}\\nstderr is:\\n{}\".format( cmd, err ) ) parsedMacros=dict() defines=( l.strip() for l in unparsedOutput.split(\"\\n\") if l.startswith(\" ) for line in defines: line=line[len(\" macro, _, value=line.partition(\" \") parsedMacros[macro]=value return parsedMacros def featureTestMacros(config, flags=\"\"): \"\"\" Return a dictionary of feature test macros. The keys are strings representing feature test macros, and the values are integers representing the value of the macro. \"\"\" allMacros=compilerMacros(config, flags) return{ m: int(v.rstrip(\"LlUu\")) for(m, v) in allMacros.items() if m.startswith(\"__cpp_\") } def _getSubstitution(substitution, config): for(orig, replacement) in config.substitutions: if orig==substitution: return replacement raise ValueError('Substitution{} is not in the config.'.format(substitution)) def _appendToSubstitution(substitutions, key, value): return[(k, v +\" \" +value) if k==key else(k, v) for(k, v) in substitutions] def _prependToSubstitution(substitutions, key, value): return[(k, value +\" \" +v) if k==key else(k, v) for(k, v) in substitutions] class ConfigAction(object): \"\"\" This class represents an action that can be performed on a Lit TestingConfig object. Examples of such actions are adding or modifying substitutions, Lit features, etc. This class only provides the interface of such actions, and it is meant to be subclassed appropriately to create new actions. \"\"\" def applyTo(self, config): \"\"\" Applies the action to the given configuration. This should modify the configuration object in place, and return nothing. If applying the action to the configuration would yield an invalid configuration, and it is possible to diagnose it here, this method should produce an error. For example, it should be an error to modify a substitution in a way that we know for sure is invalid(e.g. adding a compiler flag when we know the compiler doesn't support it). Failure to do so early may lead to difficult-to-diagnose issues down the road. \"\"\" pass def pretty(self, config, litParams): \"\"\" Returns a short and human-readable string describing what this action does. This is used for logging purposes when running the test suite, so it should be kept concise. \"\"\" pass class AddFeature(ConfigAction): \"\"\" This action defines the given Lit feature when running the test suite. The name of the feature can be a string or a callable, in which case it is called with the configuration to produce the feature name(as a string). \"\"\" def __init__(self, name): self._name=name def _getName(self, config): name=self._name(config) if callable(self._name) else self._name if not isinstance(name, str): raise ValueError( \"Lit feature did not resolve to a string(got{})\".format(name) ) return name def applyTo(self, config): config.available_features.add(self._getName(config)) def pretty(self, config, litParams): return \"add Lit feature{}\".format(self._getName(config)) class AddFlag(ConfigAction): \"\"\" This action adds the given flag to the %{flags} substitution. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) assert hasCompileFlag( config, flag ), \"Trying to enable flag{}, which is not supported\".format(flag) config.substitutions=_appendToSubstitution( config.substitutions, \"%{flags}\", flag ) def pretty(self, config, litParams): return \"add{} to %{{flags}}\".format(self._getFlag(config)) class AddFlagIfSupported(ConfigAction): \"\"\" This action adds the given flag to the %{flags} substitution, only if the compiler supports the flag. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) if hasCompileFlag(config, flag): config.substitutions=_appendToSubstitution( config.substitutions, \"%{flags}\", flag ) def pretty(self, config, litParams): return \"add{} to %{{flags}}\".format(self._getFlag(config)) class AddCompileFlag(ConfigAction): \"\"\" This action adds the given flag to the %{compile_flags} substitution. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) assert hasCompileFlag( config, flag ), \"Trying to enable compile flag{}, which is not supported\".format(flag) config.substitutions=_appendToSubstitution( config.substitutions, \"%{compile_flags}\", flag ) def pretty(self, config, litParams): return \"add{} to %{{compile_flags}}\".format(self._getFlag(config)) class AddLinkFlag(ConfigAction): \"\"\" This action appends the given flag to the %{link_flags} substitution. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) assert hasCompileFlag( config, flag ), \"Trying to enable link flag{}, which is not supported\".format(flag) config.substitutions=_appendToSubstitution( config.substitutions, \"%{link_flags}\", flag ) def pretty(self, config, litParams): return \"append{} to %{{link_flags}}\".format(self._getFlag(config)) class PrependLinkFlag(ConfigAction): \"\"\" This action prepends the given flag to the %{link_flags} substitution. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) assert hasCompileFlag( config, flag ), \"Trying to enable link flag{}, which is not supported\".format(flag) config.substitutions=_prependToSubstitution( config.substitutions, \"%{link_flags}\", flag ) def pretty(self, config, litParams): return \"prepend{} to %{{link_flags}}\".format(self._getFlag(config)) class AddOptionalWarningFlag(ConfigAction): \"\"\" This action adds the given warning flag to the %{compile_flags} substitution, if it is supported by the compiler. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) if hasCompileFlag(config, \"-Werror \" +flag): config.substitutions=_appendToSubstitution( config.substitutions, \"%{compile_flags}\", flag ) def pretty(self, config, litParams): return \"add{} to %{{compile_flags}}\".format(self._getFlag(config)) class AddSubstitution(ConfigAction): \"\"\" This action adds the given substitution to the Lit configuration. The substitution can be a string or a callable, in which case it is called with the configuration to produce the actual substitution(as a string). \"\"\" def __init__(self, key, substitution): self._key=key self._getSub=( lambda config: substitution(config) if callable(substitution) else substitution ) def applyTo(self, config): key=self._key sub=self._getSub(config) config.substitutions.append((key, sub)) def pretty(self, config, litParams): return \"add substitution{}={}\".format(self._key, self._getSub(config)) class Feature(object): \"\"\" Represents a Lit available feature that is enabled whenever it is supported. A feature like this informs the test suite about a capability of the compiler, platform, etc. Unlike Parameters, it does not make sense to explicitly control whether a Feature is enabled --it should be enabled whenever it is supported. \"\"\" def __init__(self, name, actions=None, when=lambda _: True): \"\"\" Create a Lit feature for consumption by a test suite. -name The name of the feature. This is what will end up in Lit's available features if the feature is enabled. This can be either a string or a callable, in which case it is passed the TestingConfig and should generate a string representing the name of the feature. -actions An optional list of ConfigActions to apply when the feature is supported. An AddFeature action is always created regardless of any actions supplied here --these actions are meant to perform more than setting a corresponding Lit feature(e.g. adding compiler flags). If 'actions' is a callable, it is called with the current configuration object to generate the actual list of actions. -when A callable that gets passed a TestingConfig and should return a boolean representing whether the feature is supported in that configuration. For example, this can use `hasCompileFlag` to check whether the compiler supports the flag that the feature represents. If omitted, the feature will always be considered supported. \"\"\" self._name=name self._actions=[] if actions is None else actions self._isSupported=when def _getName(self, config): name=self._name(config) if callable(self._name) else self._name if not isinstance(name, str): raise ValueError( \"Feature did not resolve to a name that's a string, got{}\".format(name) ) return name def getActions(self, config): \"\"\" Return the list of actions associated to this feature. If the feature is not supported, an empty list is returned. If the feature is supported, an `AddFeature` action is automatically added to the returned list of actions, in addition to any actions provided on construction. \"\"\" if not self._isSupported(config): return[] else: actions=( self._actions(config) if callable(self._actions) else self._actions ) return[AddFeature(self._getName(config))] +actions def pretty(self, config): \"\"\" Returns the Feature's name. \"\"\" return self._getName(config) def _str_to_bool(s): \"\"\" Convert a string value to a boolean. True values are \"y\", \"yes\", \"t\", \"true\", \"on\" and \"1\", regardless of capitalization. False values are \"n\", \"no\", \"f\", \"false\", \"off\" and \"0\", regardless of capitalization. \"\"\" trueVals=[\"y\", \"yes\", \"t\", \"true\", \"on\", \"1\"] falseVals=[\"n\", \"no\", \"f\", \"false\", \"off\", \"0\"] lower=s.lower() if lower in trueVals: return True elif lower in falseVals: return False else: raise ValueError(\"Got string '{}', which isn't a valid boolean\".format(s)) def _parse_parameter(s, type): if type is bool and isinstance(s, str): return _str_to_bool(s) elif type is list and isinstance(s, str): return[x.strip() for x in s.split(\",\") if x.strip()] return type(s) class Parameter(object): \"\"\" Represents a parameter of a Lit test suite. Parameters are used to customize the behavior of test suites in a user controllable way. There are two ways of setting the value of a Parameter. The first one is to pass `--param <KEY>=<VALUE>` when running Lit(or equivalently to set `litConfig.params[KEY]=VALUE` somewhere in the Lit configuration files. This method will set the parameter globally for all test suites being run. The second method is to set `config.KEY=VALUE` somewhere in the Lit configuration files, which sets the parameter only for the test suite(s) that use that `config` object. Parameters can have multiple possible values, and they can have a default value when left unspecified. They can also have any number of ConfigActions associated to them, in which case the actions will be performed on the TestingConfig if the parameter is enabled. Depending on the actions associated to a Parameter, it may be an error to enable the Parameter if some actions are not supported in the given configuration. For example, trying to set the compilation standard to C++23 when `-std=c++23` is not supported by the compiler would be an error. \"\"\" def __init__(self, name, type, help, actions, choices=None, default=None): \"\"\" Create a Lit parameter to customize the behavior of a test suite. -name The name of the parameter that can be used to set it on the command-line. On the command-line, the parameter can be set using `--param <name>=<value>` when running Lit. This must be non-empty. -choices An optional non-empty set of possible values for this parameter. If provided, this must be anything that can be iterated. It is an error if the parameter is given a value that is not in that set, whether explicitly or through a default value. -type A callable that can be used to parse the value of the parameter given on the command-line. As a special case, using the type `bool` also allows parsing strings with boolean-like contents, and the type `list` will parse a string delimited by commas into a list of the substrings. -help A string explaining the parameter, for documentation purposes. TODO: We should be able to surface those from the Lit command-line. -actions A callable that gets passed the parsed value of the parameter(either the one passed on the command-line or the default one), and that returns a list of ConfigAction to perform given the value of the parameter. All the ConfigAction must be supported in the given configuration. -default An optional default value to use for the parameter when no value is provided on the command-line. If the default value is a callable, it is called with the TestingConfig and should return the default value for the parameter. Whether the default value is computed or specified directly, it must be in the 'choices' provided for that Parameter. \"\"\" self._name=name if len(self._name)==0: raise ValueError(\"Parameter name must not be the empty string\") if choices is not None: self._choices=list(choices) if len(self._choices)==0: raise ValueError( \"Parameter '{}' must be given at least one possible value\".format( self._name ) ) else: self._choices=None self._parse=lambda x: _parse_parameter(x, type) self._help=help self._actions=actions self._default=default def _getValue(self, config, litParams): \"\"\" Return the value of the parameter given the configuration objects. \"\"\" param=getattr(config, self.name, None) param=litParams.get(self.name, param) if param is None and self._default is None: raise ValueError( \"Parameter{} doesn't have a default value, but it was not specified in the Lit parameters or in the Lit config\".format( self.name ) ) getDefault=( lambda: self._default(config) if callable(self._default) else self._default ) if param is not None: (pretty, value)=(param, self._parse(param)) else: value=getDefault() pretty=\"{}(default)\".format(value) if self._choices and value not in self._choices: raise ValueError( \"Got value '{}' for parameter '{}', which is not in the provided set of possible choices:{}\".format( value, self.name, self._choices ) ) return(pretty, value) @property def name(self): \"\"\" Return the name of the parameter. This is the name that can be used to set the parameter on the command-line when running Lit. \"\"\" return self._name def getActions(self, config, litParams): \"\"\" Return the list of actions associated to this value of the parameter. \"\"\" (_, parameterValue)=self._getValue(config, litParams) return self._actions(parameterValue) def pretty(self, config, litParams): \"\"\" Return a pretty representation of the parameter's name and value. \"\"\" (prettyParameterValue, _)=self._getValue(config, litParams) return \"{}={}\".format(self.name, prettyParameterValue) ", "sourceWithComments": "# ===----------------------------------------------------------------------===##\n#\n# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n# See https://llvm.org/LICENSE.txt for license information.\n# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n#\n# ===----------------------------------------------------------------------===##\n\nimport os\nimport pickle\nimport pipes\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport tempfile\n\nimport libcxx.test.format\nimport lit\nimport lit.LitConfig\nimport lit.Test\nimport lit.TestRunner\nimport lit.util\n\n\nclass ConfigurationError(Exception):\n    pass\n\n\nclass ConfigurationCompilationError(ConfigurationError):\n    pass\n\n\nclass ConfigurationRuntimeError(ConfigurationError):\n    pass\n\n\ndef _memoizeExpensiveOperation(extractCacheKey):\n    \"\"\"\n    Allows memoizing a very expensive operation.\n\n    We pickle the cache key to make sure we store an immutable representation\n    of it. If we stored an object and the object was referenced elsewhere, it\n    could be changed from under our feet, which would break the cache.\n\n    We also store the cache for a given function persistently across invocations\n    of Lit. This dramatically speeds up the configuration of the test suite when\n    invoking Lit repeatedly, which is important for developer workflow. However,\n    with the current implementation that does not synchronize updates to the\n    persistent cache, this also means that one should not call a memoized\n    operation from multiple threads. This should normally not be a problem\n    since Lit configuration is single-threaded.\n    \"\"\"\n\n    def decorator(function):\n        def f(config, *args, **kwargs):\n            cacheRoot = os.path.join(config.test_exec_root, \"__config_cache__\")\n            persistentCache = os.path.join(cacheRoot, function.__name__)\n            if not os.path.exists(cacheRoot):\n                os.makedirs(cacheRoot)\n\n            cache = {}\n            # Load a cache from a previous Lit invocation if there is one.\n            if os.path.exists(persistentCache):\n                with open(persistentCache, \"rb\") as cacheFile:\n                    cache = pickle.load(cacheFile)\n\n            cacheKey = pickle.dumps(extractCacheKey(config, *args, **kwargs))\n            if cacheKey not in cache:\n                cache[cacheKey] = function(config, *args, **kwargs)\n                # Update the persistent cache so it knows about the new key\n                with open(persistentCache, \"wb\") as cacheFile:\n                    pickle.dump(cache, cacheFile)\n            return cache[cacheKey]\n\n        return f\n\n    return decorator\n\n\ndef _executeWithFakeConfig(test, commands):\n    \"\"\"\n    Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n    \"\"\"\n    litConfig = lit.LitConfig.LitConfig(\n        progname=\"lit\",\n        path=[],\n        quiet=False,\n        useValgrind=False,\n        valgrindLeakCheck=False,\n        valgrindArgs=[],\n        noExecute=False,\n        debug=False,\n        isWindows=platform.system() == \"Windows\",\n        order=\"smart\",\n        params={},\n    )\n    return libcxx.test.format._executeScriptInternal(test, litConfig, commands)\n\n\ndef _makeConfigTest(config):\n    # Make sure the support directories exist, which is needed to create\n    # the temporary file %t below.\n    sourceRoot = os.path.join(config.test_exec_root, \"__config_src__\")\n    execRoot = os.path.join(config.test_exec_root, \"__config_exec__\")\n    for supportDir in (sourceRoot, execRoot):\n        if not os.path.exists(supportDir):\n            os.makedirs(supportDir)\n\n    # Create a dummy test suite and single dummy test inside it. As part of\n    # the Lit configuration, automatically do the equivalent of 'mkdir %T'\n    # and 'rm -r %T' to avoid cluttering the build directory.\n    suite = lit.Test.TestSuite(\"__config__\", sourceRoot, execRoot, config)\n    tmp = tempfile.NamedTemporaryFile(dir=sourceRoot, delete=False, suffix=\".cpp\")\n    tmp.close()\n    pathInSuite = [os.path.relpath(tmp.name, sourceRoot)]\n\n    class TestWrapper(lit.Test.Test):\n        def __enter__(self):\n            testDir, _ = libcxx.test.format._getTempPaths(self)\n            os.makedirs(testDir)\n            return self\n\n        def __exit__(self, *args):\n            testDir, _ = libcxx.test.format._getTempPaths(self)\n            shutil.rmtree(testDir)\n            os.remove(tmp.name)\n\n    return TestWrapper(suite, pathInSuite, config)\n\n\n@_memoizeExpensiveOperation(lambda c, s, f=[]: (c.substitutions, c.environment, s, f))\ndef sourceBuilds(config, source, additionalFlags=[]):\n    \"\"\"\n    Return whether the program in the given string builds successfully.\n\n    This is done by compiling and linking a program that consists of the given\n    source with the %{cxx} substitution, and seeing whether that succeeds. If\n    any additional flags are passed, they are appended to the compiler invocation.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        with open(test.getSourcePath(), \"w\") as sourceFile:\n            sourceFile.write(source)\n        _, _, exitCode, _, _ = _executeWithFakeConfig(\n            test, [\"%{{build}} {}\".format(\" \".join(additionalFlags))]\n        )\n        return exitCode == 0\n\n\n@_memoizeExpensiveOperation(\n    lambda c, p, args=None: (c.substitutions, c.environment, p, args)\n)\ndef programOutput(config, program, args=None):\n    \"\"\"\n    Compiles a program for the test target, run it on the test target and return\n    the output.\n\n    Note that execution of the program is done through the %{exec} substitution,\n    which means that the program may be run on a remote host depending on what\n    %{exec} does.\n    \"\"\"\n    if args is None:\n        args = []\n    with _makeConfigTest(config) as test:\n        with open(test.getSourcePath(), \"w\") as source:\n            source.write(program)\n        _, err, exitCode, _, buildcmd = _executeWithFakeConfig(test, [\"%{build}\"])\n        if exitCode != 0:\n            raise ConfigurationCompilationError(\n                \"Failed to build program, cmd:\\n{}\\nstderr is:\\n{}\".format(\n                    buildcmd, err\n                )\n            )\n\n        out, err, exitCode, _, runcmd = _executeWithFakeConfig(\n            test, [\"%{{run}} {}\".format(\" \".join(args))]\n        )\n        if exitCode != 0:\n            raise ConfigurationRuntimeError(\n                \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n            )\n\n        return libcxx.test.format._parseLitOutput(out)\n\n\n@_memoizeExpensiveOperation(\n    lambda c, p, args=None: (c.substitutions, c.environment, p, args)\n)\ndef programSucceeds(config, program, args=None):\n    \"\"\"\n    Compiles a program for the test target, run it on the test target and return\n    whether it completed successfully.\n\n    Note that execution of the program is done through the %{exec} substitution,\n    which means that the program may be run on a remote host depending on what\n    %{exec} does.\n    \"\"\"\n    try:\n        programOutput(config, program, args)\n    except ConfigurationRuntimeError:\n        return False\n    return True\n\n\n@_memoizeExpensiveOperation(lambda c, f: (c.substitutions, c.environment, f))\ndef hasCompileFlag(config, flag):\n    \"\"\"\n    Return whether the compiler in the configuration supports a given compiler flag.\n\n    This is done by executing the %{cxx} substitution with the given flag and\n    checking whether that succeeds.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        out, err, exitCode, timeoutInfo, _ = _executeWithFakeConfig(\n            test,\n            [\n                \"%{{cxx}} -xc++ {} -Werror -fsyntax-only %{{flags}} %{{compile_flags}} {}\".format(\n                    os.devnull, flag\n                )\n            ],\n        )\n        return exitCode == 0\n\n\n@_memoizeExpensiveOperation(lambda c, s: (c.substitutions, c.environment, s))\ndef runScriptExitCode(config, script):\n    \"\"\"\n    Runs the given script as a Lit test, and returns the exit code of the execution.\n\n    The script must be a list of commands, each of which being something that\n    could appear on the right-hand-side of a `RUN:` keyword.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        _, _, exitCode, _, _ = _executeWithFakeConfig(test, script)\n        return exitCode\n\n\n@_memoizeExpensiveOperation(lambda c, s: (c.substitutions, c.environment, s))\ndef commandOutput(config, command):\n    \"\"\"\n    Runs the given script as a Lit test, and returns the output.\n    If the exit code isn't 0 an exception is raised.\n\n    The script must be a list of commands, each of which being something that\n    could appear on the right-hand-side of a `RUN:` keyword.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        out, err, exitCode, _, cmd = _executeWithFakeConfig(test, command)\n        if exitCode != 0:\n            raise ConfigurationRuntimeError(\n                \"Failed to run command: {}\\nstderr is:\\n{}\".format(cmd, err)\n            )\n        return out\n\n\n@_memoizeExpensiveOperation(lambda c, l: (c.substitutions, c.environment, l))\ndef hasAnyLocale(config, locales):\n    \"\"\"\n    Return whether the runtime execution environment supports a given locale.\n    Different systems may use different names for a locale, so this function checks\n    whether any of the passed locale names is supported by setlocale() and returns\n    true if one of them works.\n\n    This is done by executing a program that tries to set the given locale using\n    %{exec} -- this means that the command may be executed on a remote host\n    depending on the %{exec} substitution.\n    \"\"\"\n    program = \"\"\"\n    #include <stddef.h>\n    #if defined(_LIBCPP_HAS_NO_LOCALIZATION)\n      int main(int, char**) { return 1; }\n    #else\n      #include <locale.h>\n      int main(int argc, char** argv) {\n        for (int i = 1; i < argc; i++) {\n          if (::setlocale(LC_ALL, argv[i]) != NULL) {\n            return 0;\n          }\n        }\n        return 1;\n      }\n    #endif\n  \"\"\"\n    return programSucceeds(config, program, args=[pipes.quote(l) for l in locales])\n\n\n@_memoizeExpensiveOperation(lambda c, flags=\"\": (c.substitutions, c.environment, flags))\ndef compilerMacros(config, flags=\"\"):\n    \"\"\"\n    Return a dictionary of predefined compiler macros.\n\n    The keys are strings representing macros, and the values are strings\n    representing what each macro is defined to.\n\n    If the optional `flags` argument (a string) is provided, these flags will\n    be added to the compiler invocation when generating the macros.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        with open(test.getSourcePath(), \"w\") as sourceFile:\n            sourceFile.write(\n                \"\"\"\n      #if __has_include(<__config_site>)\n      #  include <__config_site>\n      #endif\n      \"\"\"\n            )\n        unparsedOutput, err, exitCode, _, cmd = _executeWithFakeConfig(\n            test, [\"%{{cxx}} %s -dM -E %{{flags}} %{{compile_flags}} {}\".format(flags)]\n        )\n        if exitCode != 0:\n            raise ConfigurationCompilationError(\n                \"Failed to retrieve compiler macros, compiler invocation is:\\n{}\\nstderr is:\\n{}\".format(\n                    cmd, err\n                )\n            )\n        parsedMacros = dict()\n        defines = (\n            l.strip() for l in unparsedOutput.split(\"\\n\") if l.startswith(\"#define \")\n        )\n        for line in defines:\n            line = line[len(\"#define \") :]\n            macro, _, value = line.partition(\" \")\n            parsedMacros[macro] = value\n        return parsedMacros\n\n\ndef featureTestMacros(config, flags=\"\"):\n    \"\"\"\n    Return a dictionary of feature test macros.\n\n    The keys are strings representing feature test macros, and the values are\n    integers representing the value of the macro.\n    \"\"\"\n    allMacros = compilerMacros(config, flags)\n    return {\n        m: int(v.rstrip(\"LlUu\"))\n        for (m, v) in allMacros.items()\n        if m.startswith(\"__cpp_\")\n    }\n\n\ndef _getSubstitution(substitution, config):\n  for (orig, replacement) in config.substitutions:\n    if orig == substitution:\n      return replacement\n  raise ValueError('Substitution {} is not in the config.'.format(substitution))\n\ndef _appendToSubstitution(substitutions, key, value):\n    return [(k, v + \" \" + value) if k == key else (k, v) for (k, v) in substitutions]\n\n\ndef _prependToSubstitution(substitutions, key, value):\n    return [(k, value + \" \" + v) if k == key else (k, v) for (k, v) in substitutions]\n\n\nclass ConfigAction(object):\n    \"\"\"\n    This class represents an action that can be performed on a Lit TestingConfig\n    object.\n\n    Examples of such actions are adding or modifying substitutions, Lit features,\n    etc. This class only provides the interface of such actions, and it is meant\n    to be subclassed appropriately to create new actions.\n    \"\"\"\n\n    def applyTo(self, config):\n        \"\"\"\n        Applies the action to the given configuration.\n\n        This should modify the configuration object in place, and return nothing.\n\n        If applying the action to the configuration would yield an invalid\n        configuration, and it is possible to diagnose it here, this method\n        should produce an error. For example, it should be an error to modify\n        a substitution in a way that we know for sure is invalid (e.g. adding\n        a compiler flag when we know the compiler doesn't support it). Failure\n        to do so early may lead to difficult-to-diagnose issues down the road.\n        \"\"\"\n        pass\n\n    def pretty(self, config, litParams):\n        \"\"\"\n        Returns a short and human-readable string describing what this action does.\n\n        This is used for logging purposes when running the test suite, so it should\n        be kept concise.\n        \"\"\"\n        pass\n\n\nclass AddFeature(ConfigAction):\n    \"\"\"\n    This action defines the given Lit feature when running the test suite.\n\n    The name of the feature can be a string or a callable, in which case it is\n    called with the configuration to produce the feature name (as a string).\n    \"\"\"\n\n    def __init__(self, name):\n        self._name = name\n\n    def _getName(self, config):\n        name = self._name(config) if callable(self._name) else self._name\n        if not isinstance(name, str):\n            raise ValueError(\n                \"Lit feature did not resolve to a string (got {})\".format(name)\n            )\n        return name\n\n    def applyTo(self, config):\n        config.available_features.add(self._getName(config))\n\n    def pretty(self, config, litParams):\n        return \"add Lit feature {}\".format(self._getName(config))\n\n\nclass AddFlag(ConfigAction):\n    \"\"\"\n    This action adds the given flag to the %{flags} substitution.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        assert hasCompileFlag(\n            config, flag\n        ), \"Trying to enable flag {}, which is not supported\".format(flag)\n        config.substitutions = _appendToSubstitution(\n            config.substitutions, \"%{flags}\", flag\n        )\n\n    def pretty(self, config, litParams):\n        return \"add {} to %{{flags}}\".format(self._getFlag(config))\n\nclass AddFlagIfSupported(ConfigAction):\n    \"\"\"\n    This action adds the given flag to the %{flags} substitution, only if\n    the compiler supports the flag.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        if hasCompileFlag(config, flag):\n            config.substitutions = _appendToSubstitution(\n                config.substitutions, \"%{flags}\", flag\n            )\n\n    def pretty(self, config, litParams):\n        return \"add {} to %{{flags}}\".format(self._getFlag(config))\n\n\nclass AddCompileFlag(ConfigAction):\n    \"\"\"\n    This action adds the given flag to the %{compile_flags} substitution.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        assert hasCompileFlag(\n            config, flag\n        ), \"Trying to enable compile flag {}, which is not supported\".format(flag)\n        config.substitutions = _appendToSubstitution(\n            config.substitutions, \"%{compile_flags}\", flag\n        )\n\n    def pretty(self, config, litParams):\n        return \"add {} to %{{compile_flags}}\".format(self._getFlag(config))\n\n\nclass AddLinkFlag(ConfigAction):\n    \"\"\"\n    This action appends the given flag to the %{link_flags} substitution.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        assert hasCompileFlag(\n            config, flag\n        ), \"Trying to enable link flag {}, which is not supported\".format(flag)\n        config.substitutions = _appendToSubstitution(\n            config.substitutions, \"%{link_flags}\", flag\n        )\n\n    def pretty(self, config, litParams):\n        return \"append {} to %{{link_flags}}\".format(self._getFlag(config))\n\n\nclass PrependLinkFlag(ConfigAction):\n    \"\"\"\n    This action prepends the given flag to the %{link_flags} substitution.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        assert hasCompileFlag(\n            config, flag\n        ), \"Trying to enable link flag {}, which is not supported\".format(flag)\n        config.substitutions = _prependToSubstitution(\n            config.substitutions, \"%{link_flags}\", flag\n        )\n\n    def pretty(self, config, litParams):\n        return \"prepend {} to %{{link_flags}}\".format(self._getFlag(config))\n\n\nclass AddOptionalWarningFlag(ConfigAction):\n    \"\"\"\n    This action adds the given warning flag to the %{compile_flags} substitution,\n    if it is supported by the compiler.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        # Use -Werror to make sure we see an error about the flag being unsupported.\n        if hasCompileFlag(config, \"-Werror \" + flag):\n            config.substitutions = _appendToSubstitution(\n                config.substitutions, \"%{compile_flags}\", flag\n            )\n\n    def pretty(self, config, litParams):\n        return \"add {} to %{{compile_flags}}\".format(self._getFlag(config))\n\n\nclass AddSubstitution(ConfigAction):\n    \"\"\"\n    This action adds the given substitution to the Lit configuration.\n\n    The substitution can be a string or a callable, in which case it is called\n    with the configuration to produce the actual substitution (as a string).\n    \"\"\"\n\n    def __init__(self, key, substitution):\n        self._key = key\n        self._getSub = (\n            lambda config: substitution(config)\n            if callable(substitution)\n            else substitution\n        )\n\n    def applyTo(self, config):\n        key = self._key\n        sub = self._getSub(config)\n        config.substitutions.append((key, sub))\n\n    def pretty(self, config, litParams):\n        return \"add substitution {} = {}\".format(self._key, self._getSub(config))\n\n\nclass Feature(object):\n    \"\"\"\n    Represents a Lit available feature that is enabled whenever it is supported.\n\n    A feature like this informs the test suite about a capability of the compiler,\n    platform, etc. Unlike Parameters, it does not make sense to explicitly\n    control whether a Feature is enabled -- it should be enabled whenever it\n    is supported.\n    \"\"\"\n\n    def __init__(self, name, actions=None, when=lambda _: True):\n        \"\"\"\n        Create a Lit feature for consumption by a test suite.\n\n        - name\n            The name of the feature. This is what will end up in Lit's available\n            features if the feature is enabled. This can be either a string or a\n            callable, in which case it is passed the TestingConfig and should\n            generate a string representing the name of the feature.\n\n        - actions\n            An optional list of ConfigActions to apply when the feature is supported.\n            An AddFeature action is always created regardless of any actions supplied\n            here -- these actions are meant to perform more than setting a corresponding\n            Lit feature (e.g. adding compiler flags). If 'actions' is a callable, it\n            is called with the current configuration object to generate the actual\n            list of actions.\n\n        - when\n            A callable that gets passed a TestingConfig and should return a\n            boolean representing whether the feature is supported in that\n            configuration. For example, this can use `hasCompileFlag` to\n            check whether the compiler supports the flag that the feature\n            represents. If omitted, the feature will always be considered\n            supported.\n        \"\"\"\n        self._name = name\n        self._actions = [] if actions is None else actions\n        self._isSupported = when\n\n    def _getName(self, config):\n        name = self._name(config) if callable(self._name) else self._name\n        if not isinstance(name, str):\n            raise ValueError(\n                \"Feature did not resolve to a name that's a string, got {}\".format(name)\n            )\n        return name\n\n    def getActions(self, config):\n        \"\"\"\n        Return the list of actions associated to this feature.\n\n        If the feature is not supported, an empty list is returned.\n        If the feature is supported, an `AddFeature` action is automatically added\n        to the returned list of actions, in addition to any actions provided on\n        construction.\n        \"\"\"\n        if not self._isSupported(config):\n            return []\n        else:\n            actions = (\n                self._actions(config) if callable(self._actions) else self._actions\n            )\n            return [AddFeature(self._getName(config))] + actions\n\n    def pretty(self, config):\n        \"\"\"\n        Returns the Feature's name.\n        \"\"\"\n        return self._getName(config)\n\n\ndef _str_to_bool(s):\n    \"\"\"\n    Convert a string value to a boolean.\n\n    True values are \"y\", \"yes\", \"t\", \"true\", \"on\" and \"1\", regardless of capitalization.\n    False values are \"n\", \"no\", \"f\", \"false\", \"off\" and \"0\", regardless of capitalization.\n    \"\"\"\n    trueVals = [\"y\", \"yes\", \"t\", \"true\", \"on\", \"1\"]\n    falseVals = [\"n\", \"no\", \"f\", \"false\", \"off\", \"0\"]\n    lower = s.lower()\n    if lower in trueVals:\n        return True\n    elif lower in falseVals:\n        return False\n    else:\n        raise ValueError(\"Got string '{}', which isn't a valid boolean\".format(s))\n\n\ndef _parse_parameter(s, type):\n    if type is bool and isinstance(s, str):\n        return _str_to_bool(s)\n    elif type is list and isinstance(s, str):\n        return [x.strip() for x in s.split(\",\") if x.strip()]\n    return type(s)\n\n\nclass Parameter(object):\n    \"\"\"\n    Represents a parameter of a Lit test suite.\n\n    Parameters are used to customize the behavior of test suites in a user\n    controllable way. There are two ways of setting the value of a Parameter.\n    The first one is to pass `--param <KEY>=<VALUE>` when running Lit (or\n    equivalently to set `litConfig.params[KEY] = VALUE` somewhere in the\n    Lit configuration files. This method will set the parameter globally for\n    all test suites being run.\n\n    The second method is to set `config.KEY = VALUE` somewhere in the Lit\n    configuration files, which sets the parameter only for the test suite(s)\n    that use that `config` object.\n\n    Parameters can have multiple possible values, and they can have a default\n    value when left unspecified. They can also have any number of ConfigActions\n    associated to them, in which case the actions will be performed on the\n    TestingConfig if the parameter is enabled. Depending on the actions\n    associated to a Parameter, it may be an error to enable the Parameter\n    if some actions are not supported in the given configuration. For example,\n    trying to set the compilation standard to C++23 when `-std=c++23` is not\n    supported by the compiler would be an error.\n    \"\"\"\n\n    def __init__(self, name, type, help, actions, choices=None, default=None):\n        \"\"\"\n        Create a Lit parameter to customize the behavior of a test suite.\n\n        - name\n            The name of the parameter that can be used to set it on the command-line.\n            On the command-line, the parameter can be set using `--param <name>=<value>`\n            when running Lit. This must be non-empty.\n\n        - choices\n            An optional non-empty set of possible values for this parameter. If provided,\n            this must be anything that can be iterated. It is an error if the parameter\n            is given a value that is not in that set, whether explicitly or through a\n            default value.\n\n        - type\n            A callable that can be used to parse the value of the parameter given\n            on the command-line. As a special case, using the type `bool` also\n            allows parsing strings with boolean-like contents, and the type `list`\n            will parse a string delimited by commas into a list of the substrings.\n\n        - help\n            A string explaining the parameter, for documentation purposes.\n            TODO: We should be able to surface those from the Lit command-line.\n\n        - actions\n            A callable that gets passed the parsed value of the parameter (either\n            the one passed on the command-line or the default one), and that returns\n            a list of ConfigAction to perform given the value of the parameter.\n            All the ConfigAction must be supported in the given configuration.\n\n        - default\n            An optional default value to use for the parameter when no value is\n            provided on the command-line. If the default value is a callable, it\n            is called with the TestingConfig and should return the default value\n            for the parameter. Whether the default value is computed or specified\n            directly, it must be in the 'choices' provided for that Parameter.\n        \"\"\"\n        self._name = name\n        if len(self._name) == 0:\n            raise ValueError(\"Parameter name must not be the empty string\")\n\n        if choices is not None:\n            self._choices = list(choices)  # should be finite\n            if len(self._choices) == 0:\n                raise ValueError(\n                    \"Parameter '{}' must be given at least one possible value\".format(\n                        self._name\n                    )\n                )\n        else:\n            self._choices = None\n\n        self._parse = lambda x: _parse_parameter(x, type)\n        self._help = help\n        self._actions = actions\n        self._default = default\n\n    def _getValue(self, config, litParams):\n        \"\"\"\n        Return the value of the parameter given the configuration objects.\n        \"\"\"\n        param = getattr(config, self.name, None)\n        param = litParams.get(self.name, param)\n        if param is None and self._default is None:\n            raise ValueError(\n                \"Parameter {} doesn't have a default value, but it was not specified in the Lit parameters or in the Lit config\".format(\n                    self.name\n                )\n            )\n        getDefault = (\n            lambda: self._default(config) if callable(self._default) else self._default\n        )\n\n        if param is not None:\n            (pretty, value) = (param, self._parse(param))\n        else:\n            value = getDefault()\n            pretty = \"{} (default)\".format(value)\n\n        if self._choices and value not in self._choices:\n            raise ValueError(\n                \"Got value '{}' for parameter '{}', which is not in the provided set of possible choices: {}\".format(\n                    value, self.name, self._choices\n                )\n            )\n        return (pretty, value)\n\n    @property\n    def name(self):\n        \"\"\"\n        Return the name of the parameter.\n\n        This is the name that can be used to set the parameter on the command-line\n        when running Lit.\n        \"\"\"\n        return self._name\n\n    def getActions(self, config, litParams):\n        \"\"\"\n        Return the list of actions associated to this value of the parameter.\n        \"\"\"\n        (_, parameterValue) = self._getValue(config, litParams)\n        return self._actions(parameterValue)\n\n    def pretty(self, config, litParams):\n        \"\"\"\n        Return a pretty representation of the parameter's name and value.\n        \"\"\"\n        (prettyParameterValue, _) = self._getValue(config, litParams)\n        return \"{}={}\".format(self.name, prettyParameterValue)\n"}, "/libcxx/utils/libcxx/test/format.py": {"changes": [{"diff": "\n     for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n         assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n \n-def _parseLitOutput(fullOutput):\n-    \"\"\"\n-    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n-\n-    This takes output of the form\n-\n-        $ \":\" \"RUN: at line 11\"\n-        $ \"echo\" \"OUTPUT1\"\n-        # command output:\n-        OUTPUT1\n-\n-        $ \":\" \"RUN: at line 12\"\n-        $ \"echo\" \"OUTPUT2\"\n-        # command output:\n-        OUTPUT2\n-\n-    and returns a string containing\n-\n-        OUTPUT1\n-        OUTPUT2\n-\n-    as-if the commands had been run directly. This is a workaround for the fact\n-    that Lit doesn't let us execute ShTest and retrieve the raw output without\n-    injecting additional Lit output around it.\n-    \"\"\"\n-    parsed = ''\n-    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n-        if output: # skip blank lines\n-            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n-            if commandOutput:\n-                parsed += commandOutput.group(1)\n-    return parsed\n-\n def _executeScriptInternal(test, litConfig, commands):\n     \"\"\"\n     Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n", "add": 0, "remove": 33, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["def _parseLitOutput(fullOutput):", "    \"\"\"", "    Parse output of a Lit ShTest to extract the actual output of the contained commands.", "    This takes output of the form", "        $ \":\" \"RUN: at line 11\"", "        $ \"echo\" \"OUTPUT1\"", "        OUTPUT1", "        $ \":\" \"RUN: at line 12\"", "        $ \"echo\" \"OUTPUT2\"", "        OUTPUT2", "    and returns a string containing", "        OUTPUT1", "        OUTPUT2", "    as-if the commands had been run directly. This is a workaround for the fact", "    that Lit doesn't let us execute ShTest and retrieve the raw output without", "    injecting additional Lit output around it.", "    \"\"\"", "    parsed = ''", "    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):", "        if output: # skip blank lines", "            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)", "            if commandOutput:", "                parsed += commandOutput.group(1)", "    return parsed"], "goodparts": []}, {"diff": "\n     _, tmpBase = _getTempPaths(test)\n     execDir = os.path.dirname(test.getExecPath())\n     res = lit.TestRunner.executeScriptInternal(\n-        test, litConfig, tmpBase, parsedCommands, execDir\n+        test, litConfig, tmpBase, parsedCommands, execDir, debug=False\n     )\n     if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n         res = (\"\", res.output, 127, None)\n     (out, err, exitCode, timeoutInfo) = res\n \n-    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n-    #       split any stderr output that is included in stdout. It shouldn't be there, but\n-    #       the Lit internal shell conflates stderr and stdout.\n-    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n-    if conflatedErrorOutput:\n-        conflatedErrorOutput = conflatedErrorOutput.group(0)\n-        out = out[: -len(conflatedErrorOutput)]\n-        err += conflatedErrorOutput\n-\n     return (out, err, exitCode, timeoutInfo, parsedCommands)\n \n \n", "add": 1, "remove": 10, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["        test, litConfig, tmpBase, parsedCommands, execDir", "    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)", "    if conflatedErrorOutput:", "        conflatedErrorOutput = conflatedErrorOutput.group(0)", "        out = out[: -len(conflatedErrorOutput)]", "        err += conflatedErrorOutput"], "goodparts": ["        test, litConfig, tmpBase, parsedCommands, execDir, debug=False"]}, {"diff": "\n             raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n \n         # Split the generated output into multiple files and generate one test for each file\n-        parsed = _parseLitOutput(out)\n-        for (subfile, content) in self._splitFile(parsed):\n+        for (subfile, content) in self._splitFile(out):\n             generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n             os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n             with open(generatedFile, 'w') as f", "add": 1, "remove": 2, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["        parsed = _parseLitOutput(out)", "        for (subfile, content) in self._splitFile(parsed):"], "goodparts": ["        for (subfile, content) in self._splitFile(out):"]}], "source": "\n import contextlib import io import lit import lit.formats import os import pipes import re import shutil def _getTempPaths(test): \"\"\" Return the values to use for the %T and %t substitutions, respectively. The difference between this and Lit's default behavior is that we guarantee that %T is a path unique to the test being run. \"\"\" tmpDir, _=lit.TestRunner.getTempPaths(test) _, testName=os.path.split(test.getExecPath()) tmpDir=os.path.join(tmpDir, testName +\".dir\") tmpBase=os.path.join(tmpDir, \"t\") return tmpDir, tmpBase def _checkBaseSubstitutions(substitutions): substitutions=[s for(s, _) in substitutions] for s in[\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]: assert s in substitutions, \"Required substitution{} was not provided\".format(s) def _parseLitOutput(fullOutput): \"\"\" Parse output of a Lit ShTest to extract the actual output of the contained commands. This takes output of the form $ \":\" \"RUN: at line 11\" $ \"echo\" \"OUTPUT1\" OUTPUT1 $ \":\" \"RUN: at line 12\" $ \"echo\" \"OUTPUT2\" OUTPUT2 and returns a string containing OUTPUT1 OUTPUT2 as-if the commands had been run directly. This is a workaround for the fact that Lit doesn't let us execute ShTest and retrieve the raw output without injecting additional Lit output around it. \"\"\" parsed='' for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput): if output: commandOutput=re.search(\" if commandOutput: parsed +=commandOutput.group(1) return parsed def _executeScriptInternal(test, litConfig, commands): \"\"\" Returns(stdout, stderr, exitCode, timeoutInfo, parsedCommands) TODO: This really should be easier to access from Lit itself \"\"\" parsedCommands=parseScript(test, preamble=commands) _, tmpBase=_getTempPaths(test) execDir=os.path.dirname(test.getExecPath()) res=lit.TestRunner.executeScriptInternal( test, litConfig, tmpBase, parsedCommands, execDir ) if isinstance(res, lit.Test.Result): res=(\"\", res.output, 127, None) (out, err, exitCode, timeoutInfo)=res conflatedErrorOutput=re.search(\"( if conflatedErrorOutput: conflatedErrorOutput=conflatedErrorOutput.group(0) out=out[: -len(conflatedErrorOutput)] err +=conflatedErrorOutput return(out, err, exitCode, timeoutInfo, parsedCommands) def parseScript(test, preamble): \"\"\" Extract the script from a test, with substitutions applied. Returns a list of commands ready to be executed. -test The lit.Test to parse. -preamble A list of commands to perform before any command in the test. These commands can contain unexpanded substitutions, but they must not be of the form 'RUN:' --they must be proper commands once substituted. \"\"\" tmpDir, tmpBase=_getTempPaths(test) substitutions=lit.TestRunner.getDefaultSubstitutions(test, tmpDir, tmpBase) _checkBaseSubstitutions(substitutions) substitutions.append( (\"%{build}\", \"%{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\") ) substitutions.append((\"%{run}\", \"%{exec} %t.exe\")) additionalCompileFlags=[] fileDependencies=[] parsers=[ lit.TestRunner.IntegratedTestKeywordParser( \"FILE_DEPENDENCIES:\", lit.TestRunner.ParserKind.LIST, initial_value=fileDependencies, ), lit.TestRunner.IntegratedTestKeywordParser( \"ADDITIONAL_COMPILE_FLAGS:\", lit.TestRunner.ParserKind.LIST, initial_value=additionalCompileFlags, ), ] for feature in test.config.available_features: parser=lit.TestRunner.IntegratedTestKeywordParser( \"ADDITIONAL_COMPILE_FLAGS({}):\".format(feature), lit.TestRunner.ParserKind.LIST, initial_value=additionalCompileFlags, ) parsers.append(parser) scriptInTest=lit.TestRunner.parseIntegratedTestScript( test, additional_parsers=parsers, require_script=not preamble ) if isinstance(scriptInTest, lit.Test.Result): return scriptInTest script=[] for dep in fileDependencies: script +=[\"%dbg(SETUP) cd %S && cp{} %T\".format(dep)] script +=preamble script +=scriptInTest substitutions=[ (s, x +\" \" +\" \".join(additionalCompileFlags)) if s==\"%{compile_flags}\" else(s, x) for(s, x) in substitutions ] script=lit.TestRunner.applySubstitutions( script, substitutions, recursion_limit=test.config.recursiveExpansionLimit ) return script class CxxStandardLibraryTest(lit.formats.FileBasedTest): \"\"\" Lit test format for the C++Standard Library conformance test suite. This test format is based on top of the ShTest format --it basically creates a shell script performing the right operations(compile/link/run) based on the extension of the test file it encounters. It supports files with the following extensions: FOO.pass.cpp -Compiles, links and runs successfully FOO.pass.mm -Same as.pass.cpp, but for Objective-C++ FOO.compile.pass.cpp -Compiles successfully, link and run not attempted FOO.compile.pass.mm -Same as.compile.pass.cpp, but for Objective-C++ FOO.compile.fail.cpp -Does not compile successfully FOO.link.pass.cpp -Compiles and links successfully, run not attempted FOO.link.pass.mm -Same as.link.pass.cpp, but for Objective-C++ FOO.link.fail.cpp -Compiles successfully, but fails to link FOO.sh.<anything> -A builtin Lit Shell test FOO.gen.<anything> -A.sh test that generates one or more Lit tests on the fly. Executing this test must generate one or more files as expected by LLVM split-file, and each generated file leads to a separate Lit test that runs that file as defined by the test format. This can be used to generate multiple Lit tests from a single source file, which is useful for testing repetitive properties in the library. Be careful not to abuse this since this is not a replacement for usual code reuse techniques. FOO.verify.cpp -Compiles with clang-verify. This type of test is automatically marked as UNSUPPORTED if the compiler does not support Clang-verify. Substitution requirements =============================== The test format operates by assuming that each test's configuration provides the following substitutions, which it will reuse in the shell scripts it constructs: %{cxx} -A command that can be used to invoke the compiler %{compile_flags} -Flags to use when compiling a test case %{link_flags} -Flags to use when linking a test case %{flags} -Flags to use either when compiling or linking a test case %{exec} -A command to prefix the execution of executables Note that when building an executable(as opposed to only compiling a source file), all three of %{flags}, %{compile_flags} and %{link_flags} will be used in the same command line. In other words, the test format doesn't perform separate compilation and linking steps in this case. Additional supported directives =============================== In addition to everything that's supported in Lit ShTests, this test format also understands the following directives inside test files: // FILE_DEPENDENCIES: file, directory, /path/to/file This directive expresses that the test requires the provided files or directories in order to run. An example is a test that requires some test input stored in a data file. When a test file contains such a directive, this test format will collect them and copy them to the directory represented by %T. The intent is that %T contains all the inputs necessary to run the test, such that e.g. execution on a remote host can be done by simply copying %T to the host. // ADDITIONAL_COMPILE_FLAGS: flag1, flag2, flag3 This directive will cause the provided flags to be added to the %{compile_flags} substitution for the test that contains it. This allows adding special compilation flags without having to use a .sh.cpp test, which would be more powerful but perhaps overkill. Additional provided substitutions and features ============================================== The test format will define the following substitutions for use inside tests: %{build} Expands to a command-line that builds the current source file with the %{flags}, %{compile_flags} and %{link_flags} substitutions, and that produces an executable named %t.exe. %{run} Equivalent to `%{exec} %t.exe`. This is intended to be used in conjunction with the %{build} substitution. \"\"\" def getTestsForPath(self, testSuite, pathInSuite, litConfig, localConfig): SUPPORTED_SUFFIXES=[ \"[.]pass[.]cpp$\", \"[.]pass[.]mm$\", \"[.]compile[.]pass[.]cpp$\", \"[.]compile[.]pass[.]mm$\", \"[.]compile[.]fail[.]cpp$\", \"[.]link[.]pass[.]cpp$\", \"[.]link[.]pass[.]mm$\", \"[.]link[.]fail[.]cpp$\", \"[.]sh[.][^.]+$\", \"[.]gen[.][^.]+$\", \"[.]verify[.]cpp$\", \"[.]fail[.]cpp$\", ] sourcePath=testSuite.getSourcePath(pathInSuite) filename=os.path.basename(sourcePath) hasSupportedSuffix=lambda f: any([re.search(ext, f) for ext in SUPPORTED_SUFFIXES]) if filename.startswith(\".\") or filename in localConfig.excludes or not hasSupportedSuffix(filename): return if re.search('[.]gen[.][^.]+$', filename): for test in self._generateGenTest(testSuite, pathInSuite, litConfig, localConfig): yield test else: yield lit.Test.Test(testSuite, pathInSuite, localConfig) def execute(self, test, litConfig): VERIFY_FLAGS=( \"-Xclang -verify -Xclang -verify-ignore-unexpected=note -ferror-limit=0\" ) supportsVerify=\"verify-support\" in test.config.available_features filename=test.path_in_suite[-1] if re.search(\"[.]sh[.][^.]+$\", filename): steps=[] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".compile.pass.cpp\") or filename.endswith( \".compile.pass.mm\" ): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".compile.fail.cpp\"): steps=[ \"%dbg(COMPILED WITH) ! %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".link.pass.cpp\") or filename.endswith(\".link.pass.mm\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".link.fail.cpp\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -c -o %t.o\", \"%dbg(LINKED WITH) ! %{cxx} %t.o %{flags} %{link_flags} -o %t.exe\", ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".verify.cpp\"): if not supportsVerify: return lit.Test.Result( lit.Test.UNSUPPORTED, \"Test{} requires support for Clang-verify, which isn't supported by the compiler\".format( test.getFullName() ), ) steps=[ \"%dbg(COMPILED WITH) %{{cxx}} %s %{{flags}} %{{compile_flags}} -fsyntax-only -Wno-error{}\".format( VERIFY_FLAGS ) ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".pass.cpp\") or filename.endswith(\".pass.mm\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\", \"%dbg(EXECUTED AS) %{exec} %t.exe\", ] return self._executeShTest(test, litConfig, steps) else: return lit.Test.Result( lit.Test.UNRESOLVED, \"Unknown test suffix for '{}'\".format(filename) ) def _executeShTest(self, test, litConfig, steps): if test.config.unsupported: return lit.Test.Result(lit.Test.UNSUPPORTED, \"Test is unsupported\") script=parseScript(test, steps) if isinstance(script, lit.Test.Result): return script if litConfig.noExecute: return lit.Test.Result( lit.Test.XFAIL if test.isExpectedToFail() else lit.Test.PASS ) else: _, tmpBase=_getTempPaths(test) useExternalSh=False return lit.TestRunner._runShTest( test, litConfig, useExternalSh, script, tmpBase ) def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig): generator=lit.Test.Test(testSuite, pathInSuite, localConfig) generatorExecDir=os.path.dirname(testSuite.getExecPath(pathInSuite)) os.makedirs(generatorExecDir, exist_ok=True) steps=[] (out, err, exitCode, _, _)=_executeScriptInternal(generator, litConfig, steps) if exitCode !=0: raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\") parsed=_parseLitOutput(out) for(subfile, content) in self._splitFile(parsed): generatedFile=testSuite.getExecPath(pathInSuite +(subfile,)) os.makedirs(os.path.dirname(generatedFile), exist_ok=True) with open(generatedFile, 'w') as f: f.write(content) yield lit.Test.Test(testSuite,(generatedFile,), localConfig) def _splitFile(self, input): DELIM=r'^(//| lines=input.splitlines() currentFile=None thisFileContent=[] for line in lines: match=re.match(DELIM, line) if match: if currentFile is not None: yield(currentFile, '\\n'.join(thisFileContent)) currentFile=match.group(2).strip() thisFileContent=[] assert currentFile is not None, f\"Some input to split-file doesn't belong to any file, input was:\\n{input}\" thisFileContent.append(line) if currentFile is not None: yield(currentFile, '\\n'.join(thisFileContent)) ", "sourceWithComments": "# ===----------------------------------------------------------------------===##\n#\n# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n# See https://llvm.org/LICENSE.txt for license information.\n# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n#\n# ===----------------------------------------------------------------------===##\n\nimport contextlib\nimport io\nimport lit\nimport lit.formats\nimport os\nimport pipes\nimport re\nimport shutil\n\n\ndef _getTempPaths(test):\n    \"\"\"\n    Return the values to use for the %T and %t substitutions, respectively.\n\n    The difference between this and Lit's default behavior is that we guarantee\n    that %T is a path unique to the test being run.\n    \"\"\"\n    tmpDir, _ = lit.TestRunner.getTempPaths(test)\n    _, testName = os.path.split(test.getExecPath())\n    tmpDir = os.path.join(tmpDir, testName + \".dir\")\n    tmpBase = os.path.join(tmpDir, \"t\")\n    return tmpDir, tmpBase\n\n\ndef _checkBaseSubstitutions(substitutions):\n    substitutions = [s for (s, _) in substitutions]\n    for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n        assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n\ndef _parseLitOutput(fullOutput):\n    \"\"\"\n    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n\n    This takes output of the form\n\n        $ \":\" \"RUN: at line 11\"\n        $ \"echo\" \"OUTPUT1\"\n        # command output:\n        OUTPUT1\n\n        $ \":\" \"RUN: at line 12\"\n        $ \"echo\" \"OUTPUT2\"\n        # command output:\n        OUTPUT2\n\n    and returns a string containing\n\n        OUTPUT1\n        OUTPUT2\n\n    as-if the commands had been run directly. This is a workaround for the fact\n    that Lit doesn't let us execute ShTest and retrieve the raw output without\n    injecting additional Lit output around it.\n    \"\"\"\n    parsed = ''\n    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n        if output: # skip blank lines\n            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n            if commandOutput:\n                parsed += commandOutput.group(1)\n    return parsed\n\ndef _executeScriptInternal(test, litConfig, commands):\n    \"\"\"\n    Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n\n    TODO: This really should be easier to access from Lit itself\n    \"\"\"\n    parsedCommands = parseScript(test, preamble=commands)\n\n    _, tmpBase = _getTempPaths(test)\n    execDir = os.path.dirname(test.getExecPath())\n    res = lit.TestRunner.executeScriptInternal(\n        test, litConfig, tmpBase, parsedCommands, execDir\n    )\n    if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n        res = (\"\", res.output, 127, None)\n    (out, err, exitCode, timeoutInfo) = res\n\n    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n    #       split any stderr output that is included in stdout. It shouldn't be there, but\n    #       the Lit internal shell conflates stderr and stdout.\n    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n    if conflatedErrorOutput:\n        conflatedErrorOutput = conflatedErrorOutput.group(0)\n        out = out[: -len(conflatedErrorOutput)]\n        err += conflatedErrorOutput\n\n    return (out, err, exitCode, timeoutInfo, parsedCommands)\n\n\ndef parseScript(test, preamble):\n    \"\"\"\n    Extract the script from a test, with substitutions applied.\n\n    Returns a list of commands ready to be executed.\n\n    - test\n        The lit.Test to parse.\n\n    - preamble\n        A list of commands to perform before any command in the test.\n        These commands can contain unexpanded substitutions, but they\n        must not be of the form 'RUN:' -- they must be proper commands\n        once substituted.\n    \"\"\"\n    # Get the default substitutions\n    tmpDir, tmpBase = _getTempPaths(test)\n    substitutions = lit.TestRunner.getDefaultSubstitutions(test, tmpDir, tmpBase)\n\n    # Check base substitutions and add the %{build} and %{run} convenience substitutions\n    _checkBaseSubstitutions(substitutions)\n    substitutions.append(\n        (\"%{build}\", \"%{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\")\n    )\n    substitutions.append((\"%{run}\", \"%{exec} %t.exe\"))\n\n    # Parse the test file, including custom directives\n    additionalCompileFlags = []\n    fileDependencies = []\n    parsers = [\n        lit.TestRunner.IntegratedTestKeywordParser(\n            \"FILE_DEPENDENCIES:\",\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=fileDependencies,\n        ),\n        lit.TestRunner.IntegratedTestKeywordParser(\n            \"ADDITIONAL_COMPILE_FLAGS:\",\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=additionalCompileFlags,\n        ),\n    ]\n\n    # Add conditional parsers for ADDITIONAL_COMPILE_FLAGS. This should be replaced by first\n    # class support for conditional keywords in Lit, which would allow evaluating arbitrary\n    # Lit boolean expressions instead.\n    for feature in test.config.available_features:\n        parser = lit.TestRunner.IntegratedTestKeywordParser(\n            \"ADDITIONAL_COMPILE_FLAGS({}):\".format(feature),\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=additionalCompileFlags,\n        )\n        parsers.append(parser)\n\n    scriptInTest = lit.TestRunner.parseIntegratedTestScript(\n        test, additional_parsers=parsers, require_script=not preamble\n    )\n    if isinstance(scriptInTest, lit.Test.Result):\n        return scriptInTest\n\n    script = []\n\n    # For each file dependency in FILE_DEPENDENCIES, inject a command to copy\n    # that file to the execution directory. Execute the copy from %S to allow\n    # relative paths from the test directory.\n    for dep in fileDependencies:\n        script += [\"%dbg(SETUP) cd %S && cp {} %T\".format(dep)]\n    script += preamble\n    script += scriptInTest\n\n    # Add compile flags specified with ADDITIONAL_COMPILE_FLAGS.\n    substitutions = [\n        (s, x + \" \" + \" \".join(additionalCompileFlags))\n        if s == \"%{compile_flags}\"\n        else (s, x)\n        for (s, x) in substitutions\n    ]\n\n    # Perform substitutions in the script itself.\n    script = lit.TestRunner.applySubstitutions(\n        script, substitutions, recursion_limit=test.config.recursiveExpansionLimit\n    )\n\n    return script\n\n\nclass CxxStandardLibraryTest(lit.formats.FileBasedTest):\n    \"\"\"\n    Lit test format for the C++ Standard Library conformance test suite.\n\n    This test format is based on top of the ShTest format -- it basically\n    creates a shell script performing the right operations (compile/link/run)\n    based on the extension of the test file it encounters. It supports files\n    with the following extensions:\n\n    FOO.pass.cpp            - Compiles, links and runs successfully\n    FOO.pass.mm             - Same as .pass.cpp, but for Objective-C++\n\n    FOO.compile.pass.cpp    - Compiles successfully, link and run not attempted\n    FOO.compile.pass.mm     - Same as .compile.pass.cpp, but for Objective-C++\n    FOO.compile.fail.cpp    - Does not compile successfully\n\n    FOO.link.pass.cpp       - Compiles and links successfully, run not attempted\n    FOO.link.pass.mm        - Same as .link.pass.cpp, but for Objective-C++\n    FOO.link.fail.cpp       - Compiles successfully, but fails to link\n\n    FOO.sh.<anything>       - A builtin Lit Shell test\n\n    FOO.gen.<anything>      - A .sh test that generates one or more Lit tests on the\n                              fly. Executing this test must generate one or more files\n                              as expected by LLVM split-file, and each generated file\n                              leads to a separate Lit test that runs that file as\n                              defined by the test format. This can be used to generate\n                              multiple Lit tests from a single source file, which is\n                              useful for testing repetitive properties in the library.\n                              Be careful not to abuse this since this is not a replacement\n                              for usual code reuse techniques.\n\n    FOO.verify.cpp          - Compiles with clang-verify. This type of test is\n                              automatically marked as UNSUPPORTED if the compiler\n                              does not support Clang-verify.\n\n\n    Substitution requirements\n    ===============================\n    The test format operates by assuming that each test's configuration provides\n    the following substitutions, which it will reuse in the shell scripts it\n    constructs:\n        %{cxx}           - A command that can be used to invoke the compiler\n        %{compile_flags} - Flags to use when compiling a test case\n        %{link_flags}    - Flags to use when linking a test case\n        %{flags}         - Flags to use either when compiling or linking a test case\n        %{exec}          - A command to prefix the execution of executables\n\n    Note that when building an executable (as opposed to only compiling a source\n    file), all three of %{flags}, %{compile_flags} and %{link_flags} will be used\n    in the same command line. In other words, the test format doesn't perform\n    separate compilation and linking steps in this case.\n\n\n    Additional supported directives\n    ===============================\n    In addition to everything that's supported in Lit ShTests, this test format\n    also understands the following directives inside test files:\n\n        // FILE_DEPENDENCIES: file, directory, /path/to/file\n\n            This directive expresses that the test requires the provided files\n            or directories in order to run. An example is a test that requires\n            some test input stored in a data file. When a test file contains\n            such a directive, this test format will collect them and copy them\n            to the directory represented by %T. The intent is that %T contains\n            all the inputs necessary to run the test, such that e.g. execution\n            on a remote host can be done by simply copying %T to the host.\n\n        // ADDITIONAL_COMPILE_FLAGS: flag1, flag2, flag3\n\n            This directive will cause the provided flags to be added to the\n            %{compile_flags} substitution for the test that contains it. This\n            allows adding special compilation flags without having to use a\n            .sh.cpp test, which would be more powerful but perhaps overkill.\n\n\n    Additional provided substitutions and features\n    ==============================================\n    The test format will define the following substitutions for use inside tests:\n\n        %{build}\n            Expands to a command-line that builds the current source\n            file with the %{flags}, %{compile_flags} and %{link_flags}\n            substitutions, and that produces an executable named %t.exe.\n\n        %{run}\n            Equivalent to `%{exec} %t.exe`. This is intended to be used\n            in conjunction with the %{build} substitution.\n    \"\"\"\n\n    def getTestsForPath(self, testSuite, pathInSuite, litConfig, localConfig):\n        SUPPORTED_SUFFIXES = [\n            \"[.]pass[.]cpp$\",\n            \"[.]pass[.]mm$\",\n            \"[.]compile[.]pass[.]cpp$\",\n            \"[.]compile[.]pass[.]mm$\",\n            \"[.]compile[.]fail[.]cpp$\",\n            \"[.]link[.]pass[.]cpp$\",\n            \"[.]link[.]pass[.]mm$\",\n            \"[.]link[.]fail[.]cpp$\",\n            \"[.]sh[.][^.]+$\",\n            \"[.]gen[.][^.]+$\",\n            \"[.]verify[.]cpp$\",\n            \"[.]fail[.]cpp$\",\n        ]\n\n        sourcePath = testSuite.getSourcePath(pathInSuite)\n        filename = os.path.basename(sourcePath)\n\n        # Ignore dot files, excluded tests and tests with an unsupported suffix\n        hasSupportedSuffix = lambda f: any([re.search(ext, f) for ext in SUPPORTED_SUFFIXES])\n        if filename.startswith(\".\") or filename in localConfig.excludes or not hasSupportedSuffix(filename):\n            return\n\n        # If this is a generated test, run the generation step and add\n        # as many Lit tests as necessary.\n        if re.search('[.]gen[.][^.]+$', filename):\n            for test in self._generateGenTest(testSuite, pathInSuite, litConfig, localConfig):\n                yield test\n        else:\n            yield lit.Test.Test(testSuite, pathInSuite, localConfig)\n\n    def execute(self, test, litConfig):\n        VERIFY_FLAGS = (\n            \"-Xclang -verify -Xclang -verify-ignore-unexpected=note -ferror-limit=0\"\n        )\n        supportsVerify = \"verify-support\" in test.config.available_features\n        filename = test.path_in_suite[-1]\n\n        if re.search(\"[.]sh[.][^.]+$\", filename):\n            steps = []  # The steps are already in the script\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".compile.pass.cpp\") or filename.endswith(\n            \".compile.pass.mm\"\n        ):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".compile.fail.cpp\"):\n            steps = [\n                \"%dbg(COMPILED WITH) ! %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".link.pass.cpp\") or filename.endswith(\".link.pass.mm\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".link.fail.cpp\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -c -o %t.o\",\n                \"%dbg(LINKED WITH) ! %{cxx} %t.o %{flags} %{link_flags} -o %t.exe\",\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".verify.cpp\"):\n            if not supportsVerify:\n                return lit.Test.Result(\n                    lit.Test.UNSUPPORTED,\n                    \"Test {} requires support for Clang-verify, which isn't supported by the compiler\".format(\n                        test.getFullName()\n                    ),\n                )\n            steps = [\n                # Note: Use -Wno-error to make sure all diagnostics are not treated as errors,\n                #       which doesn't make sense for clang-verify tests.\n                \"%dbg(COMPILED WITH) %{{cxx}} %s %{{flags}} %{{compile_flags}} -fsyntax-only -Wno-error {}\".format(\n                    VERIFY_FLAGS\n                )\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        # Make sure to check these ones last, since they will match other\n        # suffixes above too.\n        elif filename.endswith(\".pass.cpp\") or filename.endswith(\".pass.mm\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\",\n                \"%dbg(EXECUTED AS) %{exec} %t.exe\",\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        else:\n            return lit.Test.Result(\n                lit.Test.UNRESOLVED, \"Unknown test suffix for '{}'\".format(filename)\n            )\n\n    def _executeShTest(self, test, litConfig, steps):\n        if test.config.unsupported:\n            return lit.Test.Result(lit.Test.UNSUPPORTED, \"Test is unsupported\")\n\n        script = parseScript(test, steps)\n        if isinstance(script, lit.Test.Result):\n            return script\n\n        if litConfig.noExecute:\n            return lit.Test.Result(\n                lit.Test.XFAIL if test.isExpectedToFail() else lit.Test.PASS\n            )\n        else:\n            _, tmpBase = _getTempPaths(test)\n            useExternalSh = False\n            return lit.TestRunner._runShTest(\n                test, litConfig, useExternalSh, script, tmpBase\n            )\n\n    def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig):\n        generator = lit.Test.Test(testSuite, pathInSuite, localConfig)\n\n        # Make sure we have a directory to execute the generator test in\n        generatorExecDir = os.path.dirname(testSuite.getExecPath(pathInSuite))\n        os.makedirs(generatorExecDir, exist_ok=True)\n\n        # Run the generator test\n        steps = [] # Steps must already be in the script\n        (out, err, exitCode, _, _) = _executeScriptInternal(generator, litConfig, steps)\n        if exitCode != 0:\n            raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n\n        # Split the generated output into multiple files and generate one test for each file\n        parsed = _parseLitOutput(out)\n        for (subfile, content) in self._splitFile(parsed):\n            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n            os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n            with open(generatedFile, 'w') as f:\n                f.write(content)\n            yield lit.Test.Test(testSuite, (generatedFile,), localConfig)\n\n    def _splitFile(self, input):\n        DELIM = r'^(//|#)---(.+)'\n        lines = input.splitlines()\n        currentFile = None\n        thisFileContent = []\n        for line in lines:\n            match = re.match(DELIM, line)\n            if match:\n                if currentFile is not None:\n                    yield (currentFile, '\\n'.join(thisFileContent))\n                currentFile = match.group(2).strip()\n                thisFileContent = []\n            assert currentFile is not None, f\"Some input to split-file doesn't belong to any file, input was:\\n{input}\"\n            thisFileContent.append(line)\n        if currentFile is not None:\n            yield (currentFile, '\\n'.join(thisFileContent))\n"}, "/llvm/utils/lit/lit/TestRunner.py": {"changes": [{"diff": "\n \n \n def executeBuiltinEcho(cmd, shenv):\n-    \"\"\"Interpret a redirected echo command\"\"\"\n+    \"\"\"Interpret a redirected echo or @echo command\"\"\"\n     opened_files = []\n     stdin, stdout, stderr = processRedirects(cmd, subprocess.PIPE, shenv, opened_files)\n     if stdin != subprocess.PIPE or stderr != subprocess.PIPE:\n         raise InternalShellError(\n-            cmd, \"stdin and stderr redirects not supported for echo\"\n+            cmd, f\"stdin and stderr redirects not supported for {cmd.args[0]}\"\n         )\n \n     # Some tests have un-redirected echo commands to help debug test failures.\n", "add": 2, "remove": 2, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["    \"\"\"Interpret a redirected echo command\"\"\"", "            cmd, \"stdin and stderr redirects not supported for echo\""], "goodparts": ["    \"\"\"Interpret a redirected echo or @echo command\"\"\"", "            cmd, f\"stdin and stderr redirects not supported for {cmd.args[0]}\""]}, {"diff": "\n         if res == -signal.SIGINT:\n             raise KeyboardInterrupt\n         if proc_not_counts[i] % 2:\n-            res = not res\n+            res = 1 if res == 0 else 0\n         elif proc_not_counts[i] > 1:\n             res = 1 if res != 0 else 0\n \n", "add": 1, "remove": 1, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["            res = not res"], "goodparts": ["            res = 1 if res == 0 else 0"]}, {"diff": "\n     return exitCode\n \n \n-def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n+def formatOutput(title, data, limit=None):\n+    if not data.strip():\n+        return \"\"\n+    if not limit is None and len(data) > limit:\n+        data = data[:limit] + \"\\n...\\n\"\n+        msg = \"data was truncated\"\n+    else:\n+        msg = \"\"\n+    ndashes = 30\n+    out =  f\"# .---{title}{'-' * (ndashes - 4 - len(title))}\\n\"\n+    out += f\"# | \" + \"\\n# | \".join(data.splitlines()) + \"\\n\"\n+    out += f\"# `---{msg}{'-' * (ndashes - 4 - len(msg))}\\n\"\n+    return out\n+\n+# Normally returns out, err, exitCode, timeoutInfo.\n+#\n+# If debug is True (the normal lit behavior), err is empty, and out contains an\n+# execution trace, including stdout and stderr shown per command executed.\n+#\n+# If debug is False (set by some custom lit test formats that call this\n+# function), out contains only stdout from the script, err contains only stderr\n+# from the script, and there is no execution trace.\n+def executeScriptInternal(test, litConfig, tmpBase, commands, cwd,\n+                          debug=True):\n     cmds = []\n     for i, ln in enumerate(commands):\n+        # Within lit, we try to always add '%dbg(...)' to command lines in order\n+        # to maximize debuggability.  However, custom lit test formats might not\n+        # always add it, so add a generic debug message in that case.\n         match = re.match(kPdbgRegex, ln)\n         if match:\n+            dbg = match.group(1)\n             command = match.group(2)\n-            ln = commands[i] = match.expand(\": '\\\\1'; \\\\2\" if command else \": '\\\\1'\")\n+        else:\n+            dbg = \"command line\"\n+            command = ln\n+        if debug:\n+            ln = f\"@echo '# {dbg}' \"\n+            if command:\n+                ln += f\"&& @echo {shlex.quote(command.lstrip())} && {command}\"\n+            else:\n+                ln += \"has no command after substitutions\"\n+        else:\n+            ln = command\n         try:\n             cmds.append(\n                 ShUtil.ShParser(ln, litConfig.isWindows, test.config.pipefail).parse()\n             )\n         except:\n-            return lit.Test.Result(Test.FAIL, \"shell parser error on: %r\" % ln)\n+            return lit.Test.Result(\n+                Test.FAIL, f\"shell parser error on {dbg}: {command.lstrip()}\\n\"\n+            )\n \n     cmd = cmds[0]\n     for c in cmds[1:]:\n", "add": 42, "remove": 3, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):", "            ln = commands[i] = match.expand(\": '\\\\1'; \\\\2\" if command else \": '\\\\1'\")", "            return lit.Test.Result(Test.FAIL, \"shell parser error on: %r\" % ln)"], "goodparts": ["def formatOutput(title, data, limit=None):", "    if not data.strip():", "        return \"\"", "    if not limit is None and len(data) > limit:", "        data = data[:limit] + \"\\n...\\n\"", "        msg = \"data was truncated\"", "    else:", "        msg = \"\"", "    ndashes = 30", "    out =  f\"# .---{title}{'-' * (ndashes - 4 - len(title))}\\n\"", "    out += f\"# | \" + \"\\n# | \".join(data.splitlines()) + \"\\n\"", "    out += f\"# `---{msg}{'-' * (ndashes - 4 - len(msg))}\\n\"", "    return out", "def executeScriptInternal(test, litConfig, tmpBase, commands, cwd,", "                          debug=True):", "            dbg = match.group(1)", "        else:", "            dbg = \"command line\"", "            command = ln", "        if debug:", "            ln = f\"@echo '# {dbg}' \"", "            if command:", "                ln += f\"&& @echo {shlex.quote(command.lstrip())} && {command}\"", "            else:", "                ln += \"has no command after substitutions\"", "        else:", "            ln = command", "            return lit.Test.Result(", "                Test.FAIL, f\"shell parser error on {dbg}: {command.lstrip()}\\n\"", "            )"]}, {"diff": "\n \n     out = err = \"\"\n     for i, result in enumerate(results):\n-        # Write the command line run.\n-        out += \"$ %s\\n\" % (\" \".join('\"%s\"' % s for s in result.command.args),)\n+        if not debug:\n+            out += result.stdout\n+            err += result.stderr\n+            continue\n+\n+        # The purpose of an \"@echo\" command is merely to add a debugging message\n+        # directly to lit's output.  It is used internally by lit's internal\n+        # shell and is not currently documented for use in lit tests.  However,\n+        # if someone misuses it (e.g., both \"echo\" and \"@echo\" complain about\n+        # stdin redirection), produce the normal execution trace to facilitate\n+        # debugging.\n+        if (\n+            result.command.args[0] == \"@echo\"\n+            and result.exitCode == 0\n+            and not result.stderr\n+            and not result.outputFiles\n+            and not result.timeoutReached\n+        ):\n+            out += result.stdout\n+            continue\n+\n+        # Write the command line that was run.  Properly quote it.  Leading\n+        # \"!\" commands should not be quoted as that would indicate they are not\n+        # the builtins.\n+        out += \"# executed command: \"\n+        nLeadingBangs = next(\n+            (i for i, cmd in enumerate(result.command.args) if cmd != \"!\"),\n+            len(result.command.args),\n+        )\n+        out += \"! \" * nLeadingBangs\n+        out += \" \".join(\n+            shlex.quote(str(s))\n+            for i, s in enumerate(result.command.args)\n+            if i >= nLeadingBangs\n+        )\n+        out += \"\\n\"\n \n         # If nothing interesting happened, move on.\n         if (\n", "add": 36, "remove": 2, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["        out += \"$ %s\\n\" % (\" \".join('\"%s\"' % s for s in result.command.args),)"], "goodparts": ["        if not debug:", "            out += result.stdout", "            err += result.stderr", "            continue", "        if (", "            result.command.args[0] == \"@echo\"", "            and result.exitCode == 0", "            and not result.stderr", "            and not result.outputFiles", "            and not result.timeoutReached", "        ):", "            out += result.stdout", "            continue", "        out += \"# executed command: \"", "        nLeadingBangs = next(", "            (i for i, cmd in enumerate(result.command.args) if cmd != \"!\"),", "            len(result.command.args),", "        )", "        out += \"! \" * nLeadingBangs", "        out += \" \".join(", "            shlex.quote(str(s))", "            for i, s in enumerate(result.command.args)", "            if i >= nLeadingBangs", "        )", "        out += \"\\n\""]}, {"diff": "\n \n         # Add the command output, if redirected.\n         for (name, path, data) in result.outputFiles:\n-            if data.strip():\n-                out += \"# redirected output from %r:\\n\" % (name,)\n-                data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n-                if len(data) > 1024:\n-                    out += data[:1024] + \"\\n...\\n\"\n-                    out += \"note: data was truncated\\n\"\n-                else:\n-                    out += data\n-                out += \"\\n\"\n-\n+            data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n+            out += formatOutput(\n+                f\"redirected output from '{name}'\", data, limit=1024\n+            )\n         if result.stdout.strip():\n-            out += \"# command output:\\n%s\\n\" % (result.stdout,)\n+            out += formatOutput(\"command stdout\", result.stdout)\n         if result.stderr.strip():\n-            out += \"# command stderr:\\n%s\\n\" % (result.stderr,)\n+            out += formatOutput(\"command stderr\", result.stderr)\n         if not result.stdout.strip() and not result.stderr.strip():\n-            out += \"note: command had no output on stdout or stderr\\n\"\n+            out += \"# note: command had no output on stdout or stderr\\n\"\n \n         # Show the error conditions:\n         if result.exitCode != 0:\n", "add": 7, "remove": 13, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["            if data.strip():", "                out += \"# redirected output from %r:\\n\" % (name,)", "                data = to_string(data.decode(\"utf-8\", errors=\"replace\"))", "                if len(data) > 1024:", "                    out += data[:1024] + \"\\n...\\n\"", "                    out += \"note: data was truncated\\n\"", "                else:", "                    out += data", "                out += \"\\n\"", "            out += \"# command output:\\n%s\\n\" % (result.stdout,)", "            out += \"# command stderr:\\n%s\\n\" % (result.stderr,)", "            out += \"note: command had no output on stdout or stderr\\n\""], "goodparts": ["            data = to_string(data.decode(\"utf-8\", errors=\"replace\"))", "            out += formatOutput(", "                f\"redirected output from '{name}'\", data, limit=1024", "            )", "            out += formatOutput(\"command stdout\", result.stdout)", "            out += formatOutput(\"command stderr\", result.stderr)", "            out += \"# note: command had no output on stdout or stderr\\n\""]}, {"diff": "\n                 codeStr = hex(int(result.exitCode & 0xFFFFFFFF)).rstrip(\"L\")\n             else:\n                 codeStr = str(result.exitCode)\n-            out += \"error: command failed with exit status: %s\\n\" % (codeStr,)\n+            out += \"# error: command failed with exit status: %s\\n\" % (codeStr,)\n         if litConfig.maxIndividualTestTime > 0 and result.timeoutReached:\n-            out += \"error: command reached timeout: %s\\n\" % (\n+            out += \"# error: command reached timeout: %s\\n\" % (\n                 str(result.timeoutReached),\n             )\n \n", "add": 2, "remove": 2, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["            out += \"error: command failed with exit status: %s\\n\" % (codeStr,)", "            out += \"error: command reached timeout: %s\\n\" % ("], "goodparts": ["            out += \"# error: command failed with exit status: %s\\n\" % (codeStr,)", "            out += \"# error: command reached timeout: %s\\n\" % ("]}, {"diff": "\n         if not output or not output[-1].add_continuation(line_number, keyword, line):\n             if output is None:\n                 output = []\n-            pdbg = \"%dbg({keyword} at line {line_number})\".format(\n-                keyword=keyword, line_number=line_number\n-            )\n-            assert re.match(\n-                kPdbgRegex + \"$\", pdbg\n-            ), \"kPdbgRegex expected to match actual %dbg usage\"\n-            line = \"{pdbg} {real_command}\".format(pdbg=pdbg, real_command=line)\n+            line = buildPdbgCommand(f\"{keyword} at line {line_number}\", line)\n             output.append(CommandDirective(line_number, line_number, keyword, line))\n         return output\n \n", "add": 1, "remove": 7, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["            pdbg = \"%dbg({keyword} at line {line_number})\".format(", "                keyword=keyword, line_number=line_number", "            )", "            assert re.match(", "                kPdbgRegex + \"$\", pdbg", "            ), \"kPdbgRegex expected to match actual %dbg usage\"", "            line = \"{pdbg} {real_command}\".format(pdbg=pdbg, real_command=line)"], "goodparts": ["            line = buildPdbgCommand(f\"{keyword} at line {line_number}\", line)"]}]}}, "msg": "[lit] Improve test output from lit's internal shell\n\nThis patch and D154984 were discussed in\n<https://discourse.llvm.org/t/rfc-improving-lits-debug-output/72839>.\n\nMotivation\n----------\n\nD154984 removes the \"Script:\" section that lit prints along with a\ntest's output, and it makes -v and -a imply -vv.  For example, after\nD154984, the \"Script:\" section below is never shown, but -v is enough\nto produce the execution trace following it:\n\n```\n Script:\n --\n : 'RUN: at line 1'; echo hello | FileCheck bogus.txt && echo success\n --\n Exit Code: 2\n\n Command Output (stdout):\n --\n $ \":\" \"RUN: at line 1\"\n $ \"echo\" \"hello\"\n # command output:\n hello\n\n $ \"FileCheck\" \"bogus.txt\"\n # command stderr:\n Could not open check file 'bogus.txt': No such file or directory\n\n error: command failed with exit status: 2\n\n --\n```\n\nIn the D154984 review, some reviewers point out that they have been\nusing the \"Script:\" section for copying and pasting a test's shell\ncommands to a terminal window.  The shell commands as printed in the\nexecution trace can be harder to copy and paste for the following\nreasons:\n\n- They drop redirections and break apart RUN lines at `&&`, `|`, etc.\n- They add `$` at the start of every command, which makes it hard to\n  copy and paste multiple commands in bulk.\n- Command stdout, stderr, etc. are interleaved with the commands and\n  are not clearly delineated.\n- They don't always use proper shell quoting.  Instead, they blindly\n  enclose all command-line arguments in double quotes.\n\nChanges\n-------\n\nD154984 plus this patch converts the above example into:\n\n```\n Exit Code: 2\n\n Command Output (stdout):\n --\n # RUN: at line 1\n echo hello | FileCheck bogus-file.txt && echo success\n # executed command: echo hello\n # .---command stdout------------\n # | hello\n # `-----------------------------\n # executed command: FileCheck bogus-file.txt\n # .---command stderr------------\n # | Could not open check file 'bogus-file.txt': No such file or directory\n # `-----------------------------\n # error: command failed with exit status: 2\n\n --\n```\n\nThus, this patch addresses the above issues as follows:\n\n- The entire execution trace can be copied and pasted in bulk to a\n  terminal for correct execution of the RUN lines, which are printed\n  intact as they appeared in the original RUN lines except lit\n  substitutions are expanded.  Everything else in the execution trace\n  appears in shell comments so it has no effect in a terminal.\n- Each of the RUN line's commands is repeated (in shell comments) as\n  it executes to show (1) that the command actually executed (e.g.,\n  `echo success` above didn't) and (2) what stdout, stderr, non-zero\n  exit status, and output files are associated with the command, if\n  any.  Shell quoting in the command is now correct and minimal but is\n  not necessarily the original shell quoting from the RUN line.\n- The start and end of the contents of stdout, stderr, or an output\n  file is now delineated clearly in the trace.\n\nTo help produce some of the above output, this patch extends lit's\ninternal shell with a built-in `@echo` command.  It's like `echo`\nexcept lit suppresses the normal execution trace for `@echo` and just\nprints its stdout directly.  For now, `@echo` isn't documented for use\nin lit tests.\n\nWithout this patch, libcxx's custom lit test format tries to parse the\nstdout from `lit.TestRunner.executeScriptInternal` (which runs lit's\ninternal shell) to extract the stdout and stderr produced by shell\ncommands, and that parse no longer works after the above changes.\nThis patch makes a small adjustment to\n`lit.TestRunner.executeScriptInternal` so libcxx can just request\nstdout and stderr without an execution trace.\n\n(As a minor drive-by fix that came up in testing: lit's internal `not`\ncommand now always produces a numeric exit status and never `True`.)\n\nCaveat\n------\n\nThis patch only makes the above changes for lit's internal shell.  In\nmost cases, we do not know how to force external shells (e.g., bash,\nsh, window's `cmd`) to produce execution traces in the manner we want.\n\nTo configure a test suite to use lit's internal shell (which is\nusually better for test portability than external shells anyway), add\nthis to the test suite's `lit.cfg` or other configuration file:\n\n```\nconfig.test_format = lit.formats.ShTest(execute_external=False)\n```\n\nReviewed By: MaskRay, awarzynski\n\nDifferential Revision: https://reviews.llvm.org/D156954"}, "f223022a4c521296a6d058862d66443ab9e355bf": {"url": "https://api.github.com/repos/dsheffie/riscv-llvm/commits/f223022a4c521296a6d058862d66443ab9e355bf", "html_url": "https://github.com/dsheffie/riscv-llvm/commit/f223022a4c521296a6d058862d66443ab9e355bf", "sha": "f223022a4c521296a6d058862d66443ab9e355bf", "keyword": "execution after redirect correct", "diff": "diff --git a/libcxx/utils/libcxx/test/dsl.py b/libcxx/utils/libcxx/test/dsl.py\nindex d2e0c6036dd3..5d4ca83be130 100644\n--- a/libcxx/utils/libcxx/test/dsl.py\n+++ b/libcxx/utils/libcxx/test/dsl.py\n@@ -186,7 +186,7 @@ def programOutput(config, program, args=None):\n                 \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n             )\n \n-        return libcxx.test.format._parseLitOutput(out)\n+        return out\n \n \n @_memoizeExpensiveOperation(\ndiff --git a/libcxx/utils/libcxx/test/format.py b/libcxx/utils/libcxx/test/format.py\nindex ddd88f25646e..c7c0bad681dd 100644\n--- a/libcxx/utils/libcxx/test/format.py\n+++ b/libcxx/utils/libcxx/test/format.py\n@@ -35,39 +35,6 @@ def _checkBaseSubstitutions(substitutions):\n     for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n         assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n \n-def _parseLitOutput(fullOutput):\n-    \"\"\"\n-    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n-\n-    This takes output of the form\n-\n-        $ \":\" \"RUN: at line 11\"\n-        $ \"echo\" \"OUTPUT1\"\n-        # command output:\n-        OUTPUT1\n-\n-        $ \":\" \"RUN: at line 12\"\n-        $ \"echo\" \"OUTPUT2\"\n-        # command output:\n-        OUTPUT2\n-\n-    and returns a string containing\n-\n-        OUTPUT1\n-        OUTPUT2\n-\n-    as-if the commands had been run directly. This is a workaround for the fact\n-    that Lit doesn't let us execute ShTest and retrieve the raw output without\n-    injecting additional Lit output around it.\n-    \"\"\"\n-    parsed = ''\n-    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n-        if output: # skip blank lines\n-            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n-            if commandOutput:\n-                parsed += commandOutput.group(1)\n-    return parsed\n-\n def _executeScriptInternal(test, litConfig, commands):\n     \"\"\"\n     Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n@@ -79,21 +46,12 @@ def _executeScriptInternal(test, litConfig, commands):\n     _, tmpBase = _getTempPaths(test)\n     execDir = os.path.dirname(test.getExecPath())\n     res = lit.TestRunner.executeScriptInternal(\n-        test, litConfig, tmpBase, parsedCommands, execDir\n+        test, litConfig, tmpBase, parsedCommands, execDir, debug=False\n     )\n     if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n         res = (\"\", res.output, 127, None)\n     (out, err, exitCode, timeoutInfo) = res\n \n-    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n-    #       split any stderr output that is included in stdout. It shouldn't be there, but\n-    #       the Lit internal shell conflates stderr and stdout.\n-    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n-    if conflatedErrorOutput:\n-        conflatedErrorOutput = conflatedErrorOutput.group(0)\n-        out = out[: -len(conflatedErrorOutput)]\n-        err += conflatedErrorOutput\n-\n     return (out, err, exitCode, timeoutInfo, parsedCommands)\n \n \n@@ -400,9 +358,8 @@ def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig):\n             raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n \n         # Split the generated output into multiple files and generate one test for each file\n-        parsed = _parseLitOutput(out)\n-        for (subfile, content) in self._splitFile(parsed):\n-            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n+        for subfile, content in self._splitFile(out):\n+            generatedFile = testSuite.getExecPath(pathInSuite + (subfile,))\n             os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n             with open(generatedFile, 'w') as f:\n                 f.write(content)\ndiff --git a/llvm/docs/CommandGuide/lit.rst b/llvm/docs/CommandGuide/lit.rst\nindex b494c74889aa..5e2443cb612a 100644\n--- a/llvm/docs/CommandGuide/lit.rst\n+++ b/llvm/docs/CommandGuide/lit.rst\n@@ -96,10 +96,9 @@ OUTPUT OPTIONS\n \n  Each command is printed before it is executed. This can be valuable for\n  debugging test failures, as the last printed command is the one that failed.\n- Moreover, :program:`lit` inserts a no-op command (``:`` in the case of bash)\n- with argument ``'RUN: at line N'`` before each command pipeline, and those\n- no-op commands are also printed to help you locate the source line of the\n- failed command.\n+ Moreover, :program:`lit` inserts ``'RUN: at line N'`` before each\n+ command pipeline in the output to help you locate the source line of\n+ the failed command.\n \n .. option:: -vv, --echo-all-commands\n \ndiff --git a/llvm/utils/lit/lit/TestRunner.py b/llvm/utils/lit/lit/TestRunner.py\nindex 0539b280a176..f85627eaf3de 100644\n--- a/llvm/utils/lit/lit/TestRunner.py\n+++ b/llvm/utils/lit/lit/TestRunner.py\n@@ -8,6 +8,7 @@\n import stat\n import pathlib\n import platform\n+import shlex\n import shutil\n import tempfile\n import threading\n@@ -348,12 +349,12 @@ def executeBuiltinExport(cmd, shenv):\n \n \n def executeBuiltinEcho(cmd, shenv):\n-    \"\"\"Interpret a redirected echo command\"\"\"\n+    \"\"\"Interpret a redirected echo or @echo command\"\"\"\n     opened_files = []\n     stdin, stdout, stderr = processRedirects(cmd, subprocess.PIPE, shenv, opened_files)\n     if stdin != subprocess.PIPE or stderr != subprocess.PIPE:\n         raise InternalShellError(\n-            cmd, \"stdin and stderr redirects not supported for echo\"\n+            cmd, f\"stdin and stderr redirects not supported for {cmd.args[0]}\"\n         )\n \n     # Some tests have un-redirected echo commands to help debug test failures.\n@@ -700,6 +701,7 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n         \"cd\": executeBuiltinCd,\n         \"export\": executeBuiltinExport,\n         \"echo\": executeBuiltinEcho,\n+        \"@echo\": executeBuiltinEcho,\n         \"mkdir\": executeBuiltinMkdir,\n         \"popd\": executeBuiltinPopd,\n         \"pushd\": executeBuiltinPushd,\n@@ -927,7 +929,7 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n         if res == -signal.SIGINT:\n             raise KeyboardInterrupt\n         if proc_not_counts[i] % 2:\n-            res = not res\n+            res = 1 if res == 0 else 0\n         elif proc_not_counts[i] > 1:\n             res = 1 if res != 0 else 0\n \n@@ -990,19 +992,60 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n     return exitCode\n \n \n-def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n+def formatOutput(title, data, limit=None):\n+    if not data.strip():\n+        return \"\"\n+    if not limit is None and len(data) > limit:\n+        data = data[:limit] + \"\\n...\\n\"\n+        msg = \"data was truncated\"\n+    else:\n+        msg = \"\"\n+    ndashes = 30\n+    # fmt: off\n+    out =  f\"# .---{title}{'-' * (ndashes - 4 - len(title))}\\n\"\n+    out += f\"# | \" + \"\\n# | \".join(data.splitlines()) + \"\\n\"\n+    out += f\"# `---{msg}{'-' * (ndashes - 4 - len(msg))}\\n\"\n+    # fmt: on\n+    return out\n+\n+\n+# Normally returns out, err, exitCode, timeoutInfo.\n+#\n+# If debug is True (the normal lit behavior), err is empty, and out contains an\n+# execution trace, including stdout and stderr shown per command executed.\n+#\n+# If debug is False (set by some custom lit test formats that call this\n+# function), out contains only stdout from the script, err contains only stderr\n+# from the script, and there is no execution trace.\n+def executeScriptInternal(test, litConfig, tmpBase, commands, cwd, debug=True):\n     cmds = []\n     for i, ln in enumerate(commands):\n+        # Within lit, we try to always add '%dbg(...)' to command lines in order\n+        # to maximize debuggability.  However, custom lit test formats might not\n+        # always add it, so add a generic debug message in that case.\n         match = re.fullmatch(kPdbgRegex, ln)\n         if match:\n+            dbg = match.group(1)\n             command = match.group(2)\n-            ln = commands[i] = match.expand(\": '\\\\1'; \\\\2\" if command else \": '\\\\1'\")\n+        else:\n+            dbg = \"command line\"\n+            command = ln\n+        if debug:\n+            ln = f\"@echo '# {dbg}' \"\n+            if command:\n+                ln += f\"&& @echo {shlex.quote(command.lstrip())} && {command}\"\n+            else:\n+                ln += \"has no command after substitutions\"\n+        else:\n+            ln = command\n         try:\n             cmds.append(\n                 ShUtil.ShParser(ln, litConfig.isWindows, test.config.pipefail).parse()\n             )\n         except:\n-            return lit.Test.Result(Test.FAIL, \"shell parser error on: %r\" % ln)\n+            return lit.Test.Result(\n+                Test.FAIL, f\"shell parser error on {dbg}: {command.lstrip()}\\n\"\n+            )\n \n     cmd = cmds[0]\n     for c in cmds[1:]:\n@@ -1022,8 +1065,42 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n \n     out = err = \"\"\n     for i, result in enumerate(results):\n-        # Write the command line run.\n-        out += \"$ %s\\n\" % (\" \".join('\"%s\"' % s for s in result.command.args),)\n+        if not debug:\n+            out += result.stdout\n+            err += result.stderr\n+            continue\n+\n+        # The purpose of an \"@echo\" command is merely to add a debugging message\n+        # directly to lit's output.  It is used internally by lit's internal\n+        # shell and is not currently documented for use in lit tests.  However,\n+        # if someone misuses it (e.g., both \"echo\" and \"@echo\" complain about\n+        # stdin redirection), produce the normal execution trace to facilitate\n+        # debugging.\n+        if (\n+            result.command.args[0] == \"@echo\"\n+            and result.exitCode == 0\n+            and not result.stderr\n+            and not result.outputFiles\n+            and not result.timeoutReached\n+        ):\n+            out += result.stdout\n+            continue\n+\n+        # Write the command line that was run.  Properly quote it.  Leading\n+        # \"!\" commands should not be quoted as that would indicate they are not\n+        # the builtins.\n+        out += \"# executed command: \"\n+        nLeadingBangs = next(\n+            (i for i, cmd in enumerate(result.command.args) if cmd != \"!\"),\n+            len(result.command.args),\n+        )\n+        out += \"! \" * nLeadingBangs\n+        out += \" \".join(\n+            shlex.quote(str(s))\n+            for i, s in enumerate(result.command.args)\n+            if i >= nLeadingBangs\n+        )\n+        out += \"\\n\"\n \n         # If nothing interesting happened, move on.\n         if (\n@@ -1038,22 +1115,14 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n \n         # Add the command output, if redirected.\n         for (name, path, data) in result.outputFiles:\n-            if data.strip():\n-                out += \"# redirected output from %r:\\n\" % (name,)\n-                data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n-                if len(data) > 1024:\n-                    out += data[:1024] + \"\\n...\\n\"\n-                    out += \"note: data was truncated\\n\"\n-                else:\n-                    out += data\n-                out += \"\\n\"\n-\n+            data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n+            out += formatOutput(f\"redirected output from '{name}'\", data, limit=1024)\n         if result.stdout.strip():\n-            out += \"# command output:\\n%s\\n\" % (result.stdout,)\n+            out += formatOutput(\"command stdout\", result.stdout)\n         if result.stderr.strip():\n-            out += \"# command stderr:\\n%s\\n\" % (result.stderr,)\n+            out += formatOutput(\"command stderr\", result.stderr)\n         if not result.stdout.strip() and not result.stderr.strip():\n-            out += \"note: command had no output on stdout or stderr\\n\"\n+            out += \"# note: command had no output on stdout or stderr\\n\"\n \n         # Show the error conditions:\n         if result.exitCode != 0:\n@@ -1063,9 +1132,9 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n                 codeStr = hex(int(result.exitCode & 0xFFFFFFFF)).rstrip(\"L\")\n             else:\n                 codeStr = str(result.exitCode)\n-            out += \"error: command failed with exit status: %s\\n\" % (codeStr,)\n+            out += \"# error: command failed with exit status: %s\\n\" % (codeStr,)\n         if litConfig.maxIndividualTestTime > 0 and result.timeoutReached:\n-            out += \"error: command reached timeout: %s\\n\" % (\n+            out += \"# error: command reached timeout: %s\\n\" % (\n                 str(result.timeoutReached),\n             )\n \n@@ -2117,6 +2186,8 @@ def executeShTest(\n         return lit.Test.Result(Test.UNSUPPORTED, \"Test is unsupported\")\n \n     script = list(preamble_commands)\n+    script = [buildPdbgCommand(f\"preamble command line\", ln) for ln in script]\n+\n     parsed = parseIntegratedTestScript(test, require_script=not script)\n     if isinstance(parsed, lit.Test.Result):\n         return parsed\ndiff --git a/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg b/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\nindex cf1a4f1ba1ec..301208c25bdc 100644\n--- a/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\n+++ b/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\n@@ -5,4 +5,4 @@ config.suffixes = [\".txt\"]\n config.test_format = lit.formats.ShTest()\n config.test_source_root = None\n config.test_exec_root = None\n-config.substitutions.append((\"%var\", lit_config.params.get(\"var\", \"\")))\n+config.substitutions.append((\"%var\", lit_config.params.get(\"var\", \"default\")))\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt b/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\nindex 6dd9b16304e0..1d94c1213723 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\n@@ -14,21 +14,21 @@\n ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0 -fopenmp-simd\n ; REDEFINE: %{fcflags} = -check-prefix=SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu -fopenmp-simd\n ; REDEFINE: %{fcflags} = -check-prefix=SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0\n ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu\n ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n \n ; CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt b/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\nindex 3bf057151afb..23c0a6d50753 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\n@@ -7,7 +7,7 @@\n #\n # REDEFINE: %{global:greeting}=Hello\n # RUN: %{global:echo}\n-# CHECK: GLOBAL: Hello World\n+# CHECK:# | GLOBAL: Hello World\n \n # We can redefine the test suite config's substitutions multiple times.  Again,\n # the expansion order remains the same (%{global:echo} before %{global:greeting}\n@@ -17,7 +17,7 @@\n # REDEFINE: %{global:greeting}=Goodbye %{global:what}\n # REDEFINE: %{global:what}=Sleep\n # RUN: %{global:echo}\n-# CHECK: GLOBAL: Goodbye Sleep Sleep\n+# CHECK:# | GLOBAL: Goodbye Sleep Sleep\n \n # A new local substitution is prepended to the substitution list so that it can\n # depend on all substitutions that were defined previously, including those from\n@@ -26,7 +26,7 @@\n # DEFINE: %{local:greeting}=Hey %{global:what}\n # DEFINE: %{local:echo}=echo \"LOCAL: %{local:greeting} %{global:what}\"\n # RUN: %{local:echo}\n-# CHECK: LOCAL: Hey Sleep Sleep\n+# CHECK:# | LOCAL: Hey Sleep Sleep\n \n # As for substitutions from the test suite config, redefining local\n # substitutions should not change the expansion order.  Again, the expansion\n@@ -36,6 +36,6 @@\n # REDEFINE: %{local:greeting}=So Long %{global:what}\n # REDEFINE: %{global:what}=World\n # RUN: %{local:echo}\n-# CHECK: LOCAL: So Long World World\n+# CHECK:# | LOCAL: So Long World World\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt b/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\nindex 65f90792ff7b..5a1d7f2e1987 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\n@@ -1,19 +1,19 @@\n # Does it work as expected directly in RUN lines?\n # RUN: echo %(line), %(line-1), %(line+2)\n-# CHECK: [[#@LINE-1]], [[#@LINE-2]], [[#@LINE+1]]\n+# CHECK:# | [[#@LINE-1]], [[#@LINE-2]], [[#@LINE+1]]\n \n # %(line) substitutions refer to the original DEFINE/REDEFINE line not the RUN\n # line they eventually appear within.\n #\n # DEFINE: %{lines} = %(line)\n # RUN: echo '%{lines}'\n-# CHECK: [[#@LINE-2]]\n+# CHECK:# | [[#@LINE-2]]\n #\n # REDEFINE: %{lines} = %(line),                                                \\\n # REDEFINE:            %(line),                                                \\\n # REDEFINE:            %(line)\n # RUN: echo '%{lines}'\n-# CHECK: [[#@LINE-4]], [[#@LINE-3]], [[#@LINE-2]]\n+# CHECK:# | [[#@LINE-4]], [[#@LINE-3]], [[#@LINE-2]]\n \n # %(line+N) and %{line-N) should work too.\n #\n@@ -21,12 +21,12 @@\n # DEFINE:                %(line),                                              \\\n # DEFINE:                %(line-1)\n # RUN: echo '%{lines-rel}'\n-# CHECK: [[#@LINE-3]], [[#@LINE-3]], [[#@LINE-3]]\n+# CHECK:# | [[#@LINE-3]], [[#@LINE-3]], [[#@LINE-3]]\n #\n # REDEFINE: %{lines-rel} = %(line+5),                                          \\\n # REDEFINE:                %(line+0),                                          \\\n # REDEFINE:                %(line-10)\n # RUN: echo '%{lines-rel}'\n-# CHECK: [[#@LINE+1]], [[#@LINE-3]], [[#@LINE-12]]\n+# CHECK:# | [[#@LINE+1]], [[#@LINE-3]], [[#@LINE-12]]\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt b/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\nindex 18a27cdd72fa..d27fda2e2fe6 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\n@@ -1,25 +1,25 @@\n # DEFINE: %{abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789} = ok\n # RUN: echo '%{abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789}'\n-# CHECK: ok\n+# CHECK:# | ok\n \n # DEFINE: %{FooBar} = ok at %(line)\n # RUN: echo '%{FooBar}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{fooBar} = ok at %(line)\n # RUN: echo '%{fooBar}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{foo-bar-} = ok at %(line)\n # RUN: echo '%{foo-bar-}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{foo:bar:} = ok at %(line)\n # RUN: echo '%{foo:bar:}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{_foo_bar_} = ok at %(line)\n # RUN: echo '%{_foo_bar_}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt b/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\nindex eb5f0b918fd1..e504b822ace8 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\n@@ -6,7 +6,7 @@\n \n # RUN: echo '%{outer}'\n \n-# CHECK-NON-RECUR:%{inner}\n-# CHECK-RECUR:expanded\n+# CHECK-NON-RECUR:# | %{inner}\n+# CHECK-RECUR:# | expanded\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt b/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\nindex 9d2e7197fb3a..c1bdfef30b1a 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\n@@ -2,21 +2,21 @@\n \n # DEFINE: %{equals} = FileCheck -check-prefixes=FOO,BAR\n # RUN: echo '%{equals}'\n-# CHECK: FileCheck -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -check-prefixes=FOO,BAR\n #\n # REDEFINE: %{equals} == == =\n # RUN: echo '%{equals}'\n-# CHECK: = == =\n+# CHECK:# | = == =\n \n # DEFINE: %{continue-equals} = FileCheck -strict-whitespace -match-full-lines \\\n # DEFINE:                      -check-prefixes=FOO,BAR\n # RUN: echo '%{continue-equals}'\n-# CHECK: FileCheck -strict-whitespace -match-full-lines -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -strict-whitespace -match-full-lines -check-prefixes=FOO,BAR\n #\n # REDEFINE: %{continue-equals} = FileCheck -input-file=test.txt                \\\n # REDEFINE:                      -implicit-check-not=foobar                    \\\n # REDEFINE:                      -check-prefixes=FOO,BAR\n # RUN: echo '%{continue-equals}'\n-# CHECK: FileCheck -input-file=test.txt -implicit-check-not=foobar -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -input-file=test.txt -implicit-check-not=foobar -check-prefixes=FOO,BAR\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt b/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\nindex 58d5c1a34ce8..9143796edd32 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\n@@ -6,11 +6,11 @@\n \n # DEFINE: %{escape} = \\g<0>\\n\n # RUN: echo '%{escape}'\n-# CHECK: {{\\\\?}}\\g<0>{{\\\\?}}\\n\n+# CHECK:# | {{\\\\?}}\\g<0>{{\\\\?}}\\n\n \n # REDEFINE: %{escape} = \\n                                                     \\\n # REDEFINE:             \\g<param>\n # RUN: echo '%{escape}'\n-# CHECK: {{\\\\?}}\\n {{\\\\?}}\\g<param>\n+# CHECK:# | {{\\\\?}}\\n {{\\\\?}}\\g<param>\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt b/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\nindex 1259e511ba70..3e4db1b15d92 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\n@@ -3,33 +3,33 @@\n #\n # DEFINE: %{empty}=\n # RUN: echo \"'%{empty}'\"\n-# CHECK:''\n+# CHECK:# | ''\n #\n # REDEFINE: %{empty}=\n # RUN: echo \"'%{empty}'\"\n-# CHECK:''\n+# CHECK:# | ''\n \n # A value consisting only of whitespace is trimmed to the empty string.\n #\n #               v~~ intentional whitespace\n # DEFINE: %{ws}=   \n # RUN: echo \"'%{ws}'\"\n-# CHECK:''\n+# CHECK:# | ''\n #\n #                 v intentional whitespace\n # REDEFINE: %{ws}= \n # RUN: echo \"'%{ws}'\"\n-# CHECK:''\n+# CHECK:# | ''\n \n # Whitespace is not required around the name or value.\n #\n # DEFINE:%{no-whitespace}=abc\n # RUN: echo \"'%{no-whitespace}'\"\n-# CHECK:'abc'\n+# CHECK:# | 'abc'\n #\n # REDEFINE:%{no-whitespace}=HelloWorld\n # RUN: echo \"'%{no-whitespace}'\"\n-# CHECK:'HelloWorld'\n+# CHECK:# | 'HelloWorld'\n \n # Whitespace is not required between substitutions in a value.\n #\n@@ -37,11 +37,11 @@\n # DEFINE: %{adjacent1} = bar\n # DEFINE: %{has-adjacent-substs} = %{adjacent0}%{adjacent1}\n # RUN: echo \"'%{has-adjacent-substs}'\"\n-# CHECK:'foobar'\n+# CHECK:# | 'foobar'\n #\n # REDEFINE: %{has-adjacent-substs} = %{adjacent0}%{adjacent1}%{adjacent0}\n # RUN: echo \"'%{has-adjacent-substs}'\"\n-# CHECK:'foobarfoo'\n+# CHECK:# | 'foobarfoo'\n \n # Exact whitespace is preserved within the value, but whitespace enclosing the\n # name or value is discarded.  ('%{' and '}' are part of the name, and\n@@ -50,11 +50,11 @@\n #                                       v~~ intentional whitespace\n # DEFINE:   %{whitespace}  =  abc    def   \n # RUN: echo \"'%{whitespace}'\"\n-# CHECK:'abc    def'\n+# CHECK:# | 'abc    def'\n #                                      v intentional whitespace\n # REDEFINE: %{whitespace} = Hello World \n # RUN: echo \"'%{whitespace}'\"\n-# CHECK:'Hello World'\n+# CHECK:# | 'Hello World'\n \n # Line continuations in the value are permitted and collapse whitespace.\n #\n@@ -66,12 +66,12 @@\n # DEFINE:  pqr \n #             ^ intentional whitespace\n # RUN: echo \"'%{continue}'\"\n-# CHECK:'abc def ghi jkl mno pqr'\n+# CHECK:# | 'abc def ghi jkl mno pqr'\n #\n # REDEFINE: %{continue} =  abc  \\\n # REDEFINE: def\n # RUN: echo \"'%{continue}'\"\n-# CHECK:'abc def'\n+# CHECK:# | 'abc def'\n \n # Whitespace at the end of the line after a '\\' is ignored, and it's treated as\n # a line continuation.  Otherwise, the behavior would be hard to understand\n@@ -83,7 +83,7 @@\n #                                   ^ intentional whitespace\n # DEFINE: baz\n # RUN: echo \"'%{ws-after-continue}'\"\n-# CHECK:'foo bar baz'\n+# CHECK:# | 'foo bar baz'\n #\n #                                     v intentional whitespace\n # REDEFINE: %{ws-after-continue}=foo \\ \n@@ -91,7 +91,7 @@\n #                                     ^~~~~~~~~~~~ intentional whitespace\n # REDEFINE: baz\n # RUN: echo \"'%{ws-after-continue}'\"\n-# CHECK:'foo bar baz'\n+# CHECK:# | 'foo bar baz'\n \n # A line continuation is recognized anywhere.  It should be used only where\n # whitespace is permitted because it reduces to a single space.\n@@ -107,7 +107,7 @@\n # DEFINE:\\\n # DEFINE:a\n # RUN: echo \"'%{blank-lines}'\"\n-# CHECK:'a'\n+# CHECK:# | 'a'\n #\n # REDEFINE:                  \\\n # REDEFINE: %{blank-lines}   \\\n@@ -120,7 +120,7 @@\n # REDEFINE:                  \\\n # REDEFINE:      c\n # RUN: echo \"'%{blank-lines}'\"\n-# CHECK:'a b c'\n+# CHECK:# | 'a b c'\n \n # The fourth DEFINE line is deceptive because it looks like a new substitution,\n # but it's actually a continuation of the previous value.\n@@ -130,6 +130,6 @@\n # DEFINE: %{deceptive-continue}=echo \\\n # DEFINE: %{name}=%{value}\n # RUN: %{deceptive-continue}\n-# CHECK:x=3\n+# CHECK:# | x=3\n \n # CHECK:{{ *}}Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt b/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\nindex b0a7cfd97941..b5fc1b49fcc5 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\n@@ -1,46 +1,34 @@\n-#       CHECK: -- Testing:{{.*}}\n-#  CHECK-NEXT: PASS: shtest-if-else :: test.txt (1 of 1)\n-#  CHECK-NEXT: Exit Code: 0\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: Command Output (stdout):\n-#  CHECK-NEXT: --\n+# CHECK: -- Testing:{{.*}}\n+# CHECK-NEXT: PASS: shtest-if-else :: test.txt (1 of 1)\n+#      CHECK: Command Output (stdout):\n+# CHECK-NEXT: --\n \n # RUN: %if feature %{ echo \"test-1\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-1\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-1\"\n \n # If %else is not present it is treated like %else %{%}. Empty commands\n # are ignored.\n #\n # RUN: %if nofeature %{ echo \"fail\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#   CHECK-NOT: fail\n+#     CHECK: # {{RUN}}: at line [[#@LINE-1]] has no command after substitutions\n+# CHECK-NOT: fail\n \n # RUN: %if nofeature %{ echo \"fail\" %} %else %{ echo \"test-2\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-2\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-2\"\n \n # Spaces inside curly braces are not ignored\n #\n # RUN: echo test-%if feature %{ 3 %} %else %{ fail %}-test\n # RUN: echo test-%if feature %{ 4 4 %} %else %{ fail %}-test\n # RUN: echo test-%if nofeature %{ fail %} %else %{ 5 5 %}-test\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 3 -test\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 4 4 -test\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 5 5 -test\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo test- 3 -test\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo test- 4 4 -test\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo test- 5 5 -test\n \n # Escape line breaks for multi-line expressions\n #\n@@ -48,42 +36,32 @@\n # RUN:   %{ echo     \\\n # RUN:     \"test-5\" \\\n # RUN:   %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-4]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-5\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-5\"\n \n # RUN: %if nofeature       \\\n # RUN:   %{ echo \"fail\" %}   \\\n # RUN: %else               \\\n # RUN:   %{ echo \"test-6\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-4]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-6\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-6\"\n \n # RUN: echo \"test%if feature %{%} %else %{%}-7\"\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-7\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-7\"\n \n # Escape %if. Without %if..%else context '%{' and '%}' are treated\n # literally.\n #\n # RUN: echo %%if feature %{ echo \"test-8\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: %if feature %{ echo test-8 %}\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo %if feature %{ echo \"test-8\" %}\n \n # Nested expressions are supported:\n #\n # RUN: echo %if feature %{ %if feature %{ %if nofeature %{\"fail\"%} %else %{\"test-9\"%} %} %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-9\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-9\"\n \n # Binary expression evaluation and regex match can be used as\n # conditions.\n@@ -91,18 +69,12 @@\n # RUN: echo %if feature && !nofeature %{ \"test-10\" %}\n # RUN: echo %if feature && nofeature %{ \"fail\" %} %else %{ \"test-11\" %}\n # RUN: echo %if {{fea.+}} %{ \"test-12\" %} %else %{ \"fail\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-10\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-11\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-12\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo \"test-10\"\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-11\"\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo \"test-12\"\n \n # Spaces between %if and %else are ignored. If there is no %else -\n # space after %if %{...%} is not ignored.\n@@ -110,39 +82,27 @@\n # RUN: echo XX %if feature %{YY%} ZZ\n # RUN: echo AA %if feature %{BB%} %else %{CC%} DD\n # RUN: echo AA %if nofeature %{BB%} %else %{CC%} DD\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: XX YY ZZ\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: AA BB DD\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: AA CC DD\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo XX YY ZZ\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo AA BB DD\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo AA CC DD\n \n # '{' and '}' can be used without escaping\n #\n # RUN: %if feature %{echo {}%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: {}\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo {}\n \n # Spaces are not required\n #\n # RUN: echo %if feature%{\"ok\"%}%else%{\"fail\"%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: ok\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"ok\"\n \n # Substitutions with braces are handled correctly\n #\n # RUN: echo %{sub} %if feature%{test-%{sub}%}%else%{\"fail\"%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: ok test-ok\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo ok test-ok\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt b/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\nindex fb3a3e000789..5ff0c891450b 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\n@@ -1,3 +1,4 @@\n # RUN: true\n # RUN: echo hi\n-# RUN: not not wc missing-file &> %t.out\n+# RUN: not not wc missing-file &> %t.out || true\n+# RUN: not %{python} %S/write-a-lot.py &> %t.out\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg b/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\nindex b872854d21e6..141fc3a596e7 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\n@@ -2,4 +2,5 @@ import lit.formats\n \n config.name = \"shtest-output-printing\"\n config.suffixes = [\".txt\"]\n+config.substitutions.append((\"%{python}\", f'\"{sys.executable}\"'))\n config.test_format = lit.formats.ShTest(execute_external=False)\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py b/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py\nnew file mode 100644\nindex 000000000000..5dbb94a41cbf\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py\n@@ -0,0 +1,6 @@\n+#!/usr/bin/env python\n+\n+import sys\n+\n+sys.stdout.write(\"All work and no play makes Jack a dull boy.\\n\" * 1000)\n+sys.stdout.flush()\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt\nnew file mode 100644\nindex 000000000000..15a87aee46a3\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt\n@@ -0,0 +1 @@\n+RUN: @echo 2> %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt\nnew file mode 100644\nindex 000000000000..27fd0c4209fd\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt\n@@ -0,0 +1,2 @@\n+RUN: touch %t\n+RUN: @echo < %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt\nnew file mode 100644\nindex 000000000000..9611918f7e12\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt\n@@ -0,0 +1 @@\n+RUN: echo 2> %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt\nnew file mode 100644\nindex 000000000000..bc771be6b22a\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt\n@@ -0,0 +1,2 @@\n+RUN: touch %t\n+RUN: echo < %t\ndiff --git a/llvm/utils/lit/tests/allow-retries.py b/llvm/utils/lit/tests/allow-retries.py\nindex bf6c04193388..45610fb70d34 100644\n--- a/llvm/utils/lit/tests/allow-retries.py\n+++ b/llvm/utils/lit/tests/allow-retries.py\n@@ -15,9 +15,28 @@\n \n # This test does not succeed within the allowed retry limit\n #\n-# RUN: not %{lit} %{inputs}/allow-retries/does-not-succeed-within-limit.py | FileCheck --check-prefix=CHECK-TEST3 %s\n-# CHECK-TEST3: Failed Tests (1):\n-# CHECK-TEST3: allow-retries :: does-not-succeed-within-limit.py\n+# Check that the execution trace isn't corrupt due to reprocessing the script\n+# multiple times (e.g., '%dbg(...)' processing used to accumulate across\n+# retries).\n+#\n+# RUN: not %{lit} %{inputs}/allow-retries/does-not-succeed-within-limit.py -v |\\\n+# RUN:   FileCheck --check-prefix=CHECK-TEST3 -match-full-lines %s\n+#\n+#       CHECK-TEST3: FAIL: allow-retries :: does-not-succeed-within-limit.py (1 of 1)\n+#  CHECK-TEST3-NEXT: {{\\**}} TEST 'allow-retries :: does-not-succeed-within-limit.py' FAILED {{\\**}}\n+#  CHECK-TEST3-NEXT: Exit Code: 1\n+# CHECK-TEST3-EMPTY:\n+#  CHECK-TEST3-NEXT: Command Output (stdout):\n+#  CHECK-TEST3-NEXT: --\n+#  CHECK-TEST3-NEXT: # {{RUN}}: at line 3\n+#  CHECK-TEST3-NEXT: false\n+#  CHECK-TEST3-NEXT: # executed command: false\n+#  CHECK-TEST3-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-TEST3-NEXT: # error: command failed with exit status: 1\n+# CHECK-TEST3-EMPTY:\n+#  CHECK-TEST3-NEXT: --\n+#       CHECK-TEST3: Failed Tests (1):\n+#       CHECK-TEST3: allow-retries :: does-not-succeed-within-limit.py\n \n # This test should be UNRESOLVED since it has more than one ALLOW_RETRIES\n # lines, and that is not allowed.\n@@ -48,6 +67,6 @@\n # RUN:     -Dcounter=%t.counter -Dpython=%{python} | \\\n # RUN:   FileCheck --check-prefix=CHECK-TEST7 %s\n #     CHECK-TEST7: Command Output (stdout):\n-#     CHECK-TEST7: LLVM_PROFILE_FILE=\n-# CHECK-TEST7-NOT: LLVM_PROFILE_FILE=\n+#     CHECK-TEST7: # executed command: export LLVM_PROFILE_FILE=\n+# CHECK-TEST7-NOT: # executed command: export LLVM_PROFILE_FILE=\n #     CHECK-TEST7: Passed With Retry: 1\ndiff --git a/llvm/utils/lit/tests/lit-opts.py b/llvm/utils/lit/tests/lit-opts.py\nindex d292ca74f3b9..a533a59d9d12 100644\n--- a/llvm/utils/lit/tests/lit-opts.py\n+++ b/llvm/utils/lit/tests/lit-opts.py\n@@ -8,7 +8,7 @@\n #\n # RUN: env LIT_OPTS=-a \\\n # RUN: %{lit} -s %{inputs}/lit-opts \\\n-# RUN: | FileCheck -check-prefix=SHOW-ALL -DVAR= %s\n+# RUN: | FileCheck -check-prefix=SHOW-ALL -DVAR=default %s\n \n # Check that LIT_OPTS understands multiple options with arbitrary spacing.\n #\n@@ -28,6 +28,6 @@\n \n # SHOW-ALL:     Testing: 1 tests\n # SHOW-ALL:     PASS: lit-opts :: test.txt (1 of 1)\n-# SHOW-ALL:     {{^}}[[VAR]]\n+# SHOW-ALL:     echo [[VAR]]\n # SHOW-ALL-NOT: PASS\n # SHOW-ALL:     Passed: 1\ndiff --git a/llvm/utils/lit/tests/shtest-define.py b/llvm/utils/lit/tests/shtest-define.py\nindex 1d0997bbbaf8..8c9309804cce 100644\n--- a/llvm/utils/lit/tests/shtest-define.py\n+++ b/llvm/utils/lit/tests/shtest-define.py\n@@ -136,15 +136,15 @@\n # RUN: %{lit} -va %{my-inputs}/shared-substs-*.txt 2>&1 |                      \\\n # RUN:   FileCheck -check-prefix=SHARED-SUBSTS -match-full-lines %s\n #\n-# SHARED-SUBSTS: shared-substs-0.txt\n-# SHARED-SUBSTS: GLOBAL: World\n-# SHARED-SUBSTS: LOCAL0: LOCAL0:Hello LOCAL0:World\n-# SHARED-SUBSTS: LOCAL0: subst\n+# SHARED-SUBSTS:# | shared-substs-0.txt\n+# SHARED-SUBSTS:# | GLOBAL: World\n+# SHARED-SUBSTS:# | LOCAL0: LOCAL0:Hello LOCAL0:World\n+# SHARED-SUBSTS:# | LOCAL0: subst\n #\n-# SHARED-SUBSTS: shared-substs-1.txt\n-# SHARED-SUBSTS: GLOBAL: World\n-# SHARED-SUBSTS: LOCAL1: LOCAL1:Hello LOCAL1:World\n-# SHARED-SUBSTS: LOCAL1: subst\n+# SHARED-SUBSTS:# | shared-substs-1.txt\n+# SHARED-SUBSTS:# | GLOBAL: World\n+# SHARED-SUBSTS:# | LOCAL1: LOCAL1:Hello LOCAL1:World\n+# SHARED-SUBSTS:# | LOCAL1: subst\n #\n # REDEFINE: %{test} = shared-substs-0.txt\n # RUN: %{record-test}\ndiff --git a/llvm/utils/lit/tests/shtest-env.py b/llvm/utils/lit/tests/shtest-env.py\nindex f2e8216f7f4a..c093b62e5420 100644\n--- a/llvm/utils/lit/tests/shtest-env.py\n+++ b/llvm/utils/lit/tests/shtest-env.py\n@@ -10,88 +10,115 @@\n # CHECK: -- Testing: 16 tests{{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-assign.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"FOO=1\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env FOO=1\n+# CHECK: # executed command: env FOO=1\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-u-arg.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO\n+# CHECK: # executed command: env -u FOO\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-u.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u\n+# CHECK: # executed command: env -u\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-nested-none.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"env\" \"env\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env env env\n+# CHECK: # executed command: env env env\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-none.txt ({{[^)]*}})\n-# CHECK: $ \"env\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env\n+# CHECK: # executed command: env\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-cd.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"cd\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'cd'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 cd foobar\n+# CHECK: # executed command: env -u FOO BAR=3 cd foobar\n+# CHECK: # | Error: 'env' cannot call 'cd'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-colon.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \":\"\n-# CHECK: Error: 'env' cannot call ':'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 :\n+# CHECK: # executed command: env -u FOO BAR=3 :\n+# CHECK: # | Error: 'env' cannot call ':'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-echo.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"echo\" \"hello\" \"world\"\n-# CHECK: Error: 'env' cannot call 'echo'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 echo hello world\n+# CHECK: # executed command: env -u FOO BAR=3 echo hello world\n+# CHECK: # | Error: 'env' cannot call 'echo'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: PASS: shtest-env :: env-calls-env.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"env\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"FOO=2\" \"env\" \"BAR=1\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"env\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=1\" \"env\" \"-u\" \"BAR\" \"FOO=2\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=1\" \"env\" \"-u\" \"BAR\" \"FOO=2\" \"env\" \"BAZ=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env env [[PYTHON:.+]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env env [[PYTHON_BARE:.+]] print_environment.py\n+# CHECK: env FOO=2 env BAR=1 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env FOO=2 env BAR=1 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO env -u BAR [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO env -u BAR [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO BAR=1 env -u BAR FOO=2 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO BAR=1 env -u BAR FOO=2 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO BAR=1 env -u BAR FOO=2 env BAZ=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO BAR=1 env -u BAR FOO=2 env BAZ=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: FAIL: shtest-env :: env-calls-export.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"export\" \"BAZ=3\"\n-# CHECK: Error: 'env' cannot call 'export'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 export BAZ=3\n+# CHECK: # executed command: env -u FOO BAR=3 export BAZ=3\n+# CHECK: # | Error: 'env' cannot call 'export'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-mkdir.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"mkdir\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'mkdir'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 mkdir foobar\n+# CHECK: # executed command: env -u FOO BAR=3 mkdir foobar\n+# CHECK: # | Error: 'env' cannot call 'mkdir'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-not-builtin.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"not\" \"rm\" \"{{.*}}.no-such-file\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 not rm {{.+}}.no-such-file\n+# CHECK: # executed command: env -u FOO BAR=3 not rm {{.+}}.no-such-file{{.*}}\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-rm.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"rm\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 rm foobar\n+# CHECK: # executed command: env -u FOO BAR=3 rm foobar\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: PASS: shtest-env :: env-u.txt ({{[^)]*}})\n-# CHECK: $ \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: env -u FOO [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO -u BAR [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO -u BAR [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: PASS: shtest-env :: env.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"A_FOO=999\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"A_FOO=1\" \"B_BAR=2\" \"C_OOF=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env A_FOO=999 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=999 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env A_FOO=1 B_BAR=2 C_OOF=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=1 B_BAR=2 C_OOF=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: PASS: shtest-env :: mixed.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"A_FOO=999\" \"-u\" \"FOO\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"A_FOO=1\" \"-u\" \"FOO\" \"B_BAR=2\" \"-u\" \"BAR\" \"C_OOF=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env A_FOO=999 -u FOO [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=999 -u FOO [[PYTHON_BARE]] print_environment.py\n+# CHECK: env A_FOO=1 -u FOO B_BAR=2 -u BAR C_OOF=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=1 -u FOO B_BAR=2 -u BAR C_OOF=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: Passed:  4\n # CHECK: Failed: 12\ndiff --git a/llvm/utils/lit/tests/shtest-format.py b/llvm/utils/lit/tests/shtest-format.py\nindex 621776ab7bc2..4a3d65b7bce4 100644\n--- a/llvm/utils/lit/tests/shtest-format.py\n+++ b/llvm/utils/lit/tests/shtest-format.py\n@@ -43,13 +43,21 @@\n # CHECK-EMPTY:\n #  CHECK-NEXT: Command Output (stdout):\n #  CHECK-NEXT: --\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-#  CHECK-NEXT: $ \"printf\"\n-#  CHECK-NEXT: # command output:\n-#  CHECK-NEXT: line 1: failed test output on stdout\n-#  CHECK-NEXT: line 2: failed test output on stdout\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-#  CHECK-NEXT: $ \"false\"\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: printf \"line 1: failed test output on stdout\\nline 2: failed test output on stdout\"\n+#  CHECK-NEXT: executed command: printf 'line 1: failed test output on stdout\\nline 2: failed test output on stdout'\n+#  CHECK-NEXT: # .---command stdout------------\n+#  CHECK-NEXT: # | line 1: failed test output on stdout\n+#  CHECK-NEXT: # | line 2: failed test output on stdout\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # RUN: at line 2\n+#  CHECK-NEXT: false\n+#  CHECK-NEXT: # executed command: false\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: --\n+\n \n # CHECK: UNRESOLVED: shtest-format :: no-test-line.txt\n # CHECK: PASS: shtest-format :: pass.txt\n@@ -73,8 +81,11 @@\n # CHECK-EMPTY:\n #  CHECK-NEXT: Command Output (stdout):\n #  CHECK-NEXT: --\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-#  CHECK-NEXT: $ \"true\"\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: true\n+#  CHECK-NEXT: # executed command: true\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: --\n \n # CHECK: Failed Tests (4)\n # CHECK: shtest-format :: external_shell/fail.txt\ndiff --git a/llvm/utils/lit/tests/shtest-if-else.py b/llvm/utils/lit/tests/shtest-if-else.py\nindex aaf94a6e2437..c18da4abbcca 100644\n--- a/llvm/utils/lit/tests/shtest-if-else.py\n+++ b/llvm/utils/lit/tests/shtest-if-else.py\n@@ -1,5 +1,6 @@\n # RUN: %{lit} -v --show-all %{inputs}/shtest-if-else/test.txt \\\n-# RUN:    | FileCheck %{inputs}/shtest-if-else/test.txt --match-full-lines\n+# RUN:    | FileCheck %{inputs}/shtest-if-else/test.txt --match-full-lines \\\n+# RUN:                --implicit-check-not='RUN:'\n \n # RUN: not %{lit} -v --show-all %{inputs}/shtest-if-else/test-neg1.txt 2>&1 \\\n # RUN:    | FileCheck %{inputs}/shtest-if-else/test-neg1.txt\ndiff --git a/llvm/utils/lit/tests/shtest-inject.py b/llvm/utils/lit/tests/shtest-inject.py\nindex 17e293ea1a12..3d34eb7161d4 100644\n--- a/llvm/utils/lit/tests/shtest-inject.py\n+++ b/llvm/utils/lit/tests/shtest-inject.py\n@@ -1,9 +1,26 @@\n-# Check that we can inject commands at the beginning of a ShTest.\n+# Check that we can inject preamble commands at the beginning of a ShTest.\n+#\n+# For one case, check the execution trace as these preamble commands have\n+# \"preamble command\" instead of the usual \"{{RUN}}: at line N\".\n \n # RUN: %{lit} %{inputs}/shtest-inject/test-empty.txt --show-all | FileCheck --check-prefix=CHECK-TEST1 %s\n #\n-# CHECK-TEST1: THIS WAS\n-# CHECK-TEST1: INJECTED\n+#       CHECK-TEST1: Command Output (stdout):\n+#  CHECK-TEST1-NEXT: --\n+#  CHECK-TEST1-NEXT: # preamble command line\n+#  CHECK-TEST1-NEXT: echo \"THIS WAS\"\n+#  CHECK-TEST1-NEXT: # executed command: echo 'THIS WAS'\n+#  CHECK-TEST1-NEXT: # .---command stdout{{-*}}\n+#  CHECK-TEST1-NEXT: # | THIS WAS\n+#  CHECK-TEST1-NEXT: # `---{{-*}}\n+#  CHECK-TEST1-NEXT: # preamble command line\n+#  CHECK-TEST1-NEXT: echo \"INJECTED\"\n+#  CHECK-TEST1-NEXT: # executed command: echo INJECTED\n+#  CHECK-TEST1-NEXT: # .---command stdout{{-*}}\n+#  CHECK-TEST1-NEXT: # | INJECTED\n+#  CHECK-TEST1-NEXT: # `---{{-*}}\n+# CHECK-TEST1-EMPTY:\n+#  CHECK-TEST1-NEXT: --\n #\n # CHECK-TEST1: Passed: 1\n \ndiff --git a/llvm/utils/lit/tests/shtest-not.py b/llvm/utils/lit/tests/shtest-not.py\nindex d23c9d0cffaf..f514cddf1def 100644\n--- a/llvm/utils/lit/tests/shtest-not.py\n+++ b/llvm/utils/lit/tests/shtest-not.py\n@@ -10,112 +10,158 @@\n # CHECK: -- Testing: 17 tests{{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-args-nested-none.txt {{.*}}\n-# CHECK: $ \"!\" \"!\" \"!\"\n-# CHECK: Error: '!' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: ! ! !\n+# CHECK: # executed command: ! ! !\n+# CHECK: # | Error: '!' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-args-none.txt {{.*}}\n-# CHECK: $ \"!\"\n-# CHECK: Error: '!' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: !\n+# CHECK: # executed command: !\n+# CHECK: # | Error: '!' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-calls-external.txt {{.*}}\n \n-# CHECK: $ \"!\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"!\" \"!\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"!\" \"!\" \"!\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"!\" \"!\" \"!\" \"!\" \"{{[^\"]*}}\" \"pass.py\"\n+# CHECK: ! [[PYTHON:.*]] fail.py\n+# CHECK: # executed command: ! [[PYTHON_BARE:.*]] fail.py\n+# CHECK: ! ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! ! [[PYTHON_BARE]] pass.py\n+# CHECK: ! ! ! [[PYTHON]] fail.py\n+# CHECK: # executed command: ! ! ! [[PYTHON_BARE]] fail.py\n+# CHECK: ! ! ! ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! ! ! ! [[PYTHON_BARE]] pass.py\n \n-# CHECK: $ \"!\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! [[PYTHON_BARE]] pass.py\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-last-is-crash.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not --crash\n+# CHECK: # executed command: not --crash\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-nested-none.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not not\n+# CHECK: # executed command: not not not\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-none.txt {{.*}}\n-# CHECK: $ \"not\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not\n+# CHECK: # executed command: not\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-cd.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"cd\" \"foobar\"\n-# CHECK: $ \"not\" \"--crash\" \"cd\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'cd'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not cd foobar\n+# CHECK: # executed command: not not cd foobar\n+# CHECK: not --crash cd foobar\n+# CHECK: # executed command: not --crash cd foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'cd'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-colon.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \":\" \"foobar\"\n-# CHECK: $ \"not\" \"--crash\" \":\"\n-# CHECK: Error: 'not --crash' cannot call ':'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not : foobar\n+# CHECK: # executed command: not not : foobar\n+# CHECK: not --crash :\n+# CHECK: # executed command: not --crash :\n+# CHECK: # | Error: 'not --crash' cannot call ':'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-diff-with-crash.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"diff\" \"-u\" {{.*}}\n-# CHECK-NOT: \"$\"\n+# CHECK: not --crash diff -u {{.*}}\n+# CHECK: # executed command: not --crash diff -u {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n # CHECK-NOT: {{[Ee]rror}}\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: # error: command failed with exit status: {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n # CHECK-NOT: {{[Ee]rror}}\n-# CHECK-NOT: \"$\"\n \n # CHECK: FAIL: shtest-not :: not-calls-diff.txt {{.*}}\n-# CHECK: $ \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"diff\" {{.*}}\n-# CHECK-NOT: \"$\"\n+# CHECK: not diff {{.*}}\n+# CHECK: # executed command: not diff {{.*}}\n+# CHECK: not not not diff {{.*}}\n+# CHECK: # executed command: not not not diff {{.*}}\n+# CHECK: not not not not not diff {{.*}}\n+# CHECK: # executed command: not not not not not diff {{.*}}\n+# CHECK: diff {{.*}}\n+# CHECK: # executed command: diff {{.*}}\n+# CHECK: not not diff {{.*}}\n+# CHECK: # executed command: not not diff {{.*}}\n+# CHECK: not not not not diff {{.*}}\n+# CHECK: # executed command: not not not not diff {{.*}}\n+# CHECK: not diff {{.*}}\n+# CHECK: # executed command: not diff {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-echo.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"echo\" \"hello\" \"world\"\n-# CHECK: $ \"not\" \"--crash\" \"echo\" \"hello\" \"world\"\n-# CHECK: Error: 'not --crash' cannot call 'echo'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not echo hello world\n+# CHECK: # executed command: not not echo hello world\n+# CHECK: not --crash echo hello world\n+# CHECK: # executed command: not --crash echo hello world\n+# CHECK: # | Error: 'not --crash' cannot call 'echo'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-env-builtin.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"env\" \"-u\" \"FOO\" \"BAR=3\" \"rm\" \"{{.*}}.no-such-file\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not --crash env -u FOO BAR=3 rm {{.*}}.no-such-file\n+# CHECK: # executed command: not --crash env -u FOO BAR=3 rm {{.+}}.no-such-file{{.*}}\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-export.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"export\" \"FOO=1\"\n-# CHECK: $ \"not\" \"--crash\" \"export\" \"BAZ=3\"\n-# CHECK: Error: 'not --crash' cannot call 'export'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not export FOO=1\n+# CHECK: # executed command: not not export FOO=1\n+# CHECK: not --crash export BAZ=3\n+# CHECK: # executed command: not --crash export BAZ=3\n+# CHECK: # | Error: 'not --crash' cannot call 'export'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n \n # CHECK: PASS: shtest-not :: not-calls-external.txt {{.*}}\n \n-# CHECK: $ \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-\n-# CHECK: $ \"env\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"env\" \"-u\" \"FOO\" \"BAR=2\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"env\" \"-u\" \"FOO\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"env\" \"FOO=1\" \"env\" \"FOO=2\" \"BAR=1\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"-u\" \"BAR\" \"env\" \"-u\" \"FOO\" \"BAR=1\" \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"env\" \"FOO=2\" \"BAR=2\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"env\" \"-u\" \"BAR\" \"not\" \"env\" \"-u\" \"FOO\" \"BAR=1\" \"{{[^\"]*}}\" \"pass.py\"\n+# CHECK: not [[PYTHON]] fail.py\n+# CHECK: # executed command: not [[PYTHON_BARE]] fail.py\n+# CHECK: not not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not [[PYTHON_BARE]] pass.py\n+# CHECK: not not not [[PYTHON]] fail.py\n+# CHECK: # executed command: not not not [[PYTHON_BARE]] fail.py\n+# CHECK: not not not not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not not not [[PYTHON_BARE]] pass.py\n+\n+# CHECK: not not --crash [[PYTHON]] pass.py\n+# CHECK: # executed command: not not --crash [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash [[PYTHON]] fail.py\n+# CHECK: # executed command: not not --crash [[PYTHON_BARE]] fail.py\n+# CHECK: not not --crash not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not --crash not [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash not [[PYTHON]] fail.py\n+# CHECK: # executed command: not not --crash not [[PYTHON_BARE]] fail.py\n+\n+# CHECK: env not [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env not [[PYTHON_BARE]] fail.py\n+# CHECK: not env [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: not env [[PYTHON_BARE]] fail.py\n+# CHECK: env FOO=1 not [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 not [[PYTHON_BARE]] fail.py\n+# CHECK: not env FOO=1 BAR=1 [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 [[PYTHON_BARE]] fail.py\n+# CHECK: env FOO=1 BAR=1 not env -u FOO BAR=2 [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 BAR=1 not env -u FOO BAR=2 [[PYTHON_BARE]] fail.py\n+# CHECK: not env FOO=1 BAR=1 not env -u FOO -u BAR [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 not env -u FOO -u BAR [[PYTHON_BARE]] pass.py\n+# CHECK: not not env FOO=1 env FOO=2 BAR=1 [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not not env FOO=1 env FOO=2 BAR=1 [[PYTHON_BARE]] pass.py\n+# CHECK: env FOO=1 -u BAR env -u FOO BAR=1 not not [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 -u BAR env -u FOO BAR=1 not not [[PYTHON_BARE]] pass.py\n+\n+# CHECK: not env FOO=1 BAR=1 env FOO=2 BAR=2 not --crash [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 env FOO=2 BAR=2 not --crash [[PYTHON_BARE]] pass.py\n+# CHECK: not env FOO=1 BAR=1 not --crash not [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 not --crash not [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash env -u BAR not env -u FOO BAR=1 [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not not --crash env -u BAR not env -u FOO BAR=1 [[PYTHON_BARE]] pass.py\n \n \n # CHECK: FAIL: shtest-not :: not-calls-fail2.txt {{.*}}\n@@ -123,16 +169,20 @@\n # CHECK-NEXT: Exit Code: 1\n \n # CHECK: FAIL: shtest-not :: not-calls-mkdir.txt {{.*}}\n-# CHECK: $ \"not\" \"mkdir\" {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"mkdir\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'mkdir'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not mkdir {{.*}}\n+# CHECK: # executed command: not mkdir {{.*}}\n+# CHECK: not --crash mkdir foobar\n+# CHECK: # executed command: not --crash mkdir foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'mkdir'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-rm.txt {{.*}}\n-# CHECK: $ \"not\" \"rm\" {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"rm\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not rm {{.*}}\n+# CHECK: # executed command: not rm {{.*}}\n+# CHECK: not --crash rm foobar\n+# CHECK: # executed command: not --crash rm foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: Passed:  1\n # CHECK: Failed: 16\ndiff --git a/llvm/utils/lit/tests/shtest-output-printing.py b/llvm/utils/lit/tests/shtest-output-printing.py\nindex 7cd975ba8d3c..129cff981eb5 100644\n--- a/llvm/utils/lit/tests/shtest-output-printing.py\n+++ b/llvm/utils/lit/tests/shtest-output-printing.py\n@@ -1,28 +1,45 @@\n # Check the various features of the ShTest format.\n #\n # RUN: not %{lit} -v %{inputs}/shtest-output-printing > %t.out\n-# RUN: FileCheck --input-file %t.out %s\n+# RUN: FileCheck --input-file %t.out --match-full-lines %s\n #\n # END.\n \n-# CHECK: -- Testing:\n-\n-# CHECK: FAIL: shtest-output-printing :: basic.txt\n-# CHECK-NEXT: *** TEST 'shtest-output-printing :: basic.txt' FAILED ***\n-# CHECK-NEXT: Exit Code: 1\n-#\n-# CHECK:      Command Output\n-# CHECK-NEXT: --\n-# CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \"true\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-# CHECK-NEXT: $ \"echo\" \"hi\"\n-# CHECK-NEXT: # command output:\n-# CHECK-NEXT: hi\n-#\n-# CHECK:      $ \":\" \"RUN: at line 3\"\n-# CHECK-NEXT: $ \"not\" \"not\" \"wc\" \"missing-file\"\n-# CHECK-NEXT: # redirected output from '{{.*(/|\\\\\\\\)}}basic.txt.tmp.out':\n-# CHECK-NEXT: {{cannot open missing-file|missing-file.* No such file or directory}}\n-# CHECK:      note: command had no output on stdout or stderr\n-# CHECK-NEXT: error: command failed with exit status: 1\n+#       CHECK: -- Testing: {{.*}}\n+#       CHECK: FAIL: shtest-output-printing :: basic.txt {{.*}}\n+#  CHECK-NEXT: ***{{\\**}} TEST 'shtest-output-printing :: basic.txt' FAILED ***{{\\**}}\n+#  CHECK-NEXT: Exit Code: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: Command Output (stdout):\n+#  CHECK-NEXT: --\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: true\n+#  CHECK-NEXT: # executed command: true\n+#  CHECK-NEXT: # RUN: at line 2\n+#  CHECK-NEXT: echo hi\n+#  CHECK-NEXT: # executed command: echo hi\n+#  CHECK-NEXT: # .---command stdout------------\n+#  CHECK-NEXT: # | hi\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # RUN: at line 3\n+#  CHECK-NEXT: not not wc missing-file &> [[FILE:.*]] || true\n+#  CHECK-NEXT: # executed command: not not wc missing-file\n+#  CHECK-NEXT: # .---redirected output from '[[FILE]]'\n+#  CHECK-NEXT: # | wc: {{cannot open missing-file|missing-file.* No such file or directory}}\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+#  CHECK-NEXT: # executed command: true\n+#  CHECK-NEXT: # RUN: at line 4\n+#  CHECK-NEXT: not {{.*}}python{{.*}} {{.*}}write-a-lot.py &> [[FILE:.*]]\n+#  CHECK-NEXT: # executed command: not {{.*}}python{{.*}} {{.*}}write-a-lot.py{{.*}}\n+#  CHECK-NEXT: # .---redirected output from '[[FILE]]'\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#       CHECK: # | ...\n+#  CHECK-NEXT: # `---data was truncated--------\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT:--\ndiff --git a/llvm/utils/lit/tests/shtest-pushd-popd.py b/llvm/utils/lit/tests/shtest-pushd-popd.py\nindex 26296a7ffcf5..6d7e93c74a05 100644\n--- a/llvm/utils/lit/tests/shtest-pushd-popd.py\n+++ b/llvm/utils/lit/tests/shtest-pushd-popd.py\n@@ -8,16 +8,16 @@\n # CHECK: -- Testing: 4 tests{{.*}}\n \n # CHECK: FAIL: shtest-pushd-popd :: popd-args.txt ({{[^)]*}})\n-# CHECK: $ \"popd\" \"invalid\"\n-# CHECK: 'popd' does not support arguments\n+# CHECK: popd invalid\n+# CHECK: # | 'popd' does not support arguments\n \n # CHECK: FAIL: shtest-pushd-popd :: popd-no-stack.txt ({{[^)]*}})\n-# CHECK: $ \"popd\"\n-# CHECK: popd: directory stack empty\n+# CHECK: popd\n+# CHECK: # | popd: directory stack empty\n \n # CHECK: FAIL: shtest-pushd-popd :: pushd-too-many-args.txt ({{[^)]*}})\n-# CHECK: $ \"pushd\" \"a\" \"b\"\n-# CHECK: 'pushd' supports only one argument\n+# CHECK: pushd a b\n+# CHECK: # | 'pushd' supports only one argument\n \n # CHECK: Passed:  1\n # CHECK: Failed:  3\ndiff --git a/llvm/utils/lit/tests/shtest-recursive-substitution.py b/llvm/utils/lit/tests/shtest-recursive-substitution.py\nindex 48f4b5b12491..65c177e65a3c 100644\n--- a/llvm/utils/lit/tests/shtest-recursive-substitution.py\n+++ b/llvm/utils/lit/tests/shtest-recursive-substitution.py\n@@ -3,7 +3,7 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/substitutes-within-limit --show-all | FileCheck --check-prefix=CHECK-TEST1 %s\n # CHECK-TEST1: PASS: substitutes-within-limit :: test.py\n-# CHECK-TEST1: $ \"echo\" \"STOP\"\n+# CHECK-TEST1: echo STOP\n \n # RUN: not %{lit} %{inputs}/shtest-recursive-substitution/does-not-substitute-within-limit --show-all | FileCheck --check-prefix=CHECK-TEST2 %s\n # CHECK-TEST2: UNRESOLVED: does-not-substitute-within-limit :: test.py\n@@ -11,7 +11,7 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/does-not-substitute-no-limit --show-all | FileCheck --check-prefix=CHECK-TEST3 %s\n # CHECK-TEST3: PASS: does-not-substitute-no-limit :: test.py\n-# CHECK-TEST3: $ \"echo\" \"%rec4\"\n+# CHECK-TEST3: echo %rec4\n \n # RUN: not %{lit} %{inputs}/shtest-recursive-substitution/not-an-integer --show-all 2>&1 | FileCheck --check-prefix=CHECK-TEST4 %s\n # CHECK-TEST4: recursiveExpansionLimit must be either None or an integer\n@@ -24,4 +24,4 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/escaping --show-all | FileCheck --check-prefix=CHECK-TEST7 %s\n # CHECK-TEST7: PASS: escaping :: test.py\n-# CHECK-TEST7: $ \"echo\" \"%s\" \"%s\" \"%%s\"\n+# CHECK-TEST7: echo %s %s %%s\ndiff --git a/llvm/utils/lit/tests/shtest-run-at-line.py b/llvm/utils/lit/tests/shtest-run-at-line.py\nindex 879cd64ebf6e..a0626f872c4c 100644\n--- a/llvm/utils/lit/tests/shtest-run-at-line.py\n+++ b/llvm/utils/lit/tests/shtest-run-at-line.py\n@@ -28,21 +28,28 @@\n # CHECK-LABEL: FAIL: shtest-run-at-line :: internal-shell/basic.txt\n \n # CHECK:      Command Output (stdout)\n-# CHECK:      $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \"true\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-# CHECK-NEXT: $ \"false\"\n+# CHECK-NEXT: --\n+# CHECK-NEXT: # RUN: at line 1\n+# CHECK-NEXT: true\n+# CHECK-NEXT: # executed command: true\n+# CHECK-NEXT: # RUN: at line 2\n+# CHECK-NEXT: false\n+# CHECK-NEXT: # executed command: false\n # CHECK-NOT:  RUN\n \n # CHECK-LABEL: FAIL: shtest-run-at-line :: internal-shell/line-continuation.txt\n \n # CHECK:      Command Output (stdout)\n-# CHECK:      $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \":\" \"first\" \"line\" \"continued\" \"to\" \"second\" \"line\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 3\"\n-# CHECK-NEXT: $ \"echo\" \"foo bar\"\n-# CHECK-NEXT: $ \"FileCheck\" \"{{.*}}\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 5\"\n-# CHECK-NEXT: $ \"echo\" \"foo baz\"\n-# CHECK-NEXT: $ \"FileCheck\" \"{{.*}}\"\n+# CHECK-NEXT: --\n+# CHECK-NEXT: # RUN: at line 1\n+# CHECK-NEXT: : first line continued to second line\n+# CHECK-NEXT: # executed command: : first line continued to second line\n+# CHECK-NEXT: # RUN: at line 3\n+# CHECK-NEXT: echo 'foo bar' | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: echo 'foo bar'\n+# CHECK-NEXT: # executed command: FileCheck {{.*}}\n+# CHECK-NEXT: # RUN: at line 5\n+# CHECK-NEXT: echo 'foo baz' | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: echo 'foo baz'\n+# CHECK-NEXT: # executed command: FileCheck {{.*}}\n # CHECK-NOT:  RUN\ndiff --git a/llvm/utils/lit/tests/shtest-shell.py b/llvm/utils/lit/tests/shtest-shell.py\nindex 93f05dbd35d0..a043582d6ae2 100644\n--- a/llvm/utils/lit/tests/shtest-shell.py\n+++ b/llvm/utils/lit/tests/shtest-shell.py\n@@ -20,202 +20,212 @@\n \n # CHECK: FAIL: shtest-shell :: cat-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: cat-error-0.txt' FAILED ***\n-# CHECK: $ \"cat\" \"-b\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'cat':  option -b not recognized\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: cat -b temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'cat':  option -b not recognized\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: cat-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: cat-error-1.txt' FAILED ***\n-# CHECK: $ \"cat\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: [Errno 2] No such file or directory: 'temp1.txt'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: cat temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | [Errno 2] No such file or directory: 'temp1.txt'\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: colon-error.txt\n # CHECK: *** TEST 'shtest-shell :: colon-error.txt' FAILED ***\n-# CHECK: $ \":\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: ':' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: :\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: ':' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: PASS: shtest-shell :: continuations.txt\n \n # CHECK: PASS: shtest-shell :: dev-null.txt\n \n-# CHECK: FAIL: shtest-shell :: diff-b.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-b.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-b\" \"{{[^\"]*}}.0\" \"{{[^\"]*}}.1\"\n-# CHECK: # command output:\n-# CHECK: 1,2\n-# CHECK-NEXT: {{^  }}f o o\n-# CHECK-NEXT: ! b a r\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: {{^  }}f o o\n-# CHECK-NEXT: ! bar\n-# CHECK-EMPTY:\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-b.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-b.txt' FAILED ***\n+#      CHECK: diff -b {{[^\"]*}}.0 {{[^\"]*}}.1\n+#      CHECK: # .---command stdout{{-*}}\n+#      CHECK: # | {{.*}}1,2\n+# CHECK-NEXT: # |   f o o\n+# CHECK-NEXT: # | ! b a r\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # |   f o o\n+# CHECK-NEXT: # | ! bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+#      CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-encodings.txt\n # CHECK: *** TEST 'shtest-shell :: diff-encodings.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"diff-in.bin\"\n+#      CHECK: diff -u diff-in.bin diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.bin diff-in.bin\n+#  CHECK-NOT: error\n+\n+#      CHECK: diff -u diff-in.utf16 diff-in.bin && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf16 diff-in.bin\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.utf8 diff-in.bin && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf8 diff-in.bin\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | -baz\n+# CHECK-NEXT: # | {{\\+.f.o.o.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{\\+.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.bin diff-in.utf8 && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.bin diff-in.utf8\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{-.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.}}\n+# CHECK-NEXT: # | {{-.b.a.z.$}}\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # | +baz\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#     CHECK: cat diff-in.bin | diff -u - diff-in.bin\n # CHECK-NOT: error\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf16\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^ .f.o.o.$}}\n-# CHECK-NEXT: {{^-.b.a.r.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^ .b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf8\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: -baz\n-# CHECK-NEXT: {{^\\+.f.o.o.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^\\+.b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"diff-in.utf8\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^\\-.f.o.o.$}}\n-# CHECK-NEXT: {{^\\-.b.a.r.}}\n-# CHECK-NEXT: {{^\\-.b.a.z.$}}\n-# CHECK-NEXT: +foo\n-# CHECK-NEXT: +bar\n-# CHECK-NEXT: +baz\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"-\"\n-# CHECK-NOT: error\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf16\" \"-\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^ .f.o.o.$}}\n-# CHECK-NEXT: {{^-.b.a.r.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^ .b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n+#     CHECK: cat diff-in.bin | diff -u diff-in.bin -\n # CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf8\" \"-\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: -baz\n-# CHECK-NEXT: {{^\\+.f.o.o.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^\\+.b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"diff-in.utf8\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^\\-.f.o.o.$}}\n-# CHECK-NEXT: {{^\\-.b.a.r.}}\n-# CHECK-NEXT: {{^\\-.b.a.z.$}}\n-# CHECK-NEXT: +foo\n-# CHECK-NEXT: +bar\n-# CHECK-NEXT: +baz\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n \n-# CHECK: $ \"false\"\n+#      CHECK: cat diff-in.bin | diff -u diff-in.utf16 - && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf16 -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat diff-in.bin | diff -u diff-in.utf8 - && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf8 -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | -baz\n+# CHECK-NEXT: # | {{\\+.f.o.o.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{\\+.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat diff-in.bin | diff -u - diff-in.utf8 && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u - diff-in.utf8\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{-.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.}}\n+# CHECK-NEXT: # | {{-.b.a.z.$}}\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # | +baz\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-1.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-B\" \"temp1.txt\" \"temp2.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'diff': option -B not recognized\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -B temp1.txt temp2.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'diff': option -B not recognized\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-2.txt' FAILED ***\n-# CHECK: $ \"diff\" \"temp.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff temp.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-3.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-3.txt' FAILED ***\n-# CHECK: $ \"diff\" \"temp.txt\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'diff' command failed\n+# CHECK: diff temp.txt temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'diff' command failed\n # CHECK: error: command failed with exit status: 1\n # CHECK: ***\n \n-# CHECK: FAIL: shtest-shell :: diff-error-4.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-error-4.txt' FAILED ***\n-# CHECK: Exit Code: 1\n-# CHECK: # command output:\n-# CHECK: diff-error-4.txt.tmp\n-# CHECK: diff-error-4.txt.tmp1\n-# CHECK: *** 1 ****\n-# CHECK: ! hello-first\n-# CHECK: --- 1 ----\n-# CHECK: ! hello-second\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-error-4.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-error-4.txt' FAILED ***\n+#      CHECK: Exit Code: 1\n+#      CHECK: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | {{.*}}diff-error-4.txt.tmp\n+# CHECK-NEXT: # | {{.*}}diff-error-4.txt.tmp1\n+# CHECK-NEXT: # | {{\\*+}}\n+# CHECK-NEXT: # | *** 1 ****\n+# CHECK-NEXT: # | ! hello-first\n+# CHECK-NEXT: # | --- 1 ----\n+# CHECK-NEXT: # | ! hello-second\n+# CHECK-NEXT: # `---{{-*}}\n+#      CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-5.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-5.txt' FAILED ***\n-# CHECK: $ \"diff\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-6.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-6.txt' FAILED ***\n-# CHECK: $ \"diff\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n \n@@ -223,137 +233,130 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-pipes.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.foo\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"FileCheck\"\n+# CHECK: diff {{[^ ]*}}.foo {{.*}}.foo | FileCheck {{.*}}\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: note: command had no output on stdout or stderr\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"FileCheck\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"true\"\n+#      CHECK: diff -u {{.*}}.foo {{.*}}.bar | FileCheck {{.*}} && false || true\n+# CHECK-NEXT: # executed command: diff -u {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # note: command had no output on stdout or stderr\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: FileCheck\n+# CHECK-NEXT: # executed command: true\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"{{[^\"]*}}.foo\"\n+#     CHECK: cat {{.*}}.foo | diff -u - {{.*}}.foo\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n+#     CHECK: cat {{.*}}.foo | diff -u {{.*}}.foo -\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: +bar\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"{{[^\"]*}}.foo\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: +foo\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-\" \"{{[^\"]*}}.foo\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"FileCheck\"\n+#      CHECK: cat {{.*}}.bar | diff -u {{.*}}.foo - && false || true\n+# CHECK-NEXT: # executed command: cat {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # executed command: diff -u {{.+}}.foo{{.*}} -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat {{.*}}.bar | diff -u - {{.*}}.foo && false || true\n+# CHECK-NEXT: # executed command: cat {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # executed command: diff -u - {{.+}}.foo{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#     CHECK: cat {{.*}}.foo | diff - {{.*}}.foo | FileCheck {{.*}}\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n-# CHECK: note: command had no output on stdout or stderr\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"FileCheck\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"true\"\n+#      CHECK: cat {{.*}}.bar | diff -u {{.*}}.foo - | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: cat {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # executed command: diff -u {{.+}}.foo{{.*}} -\n+# CHECK-NEXT: note: command had no output on stdout or stderr\n+# CHECK-NEXT: error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: FileCheck\n+# CHECK-NEXT: # executed command: true\n \n-# CHECK: $ \"false\"\n+# CHECK: false\n \n # CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-r-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-0.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: dir1unique\n-# CHECK: Only in {{.*}}dir2: dir2unique\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: dir1unique\n+# CHECK: # | Only in {{.*}}dir2: dir2unique\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-1.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: *** {{.*}}dir1{{.*}}subdir{{.*}}f01\n-# CHECK: --- {{.*}}dir2{{.*}}subdir{{.*}}f01\n-# CHECK: 12345\n-# CHECK: 00000\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | *** {{.*}}dir1{{.*}}subdir{{.*}}f01\n+# CHECK: # | --- {{.*}}dir2{{.*}}subdir{{.*}}f01\n+# CHECK: # | ! 12345\n+# CHECK: # | ! 00000\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-2.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir2: extrafile\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir2: extrafile\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-3.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-3.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: extra_subdir\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: extra_subdir\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-4.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-4.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: File {{.*}}dir1{{.*}}extra_subdir is a directory while file {{.*}}dir2{{.*}}extra_subdir is a regular file\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | File {{.*}}dir1{{.*}}extra_subdir is a directory while file {{.*}}dir2{{.*}}extra_subdir is a regular file\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-5.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-5.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: extra_subdir\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: extra_subdir\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-6.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-6.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: File {{.*}}dir1{{.*}}extra_file is a regular empty file while file {{.*}}dir2{{.*}}extra_file is a directory\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | File {{.*}}dir1{{.*}}extra_file is a regular empty file while file {{.*}}dir2{{.*}}extra_file is a directory\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-7.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-7.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\" \"-\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: cannot recursively compare '-'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r - {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: cannot recursively compare '-'\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-8.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-8.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\" \"{{[^\"]*}}\" \"-\"\n-# CHECK: # command stderr:\n-# CHECK: Error: cannot recursively compare '-'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r {{.*}} -\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: cannot recursively compare '-'\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: PASS: shtest-shell :: diff-r.txt\n \n@@ -362,51 +365,59 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-strip-trailing-cr.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.dos\" \"diff-in.unix\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -In this file, the\n-# CHECK-NEXT: -sequence \"\\r\\n\"\n-# CHECK-NEXT: -terminates lines.\n-# CHECK-NEXT: +In this file, the\n-# CHECK-NEXT: +sequence \"\\n\"\n-# CHECK-NEXT: +terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.unix\" \"diff-in.dos\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -In this file, the\n-# CHECK-NEXT: -sequence \"\\n\"\n-# CHECK-NEXT: -terminates lines.\n-# CHECK-NEXT: +In this file, the\n-# CHECK-NEXT: +sequence \"\\r\\n\"\n-# CHECK-NEXT: +terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"--strip-trailing-cr\" \"diff-in.dos\" \"diff-in.unix\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT:  In this file, the\n-# CHECK-NEXT: -sequence \"\\r\\n\"\n-# CHECK-NEXT: +sequence \"\\n\"\n-# CHECK-NEXT:  terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"--strip-trailing-cr\" \"diff-in.unix\" \"diff-in.dos\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT:  In this file, the\n-# CHECK-NEXT: -sequence \"\\n\"\n-# CHECK-NEXT: +sequence \"\\r\\n\"\n-# CHECK-NEXT:  terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"false\"\n+#      CHECK: diff -u diff-in.dos diff-in.unix && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.dos diff-in.unix\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -In this file, the\n+# CHECK-NEXT: # | -sequence \"\\r\\n\"\n+# CHECK-NEXT: # | -terminates lines.\n+# CHECK-NEXT: # | +In this file, the\n+# CHECK-NEXT: # | +sequence \"\\n\"\n+# CHECK-NEXT: # | +terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.unix diff-in.dos && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.unix diff-in.dos\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -In this file, the\n+# CHECK-NEXT: # | -sequence \"\\n\"\n+# CHECK-NEXT: # | -terminates lines.\n+# CHECK-NEXT: # | +In this file, the\n+# CHECK-NEXT: # | +sequence \"\\r\\n\"\n+# CHECK-NEXT: # | +terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u --strip-trailing-cr diff-in.dos diff-in.unix && false || true\n+# CHECK-NEXT: executed command: diff -u --strip-trailing-cr diff-in.dos diff-in.unix\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # |  In this file, the\n+# CHECK-NEXT: # | -sequence \"\\r\\n\"\n+# CHECK-NEXT: # | +sequence \"\\n\"\n+# CHECK-NEXT: # |  terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u --strip-trailing-cr diff-in.unix diff-in.dos && false || true\n+# CHECK-NEXT: # executed command: diff -u --strip-trailing-cr diff-in.unix diff-in.dos\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # |  In this file, the\n+# CHECK-NEXT: # | -sequence \"\\n\"\n+# CHECK-NEXT: # | +sequence \"\\r\\n\"\n+# CHECK-NEXT: # |  terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n@@ -415,106 +426,144 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-unified.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 3\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-NEXT: 9\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U\" \"2\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U4\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 2\n-# CHECK-NEXT: 3\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-NEXT: 9\n-# CHECK-NEXT: 10\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U0\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U\" \"30.1\" \"{{[^\"]*}}\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: invalid '-U' argument: 30.1\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U-1\" \"{{[^\"]*}}\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: invalid '-U' argument: -1\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"false\"\n+#      CHECK: diff -u {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -u {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 3\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # | 9\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U 2 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U 2 {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U4 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U4 {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 2\n+# CHECK-NEXT: # | 3\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # | 9\n+# CHECK-NEXT: # | 10\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U0 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U0 {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: diff -U 30.1 {{.*}} {{.*}} && false || true\n+# CHECK: # executed command: diff -U 30.1 {{.*}} {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: invalid '-U' argument: 30.1\n+# CHECK: # error: command failed with exit status: 1\n+# CHECK: # executed command: true\n+\n+# CHECK: diff -U-1 {{.*}} {{.*}} && false || true\n+# CHECK: # executed command: diff -U-1 {{.*}} {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: invalid '-U' argument: -1\n+# CHECK: # error: command failed with exit status: 1\n+# CHECK: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n \n-# CHECK: FAIL: shtest-shell :: diff-w.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-w.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-w\" \"{{[^\"]*}}.0\" \"{{[^\"]*}}.1\"\n-# CHECK: # command output:\n-# CHECK: 1,3\n-# CHECK-NEXT: {{^  }}foo\n-# CHECK-NEXT: {{^  }}bar\n-# CHECK-NEXT: ! baz\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: {{^  }}foo\n-# CHECK-NEXT: {{^  }}bar\n-# CHECK-NEXT: ! bat\n-# CHECK-EMPTY:\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-w.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-w.txt' FAILED ***\n+#      CHECK: diff -w {{.*}}.0 {{.*}}.1\n+#      CHECK: # .---command stdout{{-*}}\n+#      CHECK: # | {{\\*+}} 1,3\n+# CHECK-NEXT: # |   foo\n+# CHECK-NEXT: # |   bar\n+# CHECK-NEXT: # | ! baz\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # |   foo\n+# CHECK-NEXT: # |   bar\n+# CHECK-NEXT: # | ! bat\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+#      CHECK: ***\n+\n+# CHECK: FAIL: shtest-shell :: echo-at-redirect-stderr.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-at-redirect-stderr.txt' FAILED ***\n+# CHECK: @echo 2> {{.*}}\n+# CHECK: # executed command: @echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for @echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-at-redirect-stdin.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-at-redirect-stdin.txt' FAILED ***\n+# CHECK: @echo < {{.*}}\n+# CHECK: # executed command: @echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for @echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-redirect-stderr.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-redirect-stderr.txt' FAILED ***\n+# CHECK: echo 2> {{.*}}\n+# CHECK: # executed command: echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-redirect-stdin.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-redirect-stdin.txt' FAILED ***\n+# CHECK: echo < {{.*}}\n+# CHECK: # executed command: echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for echo\n+# CHECK: error: command failed with exit status:\n \n # CHECK: FAIL: shtest-shell :: error-0.txt\n # CHECK: *** TEST 'shtest-shell :: error-0.txt' FAILED ***\n-# CHECK: $ \"not-a-real-command\"\n-# CHECK: # command stderr:\n-# CHECK: 'not-a-real-command': command not found\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: not-a-real-command\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | 'not-a-real-command': command not found\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # FIXME: The output here sucks.\n #\n # CHECK: FAIL: shtest-shell :: error-1.txt\n # CHECK: *** TEST 'shtest-shell :: error-1.txt' FAILED ***\n-# CHECK: shell parser error on: ': \\'RUN: at line 3\\'; echo \"missing quote'\n+# CHECK: shell parser error on RUN: at line 3: echo \"missing quote\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: error-2.txt\n@@ -524,52 +573,52 @@\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-0.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'mkdir' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p temp | rm -rf temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'mkdir' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-1.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\" \"-m\" \"777\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'mkdir': option -m not recognized\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p -m 777 temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'mkdir': option -m not recognized\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-2.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'mkdir' is missing an operand\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'mkdir' is missing an operand\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: PASS: shtest-shell :: redirects.txt\n \n # CHECK: FAIL: shtest-shell :: rm-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-0.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-rf\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'rm' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: rm -rf temp | echo \"hello\"\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'rm' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-1.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-f\" \"-v\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'rm': option -v not recognized\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: rm -f -v temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'rm': option -v not recognized\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-2.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-r\" \"hello\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'rm' command failed\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: rm -r hello\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'rm' command failed\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-3.txt\n@@ -581,16 +630,17 @@\n # CHECK: PASS: shtest-shell :: sequencing-0.txt\n # CHECK: XFAIL: shtest-shell :: sequencing-1.txt\n \n-# CHECK: FAIL: shtest-shell :: stdout-encoding.txt\n-# CHECK: *** TEST 'shtest-shell :: stdout-encoding.txt' FAILED ***\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: {{^.f.o.o.$}}\n-# CHECK-NEXT: {{^.b.a.r.}}\n-# CHECK-NEXT: {{^.b.a.z.$}}\n-# CHECK-NOT: error\n-# CHECK: $ \"false\"\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: stdout-encoding.txt\n+#      CHECK: *** TEST 'shtest-shell :: stdout-encoding.txt' FAILED ***\n+#      CHECK: cat diff-in.bin\n+#      CHECK: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+#  CHECK-NOT: error\n+#      CHECK: false\n+#      CHECK: ***\n \n # CHECK: PASS: shtest-shell :: valid-shell.txt\n-# CHECK: Failed Tests (35)\n+# CHECK: Failed Tests (39)\n", "message": "", "files": {"/libcxx/utils/libcxx/test/dsl.py": {"changes": [{"diff": "\n                 \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n             )\n \n-        return libcxx.test.format._parseLitOutput(out)\n+        return out\n \n \n @_memoizeExpensiveOperation(", "add": 1, "remove": 1, "filename": "/libcxx/utils/libcxx/test/dsl.py", "badparts": ["        return libcxx.test.format._parseLitOutput(out)"], "goodparts": ["        return out"]}]}, "/libcxx/utils/libcxx/test/format.py": {"changes": [{"diff": "\n     for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n         assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n \n-def _parseLitOutput(fullOutput):\n-    \"\"\"\n-    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n-\n-    This takes output of the form\n-\n-        $ \":\" \"RUN: at line 11\"\n-        $ \"echo\" \"OUTPUT1\"\n-        # command output:\n-        OUTPUT1\n-\n-        $ \":\" \"RUN: at line 12\"\n-        $ \"echo\" \"OUTPUT2\"\n-        # command output:\n-        OUTPUT2\n-\n-    and returns a string containing\n-\n-        OUTPUT1\n-        OUTPUT2\n-\n-    as-if the commands had been run directly. This is a workaround for the fact\n-    that Lit doesn't let us execute ShTest and retrieve the raw output without\n-    injecting additional Lit output around it.\n-    \"\"\"\n-    parsed = ''\n-    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n-        if output: # skip blank lines\n-            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n-            if commandOutput:\n-                parsed += commandOutput.group(1)\n-    return parsed\n-\n def _executeScriptInternal(test, litConfig, commands):\n     \"\"\"\n     Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n", "add": 0, "remove": 33, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["def _parseLitOutput(fullOutput):", "    \"\"\"", "    Parse output of a Lit ShTest to extract the actual output of the contained commands.", "    This takes output of the form", "        $ \":\" \"RUN: at line 11\"", "        $ \"echo\" \"OUTPUT1\"", "        OUTPUT1", "        $ \":\" \"RUN: at line 12\"", "        $ \"echo\" \"OUTPUT2\"", "        OUTPUT2", "    and returns a string containing", "        OUTPUT1", "        OUTPUT2", "    as-if the commands had been run directly. This is a workaround for the fact", "    that Lit doesn't let us execute ShTest and retrieve the raw output without", "    injecting additional Lit output around it.", "    \"\"\"", "    parsed = ''", "    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):", "        if output: # skip blank lines", "            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)", "            if commandOutput:", "                parsed += commandOutput.group(1)", "    return parsed"], "goodparts": []}, {"diff": "\n     _, tmpBase = _getTempPaths(test)\n     execDir = os.path.dirname(test.getExecPath())\n     res = lit.TestRunner.executeScriptInternal(\n-        test, litConfig, tmpBase, parsedCommands, execDir\n+        test, litConfig, tmpBase, parsedCommands, execDir, debug=False\n     )\n     if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n         res = (\"\", res.output, 127, None)\n     (out, err, exitCode, timeoutInfo) = res\n \n-    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n-    #       split any stderr output that is included in stdout. It shouldn't be there, but\n-    #       the Lit internal shell conflates stderr and stdout.\n-    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n-    if conflatedErrorOutput:\n-        conflatedErrorOutput = conflatedErrorOutput.group(0)\n-        out = out[: -len(conflatedErrorOutput)]\n-        err += conflatedErrorOutput\n-\n     return (out, err, exitCode, timeoutInfo, parsedCommands)\n \n \n", "add": 1, "remove": 10, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["        test, litConfig, tmpBase, parsedCommands, execDir", "    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)", "    if conflatedErrorOutput:", "        conflatedErrorOutput = conflatedErrorOutput.group(0)", "        out = out[: -len(conflatedErrorOutput)]", "        err += conflatedErrorOutput"], "goodparts": ["        test, litConfig, tmpBase, parsedCommands, execDir, debug=False"]}, {"diff": "\n             raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n \n         # Split the generated output into multiple files and generate one test for each file\n-        parsed = _parseLitOutput(out)\n-        for (subfile, content) in self._splitFile(parsed):\n-            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n+        for subfile, content in self._splitFile(out):\n+            generatedFile = testSuite.getExecPath(pathInSuite + (subfile,))\n             os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n             with open(generatedFile, 'w') as f:\n                 f.write(content", "add": 2, "remove": 3, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["        parsed = _parseLitOutput(out)", "        for (subfile, content) in self._splitFile(parsed):", "            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))"], "goodparts": ["        for subfile, content in self._splitFile(out):", "            generatedFile = testSuite.getExecPath(pathInSuite + (subfile,))"]}], "source": "\n import contextlib import io import lit import lit.formats import os import pipes import re import shutil def _getTempPaths(test): \"\"\" Return the values to use for the %T and %t substitutions, respectively. The difference between this and Lit's default behavior is that we guarantee that %T is a path unique to the test being run. \"\"\" tmpDir, _=lit.TestRunner.getTempPaths(test) _, testName=os.path.split(test.getExecPath()) tmpDir=os.path.join(tmpDir, testName +\".dir\") tmpBase=os.path.join(tmpDir, \"t\") return tmpDir, tmpBase def _checkBaseSubstitutions(substitutions): substitutions=[s for(s, _) in substitutions] for s in[\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]: assert s in substitutions, \"Required substitution{} was not provided\".format(s) def _parseLitOutput(fullOutput): \"\"\" Parse output of a Lit ShTest to extract the actual output of the contained commands. This takes output of the form $ \":\" \"RUN: at line 11\" $ \"echo\" \"OUTPUT1\" OUTPUT1 $ \":\" \"RUN: at line 12\" $ \"echo\" \"OUTPUT2\" OUTPUT2 and returns a string containing OUTPUT1 OUTPUT2 as-if the commands had been run directly. This is a workaround for the fact that Lit doesn't let us execute ShTest and retrieve the raw output without injecting additional Lit output around it. \"\"\" parsed='' for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput): if output: commandOutput=re.search(\" if commandOutput: parsed +=commandOutput.group(1) return parsed def _executeScriptInternal(test, litConfig, commands): \"\"\" Returns(stdout, stderr, exitCode, timeoutInfo, parsedCommands) TODO: This really should be easier to access from Lit itself \"\"\" parsedCommands=parseScript(test, preamble=commands) _, tmpBase=_getTempPaths(test) execDir=os.path.dirname(test.getExecPath()) res=lit.TestRunner.executeScriptInternal( test, litConfig, tmpBase, parsedCommands, execDir ) if isinstance(res, lit.Test.Result): res=(\"\", res.output, 127, None) (out, err, exitCode, timeoutInfo)=res conflatedErrorOutput=re.search(\"( if conflatedErrorOutput: conflatedErrorOutput=conflatedErrorOutput.group(0) out=out[: -len(conflatedErrorOutput)] err +=conflatedErrorOutput return(out, err, exitCode, timeoutInfo, parsedCommands) def parseScript(test, preamble): \"\"\" Extract the script from a test, with substitutions applied. Returns a list of commands ready to be executed. -test The lit.Test to parse. -preamble A list of commands to perform before any command in the test. These commands can contain unexpanded substitutions, but they must not be of the form 'RUN:' --they must be proper commands once substituted. \"\"\" tmpDir, tmpBase=_getTempPaths(test) substitutions=lit.TestRunner.getDefaultSubstitutions(test, tmpDir, tmpBase) _checkBaseSubstitutions(substitutions) substitutions.append( (\"%{build}\", \"%{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\") ) substitutions.append((\"%{run}\", \"%{exec} %t.exe\")) additionalCompileFlags=[] fileDependencies=[] parsers=[ lit.TestRunner.IntegratedTestKeywordParser( \"FILE_DEPENDENCIES:\", lit.TestRunner.ParserKind.LIST, initial_value=fileDependencies, ), lit.TestRunner.IntegratedTestKeywordParser( \"ADDITIONAL_COMPILE_FLAGS:\", lit.TestRunner.ParserKind.LIST, initial_value=additionalCompileFlags, ), ] for feature in test.config.available_features: parser=lit.TestRunner.IntegratedTestKeywordParser( \"ADDITIONAL_COMPILE_FLAGS({}):\".format(feature), lit.TestRunner.ParserKind.LIST, initial_value=additionalCompileFlags, ) parsers.append(parser) scriptInTest=lit.TestRunner.parseIntegratedTestScript( test, additional_parsers=parsers, require_script=not preamble ) if isinstance(scriptInTest, lit.Test.Result): return scriptInTest script=[] for dep in fileDependencies: script +=[\"%dbg(SETUP) cd %S && cp{} %T\".format(dep)] script +=preamble script +=scriptInTest substitutions=[ (s, x +\" \" +\" \".join(additionalCompileFlags)) if s==\"%{compile_flags}\" else(s, x) for(s, x) in substitutions ] script=lit.TestRunner.applySubstitutions( script, substitutions, recursion_limit=test.config.recursiveExpansionLimit ) return script class CxxStandardLibraryTest(lit.formats.FileBasedTest): \"\"\" Lit test format for the C++Standard Library conformance test suite. This test format is based on top of the ShTest format --it basically creates a shell script performing the right operations(compile/link/run) based on the extension of the test file it encounters. It supports files with the following extensions: FOO.pass.cpp -Compiles, links and runs successfully FOO.pass.mm -Same as.pass.cpp, but for Objective-C++ FOO.compile.pass.cpp -Compiles successfully, link and run not attempted FOO.compile.pass.mm -Same as.compile.pass.cpp, but for Objective-C++ FOO.compile.fail.cpp -Does not compile successfully FOO.link.pass.cpp -Compiles and links successfully, run not attempted FOO.link.pass.mm -Same as.link.pass.cpp, but for Objective-C++ FOO.link.fail.cpp -Compiles successfully, but fails to link FOO.sh.<anything> -A builtin Lit Shell test FOO.gen.<anything> -A.sh test that generates one or more Lit tests on the fly. Executing this test must generate one or more files as expected by LLVM split-file, and each generated file leads to a separate Lit test that runs that file as defined by the test format. This can be used to generate multiple Lit tests from a single source file, which is useful for testing repetitive properties in the library. Be careful not to abuse this since this is not a replacement for usual code reuse techniques. FOO.verify.cpp -Compiles with clang-verify. This type of test is automatically marked as UNSUPPORTED if the compiler does not support Clang-verify. Substitution requirements =============================== The test format operates by assuming that each test's configuration provides the following substitutions, which it will reuse in the shell scripts it constructs: %{cxx} -A command that can be used to invoke the compiler %{compile_flags} -Flags to use when compiling a test case %{link_flags} -Flags to use when linking a test case %{flags} -Flags to use either when compiling or linking a test case %{exec} -A command to prefix the execution of executables Note that when building an executable(as opposed to only compiling a source file), all three of %{flags}, %{compile_flags} and %{link_flags} will be used in the same command line. In other words, the test format doesn't perform separate compilation and linking steps in this case. Additional supported directives =============================== In addition to everything that's supported in Lit ShTests, this test format also understands the following directives inside test files: // FILE_DEPENDENCIES: file, directory, /path/to/file This directive expresses that the test requires the provided files or directories in order to run. An example is a test that requires some test input stored in a data file. When a test file contains such a directive, this test format will collect them and copy them to the directory represented by %T. The intent is that %T contains all the inputs necessary to run the test, such that e.g. execution on a remote host can be done by simply copying %T to the host. // ADDITIONAL_COMPILE_FLAGS: flag1, flag2, flag3 This directive will cause the provided flags to be added to the %{compile_flags} substitution for the test that contains it. This allows adding special compilation flags without having to use a .sh.cpp test, which would be more powerful but perhaps overkill. Additional provided substitutions and features ============================================== The test format will define the following substitutions for use inside tests: %{build} Expands to a command-line that builds the current source file with the %{flags}, %{compile_flags} and %{link_flags} substitutions, and that produces an executable named %t.exe. %{run} Equivalent to `%{exec} %t.exe`. This is intended to be used in conjunction with the %{build} substitution. \"\"\" def getTestsForPath(self, testSuite, pathInSuite, litConfig, localConfig): SUPPORTED_SUFFIXES=[ \"[.]pass[.]cpp$\", \"[.]pass[.]mm$\", \"[.]compile[.]pass[.]cpp$\", \"[.]compile[.]pass[.]mm$\", \"[.]compile[.]fail[.]cpp$\", \"[.]link[.]pass[.]cpp$\", \"[.]link[.]pass[.]mm$\", \"[.]link[.]fail[.]cpp$\", \"[.]sh[.][^.]+$\", \"[.]gen[.][^.]+$\", \"[.]verify[.]cpp$\", \"[.]fail[.]cpp$\", ] sourcePath=testSuite.getSourcePath(pathInSuite) filename=os.path.basename(sourcePath) hasSupportedSuffix=lambda f: any([re.search(ext, f) for ext in SUPPORTED_SUFFIXES]) if filename.startswith(\".\") or filename in localConfig.excludes or not hasSupportedSuffix(filename): return if re.search('[.]gen[.][^.]+$', filename): for test in self._generateGenTest(testSuite, pathInSuite, litConfig, localConfig): yield test else: yield lit.Test.Test(testSuite, pathInSuite, localConfig) def execute(self, test, litConfig): VERIFY_FLAGS=( \"-Xclang -verify -Xclang -verify-ignore-unexpected=note -ferror-limit=0\" ) supportsVerify=\"verify-support\" in test.config.available_features filename=test.path_in_suite[-1] if re.search(\"[.]sh[.][^.]+$\", filename): steps=[] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".compile.pass.cpp\") or filename.endswith( \".compile.pass.mm\" ): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".compile.fail.cpp\"): steps=[ \"%dbg(COMPILED WITH) ! %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".link.pass.cpp\") or filename.endswith(\".link.pass.mm\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".link.fail.cpp\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -c -o %t.o\", \"%dbg(LINKED WITH) ! %{cxx} %t.o %{flags} %{link_flags} -o %t.exe\", ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".verify.cpp\"): if not supportsVerify: return lit.Test.Result( lit.Test.UNSUPPORTED, \"Test{} requires support for Clang-verify, which isn't supported by the compiler\".format( test.getFullName() ), ) steps=[ \"%dbg(COMPILED WITH) %{{cxx}} %s %{{flags}} %{{compile_flags}} -fsyntax-only -Wno-error{}\".format( VERIFY_FLAGS ) ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".pass.cpp\") or filename.endswith(\".pass.mm\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\", \"%dbg(EXECUTED AS) %{exec} %t.exe\", ] return self._executeShTest(test, litConfig, steps) else: return lit.Test.Result( lit.Test.UNRESOLVED, \"Unknown test suffix for '{}'\".format(filename) ) def _executeShTest(self, test, litConfig, steps): if test.config.unsupported: return lit.Test.Result(lit.Test.UNSUPPORTED, \"Test is unsupported\") script=parseScript(test, steps) if isinstance(script, lit.Test.Result): return script if litConfig.noExecute: return lit.Test.Result( lit.Test.XFAIL if test.isExpectedToFail() else lit.Test.PASS ) else: _, tmpBase=_getTempPaths(test) useExternalSh=False return lit.TestRunner._runShTest( test, litConfig, useExternalSh, script, tmpBase ) def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig): generator=lit.Test.Test(testSuite, pathInSuite, localConfig) generatorExecDir=os.path.dirname(testSuite.getExecPath(pathInSuite)) os.makedirs(generatorExecDir, exist_ok=True) steps=[] (out, err, exitCode, _, _)=_executeScriptInternal(generator, litConfig, steps) if exitCode !=0: raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\") parsed=_parseLitOutput(out) for(subfile, content) in self._splitFile(parsed): generatedFile=testSuite.getExecPath(pathInSuite +(subfile,)) os.makedirs(os.path.dirname(generatedFile), exist_ok=True) with open(generatedFile, 'w') as f: f.write(content) yield lit.Test.Test(testSuite,(generatedFile,), localConfig) def _splitFile(self, input): DELIM=r'^(//| lines=input.splitlines() currentFile=None thisFileContent=[] for line in lines: match=re.match(DELIM, line) if match: if currentFile is not None: yield(currentFile, '\\n'.join(thisFileContent)) currentFile=match.group(2).strip() thisFileContent=[] assert currentFile is not None, f\"Some input to split-file doesn't belong to any file, input was:\\n{input}\" thisFileContent.append(line) if currentFile is not None: yield(currentFile, '\\n'.join(thisFileContent)) ", "sourceWithComments": "# ===----------------------------------------------------------------------===##\n#\n# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n# See https://llvm.org/LICENSE.txt for license information.\n# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n#\n# ===----------------------------------------------------------------------===##\n\nimport contextlib\nimport io\nimport lit\nimport lit.formats\nimport os\nimport pipes\nimport re\nimport shutil\n\n\ndef _getTempPaths(test):\n    \"\"\"\n    Return the values to use for the %T and %t substitutions, respectively.\n\n    The difference between this and Lit's default behavior is that we guarantee\n    that %T is a path unique to the test being run.\n    \"\"\"\n    tmpDir, _ = lit.TestRunner.getTempPaths(test)\n    _, testName = os.path.split(test.getExecPath())\n    tmpDir = os.path.join(tmpDir, testName + \".dir\")\n    tmpBase = os.path.join(tmpDir, \"t\")\n    return tmpDir, tmpBase\n\n\ndef _checkBaseSubstitutions(substitutions):\n    substitutions = [s for (s, _) in substitutions]\n    for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n        assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n\ndef _parseLitOutput(fullOutput):\n    \"\"\"\n    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n\n    This takes output of the form\n\n        $ \":\" \"RUN: at line 11\"\n        $ \"echo\" \"OUTPUT1\"\n        # command output:\n        OUTPUT1\n\n        $ \":\" \"RUN: at line 12\"\n        $ \"echo\" \"OUTPUT2\"\n        # command output:\n        OUTPUT2\n\n    and returns a string containing\n\n        OUTPUT1\n        OUTPUT2\n\n    as-if the commands had been run directly. This is a workaround for the fact\n    that Lit doesn't let us execute ShTest and retrieve the raw output without\n    injecting additional Lit output around it.\n    \"\"\"\n    parsed = ''\n    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n        if output: # skip blank lines\n            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n            if commandOutput:\n                parsed += commandOutput.group(1)\n    return parsed\n\ndef _executeScriptInternal(test, litConfig, commands):\n    \"\"\"\n    Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n\n    TODO: This really should be easier to access from Lit itself\n    \"\"\"\n    parsedCommands = parseScript(test, preamble=commands)\n\n    _, tmpBase = _getTempPaths(test)\n    execDir = os.path.dirname(test.getExecPath())\n    res = lit.TestRunner.executeScriptInternal(\n        test, litConfig, tmpBase, parsedCommands, execDir\n    )\n    if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n        res = (\"\", res.output, 127, None)\n    (out, err, exitCode, timeoutInfo) = res\n\n    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n    #       split any stderr output that is included in stdout. It shouldn't be there, but\n    #       the Lit internal shell conflates stderr and stdout.\n    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n    if conflatedErrorOutput:\n        conflatedErrorOutput = conflatedErrorOutput.group(0)\n        out = out[: -len(conflatedErrorOutput)]\n        err += conflatedErrorOutput\n\n    return (out, err, exitCode, timeoutInfo, parsedCommands)\n\n\ndef parseScript(test, preamble):\n    \"\"\"\n    Extract the script from a test, with substitutions applied.\n\n    Returns a list of commands ready to be executed.\n\n    - test\n        The lit.Test to parse.\n\n    - preamble\n        A list of commands to perform before any command in the test.\n        These commands can contain unexpanded substitutions, but they\n        must not be of the form 'RUN:' -- they must be proper commands\n        once substituted.\n    \"\"\"\n    # Get the default substitutions\n    tmpDir, tmpBase = _getTempPaths(test)\n    substitutions = lit.TestRunner.getDefaultSubstitutions(test, tmpDir, tmpBase)\n\n    # Check base substitutions and add the %{build} and %{run} convenience substitutions\n    _checkBaseSubstitutions(substitutions)\n    substitutions.append(\n        (\"%{build}\", \"%{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\")\n    )\n    substitutions.append((\"%{run}\", \"%{exec} %t.exe\"))\n\n    # Parse the test file, including custom directives\n    additionalCompileFlags = []\n    fileDependencies = []\n    parsers = [\n        lit.TestRunner.IntegratedTestKeywordParser(\n            \"FILE_DEPENDENCIES:\",\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=fileDependencies,\n        ),\n        lit.TestRunner.IntegratedTestKeywordParser(\n            \"ADDITIONAL_COMPILE_FLAGS:\",\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=additionalCompileFlags,\n        ),\n    ]\n\n    # Add conditional parsers for ADDITIONAL_COMPILE_FLAGS. This should be replaced by first\n    # class support for conditional keywords in Lit, which would allow evaluating arbitrary\n    # Lit boolean expressions instead.\n    for feature in test.config.available_features:\n        parser = lit.TestRunner.IntegratedTestKeywordParser(\n            \"ADDITIONAL_COMPILE_FLAGS({}):\".format(feature),\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=additionalCompileFlags,\n        )\n        parsers.append(parser)\n\n    scriptInTest = lit.TestRunner.parseIntegratedTestScript(\n        test, additional_parsers=parsers, require_script=not preamble\n    )\n    if isinstance(scriptInTest, lit.Test.Result):\n        return scriptInTest\n\n    script = []\n\n    # For each file dependency in FILE_DEPENDENCIES, inject a command to copy\n    # that file to the execution directory. Execute the copy from %S to allow\n    # relative paths from the test directory.\n    for dep in fileDependencies:\n        script += [\"%dbg(SETUP) cd %S && cp {} %T\".format(dep)]\n    script += preamble\n    script += scriptInTest\n\n    # Add compile flags specified with ADDITIONAL_COMPILE_FLAGS.\n    substitutions = [\n        (s, x + \" \" + \" \".join(additionalCompileFlags))\n        if s == \"%{compile_flags}\"\n        else (s, x)\n        for (s, x) in substitutions\n    ]\n\n    # Perform substitutions in the script itself.\n    script = lit.TestRunner.applySubstitutions(\n        script, substitutions, recursion_limit=test.config.recursiveExpansionLimit\n    )\n\n    return script\n\n\nclass CxxStandardLibraryTest(lit.formats.FileBasedTest):\n    \"\"\"\n    Lit test format for the C++ Standard Library conformance test suite.\n\n    This test format is based on top of the ShTest format -- it basically\n    creates a shell script performing the right operations (compile/link/run)\n    based on the extension of the test file it encounters. It supports files\n    with the following extensions:\n\n    FOO.pass.cpp            - Compiles, links and runs successfully\n    FOO.pass.mm             - Same as .pass.cpp, but for Objective-C++\n\n    FOO.compile.pass.cpp    - Compiles successfully, link and run not attempted\n    FOO.compile.pass.mm     - Same as .compile.pass.cpp, but for Objective-C++\n    FOO.compile.fail.cpp    - Does not compile successfully\n\n    FOO.link.pass.cpp       - Compiles and links successfully, run not attempted\n    FOO.link.pass.mm        - Same as .link.pass.cpp, but for Objective-C++\n    FOO.link.fail.cpp       - Compiles successfully, but fails to link\n\n    FOO.sh.<anything>       - A builtin Lit Shell test\n\n    FOO.gen.<anything>      - A .sh test that generates one or more Lit tests on the\n                              fly. Executing this test must generate one or more files\n                              as expected by LLVM split-file, and each generated file\n                              leads to a separate Lit test that runs that file as\n                              defined by the test format. This can be used to generate\n                              multiple Lit tests from a single source file, which is\n                              useful for testing repetitive properties in the library.\n                              Be careful not to abuse this since this is not a replacement\n                              for usual code reuse techniques.\n\n    FOO.verify.cpp          - Compiles with clang-verify. This type of test is\n                              automatically marked as UNSUPPORTED if the compiler\n                              does not support Clang-verify.\n\n\n    Substitution requirements\n    ===============================\n    The test format operates by assuming that each test's configuration provides\n    the following substitutions, which it will reuse in the shell scripts it\n    constructs:\n        %{cxx}           - A command that can be used to invoke the compiler\n        %{compile_flags} - Flags to use when compiling a test case\n        %{link_flags}    - Flags to use when linking a test case\n        %{flags}         - Flags to use either when compiling or linking a test case\n        %{exec}          - A command to prefix the execution of executables\n\n    Note that when building an executable (as opposed to only compiling a source\n    file), all three of %{flags}, %{compile_flags} and %{link_flags} will be used\n    in the same command line. In other words, the test format doesn't perform\n    separate compilation and linking steps in this case.\n\n\n    Additional supported directives\n    ===============================\n    In addition to everything that's supported in Lit ShTests, this test format\n    also understands the following directives inside test files:\n\n        // FILE_DEPENDENCIES: file, directory, /path/to/file\n\n            This directive expresses that the test requires the provided files\n            or directories in order to run. An example is a test that requires\n            some test input stored in a data file. When a test file contains\n            such a directive, this test format will collect them and copy them\n            to the directory represented by %T. The intent is that %T contains\n            all the inputs necessary to run the test, such that e.g. execution\n            on a remote host can be done by simply copying %T to the host.\n\n        // ADDITIONAL_COMPILE_FLAGS: flag1, flag2, flag3\n\n            This directive will cause the provided flags to be added to the\n            %{compile_flags} substitution for the test that contains it. This\n            allows adding special compilation flags without having to use a\n            .sh.cpp test, which would be more powerful but perhaps overkill.\n\n\n    Additional provided substitutions and features\n    ==============================================\n    The test format will define the following substitutions for use inside tests:\n\n        %{build}\n            Expands to a command-line that builds the current source\n            file with the %{flags}, %{compile_flags} and %{link_flags}\n            substitutions, and that produces an executable named %t.exe.\n\n        %{run}\n            Equivalent to `%{exec} %t.exe`. This is intended to be used\n            in conjunction with the %{build} substitution.\n    \"\"\"\n\n    def getTestsForPath(self, testSuite, pathInSuite, litConfig, localConfig):\n        SUPPORTED_SUFFIXES = [\n            \"[.]pass[.]cpp$\",\n            \"[.]pass[.]mm$\",\n            \"[.]compile[.]pass[.]cpp$\",\n            \"[.]compile[.]pass[.]mm$\",\n            \"[.]compile[.]fail[.]cpp$\",\n            \"[.]link[.]pass[.]cpp$\",\n            \"[.]link[.]pass[.]mm$\",\n            \"[.]link[.]fail[.]cpp$\",\n            \"[.]sh[.][^.]+$\",\n            \"[.]gen[.][^.]+$\",\n            \"[.]verify[.]cpp$\",\n            \"[.]fail[.]cpp$\",\n        ]\n\n        sourcePath = testSuite.getSourcePath(pathInSuite)\n        filename = os.path.basename(sourcePath)\n\n        # Ignore dot files, excluded tests and tests with an unsupported suffix\n        hasSupportedSuffix = lambda f: any([re.search(ext, f) for ext in SUPPORTED_SUFFIXES])\n        if filename.startswith(\".\") or filename in localConfig.excludes or not hasSupportedSuffix(filename):\n            return\n\n        # If this is a generated test, run the generation step and add\n        # as many Lit tests as necessary.\n        if re.search('[.]gen[.][^.]+$', filename):\n            for test in self._generateGenTest(testSuite, pathInSuite, litConfig, localConfig):\n                yield test\n        else:\n            yield lit.Test.Test(testSuite, pathInSuite, localConfig)\n\n    def execute(self, test, litConfig):\n        VERIFY_FLAGS = (\n            \"-Xclang -verify -Xclang -verify-ignore-unexpected=note -ferror-limit=0\"\n        )\n        supportsVerify = \"verify-support\" in test.config.available_features\n        filename = test.path_in_suite[-1]\n\n        if re.search(\"[.]sh[.][^.]+$\", filename):\n            steps = []  # The steps are already in the script\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".compile.pass.cpp\") or filename.endswith(\n            \".compile.pass.mm\"\n        ):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".compile.fail.cpp\"):\n            steps = [\n                \"%dbg(COMPILED WITH) ! %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".link.pass.cpp\") or filename.endswith(\".link.pass.mm\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".link.fail.cpp\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -c -o %t.o\",\n                \"%dbg(LINKED WITH) ! %{cxx} %t.o %{flags} %{link_flags} -o %t.exe\",\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".verify.cpp\"):\n            if not supportsVerify:\n                return lit.Test.Result(\n                    lit.Test.UNSUPPORTED,\n                    \"Test {} requires support for Clang-verify, which isn't supported by the compiler\".format(\n                        test.getFullName()\n                    ),\n                )\n            steps = [\n                # Note: Use -Wno-error to make sure all diagnostics are not treated as errors,\n                #       which doesn't make sense for clang-verify tests.\n                \"%dbg(COMPILED WITH) %{{cxx}} %s %{{flags}} %{{compile_flags}} -fsyntax-only -Wno-error {}\".format(\n                    VERIFY_FLAGS\n                )\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        # Make sure to check these ones last, since they will match other\n        # suffixes above too.\n        elif filename.endswith(\".pass.cpp\") or filename.endswith(\".pass.mm\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\",\n                \"%dbg(EXECUTED AS) %{exec} %t.exe\",\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        else:\n            return lit.Test.Result(\n                lit.Test.UNRESOLVED, \"Unknown test suffix for '{}'\".format(filename)\n            )\n\n    def _executeShTest(self, test, litConfig, steps):\n        if test.config.unsupported:\n            return lit.Test.Result(lit.Test.UNSUPPORTED, \"Test is unsupported\")\n\n        script = parseScript(test, steps)\n        if isinstance(script, lit.Test.Result):\n            return script\n\n        if litConfig.noExecute:\n            return lit.Test.Result(\n                lit.Test.XFAIL if test.isExpectedToFail() else lit.Test.PASS\n            )\n        else:\n            _, tmpBase = _getTempPaths(test)\n            useExternalSh = False\n            return lit.TestRunner._runShTest(\n                test, litConfig, useExternalSh, script, tmpBase\n            )\n\n    def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig):\n        generator = lit.Test.Test(testSuite, pathInSuite, localConfig)\n\n        # Make sure we have a directory to execute the generator test in\n        generatorExecDir = os.path.dirname(testSuite.getExecPath(pathInSuite))\n        os.makedirs(generatorExecDir, exist_ok=True)\n\n        # Run the generator test\n        steps = [] # Steps must already be in the script\n        (out, err, exitCode, _, _) = _executeScriptInternal(generator, litConfig, steps)\n        if exitCode != 0:\n            raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n\n        # Split the generated output into multiple files and generate one test for each file\n        parsed = _parseLitOutput(out)\n        for (subfile, content) in self._splitFile(parsed):\n            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n            os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n            with open(generatedFile, 'w') as f:\n                f.write(content)\n            yield lit.Test.Test(testSuite, (generatedFile,), localConfig)\n\n    def _splitFile(self, input):\n        DELIM = r'^(//|#)---(.+)'\n        lines = input.splitlines()\n        currentFile = None\n        thisFileContent = []\n        for line in lines:\n            match = re.match(DELIM, line)\n            if match:\n                if currentFile is not None:\n                    yield (currentFile, '\\n'.join(thisFileContent))\n                currentFile = match.group(2).strip()\n                thisFileContent = []\n            assert currentFile is not None, f\"Some input to split-file doesn't belong to any file, input was:\\n{input}\"\n            thisFileContent.append(line)\n        if currentFile is not None:\n            yield (currentFile, '\\n'.join(thisFileContent))\n"}}, "msg": "[lit] Improve test output from lit's internal shell\n\nThis patch and D154984 were discussed in\n<https://discourse.llvm.org/t/rfc-improving-lits-debug-output/72839>.\n\nMotivation\n----------\n\nD154984 removes the \"Script:\" section that lit prints along with a\ntest's output, and it makes -v and -a imply -vv.  For example, after\nD154984, the \"Script:\" section below is never shown, but -v is enough\nto produce the execution trace following it:\n\n```\n Script:\n --\n : 'RUN: at line 1'; echo hello | FileCheck bogus.txt && echo success\n --\n Exit Code: 2\n\n Command Output (stdout):\n --\n $ \":\" \"RUN: at line 1\"\n $ \"echo\" \"hello\"\n # command output:\n hello\n\n $ \"FileCheck\" \"bogus.txt\"\n # command stderr:\n Could not open check file 'bogus.txt': No such file or directory\n\n error: command failed with exit status: 2\n\n --\n```\n\nIn the D154984 review, some reviewers point out that they have been\nusing the \"Script:\" section for copying and pasting a test's shell\ncommands to a terminal window.  The shell commands as printed in the\nexecution trace can be harder to copy and paste for the following\nreasons:\n\n- They drop redirections and break apart RUN lines at `&&`, `|`, etc.\n- They add `$` at the start of every command, which makes it hard to\n  copy and paste multiple commands in bulk.\n- Command stdout, stderr, etc. are interleaved with the commands and\n  are not clearly delineated.\n- They don't always use proper shell quoting.  Instead, they blindly\n  enclose all command-line arguments in double quotes.\n\nChanges\n-------\n\nD154984 plus this patch converts the above example into:\n\n```\n Exit Code: 2\n\n Command Output (stdout):\n --\n # RUN: at line 1\n echo hello | FileCheck bogus-file.txt && echo success\n # executed command: echo hello\n # .---command stdout------------\n # | hello\n # `-----------------------------\n # executed command: FileCheck bogus-file.txt\n # .---command stderr------------\n # | Could not open check file 'bogus-file.txt': No such file or directory\n # `-----------------------------\n # error: command failed with exit status: 2\n\n --\n```\n\nThus, this patch addresses the above issues as follows:\n\n- The entire execution trace can be copied and pasted in bulk to a\n  terminal for correct execution of the RUN lines, which are printed\n  intact as they appeared in the original RUN lines except lit\n  substitutions are expanded.  Everything else in the execution trace\n  appears in shell comments so it has no effect in a terminal.\n- Each of the RUN line's commands is repeated (in shell comments) as\n  it executes to show (1) that the command actually executed (e.g.,\n  `echo success` above didn't) and (2) what stdout, stderr, non-zero\n  exit status, and output files are associated with the command, if\n  any.  Shell quoting in the command is now correct and minimal but is\n  not necessarily the original shell quoting from the RUN line.\n- The start and end of the contents of stdout, stderr, or an output\n  file is now delineated clearly in the trace.\n\nTo help produce some of the above output, this patch extends lit's\ninternal shell with a built-in `@echo` command.  It's like `echo`\nexcept lit suppresses the normal execution trace for `@echo` and just\nprints its stdout directly.  For now, `@echo` isn't documented for use\nin lit tests.\n\nWithout this patch, libcxx's custom lit test format tries to parse the\nstdout from `lit.TestRunner.executeScriptInternal` (which runs lit's\ninternal shell) to extract the stdout and stderr produced by shell\ncommands, and that parse no longer works after the above changes.\nThis patch makes a small adjustment to\n`lit.TestRunner.executeScriptInternal` so libcxx can just request\nstdout and stderr without an execution trace.\n\n(As a minor drive-by fix that came up in testing: lit's internal `not`\ncommand now always produces a numeric exit status and never `True`.)\n\nCaveat\n------\n\nThis patch only makes the above changes for lit's internal shell.  In\nmost cases, we do not know how to force external shells (e.g., bash,\nsh, window's `cmd`) to produce execution traces in the manner we want.\n\nTo configure a test suite to use lit's internal shell (which is\nusually better for test portability than external shells anyway), add\nthis to the test suite's `lit.cfg` or other configuration file:\n\n```\nconfig.test_format = lit.formats.ShTest(execute_external=False)\n```\n\nReviewed By: MaskRay, awarzynski\n\nDifferential Revision: https://reviews.llvm.org/D156954"}}, "https://github.com/millaker/MiGPU-llvm-project": {"c981c533055e14302e7bff5d6898c9308065f665": {"url": "https://api.github.com/repos/millaker/MiGPU-llvm-project/commits/c981c533055e14302e7bff5d6898c9308065f665", "html_url": "https://github.com/millaker/MiGPU-llvm-project/commit/c981c533055e14302e7bff5d6898c9308065f665", "sha": "c981c533055e14302e7bff5d6898c9308065f665", "keyword": "execution after redirect correct", "diff": "diff --git a/libcxx/utils/libcxx/test/dsl.py b/libcxx/utils/libcxx/test/dsl.py\nindex 847cebf5962f..4c2217ec3142 100644\n--- a/libcxx/utils/libcxx/test/dsl.py\n+++ b/libcxx/utils/libcxx/test/dsl.py\n@@ -180,7 +180,7 @@ def programOutput(config, program, args=None):\n                 \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n             )\n \n-        return libcxx.test.format._parseLitOutput(out)\n+        return out\n \n \n @_memoizeExpensiveOperation(\ndiff --git a/libcxx/utils/libcxx/test/format.py b/libcxx/utils/libcxx/test/format.py\nindex ddd88f25646e..2be42d293280 100644\n--- a/libcxx/utils/libcxx/test/format.py\n+++ b/libcxx/utils/libcxx/test/format.py\n@@ -35,39 +35,6 @@ def _checkBaseSubstitutions(substitutions):\n     for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n         assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n \n-def _parseLitOutput(fullOutput):\n-    \"\"\"\n-    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n-\n-    This takes output of the form\n-\n-        $ \":\" \"RUN: at line 11\"\n-        $ \"echo\" \"OUTPUT1\"\n-        # command output:\n-        OUTPUT1\n-\n-        $ \":\" \"RUN: at line 12\"\n-        $ \"echo\" \"OUTPUT2\"\n-        # command output:\n-        OUTPUT2\n-\n-    and returns a string containing\n-\n-        OUTPUT1\n-        OUTPUT2\n-\n-    as-if the commands had been run directly. This is a workaround for the fact\n-    that Lit doesn't let us execute ShTest and retrieve the raw output without\n-    injecting additional Lit output around it.\n-    \"\"\"\n-    parsed = ''\n-    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n-        if output: # skip blank lines\n-            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n-            if commandOutput:\n-                parsed += commandOutput.group(1)\n-    return parsed\n-\n def _executeScriptInternal(test, litConfig, commands):\n     \"\"\"\n     Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n@@ -79,21 +46,12 @@ def _executeScriptInternal(test, litConfig, commands):\n     _, tmpBase = _getTempPaths(test)\n     execDir = os.path.dirname(test.getExecPath())\n     res = lit.TestRunner.executeScriptInternal(\n-        test, litConfig, tmpBase, parsedCommands, execDir\n+        test, litConfig, tmpBase, parsedCommands, execDir, debug=False\n     )\n     if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n         res = (\"\", res.output, 127, None)\n     (out, err, exitCode, timeoutInfo) = res\n \n-    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n-    #       split any stderr output that is included in stdout. It shouldn't be there, but\n-    #       the Lit internal shell conflates stderr and stdout.\n-    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n-    if conflatedErrorOutput:\n-        conflatedErrorOutput = conflatedErrorOutput.group(0)\n-        out = out[: -len(conflatedErrorOutput)]\n-        err += conflatedErrorOutput\n-\n     return (out, err, exitCode, timeoutInfo, parsedCommands)\n \n \n@@ -400,8 +358,7 @@ def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig):\n             raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n \n         # Split the generated output into multiple files and generate one test for each file\n-        parsed = _parseLitOutput(out)\n-        for (subfile, content) in self._splitFile(parsed):\n+        for (subfile, content) in self._splitFile(out):\n             generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n             os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n             with open(generatedFile, 'w') as f:\ndiff --git a/llvm/utils/lit/lit/TestRunner.py b/llvm/utils/lit/lit/TestRunner.py\nindex 0629eca42049..461cf63d6b96 100644\n--- a/llvm/utils/lit/lit/TestRunner.py\n+++ b/llvm/utils/lit/lit/TestRunner.py\n@@ -8,6 +8,7 @@\n import stat\n import pathlib\n import platform\n+import shlex\n import shutil\n import tempfile\n import threading\n@@ -57,6 +58,14 @@ def __init__(self, command, message):\n kPdbgRegex = \"%dbg\\\\(([^)'\\\"]*)\\\\)(.*)\"\n \n \n+def buildPdbgCommand(msg, cmd):\n+    res = f\"%dbg({msg}) {cmd}\"\n+    assert re.match(\n+        kPdbgRegex, res\n+    ), f\"kPdbgRegex expected to match actual %dbg usage: {res}\"\n+    return res\n+\n+\n class ShellEnvironment(object):\n \n     \"\"\"Mutable shell environment containing things like CWD and env vars.\n@@ -340,12 +349,12 @@ def executeBuiltinExport(cmd, shenv):\n \n \n def executeBuiltinEcho(cmd, shenv):\n-    \"\"\"Interpret a redirected echo command\"\"\"\n+    \"\"\"Interpret a redirected echo or @echo command\"\"\"\n     opened_files = []\n     stdin, stdout, stderr = processRedirects(cmd, subprocess.PIPE, shenv, opened_files)\n     if stdin != subprocess.PIPE or stderr != subprocess.PIPE:\n         raise InternalShellError(\n-            cmd, \"stdin and stderr redirects not supported for echo\"\n+            cmd, f\"stdin and stderr redirects not supported for {cmd.args[0]}\"\n         )\n \n     # Some tests have un-redirected echo commands to help debug test failures.\n@@ -692,6 +701,7 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n         \"cd\": executeBuiltinCd,\n         \"export\": executeBuiltinExport,\n         \"echo\": executeBuiltinEcho,\n+        \"@echo\": executeBuiltinEcho,\n         \"mkdir\": executeBuiltinMkdir,\n         \"popd\": executeBuiltinPopd,\n         \"pushd\": executeBuiltinPushd,\n@@ -919,7 +929,7 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n         if res == -signal.SIGINT:\n             raise KeyboardInterrupt\n         if proc_not_counts[i] % 2:\n-            res = not res\n+            res = 1 if res == 0 else 0\n         elif proc_not_counts[i] > 1:\n             res = 1 if res != 0 else 0\n \n@@ -982,19 +992,58 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n     return exitCode\n \n \n-def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n+def formatOutput(title, data, limit=None):\n+    if not data.strip():\n+        return \"\"\n+    if not limit is None and len(data) > limit:\n+        data = data[:limit] + \"\\n...\\n\"\n+        msg = \"data was truncated\"\n+    else:\n+        msg = \"\"\n+    ndashes = 30\n+    out =  f\"# .---{title}{'-' * (ndashes - 4 - len(title))}\\n\"\n+    out += f\"# | \" + \"\\n# | \".join(data.splitlines()) + \"\\n\"\n+    out += f\"# `---{msg}{'-' * (ndashes - 4 - len(msg))}\\n\"\n+    return out\n+\n+# Normally returns out, err, exitCode, timeoutInfo.\n+#\n+# If debug is True (the normal lit behavior), err is empty, and out contains an\n+# execution trace, including stdout and stderr shown per command executed.\n+#\n+# If debug is False (set by some custom lit test formats that call this\n+# function), out contains only stdout from the script, err contains only stderr\n+# from the script, and there is no execution trace.\n+def executeScriptInternal(test, litConfig, tmpBase, commands, cwd,\n+                          debug=True):\n     cmds = []\n     for i, ln in enumerate(commands):\n+        # Within lit, we try to always add '%dbg(...)' to command lines in order\n+        # to maximize debuggability.  However, custom lit test formats might not\n+        # always add it, so add a generic debug message in that case.\n         match = re.match(kPdbgRegex, ln)\n         if match:\n+            dbg = match.group(1)\n             command = match.group(2)\n-            ln = commands[i] = match.expand(\": '\\\\1'; \\\\2\" if command else \": '\\\\1'\")\n+        else:\n+            dbg = \"command line\"\n+            command = ln\n+        if debug:\n+            ln = f\"@echo '# {dbg}' \"\n+            if command:\n+                ln += f\"&& @echo {shlex.quote(command.lstrip())} && {command}\"\n+            else:\n+                ln += \"has no command after substitutions\"\n+        else:\n+            ln = command\n         try:\n             cmds.append(\n                 ShUtil.ShParser(ln, litConfig.isWindows, test.config.pipefail).parse()\n             )\n         except:\n-            return lit.Test.Result(Test.FAIL, \"shell parser error on: %r\" % ln)\n+            return lit.Test.Result(\n+                Test.FAIL, f\"shell parser error on {dbg}: {command.lstrip()}\\n\"\n+            )\n \n     cmd = cmds[0]\n     for c in cmds[1:]:\n@@ -1014,8 +1063,42 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n \n     out = err = \"\"\n     for i, result in enumerate(results):\n-        # Write the command line run.\n-        out += \"$ %s\\n\" % (\" \".join('\"%s\"' % s for s in result.command.args),)\n+        if not debug:\n+            out += result.stdout\n+            err += result.stderr\n+            continue\n+\n+        # The purpose of an \"@echo\" command is merely to add a debugging message\n+        # directly to lit's output.  It is used internally by lit's internal\n+        # shell and is not currently documented for use in lit tests.  However,\n+        # if someone misuses it (e.g., both \"echo\" and \"@echo\" complain about\n+        # stdin redirection), produce the normal execution trace to facilitate\n+        # debugging.\n+        if (\n+            result.command.args[0] == \"@echo\"\n+            and result.exitCode == 0\n+            and not result.stderr\n+            and not result.outputFiles\n+            and not result.timeoutReached\n+        ):\n+            out += result.stdout\n+            continue\n+\n+        # Write the command line that was run.  Properly quote it.  Leading\n+        # \"!\" commands should not be quoted as that would indicate they are not\n+        # the builtins.\n+        out += \"# executed command: \"\n+        nLeadingBangs = next(\n+            (i for i, cmd in enumerate(result.command.args) if cmd != \"!\"),\n+            len(result.command.args),\n+        )\n+        out += \"! \" * nLeadingBangs\n+        out += \" \".join(\n+            shlex.quote(str(s))\n+            for i, s in enumerate(result.command.args)\n+            if i >= nLeadingBangs\n+        )\n+        out += \"\\n\"\n \n         # If nothing interesting happened, move on.\n         if (\n@@ -1030,22 +1113,16 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n \n         # Add the command output, if redirected.\n         for (name, path, data) in result.outputFiles:\n-            if data.strip():\n-                out += \"# redirected output from %r:\\n\" % (name,)\n-                data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n-                if len(data) > 1024:\n-                    out += data[:1024] + \"\\n...\\n\"\n-                    out += \"note: data was truncated\\n\"\n-                else:\n-                    out += data\n-                out += \"\\n\"\n-\n+            data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n+            out += formatOutput(\n+                f\"redirected output from '{name}'\", data, limit=1024\n+            )\n         if result.stdout.strip():\n-            out += \"# command output:\\n%s\\n\" % (result.stdout,)\n+            out += formatOutput(\"command stdout\", result.stdout)\n         if result.stderr.strip():\n-            out += \"# command stderr:\\n%s\\n\" % (result.stderr,)\n+            out += formatOutput(\"command stderr\", result.stderr)\n         if not result.stdout.strip() and not result.stderr.strip():\n-            out += \"note: command had no output on stdout or stderr\\n\"\n+            out += \"# note: command had no output on stdout or stderr\\n\"\n \n         # Show the error conditions:\n         if result.exitCode != 0:\n@@ -1055,9 +1132,9 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n                 codeStr = hex(int(result.exitCode & 0xFFFFFFFF)).rstrip(\"L\")\n             else:\n                 codeStr = str(result.exitCode)\n-            out += \"error: command failed with exit status: %s\\n\" % (codeStr,)\n+            out += \"# error: command failed with exit status: %s\\n\" % (codeStr,)\n         if litConfig.maxIndividualTestTime > 0 and result.timeoutReached:\n-            out += \"error: command reached timeout: %s\\n\" % (\n+            out += \"# error: command reached timeout: %s\\n\" % (\n                 str(result.timeoutReached),\n             )\n \n@@ -1833,13 +1910,7 @@ def _handleCommand(cls, line_number, line, output, keyword):\n         if not output or not output[-1].add_continuation(line_number, keyword, line):\n             if output is None:\n                 output = []\n-            pdbg = \"%dbg({keyword} at line {line_number})\".format(\n-                keyword=keyword, line_number=line_number\n-            )\n-            assert re.match(\n-                kPdbgRegex + \"$\", pdbg\n-            ), \"kPdbgRegex expected to match actual %dbg usage\"\n-            line = \"{pdbg} {real_command}\".format(pdbg=pdbg, real_command=line)\n+            line = buildPdbgCommand(f\"{keyword} at line {line_number}\", line)\n             output.append(CommandDirective(line_number, line_number, keyword, line))\n         return output\n \n@@ -2104,6 +2175,8 @@ def executeShTest(\n         return lit.Test.Result(Test.UNSUPPORTED, \"Test is unsupported\")\n \n     script = list(preamble_commands)\n+    script = [buildPdbgCommand(f\"preamble command line\", ln) for ln in script]\n+\n     parsed = parseIntegratedTestScript(test, require_script=not script)\n     if isinstance(parsed, lit.Test.Result):\n         return parsed\ndiff --git a/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg b/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\nindex cf1a4f1ba1ec..301208c25bdc 100644\n--- a/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\n+++ b/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\n@@ -5,4 +5,4 @@ config.suffixes = [\".txt\"]\n config.test_format = lit.formats.ShTest()\n config.test_source_root = None\n config.test_exec_root = None\n-config.substitutions.append((\"%var\", lit_config.params.get(\"var\", \"\")))\n+config.substitutions.append((\"%var\", lit_config.params.get(\"var\", \"default\")))\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt b/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\nindex 6dd9b16304e0..1d94c1213723 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\n@@ -14,21 +14,21 @@\n ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0 -fopenmp-simd\n ; REDEFINE: %{fcflags} = -check-prefix=SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu -fopenmp-simd\n ; REDEFINE: %{fcflags} = -check-prefix=SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0\n ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu\n ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n \n ; CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt b/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\nindex 3bf057151afb..23c0a6d50753 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\n@@ -7,7 +7,7 @@\n #\n # REDEFINE: %{global:greeting}=Hello\n # RUN: %{global:echo}\n-# CHECK: GLOBAL: Hello World\n+# CHECK:# | GLOBAL: Hello World\n \n # We can redefine the test suite config's substitutions multiple times.  Again,\n # the expansion order remains the same (%{global:echo} before %{global:greeting}\n@@ -17,7 +17,7 @@\n # REDEFINE: %{global:greeting}=Goodbye %{global:what}\n # REDEFINE: %{global:what}=Sleep\n # RUN: %{global:echo}\n-# CHECK: GLOBAL: Goodbye Sleep Sleep\n+# CHECK:# | GLOBAL: Goodbye Sleep Sleep\n \n # A new local substitution is prepended to the substitution list so that it can\n # depend on all substitutions that were defined previously, including those from\n@@ -26,7 +26,7 @@\n # DEFINE: %{local:greeting}=Hey %{global:what}\n # DEFINE: %{local:echo}=echo \"LOCAL: %{local:greeting} %{global:what}\"\n # RUN: %{local:echo}\n-# CHECK: LOCAL: Hey Sleep Sleep\n+# CHECK:# | LOCAL: Hey Sleep Sleep\n \n # As for substitutions from the test suite config, redefining local\n # substitutions should not change the expansion order.  Again, the expansion\n@@ -36,6 +36,6 @@\n # REDEFINE: %{local:greeting}=So Long %{global:what}\n # REDEFINE: %{global:what}=World\n # RUN: %{local:echo}\n-# CHECK: LOCAL: So Long World World\n+# CHECK:# | LOCAL: So Long World World\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt b/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\nindex 65f90792ff7b..5a1d7f2e1987 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\n@@ -1,19 +1,19 @@\n # Does it work as expected directly in RUN lines?\n # RUN: echo %(line), %(line-1), %(line+2)\n-# CHECK: [[#@LINE-1]], [[#@LINE-2]], [[#@LINE+1]]\n+# CHECK:# | [[#@LINE-1]], [[#@LINE-2]], [[#@LINE+1]]\n \n # %(line) substitutions refer to the original DEFINE/REDEFINE line not the RUN\n # line they eventually appear within.\n #\n # DEFINE: %{lines} = %(line)\n # RUN: echo '%{lines}'\n-# CHECK: [[#@LINE-2]]\n+# CHECK:# | [[#@LINE-2]]\n #\n # REDEFINE: %{lines} = %(line),                                                \\\n # REDEFINE:            %(line),                                                \\\n # REDEFINE:            %(line)\n # RUN: echo '%{lines}'\n-# CHECK: [[#@LINE-4]], [[#@LINE-3]], [[#@LINE-2]]\n+# CHECK:# | [[#@LINE-4]], [[#@LINE-3]], [[#@LINE-2]]\n \n # %(line+N) and %{line-N) should work too.\n #\n@@ -21,12 +21,12 @@\n # DEFINE:                %(line),                                              \\\n # DEFINE:                %(line-1)\n # RUN: echo '%{lines-rel}'\n-# CHECK: [[#@LINE-3]], [[#@LINE-3]], [[#@LINE-3]]\n+# CHECK:# | [[#@LINE-3]], [[#@LINE-3]], [[#@LINE-3]]\n #\n # REDEFINE: %{lines-rel} = %(line+5),                                          \\\n # REDEFINE:                %(line+0),                                          \\\n # REDEFINE:                %(line-10)\n # RUN: echo '%{lines-rel}'\n-# CHECK: [[#@LINE+1]], [[#@LINE-3]], [[#@LINE-12]]\n+# CHECK:# | [[#@LINE+1]], [[#@LINE-3]], [[#@LINE-12]]\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt b/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\nindex 18a27cdd72fa..d27fda2e2fe6 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\n@@ -1,25 +1,25 @@\n # DEFINE: %{abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789} = ok\n # RUN: echo '%{abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789}'\n-# CHECK: ok\n+# CHECK:# | ok\n \n # DEFINE: %{FooBar} = ok at %(line)\n # RUN: echo '%{FooBar}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{fooBar} = ok at %(line)\n # RUN: echo '%{fooBar}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{foo-bar-} = ok at %(line)\n # RUN: echo '%{foo-bar-}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{foo:bar:} = ok at %(line)\n # RUN: echo '%{foo:bar:}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{_foo_bar_} = ok at %(line)\n # RUN: echo '%{_foo_bar_}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt b/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\nindex eb5f0b918fd1..e504b822ace8 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\n@@ -6,7 +6,7 @@\n \n # RUN: echo '%{outer}'\n \n-# CHECK-NON-RECUR:%{inner}\n-# CHECK-RECUR:expanded\n+# CHECK-NON-RECUR:# | %{inner}\n+# CHECK-RECUR:# | expanded\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt b/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\nindex 9d2e7197fb3a..c1bdfef30b1a 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\n@@ -2,21 +2,21 @@\n \n # DEFINE: %{equals} = FileCheck -check-prefixes=FOO,BAR\n # RUN: echo '%{equals}'\n-# CHECK: FileCheck -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -check-prefixes=FOO,BAR\n #\n # REDEFINE: %{equals} == == =\n # RUN: echo '%{equals}'\n-# CHECK: = == =\n+# CHECK:# | = == =\n \n # DEFINE: %{continue-equals} = FileCheck -strict-whitespace -match-full-lines \\\n # DEFINE:                      -check-prefixes=FOO,BAR\n # RUN: echo '%{continue-equals}'\n-# CHECK: FileCheck -strict-whitespace -match-full-lines -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -strict-whitespace -match-full-lines -check-prefixes=FOO,BAR\n #\n # REDEFINE: %{continue-equals} = FileCheck -input-file=test.txt                \\\n # REDEFINE:                      -implicit-check-not=foobar                    \\\n # REDEFINE:                      -check-prefixes=FOO,BAR\n # RUN: echo '%{continue-equals}'\n-# CHECK: FileCheck -input-file=test.txt -implicit-check-not=foobar -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -input-file=test.txt -implicit-check-not=foobar -check-prefixes=FOO,BAR\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt b/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\nindex 58d5c1a34ce8..9143796edd32 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\n@@ -6,11 +6,11 @@\n \n # DEFINE: %{escape} = \\g<0>\\n\n # RUN: echo '%{escape}'\n-# CHECK: {{\\\\?}}\\g<0>{{\\\\?}}\\n\n+# CHECK:# | {{\\\\?}}\\g<0>{{\\\\?}}\\n\n \n # REDEFINE: %{escape} = \\n                                                     \\\n # REDEFINE:             \\g<param>\n # RUN: echo '%{escape}'\n-# CHECK: {{\\\\?}}\\n {{\\\\?}}\\g<param>\n+# CHECK:# | {{\\\\?}}\\n {{\\\\?}}\\g<param>\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt b/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\nindex 1259e511ba70..3e4db1b15d92 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\n@@ -3,33 +3,33 @@\n #\n # DEFINE: %{empty}=\n # RUN: echo \"'%{empty}'\"\n-# CHECK:''\n+# CHECK:# | ''\n #\n # REDEFINE: %{empty}=\n # RUN: echo \"'%{empty}'\"\n-# CHECK:''\n+# CHECK:# | ''\n \n # A value consisting only of whitespace is trimmed to the empty string.\n #\n #               v~~ intentional whitespace\n # DEFINE: %{ws}=   \n # RUN: echo \"'%{ws}'\"\n-# CHECK:''\n+# CHECK:# | ''\n #\n #                 v intentional whitespace\n # REDEFINE: %{ws}= \n # RUN: echo \"'%{ws}'\"\n-# CHECK:''\n+# CHECK:# | ''\n \n # Whitespace is not required around the name or value.\n #\n # DEFINE:%{no-whitespace}=abc\n # RUN: echo \"'%{no-whitespace}'\"\n-# CHECK:'abc'\n+# CHECK:# | 'abc'\n #\n # REDEFINE:%{no-whitespace}=HelloWorld\n # RUN: echo \"'%{no-whitespace}'\"\n-# CHECK:'HelloWorld'\n+# CHECK:# | 'HelloWorld'\n \n # Whitespace is not required between substitutions in a value.\n #\n@@ -37,11 +37,11 @@\n # DEFINE: %{adjacent1} = bar\n # DEFINE: %{has-adjacent-substs} = %{adjacent0}%{adjacent1}\n # RUN: echo \"'%{has-adjacent-substs}'\"\n-# CHECK:'foobar'\n+# CHECK:# | 'foobar'\n #\n # REDEFINE: %{has-adjacent-substs} = %{adjacent0}%{adjacent1}%{adjacent0}\n # RUN: echo \"'%{has-adjacent-substs}'\"\n-# CHECK:'foobarfoo'\n+# CHECK:# | 'foobarfoo'\n \n # Exact whitespace is preserved within the value, but whitespace enclosing the\n # name or value is discarded.  ('%{' and '}' are part of the name, and\n@@ -50,11 +50,11 @@\n #                                       v~~ intentional whitespace\n # DEFINE:   %{whitespace}  =  abc    def   \n # RUN: echo \"'%{whitespace}'\"\n-# CHECK:'abc    def'\n+# CHECK:# | 'abc    def'\n #                                      v intentional whitespace\n # REDEFINE: %{whitespace} = Hello World \n # RUN: echo \"'%{whitespace}'\"\n-# CHECK:'Hello World'\n+# CHECK:# | 'Hello World'\n \n # Line continuations in the value are permitted and collapse whitespace.\n #\n@@ -66,12 +66,12 @@\n # DEFINE:  pqr \n #             ^ intentional whitespace\n # RUN: echo \"'%{continue}'\"\n-# CHECK:'abc def ghi jkl mno pqr'\n+# CHECK:# | 'abc def ghi jkl mno pqr'\n #\n # REDEFINE: %{continue} =  abc  \\\n # REDEFINE: def\n # RUN: echo \"'%{continue}'\"\n-# CHECK:'abc def'\n+# CHECK:# | 'abc def'\n \n # Whitespace at the end of the line after a '\\' is ignored, and it's treated as\n # a line continuation.  Otherwise, the behavior would be hard to understand\n@@ -83,7 +83,7 @@\n #                                   ^ intentional whitespace\n # DEFINE: baz\n # RUN: echo \"'%{ws-after-continue}'\"\n-# CHECK:'foo bar baz'\n+# CHECK:# | 'foo bar baz'\n #\n #                                     v intentional whitespace\n # REDEFINE: %{ws-after-continue}=foo \\ \n@@ -91,7 +91,7 @@\n #                                     ^~~~~~~~~~~~ intentional whitespace\n # REDEFINE: baz\n # RUN: echo \"'%{ws-after-continue}'\"\n-# CHECK:'foo bar baz'\n+# CHECK:# | 'foo bar baz'\n \n # A line continuation is recognized anywhere.  It should be used only where\n # whitespace is permitted because it reduces to a single space.\n@@ -107,7 +107,7 @@\n # DEFINE:\\\n # DEFINE:a\n # RUN: echo \"'%{blank-lines}'\"\n-# CHECK:'a'\n+# CHECK:# | 'a'\n #\n # REDEFINE:                  \\\n # REDEFINE: %{blank-lines}   \\\n@@ -120,7 +120,7 @@\n # REDEFINE:                  \\\n # REDEFINE:      c\n # RUN: echo \"'%{blank-lines}'\"\n-# CHECK:'a b c'\n+# CHECK:# | 'a b c'\n \n # The fourth DEFINE line is deceptive because it looks like a new substitution,\n # but it's actually a continuation of the previous value.\n@@ -130,6 +130,6 @@\n # DEFINE: %{deceptive-continue}=echo \\\n # DEFINE: %{name}=%{value}\n # RUN: %{deceptive-continue}\n-# CHECK:x=3\n+# CHECK:# | x=3\n \n # CHECK:{{ *}}Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt b/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\nindex b0a7cfd97941..b5fc1b49fcc5 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\n@@ -1,46 +1,34 @@\n-#       CHECK: -- Testing:{{.*}}\n-#  CHECK-NEXT: PASS: shtest-if-else :: test.txt (1 of 1)\n-#  CHECK-NEXT: Exit Code: 0\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: Command Output (stdout):\n-#  CHECK-NEXT: --\n+# CHECK: -- Testing:{{.*}}\n+# CHECK-NEXT: PASS: shtest-if-else :: test.txt (1 of 1)\n+#      CHECK: Command Output (stdout):\n+# CHECK-NEXT: --\n \n # RUN: %if feature %{ echo \"test-1\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-1\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-1\"\n \n # If %else is not present it is treated like %else %{%}. Empty commands\n # are ignored.\n #\n # RUN: %if nofeature %{ echo \"fail\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#   CHECK-NOT: fail\n+#     CHECK: # {{RUN}}: at line [[#@LINE-1]] has no command after substitutions\n+# CHECK-NOT: fail\n \n # RUN: %if nofeature %{ echo \"fail\" %} %else %{ echo \"test-2\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-2\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-2\"\n \n # Spaces inside curly braces are not ignored\n #\n # RUN: echo test-%if feature %{ 3 %} %else %{ fail %}-test\n # RUN: echo test-%if feature %{ 4 4 %} %else %{ fail %}-test\n # RUN: echo test-%if nofeature %{ fail %} %else %{ 5 5 %}-test\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 3 -test\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 4 4 -test\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 5 5 -test\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo test- 3 -test\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo test- 4 4 -test\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo test- 5 5 -test\n \n # Escape line breaks for multi-line expressions\n #\n@@ -48,42 +36,32 @@\n # RUN:   %{ echo     \\\n # RUN:     \"test-5\" \\\n # RUN:   %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-4]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-5\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-5\"\n \n # RUN: %if nofeature       \\\n # RUN:   %{ echo \"fail\" %}   \\\n # RUN: %else               \\\n # RUN:   %{ echo \"test-6\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-4]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-6\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-6\"\n \n # RUN: echo \"test%if feature %{%} %else %{%}-7\"\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-7\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-7\"\n \n # Escape %if. Without %if..%else context '%{' and '%}' are treated\n # literally.\n #\n # RUN: echo %%if feature %{ echo \"test-8\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: %if feature %{ echo test-8 %}\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo %if feature %{ echo \"test-8\" %}\n \n # Nested expressions are supported:\n #\n # RUN: echo %if feature %{ %if feature %{ %if nofeature %{\"fail\"%} %else %{\"test-9\"%} %} %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-9\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-9\"\n \n # Binary expression evaluation and regex match can be used as\n # conditions.\n@@ -91,18 +69,12 @@\n # RUN: echo %if feature && !nofeature %{ \"test-10\" %}\n # RUN: echo %if feature && nofeature %{ \"fail\" %} %else %{ \"test-11\" %}\n # RUN: echo %if {{fea.+}} %{ \"test-12\" %} %else %{ \"fail\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-10\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-11\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-12\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo \"test-10\"\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-11\"\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo \"test-12\"\n \n # Spaces between %if and %else are ignored. If there is no %else -\n # space after %if %{...%} is not ignored.\n@@ -110,39 +82,27 @@\n # RUN: echo XX %if feature %{YY%} ZZ\n # RUN: echo AA %if feature %{BB%} %else %{CC%} DD\n # RUN: echo AA %if nofeature %{BB%} %else %{CC%} DD\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: XX YY ZZ\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: AA BB DD\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: AA CC DD\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo XX YY ZZ\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo AA BB DD\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo AA CC DD\n \n # '{' and '}' can be used without escaping\n #\n # RUN: %if feature %{echo {}%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: {}\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo {}\n \n # Spaces are not required\n #\n # RUN: echo %if feature%{\"ok\"%}%else%{\"fail\"%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: ok\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"ok\"\n \n # Substitutions with braces are handled correctly\n #\n # RUN: echo %{sub} %if feature%{test-%{sub}%}%else%{\"fail\"%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: ok test-ok\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo ok test-ok\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt b/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\nindex fb3a3e000789..5ff0c891450b 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\n@@ -1,3 +1,4 @@\n # RUN: true\n # RUN: echo hi\n-# RUN: not not wc missing-file &> %t.out\n+# RUN: not not wc missing-file &> %t.out || true\n+# RUN: not %{python} %S/write-a-lot.py &> %t.out\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg b/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\nindex b872854d21e6..c53fd157b6ae 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\n@@ -2,4 +2,5 @@ import lit.formats\n \n config.name = \"shtest-output-printing\"\n config.suffixes = [\".txt\"]\n+config.substitutions.append((\"%{python}\", sys.executable))\n config.test_format = lit.formats.ShTest(execute_external=False)\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py b/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py\nnew file mode 100644\nindex 000000000000..ffcba7d517cd\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py\n@@ -0,0 +1,6 @@\n+#!/usr/bin/env python\n+\n+import sys\n+\n+sys.stdout.write(\"All work and no play makes Jack a dull boy.\\n\" * 1000);\n+sys.stdout.flush()\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt\nnew file mode 100644\nindex 000000000000..15a87aee46a3\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt\n@@ -0,0 +1 @@\n+RUN: @echo 2> %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt\nnew file mode 100644\nindex 000000000000..27fd0c4209fd\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt\n@@ -0,0 +1,2 @@\n+RUN: touch %t\n+RUN: @echo < %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt\nnew file mode 100644\nindex 000000000000..9611918f7e12\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt\n@@ -0,0 +1 @@\n+RUN: echo 2> %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt\nnew file mode 100644\nindex 000000000000..bc771be6b22a\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt\n@@ -0,0 +1,2 @@\n+RUN: touch %t\n+RUN: echo < %t\ndiff --git a/llvm/utils/lit/tests/allow-retries.py b/llvm/utils/lit/tests/allow-retries.py\nindex b8abe0ba4fee..ef548534f082 100644\n--- a/llvm/utils/lit/tests/allow-retries.py\n+++ b/llvm/utils/lit/tests/allow-retries.py\n@@ -15,9 +15,28 @@\n \n # This test does not succeed within the allowed retry limit\n #\n-# RUN: not %{lit} %{inputs}/allow-retries/does-not-succeed-within-limit.py | FileCheck --check-prefix=CHECK-TEST3 %s\n-# CHECK-TEST3: Failed Tests (1):\n-# CHECK-TEST3: allow-retries :: does-not-succeed-within-limit.py\n+# Check that the execution trace isn't corrupt due to reprocessing the script\n+# multiple times (e.g., '%dbg(...)' processing used to accumulate across\n+# retries).\n+#\n+# RUN: not %{lit} %{inputs}/allow-retries/does-not-succeed-within-limit.py -v |\\\n+# RUN:   FileCheck --check-prefix=CHECK-TEST3 -match-full-lines %s\n+#\n+#       CHECK-TEST3: FAIL: allow-retries :: does-not-succeed-within-limit.py (1 of 1)\n+#  CHECK-TEST3-NEXT: {{\\**}} TEST 'allow-retries :: does-not-succeed-within-limit.py' FAILED {{\\**}}\n+#  CHECK-TEST3-NEXT: Exit Code: 1\n+# CHECK-TEST3-EMPTY:\n+#  CHECK-TEST3-NEXT: Command Output (stdout):\n+#  CHECK-TEST3-NEXT: --\n+#  CHECK-TEST3-NEXT: # {{RUN}}: at line 3\n+#  CHECK-TEST3-NEXT: false\n+#  CHECK-TEST3-NEXT: # executed command: false\n+#  CHECK-TEST3-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-TEST3-NEXT: # error: command failed with exit status: 1\n+# CHECK-TEST3-EMPTY:\n+#  CHECK-TEST3-NEXT: --\n+#       CHECK-TEST3: Failed Tests (1):\n+#       CHECK-TEST3: allow-retries :: does-not-succeed-within-limit.py\n \n # This test should be UNRESOLVED since it has more than one ALLOW_RETRIES\n # lines, and that is not allowed.\ndiff --git a/llvm/utils/lit/tests/lit-opts.py b/llvm/utils/lit/tests/lit-opts.py\nindex d292ca74f3b9..a533a59d9d12 100644\n--- a/llvm/utils/lit/tests/lit-opts.py\n+++ b/llvm/utils/lit/tests/lit-opts.py\n@@ -8,7 +8,7 @@\n #\n # RUN: env LIT_OPTS=-a \\\n # RUN: %{lit} -s %{inputs}/lit-opts \\\n-# RUN: | FileCheck -check-prefix=SHOW-ALL -DVAR= %s\n+# RUN: | FileCheck -check-prefix=SHOW-ALL -DVAR=default %s\n \n # Check that LIT_OPTS understands multiple options with arbitrary spacing.\n #\n@@ -28,6 +28,6 @@\n \n # SHOW-ALL:     Testing: 1 tests\n # SHOW-ALL:     PASS: lit-opts :: test.txt (1 of 1)\n-# SHOW-ALL:     {{^}}[[VAR]]\n+# SHOW-ALL:     echo [[VAR]]\n # SHOW-ALL-NOT: PASS\n # SHOW-ALL:     Passed: 1\ndiff --git a/llvm/utils/lit/tests/shtest-define.py b/llvm/utils/lit/tests/shtest-define.py\nindex 1d0997bbbaf8..8c9309804cce 100644\n--- a/llvm/utils/lit/tests/shtest-define.py\n+++ b/llvm/utils/lit/tests/shtest-define.py\n@@ -136,15 +136,15 @@\n # RUN: %{lit} -va %{my-inputs}/shared-substs-*.txt 2>&1 |                      \\\n # RUN:   FileCheck -check-prefix=SHARED-SUBSTS -match-full-lines %s\n #\n-# SHARED-SUBSTS: shared-substs-0.txt\n-# SHARED-SUBSTS: GLOBAL: World\n-# SHARED-SUBSTS: LOCAL0: LOCAL0:Hello LOCAL0:World\n-# SHARED-SUBSTS: LOCAL0: subst\n+# SHARED-SUBSTS:# | shared-substs-0.txt\n+# SHARED-SUBSTS:# | GLOBAL: World\n+# SHARED-SUBSTS:# | LOCAL0: LOCAL0:Hello LOCAL0:World\n+# SHARED-SUBSTS:# | LOCAL0: subst\n #\n-# SHARED-SUBSTS: shared-substs-1.txt\n-# SHARED-SUBSTS: GLOBAL: World\n-# SHARED-SUBSTS: LOCAL1: LOCAL1:Hello LOCAL1:World\n-# SHARED-SUBSTS: LOCAL1: subst\n+# SHARED-SUBSTS:# | shared-substs-1.txt\n+# SHARED-SUBSTS:# | GLOBAL: World\n+# SHARED-SUBSTS:# | LOCAL1: LOCAL1:Hello LOCAL1:World\n+# SHARED-SUBSTS:# | LOCAL1: subst\n #\n # REDEFINE: %{test} = shared-substs-0.txt\n # RUN: %{record-test}\ndiff --git a/llvm/utils/lit/tests/shtest-env.py b/llvm/utils/lit/tests/shtest-env.py\nindex f2e8216f7f4a..a4775ac6688d 100644\n--- a/llvm/utils/lit/tests/shtest-env.py\n+++ b/llvm/utils/lit/tests/shtest-env.py\n@@ -10,88 +10,115 @@\n # CHECK: -- Testing: 16 tests{{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-assign.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"FOO=1\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env FOO=1\n+# CHECK: # executed command: env FOO=1\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-u-arg.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO\n+# CHECK: # executed command: env -u FOO\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-u.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u\n+# CHECK: # executed command: env -u\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-nested-none.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"env\" \"env\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env env env\n+# CHECK: # executed command: env env env\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-none.txt ({{[^)]*}})\n-# CHECK: $ \"env\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env\n+# CHECK: # executed command: env\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-cd.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"cd\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'cd'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 cd foobar\n+# CHECK: # executed command: env -u FOO BAR=3 cd foobar\n+# CHECK: # | Error: 'env' cannot call 'cd'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-colon.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \":\"\n-# CHECK: Error: 'env' cannot call ':'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 :\n+# CHECK: # executed command: env -u FOO BAR=3 :\n+# CHECK: # | Error: 'env' cannot call ':'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-echo.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"echo\" \"hello\" \"world\"\n-# CHECK: Error: 'env' cannot call 'echo'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 echo hello world\n+# CHECK: # executed command: env -u FOO BAR=3 echo hello world\n+# CHECK: # | Error: 'env' cannot call 'echo'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: PASS: shtest-env :: env-calls-env.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"env\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"FOO=2\" \"env\" \"BAR=1\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"env\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=1\" \"env\" \"-u\" \"BAR\" \"FOO=2\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=1\" \"env\" \"-u\" \"BAR\" \"FOO=2\" \"env\" \"BAZ=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env env [[PYTHON:.+]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env env [[PYTHON_BARE:.+]] print_environment.py\n+# CHECK: env FOO=2 env BAR=1 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env FOO=2 env BAR=1 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO env -u BAR [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO env -u BAR [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO BAR=1 env -u BAR FOO=2 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO BAR=1 env -u BAR FOO=2 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO BAR=1 env -u BAR FOO=2 env BAZ=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO BAR=1 env -u BAR FOO=2 env BAZ=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: FAIL: shtest-env :: env-calls-export.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"export\" \"BAZ=3\"\n-# CHECK: Error: 'env' cannot call 'export'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 export BAZ=3\n+# CHECK: # executed command: env -u FOO BAR=3 export BAZ=3\n+# CHECK: # | Error: 'env' cannot call 'export'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-mkdir.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"mkdir\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'mkdir'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 mkdir foobar\n+# CHECK: # executed command: env -u FOO BAR=3 mkdir foobar\n+# CHECK: # | Error: 'env' cannot call 'mkdir'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-not-builtin.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"not\" \"rm\" \"{{.*}}.no-such-file\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 not rm {{.+}}.no-such-file\n+# CHECK: # executed command: env -u FOO BAR=3 not rm {{.+}}.no-such-file\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-rm.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"rm\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 rm foobar\n+# CHECK: # executed command: env -u FOO BAR=3 rm foobar\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: PASS: shtest-env :: env-u.txt ({{[^)]*}})\n-# CHECK: $ \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: env -u FOO [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO -u BAR [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO -u BAR [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: PASS: shtest-env :: env.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"A_FOO=999\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"A_FOO=1\" \"B_BAR=2\" \"C_OOF=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env A_FOO=999 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=999 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env A_FOO=1 B_BAR=2 C_OOF=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=1 B_BAR=2 C_OOF=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: PASS: shtest-env :: mixed.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"A_FOO=999\" \"-u\" \"FOO\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"A_FOO=1\" \"-u\" \"FOO\" \"B_BAR=2\" \"-u\" \"BAR\" \"C_OOF=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env A_FOO=999 -u FOO [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=999 -u FOO [[PYTHON_BARE]] print_environment.py\n+# CHECK: env A_FOO=1 -u FOO B_BAR=2 -u BAR C_OOF=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=1 -u FOO B_BAR=2 -u BAR C_OOF=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: Passed:  4\n # CHECK: Failed: 12\ndiff --git a/llvm/utils/lit/tests/shtest-format.py b/llvm/utils/lit/tests/shtest-format.py\nindex 621776ab7bc2..4a3d65b7bce4 100644\n--- a/llvm/utils/lit/tests/shtest-format.py\n+++ b/llvm/utils/lit/tests/shtest-format.py\n@@ -43,13 +43,21 @@\n # CHECK-EMPTY:\n #  CHECK-NEXT: Command Output (stdout):\n #  CHECK-NEXT: --\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-#  CHECK-NEXT: $ \"printf\"\n-#  CHECK-NEXT: # command output:\n-#  CHECK-NEXT: line 1: failed test output on stdout\n-#  CHECK-NEXT: line 2: failed test output on stdout\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-#  CHECK-NEXT: $ \"false\"\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: printf \"line 1: failed test output on stdout\\nline 2: failed test output on stdout\"\n+#  CHECK-NEXT: executed command: printf 'line 1: failed test output on stdout\\nline 2: failed test output on stdout'\n+#  CHECK-NEXT: # .---command stdout------------\n+#  CHECK-NEXT: # | line 1: failed test output on stdout\n+#  CHECK-NEXT: # | line 2: failed test output on stdout\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # RUN: at line 2\n+#  CHECK-NEXT: false\n+#  CHECK-NEXT: # executed command: false\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: --\n+\n \n # CHECK: UNRESOLVED: shtest-format :: no-test-line.txt\n # CHECK: PASS: shtest-format :: pass.txt\n@@ -73,8 +81,11 @@\n # CHECK-EMPTY:\n #  CHECK-NEXT: Command Output (stdout):\n #  CHECK-NEXT: --\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-#  CHECK-NEXT: $ \"true\"\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: true\n+#  CHECK-NEXT: # executed command: true\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: --\n \n # CHECK: Failed Tests (4)\n # CHECK: shtest-format :: external_shell/fail.txt\ndiff --git a/llvm/utils/lit/tests/shtest-if-else.py b/llvm/utils/lit/tests/shtest-if-else.py\nindex aaf94a6e2437..c18da4abbcca 100644\n--- a/llvm/utils/lit/tests/shtest-if-else.py\n+++ b/llvm/utils/lit/tests/shtest-if-else.py\n@@ -1,5 +1,6 @@\n # RUN: %{lit} -v --show-all %{inputs}/shtest-if-else/test.txt \\\n-# RUN:    | FileCheck %{inputs}/shtest-if-else/test.txt --match-full-lines\n+# RUN:    | FileCheck %{inputs}/shtest-if-else/test.txt --match-full-lines \\\n+# RUN:                --implicit-check-not='RUN:'\n \n # RUN: not %{lit} -v --show-all %{inputs}/shtest-if-else/test-neg1.txt 2>&1 \\\n # RUN:    | FileCheck %{inputs}/shtest-if-else/test-neg1.txt\ndiff --git a/llvm/utils/lit/tests/shtest-inject.py b/llvm/utils/lit/tests/shtest-inject.py\nindex 17e293ea1a12..3d34eb7161d4 100644\n--- a/llvm/utils/lit/tests/shtest-inject.py\n+++ b/llvm/utils/lit/tests/shtest-inject.py\n@@ -1,9 +1,26 @@\n-# Check that we can inject commands at the beginning of a ShTest.\n+# Check that we can inject preamble commands at the beginning of a ShTest.\n+#\n+# For one case, check the execution trace as these preamble commands have\n+# \"preamble command\" instead of the usual \"{{RUN}}: at line N\".\n \n # RUN: %{lit} %{inputs}/shtest-inject/test-empty.txt --show-all | FileCheck --check-prefix=CHECK-TEST1 %s\n #\n-# CHECK-TEST1: THIS WAS\n-# CHECK-TEST1: INJECTED\n+#       CHECK-TEST1: Command Output (stdout):\n+#  CHECK-TEST1-NEXT: --\n+#  CHECK-TEST1-NEXT: # preamble command line\n+#  CHECK-TEST1-NEXT: echo \"THIS WAS\"\n+#  CHECK-TEST1-NEXT: # executed command: echo 'THIS WAS'\n+#  CHECK-TEST1-NEXT: # .---command stdout{{-*}}\n+#  CHECK-TEST1-NEXT: # | THIS WAS\n+#  CHECK-TEST1-NEXT: # `---{{-*}}\n+#  CHECK-TEST1-NEXT: # preamble command line\n+#  CHECK-TEST1-NEXT: echo \"INJECTED\"\n+#  CHECK-TEST1-NEXT: # executed command: echo INJECTED\n+#  CHECK-TEST1-NEXT: # .---command stdout{{-*}}\n+#  CHECK-TEST1-NEXT: # | INJECTED\n+#  CHECK-TEST1-NEXT: # `---{{-*}}\n+# CHECK-TEST1-EMPTY:\n+#  CHECK-TEST1-NEXT: --\n #\n # CHECK-TEST1: Passed: 1\n \ndiff --git a/llvm/utils/lit/tests/shtest-not.py b/llvm/utils/lit/tests/shtest-not.py\nindex d23c9d0cffaf..4590b9664b84 100644\n--- a/llvm/utils/lit/tests/shtest-not.py\n+++ b/llvm/utils/lit/tests/shtest-not.py\n@@ -10,112 +10,158 @@\n # CHECK: -- Testing: 17 tests{{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-args-nested-none.txt {{.*}}\n-# CHECK: $ \"!\" \"!\" \"!\"\n-# CHECK: Error: '!' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: ! ! !\n+# CHECK: # executed command: ! ! !\n+# CHECK: # | Error: '!' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-args-none.txt {{.*}}\n-# CHECK: $ \"!\"\n-# CHECK: Error: '!' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: !\n+# CHECK: # executed command: !\n+# CHECK: # | Error: '!' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-calls-external.txt {{.*}}\n \n-# CHECK: $ \"!\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"!\" \"!\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"!\" \"!\" \"!\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"!\" \"!\" \"!\" \"!\" \"{{[^\"]*}}\" \"pass.py\"\n+# CHECK: ! [[PYTHON:.*]] fail.py\n+# CHECK: # executed command: ! [[PYTHON_BARE:.*]] fail.py\n+# CHECK: ! ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! ! [[PYTHON_BARE]] pass.py\n+# CHECK: ! ! ! [[PYTHON]] fail.py\n+# CHECK: # executed command: ! ! ! [[PYTHON_BARE]] fail.py\n+# CHECK: ! ! ! ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! ! ! ! [[PYTHON_BARE]] pass.py\n \n-# CHECK: $ \"!\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! [[PYTHON_BARE]] pass.py\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-last-is-crash.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not --crash\n+# CHECK: # executed command: not --crash\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-nested-none.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not not\n+# CHECK: # executed command: not not not\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-none.txt {{.*}}\n-# CHECK: $ \"not\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not\n+# CHECK: # executed command: not\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-cd.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"cd\" \"foobar\"\n-# CHECK: $ \"not\" \"--crash\" \"cd\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'cd'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not cd foobar\n+# CHECK: # executed command: not not cd foobar\n+# CHECK: not --crash cd foobar\n+# CHECK: # executed command: not --crash cd foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'cd'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-colon.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \":\" \"foobar\"\n-# CHECK: $ \"not\" \"--crash\" \":\"\n-# CHECK: Error: 'not --crash' cannot call ':'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not : foobar\n+# CHECK: # executed command: not not : foobar\n+# CHECK: not --crash :\n+# CHECK: # executed command: not --crash :\n+# CHECK: # | Error: 'not --crash' cannot call ':'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-diff-with-crash.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"diff\" \"-u\" {{.*}}\n-# CHECK-NOT: \"$\"\n+# CHECK: not --crash diff -u {{.*}}\n+# CHECK: # executed command: not --crash diff -u {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n # CHECK-NOT: {{[Ee]rror}}\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: # error: command failed with exit status: {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n # CHECK-NOT: {{[Ee]rror}}\n-# CHECK-NOT: \"$\"\n \n # CHECK: FAIL: shtest-not :: not-calls-diff.txt {{.*}}\n-# CHECK: $ \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"diff\" {{.*}}\n-# CHECK-NOT: \"$\"\n+# CHECK: not diff {{.*}}\n+# CHECK: # executed command: not diff {{.*}}\n+# CHECK: not not not diff {{.*}}\n+# CHECK: # executed command: not not not diff {{.*}}\n+# CHECK: not not not not not diff {{.*}}\n+# CHECK: # executed command: not not not not not diff {{.*}}\n+# CHECK: diff {{.*}}\n+# CHECK: # executed command: diff {{.*}}\n+# CHECK: not not diff {{.*}}\n+# CHECK: # executed command: not not diff {{.*}}\n+# CHECK: not not not not diff {{.*}}\n+# CHECK: # executed command: not not not not diff {{.*}}\n+# CHECK: not diff {{.*}}\n+# CHECK: # executed command: not diff {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-echo.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"echo\" \"hello\" \"world\"\n-# CHECK: $ \"not\" \"--crash\" \"echo\" \"hello\" \"world\"\n-# CHECK: Error: 'not --crash' cannot call 'echo'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not echo hello world\n+# CHECK: # executed command: not not echo hello world\n+# CHECK: not --crash echo hello world\n+# CHECK: # executed command: not --crash echo hello world\n+# CHECK: # | Error: 'not --crash' cannot call 'echo'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-env-builtin.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"env\" \"-u\" \"FOO\" \"BAR=3\" \"rm\" \"{{.*}}.no-such-file\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not --crash env -u FOO BAR=3 rm {{.*}}.no-such-file\n+# CHECK: # executed command: not --crash env -u FOO BAR=3 rm {{.*}}.no-such-file\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-export.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"export\" \"FOO=1\"\n-# CHECK: $ \"not\" \"--crash\" \"export\" \"BAZ=3\"\n-# CHECK: Error: 'not --crash' cannot call 'export'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not export FOO=1\n+# CHECK: # executed command: not not export FOO=1\n+# CHECK: not --crash export BAZ=3\n+# CHECK: # executed command: not --crash export BAZ=3\n+# CHECK: # | Error: 'not --crash' cannot call 'export'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n \n # CHECK: PASS: shtest-not :: not-calls-external.txt {{.*}}\n \n-# CHECK: $ \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-\n-# CHECK: $ \"env\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"env\" \"-u\" \"FOO\" \"BAR=2\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"env\" \"-u\" \"FOO\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"env\" \"FOO=1\" \"env\" \"FOO=2\" \"BAR=1\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"-u\" \"BAR\" \"env\" \"-u\" \"FOO\" \"BAR=1\" \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"env\" \"FOO=2\" \"BAR=2\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"env\" \"-u\" \"BAR\" \"not\" \"env\" \"-u\" \"FOO\" \"BAR=1\" \"{{[^\"]*}}\" \"pass.py\"\n+# CHECK: not [[PYTHON]] fail.py\n+# CHECK: # executed command: not [[PYTHON_BARE]] fail.py\n+# CHECK: not not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not [[PYTHON_BARE]] pass.py\n+# CHECK: not not not [[PYTHON]] fail.py\n+# CHECK: # executed command: not not not [[PYTHON_BARE]] fail.py\n+# CHECK: not not not not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not not not [[PYTHON_BARE]] pass.py\n+\n+# CHECK: not not --crash [[PYTHON]] pass.py\n+# CHECK: # executed command: not not --crash [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash [[PYTHON]] fail.py\n+# CHECK: # executed command: not not --crash [[PYTHON_BARE]] fail.py\n+# CHECK: not not --crash not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not --crash not [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash not [[PYTHON]] fail.py\n+# CHECK: # executed command: not not --crash not [[PYTHON_BARE]] fail.py\n+\n+# CHECK: env not [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env not [[PYTHON_BARE]] fail.py\n+# CHECK: not env [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: not env [[PYTHON_BARE]] fail.py\n+# CHECK: env FOO=1 not [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 not [[PYTHON_BARE]] fail.py\n+# CHECK: not env FOO=1 BAR=1 [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 [[PYTHON_BARE]] fail.py\n+# CHECK: env FOO=1 BAR=1 not env -u FOO BAR=2 [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 BAR=1 not env -u FOO BAR=2 [[PYTHON_BARE]] fail.py\n+# CHECK: not env FOO=1 BAR=1 not env -u FOO -u BAR [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 not env -u FOO -u BAR [[PYTHON_BARE]] pass.py\n+# CHECK: not not env FOO=1 env FOO=2 BAR=1 [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not not env FOO=1 env FOO=2 BAR=1 [[PYTHON_BARE]] pass.py\n+# CHECK: env FOO=1 -u BAR env -u FOO BAR=1 not not [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 -u BAR env -u FOO BAR=1 not not [[PYTHON_BARE]] pass.py\n+\n+# CHECK: not env FOO=1 BAR=1 env FOO=2 BAR=2 not --crash [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 env FOO=2 BAR=2 not --crash [[PYTHON_BARE]] pass.py\n+# CHECK: not env FOO=1 BAR=1 not --crash not [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 not --crash not [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash env -u BAR not env -u FOO BAR=1 [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not not --crash env -u BAR not env -u FOO BAR=1 [[PYTHON_BARE]] pass.py\n \n \n # CHECK: FAIL: shtest-not :: not-calls-fail2.txt {{.*}}\n@@ -123,16 +169,20 @@\n # CHECK-NEXT: Exit Code: 1\n \n # CHECK: FAIL: shtest-not :: not-calls-mkdir.txt {{.*}}\n-# CHECK: $ \"not\" \"mkdir\" {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"mkdir\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'mkdir'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not mkdir {{.*}}\n+# CHECK: # executed command: not mkdir {{.*}}\n+# CHECK: not --crash mkdir foobar\n+# CHECK: # executed command: not --crash mkdir foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'mkdir'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-rm.txt {{.*}}\n-# CHECK: $ \"not\" \"rm\" {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"rm\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not rm {{.*}}\n+# CHECK: # executed command: not rm {{.*}}\n+# CHECK: not --crash rm foobar\n+# CHECK: # executed command: not --crash rm foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: Passed:  1\n # CHECK: Failed: 16\ndiff --git a/llvm/utils/lit/tests/shtest-output-printing.py b/llvm/utils/lit/tests/shtest-output-printing.py\nindex 7cd975ba8d3c..3e49197520a9 100644\n--- a/llvm/utils/lit/tests/shtest-output-printing.py\n+++ b/llvm/utils/lit/tests/shtest-output-printing.py\n@@ -1,28 +1,45 @@\n # Check the various features of the ShTest format.\n #\n # RUN: not %{lit} -v %{inputs}/shtest-output-printing > %t.out\n-# RUN: FileCheck --input-file %t.out %s\n+# RUN: FileCheck --input-file %t.out --match-full-lines %s\n #\n # END.\n \n-# CHECK: -- Testing:\n-\n-# CHECK: FAIL: shtest-output-printing :: basic.txt\n-# CHECK-NEXT: *** TEST 'shtest-output-printing :: basic.txt' FAILED ***\n-# CHECK-NEXT: Exit Code: 1\n-#\n-# CHECK:      Command Output\n-# CHECK-NEXT: --\n-# CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \"true\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-# CHECK-NEXT: $ \"echo\" \"hi\"\n-# CHECK-NEXT: # command output:\n-# CHECK-NEXT: hi\n-#\n-# CHECK:      $ \":\" \"RUN: at line 3\"\n-# CHECK-NEXT: $ \"not\" \"not\" \"wc\" \"missing-file\"\n-# CHECK-NEXT: # redirected output from '{{.*(/|\\\\\\\\)}}basic.txt.tmp.out':\n-# CHECK-NEXT: {{cannot open missing-file|missing-file.* No such file or directory}}\n-# CHECK:      note: command had no output on stdout or stderr\n-# CHECK-NEXT: error: command failed with exit status: 1\n+#       CHECK: -- Testing: {{.*}}\n+#       CHECK: FAIL: shtest-output-printing :: basic.txt {{.*}}\n+#  CHECK-NEXT: ***{{\\**}} TEST 'shtest-output-printing :: basic.txt' FAILED ***{{\\**}}\n+#  CHECK-NEXT: Exit Code: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: Command Output (stdout):\n+#  CHECK-NEXT: --\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: true\n+#  CHECK-NEXT: # executed command: true\n+#  CHECK-NEXT: # RUN: at line 2\n+#  CHECK-NEXT: echo hi\n+#  CHECK-NEXT: # executed command: echo hi\n+#  CHECK-NEXT: # .---command stdout------------\n+#  CHECK-NEXT: # | hi\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # RUN: at line 3\n+#  CHECK-NEXT: not not wc missing-file &> [[FILE:.*]] || true\n+#  CHECK-NEXT: # executed command: not not wc missing-file\n+#  CHECK-NEXT: # .---redirected output from '[[FILE]]'\n+#  CHECK-NEXT: # | wc: {{cannot open missing-file|missing-file.* No such file or directory}}\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+#  CHECK-NEXT: # executed command: true\n+#  CHECK-NEXT: # RUN: at line 4\n+#  CHECK-NEXT: not {{.*}}/python{{.*}} {{.*}}/write-a-lot.py &> [[FILE:.*]]\n+#  CHECK-NEXT: # executed command: not {{.*}}/python{{.*}} {{.*}}/write-a-lot.py\n+#  CHECK-NEXT: # .---redirected output from '[[FILE]]'\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#       CHECK: # | ...\n+#  CHECK-NEXT: # `---data was truncated--------\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT:--\ndiff --git a/llvm/utils/lit/tests/shtest-pushd-popd.py b/llvm/utils/lit/tests/shtest-pushd-popd.py\nindex 26296a7ffcf5..6d7e93c74a05 100644\n--- a/llvm/utils/lit/tests/shtest-pushd-popd.py\n+++ b/llvm/utils/lit/tests/shtest-pushd-popd.py\n@@ -8,16 +8,16 @@\n # CHECK: -- Testing: 4 tests{{.*}}\n \n # CHECK: FAIL: shtest-pushd-popd :: popd-args.txt ({{[^)]*}})\n-# CHECK: $ \"popd\" \"invalid\"\n-# CHECK: 'popd' does not support arguments\n+# CHECK: popd invalid\n+# CHECK: # | 'popd' does not support arguments\n \n # CHECK: FAIL: shtest-pushd-popd :: popd-no-stack.txt ({{[^)]*}})\n-# CHECK: $ \"popd\"\n-# CHECK: popd: directory stack empty\n+# CHECK: popd\n+# CHECK: # | popd: directory stack empty\n \n # CHECK: FAIL: shtest-pushd-popd :: pushd-too-many-args.txt ({{[^)]*}})\n-# CHECK: $ \"pushd\" \"a\" \"b\"\n-# CHECK: 'pushd' supports only one argument\n+# CHECK: pushd a b\n+# CHECK: # | 'pushd' supports only one argument\n \n # CHECK: Passed:  1\n # CHECK: Failed:  3\ndiff --git a/llvm/utils/lit/tests/shtest-recursive-substitution.py b/llvm/utils/lit/tests/shtest-recursive-substitution.py\nindex 48f4b5b12491..65c177e65a3c 100644\n--- a/llvm/utils/lit/tests/shtest-recursive-substitution.py\n+++ b/llvm/utils/lit/tests/shtest-recursive-substitution.py\n@@ -3,7 +3,7 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/substitutes-within-limit --show-all | FileCheck --check-prefix=CHECK-TEST1 %s\n # CHECK-TEST1: PASS: substitutes-within-limit :: test.py\n-# CHECK-TEST1: $ \"echo\" \"STOP\"\n+# CHECK-TEST1: echo STOP\n \n # RUN: not %{lit} %{inputs}/shtest-recursive-substitution/does-not-substitute-within-limit --show-all | FileCheck --check-prefix=CHECK-TEST2 %s\n # CHECK-TEST2: UNRESOLVED: does-not-substitute-within-limit :: test.py\n@@ -11,7 +11,7 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/does-not-substitute-no-limit --show-all | FileCheck --check-prefix=CHECK-TEST3 %s\n # CHECK-TEST3: PASS: does-not-substitute-no-limit :: test.py\n-# CHECK-TEST3: $ \"echo\" \"%rec4\"\n+# CHECK-TEST3: echo %rec4\n \n # RUN: not %{lit} %{inputs}/shtest-recursive-substitution/not-an-integer --show-all 2>&1 | FileCheck --check-prefix=CHECK-TEST4 %s\n # CHECK-TEST4: recursiveExpansionLimit must be either None or an integer\n@@ -24,4 +24,4 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/escaping --show-all | FileCheck --check-prefix=CHECK-TEST7 %s\n # CHECK-TEST7: PASS: escaping :: test.py\n-# CHECK-TEST7: $ \"echo\" \"%s\" \"%s\" \"%%s\"\n+# CHECK-TEST7: echo %s %s %%s\ndiff --git a/llvm/utils/lit/tests/shtest-run-at-line.py b/llvm/utils/lit/tests/shtest-run-at-line.py\nindex 879cd64ebf6e..a0626f872c4c 100644\n--- a/llvm/utils/lit/tests/shtest-run-at-line.py\n+++ b/llvm/utils/lit/tests/shtest-run-at-line.py\n@@ -28,21 +28,28 @@\n # CHECK-LABEL: FAIL: shtest-run-at-line :: internal-shell/basic.txt\n \n # CHECK:      Command Output (stdout)\n-# CHECK:      $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \"true\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-# CHECK-NEXT: $ \"false\"\n+# CHECK-NEXT: --\n+# CHECK-NEXT: # RUN: at line 1\n+# CHECK-NEXT: true\n+# CHECK-NEXT: # executed command: true\n+# CHECK-NEXT: # RUN: at line 2\n+# CHECK-NEXT: false\n+# CHECK-NEXT: # executed command: false\n # CHECK-NOT:  RUN\n \n # CHECK-LABEL: FAIL: shtest-run-at-line :: internal-shell/line-continuation.txt\n \n # CHECK:      Command Output (stdout)\n-# CHECK:      $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \":\" \"first\" \"line\" \"continued\" \"to\" \"second\" \"line\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 3\"\n-# CHECK-NEXT: $ \"echo\" \"foo bar\"\n-# CHECK-NEXT: $ \"FileCheck\" \"{{.*}}\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 5\"\n-# CHECK-NEXT: $ \"echo\" \"foo baz\"\n-# CHECK-NEXT: $ \"FileCheck\" \"{{.*}}\"\n+# CHECK-NEXT: --\n+# CHECK-NEXT: # RUN: at line 1\n+# CHECK-NEXT: : first line continued to second line\n+# CHECK-NEXT: # executed command: : first line continued to second line\n+# CHECK-NEXT: # RUN: at line 3\n+# CHECK-NEXT: echo 'foo bar' | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: echo 'foo bar'\n+# CHECK-NEXT: # executed command: FileCheck {{.*}}\n+# CHECK-NEXT: # RUN: at line 5\n+# CHECK-NEXT: echo 'foo baz' | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: echo 'foo baz'\n+# CHECK-NEXT: # executed command: FileCheck {{.*}}\n # CHECK-NOT:  RUN\ndiff --git a/llvm/utils/lit/tests/shtest-shell.py b/llvm/utils/lit/tests/shtest-shell.py\nindex 93f05dbd35d0..8ce71296c144 100644\n--- a/llvm/utils/lit/tests/shtest-shell.py\n+++ b/llvm/utils/lit/tests/shtest-shell.py\n@@ -20,202 +20,212 @@\n \n # CHECK: FAIL: shtest-shell :: cat-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: cat-error-0.txt' FAILED ***\n-# CHECK: $ \"cat\" \"-b\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'cat':  option -b not recognized\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: cat -b temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'cat':  option -b not recognized\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: cat-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: cat-error-1.txt' FAILED ***\n-# CHECK: $ \"cat\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: [Errno 2] No such file or directory: 'temp1.txt'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: cat temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | [Errno 2] No such file or directory: 'temp1.txt'\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: colon-error.txt\n # CHECK: *** TEST 'shtest-shell :: colon-error.txt' FAILED ***\n-# CHECK: $ \":\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: ':' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: :\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: ':' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: PASS: shtest-shell :: continuations.txt\n \n # CHECK: PASS: shtest-shell :: dev-null.txt\n \n-# CHECK: FAIL: shtest-shell :: diff-b.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-b.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-b\" \"{{[^\"]*}}.0\" \"{{[^\"]*}}.1\"\n-# CHECK: # command output:\n-# CHECK: 1,2\n-# CHECK-NEXT: {{^  }}f o o\n-# CHECK-NEXT: ! b a r\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: {{^  }}f o o\n-# CHECK-NEXT: ! bar\n-# CHECK-EMPTY:\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-b.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-b.txt' FAILED ***\n+#      CHECK: diff -b {{[^\"]*}}.0 {{[^\"]*}}.1\n+#      CHECK: # .---command stdout{{-*}}\n+#      CHECK: # | {{.*}}1,2\n+# CHECK-NEXT: # |   f o o\n+# CHECK-NEXT: # | ! b a r\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # |   f o o\n+# CHECK-NEXT: # | ! bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+#      CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-encodings.txt\n # CHECK: *** TEST 'shtest-shell :: diff-encodings.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"diff-in.bin\"\n+#      CHECK: diff -u diff-in.bin diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.bin diff-in.bin\n+#  CHECK-NOT: error\n+\n+#      CHECK: diff -u diff-in.utf16 diff-in.bin && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf16 diff-in.bin\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.utf8 diff-in.bin && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf8 diff-in.bin\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | -baz\n+# CHECK-NEXT: # | {{\\+.f.o.o.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{\\+.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.bin diff-in.utf8 && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.bin diff-in.utf8\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{-.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.}}\n+# CHECK-NEXT: # | {{-.b.a.z.$}}\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # | +baz\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#     CHECK: cat diff-in.bin | diff -u - diff-in.bin\n # CHECK-NOT: error\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf16\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^ .f.o.o.$}}\n-# CHECK-NEXT: {{^-.b.a.r.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^ .b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf8\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: -baz\n-# CHECK-NEXT: {{^\\+.f.o.o.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^\\+.b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"diff-in.utf8\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^\\-.f.o.o.$}}\n-# CHECK-NEXT: {{^\\-.b.a.r.}}\n-# CHECK-NEXT: {{^\\-.b.a.z.$}}\n-# CHECK-NEXT: +foo\n-# CHECK-NEXT: +bar\n-# CHECK-NEXT: +baz\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"-\"\n-# CHECK-NOT: error\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf16\" \"-\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^ .f.o.o.$}}\n-# CHECK-NEXT: {{^-.b.a.r.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^ .b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n+#     CHECK: cat diff-in.bin | diff -u diff-in.bin -\n # CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf8\" \"-\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: -baz\n-# CHECK-NEXT: {{^\\+.f.o.o.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^\\+.b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"diff-in.utf8\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^\\-.f.o.o.$}}\n-# CHECK-NEXT: {{^\\-.b.a.r.}}\n-# CHECK-NEXT: {{^\\-.b.a.z.$}}\n-# CHECK-NEXT: +foo\n-# CHECK-NEXT: +bar\n-# CHECK-NEXT: +baz\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n \n-# CHECK: $ \"false\"\n+#      CHECK: cat diff-in.bin | diff -u diff-in.utf16 - && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf16 -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat diff-in.bin | diff -u diff-in.utf8 - && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf8 -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | -baz\n+# CHECK-NEXT: # | {{\\+.f.o.o.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{\\+.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat diff-in.bin | diff -u - diff-in.utf8 && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u - diff-in.utf8\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{-.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.}}\n+# CHECK-NEXT: # | {{-.b.a.z.$}}\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # | +baz\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-1.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-B\" \"temp1.txt\" \"temp2.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'diff': option -B not recognized\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -B temp1.txt temp2.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'diff': option -B not recognized\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-2.txt' FAILED ***\n-# CHECK: $ \"diff\" \"temp.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff temp.txt \n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-3.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-3.txt' FAILED ***\n-# CHECK: $ \"diff\" \"temp.txt\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'diff' command failed\n+# CHECK: diff temp.txt temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'diff' command failed\n # CHECK: error: command failed with exit status: 1\n # CHECK: ***\n \n-# CHECK: FAIL: shtest-shell :: diff-error-4.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-error-4.txt' FAILED ***\n-# CHECK: Exit Code: 1\n-# CHECK: # command output:\n-# CHECK: diff-error-4.txt.tmp\n-# CHECK: diff-error-4.txt.tmp1\n-# CHECK: *** 1 ****\n-# CHECK: ! hello-first\n-# CHECK: --- 1 ----\n-# CHECK: ! hello-second\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-error-4.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-error-4.txt' FAILED ***\n+#      CHECK: Exit Code: 1\n+#      CHECK: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | {{.*}}diff-error-4.txt.tmp\n+# CHECK-NEXT: # | {{.*}}diff-error-4.txt.tmp1\n+# CHECK-NEXT: # | {{\\*+}}\n+# CHECK-NEXT: # | *** 1 ****\n+# CHECK-NEXT: # | ! hello-first\n+# CHECK-NEXT: # | --- 1 ----\n+# CHECK-NEXT: # | ! hello-second\n+# CHECK-NEXT: # `---{{-*}}\n+#      CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-5.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-5.txt' FAILED ***\n-# CHECK: $ \"diff\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-6.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-6.txt' FAILED ***\n-# CHECK: $ \"diff\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n \n@@ -223,137 +233,130 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-pipes.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.foo\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"FileCheck\"\n+# CHECK: diff {{[^ ]*}}.foo {{.*}}.foo | FileCheck {{.*}}\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: note: command had no output on stdout or stderr\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"FileCheck\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"true\"\n+#      CHECK: diff -u {{.*}}.foo {{.*}}.bar | FileCheck {{.*}} && false || true\n+# CHECK-NEXT: # executed command: diff -u {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # note: command had no output on stdout or stderr\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: FileCheck\n+# CHECK-NEXT: # executed command: true\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"{{[^\"]*}}.foo\"\n+#     CHECK: cat {{.*}}.foo | diff -u - {{.*}}.foo\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n+#     CHECK: cat {{.*}}.foo | diff -u {{.*}}.foo -\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: +bar\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"{{[^\"]*}}.foo\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: +foo\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-\" \"{{[^\"]*}}.foo\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"FileCheck\"\n+#      CHECK: cat {{.*}}.bar | diff -u {{.*}}.foo - && false || true\n+# CHECK-NEXT: # executed command: cat {{.*}}.bar\n+# CHECK-NEXT: # executed command: diff -u {{.*}}.foo -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat {{.*}}.bar | diff -u - {{.*}}.foo && false || true\n+# CHECK-NEXT: # executed command: cat {{.*}}.bar\n+# CHECK-NEXT: # executed command: diff -u - {{.*}}.foo\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#     CHECK: cat {{.*}}.foo | diff - {{.*}}.foo | FileCheck {{.*}}\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n-# CHECK: note: command had no output on stdout or stderr\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"FileCheck\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"true\"\n+#      CHECK: cat {{.*}}.bar | diff -u {{.*}}.foo - | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: cat {{.*}}.bar\n+# CHECK-NEXT: # executed command: diff -u {{.*}}.foo -\n+# CHECK-NEXT: note: command had no output on stdout or stderr\n+# CHECK-NEXT: error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: FileCheck\n+# CHECK-NEXT: # executed command: true\n \n-# CHECK: $ \"false\"\n+# CHECK: false\n \n # CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-r-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-0.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: dir1unique\n-# CHECK: Only in {{.*}}dir2: dir2unique\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: dir1unique\n+# CHECK: # | Only in {{.*}}dir2: dir2unique\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-1.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: *** {{.*}}dir1{{.*}}subdir{{.*}}f01\n-# CHECK: --- {{.*}}dir2{{.*}}subdir{{.*}}f01\n-# CHECK: 12345\n-# CHECK: 00000\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | *** {{.*}}dir1{{.*}}subdir{{.*}}f01\n+# CHECK: # | --- {{.*}}dir2{{.*}}subdir{{.*}}f01\n+# CHECK: # | ! 12345\n+# CHECK: # | ! 00000\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-2.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir2: extrafile\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir2: extrafile\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-3.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-3.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: extra_subdir\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: extra_subdir\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-4.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-4.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: File {{.*}}dir1{{.*}}extra_subdir is a directory while file {{.*}}dir2{{.*}}extra_subdir is a regular file\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | File {{.*}}dir1{{.*}}extra_subdir is a directory while file {{.*}}dir2{{.*}}extra_subdir is a regular file\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-5.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-5.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: extra_subdir\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: extra_subdir\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-6.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-6.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: File {{.*}}dir1{{.*}}extra_file is a regular empty file while file {{.*}}dir2{{.*}}extra_file is a directory\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | File {{.*}}dir1{{.*}}extra_file is a regular empty file while file {{.*}}dir2{{.*}}extra_file is a directory\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-7.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-7.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\" \"-\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: cannot recursively compare '-'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r - {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: cannot recursively compare '-'\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-8.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-8.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\" \"{{[^\"]*}}\" \"-\"\n-# CHECK: # command stderr:\n-# CHECK: Error: cannot recursively compare '-'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r {{.*}} -\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: cannot recursively compare '-'\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: PASS: shtest-shell :: diff-r.txt\n \n@@ -362,51 +365,59 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-strip-trailing-cr.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.dos\" \"diff-in.unix\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -In this file, the\n-# CHECK-NEXT: -sequence \"\\r\\n\"\n-# CHECK-NEXT: -terminates lines.\n-# CHECK-NEXT: +In this file, the\n-# CHECK-NEXT: +sequence \"\\n\"\n-# CHECK-NEXT: +terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.unix\" \"diff-in.dos\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -In this file, the\n-# CHECK-NEXT: -sequence \"\\n\"\n-# CHECK-NEXT: -terminates lines.\n-# CHECK-NEXT: +In this file, the\n-# CHECK-NEXT: +sequence \"\\r\\n\"\n-# CHECK-NEXT: +terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"--strip-trailing-cr\" \"diff-in.dos\" \"diff-in.unix\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT:  In this file, the\n-# CHECK-NEXT: -sequence \"\\r\\n\"\n-# CHECK-NEXT: +sequence \"\\n\"\n-# CHECK-NEXT:  terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"--strip-trailing-cr\" \"diff-in.unix\" \"diff-in.dos\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT:  In this file, the\n-# CHECK-NEXT: -sequence \"\\n\"\n-# CHECK-NEXT: +sequence \"\\r\\n\"\n-# CHECK-NEXT:  terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"false\"\n+#      CHECK: diff -u diff-in.dos diff-in.unix && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.dos diff-in.unix\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -In this file, the\n+# CHECK-NEXT: # | -sequence \"\\r\\n\"\n+# CHECK-NEXT: # | -terminates lines.\n+# CHECK-NEXT: # | +In this file, the\n+# CHECK-NEXT: # | +sequence \"\\n\"\n+# CHECK-NEXT: # | +terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.unix diff-in.dos && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.unix diff-in.dos\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -In this file, the\n+# CHECK-NEXT: # | -sequence \"\\n\"\n+# CHECK-NEXT: # | -terminates lines.\n+# CHECK-NEXT: # | +In this file, the\n+# CHECK-NEXT: # | +sequence \"\\r\\n\"\n+# CHECK-NEXT: # | +terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u --strip-trailing-cr diff-in.dos diff-in.unix && false || true\n+# CHECK-NEXT: executed command: diff -u --strip-trailing-cr diff-in.dos diff-in.unix\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # |  In this file, the\n+# CHECK-NEXT: # | -sequence \"\\r\\n\"\n+# CHECK-NEXT: # | +sequence \"\\n\"\n+# CHECK-NEXT: # |  terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u --strip-trailing-cr diff-in.unix diff-in.dos && false || true\n+# CHECK-NEXT: # executed command: diff -u --strip-trailing-cr diff-in.unix diff-in.dos\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # |  In this file, the\n+# CHECK-NEXT: # | -sequence \"\\n\"\n+# CHECK-NEXT: # | +sequence \"\\r\\n\"\n+# CHECK-NEXT: # |  terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n@@ -415,106 +426,144 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-unified.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 3\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-NEXT: 9\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U\" \"2\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U4\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 2\n-# CHECK-NEXT: 3\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-NEXT: 9\n-# CHECK-NEXT: 10\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U0\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U\" \"30.1\" \"{{[^\"]*}}\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: invalid '-U' argument: 30.1\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U-1\" \"{{[^\"]*}}\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: invalid '-U' argument: -1\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"false\"\n+#      CHECK: diff -u {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -u {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 3\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # | 9\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U 2 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U 2 {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U4 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U4 {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 2\n+# CHECK-NEXT: # | 3\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # | 9\n+# CHECK-NEXT: # | 10\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U0 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: diff -U0 {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: diff -U 30.1 {{.*}} {{.*}} && false || true\n+# CHECK: # executed command: diff -U 30.1 {{.*}} {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: invalid '-U' argument: 30.1\n+# CHECK: # error: command failed with exit status: 1\n+# CHECK: # executed command: true\n+\n+# CHECK: diff -U-1 {{.*}} {{.*}} && false || true\n+# CHECK: # executed command: diff -U-1 {{.*}} {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: invalid '-U' argument: -1\n+# CHECK: # error: command failed with exit status: 1\n+# CHECK: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n \n-# CHECK: FAIL: shtest-shell :: diff-w.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-w.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-w\" \"{{[^\"]*}}.0\" \"{{[^\"]*}}.1\"\n-# CHECK: # command output:\n-# CHECK: 1,3\n-# CHECK-NEXT: {{^  }}foo\n-# CHECK-NEXT: {{^  }}bar\n-# CHECK-NEXT: ! baz\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: {{^  }}foo\n-# CHECK-NEXT: {{^  }}bar\n-# CHECK-NEXT: ! bat\n-# CHECK-EMPTY:\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-w.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-w.txt' FAILED ***\n+#      CHECK: diff -w {{.*}}.0 {{.*}}.1\n+#      CHECK: # .---command stdout{{-*}}\n+#      CHECK: # | {{\\*+}} 1,3\n+# CHECK-NEXT: # |   foo\n+# CHECK-NEXT: # |   bar\n+# CHECK-NEXT: # | ! baz\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # |   foo\n+# CHECK-NEXT: # |   bar\n+# CHECK-NEXT: # | ! bat\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+#      CHECK: ***\n+\n+# CHECK: FAIL: shtest-shell :: echo-at-redirect-stderr.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-at-redirect-stderr.txt' FAILED ***\n+# CHECK: @echo 2> {{.*}}\n+# CHECK: # executed command: @echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for @echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-at-redirect-stdin.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-at-redirect-stdin.txt' FAILED ***\n+# CHECK: @echo < {{.*}}\n+# CHECK: # executed command: @echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for @echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-redirect-stderr.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-redirect-stderr.txt' FAILED ***\n+# CHECK: echo 2> {{.*}}\n+# CHECK: # executed command: echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-redirect-stdin.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-redirect-stdin.txt' FAILED ***\n+# CHECK: echo < {{.*}}\n+# CHECK: # executed command: echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for echo\n+# CHECK: error: command failed with exit status:\n \n # CHECK: FAIL: shtest-shell :: error-0.txt\n # CHECK: *** TEST 'shtest-shell :: error-0.txt' FAILED ***\n-# CHECK: $ \"not-a-real-command\"\n-# CHECK: # command stderr:\n-# CHECK: 'not-a-real-command': command not found\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: not-a-real-command\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | 'not-a-real-command': command not found\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # FIXME: The output here sucks.\n #\n # CHECK: FAIL: shtest-shell :: error-1.txt\n # CHECK: *** TEST 'shtest-shell :: error-1.txt' FAILED ***\n-# CHECK: shell parser error on: ': \\'RUN: at line 3\\'; echo \"missing quote'\n+# CHECK: shell parser error on RUN: at line 3: echo \"missing quote\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: error-2.txt\n@@ -524,52 +573,52 @@\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-0.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'mkdir' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p temp | rm -rf temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'mkdir' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-1.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\" \"-m\" \"777\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'mkdir': option -m not recognized\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p -m 777 temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'mkdir': option -m not recognized\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-2.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'mkdir' is missing an operand\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'mkdir' is missing an operand\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: PASS: shtest-shell :: redirects.txt\n \n # CHECK: FAIL: shtest-shell :: rm-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-0.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-rf\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'rm' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: rm -rf temp | echo \"hello\"\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'rm' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-1.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-f\" \"-v\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'rm': option -v not recognized\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: rm -f -v temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'rm': option -v not recognized\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-2.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-r\" \"hello\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'rm' command failed\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: rm -r hello\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'rm' command failed\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-3.txt\n@@ -581,16 +630,17 @@\n # CHECK: PASS: shtest-shell :: sequencing-0.txt\n # CHECK: XFAIL: shtest-shell :: sequencing-1.txt\n \n-# CHECK: FAIL: shtest-shell :: stdout-encoding.txt\n-# CHECK: *** TEST 'shtest-shell :: stdout-encoding.txt' FAILED ***\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: {{^.f.o.o.$}}\n-# CHECK-NEXT: {{^.b.a.r.}}\n-# CHECK-NEXT: {{^.b.a.z.$}}\n-# CHECK-NOT: error\n-# CHECK: $ \"false\"\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: stdout-encoding.txt\n+#      CHECK: *** TEST 'shtest-shell :: stdout-encoding.txt' FAILED ***\n+#      CHECK: cat diff-in.bin\n+#      CHECK: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+#  CHECK-NOT: error\n+#      CHECK: false\n+#      CHECK: ***\n \n # CHECK: PASS: shtest-shell :: valid-shell.txt\n-# CHECK: Failed Tests (35)\n+# CHECK: Failed Tests (39)\n", "message": "", "files": {"/libcxx/utils/libcxx/test/dsl.py": {"changes": [{"diff": "\n                 \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n             )\n \n-        return libcxx.test.format._parseLitOutput(out)\n+        return out\n \n \n @_memoizeExpensiveOperation(", "add": 1, "remove": 1, "filename": "/libcxx/utils/libcxx/test/dsl.py", "badparts": ["        return libcxx.test.format._parseLitOutput(out)"], "goodparts": ["        return out"]}], "source": "\n import os import pickle import pipes import platform import re import shutil import subprocess import tempfile import libcxx.test.format import lit import lit.LitConfig import lit.Test import lit.TestRunner import lit.util class ConfigurationError(Exception): pass class ConfigurationCompilationError(ConfigurationError): pass class ConfigurationRuntimeError(ConfigurationError): pass def _memoizeExpensiveOperation(extractCacheKey): \"\"\" Allows memoizing a very expensive operation. We pickle the cache key to make sure we store an immutable representation of it. If we stored an object and the object was referenced elsewhere, it could be changed from under our feet, which would break the cache. We also store the cache for a given function persistently across invocations of Lit. This dramatically speeds up the configuration of the test suite when invoking Lit repeatedly, which is important for developer workflow. However, with the current implementation that does not synchronize updates to the persistent cache, this also means that one should not call a memoized operation from multiple threads. This should normally not be a problem since Lit configuration is single-threaded. \"\"\" def decorator(function): def f(config, *args, **kwargs): cacheRoot=os.path.join(config.test_exec_root, \"__config_cache__\") persistentCache=os.path.join(cacheRoot, function.__name__) if not os.path.exists(cacheRoot): os.makedirs(cacheRoot) cache={} if os.path.exists(persistentCache): with open(persistentCache, \"rb\") as cacheFile: cache=pickle.load(cacheFile) cacheKey=pickle.dumps(extractCacheKey(config, *args, **kwargs)) if cacheKey not in cache: cache[cacheKey]=function(config, *args, **kwargs) with open(persistentCache, \"wb\") as cacheFile: pickle.dump(cache, cacheFile) return cache[cacheKey] return f return decorator def _executeWithFakeConfig(test, commands): \"\"\" Returns(stdout, stderr, exitCode, timeoutInfo, parsedCommands) \"\"\" litConfig=lit.LitConfig.LitConfig( progname=\"lit\", path=[], quiet=False, useValgrind=False, valgrindLeakCheck=False, valgrindArgs=[], noExecute=False, debug=False, isWindows=platform.system()==\"Windows\", order=\"smart\", params={}, ) return libcxx.test.format._executeScriptInternal(test, litConfig, commands) def _makeConfigTest(config): sourceRoot=os.path.join(config.test_exec_root, \"__config_src__\") execRoot=os.path.join(config.test_exec_root, \"__config_exec__\") for supportDir in(sourceRoot, execRoot): if not os.path.exists(supportDir): os.makedirs(supportDir) suite=lit.Test.TestSuite(\"__config__\", sourceRoot, execRoot, config) tmp=tempfile.NamedTemporaryFile(dir=sourceRoot, delete=False, suffix=\".cpp\") tmp.close() pathInSuite=[os.path.relpath(tmp.name, sourceRoot)] class TestWrapper(lit.Test.Test): def __enter__(self): testDir, _=libcxx.test.format._getTempPaths(self) os.makedirs(testDir) return self def __exit__(self, *args): testDir, _=libcxx.test.format._getTempPaths(self) shutil.rmtree(testDir) os.remove(tmp.name) return TestWrapper(suite, pathInSuite, config) @_memoizeExpensiveOperation(lambda c, s, f=[]:(c.substitutions, c.environment, s, f)) def sourceBuilds(config, source, additionalFlags=[]): \"\"\" Return whether the program in the given string builds successfully. This is done by compiling and linking a program that consists of the given source with the %{cxx} substitution, and seeing whether that succeeds. If any additional flags are passed, they are appended to the compiler invocation. \"\"\" with _makeConfigTest(config) as test: with open(test.getSourcePath(), \"w\") as sourceFile: sourceFile.write(source) _, _, exitCode, _, _=_executeWithFakeConfig( test,[\"%{{build}}{}\".format(\" \".join(additionalFlags))] ) return exitCode==0 @_memoizeExpensiveOperation( lambda c, p, args=None:(c.substitutions, c.environment, p, args) ) def programOutput(config, program, args=None): \"\"\" Compiles a program for the test target, run it on the test target and return the output. Note that execution of the program is done through the %{exec} substitution, which means that the program may be run on a remote host depending on what %{exec} does. \"\"\" if args is None: args=[] with _makeConfigTest(config) as test: with open(test.getSourcePath(), \"w\") as source: source.write(program) _, err, exitCode, _, buildcmd=_executeWithFakeConfig(test,[\"%{build}\"]) if exitCode !=0: raise ConfigurationCompilationError( \"Failed to build program, cmd:\\n{}\\nstderr is:\\n{}\".format( buildcmd, err ) ) out, err, exitCode, _, runcmd=_executeWithFakeConfig( test,[\"%{{run}}{}\".format(\" \".join(args))] ) if exitCode !=0: raise ConfigurationRuntimeError( \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err) ) return libcxx.test.format._parseLitOutput(out) @_memoizeExpensiveOperation( lambda c, p, args=None:(c.substitutions, c.environment, p, args) ) def programSucceeds(config, program, args=None): \"\"\" Compiles a program for the test target, run it on the test target and return whether it completed successfully. Note that execution of the program is done through the %{exec} substitution, which means that the program may be run on a remote host depending on what %{exec} does. \"\"\" try: programOutput(config, program, args) except ConfigurationRuntimeError: return False return True @_memoizeExpensiveOperation(lambda c, f:(c.substitutions, c.environment, f)) def hasCompileFlag(config, flag): \"\"\" Return whether the compiler in the configuration supports a given compiler flag. This is done by executing the %{cxx} substitution with the given flag and checking whether that succeeds. \"\"\" with _makeConfigTest(config) as test: out, err, exitCode, timeoutInfo, _=_executeWithFakeConfig( test, [ \"%{{cxx}} -xc++{} -Werror -fsyntax-only %{{flags}} %{{compile_flags}}{}\".format( os.devnull, flag ) ], ) return exitCode==0 @_memoizeExpensiveOperation(lambda c, s:(c.substitutions, c.environment, s)) def runScriptExitCode(config, script): \"\"\" Runs the given script as a Lit test, and returns the exit code of the execution. The script must be a list of commands, each of which being something that could appear on the right-hand-side of a `RUN:` keyword. \"\"\" with _makeConfigTest(config) as test: _, _, exitCode, _, _=_executeWithFakeConfig(test, script) return exitCode @_memoizeExpensiveOperation(lambda c, s:(c.substitutions, c.environment, s)) def commandOutput(config, command): \"\"\" Runs the given script as a Lit test, and returns the output. If the exit code isn't 0 an exception is raised. The script must be a list of commands, each of which being something that could appear on the right-hand-side of a `RUN:` keyword. \"\"\" with _makeConfigTest(config) as test: out, err, exitCode, _, cmd=_executeWithFakeConfig(test, command) if exitCode !=0: raise ConfigurationRuntimeError( \"Failed to run command:{}\\nstderr is:\\n{}\".format(cmd, err) ) return out @_memoizeExpensiveOperation(lambda c, l:(c.substitutions, c.environment, l)) def hasAnyLocale(config, locales): \"\"\" Return whether the runtime execution environment supports a given locale. Different systems may use different names for a locale, so this function checks whether any of the passed locale names is supported by setlocale() and returns true if one of them works. This is done by executing a program that tries to set the given locale using %{exec} --this means that the command may be executed on a remote host depending on the %{exec} substitution. \"\"\" program=\"\"\" int main(int, char**){ return 1;} int main(int argc, char** argv){ for(int i=1; i < argc; i++){ if(::setlocale(LC_ALL, argv[i]) !=NULL){ return 0; } } return 1; } \"\"\" return programSucceeds(config, program, args=[pipes.quote(l) for l in locales]) @_memoizeExpensiveOperation(lambda c, flags=\"\":(c.substitutions, c.environment, flags)) def compilerMacros(config, flags=\"\"): \"\"\" Return a dictionary of predefined compiler macros. The keys are strings representing macros, and the values are strings representing what each macro is defined to. If the optional `flags` argument(a string) is provided, these flags will be added to the compiler invocation when generating the macros. \"\"\" with _makeConfigTest(config) as test: with open(test.getSourcePath(), \"w\") as sourceFile: sourceFile.write( \"\"\" \"\"\" ) unparsedOutput, err, exitCode, _, cmd=_executeWithFakeConfig( test,[\"%{{cxx}} %s -dM -E %{{flags}} %{{compile_flags}}{}\".format(flags)] ) if exitCode !=0: raise ConfigurationCompilationError( \"Failed to retrieve compiler macros, compiler invocation is:\\n{}\\nstderr is:\\n{}\".format( cmd, err ) ) parsedMacros=dict() defines=( l.strip() for l in unparsedOutput.split(\"\\n\") if l.startswith(\" ) for line in defines: line=line[len(\" macro, _, value=line.partition(\" \") parsedMacros[macro]=value return parsedMacros def featureTestMacros(config, flags=\"\"): \"\"\" Return a dictionary of feature test macros. The keys are strings representing feature test macros, and the values are integers representing the value of the macro. \"\"\" allMacros=compilerMacros(config, flags) return{ m: int(v.rstrip(\"LlUu\")) for(m, v) in allMacros.items() if m.startswith(\"__cpp_\") } def _getSubstitution(substitution, config): for(orig, replacement) in config.substitutions: if orig==substitution: return replacement raise ValueError('Substitution{} is not in the config.'.format(substitution)) def _appendToSubstitution(substitutions, key, value): return[(k, v +\" \" +value) if k==key else(k, v) for(k, v) in substitutions] def _prependToSubstitution(substitutions, key, value): return[(k, value +\" \" +v) if k==key else(k, v) for(k, v) in substitutions] class ConfigAction(object): \"\"\" This class represents an action that can be performed on a Lit TestingConfig object. Examples of such actions are adding or modifying substitutions, Lit features, etc. This class only provides the interface of such actions, and it is meant to be subclassed appropriately to create new actions. \"\"\" def applyTo(self, config): \"\"\" Applies the action to the given configuration. This should modify the configuration object in place, and return nothing. If applying the action to the configuration would yield an invalid configuration, and it is possible to diagnose it here, this method should produce an error. For example, it should be an error to modify a substitution in a way that we know for sure is invalid(e.g. adding a compiler flag when we know the compiler doesn't support it). Failure to do so early may lead to difficult-to-diagnose issues down the road. \"\"\" pass def pretty(self, config, litParams): \"\"\" Returns a short and human-readable string describing what this action does. This is used for logging purposes when running the test suite, so it should be kept concise. \"\"\" pass class AddFeature(ConfigAction): \"\"\" This action defines the given Lit feature when running the test suite. The name of the feature can be a string or a callable, in which case it is called with the configuration to produce the feature name(as a string). \"\"\" def __init__(self, name): self._name=name def _getName(self, config): name=self._name(config) if callable(self._name) else self._name if not isinstance(name, str): raise ValueError( \"Lit feature did not resolve to a string(got{})\".format(name) ) return name def applyTo(self, config): config.available_features.add(self._getName(config)) def pretty(self, config, litParams): return \"add Lit feature{}\".format(self._getName(config)) class AddFlag(ConfigAction): \"\"\" This action adds the given flag to the %{flags} substitution. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) assert hasCompileFlag( config, flag ), \"Trying to enable flag{}, which is not supported\".format(flag) config.substitutions=_appendToSubstitution( config.substitutions, \"%{flags}\", flag ) def pretty(self, config, litParams): return \"add{} to %{{flags}}\".format(self._getFlag(config)) class AddFlagIfSupported(ConfigAction): \"\"\" This action adds the given flag to the %{flags} substitution, only if the compiler supports the flag. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) if hasCompileFlag(config, flag): config.substitutions=_appendToSubstitution( config.substitutions, \"%{flags}\", flag ) def pretty(self, config, litParams): return \"add{} to %{{flags}}\".format(self._getFlag(config)) class AddCompileFlag(ConfigAction): \"\"\" This action adds the given flag to the %{compile_flags} substitution. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) assert hasCompileFlag( config, flag ), \"Trying to enable compile flag{}, which is not supported\".format(flag) config.substitutions=_appendToSubstitution( config.substitutions, \"%{compile_flags}\", flag ) def pretty(self, config, litParams): return \"add{} to %{{compile_flags}}\".format(self._getFlag(config)) class AddLinkFlag(ConfigAction): \"\"\" This action appends the given flag to the %{link_flags} substitution. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) assert hasCompileFlag( config, flag ), \"Trying to enable link flag{}, which is not supported\".format(flag) config.substitutions=_appendToSubstitution( config.substitutions, \"%{link_flags}\", flag ) def pretty(self, config, litParams): return \"append{} to %{{link_flags}}\".format(self._getFlag(config)) class PrependLinkFlag(ConfigAction): \"\"\" This action prepends the given flag to the %{link_flags} substitution. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) assert hasCompileFlag( config, flag ), \"Trying to enable link flag{}, which is not supported\".format(flag) config.substitutions=_prependToSubstitution( config.substitutions, \"%{link_flags}\", flag ) def pretty(self, config, litParams): return \"prepend{} to %{{link_flags}}\".format(self._getFlag(config)) class AddOptionalWarningFlag(ConfigAction): \"\"\" This action adds the given warning flag to the %{compile_flags} substitution, if it is supported by the compiler. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) if hasCompileFlag(config, \"-Werror \" +flag): config.substitutions=_appendToSubstitution( config.substitutions, \"%{compile_flags}\", flag ) def pretty(self, config, litParams): return \"add{} to %{{compile_flags}}\".format(self._getFlag(config)) class AddSubstitution(ConfigAction): \"\"\" This action adds the given substitution to the Lit configuration. The substitution can be a string or a callable, in which case it is called with the configuration to produce the actual substitution(as a string). \"\"\" def __init__(self, key, substitution): self._key=key self._getSub=( lambda config: substitution(config) if callable(substitution) else substitution ) def applyTo(self, config): key=self._key sub=self._getSub(config) config.substitutions.append((key, sub)) def pretty(self, config, litParams): return \"add substitution{}={}\".format(self._key, self._getSub(config)) class Feature(object): \"\"\" Represents a Lit available feature that is enabled whenever it is supported. A feature like this informs the test suite about a capability of the compiler, platform, etc. Unlike Parameters, it does not make sense to explicitly control whether a Feature is enabled --it should be enabled whenever it is supported. \"\"\" def __init__(self, name, actions=None, when=lambda _: True): \"\"\" Create a Lit feature for consumption by a test suite. -name The name of the feature. This is what will end up in Lit's available features if the feature is enabled. This can be either a string or a callable, in which case it is passed the TestingConfig and should generate a string representing the name of the feature. -actions An optional list of ConfigActions to apply when the feature is supported. An AddFeature action is always created regardless of any actions supplied here --these actions are meant to perform more than setting a corresponding Lit feature(e.g. adding compiler flags). If 'actions' is a callable, it is called with the current configuration object to generate the actual list of actions. -when A callable that gets passed a TestingConfig and should return a boolean representing whether the feature is supported in that configuration. For example, this can use `hasCompileFlag` to check whether the compiler supports the flag that the feature represents. If omitted, the feature will always be considered supported. \"\"\" self._name=name self._actions=[] if actions is None else actions self._isSupported=when def _getName(self, config): name=self._name(config) if callable(self._name) else self._name if not isinstance(name, str): raise ValueError( \"Feature did not resolve to a name that's a string, got{}\".format(name) ) return name def getActions(self, config): \"\"\" Return the list of actions associated to this feature. If the feature is not supported, an empty list is returned. If the feature is supported, an `AddFeature` action is automatically added to the returned list of actions, in addition to any actions provided on construction. \"\"\" if not self._isSupported(config): return[] else: actions=( self._actions(config) if callable(self._actions) else self._actions ) return[AddFeature(self._getName(config))] +actions def pretty(self, config): \"\"\" Returns the Feature's name. \"\"\" return self._getName(config) def _str_to_bool(s): \"\"\" Convert a string value to a boolean. True values are \"y\", \"yes\", \"t\", \"true\", \"on\" and \"1\", regardless of capitalization. False values are \"n\", \"no\", \"f\", \"false\", \"off\" and \"0\", regardless of capitalization. \"\"\" trueVals=[\"y\", \"yes\", \"t\", \"true\", \"on\", \"1\"] falseVals=[\"n\", \"no\", \"f\", \"false\", \"off\", \"0\"] lower=s.lower() if lower in trueVals: return True elif lower in falseVals: return False else: raise ValueError(\"Got string '{}', which isn't a valid boolean\".format(s)) def _parse_parameter(s, type): if type is bool and isinstance(s, str): return _str_to_bool(s) elif type is list and isinstance(s, str): return[x.strip() for x in s.split(\",\") if x.strip()] return type(s) class Parameter(object): \"\"\" Represents a parameter of a Lit test suite. Parameters are used to customize the behavior of test suites in a user controllable way. There are two ways of setting the value of a Parameter. The first one is to pass `--param <KEY>=<VALUE>` when running Lit(or equivalently to set `litConfig.params[KEY]=VALUE` somewhere in the Lit configuration files. This method will set the parameter globally for all test suites being run. The second method is to set `config.KEY=VALUE` somewhere in the Lit configuration files, which sets the parameter only for the test suite(s) that use that `config` object. Parameters can have multiple possible values, and they can have a default value when left unspecified. They can also have any number of ConfigActions associated to them, in which case the actions will be performed on the TestingConfig if the parameter is enabled. Depending on the actions associated to a Parameter, it may be an error to enable the Parameter if some actions are not supported in the given configuration. For example, trying to set the compilation standard to C++23 when `-std=c++23` is not supported by the compiler would be an error. \"\"\" def __init__(self, name, type, help, actions, choices=None, default=None): \"\"\" Create a Lit parameter to customize the behavior of a test suite. -name The name of the parameter that can be used to set it on the command-line. On the command-line, the parameter can be set using `--param <name>=<value>` when running Lit. This must be non-empty. -choices An optional non-empty set of possible values for this parameter. If provided, this must be anything that can be iterated. It is an error if the parameter is given a value that is not in that set, whether explicitly or through a default value. -type A callable that can be used to parse the value of the parameter given on the command-line. As a special case, using the type `bool` also allows parsing strings with boolean-like contents, and the type `list` will parse a string delimited by commas into a list of the substrings. -help A string explaining the parameter, for documentation purposes. TODO: We should be able to surface those from the Lit command-line. -actions A callable that gets passed the parsed value of the parameter(either the one passed on the command-line or the default one), and that returns a list of ConfigAction to perform given the value of the parameter. All the ConfigAction must be supported in the given configuration. -default An optional default value to use for the parameter when no value is provided on the command-line. If the default value is a callable, it is called with the TestingConfig and should return the default value for the parameter. Whether the default value is computed or specified directly, it must be in the 'choices' provided for that Parameter. \"\"\" self._name=name if len(self._name)==0: raise ValueError(\"Parameter name must not be the empty string\") if choices is not None: self._choices=list(choices) if len(self._choices)==0: raise ValueError( \"Parameter '{}' must be given at least one possible value\".format( self._name ) ) else: self._choices=None self._parse=lambda x: _parse_parameter(x, type) self._help=help self._actions=actions self._default=default def _getValue(self, config, litParams): \"\"\" Return the value of the parameter given the configuration objects. \"\"\" param=getattr(config, self.name, None) param=litParams.get(self.name, param) if param is None and self._default is None: raise ValueError( \"Parameter{} doesn't have a default value, but it was not specified in the Lit parameters or in the Lit config\".format( self.name ) ) getDefault=( lambda: self._default(config) if callable(self._default) else self._default ) if param is not None: (pretty, value)=(param, self._parse(param)) else: value=getDefault() pretty=\"{}(default)\".format(value) if self._choices and value not in self._choices: raise ValueError( \"Got value '{}' for parameter '{}', which is not in the provided set of possible choices:{}\".format( value, self.name, self._choices ) ) return(pretty, value) @property def name(self): \"\"\" Return the name of the parameter. This is the name that can be used to set the parameter on the command-line when running Lit. \"\"\" return self._name def getActions(self, config, litParams): \"\"\" Return the list of actions associated to this value of the parameter. \"\"\" (_, parameterValue)=self._getValue(config, litParams) return self._actions(parameterValue) def pretty(self, config, litParams): \"\"\" Return a pretty representation of the parameter's name and value. \"\"\" (prettyParameterValue, _)=self._getValue(config, litParams) return \"{}={}\".format(self.name, prettyParameterValue) ", "sourceWithComments": "# ===----------------------------------------------------------------------===##\n#\n# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n# See https://llvm.org/LICENSE.txt for license information.\n# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n#\n# ===----------------------------------------------------------------------===##\n\nimport os\nimport pickle\nimport pipes\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport tempfile\n\nimport libcxx.test.format\nimport lit\nimport lit.LitConfig\nimport lit.Test\nimport lit.TestRunner\nimport lit.util\n\n\nclass ConfigurationError(Exception):\n    pass\n\n\nclass ConfigurationCompilationError(ConfigurationError):\n    pass\n\n\nclass ConfigurationRuntimeError(ConfigurationError):\n    pass\n\n\ndef _memoizeExpensiveOperation(extractCacheKey):\n    \"\"\"\n    Allows memoizing a very expensive operation.\n\n    We pickle the cache key to make sure we store an immutable representation\n    of it. If we stored an object and the object was referenced elsewhere, it\n    could be changed from under our feet, which would break the cache.\n\n    We also store the cache for a given function persistently across invocations\n    of Lit. This dramatically speeds up the configuration of the test suite when\n    invoking Lit repeatedly, which is important for developer workflow. However,\n    with the current implementation that does not synchronize updates to the\n    persistent cache, this also means that one should not call a memoized\n    operation from multiple threads. This should normally not be a problem\n    since Lit configuration is single-threaded.\n    \"\"\"\n\n    def decorator(function):\n        def f(config, *args, **kwargs):\n            cacheRoot = os.path.join(config.test_exec_root, \"__config_cache__\")\n            persistentCache = os.path.join(cacheRoot, function.__name__)\n            if not os.path.exists(cacheRoot):\n                os.makedirs(cacheRoot)\n\n            cache = {}\n            # Load a cache from a previous Lit invocation if there is one.\n            if os.path.exists(persistentCache):\n                with open(persistentCache, \"rb\") as cacheFile:\n                    cache = pickle.load(cacheFile)\n\n            cacheKey = pickle.dumps(extractCacheKey(config, *args, **kwargs))\n            if cacheKey not in cache:\n                cache[cacheKey] = function(config, *args, **kwargs)\n                # Update the persistent cache so it knows about the new key\n                with open(persistentCache, \"wb\") as cacheFile:\n                    pickle.dump(cache, cacheFile)\n            return cache[cacheKey]\n\n        return f\n\n    return decorator\n\n\ndef _executeWithFakeConfig(test, commands):\n    \"\"\"\n    Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n    \"\"\"\n    litConfig = lit.LitConfig.LitConfig(\n        progname=\"lit\",\n        path=[],\n        quiet=False,\n        useValgrind=False,\n        valgrindLeakCheck=False,\n        valgrindArgs=[],\n        noExecute=False,\n        debug=False,\n        isWindows=platform.system() == \"Windows\",\n        order=\"smart\",\n        params={},\n    )\n    return libcxx.test.format._executeScriptInternal(test, litConfig, commands)\n\n\ndef _makeConfigTest(config):\n    # Make sure the support directories exist, which is needed to create\n    # the temporary file %t below.\n    sourceRoot = os.path.join(config.test_exec_root, \"__config_src__\")\n    execRoot = os.path.join(config.test_exec_root, \"__config_exec__\")\n    for supportDir in (sourceRoot, execRoot):\n        if not os.path.exists(supportDir):\n            os.makedirs(supportDir)\n\n    # Create a dummy test suite and single dummy test inside it. As part of\n    # the Lit configuration, automatically do the equivalent of 'mkdir %T'\n    # and 'rm -r %T' to avoid cluttering the build directory.\n    suite = lit.Test.TestSuite(\"__config__\", sourceRoot, execRoot, config)\n    tmp = tempfile.NamedTemporaryFile(dir=sourceRoot, delete=False, suffix=\".cpp\")\n    tmp.close()\n    pathInSuite = [os.path.relpath(tmp.name, sourceRoot)]\n\n    class TestWrapper(lit.Test.Test):\n        def __enter__(self):\n            testDir, _ = libcxx.test.format._getTempPaths(self)\n            os.makedirs(testDir)\n            return self\n\n        def __exit__(self, *args):\n            testDir, _ = libcxx.test.format._getTempPaths(self)\n            shutil.rmtree(testDir)\n            os.remove(tmp.name)\n\n    return TestWrapper(suite, pathInSuite, config)\n\n\n@_memoizeExpensiveOperation(lambda c, s, f=[]: (c.substitutions, c.environment, s, f))\ndef sourceBuilds(config, source, additionalFlags=[]):\n    \"\"\"\n    Return whether the program in the given string builds successfully.\n\n    This is done by compiling and linking a program that consists of the given\n    source with the %{cxx} substitution, and seeing whether that succeeds. If\n    any additional flags are passed, they are appended to the compiler invocation.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        with open(test.getSourcePath(), \"w\") as sourceFile:\n            sourceFile.write(source)\n        _, _, exitCode, _, _ = _executeWithFakeConfig(\n            test, [\"%{{build}} {}\".format(\" \".join(additionalFlags))]\n        )\n        return exitCode == 0\n\n\n@_memoizeExpensiveOperation(\n    lambda c, p, args=None: (c.substitutions, c.environment, p, args)\n)\ndef programOutput(config, program, args=None):\n    \"\"\"\n    Compiles a program for the test target, run it on the test target and return\n    the output.\n\n    Note that execution of the program is done through the %{exec} substitution,\n    which means that the program may be run on a remote host depending on what\n    %{exec} does.\n    \"\"\"\n    if args is None:\n        args = []\n    with _makeConfigTest(config) as test:\n        with open(test.getSourcePath(), \"w\") as source:\n            source.write(program)\n        _, err, exitCode, _, buildcmd = _executeWithFakeConfig(test, [\"%{build}\"])\n        if exitCode != 0:\n            raise ConfigurationCompilationError(\n                \"Failed to build program, cmd:\\n{}\\nstderr is:\\n{}\".format(\n                    buildcmd, err\n                )\n            )\n\n        out, err, exitCode, _, runcmd = _executeWithFakeConfig(\n            test, [\"%{{run}} {}\".format(\" \".join(args))]\n        )\n        if exitCode != 0:\n            raise ConfigurationRuntimeError(\n                \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n            )\n\n        return libcxx.test.format._parseLitOutput(out)\n\n\n@_memoizeExpensiveOperation(\n    lambda c, p, args=None: (c.substitutions, c.environment, p, args)\n)\ndef programSucceeds(config, program, args=None):\n    \"\"\"\n    Compiles a program for the test target, run it on the test target and return\n    whether it completed successfully.\n\n    Note that execution of the program is done through the %{exec} substitution,\n    which means that the program may be run on a remote host depending on what\n    %{exec} does.\n    \"\"\"\n    try:\n        programOutput(config, program, args)\n    except ConfigurationRuntimeError:\n        return False\n    return True\n\n\n@_memoizeExpensiveOperation(lambda c, f: (c.substitutions, c.environment, f))\ndef hasCompileFlag(config, flag):\n    \"\"\"\n    Return whether the compiler in the configuration supports a given compiler flag.\n\n    This is done by executing the %{cxx} substitution with the given flag and\n    checking whether that succeeds.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        out, err, exitCode, timeoutInfo, _ = _executeWithFakeConfig(\n            test,\n            [\n                \"%{{cxx}} -xc++ {} -Werror -fsyntax-only %{{flags}} %{{compile_flags}} {}\".format(\n                    os.devnull, flag\n                )\n            ],\n        )\n        return exitCode == 0\n\n\n@_memoizeExpensiveOperation(lambda c, s: (c.substitutions, c.environment, s))\ndef runScriptExitCode(config, script):\n    \"\"\"\n    Runs the given script as a Lit test, and returns the exit code of the execution.\n\n    The script must be a list of commands, each of which being something that\n    could appear on the right-hand-side of a `RUN:` keyword.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        _, _, exitCode, _, _ = _executeWithFakeConfig(test, script)\n        return exitCode\n\n\n@_memoizeExpensiveOperation(lambda c, s: (c.substitutions, c.environment, s))\ndef commandOutput(config, command):\n    \"\"\"\n    Runs the given script as a Lit test, and returns the output.\n    If the exit code isn't 0 an exception is raised.\n\n    The script must be a list of commands, each of which being something that\n    could appear on the right-hand-side of a `RUN:` keyword.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        out, err, exitCode, _, cmd = _executeWithFakeConfig(test, command)\n        if exitCode != 0:\n            raise ConfigurationRuntimeError(\n                \"Failed to run command: {}\\nstderr is:\\n{}\".format(cmd, err)\n            )\n        return out\n\n\n@_memoizeExpensiveOperation(lambda c, l: (c.substitutions, c.environment, l))\ndef hasAnyLocale(config, locales):\n    \"\"\"\n    Return whether the runtime execution environment supports a given locale.\n    Different systems may use different names for a locale, so this function checks\n    whether any of the passed locale names is supported by setlocale() and returns\n    true if one of them works.\n\n    This is done by executing a program that tries to set the given locale using\n    %{exec} -- this means that the command may be executed on a remote host\n    depending on the %{exec} substitution.\n    \"\"\"\n    program = \"\"\"\n    #include <stddef.h>\n    #if defined(_LIBCPP_HAS_NO_LOCALIZATION)\n      int main(int, char**) { return 1; }\n    #else\n      #include <locale.h>\n      int main(int argc, char** argv) {\n        for (int i = 1; i < argc; i++) {\n          if (::setlocale(LC_ALL, argv[i]) != NULL) {\n            return 0;\n          }\n        }\n        return 1;\n      }\n    #endif\n  \"\"\"\n    return programSucceeds(config, program, args=[pipes.quote(l) for l in locales])\n\n\n@_memoizeExpensiveOperation(lambda c, flags=\"\": (c.substitutions, c.environment, flags))\ndef compilerMacros(config, flags=\"\"):\n    \"\"\"\n    Return a dictionary of predefined compiler macros.\n\n    The keys are strings representing macros, and the values are strings\n    representing what each macro is defined to.\n\n    If the optional `flags` argument (a string) is provided, these flags will\n    be added to the compiler invocation when generating the macros.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        with open(test.getSourcePath(), \"w\") as sourceFile:\n            sourceFile.write(\n                \"\"\"\n      #if __has_include(<__config_site>)\n      #  include <__config_site>\n      #endif\n      \"\"\"\n            )\n        unparsedOutput, err, exitCode, _, cmd = _executeWithFakeConfig(\n            test, [\"%{{cxx}} %s -dM -E %{{flags}} %{{compile_flags}} {}\".format(flags)]\n        )\n        if exitCode != 0:\n            raise ConfigurationCompilationError(\n                \"Failed to retrieve compiler macros, compiler invocation is:\\n{}\\nstderr is:\\n{}\".format(\n                    cmd, err\n                )\n            )\n        parsedMacros = dict()\n        defines = (\n            l.strip() for l in unparsedOutput.split(\"\\n\") if l.startswith(\"#define \")\n        )\n        for line in defines:\n            line = line[len(\"#define \") :]\n            macro, _, value = line.partition(\" \")\n            parsedMacros[macro] = value\n        return parsedMacros\n\n\ndef featureTestMacros(config, flags=\"\"):\n    \"\"\"\n    Return a dictionary of feature test macros.\n\n    The keys are strings representing feature test macros, and the values are\n    integers representing the value of the macro.\n    \"\"\"\n    allMacros = compilerMacros(config, flags)\n    return {\n        m: int(v.rstrip(\"LlUu\"))\n        for (m, v) in allMacros.items()\n        if m.startswith(\"__cpp_\")\n    }\n\n\ndef _getSubstitution(substitution, config):\n  for (orig, replacement) in config.substitutions:\n    if orig == substitution:\n      return replacement\n  raise ValueError('Substitution {} is not in the config.'.format(substitution))\n\ndef _appendToSubstitution(substitutions, key, value):\n    return [(k, v + \" \" + value) if k == key else (k, v) for (k, v) in substitutions]\n\n\ndef _prependToSubstitution(substitutions, key, value):\n    return [(k, value + \" \" + v) if k == key else (k, v) for (k, v) in substitutions]\n\n\nclass ConfigAction(object):\n    \"\"\"\n    This class represents an action that can be performed on a Lit TestingConfig\n    object.\n\n    Examples of such actions are adding or modifying substitutions, Lit features,\n    etc. This class only provides the interface of such actions, and it is meant\n    to be subclassed appropriately to create new actions.\n    \"\"\"\n\n    def applyTo(self, config):\n        \"\"\"\n        Applies the action to the given configuration.\n\n        This should modify the configuration object in place, and return nothing.\n\n        If applying the action to the configuration would yield an invalid\n        configuration, and it is possible to diagnose it here, this method\n        should produce an error. For example, it should be an error to modify\n        a substitution in a way that we know for sure is invalid (e.g. adding\n        a compiler flag when we know the compiler doesn't support it). Failure\n        to do so early may lead to difficult-to-diagnose issues down the road.\n        \"\"\"\n        pass\n\n    def pretty(self, config, litParams):\n        \"\"\"\n        Returns a short and human-readable string describing what this action does.\n\n        This is used for logging purposes when running the test suite, so it should\n        be kept concise.\n        \"\"\"\n        pass\n\n\nclass AddFeature(ConfigAction):\n    \"\"\"\n    This action defines the given Lit feature when running the test suite.\n\n    The name of the feature can be a string or a callable, in which case it is\n    called with the configuration to produce the feature name (as a string).\n    \"\"\"\n\n    def __init__(self, name):\n        self._name = name\n\n    def _getName(self, config):\n        name = self._name(config) if callable(self._name) else self._name\n        if not isinstance(name, str):\n            raise ValueError(\n                \"Lit feature did not resolve to a string (got {})\".format(name)\n            )\n        return name\n\n    def applyTo(self, config):\n        config.available_features.add(self._getName(config))\n\n    def pretty(self, config, litParams):\n        return \"add Lit feature {}\".format(self._getName(config))\n\n\nclass AddFlag(ConfigAction):\n    \"\"\"\n    This action adds the given flag to the %{flags} substitution.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        assert hasCompileFlag(\n            config, flag\n        ), \"Trying to enable flag {}, which is not supported\".format(flag)\n        config.substitutions = _appendToSubstitution(\n            config.substitutions, \"%{flags}\", flag\n        )\n\n    def pretty(self, config, litParams):\n        return \"add {} to %{{flags}}\".format(self._getFlag(config))\n\nclass AddFlagIfSupported(ConfigAction):\n    \"\"\"\n    This action adds the given flag to the %{flags} substitution, only if\n    the compiler supports the flag.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        if hasCompileFlag(config, flag):\n            config.substitutions = _appendToSubstitution(\n                config.substitutions, \"%{flags}\", flag\n            )\n\n    def pretty(self, config, litParams):\n        return \"add {} to %{{flags}}\".format(self._getFlag(config))\n\n\nclass AddCompileFlag(ConfigAction):\n    \"\"\"\n    This action adds the given flag to the %{compile_flags} substitution.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        assert hasCompileFlag(\n            config, flag\n        ), \"Trying to enable compile flag {}, which is not supported\".format(flag)\n        config.substitutions = _appendToSubstitution(\n            config.substitutions, \"%{compile_flags}\", flag\n        )\n\n    def pretty(self, config, litParams):\n        return \"add {} to %{{compile_flags}}\".format(self._getFlag(config))\n\n\nclass AddLinkFlag(ConfigAction):\n    \"\"\"\n    This action appends the given flag to the %{link_flags} substitution.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        assert hasCompileFlag(\n            config, flag\n        ), \"Trying to enable link flag {}, which is not supported\".format(flag)\n        config.substitutions = _appendToSubstitution(\n            config.substitutions, \"%{link_flags}\", flag\n        )\n\n    def pretty(self, config, litParams):\n        return \"append {} to %{{link_flags}}\".format(self._getFlag(config))\n\n\nclass PrependLinkFlag(ConfigAction):\n    \"\"\"\n    This action prepends the given flag to the %{link_flags} substitution.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        assert hasCompileFlag(\n            config, flag\n        ), \"Trying to enable link flag {}, which is not supported\".format(flag)\n        config.substitutions = _prependToSubstitution(\n            config.substitutions, \"%{link_flags}\", flag\n        )\n\n    def pretty(self, config, litParams):\n        return \"prepend {} to %{{link_flags}}\".format(self._getFlag(config))\n\n\nclass AddOptionalWarningFlag(ConfigAction):\n    \"\"\"\n    This action adds the given warning flag to the %{compile_flags} substitution,\n    if it is supported by the compiler.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        # Use -Werror to make sure we see an error about the flag being unsupported.\n        if hasCompileFlag(config, \"-Werror \" + flag):\n            config.substitutions = _appendToSubstitution(\n                config.substitutions, \"%{compile_flags}\", flag\n            )\n\n    def pretty(self, config, litParams):\n        return \"add {} to %{{compile_flags}}\".format(self._getFlag(config))\n\n\nclass AddSubstitution(ConfigAction):\n    \"\"\"\n    This action adds the given substitution to the Lit configuration.\n\n    The substitution can be a string or a callable, in which case it is called\n    with the configuration to produce the actual substitution (as a string).\n    \"\"\"\n\n    def __init__(self, key, substitution):\n        self._key = key\n        self._getSub = (\n            lambda config: substitution(config)\n            if callable(substitution)\n            else substitution\n        )\n\n    def applyTo(self, config):\n        key = self._key\n        sub = self._getSub(config)\n        config.substitutions.append((key, sub))\n\n    def pretty(self, config, litParams):\n        return \"add substitution {} = {}\".format(self._key, self._getSub(config))\n\n\nclass Feature(object):\n    \"\"\"\n    Represents a Lit available feature that is enabled whenever it is supported.\n\n    A feature like this informs the test suite about a capability of the compiler,\n    platform, etc. Unlike Parameters, it does not make sense to explicitly\n    control whether a Feature is enabled -- it should be enabled whenever it\n    is supported.\n    \"\"\"\n\n    def __init__(self, name, actions=None, when=lambda _: True):\n        \"\"\"\n        Create a Lit feature for consumption by a test suite.\n\n        - name\n            The name of the feature. This is what will end up in Lit's available\n            features if the feature is enabled. This can be either a string or a\n            callable, in which case it is passed the TestingConfig and should\n            generate a string representing the name of the feature.\n\n        - actions\n            An optional list of ConfigActions to apply when the feature is supported.\n            An AddFeature action is always created regardless of any actions supplied\n            here -- these actions are meant to perform more than setting a corresponding\n            Lit feature (e.g. adding compiler flags). If 'actions' is a callable, it\n            is called with the current configuration object to generate the actual\n            list of actions.\n\n        - when\n            A callable that gets passed a TestingConfig and should return a\n            boolean representing whether the feature is supported in that\n            configuration. For example, this can use `hasCompileFlag` to\n            check whether the compiler supports the flag that the feature\n            represents. If omitted, the feature will always be considered\n            supported.\n        \"\"\"\n        self._name = name\n        self._actions = [] if actions is None else actions\n        self._isSupported = when\n\n    def _getName(self, config):\n        name = self._name(config) if callable(self._name) else self._name\n        if not isinstance(name, str):\n            raise ValueError(\n                \"Feature did not resolve to a name that's a string, got {}\".format(name)\n            )\n        return name\n\n    def getActions(self, config):\n        \"\"\"\n        Return the list of actions associated to this feature.\n\n        If the feature is not supported, an empty list is returned.\n        If the feature is supported, an `AddFeature` action is automatically added\n        to the returned list of actions, in addition to any actions provided on\n        construction.\n        \"\"\"\n        if not self._isSupported(config):\n            return []\n        else:\n            actions = (\n                self._actions(config) if callable(self._actions) else self._actions\n            )\n            return [AddFeature(self._getName(config))] + actions\n\n    def pretty(self, config):\n        \"\"\"\n        Returns the Feature's name.\n        \"\"\"\n        return self._getName(config)\n\n\ndef _str_to_bool(s):\n    \"\"\"\n    Convert a string value to a boolean.\n\n    True values are \"y\", \"yes\", \"t\", \"true\", \"on\" and \"1\", regardless of capitalization.\n    False values are \"n\", \"no\", \"f\", \"false\", \"off\" and \"0\", regardless of capitalization.\n    \"\"\"\n    trueVals = [\"y\", \"yes\", \"t\", \"true\", \"on\", \"1\"]\n    falseVals = [\"n\", \"no\", \"f\", \"false\", \"off\", \"0\"]\n    lower = s.lower()\n    if lower in trueVals:\n        return True\n    elif lower in falseVals:\n        return False\n    else:\n        raise ValueError(\"Got string '{}', which isn't a valid boolean\".format(s))\n\n\ndef _parse_parameter(s, type):\n    if type is bool and isinstance(s, str):\n        return _str_to_bool(s)\n    elif type is list and isinstance(s, str):\n        return [x.strip() for x in s.split(\",\") if x.strip()]\n    return type(s)\n\n\nclass Parameter(object):\n    \"\"\"\n    Represents a parameter of a Lit test suite.\n\n    Parameters are used to customize the behavior of test suites in a user\n    controllable way. There are two ways of setting the value of a Parameter.\n    The first one is to pass `--param <KEY>=<VALUE>` when running Lit (or\n    equivalently to set `litConfig.params[KEY] = VALUE` somewhere in the\n    Lit configuration files. This method will set the parameter globally for\n    all test suites being run.\n\n    The second method is to set `config.KEY = VALUE` somewhere in the Lit\n    configuration files, which sets the parameter only for the test suite(s)\n    that use that `config` object.\n\n    Parameters can have multiple possible values, and they can have a default\n    value when left unspecified. They can also have any number of ConfigActions\n    associated to them, in which case the actions will be performed on the\n    TestingConfig if the parameter is enabled. Depending on the actions\n    associated to a Parameter, it may be an error to enable the Parameter\n    if some actions are not supported in the given configuration. For example,\n    trying to set the compilation standard to C++23 when `-std=c++23` is not\n    supported by the compiler would be an error.\n    \"\"\"\n\n    def __init__(self, name, type, help, actions, choices=None, default=None):\n        \"\"\"\n        Create a Lit parameter to customize the behavior of a test suite.\n\n        - name\n            The name of the parameter that can be used to set it on the command-line.\n            On the command-line, the parameter can be set using `--param <name>=<value>`\n            when running Lit. This must be non-empty.\n\n        - choices\n            An optional non-empty set of possible values for this parameter. If provided,\n            this must be anything that can be iterated. It is an error if the parameter\n            is given a value that is not in that set, whether explicitly or through a\n            default value.\n\n        - type\n            A callable that can be used to parse the value of the parameter given\n            on the command-line. As a special case, using the type `bool` also\n            allows parsing strings with boolean-like contents, and the type `list`\n            will parse a string delimited by commas into a list of the substrings.\n\n        - help\n            A string explaining the parameter, for documentation purposes.\n            TODO: We should be able to surface those from the Lit command-line.\n\n        - actions\n            A callable that gets passed the parsed value of the parameter (either\n            the one passed on the command-line or the default one), and that returns\n            a list of ConfigAction to perform given the value of the parameter.\n            All the ConfigAction must be supported in the given configuration.\n\n        - default\n            An optional default value to use for the parameter when no value is\n            provided on the command-line. If the default value is a callable, it\n            is called with the TestingConfig and should return the default value\n            for the parameter. Whether the default value is computed or specified\n            directly, it must be in the 'choices' provided for that Parameter.\n        \"\"\"\n        self._name = name\n        if len(self._name) == 0:\n            raise ValueError(\"Parameter name must not be the empty string\")\n\n        if choices is not None:\n            self._choices = list(choices)  # should be finite\n            if len(self._choices) == 0:\n                raise ValueError(\n                    \"Parameter '{}' must be given at least one possible value\".format(\n                        self._name\n                    )\n                )\n        else:\n            self._choices = None\n\n        self._parse = lambda x: _parse_parameter(x, type)\n        self._help = help\n        self._actions = actions\n        self._default = default\n\n    def _getValue(self, config, litParams):\n        \"\"\"\n        Return the value of the parameter given the configuration objects.\n        \"\"\"\n        param = getattr(config, self.name, None)\n        param = litParams.get(self.name, param)\n        if param is None and self._default is None:\n            raise ValueError(\n                \"Parameter {} doesn't have a default value, but it was not specified in the Lit parameters or in the Lit config\".format(\n                    self.name\n                )\n            )\n        getDefault = (\n            lambda: self._default(config) if callable(self._default) else self._default\n        )\n\n        if param is not None:\n            (pretty, value) = (param, self._parse(param))\n        else:\n            value = getDefault()\n            pretty = \"{} (default)\".format(value)\n\n        if self._choices and value not in self._choices:\n            raise ValueError(\n                \"Got value '{}' for parameter '{}', which is not in the provided set of possible choices: {}\".format(\n                    value, self.name, self._choices\n                )\n            )\n        return (pretty, value)\n\n    @property\n    def name(self):\n        \"\"\"\n        Return the name of the parameter.\n\n        This is the name that can be used to set the parameter on the command-line\n        when running Lit.\n        \"\"\"\n        return self._name\n\n    def getActions(self, config, litParams):\n        \"\"\"\n        Return the list of actions associated to this value of the parameter.\n        \"\"\"\n        (_, parameterValue) = self._getValue(config, litParams)\n        return self._actions(parameterValue)\n\n    def pretty(self, config, litParams):\n        \"\"\"\n        Return a pretty representation of the parameter's name and value.\n        \"\"\"\n        (prettyParameterValue, _) = self._getValue(config, litParams)\n        return \"{}={}\".format(self.name, prettyParameterValue)\n"}, "/libcxx/utils/libcxx/test/format.py": {"changes": [{"diff": "\n     for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n         assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n \n-def _parseLitOutput(fullOutput):\n-    \"\"\"\n-    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n-\n-    This takes output of the form\n-\n-        $ \":\" \"RUN: at line 11\"\n-        $ \"echo\" \"OUTPUT1\"\n-        # command output:\n-        OUTPUT1\n-\n-        $ \":\" \"RUN: at line 12\"\n-        $ \"echo\" \"OUTPUT2\"\n-        # command output:\n-        OUTPUT2\n-\n-    and returns a string containing\n-\n-        OUTPUT1\n-        OUTPUT2\n-\n-    as-if the commands had been run directly. This is a workaround for the fact\n-    that Lit doesn't let us execute ShTest and retrieve the raw output without\n-    injecting additional Lit output around it.\n-    \"\"\"\n-    parsed = ''\n-    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n-        if output: # skip blank lines\n-            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n-            if commandOutput:\n-                parsed += commandOutput.group(1)\n-    return parsed\n-\n def _executeScriptInternal(test, litConfig, commands):\n     \"\"\"\n     Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n", "add": 0, "remove": 33, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["def _parseLitOutput(fullOutput):", "    \"\"\"", "    Parse output of a Lit ShTest to extract the actual output of the contained commands.", "    This takes output of the form", "        $ \":\" \"RUN: at line 11\"", "        $ \"echo\" \"OUTPUT1\"", "        OUTPUT1", "        $ \":\" \"RUN: at line 12\"", "        $ \"echo\" \"OUTPUT2\"", "        OUTPUT2", "    and returns a string containing", "        OUTPUT1", "        OUTPUT2", "    as-if the commands had been run directly. This is a workaround for the fact", "    that Lit doesn't let us execute ShTest and retrieve the raw output without", "    injecting additional Lit output around it.", "    \"\"\"", "    parsed = ''", "    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):", "        if output: # skip blank lines", "            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)", "            if commandOutput:", "                parsed += commandOutput.group(1)", "    return parsed"], "goodparts": []}, {"diff": "\n     _, tmpBase = _getTempPaths(test)\n     execDir = os.path.dirname(test.getExecPath())\n     res = lit.TestRunner.executeScriptInternal(\n-        test, litConfig, tmpBase, parsedCommands, execDir\n+        test, litConfig, tmpBase, parsedCommands, execDir, debug=False\n     )\n     if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n         res = (\"\", res.output, 127, None)\n     (out, err, exitCode, timeoutInfo) = res\n \n-    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n-    #       split any stderr output that is included in stdout. It shouldn't be there, but\n-    #       the Lit internal shell conflates stderr and stdout.\n-    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n-    if conflatedErrorOutput:\n-        conflatedErrorOutput = conflatedErrorOutput.group(0)\n-        out = out[: -len(conflatedErrorOutput)]\n-        err += conflatedErrorOutput\n-\n     return (out, err, exitCode, timeoutInfo, parsedCommands)\n \n \n", "add": 1, "remove": 10, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["        test, litConfig, tmpBase, parsedCommands, execDir", "    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)", "    if conflatedErrorOutput:", "        conflatedErrorOutput = conflatedErrorOutput.group(0)", "        out = out[: -len(conflatedErrorOutput)]", "        err += conflatedErrorOutput"], "goodparts": ["        test, litConfig, tmpBase, parsedCommands, execDir, debug=False"]}, {"diff": "\n             raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n \n         # Split the generated output into multiple files and generate one test for each file\n-        parsed = _parseLitOutput(out)\n-        for (subfile, content) in self._splitFile(parsed):\n+        for (subfile, content) in self._splitFile(out):\n             generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n             os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n             with open(generatedFile, 'w') as f", "add": 1, "remove": 2, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["        parsed = _parseLitOutput(out)", "        for (subfile, content) in self._splitFile(parsed):"], "goodparts": ["        for (subfile, content) in self._splitFile(out):"]}], "source": "\n import contextlib import io import lit import lit.formats import os import pipes import re import shutil def _getTempPaths(test): \"\"\" Return the values to use for the %T and %t substitutions, respectively. The difference between this and Lit's default behavior is that we guarantee that %T is a path unique to the test being run. \"\"\" tmpDir, _=lit.TestRunner.getTempPaths(test) _, testName=os.path.split(test.getExecPath()) tmpDir=os.path.join(tmpDir, testName +\".dir\") tmpBase=os.path.join(tmpDir, \"t\") return tmpDir, tmpBase def _checkBaseSubstitutions(substitutions): substitutions=[s for(s, _) in substitutions] for s in[\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]: assert s in substitutions, \"Required substitution{} was not provided\".format(s) def _parseLitOutput(fullOutput): \"\"\" Parse output of a Lit ShTest to extract the actual output of the contained commands. This takes output of the form $ \":\" \"RUN: at line 11\" $ \"echo\" \"OUTPUT1\" OUTPUT1 $ \":\" \"RUN: at line 12\" $ \"echo\" \"OUTPUT2\" OUTPUT2 and returns a string containing OUTPUT1 OUTPUT2 as-if the commands had been run directly. This is a workaround for the fact that Lit doesn't let us execute ShTest and retrieve the raw output without injecting additional Lit output around it. \"\"\" parsed='' for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput): if output: commandOutput=re.search(\" if commandOutput: parsed +=commandOutput.group(1) return parsed def _executeScriptInternal(test, litConfig, commands): \"\"\" Returns(stdout, stderr, exitCode, timeoutInfo, parsedCommands) TODO: This really should be easier to access from Lit itself \"\"\" parsedCommands=parseScript(test, preamble=commands) _, tmpBase=_getTempPaths(test) execDir=os.path.dirname(test.getExecPath()) res=lit.TestRunner.executeScriptInternal( test, litConfig, tmpBase, parsedCommands, execDir ) if isinstance(res, lit.Test.Result): res=(\"\", res.output, 127, None) (out, err, exitCode, timeoutInfo)=res conflatedErrorOutput=re.search(\"( if conflatedErrorOutput: conflatedErrorOutput=conflatedErrorOutput.group(0) out=out[: -len(conflatedErrorOutput)] err +=conflatedErrorOutput return(out, err, exitCode, timeoutInfo, parsedCommands) def parseScript(test, preamble): \"\"\" Extract the script from a test, with substitutions applied. Returns a list of commands ready to be executed. -test The lit.Test to parse. -preamble A list of commands to perform before any command in the test. These commands can contain unexpanded substitutions, but they must not be of the form 'RUN:' --they must be proper commands once substituted. \"\"\" tmpDir, tmpBase=_getTempPaths(test) substitutions=lit.TestRunner.getDefaultSubstitutions(test, tmpDir, tmpBase) _checkBaseSubstitutions(substitutions) substitutions.append( (\"%{build}\", \"%{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\") ) substitutions.append((\"%{run}\", \"%{exec} %t.exe\")) additionalCompileFlags=[] fileDependencies=[] parsers=[ lit.TestRunner.IntegratedTestKeywordParser( \"FILE_DEPENDENCIES:\", lit.TestRunner.ParserKind.LIST, initial_value=fileDependencies, ), lit.TestRunner.IntegratedTestKeywordParser( \"ADDITIONAL_COMPILE_FLAGS:\", lit.TestRunner.ParserKind.LIST, initial_value=additionalCompileFlags, ), ] for feature in test.config.available_features: parser=lit.TestRunner.IntegratedTestKeywordParser( \"ADDITIONAL_COMPILE_FLAGS({}):\".format(feature), lit.TestRunner.ParserKind.LIST, initial_value=additionalCompileFlags, ) parsers.append(parser) scriptInTest=lit.TestRunner.parseIntegratedTestScript( test, additional_parsers=parsers, require_script=not preamble ) if isinstance(scriptInTest, lit.Test.Result): return scriptInTest script=[] for dep in fileDependencies: script +=[\"%dbg(SETUP) cd %S && cp{} %T\".format(dep)] script +=preamble script +=scriptInTest substitutions=[ (s, x +\" \" +\" \".join(additionalCompileFlags)) if s==\"%{compile_flags}\" else(s, x) for(s, x) in substitutions ] script=lit.TestRunner.applySubstitutions( script, substitutions, recursion_limit=test.config.recursiveExpansionLimit ) return script class CxxStandardLibraryTest(lit.formats.FileBasedTest): \"\"\" Lit test format for the C++Standard Library conformance test suite. This test format is based on top of the ShTest format --it basically creates a shell script performing the right operations(compile/link/run) based on the extension of the test file it encounters. It supports files with the following extensions: FOO.pass.cpp -Compiles, links and runs successfully FOO.pass.mm -Same as.pass.cpp, but for Objective-C++ FOO.compile.pass.cpp -Compiles successfully, link and run not attempted FOO.compile.pass.mm -Same as.compile.pass.cpp, but for Objective-C++ FOO.compile.fail.cpp -Does not compile successfully FOO.link.pass.cpp -Compiles and links successfully, run not attempted FOO.link.pass.mm -Same as.link.pass.cpp, but for Objective-C++ FOO.link.fail.cpp -Compiles successfully, but fails to link FOO.sh.<anything> -A builtin Lit Shell test FOO.gen.<anything> -A.sh test that generates one or more Lit tests on the fly. Executing this test must generate one or more files as expected by LLVM split-file, and each generated file leads to a separate Lit test that runs that file as defined by the test format. This can be used to generate multiple Lit tests from a single source file, which is useful for testing repetitive properties in the library. Be careful not to abuse this since this is not a replacement for usual code reuse techniques. FOO.verify.cpp -Compiles with clang-verify. This type of test is automatically marked as UNSUPPORTED if the compiler does not support Clang-verify. Substitution requirements =============================== The test format operates by assuming that each test's configuration provides the following substitutions, which it will reuse in the shell scripts it constructs: %{cxx} -A command that can be used to invoke the compiler %{compile_flags} -Flags to use when compiling a test case %{link_flags} -Flags to use when linking a test case %{flags} -Flags to use either when compiling or linking a test case %{exec} -A command to prefix the execution of executables Note that when building an executable(as opposed to only compiling a source file), all three of %{flags}, %{compile_flags} and %{link_flags} will be used in the same command line. In other words, the test format doesn't perform separate compilation and linking steps in this case. Additional supported directives =============================== In addition to everything that's supported in Lit ShTests, this test format also understands the following directives inside test files: // FILE_DEPENDENCIES: file, directory, /path/to/file This directive expresses that the test requires the provided files or directories in order to run. An example is a test that requires some test input stored in a data file. When a test file contains such a directive, this test format will collect them and copy them to the directory represented by %T. The intent is that %T contains all the inputs necessary to run the test, such that e.g. execution on a remote host can be done by simply copying %T to the host. // ADDITIONAL_COMPILE_FLAGS: flag1, flag2, flag3 This directive will cause the provided flags to be added to the %{compile_flags} substitution for the test that contains it. This allows adding special compilation flags without having to use a .sh.cpp test, which would be more powerful but perhaps overkill. Additional provided substitutions and features ============================================== The test format will define the following substitutions for use inside tests: %{build} Expands to a command-line that builds the current source file with the %{flags}, %{compile_flags} and %{link_flags} substitutions, and that produces an executable named %t.exe. %{run} Equivalent to `%{exec} %t.exe`. This is intended to be used in conjunction with the %{build} substitution. \"\"\" def getTestsForPath(self, testSuite, pathInSuite, litConfig, localConfig): SUPPORTED_SUFFIXES=[ \"[.]pass[.]cpp$\", \"[.]pass[.]mm$\", \"[.]compile[.]pass[.]cpp$\", \"[.]compile[.]pass[.]mm$\", \"[.]compile[.]fail[.]cpp$\", \"[.]link[.]pass[.]cpp$\", \"[.]link[.]pass[.]mm$\", \"[.]link[.]fail[.]cpp$\", \"[.]sh[.][^.]+$\", \"[.]gen[.][^.]+$\", \"[.]verify[.]cpp$\", \"[.]fail[.]cpp$\", ] sourcePath=testSuite.getSourcePath(pathInSuite) filename=os.path.basename(sourcePath) hasSupportedSuffix=lambda f: any([re.search(ext, f) for ext in SUPPORTED_SUFFIXES]) if filename.startswith(\".\") or filename in localConfig.excludes or not hasSupportedSuffix(filename): return if re.search('[.]gen[.][^.]+$', filename): for test in self._generateGenTest(testSuite, pathInSuite, litConfig, localConfig): yield test else: yield lit.Test.Test(testSuite, pathInSuite, localConfig) def execute(self, test, litConfig): VERIFY_FLAGS=( \"-Xclang -verify -Xclang -verify-ignore-unexpected=note -ferror-limit=0\" ) supportsVerify=\"verify-support\" in test.config.available_features filename=test.path_in_suite[-1] if re.search(\"[.]sh[.][^.]+$\", filename): steps=[] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".compile.pass.cpp\") or filename.endswith( \".compile.pass.mm\" ): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".compile.fail.cpp\"): steps=[ \"%dbg(COMPILED WITH) ! %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".link.pass.cpp\") or filename.endswith(\".link.pass.mm\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".link.fail.cpp\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -c -o %t.o\", \"%dbg(LINKED WITH) ! %{cxx} %t.o %{flags} %{link_flags} -o %t.exe\", ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".verify.cpp\"): if not supportsVerify: return lit.Test.Result( lit.Test.UNSUPPORTED, \"Test{} requires support for Clang-verify, which isn't supported by the compiler\".format( test.getFullName() ), ) steps=[ \"%dbg(COMPILED WITH) %{{cxx}} %s %{{flags}} %{{compile_flags}} -fsyntax-only -Wno-error{}\".format( VERIFY_FLAGS ) ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".pass.cpp\") or filename.endswith(\".pass.mm\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\", \"%dbg(EXECUTED AS) %{exec} %t.exe\", ] return self._executeShTest(test, litConfig, steps) else: return lit.Test.Result( lit.Test.UNRESOLVED, \"Unknown test suffix for '{}'\".format(filename) ) def _executeShTest(self, test, litConfig, steps): if test.config.unsupported: return lit.Test.Result(lit.Test.UNSUPPORTED, \"Test is unsupported\") script=parseScript(test, steps) if isinstance(script, lit.Test.Result): return script if litConfig.noExecute: return lit.Test.Result( lit.Test.XFAIL if test.isExpectedToFail() else lit.Test.PASS ) else: _, tmpBase=_getTempPaths(test) useExternalSh=False return lit.TestRunner._runShTest( test, litConfig, useExternalSh, script, tmpBase ) def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig): generator=lit.Test.Test(testSuite, pathInSuite, localConfig) generatorExecDir=os.path.dirname(testSuite.getExecPath(pathInSuite)) os.makedirs(generatorExecDir, exist_ok=True) steps=[] (out, err, exitCode, _, _)=_executeScriptInternal(generator, litConfig, steps) if exitCode !=0: raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\") parsed=_parseLitOutput(out) for(subfile, content) in self._splitFile(parsed): generatedFile=testSuite.getExecPath(pathInSuite +(subfile,)) os.makedirs(os.path.dirname(generatedFile), exist_ok=True) with open(generatedFile, 'w') as f: f.write(content) yield lit.Test.Test(testSuite,(generatedFile,), localConfig) def _splitFile(self, input): DELIM=r'^(//| lines=input.splitlines() currentFile=None thisFileContent=[] for line in lines: match=re.match(DELIM, line) if match: if currentFile is not None: yield(currentFile, '\\n'.join(thisFileContent)) currentFile=match.group(2).strip() thisFileContent=[] assert currentFile is not None, f\"Some input to split-file doesn't belong to any file, input was:\\n{input}\" thisFileContent.append(line) if currentFile is not None: yield(currentFile, '\\n'.join(thisFileContent)) ", "sourceWithComments": "# ===----------------------------------------------------------------------===##\n#\n# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n# See https://llvm.org/LICENSE.txt for license information.\n# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n#\n# ===----------------------------------------------------------------------===##\n\nimport contextlib\nimport io\nimport lit\nimport lit.formats\nimport os\nimport pipes\nimport re\nimport shutil\n\n\ndef _getTempPaths(test):\n    \"\"\"\n    Return the values to use for the %T and %t substitutions, respectively.\n\n    The difference between this and Lit's default behavior is that we guarantee\n    that %T is a path unique to the test being run.\n    \"\"\"\n    tmpDir, _ = lit.TestRunner.getTempPaths(test)\n    _, testName = os.path.split(test.getExecPath())\n    tmpDir = os.path.join(tmpDir, testName + \".dir\")\n    tmpBase = os.path.join(tmpDir, \"t\")\n    return tmpDir, tmpBase\n\n\ndef _checkBaseSubstitutions(substitutions):\n    substitutions = [s for (s, _) in substitutions]\n    for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n        assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n\ndef _parseLitOutput(fullOutput):\n    \"\"\"\n    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n\n    This takes output of the form\n\n        $ \":\" \"RUN: at line 11\"\n        $ \"echo\" \"OUTPUT1\"\n        # command output:\n        OUTPUT1\n\n        $ \":\" \"RUN: at line 12\"\n        $ \"echo\" \"OUTPUT2\"\n        # command output:\n        OUTPUT2\n\n    and returns a string containing\n\n        OUTPUT1\n        OUTPUT2\n\n    as-if the commands had been run directly. This is a workaround for the fact\n    that Lit doesn't let us execute ShTest and retrieve the raw output without\n    injecting additional Lit output around it.\n    \"\"\"\n    parsed = ''\n    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n        if output: # skip blank lines\n            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n            if commandOutput:\n                parsed += commandOutput.group(1)\n    return parsed\n\ndef _executeScriptInternal(test, litConfig, commands):\n    \"\"\"\n    Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n\n    TODO: This really should be easier to access from Lit itself\n    \"\"\"\n    parsedCommands = parseScript(test, preamble=commands)\n\n    _, tmpBase = _getTempPaths(test)\n    execDir = os.path.dirname(test.getExecPath())\n    res = lit.TestRunner.executeScriptInternal(\n        test, litConfig, tmpBase, parsedCommands, execDir\n    )\n    if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n        res = (\"\", res.output, 127, None)\n    (out, err, exitCode, timeoutInfo) = res\n\n    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n    #       split any stderr output that is included in stdout. It shouldn't be there, but\n    #       the Lit internal shell conflates stderr and stdout.\n    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n    if conflatedErrorOutput:\n        conflatedErrorOutput = conflatedErrorOutput.group(0)\n        out = out[: -len(conflatedErrorOutput)]\n        err += conflatedErrorOutput\n\n    return (out, err, exitCode, timeoutInfo, parsedCommands)\n\n\ndef parseScript(test, preamble):\n    \"\"\"\n    Extract the script from a test, with substitutions applied.\n\n    Returns a list of commands ready to be executed.\n\n    - test\n        The lit.Test to parse.\n\n    - preamble\n        A list of commands to perform before any command in the test.\n        These commands can contain unexpanded substitutions, but they\n        must not be of the form 'RUN:' -- they must be proper commands\n        once substituted.\n    \"\"\"\n    # Get the default substitutions\n    tmpDir, tmpBase = _getTempPaths(test)\n    substitutions = lit.TestRunner.getDefaultSubstitutions(test, tmpDir, tmpBase)\n\n    # Check base substitutions and add the %{build} and %{run} convenience substitutions\n    _checkBaseSubstitutions(substitutions)\n    substitutions.append(\n        (\"%{build}\", \"%{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\")\n    )\n    substitutions.append((\"%{run}\", \"%{exec} %t.exe\"))\n\n    # Parse the test file, including custom directives\n    additionalCompileFlags = []\n    fileDependencies = []\n    parsers = [\n        lit.TestRunner.IntegratedTestKeywordParser(\n            \"FILE_DEPENDENCIES:\",\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=fileDependencies,\n        ),\n        lit.TestRunner.IntegratedTestKeywordParser(\n            \"ADDITIONAL_COMPILE_FLAGS:\",\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=additionalCompileFlags,\n        ),\n    ]\n\n    # Add conditional parsers for ADDITIONAL_COMPILE_FLAGS. This should be replaced by first\n    # class support for conditional keywords in Lit, which would allow evaluating arbitrary\n    # Lit boolean expressions instead.\n    for feature in test.config.available_features:\n        parser = lit.TestRunner.IntegratedTestKeywordParser(\n            \"ADDITIONAL_COMPILE_FLAGS({}):\".format(feature),\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=additionalCompileFlags,\n        )\n        parsers.append(parser)\n\n    scriptInTest = lit.TestRunner.parseIntegratedTestScript(\n        test, additional_parsers=parsers, require_script=not preamble\n    )\n    if isinstance(scriptInTest, lit.Test.Result):\n        return scriptInTest\n\n    script = []\n\n    # For each file dependency in FILE_DEPENDENCIES, inject a command to copy\n    # that file to the execution directory. Execute the copy from %S to allow\n    # relative paths from the test directory.\n    for dep in fileDependencies:\n        script += [\"%dbg(SETUP) cd %S && cp {} %T\".format(dep)]\n    script += preamble\n    script += scriptInTest\n\n    # Add compile flags specified with ADDITIONAL_COMPILE_FLAGS.\n    substitutions = [\n        (s, x + \" \" + \" \".join(additionalCompileFlags))\n        if s == \"%{compile_flags}\"\n        else (s, x)\n        for (s, x) in substitutions\n    ]\n\n    # Perform substitutions in the script itself.\n    script = lit.TestRunner.applySubstitutions(\n        script, substitutions, recursion_limit=test.config.recursiveExpansionLimit\n    )\n\n    return script\n\n\nclass CxxStandardLibraryTest(lit.formats.FileBasedTest):\n    \"\"\"\n    Lit test format for the C++ Standard Library conformance test suite.\n\n    This test format is based on top of the ShTest format -- it basically\n    creates a shell script performing the right operations (compile/link/run)\n    based on the extension of the test file it encounters. It supports files\n    with the following extensions:\n\n    FOO.pass.cpp            - Compiles, links and runs successfully\n    FOO.pass.mm             - Same as .pass.cpp, but for Objective-C++\n\n    FOO.compile.pass.cpp    - Compiles successfully, link and run not attempted\n    FOO.compile.pass.mm     - Same as .compile.pass.cpp, but for Objective-C++\n    FOO.compile.fail.cpp    - Does not compile successfully\n\n    FOO.link.pass.cpp       - Compiles and links successfully, run not attempted\n    FOO.link.pass.mm        - Same as .link.pass.cpp, but for Objective-C++\n    FOO.link.fail.cpp       - Compiles successfully, but fails to link\n\n    FOO.sh.<anything>       - A builtin Lit Shell test\n\n    FOO.gen.<anything>      - A .sh test that generates one or more Lit tests on the\n                              fly. Executing this test must generate one or more files\n                              as expected by LLVM split-file, and each generated file\n                              leads to a separate Lit test that runs that file as\n                              defined by the test format. This can be used to generate\n                              multiple Lit tests from a single source file, which is\n                              useful for testing repetitive properties in the library.\n                              Be careful not to abuse this since this is not a replacement\n                              for usual code reuse techniques.\n\n    FOO.verify.cpp          - Compiles with clang-verify. This type of test is\n                              automatically marked as UNSUPPORTED if the compiler\n                              does not support Clang-verify.\n\n\n    Substitution requirements\n    ===============================\n    The test format operates by assuming that each test's configuration provides\n    the following substitutions, which it will reuse in the shell scripts it\n    constructs:\n        %{cxx}           - A command that can be used to invoke the compiler\n        %{compile_flags} - Flags to use when compiling a test case\n        %{link_flags}    - Flags to use when linking a test case\n        %{flags}         - Flags to use either when compiling or linking a test case\n        %{exec}          - A command to prefix the execution of executables\n\n    Note that when building an executable (as opposed to only compiling a source\n    file), all three of %{flags}, %{compile_flags} and %{link_flags} will be used\n    in the same command line. In other words, the test format doesn't perform\n    separate compilation and linking steps in this case.\n\n\n    Additional supported directives\n    ===============================\n    In addition to everything that's supported in Lit ShTests, this test format\n    also understands the following directives inside test files:\n\n        // FILE_DEPENDENCIES: file, directory, /path/to/file\n\n            This directive expresses that the test requires the provided files\n            or directories in order to run. An example is a test that requires\n            some test input stored in a data file. When a test file contains\n            such a directive, this test format will collect them and copy them\n            to the directory represented by %T. The intent is that %T contains\n            all the inputs necessary to run the test, such that e.g. execution\n            on a remote host can be done by simply copying %T to the host.\n\n        // ADDITIONAL_COMPILE_FLAGS: flag1, flag2, flag3\n\n            This directive will cause the provided flags to be added to the\n            %{compile_flags} substitution for the test that contains it. This\n            allows adding special compilation flags without having to use a\n            .sh.cpp test, which would be more powerful but perhaps overkill.\n\n\n    Additional provided substitutions and features\n    ==============================================\n    The test format will define the following substitutions for use inside tests:\n\n        %{build}\n            Expands to a command-line that builds the current source\n            file with the %{flags}, %{compile_flags} and %{link_flags}\n            substitutions, and that produces an executable named %t.exe.\n\n        %{run}\n            Equivalent to `%{exec} %t.exe`. This is intended to be used\n            in conjunction with the %{build} substitution.\n    \"\"\"\n\n    def getTestsForPath(self, testSuite, pathInSuite, litConfig, localConfig):\n        SUPPORTED_SUFFIXES = [\n            \"[.]pass[.]cpp$\",\n            \"[.]pass[.]mm$\",\n            \"[.]compile[.]pass[.]cpp$\",\n            \"[.]compile[.]pass[.]mm$\",\n            \"[.]compile[.]fail[.]cpp$\",\n            \"[.]link[.]pass[.]cpp$\",\n            \"[.]link[.]pass[.]mm$\",\n            \"[.]link[.]fail[.]cpp$\",\n            \"[.]sh[.][^.]+$\",\n            \"[.]gen[.][^.]+$\",\n            \"[.]verify[.]cpp$\",\n            \"[.]fail[.]cpp$\",\n        ]\n\n        sourcePath = testSuite.getSourcePath(pathInSuite)\n        filename = os.path.basename(sourcePath)\n\n        # Ignore dot files, excluded tests and tests with an unsupported suffix\n        hasSupportedSuffix = lambda f: any([re.search(ext, f) for ext in SUPPORTED_SUFFIXES])\n        if filename.startswith(\".\") or filename in localConfig.excludes or not hasSupportedSuffix(filename):\n            return\n\n        # If this is a generated test, run the generation step and add\n        # as many Lit tests as necessary.\n        if re.search('[.]gen[.][^.]+$', filename):\n            for test in self._generateGenTest(testSuite, pathInSuite, litConfig, localConfig):\n                yield test\n        else:\n            yield lit.Test.Test(testSuite, pathInSuite, localConfig)\n\n    def execute(self, test, litConfig):\n        VERIFY_FLAGS = (\n            \"-Xclang -verify -Xclang -verify-ignore-unexpected=note -ferror-limit=0\"\n        )\n        supportsVerify = \"verify-support\" in test.config.available_features\n        filename = test.path_in_suite[-1]\n\n        if re.search(\"[.]sh[.][^.]+$\", filename):\n            steps = []  # The steps are already in the script\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".compile.pass.cpp\") or filename.endswith(\n            \".compile.pass.mm\"\n        ):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".compile.fail.cpp\"):\n            steps = [\n                \"%dbg(COMPILED WITH) ! %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".link.pass.cpp\") or filename.endswith(\".link.pass.mm\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".link.fail.cpp\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -c -o %t.o\",\n                \"%dbg(LINKED WITH) ! %{cxx} %t.o %{flags} %{link_flags} -o %t.exe\",\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".verify.cpp\"):\n            if not supportsVerify:\n                return lit.Test.Result(\n                    lit.Test.UNSUPPORTED,\n                    \"Test {} requires support for Clang-verify, which isn't supported by the compiler\".format(\n                        test.getFullName()\n                    ),\n                )\n            steps = [\n                # Note: Use -Wno-error to make sure all diagnostics are not treated as errors,\n                #       which doesn't make sense for clang-verify tests.\n                \"%dbg(COMPILED WITH) %{{cxx}} %s %{{flags}} %{{compile_flags}} -fsyntax-only -Wno-error {}\".format(\n                    VERIFY_FLAGS\n                )\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        # Make sure to check these ones last, since they will match other\n        # suffixes above too.\n        elif filename.endswith(\".pass.cpp\") or filename.endswith(\".pass.mm\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\",\n                \"%dbg(EXECUTED AS) %{exec} %t.exe\",\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        else:\n            return lit.Test.Result(\n                lit.Test.UNRESOLVED, \"Unknown test suffix for '{}'\".format(filename)\n            )\n\n    def _executeShTest(self, test, litConfig, steps):\n        if test.config.unsupported:\n            return lit.Test.Result(lit.Test.UNSUPPORTED, \"Test is unsupported\")\n\n        script = parseScript(test, steps)\n        if isinstance(script, lit.Test.Result):\n            return script\n\n        if litConfig.noExecute:\n            return lit.Test.Result(\n                lit.Test.XFAIL if test.isExpectedToFail() else lit.Test.PASS\n            )\n        else:\n            _, tmpBase = _getTempPaths(test)\n            useExternalSh = False\n            return lit.TestRunner._runShTest(\n                test, litConfig, useExternalSh, script, tmpBase\n            )\n\n    def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig):\n        generator = lit.Test.Test(testSuite, pathInSuite, localConfig)\n\n        # Make sure we have a directory to execute the generator test in\n        generatorExecDir = os.path.dirname(testSuite.getExecPath(pathInSuite))\n        os.makedirs(generatorExecDir, exist_ok=True)\n\n        # Run the generator test\n        steps = [] # Steps must already be in the script\n        (out, err, exitCode, _, _) = _executeScriptInternal(generator, litConfig, steps)\n        if exitCode != 0:\n            raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n\n        # Split the generated output into multiple files and generate one test for each file\n        parsed = _parseLitOutput(out)\n        for (subfile, content) in self._splitFile(parsed):\n            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n            os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n            with open(generatedFile, 'w') as f:\n                f.write(content)\n            yield lit.Test.Test(testSuite, (generatedFile,), localConfig)\n\n    def _splitFile(self, input):\n        DELIM = r'^(//|#)---(.+)'\n        lines = input.splitlines()\n        currentFile = None\n        thisFileContent = []\n        for line in lines:\n            match = re.match(DELIM, line)\n            if match:\n                if currentFile is not None:\n                    yield (currentFile, '\\n'.join(thisFileContent))\n                currentFile = match.group(2).strip()\n                thisFileContent = []\n            assert currentFile is not None, f\"Some input to split-file doesn't belong to any file, input was:\\n{input}\"\n            thisFileContent.append(line)\n        if currentFile is not None:\n            yield (currentFile, '\\n'.join(thisFileContent))\n"}, "/llvm/utils/lit/lit/TestRunner.py": {"changes": [{"diff": "\n \n \n def executeBuiltinEcho(cmd, shenv):\n-    \"\"\"Interpret a redirected echo command\"\"\"\n+    \"\"\"Interpret a redirected echo or @echo command\"\"\"\n     opened_files = []\n     stdin, stdout, stderr = processRedirects(cmd, subprocess.PIPE, shenv, opened_files)\n     if stdin != subprocess.PIPE or stderr != subprocess.PIPE:\n         raise InternalShellError(\n-            cmd, \"stdin and stderr redirects not supported for echo\"\n+            cmd, f\"stdin and stderr redirects not supported for {cmd.args[0]}\"\n         )\n \n     # Some tests have un-redirected echo commands to help debug test failures.\n", "add": 2, "remove": 2, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["    \"\"\"Interpret a redirected echo command\"\"\"", "            cmd, \"stdin and stderr redirects not supported for echo\""], "goodparts": ["    \"\"\"Interpret a redirected echo or @echo command\"\"\"", "            cmd, f\"stdin and stderr redirects not supported for {cmd.args[0]}\""]}, {"diff": "\n         if res == -signal.SIGINT:\n             raise KeyboardInterrupt\n         if proc_not_counts[i] % 2:\n-            res = not res\n+            res = 1 if res == 0 else 0\n         elif proc_not_counts[i] > 1:\n             res = 1 if res != 0 else 0\n \n", "add": 1, "remove": 1, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["            res = not res"], "goodparts": ["            res = 1 if res == 0 else 0"]}, {"diff": "\n     return exitCode\n \n \n-def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n+def formatOutput(title, data, limit=None):\n+    if not data.strip():\n+        return \"\"\n+    if not limit is None and len(data) > limit:\n+        data = data[:limit] + \"\\n...\\n\"\n+        msg = \"data was truncated\"\n+    else:\n+        msg = \"\"\n+    ndashes = 30\n+    out =  f\"# .---{title}{'-' * (ndashes - 4 - len(title))}\\n\"\n+    out += f\"# | \" + \"\\n# | \".join(data.splitlines()) + \"\\n\"\n+    out += f\"# `---{msg}{'-' * (ndashes - 4 - len(msg))}\\n\"\n+    return out\n+\n+# Normally returns out, err, exitCode, timeoutInfo.\n+#\n+# If debug is True (the normal lit behavior), err is empty, and out contains an\n+# execution trace, including stdout and stderr shown per command executed.\n+#\n+# If debug is False (set by some custom lit test formats that call this\n+# function), out contains only stdout from the script, err contains only stderr\n+# from the script, and there is no execution trace.\n+def executeScriptInternal(test, litConfig, tmpBase, commands, cwd,\n+                          debug=True):\n     cmds = []\n     for i, ln in enumerate(commands):\n+        # Within lit, we try to always add '%dbg(...)' to command lines in order\n+        # to maximize debuggability.  However, custom lit test formats might not\n+        # always add it, so add a generic debug message in that case.\n         match = re.match(kPdbgRegex, ln)\n         if match:\n+            dbg = match.group(1)\n             command = match.group(2)\n-            ln = commands[i] = match.expand(\": '\\\\1'; \\\\2\" if command else \": '\\\\1'\")\n+        else:\n+            dbg = \"command line\"\n+            command = ln\n+        if debug:\n+            ln = f\"@echo '# {dbg}' \"\n+            if command:\n+                ln += f\"&& @echo {shlex.quote(command.lstrip())} && {command}\"\n+            else:\n+                ln += \"has no command after substitutions\"\n+        else:\n+            ln = command\n         try:\n             cmds.append(\n                 ShUtil.ShParser(ln, litConfig.isWindows, test.config.pipefail).parse()\n             )\n         except:\n-            return lit.Test.Result(Test.FAIL, \"shell parser error on: %r\" % ln)\n+            return lit.Test.Result(\n+                Test.FAIL, f\"shell parser error on {dbg}: {command.lstrip()}\\n\"\n+            )\n \n     cmd = cmds[0]\n     for c in cmds[1:]:\n", "add": 42, "remove": 3, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):", "            ln = commands[i] = match.expand(\": '\\\\1'; \\\\2\" if command else \": '\\\\1'\")", "            return lit.Test.Result(Test.FAIL, \"shell parser error on: %r\" % ln)"], "goodparts": ["def formatOutput(title, data, limit=None):", "    if not data.strip():", "        return \"\"", "    if not limit is None and len(data) > limit:", "        data = data[:limit] + \"\\n...\\n\"", "        msg = \"data was truncated\"", "    else:", "        msg = \"\"", "    ndashes = 30", "    out =  f\"# .---{title}{'-' * (ndashes - 4 - len(title))}\\n\"", "    out += f\"# | \" + \"\\n# | \".join(data.splitlines()) + \"\\n\"", "    out += f\"# `---{msg}{'-' * (ndashes - 4 - len(msg))}\\n\"", "    return out", "def executeScriptInternal(test, litConfig, tmpBase, commands, cwd,", "                          debug=True):", "            dbg = match.group(1)", "        else:", "            dbg = \"command line\"", "            command = ln", "        if debug:", "            ln = f\"@echo '# {dbg}' \"", "            if command:", "                ln += f\"&& @echo {shlex.quote(command.lstrip())} && {command}\"", "            else:", "                ln += \"has no command after substitutions\"", "        else:", "            ln = command", "            return lit.Test.Result(", "                Test.FAIL, f\"shell parser error on {dbg}: {command.lstrip()}\\n\"", "            )"]}, {"diff": "\n \n     out = err = \"\"\n     for i, result in enumerate(results):\n-        # Write the command line run.\n-        out += \"$ %s\\n\" % (\" \".join('\"%s\"' % s for s in result.command.args),)\n+        if not debug:\n+            out += result.stdout\n+            err += result.stderr\n+            continue\n+\n+        # The purpose of an \"@echo\" command is merely to add a debugging message\n+        # directly to lit's output.  It is used internally by lit's internal\n+        # shell and is not currently documented for use in lit tests.  However,\n+        # if someone misuses it (e.g., both \"echo\" and \"@echo\" complain about\n+        # stdin redirection), produce the normal execution trace to facilitate\n+        # debugging.\n+        if (\n+            result.command.args[0] == \"@echo\"\n+            and result.exitCode == 0\n+            and not result.stderr\n+            and not result.outputFiles\n+            and not result.timeoutReached\n+        ):\n+            out += result.stdout\n+            continue\n+\n+        # Write the command line that was run.  Properly quote it.  Leading\n+        # \"!\" commands should not be quoted as that would indicate they are not\n+        # the builtins.\n+        out += \"# executed command: \"\n+        nLeadingBangs = next(\n+            (i for i, cmd in enumerate(result.command.args) if cmd != \"!\"),\n+            len(result.command.args),\n+        )\n+        out += \"! \" * nLeadingBangs\n+        out += \" \".join(\n+            shlex.quote(str(s))\n+            for i, s in enumerate(result.command.args)\n+            if i >= nLeadingBangs\n+        )\n+        out += \"\\n\"\n \n         # If nothing interesting happened, move on.\n         if (\n", "add": 36, "remove": 2, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["        out += \"$ %s\\n\" % (\" \".join('\"%s\"' % s for s in result.command.args),)"], "goodparts": ["        if not debug:", "            out += result.stdout", "            err += result.stderr", "            continue", "        if (", "            result.command.args[0] == \"@echo\"", "            and result.exitCode == 0", "            and not result.stderr", "            and not result.outputFiles", "            and not result.timeoutReached", "        ):", "            out += result.stdout", "            continue", "        out += \"# executed command: \"", "        nLeadingBangs = next(", "            (i for i, cmd in enumerate(result.command.args) if cmd != \"!\"),", "            len(result.command.args),", "        )", "        out += \"! \" * nLeadingBangs", "        out += \" \".join(", "            shlex.quote(str(s))", "            for i, s in enumerate(result.command.args)", "            if i >= nLeadingBangs", "        )", "        out += \"\\n\""]}, {"diff": "\n \n         # Add the command output, if redirected.\n         for (name, path, data) in result.outputFiles:\n-            if data.strip():\n-                out += \"# redirected output from %r:\\n\" % (name,)\n-                data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n-                if len(data) > 1024:\n-                    out += data[:1024] + \"\\n...\\n\"\n-                    out += \"note: data was truncated\\n\"\n-                else:\n-                    out += data\n-                out += \"\\n\"\n-\n+            data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n+            out += formatOutput(\n+                f\"redirected output from '{name}'\", data, limit=1024\n+            )\n         if result.stdout.strip():\n-            out += \"# command output:\\n%s\\n\" % (result.stdout,)\n+            out += formatOutput(\"command stdout\", result.stdout)\n         if result.stderr.strip():\n-            out += \"# command stderr:\\n%s\\n\" % (result.stderr,)\n+            out += formatOutput(\"command stderr\", result.stderr)\n         if not result.stdout.strip() and not result.stderr.strip():\n-            out += \"note: command had no output on stdout or stderr\\n\"\n+            out += \"# note: command had no output on stdout or stderr\\n\"\n \n         # Show the error conditions:\n         if result.exitCode != 0:\n", "add": 7, "remove": 13, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["            if data.strip():", "                out += \"# redirected output from %r:\\n\" % (name,)", "                data = to_string(data.decode(\"utf-8\", errors=\"replace\"))", "                if len(data) > 1024:", "                    out += data[:1024] + \"\\n...\\n\"", "                    out += \"note: data was truncated\\n\"", "                else:", "                    out += data", "                out += \"\\n\"", "            out += \"# command output:\\n%s\\n\" % (result.stdout,)", "            out += \"# command stderr:\\n%s\\n\" % (result.stderr,)", "            out += \"note: command had no output on stdout or stderr\\n\""], "goodparts": ["            data = to_string(data.decode(\"utf-8\", errors=\"replace\"))", "            out += formatOutput(", "                f\"redirected output from '{name}'\", data, limit=1024", "            )", "            out += formatOutput(\"command stdout\", result.stdout)", "            out += formatOutput(\"command stderr\", result.stderr)", "            out += \"# note: command had no output on stdout or stderr\\n\""]}, {"diff": "\n                 codeStr = hex(int(result.exitCode & 0xFFFFFFFF)).rstrip(\"L\")\n             else:\n                 codeStr = str(result.exitCode)\n-            out += \"error: command failed with exit status: %s\\n\" % (codeStr,)\n+            out += \"# error: command failed with exit status: %s\\n\" % (codeStr,)\n         if litConfig.maxIndividualTestTime > 0 and result.timeoutReached:\n-            out += \"error: command reached timeout: %s\\n\" % (\n+            out += \"# error: command reached timeout: %s\\n\" % (\n                 str(result.timeoutReached),\n             )\n \n", "add": 2, "remove": 2, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["            out += \"error: command failed with exit status: %s\\n\" % (codeStr,)", "            out += \"error: command reached timeout: %s\\n\" % ("], "goodparts": ["            out += \"# error: command failed with exit status: %s\\n\" % (codeStr,)", "            out += \"# error: command reached timeout: %s\\n\" % ("]}, {"diff": "\n         if not output or not output[-1].add_continuation(line_number, keyword, line):\n             if output is None:\n                 output = []\n-            pdbg = \"%dbg({keyword} at line {line_number})\".format(\n-                keyword=keyword, line_number=line_number\n-            )\n-            assert re.match(\n-                kPdbgRegex + \"$\", pdbg\n-            ), \"kPdbgRegex expected to match actual %dbg usage\"\n-            line = \"{pdbg} {real_command}\".format(pdbg=pdbg, real_command=line)\n+            line = buildPdbgCommand(f\"{keyword} at line {line_number}\", line)\n             output.append(CommandDirective(line_number, line_number, keyword, line))\n         return output\n \n", "add": 1, "remove": 7, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["            pdbg = \"%dbg({keyword} at line {line_number})\".format(", "                keyword=keyword, line_number=line_number", "            )", "            assert re.match(", "                kPdbgRegex + \"$\", pdbg", "            ), \"kPdbgRegex expected to match actual %dbg usage\"", "            line = \"{pdbg} {real_command}\".format(pdbg=pdbg, real_command=line)"], "goodparts": ["            line = buildPdbgCommand(f\"{keyword} at line {line_number}\", line)"]}]}}, "msg": "[lit] Improve test output from lit's internal shell\n\nThis patch and D154984 were discussed in\n<https://discourse.llvm.org/t/rfc-improving-lits-debug-output/72839>.\n\nMotivation\n----------\n\nD154984 removes the \"Script:\" section that lit prints along with a\ntest's output, and it makes -v and -a imply -vv.  For example, after\nD154984, the \"Script:\" section below is never shown, but -v is enough\nto produce the execution trace following it:\n\n```\n Script:\n --\n : 'RUN: at line 1'; echo hello | FileCheck bogus.txt && echo success\n --\n Exit Code: 2\n\n Command Output (stdout):\n --\n $ \":\" \"RUN: at line 1\"\n $ \"echo\" \"hello\"\n # command output:\n hello\n\n $ \"FileCheck\" \"bogus.txt\"\n # command stderr:\n Could not open check file 'bogus.txt': No such file or directory\n\n error: command failed with exit status: 2\n\n --\n```\n\nIn the D154984 review, some reviewers point out that they have been\nusing the \"Script:\" section for copying and pasting a test's shell\ncommands to a terminal window.  The shell commands as printed in the\nexecution trace can be harder to copy and paste for the following\nreasons:\n\n- They drop redirections and break apart RUN lines at `&&`, `|`, etc.\n- They add `$` at the start of every command, which makes it hard to\n  copy and paste multiple commands in bulk.\n- Command stdout, stderr, etc. are interleaved with the commands and\n  are not clearly delineated.\n- They don't always use proper shell quoting.  Instead, they blindly\n  enclose all command-line arguments in double quotes.\n\nChanges\n-------\n\nD154984 plus this patch converts the above example into:\n\n```\n Exit Code: 2\n\n Command Output (stdout):\n --\n # RUN: at line 1\n echo hello | FileCheck bogus-file.txt && echo success\n # executed command: echo hello\n # .---command stdout------------\n # | hello\n # `-----------------------------\n # executed command: FileCheck bogus-file.txt\n # .---command stderr------------\n # | Could not open check file 'bogus-file.txt': No such file or directory\n # `-----------------------------\n # error: command failed with exit status: 2\n\n --\n```\n\nThus, this patch addresses the above issues as follows:\n\n- The entire execution trace can be copied and pasted in bulk to a\n  terminal for correct execution of the RUN lines, which are printed\n  intact as they appeared in the original RUN lines except lit\n  substitutions are expanded.  Everything else in the execution trace\n  appears in shell comments so it has no effect in a terminal.\n- Each of the RUN line's commands is repeated (in shell comments) as\n  it executes to show (1) that the command actually executed (e.g.,\n  `echo success` above didn't) and (2) what stdout, stderr, non-zero\n  exit status, and output files are associated with the command, if\n  any.  Shell quoting in the command is now correct and minimal but is\n  not necessarily the original shell quoting from the RUN line.\n- The start and end of the contents of stdout, stderr, or an output\n  file is now delineated clearly in the trace.\n\nTo help produce some of the above output, this patch extends lit's\ninternal shell with a built-in `@echo` command.  It's like `echo`\nexcept lit suppresses the normal execution trace for `@echo` and just\nprints its stdout directly.  For now, `@echo` isn't documented for use\nin lit tests.\n\nWithout this patch, libcxx's custom lit test format tries to parse the\nstdout from `lit.TestRunner.executeScriptInternal` (which runs lit's\ninternal shell) to extract the stdout and stderr produced by shell\ncommands, and that parse no longer works after the above changes.\nThis patch makes a small adjustment to\n`lit.TestRunner.executeScriptInternal` so libcxx can just request\nstdout and stderr without an execution trace.\n\n(As a minor drive-by fix that came up in testing: lit's internal `not`\ncommand now always produces a numeric exit status and never `True`.)\n\nCaveat\n------\n\nThis patch only makes the above changes for lit's internal shell.  In\nmost cases, we do not know how to force external shells (e.g., bash,\nsh, window's `cmd`) to produce execution traces in the manner we want.\n\nTo configure a test suite to use lit's internal shell (which is\nusually better for test portability than external shells anyway), add\nthis to the test suite's `lit.cfg` or other configuration file:\n\n```\nconfig.test_format = lit.formats.ShTest(execute_external=False)\n```\n\nReviewed By: MaskRay, awarzynski\n\nDifferential Revision: https://reviews.llvm.org/D156954"}, "f223022a4c521296a6d058862d66443ab9e355bf": {"url": "https://api.github.com/repos/millaker/MiGPU-llvm-project/commits/f223022a4c521296a6d058862d66443ab9e355bf", "html_url": "https://github.com/millaker/MiGPU-llvm-project/commit/f223022a4c521296a6d058862d66443ab9e355bf", "sha": "f223022a4c521296a6d058862d66443ab9e355bf", "keyword": "execution after redirect correct", "diff": "diff --git a/libcxx/utils/libcxx/test/dsl.py b/libcxx/utils/libcxx/test/dsl.py\nindex d2e0c6036dd3..5d4ca83be130 100644\n--- a/libcxx/utils/libcxx/test/dsl.py\n+++ b/libcxx/utils/libcxx/test/dsl.py\n@@ -186,7 +186,7 @@ def programOutput(config, program, args=None):\n                 \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n             )\n \n-        return libcxx.test.format._parseLitOutput(out)\n+        return out\n \n \n @_memoizeExpensiveOperation(\ndiff --git a/libcxx/utils/libcxx/test/format.py b/libcxx/utils/libcxx/test/format.py\nindex ddd88f25646e..c7c0bad681dd 100644\n--- a/libcxx/utils/libcxx/test/format.py\n+++ b/libcxx/utils/libcxx/test/format.py\n@@ -35,39 +35,6 @@ def _checkBaseSubstitutions(substitutions):\n     for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n         assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n \n-def _parseLitOutput(fullOutput):\n-    \"\"\"\n-    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n-\n-    This takes output of the form\n-\n-        $ \":\" \"RUN: at line 11\"\n-        $ \"echo\" \"OUTPUT1\"\n-        # command output:\n-        OUTPUT1\n-\n-        $ \":\" \"RUN: at line 12\"\n-        $ \"echo\" \"OUTPUT2\"\n-        # command output:\n-        OUTPUT2\n-\n-    and returns a string containing\n-\n-        OUTPUT1\n-        OUTPUT2\n-\n-    as-if the commands had been run directly. This is a workaround for the fact\n-    that Lit doesn't let us execute ShTest and retrieve the raw output without\n-    injecting additional Lit output around it.\n-    \"\"\"\n-    parsed = ''\n-    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n-        if output: # skip blank lines\n-            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n-            if commandOutput:\n-                parsed += commandOutput.group(1)\n-    return parsed\n-\n def _executeScriptInternal(test, litConfig, commands):\n     \"\"\"\n     Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n@@ -79,21 +46,12 @@ def _executeScriptInternal(test, litConfig, commands):\n     _, tmpBase = _getTempPaths(test)\n     execDir = os.path.dirname(test.getExecPath())\n     res = lit.TestRunner.executeScriptInternal(\n-        test, litConfig, tmpBase, parsedCommands, execDir\n+        test, litConfig, tmpBase, parsedCommands, execDir, debug=False\n     )\n     if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n         res = (\"\", res.output, 127, None)\n     (out, err, exitCode, timeoutInfo) = res\n \n-    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n-    #       split any stderr output that is included in stdout. It shouldn't be there, but\n-    #       the Lit internal shell conflates stderr and stdout.\n-    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n-    if conflatedErrorOutput:\n-        conflatedErrorOutput = conflatedErrorOutput.group(0)\n-        out = out[: -len(conflatedErrorOutput)]\n-        err += conflatedErrorOutput\n-\n     return (out, err, exitCode, timeoutInfo, parsedCommands)\n \n \n@@ -400,9 +358,8 @@ def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig):\n             raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n \n         # Split the generated output into multiple files and generate one test for each file\n-        parsed = _parseLitOutput(out)\n-        for (subfile, content) in self._splitFile(parsed):\n-            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n+        for subfile, content in self._splitFile(out):\n+            generatedFile = testSuite.getExecPath(pathInSuite + (subfile,))\n             os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n             with open(generatedFile, 'w') as f:\n                 f.write(content)\ndiff --git a/llvm/docs/CommandGuide/lit.rst b/llvm/docs/CommandGuide/lit.rst\nindex b494c74889aa..5e2443cb612a 100644\n--- a/llvm/docs/CommandGuide/lit.rst\n+++ b/llvm/docs/CommandGuide/lit.rst\n@@ -96,10 +96,9 @@ OUTPUT OPTIONS\n \n  Each command is printed before it is executed. This can be valuable for\n  debugging test failures, as the last printed command is the one that failed.\n- Moreover, :program:`lit` inserts a no-op command (``:`` in the case of bash)\n- with argument ``'RUN: at line N'`` before each command pipeline, and those\n- no-op commands are also printed to help you locate the source line of the\n- failed command.\n+ Moreover, :program:`lit` inserts ``'RUN: at line N'`` before each\n+ command pipeline in the output to help you locate the source line of\n+ the failed command.\n \n .. option:: -vv, --echo-all-commands\n \ndiff --git a/llvm/utils/lit/lit/TestRunner.py b/llvm/utils/lit/lit/TestRunner.py\nindex 0539b280a176..f85627eaf3de 100644\n--- a/llvm/utils/lit/lit/TestRunner.py\n+++ b/llvm/utils/lit/lit/TestRunner.py\n@@ -8,6 +8,7 @@\n import stat\n import pathlib\n import platform\n+import shlex\n import shutil\n import tempfile\n import threading\n@@ -348,12 +349,12 @@ def executeBuiltinExport(cmd, shenv):\n \n \n def executeBuiltinEcho(cmd, shenv):\n-    \"\"\"Interpret a redirected echo command\"\"\"\n+    \"\"\"Interpret a redirected echo or @echo command\"\"\"\n     opened_files = []\n     stdin, stdout, stderr = processRedirects(cmd, subprocess.PIPE, shenv, opened_files)\n     if stdin != subprocess.PIPE or stderr != subprocess.PIPE:\n         raise InternalShellError(\n-            cmd, \"stdin and stderr redirects not supported for echo\"\n+            cmd, f\"stdin and stderr redirects not supported for {cmd.args[0]}\"\n         )\n \n     # Some tests have un-redirected echo commands to help debug test failures.\n@@ -700,6 +701,7 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n         \"cd\": executeBuiltinCd,\n         \"export\": executeBuiltinExport,\n         \"echo\": executeBuiltinEcho,\n+        \"@echo\": executeBuiltinEcho,\n         \"mkdir\": executeBuiltinMkdir,\n         \"popd\": executeBuiltinPopd,\n         \"pushd\": executeBuiltinPushd,\n@@ -927,7 +929,7 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n         if res == -signal.SIGINT:\n             raise KeyboardInterrupt\n         if proc_not_counts[i] % 2:\n-            res = not res\n+            res = 1 if res == 0 else 0\n         elif proc_not_counts[i] > 1:\n             res = 1 if res != 0 else 0\n \n@@ -990,19 +992,60 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n     return exitCode\n \n \n-def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n+def formatOutput(title, data, limit=None):\n+    if not data.strip():\n+        return \"\"\n+    if not limit is None and len(data) > limit:\n+        data = data[:limit] + \"\\n...\\n\"\n+        msg = \"data was truncated\"\n+    else:\n+        msg = \"\"\n+    ndashes = 30\n+    # fmt: off\n+    out =  f\"# .---{title}{'-' * (ndashes - 4 - len(title))}\\n\"\n+    out += f\"# | \" + \"\\n# | \".join(data.splitlines()) + \"\\n\"\n+    out += f\"# `---{msg}{'-' * (ndashes - 4 - len(msg))}\\n\"\n+    # fmt: on\n+    return out\n+\n+\n+# Normally returns out, err, exitCode, timeoutInfo.\n+#\n+# If debug is True (the normal lit behavior), err is empty, and out contains an\n+# execution trace, including stdout and stderr shown per command executed.\n+#\n+# If debug is False (set by some custom lit test formats that call this\n+# function), out contains only stdout from the script, err contains only stderr\n+# from the script, and there is no execution trace.\n+def executeScriptInternal(test, litConfig, tmpBase, commands, cwd, debug=True):\n     cmds = []\n     for i, ln in enumerate(commands):\n+        # Within lit, we try to always add '%dbg(...)' to command lines in order\n+        # to maximize debuggability.  However, custom lit test formats might not\n+        # always add it, so add a generic debug message in that case.\n         match = re.fullmatch(kPdbgRegex, ln)\n         if match:\n+            dbg = match.group(1)\n             command = match.group(2)\n-            ln = commands[i] = match.expand(\": '\\\\1'; \\\\2\" if command else \": '\\\\1'\")\n+        else:\n+            dbg = \"command line\"\n+            command = ln\n+        if debug:\n+            ln = f\"@echo '# {dbg}' \"\n+            if command:\n+                ln += f\"&& @echo {shlex.quote(command.lstrip())} && {command}\"\n+            else:\n+                ln += \"has no command after substitutions\"\n+        else:\n+            ln = command\n         try:\n             cmds.append(\n                 ShUtil.ShParser(ln, litConfig.isWindows, test.config.pipefail).parse()\n             )\n         except:\n-            return lit.Test.Result(Test.FAIL, \"shell parser error on: %r\" % ln)\n+            return lit.Test.Result(\n+                Test.FAIL, f\"shell parser error on {dbg}: {command.lstrip()}\\n\"\n+            )\n \n     cmd = cmds[0]\n     for c in cmds[1:]:\n@@ -1022,8 +1065,42 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n \n     out = err = \"\"\n     for i, result in enumerate(results):\n-        # Write the command line run.\n-        out += \"$ %s\\n\" % (\" \".join('\"%s\"' % s for s in result.command.args),)\n+        if not debug:\n+            out += result.stdout\n+            err += result.stderr\n+            continue\n+\n+        # The purpose of an \"@echo\" command is merely to add a debugging message\n+        # directly to lit's output.  It is used internally by lit's internal\n+        # shell and is not currently documented for use in lit tests.  However,\n+        # if someone misuses it (e.g., both \"echo\" and \"@echo\" complain about\n+        # stdin redirection), produce the normal execution trace to facilitate\n+        # debugging.\n+        if (\n+            result.command.args[0] == \"@echo\"\n+            and result.exitCode == 0\n+            and not result.stderr\n+            and not result.outputFiles\n+            and not result.timeoutReached\n+        ):\n+            out += result.stdout\n+            continue\n+\n+        # Write the command line that was run.  Properly quote it.  Leading\n+        # \"!\" commands should not be quoted as that would indicate they are not\n+        # the builtins.\n+        out += \"# executed command: \"\n+        nLeadingBangs = next(\n+            (i for i, cmd in enumerate(result.command.args) if cmd != \"!\"),\n+            len(result.command.args),\n+        )\n+        out += \"! \" * nLeadingBangs\n+        out += \" \".join(\n+            shlex.quote(str(s))\n+            for i, s in enumerate(result.command.args)\n+            if i >= nLeadingBangs\n+        )\n+        out += \"\\n\"\n \n         # If nothing interesting happened, move on.\n         if (\n@@ -1038,22 +1115,14 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n \n         # Add the command output, if redirected.\n         for (name, path, data) in result.outputFiles:\n-            if data.strip():\n-                out += \"# redirected output from %r:\\n\" % (name,)\n-                data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n-                if len(data) > 1024:\n-                    out += data[:1024] + \"\\n...\\n\"\n-                    out += \"note: data was truncated\\n\"\n-                else:\n-                    out += data\n-                out += \"\\n\"\n-\n+            data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n+            out += formatOutput(f\"redirected output from '{name}'\", data, limit=1024)\n         if result.stdout.strip():\n-            out += \"# command output:\\n%s\\n\" % (result.stdout,)\n+            out += formatOutput(\"command stdout\", result.stdout)\n         if result.stderr.strip():\n-            out += \"# command stderr:\\n%s\\n\" % (result.stderr,)\n+            out += formatOutput(\"command stderr\", result.stderr)\n         if not result.stdout.strip() and not result.stderr.strip():\n-            out += \"note: command had no output on stdout or stderr\\n\"\n+            out += \"# note: command had no output on stdout or stderr\\n\"\n \n         # Show the error conditions:\n         if result.exitCode != 0:\n@@ -1063,9 +1132,9 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n                 codeStr = hex(int(result.exitCode & 0xFFFFFFFF)).rstrip(\"L\")\n             else:\n                 codeStr = str(result.exitCode)\n-            out += \"error: command failed with exit status: %s\\n\" % (codeStr,)\n+            out += \"# error: command failed with exit status: %s\\n\" % (codeStr,)\n         if litConfig.maxIndividualTestTime > 0 and result.timeoutReached:\n-            out += \"error: command reached timeout: %s\\n\" % (\n+            out += \"# error: command reached timeout: %s\\n\" % (\n                 str(result.timeoutReached),\n             )\n \n@@ -2117,6 +2186,8 @@ def executeShTest(\n         return lit.Test.Result(Test.UNSUPPORTED, \"Test is unsupported\")\n \n     script = list(preamble_commands)\n+    script = [buildPdbgCommand(f\"preamble command line\", ln) for ln in script]\n+\n     parsed = parseIntegratedTestScript(test, require_script=not script)\n     if isinstance(parsed, lit.Test.Result):\n         return parsed\ndiff --git a/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg b/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\nindex cf1a4f1ba1ec..301208c25bdc 100644\n--- a/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\n+++ b/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\n@@ -5,4 +5,4 @@ config.suffixes = [\".txt\"]\n config.test_format = lit.formats.ShTest()\n config.test_source_root = None\n config.test_exec_root = None\n-config.substitutions.append((\"%var\", lit_config.params.get(\"var\", \"\")))\n+config.substitutions.append((\"%var\", lit_config.params.get(\"var\", \"default\")))\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt b/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\nindex 6dd9b16304e0..1d94c1213723 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\n@@ -14,21 +14,21 @@\n ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0 -fopenmp-simd\n ; REDEFINE: %{fcflags} = -check-prefix=SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu -fopenmp-simd\n ; REDEFINE: %{fcflags} = -check-prefix=SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0\n ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu\n ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n \n ; CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt b/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\nindex 3bf057151afb..23c0a6d50753 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\n@@ -7,7 +7,7 @@\n #\n # REDEFINE: %{global:greeting}=Hello\n # RUN: %{global:echo}\n-# CHECK: GLOBAL: Hello World\n+# CHECK:# | GLOBAL: Hello World\n \n # We can redefine the test suite config's substitutions multiple times.  Again,\n # the expansion order remains the same (%{global:echo} before %{global:greeting}\n@@ -17,7 +17,7 @@\n # REDEFINE: %{global:greeting}=Goodbye %{global:what}\n # REDEFINE: %{global:what}=Sleep\n # RUN: %{global:echo}\n-# CHECK: GLOBAL: Goodbye Sleep Sleep\n+# CHECK:# | GLOBAL: Goodbye Sleep Sleep\n \n # A new local substitution is prepended to the substitution list so that it can\n # depend on all substitutions that were defined previously, including those from\n@@ -26,7 +26,7 @@\n # DEFINE: %{local:greeting}=Hey %{global:what}\n # DEFINE: %{local:echo}=echo \"LOCAL: %{local:greeting} %{global:what}\"\n # RUN: %{local:echo}\n-# CHECK: LOCAL: Hey Sleep Sleep\n+# CHECK:# | LOCAL: Hey Sleep Sleep\n \n # As for substitutions from the test suite config, redefining local\n # substitutions should not change the expansion order.  Again, the expansion\n@@ -36,6 +36,6 @@\n # REDEFINE: %{local:greeting}=So Long %{global:what}\n # REDEFINE: %{global:what}=World\n # RUN: %{local:echo}\n-# CHECK: LOCAL: So Long World World\n+# CHECK:# | LOCAL: So Long World World\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt b/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\nindex 65f90792ff7b..5a1d7f2e1987 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\n@@ -1,19 +1,19 @@\n # Does it work as expected directly in RUN lines?\n # RUN: echo %(line), %(line-1), %(line+2)\n-# CHECK: [[#@LINE-1]], [[#@LINE-2]], [[#@LINE+1]]\n+# CHECK:# | [[#@LINE-1]], [[#@LINE-2]], [[#@LINE+1]]\n \n # %(line) substitutions refer to the original DEFINE/REDEFINE line not the RUN\n # line they eventually appear within.\n #\n # DEFINE: %{lines} = %(line)\n # RUN: echo '%{lines}'\n-# CHECK: [[#@LINE-2]]\n+# CHECK:# | [[#@LINE-2]]\n #\n # REDEFINE: %{lines} = %(line),                                                \\\n # REDEFINE:            %(line),                                                \\\n # REDEFINE:            %(line)\n # RUN: echo '%{lines}'\n-# CHECK: [[#@LINE-4]], [[#@LINE-3]], [[#@LINE-2]]\n+# CHECK:# | [[#@LINE-4]], [[#@LINE-3]], [[#@LINE-2]]\n \n # %(line+N) and %{line-N) should work too.\n #\n@@ -21,12 +21,12 @@\n # DEFINE:                %(line),                                              \\\n # DEFINE:                %(line-1)\n # RUN: echo '%{lines-rel}'\n-# CHECK: [[#@LINE-3]], [[#@LINE-3]], [[#@LINE-3]]\n+# CHECK:# | [[#@LINE-3]], [[#@LINE-3]], [[#@LINE-3]]\n #\n # REDEFINE: %{lines-rel} = %(line+5),                                          \\\n # REDEFINE:                %(line+0),                                          \\\n # REDEFINE:                %(line-10)\n # RUN: echo '%{lines-rel}'\n-# CHECK: [[#@LINE+1]], [[#@LINE-3]], [[#@LINE-12]]\n+# CHECK:# | [[#@LINE+1]], [[#@LINE-3]], [[#@LINE-12]]\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt b/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\nindex 18a27cdd72fa..d27fda2e2fe6 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\n@@ -1,25 +1,25 @@\n # DEFINE: %{abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789} = ok\n # RUN: echo '%{abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789}'\n-# CHECK: ok\n+# CHECK:# | ok\n \n # DEFINE: %{FooBar} = ok at %(line)\n # RUN: echo '%{FooBar}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{fooBar} = ok at %(line)\n # RUN: echo '%{fooBar}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{foo-bar-} = ok at %(line)\n # RUN: echo '%{foo-bar-}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{foo:bar:} = ok at %(line)\n # RUN: echo '%{foo:bar:}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{_foo_bar_} = ok at %(line)\n # RUN: echo '%{_foo_bar_}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt b/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\nindex eb5f0b918fd1..e504b822ace8 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\n@@ -6,7 +6,7 @@\n \n # RUN: echo '%{outer}'\n \n-# CHECK-NON-RECUR:%{inner}\n-# CHECK-RECUR:expanded\n+# CHECK-NON-RECUR:# | %{inner}\n+# CHECK-RECUR:# | expanded\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt b/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\nindex 9d2e7197fb3a..c1bdfef30b1a 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\n@@ -2,21 +2,21 @@\n \n # DEFINE: %{equals} = FileCheck -check-prefixes=FOO,BAR\n # RUN: echo '%{equals}'\n-# CHECK: FileCheck -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -check-prefixes=FOO,BAR\n #\n # REDEFINE: %{equals} == == =\n # RUN: echo '%{equals}'\n-# CHECK: = == =\n+# CHECK:# | = == =\n \n # DEFINE: %{continue-equals} = FileCheck -strict-whitespace -match-full-lines \\\n # DEFINE:                      -check-prefixes=FOO,BAR\n # RUN: echo '%{continue-equals}'\n-# CHECK: FileCheck -strict-whitespace -match-full-lines -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -strict-whitespace -match-full-lines -check-prefixes=FOO,BAR\n #\n # REDEFINE: %{continue-equals} = FileCheck -input-file=test.txt                \\\n # REDEFINE:                      -implicit-check-not=foobar                    \\\n # REDEFINE:                      -check-prefixes=FOO,BAR\n # RUN: echo '%{continue-equals}'\n-# CHECK: FileCheck -input-file=test.txt -implicit-check-not=foobar -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -input-file=test.txt -implicit-check-not=foobar -check-prefixes=FOO,BAR\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt b/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\nindex 58d5c1a34ce8..9143796edd32 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\n@@ -6,11 +6,11 @@\n \n # DEFINE: %{escape} = \\g<0>\\n\n # RUN: echo '%{escape}'\n-# CHECK: {{\\\\?}}\\g<0>{{\\\\?}}\\n\n+# CHECK:# | {{\\\\?}}\\g<0>{{\\\\?}}\\n\n \n # REDEFINE: %{escape} = \\n                                                     \\\n # REDEFINE:             \\g<param>\n # RUN: echo '%{escape}'\n-# CHECK: {{\\\\?}}\\n {{\\\\?}}\\g<param>\n+# CHECK:# | {{\\\\?}}\\n {{\\\\?}}\\g<param>\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt b/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\nindex 1259e511ba70..3e4db1b15d92 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\n@@ -3,33 +3,33 @@\n #\n # DEFINE: %{empty}=\n # RUN: echo \"'%{empty}'\"\n-# CHECK:''\n+# CHECK:# | ''\n #\n # REDEFINE: %{empty}=\n # RUN: echo \"'%{empty}'\"\n-# CHECK:''\n+# CHECK:# | ''\n \n # A value consisting only of whitespace is trimmed to the empty string.\n #\n #               v~~ intentional whitespace\n # DEFINE: %{ws}=   \n # RUN: echo \"'%{ws}'\"\n-# CHECK:''\n+# CHECK:# | ''\n #\n #                 v intentional whitespace\n # REDEFINE: %{ws}= \n # RUN: echo \"'%{ws}'\"\n-# CHECK:''\n+# CHECK:# | ''\n \n # Whitespace is not required around the name or value.\n #\n # DEFINE:%{no-whitespace}=abc\n # RUN: echo \"'%{no-whitespace}'\"\n-# CHECK:'abc'\n+# CHECK:# | 'abc'\n #\n # REDEFINE:%{no-whitespace}=HelloWorld\n # RUN: echo \"'%{no-whitespace}'\"\n-# CHECK:'HelloWorld'\n+# CHECK:# | 'HelloWorld'\n \n # Whitespace is not required between substitutions in a value.\n #\n@@ -37,11 +37,11 @@\n # DEFINE: %{adjacent1} = bar\n # DEFINE: %{has-adjacent-substs} = %{adjacent0}%{adjacent1}\n # RUN: echo \"'%{has-adjacent-substs}'\"\n-# CHECK:'foobar'\n+# CHECK:# | 'foobar'\n #\n # REDEFINE: %{has-adjacent-substs} = %{adjacent0}%{adjacent1}%{adjacent0}\n # RUN: echo \"'%{has-adjacent-substs}'\"\n-# CHECK:'foobarfoo'\n+# CHECK:# | 'foobarfoo'\n \n # Exact whitespace is preserved within the value, but whitespace enclosing the\n # name or value is discarded.  ('%{' and '}' are part of the name, and\n@@ -50,11 +50,11 @@\n #                                       v~~ intentional whitespace\n # DEFINE:   %{whitespace}  =  abc    def   \n # RUN: echo \"'%{whitespace}'\"\n-# CHECK:'abc    def'\n+# CHECK:# | 'abc    def'\n #                                      v intentional whitespace\n # REDEFINE: %{whitespace} = Hello World \n # RUN: echo \"'%{whitespace}'\"\n-# CHECK:'Hello World'\n+# CHECK:# | 'Hello World'\n \n # Line continuations in the value are permitted and collapse whitespace.\n #\n@@ -66,12 +66,12 @@\n # DEFINE:  pqr \n #             ^ intentional whitespace\n # RUN: echo \"'%{continue}'\"\n-# CHECK:'abc def ghi jkl mno pqr'\n+# CHECK:# | 'abc def ghi jkl mno pqr'\n #\n # REDEFINE: %{continue} =  abc  \\\n # REDEFINE: def\n # RUN: echo \"'%{continue}'\"\n-# CHECK:'abc def'\n+# CHECK:# | 'abc def'\n \n # Whitespace at the end of the line after a '\\' is ignored, and it's treated as\n # a line continuation.  Otherwise, the behavior would be hard to understand\n@@ -83,7 +83,7 @@\n #                                   ^ intentional whitespace\n # DEFINE: baz\n # RUN: echo \"'%{ws-after-continue}'\"\n-# CHECK:'foo bar baz'\n+# CHECK:# | 'foo bar baz'\n #\n #                                     v intentional whitespace\n # REDEFINE: %{ws-after-continue}=foo \\ \n@@ -91,7 +91,7 @@\n #                                     ^~~~~~~~~~~~ intentional whitespace\n # REDEFINE: baz\n # RUN: echo \"'%{ws-after-continue}'\"\n-# CHECK:'foo bar baz'\n+# CHECK:# | 'foo bar baz'\n \n # A line continuation is recognized anywhere.  It should be used only where\n # whitespace is permitted because it reduces to a single space.\n@@ -107,7 +107,7 @@\n # DEFINE:\\\n # DEFINE:a\n # RUN: echo \"'%{blank-lines}'\"\n-# CHECK:'a'\n+# CHECK:# | 'a'\n #\n # REDEFINE:                  \\\n # REDEFINE: %{blank-lines}   \\\n@@ -120,7 +120,7 @@\n # REDEFINE:                  \\\n # REDEFINE:      c\n # RUN: echo \"'%{blank-lines}'\"\n-# CHECK:'a b c'\n+# CHECK:# | 'a b c'\n \n # The fourth DEFINE line is deceptive because it looks like a new substitution,\n # but it's actually a continuation of the previous value.\n@@ -130,6 +130,6 @@\n # DEFINE: %{deceptive-continue}=echo \\\n # DEFINE: %{name}=%{value}\n # RUN: %{deceptive-continue}\n-# CHECK:x=3\n+# CHECK:# | x=3\n \n # CHECK:{{ *}}Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt b/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\nindex b0a7cfd97941..b5fc1b49fcc5 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\n@@ -1,46 +1,34 @@\n-#       CHECK: -- Testing:{{.*}}\n-#  CHECK-NEXT: PASS: shtest-if-else :: test.txt (1 of 1)\n-#  CHECK-NEXT: Exit Code: 0\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: Command Output (stdout):\n-#  CHECK-NEXT: --\n+# CHECK: -- Testing:{{.*}}\n+# CHECK-NEXT: PASS: shtest-if-else :: test.txt (1 of 1)\n+#      CHECK: Command Output (stdout):\n+# CHECK-NEXT: --\n \n # RUN: %if feature %{ echo \"test-1\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-1\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-1\"\n \n # If %else is not present it is treated like %else %{%}. Empty commands\n # are ignored.\n #\n # RUN: %if nofeature %{ echo \"fail\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#   CHECK-NOT: fail\n+#     CHECK: # {{RUN}}: at line [[#@LINE-1]] has no command after substitutions\n+# CHECK-NOT: fail\n \n # RUN: %if nofeature %{ echo \"fail\" %} %else %{ echo \"test-2\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-2\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-2\"\n \n # Spaces inside curly braces are not ignored\n #\n # RUN: echo test-%if feature %{ 3 %} %else %{ fail %}-test\n # RUN: echo test-%if feature %{ 4 4 %} %else %{ fail %}-test\n # RUN: echo test-%if nofeature %{ fail %} %else %{ 5 5 %}-test\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 3 -test\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 4 4 -test\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 5 5 -test\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo test- 3 -test\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo test- 4 4 -test\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo test- 5 5 -test\n \n # Escape line breaks for multi-line expressions\n #\n@@ -48,42 +36,32 @@\n # RUN:   %{ echo     \\\n # RUN:     \"test-5\" \\\n # RUN:   %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-4]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-5\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-5\"\n \n # RUN: %if nofeature       \\\n # RUN:   %{ echo \"fail\" %}   \\\n # RUN: %else               \\\n # RUN:   %{ echo \"test-6\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-4]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-6\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-6\"\n \n # RUN: echo \"test%if feature %{%} %else %{%}-7\"\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-7\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-7\"\n \n # Escape %if. Without %if..%else context '%{' and '%}' are treated\n # literally.\n #\n # RUN: echo %%if feature %{ echo \"test-8\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: %if feature %{ echo test-8 %}\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo %if feature %{ echo \"test-8\" %}\n \n # Nested expressions are supported:\n #\n # RUN: echo %if feature %{ %if feature %{ %if nofeature %{\"fail\"%} %else %{\"test-9\"%} %} %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-9\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-9\"\n \n # Binary expression evaluation and regex match can be used as\n # conditions.\n@@ -91,18 +69,12 @@\n # RUN: echo %if feature && !nofeature %{ \"test-10\" %}\n # RUN: echo %if feature && nofeature %{ \"fail\" %} %else %{ \"test-11\" %}\n # RUN: echo %if {{fea.+}} %{ \"test-12\" %} %else %{ \"fail\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-10\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-11\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-12\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo \"test-10\"\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-11\"\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo \"test-12\"\n \n # Spaces between %if and %else are ignored. If there is no %else -\n # space after %if %{...%} is not ignored.\n@@ -110,39 +82,27 @@\n # RUN: echo XX %if feature %{YY%} ZZ\n # RUN: echo AA %if feature %{BB%} %else %{CC%} DD\n # RUN: echo AA %if nofeature %{BB%} %else %{CC%} DD\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: XX YY ZZ\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: AA BB DD\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: AA CC DD\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo XX YY ZZ\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo AA BB DD\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo AA CC DD\n \n # '{' and '}' can be used without escaping\n #\n # RUN: %if feature %{echo {}%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: {}\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo {}\n \n # Spaces are not required\n #\n # RUN: echo %if feature%{\"ok\"%}%else%{\"fail\"%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: ok\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"ok\"\n \n # Substitutions with braces are handled correctly\n #\n # RUN: echo %{sub} %if feature%{test-%{sub}%}%else%{\"fail\"%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: ok test-ok\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo ok test-ok\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt b/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\nindex fb3a3e000789..5ff0c891450b 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\n@@ -1,3 +1,4 @@\n # RUN: true\n # RUN: echo hi\n-# RUN: not not wc missing-file &> %t.out\n+# RUN: not not wc missing-file &> %t.out || true\n+# RUN: not %{python} %S/write-a-lot.py &> %t.out\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg b/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\nindex b872854d21e6..141fc3a596e7 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\n@@ -2,4 +2,5 @@ import lit.formats\n \n config.name = \"shtest-output-printing\"\n config.suffixes = [\".txt\"]\n+config.substitutions.append((\"%{python}\", f'\"{sys.executable}\"'))\n config.test_format = lit.formats.ShTest(execute_external=False)\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py b/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py\nnew file mode 100644\nindex 000000000000..5dbb94a41cbf\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py\n@@ -0,0 +1,6 @@\n+#!/usr/bin/env python\n+\n+import sys\n+\n+sys.stdout.write(\"All work and no play makes Jack a dull boy.\\n\" * 1000)\n+sys.stdout.flush()\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt\nnew file mode 100644\nindex 000000000000..15a87aee46a3\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt\n@@ -0,0 +1 @@\n+RUN: @echo 2> %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt\nnew file mode 100644\nindex 000000000000..27fd0c4209fd\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt\n@@ -0,0 +1,2 @@\n+RUN: touch %t\n+RUN: @echo < %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt\nnew file mode 100644\nindex 000000000000..9611918f7e12\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt\n@@ -0,0 +1 @@\n+RUN: echo 2> %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt\nnew file mode 100644\nindex 000000000000..bc771be6b22a\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt\n@@ -0,0 +1,2 @@\n+RUN: touch %t\n+RUN: echo < %t\ndiff --git a/llvm/utils/lit/tests/allow-retries.py b/llvm/utils/lit/tests/allow-retries.py\nindex bf6c04193388..45610fb70d34 100644\n--- a/llvm/utils/lit/tests/allow-retries.py\n+++ b/llvm/utils/lit/tests/allow-retries.py\n@@ -15,9 +15,28 @@\n \n # This test does not succeed within the allowed retry limit\n #\n-# RUN: not %{lit} %{inputs}/allow-retries/does-not-succeed-within-limit.py | FileCheck --check-prefix=CHECK-TEST3 %s\n-# CHECK-TEST3: Failed Tests (1):\n-# CHECK-TEST3: allow-retries :: does-not-succeed-within-limit.py\n+# Check that the execution trace isn't corrupt due to reprocessing the script\n+# multiple times (e.g., '%dbg(...)' processing used to accumulate across\n+# retries).\n+#\n+# RUN: not %{lit} %{inputs}/allow-retries/does-not-succeed-within-limit.py -v |\\\n+# RUN:   FileCheck --check-prefix=CHECK-TEST3 -match-full-lines %s\n+#\n+#       CHECK-TEST3: FAIL: allow-retries :: does-not-succeed-within-limit.py (1 of 1)\n+#  CHECK-TEST3-NEXT: {{\\**}} TEST 'allow-retries :: does-not-succeed-within-limit.py' FAILED {{\\**}}\n+#  CHECK-TEST3-NEXT: Exit Code: 1\n+# CHECK-TEST3-EMPTY:\n+#  CHECK-TEST3-NEXT: Command Output (stdout):\n+#  CHECK-TEST3-NEXT: --\n+#  CHECK-TEST3-NEXT: # {{RUN}}: at line 3\n+#  CHECK-TEST3-NEXT: false\n+#  CHECK-TEST3-NEXT: # executed command: false\n+#  CHECK-TEST3-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-TEST3-NEXT: # error: command failed with exit status: 1\n+# CHECK-TEST3-EMPTY:\n+#  CHECK-TEST3-NEXT: --\n+#       CHECK-TEST3: Failed Tests (1):\n+#       CHECK-TEST3: allow-retries :: does-not-succeed-within-limit.py\n \n # This test should be UNRESOLVED since it has more than one ALLOW_RETRIES\n # lines, and that is not allowed.\n@@ -48,6 +67,6 @@\n # RUN:     -Dcounter=%t.counter -Dpython=%{python} | \\\n # RUN:   FileCheck --check-prefix=CHECK-TEST7 %s\n #     CHECK-TEST7: Command Output (stdout):\n-#     CHECK-TEST7: LLVM_PROFILE_FILE=\n-# CHECK-TEST7-NOT: LLVM_PROFILE_FILE=\n+#     CHECK-TEST7: # executed command: export LLVM_PROFILE_FILE=\n+# CHECK-TEST7-NOT: # executed command: export LLVM_PROFILE_FILE=\n #     CHECK-TEST7: Passed With Retry: 1\ndiff --git a/llvm/utils/lit/tests/lit-opts.py b/llvm/utils/lit/tests/lit-opts.py\nindex d292ca74f3b9..a533a59d9d12 100644\n--- a/llvm/utils/lit/tests/lit-opts.py\n+++ b/llvm/utils/lit/tests/lit-opts.py\n@@ -8,7 +8,7 @@\n #\n # RUN: env LIT_OPTS=-a \\\n # RUN: %{lit} -s %{inputs}/lit-opts \\\n-# RUN: | FileCheck -check-prefix=SHOW-ALL -DVAR= %s\n+# RUN: | FileCheck -check-prefix=SHOW-ALL -DVAR=default %s\n \n # Check that LIT_OPTS understands multiple options with arbitrary spacing.\n #\n@@ -28,6 +28,6 @@\n \n # SHOW-ALL:     Testing: 1 tests\n # SHOW-ALL:     PASS: lit-opts :: test.txt (1 of 1)\n-# SHOW-ALL:     {{^}}[[VAR]]\n+# SHOW-ALL:     echo [[VAR]]\n # SHOW-ALL-NOT: PASS\n # SHOW-ALL:     Passed: 1\ndiff --git a/llvm/utils/lit/tests/shtest-define.py b/llvm/utils/lit/tests/shtest-define.py\nindex 1d0997bbbaf8..8c9309804cce 100644\n--- a/llvm/utils/lit/tests/shtest-define.py\n+++ b/llvm/utils/lit/tests/shtest-define.py\n@@ -136,15 +136,15 @@\n # RUN: %{lit} -va %{my-inputs}/shared-substs-*.txt 2>&1 |                      \\\n # RUN:   FileCheck -check-prefix=SHARED-SUBSTS -match-full-lines %s\n #\n-# SHARED-SUBSTS: shared-substs-0.txt\n-# SHARED-SUBSTS: GLOBAL: World\n-# SHARED-SUBSTS: LOCAL0: LOCAL0:Hello LOCAL0:World\n-# SHARED-SUBSTS: LOCAL0: subst\n+# SHARED-SUBSTS:# | shared-substs-0.txt\n+# SHARED-SUBSTS:# | GLOBAL: World\n+# SHARED-SUBSTS:# | LOCAL0: LOCAL0:Hello LOCAL0:World\n+# SHARED-SUBSTS:# | LOCAL0: subst\n #\n-# SHARED-SUBSTS: shared-substs-1.txt\n-# SHARED-SUBSTS: GLOBAL: World\n-# SHARED-SUBSTS: LOCAL1: LOCAL1:Hello LOCAL1:World\n-# SHARED-SUBSTS: LOCAL1: subst\n+# SHARED-SUBSTS:# | shared-substs-1.txt\n+# SHARED-SUBSTS:# | GLOBAL: World\n+# SHARED-SUBSTS:# | LOCAL1: LOCAL1:Hello LOCAL1:World\n+# SHARED-SUBSTS:# | LOCAL1: subst\n #\n # REDEFINE: %{test} = shared-substs-0.txt\n # RUN: %{record-test}\ndiff --git a/llvm/utils/lit/tests/shtest-env.py b/llvm/utils/lit/tests/shtest-env.py\nindex f2e8216f7f4a..c093b62e5420 100644\n--- a/llvm/utils/lit/tests/shtest-env.py\n+++ b/llvm/utils/lit/tests/shtest-env.py\n@@ -10,88 +10,115 @@\n # CHECK: -- Testing: 16 tests{{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-assign.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"FOO=1\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env FOO=1\n+# CHECK: # executed command: env FOO=1\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-u-arg.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO\n+# CHECK: # executed command: env -u FOO\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-u.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u\n+# CHECK: # executed command: env -u\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-nested-none.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"env\" \"env\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env env env\n+# CHECK: # executed command: env env env\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-none.txt ({{[^)]*}})\n-# CHECK: $ \"env\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env\n+# CHECK: # executed command: env\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-cd.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"cd\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'cd'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 cd foobar\n+# CHECK: # executed command: env -u FOO BAR=3 cd foobar\n+# CHECK: # | Error: 'env' cannot call 'cd'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-colon.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \":\"\n-# CHECK: Error: 'env' cannot call ':'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 :\n+# CHECK: # executed command: env -u FOO BAR=3 :\n+# CHECK: # | Error: 'env' cannot call ':'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-echo.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"echo\" \"hello\" \"world\"\n-# CHECK: Error: 'env' cannot call 'echo'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 echo hello world\n+# CHECK: # executed command: env -u FOO BAR=3 echo hello world\n+# CHECK: # | Error: 'env' cannot call 'echo'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: PASS: shtest-env :: env-calls-env.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"env\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"FOO=2\" \"env\" \"BAR=1\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"env\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=1\" \"env\" \"-u\" \"BAR\" \"FOO=2\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=1\" \"env\" \"-u\" \"BAR\" \"FOO=2\" \"env\" \"BAZ=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env env [[PYTHON:.+]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env env [[PYTHON_BARE:.+]] print_environment.py\n+# CHECK: env FOO=2 env BAR=1 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env FOO=2 env BAR=1 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO env -u BAR [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO env -u BAR [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO BAR=1 env -u BAR FOO=2 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO BAR=1 env -u BAR FOO=2 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO BAR=1 env -u BAR FOO=2 env BAZ=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO BAR=1 env -u BAR FOO=2 env BAZ=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: FAIL: shtest-env :: env-calls-export.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"export\" \"BAZ=3\"\n-# CHECK: Error: 'env' cannot call 'export'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 export BAZ=3\n+# CHECK: # executed command: env -u FOO BAR=3 export BAZ=3\n+# CHECK: # | Error: 'env' cannot call 'export'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-mkdir.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"mkdir\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'mkdir'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 mkdir foobar\n+# CHECK: # executed command: env -u FOO BAR=3 mkdir foobar\n+# CHECK: # | Error: 'env' cannot call 'mkdir'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-not-builtin.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"not\" \"rm\" \"{{.*}}.no-such-file\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 not rm {{.+}}.no-such-file\n+# CHECK: # executed command: env -u FOO BAR=3 not rm {{.+}}.no-such-file{{.*}}\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-rm.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"rm\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 rm foobar\n+# CHECK: # executed command: env -u FOO BAR=3 rm foobar\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: PASS: shtest-env :: env-u.txt ({{[^)]*}})\n-# CHECK: $ \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: env -u FOO [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO -u BAR [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO -u BAR [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: PASS: shtest-env :: env.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"A_FOO=999\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"A_FOO=1\" \"B_BAR=2\" \"C_OOF=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env A_FOO=999 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=999 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env A_FOO=1 B_BAR=2 C_OOF=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=1 B_BAR=2 C_OOF=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: PASS: shtest-env :: mixed.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"A_FOO=999\" \"-u\" \"FOO\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"A_FOO=1\" \"-u\" \"FOO\" \"B_BAR=2\" \"-u\" \"BAR\" \"C_OOF=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env A_FOO=999 -u FOO [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=999 -u FOO [[PYTHON_BARE]] print_environment.py\n+# CHECK: env A_FOO=1 -u FOO B_BAR=2 -u BAR C_OOF=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=1 -u FOO B_BAR=2 -u BAR C_OOF=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: Passed:  4\n # CHECK: Failed: 12\ndiff --git a/llvm/utils/lit/tests/shtest-format.py b/llvm/utils/lit/tests/shtest-format.py\nindex 621776ab7bc2..4a3d65b7bce4 100644\n--- a/llvm/utils/lit/tests/shtest-format.py\n+++ b/llvm/utils/lit/tests/shtest-format.py\n@@ -43,13 +43,21 @@\n # CHECK-EMPTY:\n #  CHECK-NEXT: Command Output (stdout):\n #  CHECK-NEXT: --\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-#  CHECK-NEXT: $ \"printf\"\n-#  CHECK-NEXT: # command output:\n-#  CHECK-NEXT: line 1: failed test output on stdout\n-#  CHECK-NEXT: line 2: failed test output on stdout\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-#  CHECK-NEXT: $ \"false\"\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: printf \"line 1: failed test output on stdout\\nline 2: failed test output on stdout\"\n+#  CHECK-NEXT: executed command: printf 'line 1: failed test output on stdout\\nline 2: failed test output on stdout'\n+#  CHECK-NEXT: # .---command stdout------------\n+#  CHECK-NEXT: # | line 1: failed test output on stdout\n+#  CHECK-NEXT: # | line 2: failed test output on stdout\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # RUN: at line 2\n+#  CHECK-NEXT: false\n+#  CHECK-NEXT: # executed command: false\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: --\n+\n \n # CHECK: UNRESOLVED: shtest-format :: no-test-line.txt\n # CHECK: PASS: shtest-format :: pass.txt\n@@ -73,8 +81,11 @@\n # CHECK-EMPTY:\n #  CHECK-NEXT: Command Output (stdout):\n #  CHECK-NEXT: --\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-#  CHECK-NEXT: $ \"true\"\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: true\n+#  CHECK-NEXT: # executed command: true\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: --\n \n # CHECK: Failed Tests (4)\n # CHECK: shtest-format :: external_shell/fail.txt\ndiff --git a/llvm/utils/lit/tests/shtest-if-else.py b/llvm/utils/lit/tests/shtest-if-else.py\nindex aaf94a6e2437..c18da4abbcca 100644\n--- a/llvm/utils/lit/tests/shtest-if-else.py\n+++ b/llvm/utils/lit/tests/shtest-if-else.py\n@@ -1,5 +1,6 @@\n # RUN: %{lit} -v --show-all %{inputs}/shtest-if-else/test.txt \\\n-# RUN:    | FileCheck %{inputs}/shtest-if-else/test.txt --match-full-lines\n+# RUN:    | FileCheck %{inputs}/shtest-if-else/test.txt --match-full-lines \\\n+# RUN:                --implicit-check-not='RUN:'\n \n # RUN: not %{lit} -v --show-all %{inputs}/shtest-if-else/test-neg1.txt 2>&1 \\\n # RUN:    | FileCheck %{inputs}/shtest-if-else/test-neg1.txt\ndiff --git a/llvm/utils/lit/tests/shtest-inject.py b/llvm/utils/lit/tests/shtest-inject.py\nindex 17e293ea1a12..3d34eb7161d4 100644\n--- a/llvm/utils/lit/tests/shtest-inject.py\n+++ b/llvm/utils/lit/tests/shtest-inject.py\n@@ -1,9 +1,26 @@\n-# Check that we can inject commands at the beginning of a ShTest.\n+# Check that we can inject preamble commands at the beginning of a ShTest.\n+#\n+# For one case, check the execution trace as these preamble commands have\n+# \"preamble command\" instead of the usual \"{{RUN}}: at line N\".\n \n # RUN: %{lit} %{inputs}/shtest-inject/test-empty.txt --show-all | FileCheck --check-prefix=CHECK-TEST1 %s\n #\n-# CHECK-TEST1: THIS WAS\n-# CHECK-TEST1: INJECTED\n+#       CHECK-TEST1: Command Output (stdout):\n+#  CHECK-TEST1-NEXT: --\n+#  CHECK-TEST1-NEXT: # preamble command line\n+#  CHECK-TEST1-NEXT: echo \"THIS WAS\"\n+#  CHECK-TEST1-NEXT: # executed command: echo 'THIS WAS'\n+#  CHECK-TEST1-NEXT: # .---command stdout{{-*}}\n+#  CHECK-TEST1-NEXT: # | THIS WAS\n+#  CHECK-TEST1-NEXT: # `---{{-*}}\n+#  CHECK-TEST1-NEXT: # preamble command line\n+#  CHECK-TEST1-NEXT: echo \"INJECTED\"\n+#  CHECK-TEST1-NEXT: # executed command: echo INJECTED\n+#  CHECK-TEST1-NEXT: # .---command stdout{{-*}}\n+#  CHECK-TEST1-NEXT: # | INJECTED\n+#  CHECK-TEST1-NEXT: # `---{{-*}}\n+# CHECK-TEST1-EMPTY:\n+#  CHECK-TEST1-NEXT: --\n #\n # CHECK-TEST1: Passed: 1\n \ndiff --git a/llvm/utils/lit/tests/shtest-not.py b/llvm/utils/lit/tests/shtest-not.py\nindex d23c9d0cffaf..f514cddf1def 100644\n--- a/llvm/utils/lit/tests/shtest-not.py\n+++ b/llvm/utils/lit/tests/shtest-not.py\n@@ -10,112 +10,158 @@\n # CHECK: -- Testing: 17 tests{{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-args-nested-none.txt {{.*}}\n-# CHECK: $ \"!\" \"!\" \"!\"\n-# CHECK: Error: '!' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: ! ! !\n+# CHECK: # executed command: ! ! !\n+# CHECK: # | Error: '!' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-args-none.txt {{.*}}\n-# CHECK: $ \"!\"\n-# CHECK: Error: '!' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: !\n+# CHECK: # executed command: !\n+# CHECK: # | Error: '!' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-calls-external.txt {{.*}}\n \n-# CHECK: $ \"!\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"!\" \"!\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"!\" \"!\" \"!\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"!\" \"!\" \"!\" \"!\" \"{{[^\"]*}}\" \"pass.py\"\n+# CHECK: ! [[PYTHON:.*]] fail.py\n+# CHECK: # executed command: ! [[PYTHON_BARE:.*]] fail.py\n+# CHECK: ! ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! ! [[PYTHON_BARE]] pass.py\n+# CHECK: ! ! ! [[PYTHON]] fail.py\n+# CHECK: # executed command: ! ! ! [[PYTHON_BARE]] fail.py\n+# CHECK: ! ! ! ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! ! ! ! [[PYTHON_BARE]] pass.py\n \n-# CHECK: $ \"!\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! [[PYTHON_BARE]] pass.py\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-last-is-crash.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not --crash\n+# CHECK: # executed command: not --crash\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-nested-none.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not not\n+# CHECK: # executed command: not not not\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-none.txt {{.*}}\n-# CHECK: $ \"not\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not\n+# CHECK: # executed command: not\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-cd.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"cd\" \"foobar\"\n-# CHECK: $ \"not\" \"--crash\" \"cd\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'cd'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not cd foobar\n+# CHECK: # executed command: not not cd foobar\n+# CHECK: not --crash cd foobar\n+# CHECK: # executed command: not --crash cd foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'cd'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-colon.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \":\" \"foobar\"\n-# CHECK: $ \"not\" \"--crash\" \":\"\n-# CHECK: Error: 'not --crash' cannot call ':'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not : foobar\n+# CHECK: # executed command: not not : foobar\n+# CHECK: not --crash :\n+# CHECK: # executed command: not --crash :\n+# CHECK: # | Error: 'not --crash' cannot call ':'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-diff-with-crash.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"diff\" \"-u\" {{.*}}\n-# CHECK-NOT: \"$\"\n+# CHECK: not --crash diff -u {{.*}}\n+# CHECK: # executed command: not --crash diff -u {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n # CHECK-NOT: {{[Ee]rror}}\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: # error: command failed with exit status: {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n # CHECK-NOT: {{[Ee]rror}}\n-# CHECK-NOT: \"$\"\n \n # CHECK: FAIL: shtest-not :: not-calls-diff.txt {{.*}}\n-# CHECK: $ \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"diff\" {{.*}}\n-# CHECK-NOT: \"$\"\n+# CHECK: not diff {{.*}}\n+# CHECK: # executed command: not diff {{.*}}\n+# CHECK: not not not diff {{.*}}\n+# CHECK: # executed command: not not not diff {{.*}}\n+# CHECK: not not not not not diff {{.*}}\n+# CHECK: # executed command: not not not not not diff {{.*}}\n+# CHECK: diff {{.*}}\n+# CHECK: # executed command: diff {{.*}}\n+# CHECK: not not diff {{.*}}\n+# CHECK: # executed command: not not diff {{.*}}\n+# CHECK: not not not not diff {{.*}}\n+# CHECK: # executed command: not not not not diff {{.*}}\n+# CHECK: not diff {{.*}}\n+# CHECK: # executed command: not diff {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-echo.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"echo\" \"hello\" \"world\"\n-# CHECK: $ \"not\" \"--crash\" \"echo\" \"hello\" \"world\"\n-# CHECK: Error: 'not --crash' cannot call 'echo'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not echo hello world\n+# CHECK: # executed command: not not echo hello world\n+# CHECK: not --crash echo hello world\n+# CHECK: # executed command: not --crash echo hello world\n+# CHECK: # | Error: 'not --crash' cannot call 'echo'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-env-builtin.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"env\" \"-u\" \"FOO\" \"BAR=3\" \"rm\" \"{{.*}}.no-such-file\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not --crash env -u FOO BAR=3 rm {{.*}}.no-such-file\n+# CHECK: # executed command: not --crash env -u FOO BAR=3 rm {{.+}}.no-such-file{{.*}}\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-export.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"export\" \"FOO=1\"\n-# CHECK: $ \"not\" \"--crash\" \"export\" \"BAZ=3\"\n-# CHECK: Error: 'not --crash' cannot call 'export'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not export FOO=1\n+# CHECK: # executed command: not not export FOO=1\n+# CHECK: not --crash export BAZ=3\n+# CHECK: # executed command: not --crash export BAZ=3\n+# CHECK: # | Error: 'not --crash' cannot call 'export'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n \n # CHECK: PASS: shtest-not :: not-calls-external.txt {{.*}}\n \n-# CHECK: $ \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-\n-# CHECK: $ \"env\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"env\" \"-u\" \"FOO\" \"BAR=2\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"env\" \"-u\" \"FOO\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"env\" \"FOO=1\" \"env\" \"FOO=2\" \"BAR=1\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"-u\" \"BAR\" \"env\" \"-u\" \"FOO\" \"BAR=1\" \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"env\" \"FOO=2\" \"BAR=2\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"env\" \"-u\" \"BAR\" \"not\" \"env\" \"-u\" \"FOO\" \"BAR=1\" \"{{[^\"]*}}\" \"pass.py\"\n+# CHECK: not [[PYTHON]] fail.py\n+# CHECK: # executed command: not [[PYTHON_BARE]] fail.py\n+# CHECK: not not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not [[PYTHON_BARE]] pass.py\n+# CHECK: not not not [[PYTHON]] fail.py\n+# CHECK: # executed command: not not not [[PYTHON_BARE]] fail.py\n+# CHECK: not not not not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not not not [[PYTHON_BARE]] pass.py\n+\n+# CHECK: not not --crash [[PYTHON]] pass.py\n+# CHECK: # executed command: not not --crash [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash [[PYTHON]] fail.py\n+# CHECK: # executed command: not not --crash [[PYTHON_BARE]] fail.py\n+# CHECK: not not --crash not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not --crash not [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash not [[PYTHON]] fail.py\n+# CHECK: # executed command: not not --crash not [[PYTHON_BARE]] fail.py\n+\n+# CHECK: env not [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env not [[PYTHON_BARE]] fail.py\n+# CHECK: not env [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: not env [[PYTHON_BARE]] fail.py\n+# CHECK: env FOO=1 not [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 not [[PYTHON_BARE]] fail.py\n+# CHECK: not env FOO=1 BAR=1 [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 [[PYTHON_BARE]] fail.py\n+# CHECK: env FOO=1 BAR=1 not env -u FOO BAR=2 [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 BAR=1 not env -u FOO BAR=2 [[PYTHON_BARE]] fail.py\n+# CHECK: not env FOO=1 BAR=1 not env -u FOO -u BAR [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 not env -u FOO -u BAR [[PYTHON_BARE]] pass.py\n+# CHECK: not not env FOO=1 env FOO=2 BAR=1 [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not not env FOO=1 env FOO=2 BAR=1 [[PYTHON_BARE]] pass.py\n+# CHECK: env FOO=1 -u BAR env -u FOO BAR=1 not not [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 -u BAR env -u FOO BAR=1 not not [[PYTHON_BARE]] pass.py\n+\n+# CHECK: not env FOO=1 BAR=1 env FOO=2 BAR=2 not --crash [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 env FOO=2 BAR=2 not --crash [[PYTHON_BARE]] pass.py\n+# CHECK: not env FOO=1 BAR=1 not --crash not [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 not --crash not [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash env -u BAR not env -u FOO BAR=1 [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not not --crash env -u BAR not env -u FOO BAR=1 [[PYTHON_BARE]] pass.py\n \n \n # CHECK: FAIL: shtest-not :: not-calls-fail2.txt {{.*}}\n@@ -123,16 +169,20 @@\n # CHECK-NEXT: Exit Code: 1\n \n # CHECK: FAIL: shtest-not :: not-calls-mkdir.txt {{.*}}\n-# CHECK: $ \"not\" \"mkdir\" {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"mkdir\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'mkdir'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not mkdir {{.*}}\n+# CHECK: # executed command: not mkdir {{.*}}\n+# CHECK: not --crash mkdir foobar\n+# CHECK: # executed command: not --crash mkdir foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'mkdir'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-rm.txt {{.*}}\n-# CHECK: $ \"not\" \"rm\" {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"rm\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not rm {{.*}}\n+# CHECK: # executed command: not rm {{.*}}\n+# CHECK: not --crash rm foobar\n+# CHECK: # executed command: not --crash rm foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: Passed:  1\n # CHECK: Failed: 16\ndiff --git a/llvm/utils/lit/tests/shtest-output-printing.py b/llvm/utils/lit/tests/shtest-output-printing.py\nindex 7cd975ba8d3c..129cff981eb5 100644\n--- a/llvm/utils/lit/tests/shtest-output-printing.py\n+++ b/llvm/utils/lit/tests/shtest-output-printing.py\n@@ -1,28 +1,45 @@\n # Check the various features of the ShTest format.\n #\n # RUN: not %{lit} -v %{inputs}/shtest-output-printing > %t.out\n-# RUN: FileCheck --input-file %t.out %s\n+# RUN: FileCheck --input-file %t.out --match-full-lines %s\n #\n # END.\n \n-# CHECK: -- Testing:\n-\n-# CHECK: FAIL: shtest-output-printing :: basic.txt\n-# CHECK-NEXT: *** TEST 'shtest-output-printing :: basic.txt' FAILED ***\n-# CHECK-NEXT: Exit Code: 1\n-#\n-# CHECK:      Command Output\n-# CHECK-NEXT: --\n-# CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \"true\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-# CHECK-NEXT: $ \"echo\" \"hi\"\n-# CHECK-NEXT: # command output:\n-# CHECK-NEXT: hi\n-#\n-# CHECK:      $ \":\" \"RUN: at line 3\"\n-# CHECK-NEXT: $ \"not\" \"not\" \"wc\" \"missing-file\"\n-# CHECK-NEXT: # redirected output from '{{.*(/|\\\\\\\\)}}basic.txt.tmp.out':\n-# CHECK-NEXT: {{cannot open missing-file|missing-file.* No such file or directory}}\n-# CHECK:      note: command had no output on stdout or stderr\n-# CHECK-NEXT: error: command failed with exit status: 1\n+#       CHECK: -- Testing: {{.*}}\n+#       CHECK: FAIL: shtest-output-printing :: basic.txt {{.*}}\n+#  CHECK-NEXT: ***{{\\**}} TEST 'shtest-output-printing :: basic.txt' FAILED ***{{\\**}}\n+#  CHECK-NEXT: Exit Code: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: Command Output (stdout):\n+#  CHECK-NEXT: --\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: true\n+#  CHECK-NEXT: # executed command: true\n+#  CHECK-NEXT: # RUN: at line 2\n+#  CHECK-NEXT: echo hi\n+#  CHECK-NEXT: # executed command: echo hi\n+#  CHECK-NEXT: # .---command stdout------------\n+#  CHECK-NEXT: # | hi\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # RUN: at line 3\n+#  CHECK-NEXT: not not wc missing-file &> [[FILE:.*]] || true\n+#  CHECK-NEXT: # executed command: not not wc missing-file\n+#  CHECK-NEXT: # .---redirected output from '[[FILE]]'\n+#  CHECK-NEXT: # | wc: {{cannot open missing-file|missing-file.* No such file or directory}}\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+#  CHECK-NEXT: # executed command: true\n+#  CHECK-NEXT: # RUN: at line 4\n+#  CHECK-NEXT: not {{.*}}python{{.*}} {{.*}}write-a-lot.py &> [[FILE:.*]]\n+#  CHECK-NEXT: # executed command: not {{.*}}python{{.*}} {{.*}}write-a-lot.py{{.*}}\n+#  CHECK-NEXT: # .---redirected output from '[[FILE]]'\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#       CHECK: # | ...\n+#  CHECK-NEXT: # `---data was truncated--------\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT:--\ndiff --git a/llvm/utils/lit/tests/shtest-pushd-popd.py b/llvm/utils/lit/tests/shtest-pushd-popd.py\nindex 26296a7ffcf5..6d7e93c74a05 100644\n--- a/llvm/utils/lit/tests/shtest-pushd-popd.py\n+++ b/llvm/utils/lit/tests/shtest-pushd-popd.py\n@@ -8,16 +8,16 @@\n # CHECK: -- Testing: 4 tests{{.*}}\n \n # CHECK: FAIL: shtest-pushd-popd :: popd-args.txt ({{[^)]*}})\n-# CHECK: $ \"popd\" \"invalid\"\n-# CHECK: 'popd' does not support arguments\n+# CHECK: popd invalid\n+# CHECK: # | 'popd' does not support arguments\n \n # CHECK: FAIL: shtest-pushd-popd :: popd-no-stack.txt ({{[^)]*}})\n-# CHECK: $ \"popd\"\n-# CHECK: popd: directory stack empty\n+# CHECK: popd\n+# CHECK: # | popd: directory stack empty\n \n # CHECK: FAIL: shtest-pushd-popd :: pushd-too-many-args.txt ({{[^)]*}})\n-# CHECK: $ \"pushd\" \"a\" \"b\"\n-# CHECK: 'pushd' supports only one argument\n+# CHECK: pushd a b\n+# CHECK: # | 'pushd' supports only one argument\n \n # CHECK: Passed:  1\n # CHECK: Failed:  3\ndiff --git a/llvm/utils/lit/tests/shtest-recursive-substitution.py b/llvm/utils/lit/tests/shtest-recursive-substitution.py\nindex 48f4b5b12491..65c177e65a3c 100644\n--- a/llvm/utils/lit/tests/shtest-recursive-substitution.py\n+++ b/llvm/utils/lit/tests/shtest-recursive-substitution.py\n@@ -3,7 +3,7 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/substitutes-within-limit --show-all | FileCheck --check-prefix=CHECK-TEST1 %s\n # CHECK-TEST1: PASS: substitutes-within-limit :: test.py\n-# CHECK-TEST1: $ \"echo\" \"STOP\"\n+# CHECK-TEST1: echo STOP\n \n # RUN: not %{lit} %{inputs}/shtest-recursive-substitution/does-not-substitute-within-limit --show-all | FileCheck --check-prefix=CHECK-TEST2 %s\n # CHECK-TEST2: UNRESOLVED: does-not-substitute-within-limit :: test.py\n@@ -11,7 +11,7 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/does-not-substitute-no-limit --show-all | FileCheck --check-prefix=CHECK-TEST3 %s\n # CHECK-TEST3: PASS: does-not-substitute-no-limit :: test.py\n-# CHECK-TEST3: $ \"echo\" \"%rec4\"\n+# CHECK-TEST3: echo %rec4\n \n # RUN: not %{lit} %{inputs}/shtest-recursive-substitution/not-an-integer --show-all 2>&1 | FileCheck --check-prefix=CHECK-TEST4 %s\n # CHECK-TEST4: recursiveExpansionLimit must be either None or an integer\n@@ -24,4 +24,4 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/escaping --show-all | FileCheck --check-prefix=CHECK-TEST7 %s\n # CHECK-TEST7: PASS: escaping :: test.py\n-# CHECK-TEST7: $ \"echo\" \"%s\" \"%s\" \"%%s\"\n+# CHECK-TEST7: echo %s %s %%s\ndiff --git a/llvm/utils/lit/tests/shtest-run-at-line.py b/llvm/utils/lit/tests/shtest-run-at-line.py\nindex 879cd64ebf6e..a0626f872c4c 100644\n--- a/llvm/utils/lit/tests/shtest-run-at-line.py\n+++ b/llvm/utils/lit/tests/shtest-run-at-line.py\n@@ -28,21 +28,28 @@\n # CHECK-LABEL: FAIL: shtest-run-at-line :: internal-shell/basic.txt\n \n # CHECK:      Command Output (stdout)\n-# CHECK:      $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \"true\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-# CHECK-NEXT: $ \"false\"\n+# CHECK-NEXT: --\n+# CHECK-NEXT: # RUN: at line 1\n+# CHECK-NEXT: true\n+# CHECK-NEXT: # executed command: true\n+# CHECK-NEXT: # RUN: at line 2\n+# CHECK-NEXT: false\n+# CHECK-NEXT: # executed command: false\n # CHECK-NOT:  RUN\n \n # CHECK-LABEL: FAIL: shtest-run-at-line :: internal-shell/line-continuation.txt\n \n # CHECK:      Command Output (stdout)\n-# CHECK:      $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \":\" \"first\" \"line\" \"continued\" \"to\" \"second\" \"line\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 3\"\n-# CHECK-NEXT: $ \"echo\" \"foo bar\"\n-# CHECK-NEXT: $ \"FileCheck\" \"{{.*}}\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 5\"\n-# CHECK-NEXT: $ \"echo\" \"foo baz\"\n-# CHECK-NEXT: $ \"FileCheck\" \"{{.*}}\"\n+# CHECK-NEXT: --\n+# CHECK-NEXT: # RUN: at line 1\n+# CHECK-NEXT: : first line continued to second line\n+# CHECK-NEXT: # executed command: : first line continued to second line\n+# CHECK-NEXT: # RUN: at line 3\n+# CHECK-NEXT: echo 'foo bar' | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: echo 'foo bar'\n+# CHECK-NEXT: # executed command: FileCheck {{.*}}\n+# CHECK-NEXT: # RUN: at line 5\n+# CHECK-NEXT: echo 'foo baz' | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: echo 'foo baz'\n+# CHECK-NEXT: # executed command: FileCheck {{.*}}\n # CHECK-NOT:  RUN\ndiff --git a/llvm/utils/lit/tests/shtest-shell.py b/llvm/utils/lit/tests/shtest-shell.py\nindex 93f05dbd35d0..a043582d6ae2 100644\n--- a/llvm/utils/lit/tests/shtest-shell.py\n+++ b/llvm/utils/lit/tests/shtest-shell.py\n@@ -20,202 +20,212 @@\n \n # CHECK: FAIL: shtest-shell :: cat-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: cat-error-0.txt' FAILED ***\n-# CHECK: $ \"cat\" \"-b\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'cat':  option -b not recognized\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: cat -b temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'cat':  option -b not recognized\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: cat-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: cat-error-1.txt' FAILED ***\n-# CHECK: $ \"cat\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: [Errno 2] No such file or directory: 'temp1.txt'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: cat temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | [Errno 2] No such file or directory: 'temp1.txt'\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: colon-error.txt\n # CHECK: *** TEST 'shtest-shell :: colon-error.txt' FAILED ***\n-# CHECK: $ \":\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: ':' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: :\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: ':' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: PASS: shtest-shell :: continuations.txt\n \n # CHECK: PASS: shtest-shell :: dev-null.txt\n \n-# CHECK: FAIL: shtest-shell :: diff-b.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-b.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-b\" \"{{[^\"]*}}.0\" \"{{[^\"]*}}.1\"\n-# CHECK: # command output:\n-# CHECK: 1,2\n-# CHECK-NEXT: {{^  }}f o o\n-# CHECK-NEXT: ! b a r\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: {{^  }}f o o\n-# CHECK-NEXT: ! bar\n-# CHECK-EMPTY:\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-b.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-b.txt' FAILED ***\n+#      CHECK: diff -b {{[^\"]*}}.0 {{[^\"]*}}.1\n+#      CHECK: # .---command stdout{{-*}}\n+#      CHECK: # | {{.*}}1,2\n+# CHECK-NEXT: # |   f o o\n+# CHECK-NEXT: # | ! b a r\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # |   f o o\n+# CHECK-NEXT: # | ! bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+#      CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-encodings.txt\n # CHECK: *** TEST 'shtest-shell :: diff-encodings.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"diff-in.bin\"\n+#      CHECK: diff -u diff-in.bin diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.bin diff-in.bin\n+#  CHECK-NOT: error\n+\n+#      CHECK: diff -u diff-in.utf16 diff-in.bin && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf16 diff-in.bin\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.utf8 diff-in.bin && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf8 diff-in.bin\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | -baz\n+# CHECK-NEXT: # | {{\\+.f.o.o.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{\\+.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.bin diff-in.utf8 && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.bin diff-in.utf8\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{-.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.}}\n+# CHECK-NEXT: # | {{-.b.a.z.$}}\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # | +baz\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#     CHECK: cat diff-in.bin | diff -u - diff-in.bin\n # CHECK-NOT: error\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf16\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^ .f.o.o.$}}\n-# CHECK-NEXT: {{^-.b.a.r.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^ .b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf8\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: -baz\n-# CHECK-NEXT: {{^\\+.f.o.o.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^\\+.b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"diff-in.utf8\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^\\-.f.o.o.$}}\n-# CHECK-NEXT: {{^\\-.b.a.r.}}\n-# CHECK-NEXT: {{^\\-.b.a.z.$}}\n-# CHECK-NEXT: +foo\n-# CHECK-NEXT: +bar\n-# CHECK-NEXT: +baz\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"-\"\n-# CHECK-NOT: error\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf16\" \"-\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^ .f.o.o.$}}\n-# CHECK-NEXT: {{^-.b.a.r.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^ .b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n+#     CHECK: cat diff-in.bin | diff -u diff-in.bin -\n # CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf8\" \"-\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: -baz\n-# CHECK-NEXT: {{^\\+.f.o.o.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^\\+.b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"diff-in.utf8\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^\\-.f.o.o.$}}\n-# CHECK-NEXT: {{^\\-.b.a.r.}}\n-# CHECK-NEXT: {{^\\-.b.a.z.$}}\n-# CHECK-NEXT: +foo\n-# CHECK-NEXT: +bar\n-# CHECK-NEXT: +baz\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n \n-# CHECK: $ \"false\"\n+#      CHECK: cat diff-in.bin | diff -u diff-in.utf16 - && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf16 -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat diff-in.bin | diff -u diff-in.utf8 - && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf8 -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | -baz\n+# CHECK-NEXT: # | {{\\+.f.o.o.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{\\+.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat diff-in.bin | diff -u - diff-in.utf8 && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u - diff-in.utf8\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{-.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.}}\n+# CHECK-NEXT: # | {{-.b.a.z.$}}\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # | +baz\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-1.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-B\" \"temp1.txt\" \"temp2.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'diff': option -B not recognized\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -B temp1.txt temp2.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'diff': option -B not recognized\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-2.txt' FAILED ***\n-# CHECK: $ \"diff\" \"temp.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff temp.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-3.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-3.txt' FAILED ***\n-# CHECK: $ \"diff\" \"temp.txt\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'diff' command failed\n+# CHECK: diff temp.txt temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'diff' command failed\n # CHECK: error: command failed with exit status: 1\n # CHECK: ***\n \n-# CHECK: FAIL: shtest-shell :: diff-error-4.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-error-4.txt' FAILED ***\n-# CHECK: Exit Code: 1\n-# CHECK: # command output:\n-# CHECK: diff-error-4.txt.tmp\n-# CHECK: diff-error-4.txt.tmp1\n-# CHECK: *** 1 ****\n-# CHECK: ! hello-first\n-# CHECK: --- 1 ----\n-# CHECK: ! hello-second\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-error-4.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-error-4.txt' FAILED ***\n+#      CHECK: Exit Code: 1\n+#      CHECK: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | {{.*}}diff-error-4.txt.tmp\n+# CHECK-NEXT: # | {{.*}}diff-error-4.txt.tmp1\n+# CHECK-NEXT: # | {{\\*+}}\n+# CHECK-NEXT: # | *** 1 ****\n+# CHECK-NEXT: # | ! hello-first\n+# CHECK-NEXT: # | --- 1 ----\n+# CHECK-NEXT: # | ! hello-second\n+# CHECK-NEXT: # `---{{-*}}\n+#      CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-5.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-5.txt' FAILED ***\n-# CHECK: $ \"diff\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-6.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-6.txt' FAILED ***\n-# CHECK: $ \"diff\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n \n@@ -223,137 +233,130 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-pipes.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.foo\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"FileCheck\"\n+# CHECK: diff {{[^ ]*}}.foo {{.*}}.foo | FileCheck {{.*}}\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: note: command had no output on stdout or stderr\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"FileCheck\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"true\"\n+#      CHECK: diff -u {{.*}}.foo {{.*}}.bar | FileCheck {{.*}} && false || true\n+# CHECK-NEXT: # executed command: diff -u {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # note: command had no output on stdout or stderr\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: FileCheck\n+# CHECK-NEXT: # executed command: true\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"{{[^\"]*}}.foo\"\n+#     CHECK: cat {{.*}}.foo | diff -u - {{.*}}.foo\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n+#     CHECK: cat {{.*}}.foo | diff -u {{.*}}.foo -\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: +bar\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"{{[^\"]*}}.foo\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: +foo\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-\" \"{{[^\"]*}}.foo\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"FileCheck\"\n+#      CHECK: cat {{.*}}.bar | diff -u {{.*}}.foo - && false || true\n+# CHECK-NEXT: # executed command: cat {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # executed command: diff -u {{.+}}.foo{{.*}} -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat {{.*}}.bar | diff -u - {{.*}}.foo && false || true\n+# CHECK-NEXT: # executed command: cat {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # executed command: diff -u - {{.+}}.foo{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#     CHECK: cat {{.*}}.foo | diff - {{.*}}.foo | FileCheck {{.*}}\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n-# CHECK: note: command had no output on stdout or stderr\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"FileCheck\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"true\"\n+#      CHECK: cat {{.*}}.bar | diff -u {{.*}}.foo - | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: cat {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # executed command: diff -u {{.+}}.foo{{.*}} -\n+# CHECK-NEXT: note: command had no output on stdout or stderr\n+# CHECK-NEXT: error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: FileCheck\n+# CHECK-NEXT: # executed command: true\n \n-# CHECK: $ \"false\"\n+# CHECK: false\n \n # CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-r-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-0.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: dir1unique\n-# CHECK: Only in {{.*}}dir2: dir2unique\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: dir1unique\n+# CHECK: # | Only in {{.*}}dir2: dir2unique\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-1.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: *** {{.*}}dir1{{.*}}subdir{{.*}}f01\n-# CHECK: --- {{.*}}dir2{{.*}}subdir{{.*}}f01\n-# CHECK: 12345\n-# CHECK: 00000\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | *** {{.*}}dir1{{.*}}subdir{{.*}}f01\n+# CHECK: # | --- {{.*}}dir2{{.*}}subdir{{.*}}f01\n+# CHECK: # | ! 12345\n+# CHECK: # | ! 00000\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-2.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir2: extrafile\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir2: extrafile\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-3.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-3.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: extra_subdir\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: extra_subdir\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-4.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-4.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: File {{.*}}dir1{{.*}}extra_subdir is a directory while file {{.*}}dir2{{.*}}extra_subdir is a regular file\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | File {{.*}}dir1{{.*}}extra_subdir is a directory while file {{.*}}dir2{{.*}}extra_subdir is a regular file\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-5.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-5.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: extra_subdir\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: extra_subdir\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-6.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-6.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: File {{.*}}dir1{{.*}}extra_file is a regular empty file while file {{.*}}dir2{{.*}}extra_file is a directory\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | File {{.*}}dir1{{.*}}extra_file is a regular empty file while file {{.*}}dir2{{.*}}extra_file is a directory\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-7.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-7.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\" \"-\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: cannot recursively compare '-'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r - {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: cannot recursively compare '-'\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-8.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-8.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\" \"{{[^\"]*}}\" \"-\"\n-# CHECK: # command stderr:\n-# CHECK: Error: cannot recursively compare '-'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r {{.*}} -\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: cannot recursively compare '-'\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: PASS: shtest-shell :: diff-r.txt\n \n@@ -362,51 +365,59 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-strip-trailing-cr.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.dos\" \"diff-in.unix\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -In this file, the\n-# CHECK-NEXT: -sequence \"\\r\\n\"\n-# CHECK-NEXT: -terminates lines.\n-# CHECK-NEXT: +In this file, the\n-# CHECK-NEXT: +sequence \"\\n\"\n-# CHECK-NEXT: +terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.unix\" \"diff-in.dos\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -In this file, the\n-# CHECK-NEXT: -sequence \"\\n\"\n-# CHECK-NEXT: -terminates lines.\n-# CHECK-NEXT: +In this file, the\n-# CHECK-NEXT: +sequence \"\\r\\n\"\n-# CHECK-NEXT: +terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"--strip-trailing-cr\" \"diff-in.dos\" \"diff-in.unix\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT:  In this file, the\n-# CHECK-NEXT: -sequence \"\\r\\n\"\n-# CHECK-NEXT: +sequence \"\\n\"\n-# CHECK-NEXT:  terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"--strip-trailing-cr\" \"diff-in.unix\" \"diff-in.dos\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT:  In this file, the\n-# CHECK-NEXT: -sequence \"\\n\"\n-# CHECK-NEXT: +sequence \"\\r\\n\"\n-# CHECK-NEXT:  terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"false\"\n+#      CHECK: diff -u diff-in.dos diff-in.unix && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.dos diff-in.unix\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -In this file, the\n+# CHECK-NEXT: # | -sequence \"\\r\\n\"\n+# CHECK-NEXT: # | -terminates lines.\n+# CHECK-NEXT: # | +In this file, the\n+# CHECK-NEXT: # | +sequence \"\\n\"\n+# CHECK-NEXT: # | +terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.unix diff-in.dos && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.unix diff-in.dos\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -In this file, the\n+# CHECK-NEXT: # | -sequence \"\\n\"\n+# CHECK-NEXT: # | -terminates lines.\n+# CHECK-NEXT: # | +In this file, the\n+# CHECK-NEXT: # | +sequence \"\\r\\n\"\n+# CHECK-NEXT: # | +terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u --strip-trailing-cr diff-in.dos diff-in.unix && false || true\n+# CHECK-NEXT: executed command: diff -u --strip-trailing-cr diff-in.dos diff-in.unix\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # |  In this file, the\n+# CHECK-NEXT: # | -sequence \"\\r\\n\"\n+# CHECK-NEXT: # | +sequence \"\\n\"\n+# CHECK-NEXT: # |  terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u --strip-trailing-cr diff-in.unix diff-in.dos && false || true\n+# CHECK-NEXT: # executed command: diff -u --strip-trailing-cr diff-in.unix diff-in.dos\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # |  In this file, the\n+# CHECK-NEXT: # | -sequence \"\\n\"\n+# CHECK-NEXT: # | +sequence \"\\r\\n\"\n+# CHECK-NEXT: # |  terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n@@ -415,106 +426,144 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-unified.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 3\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-NEXT: 9\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U\" \"2\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U4\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 2\n-# CHECK-NEXT: 3\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-NEXT: 9\n-# CHECK-NEXT: 10\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U0\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U\" \"30.1\" \"{{[^\"]*}}\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: invalid '-U' argument: 30.1\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U-1\" \"{{[^\"]*}}\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: invalid '-U' argument: -1\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"false\"\n+#      CHECK: diff -u {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -u {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 3\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # | 9\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U 2 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U 2 {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U4 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U4 {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 2\n+# CHECK-NEXT: # | 3\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # | 9\n+# CHECK-NEXT: # | 10\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U0 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U0 {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: diff -U 30.1 {{.*}} {{.*}} && false || true\n+# CHECK: # executed command: diff -U 30.1 {{.*}} {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: invalid '-U' argument: 30.1\n+# CHECK: # error: command failed with exit status: 1\n+# CHECK: # executed command: true\n+\n+# CHECK: diff -U-1 {{.*}} {{.*}} && false || true\n+# CHECK: # executed command: diff -U-1 {{.*}} {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: invalid '-U' argument: -1\n+# CHECK: # error: command failed with exit status: 1\n+# CHECK: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n \n-# CHECK: FAIL: shtest-shell :: diff-w.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-w.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-w\" \"{{[^\"]*}}.0\" \"{{[^\"]*}}.1\"\n-# CHECK: # command output:\n-# CHECK: 1,3\n-# CHECK-NEXT: {{^  }}foo\n-# CHECK-NEXT: {{^  }}bar\n-# CHECK-NEXT: ! baz\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: {{^  }}foo\n-# CHECK-NEXT: {{^  }}bar\n-# CHECK-NEXT: ! bat\n-# CHECK-EMPTY:\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-w.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-w.txt' FAILED ***\n+#      CHECK: diff -w {{.*}}.0 {{.*}}.1\n+#      CHECK: # .---command stdout{{-*}}\n+#      CHECK: # | {{\\*+}} 1,3\n+# CHECK-NEXT: # |   foo\n+# CHECK-NEXT: # |   bar\n+# CHECK-NEXT: # | ! baz\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # |   foo\n+# CHECK-NEXT: # |   bar\n+# CHECK-NEXT: # | ! bat\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+#      CHECK: ***\n+\n+# CHECK: FAIL: shtest-shell :: echo-at-redirect-stderr.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-at-redirect-stderr.txt' FAILED ***\n+# CHECK: @echo 2> {{.*}}\n+# CHECK: # executed command: @echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for @echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-at-redirect-stdin.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-at-redirect-stdin.txt' FAILED ***\n+# CHECK: @echo < {{.*}}\n+# CHECK: # executed command: @echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for @echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-redirect-stderr.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-redirect-stderr.txt' FAILED ***\n+# CHECK: echo 2> {{.*}}\n+# CHECK: # executed command: echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-redirect-stdin.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-redirect-stdin.txt' FAILED ***\n+# CHECK: echo < {{.*}}\n+# CHECK: # executed command: echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for echo\n+# CHECK: error: command failed with exit status:\n \n # CHECK: FAIL: shtest-shell :: error-0.txt\n # CHECK: *** TEST 'shtest-shell :: error-0.txt' FAILED ***\n-# CHECK: $ \"not-a-real-command\"\n-# CHECK: # command stderr:\n-# CHECK: 'not-a-real-command': command not found\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: not-a-real-command\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | 'not-a-real-command': command not found\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # FIXME: The output here sucks.\n #\n # CHECK: FAIL: shtest-shell :: error-1.txt\n # CHECK: *** TEST 'shtest-shell :: error-1.txt' FAILED ***\n-# CHECK: shell parser error on: ': \\'RUN: at line 3\\'; echo \"missing quote'\n+# CHECK: shell parser error on RUN: at line 3: echo \"missing quote\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: error-2.txt\n@@ -524,52 +573,52 @@\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-0.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'mkdir' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p temp | rm -rf temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'mkdir' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-1.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\" \"-m\" \"777\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'mkdir': option -m not recognized\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p -m 777 temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'mkdir': option -m not recognized\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-2.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'mkdir' is missing an operand\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'mkdir' is missing an operand\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: PASS: shtest-shell :: redirects.txt\n \n # CHECK: FAIL: shtest-shell :: rm-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-0.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-rf\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'rm' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: rm -rf temp | echo \"hello\"\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'rm' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-1.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-f\" \"-v\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'rm': option -v not recognized\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: rm -f -v temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'rm': option -v not recognized\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-2.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-r\" \"hello\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'rm' command failed\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: rm -r hello\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'rm' command failed\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-3.txt\n@@ -581,16 +630,17 @@\n # CHECK: PASS: shtest-shell :: sequencing-0.txt\n # CHECK: XFAIL: shtest-shell :: sequencing-1.txt\n \n-# CHECK: FAIL: shtest-shell :: stdout-encoding.txt\n-# CHECK: *** TEST 'shtest-shell :: stdout-encoding.txt' FAILED ***\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: {{^.f.o.o.$}}\n-# CHECK-NEXT: {{^.b.a.r.}}\n-# CHECK-NEXT: {{^.b.a.z.$}}\n-# CHECK-NOT: error\n-# CHECK: $ \"false\"\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: stdout-encoding.txt\n+#      CHECK: *** TEST 'shtest-shell :: stdout-encoding.txt' FAILED ***\n+#      CHECK: cat diff-in.bin\n+#      CHECK: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+#  CHECK-NOT: error\n+#      CHECK: false\n+#      CHECK: ***\n \n # CHECK: PASS: shtest-shell :: valid-shell.txt\n-# CHECK: Failed Tests (35)\n+# CHECK: Failed Tests (39)\n", "message": "", "files": {"/libcxx/utils/libcxx/test/dsl.py": {"changes": [{"diff": "\n                 \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n             )\n \n-        return libcxx.test.format._parseLitOutput(out)\n+        return out\n \n \n @_memoizeExpensiveOperation(", "add": 1, "remove": 1, "filename": "/libcxx/utils/libcxx/test/dsl.py", "badparts": ["        return libcxx.test.format._parseLitOutput(out)"], "goodparts": ["        return out"]}]}, "/libcxx/utils/libcxx/test/format.py": {"changes": [{"diff": "\n     for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n         assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n \n-def _parseLitOutput(fullOutput):\n-    \"\"\"\n-    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n-\n-    This takes output of the form\n-\n-        $ \":\" \"RUN: at line 11\"\n-        $ \"echo\" \"OUTPUT1\"\n-        # command output:\n-        OUTPUT1\n-\n-        $ \":\" \"RUN: at line 12\"\n-        $ \"echo\" \"OUTPUT2\"\n-        # command output:\n-        OUTPUT2\n-\n-    and returns a string containing\n-\n-        OUTPUT1\n-        OUTPUT2\n-\n-    as-if the commands had been run directly. This is a workaround for the fact\n-    that Lit doesn't let us execute ShTest and retrieve the raw output without\n-    injecting additional Lit output around it.\n-    \"\"\"\n-    parsed = ''\n-    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n-        if output: # skip blank lines\n-            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n-            if commandOutput:\n-                parsed += commandOutput.group(1)\n-    return parsed\n-\n def _executeScriptInternal(test, litConfig, commands):\n     \"\"\"\n     Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n", "add": 0, "remove": 33, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["def _parseLitOutput(fullOutput):", "    \"\"\"", "    Parse output of a Lit ShTest to extract the actual output of the contained commands.", "    This takes output of the form", "        $ \":\" \"RUN: at line 11\"", "        $ \"echo\" \"OUTPUT1\"", "        OUTPUT1", "        $ \":\" \"RUN: at line 12\"", "        $ \"echo\" \"OUTPUT2\"", "        OUTPUT2", "    and returns a string containing", "        OUTPUT1", "        OUTPUT2", "    as-if the commands had been run directly. This is a workaround for the fact", "    that Lit doesn't let us execute ShTest and retrieve the raw output without", "    injecting additional Lit output around it.", "    \"\"\"", "    parsed = ''", "    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):", "        if output: # skip blank lines", "            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)", "            if commandOutput:", "                parsed += commandOutput.group(1)", "    return parsed"], "goodparts": []}, {"diff": "\n     _, tmpBase = _getTempPaths(test)\n     execDir = os.path.dirname(test.getExecPath())\n     res = lit.TestRunner.executeScriptInternal(\n-        test, litConfig, tmpBase, parsedCommands, execDir\n+        test, litConfig, tmpBase, parsedCommands, execDir, debug=False\n     )\n     if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n         res = (\"\", res.output, 127, None)\n     (out, err, exitCode, timeoutInfo) = res\n \n-    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n-    #       split any stderr output that is included in stdout. It shouldn't be there, but\n-    #       the Lit internal shell conflates stderr and stdout.\n-    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n-    if conflatedErrorOutput:\n-        conflatedErrorOutput = conflatedErrorOutput.group(0)\n-        out = out[: -len(conflatedErrorOutput)]\n-        err += conflatedErrorOutput\n-\n     return (out, err, exitCode, timeoutInfo, parsedCommands)\n \n \n", "add": 1, "remove": 10, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["        test, litConfig, tmpBase, parsedCommands, execDir", "    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)", "    if conflatedErrorOutput:", "        conflatedErrorOutput = conflatedErrorOutput.group(0)", "        out = out[: -len(conflatedErrorOutput)]", "        err += conflatedErrorOutput"], "goodparts": ["        test, litConfig, tmpBase, parsedCommands, execDir, debug=False"]}, {"diff": "\n             raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n \n         # Split the generated output into multiple files and generate one test for each file\n-        parsed = _parseLitOutput(out)\n-        for (subfile, content) in self._splitFile(parsed):\n-            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n+        for subfile, content in self._splitFile(out):\n+            generatedFile = testSuite.getExecPath(pathInSuite + (subfile,))\n             os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n             with open(generatedFile, 'w') as f:\n                 f.write(content", "add": 2, "remove": 3, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["        parsed = _parseLitOutput(out)", "        for (subfile, content) in self._splitFile(parsed):", "            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))"], "goodparts": ["        for subfile, content in self._splitFile(out):", "            generatedFile = testSuite.getExecPath(pathInSuite + (subfile,))"]}], "source": "\n import contextlib import io import lit import lit.formats import os import pipes import re import shutil def _getTempPaths(test): \"\"\" Return the values to use for the %T and %t substitutions, respectively. The difference between this and Lit's default behavior is that we guarantee that %T is a path unique to the test being run. \"\"\" tmpDir, _=lit.TestRunner.getTempPaths(test) _, testName=os.path.split(test.getExecPath()) tmpDir=os.path.join(tmpDir, testName +\".dir\") tmpBase=os.path.join(tmpDir, \"t\") return tmpDir, tmpBase def _checkBaseSubstitutions(substitutions): substitutions=[s for(s, _) in substitutions] for s in[\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]: assert s in substitutions, \"Required substitution{} was not provided\".format(s) def _parseLitOutput(fullOutput): \"\"\" Parse output of a Lit ShTest to extract the actual output of the contained commands. This takes output of the form $ \":\" \"RUN: at line 11\" $ \"echo\" \"OUTPUT1\" OUTPUT1 $ \":\" \"RUN: at line 12\" $ \"echo\" \"OUTPUT2\" OUTPUT2 and returns a string containing OUTPUT1 OUTPUT2 as-if the commands had been run directly. This is a workaround for the fact that Lit doesn't let us execute ShTest and retrieve the raw output without injecting additional Lit output around it. \"\"\" parsed='' for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput): if output: commandOutput=re.search(\" if commandOutput: parsed +=commandOutput.group(1) return parsed def _executeScriptInternal(test, litConfig, commands): \"\"\" Returns(stdout, stderr, exitCode, timeoutInfo, parsedCommands) TODO: This really should be easier to access from Lit itself \"\"\" parsedCommands=parseScript(test, preamble=commands) _, tmpBase=_getTempPaths(test) execDir=os.path.dirname(test.getExecPath()) res=lit.TestRunner.executeScriptInternal( test, litConfig, tmpBase, parsedCommands, execDir ) if isinstance(res, lit.Test.Result): res=(\"\", res.output, 127, None) (out, err, exitCode, timeoutInfo)=res conflatedErrorOutput=re.search(\"( if conflatedErrorOutput: conflatedErrorOutput=conflatedErrorOutput.group(0) out=out[: -len(conflatedErrorOutput)] err +=conflatedErrorOutput return(out, err, exitCode, timeoutInfo, parsedCommands) def parseScript(test, preamble): \"\"\" Extract the script from a test, with substitutions applied. Returns a list of commands ready to be executed. -test The lit.Test to parse. -preamble A list of commands to perform before any command in the test. These commands can contain unexpanded substitutions, but they must not be of the form 'RUN:' --they must be proper commands once substituted. \"\"\" tmpDir, tmpBase=_getTempPaths(test) substitutions=lit.TestRunner.getDefaultSubstitutions(test, tmpDir, tmpBase) _checkBaseSubstitutions(substitutions) substitutions.append( (\"%{build}\", \"%{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\") ) substitutions.append((\"%{run}\", \"%{exec} %t.exe\")) additionalCompileFlags=[] fileDependencies=[] parsers=[ lit.TestRunner.IntegratedTestKeywordParser( \"FILE_DEPENDENCIES:\", lit.TestRunner.ParserKind.LIST, initial_value=fileDependencies, ), lit.TestRunner.IntegratedTestKeywordParser( \"ADDITIONAL_COMPILE_FLAGS:\", lit.TestRunner.ParserKind.LIST, initial_value=additionalCompileFlags, ), ] for feature in test.config.available_features: parser=lit.TestRunner.IntegratedTestKeywordParser( \"ADDITIONAL_COMPILE_FLAGS({}):\".format(feature), lit.TestRunner.ParserKind.LIST, initial_value=additionalCompileFlags, ) parsers.append(parser) scriptInTest=lit.TestRunner.parseIntegratedTestScript( test, additional_parsers=parsers, require_script=not preamble ) if isinstance(scriptInTest, lit.Test.Result): return scriptInTest script=[] for dep in fileDependencies: script +=[\"%dbg(SETUP) cd %S && cp{} %T\".format(dep)] script +=preamble script +=scriptInTest substitutions=[ (s, x +\" \" +\" \".join(additionalCompileFlags)) if s==\"%{compile_flags}\" else(s, x) for(s, x) in substitutions ] script=lit.TestRunner.applySubstitutions( script, substitutions, recursion_limit=test.config.recursiveExpansionLimit ) return script class CxxStandardLibraryTest(lit.formats.FileBasedTest): \"\"\" Lit test format for the C++Standard Library conformance test suite. This test format is based on top of the ShTest format --it basically creates a shell script performing the right operations(compile/link/run) based on the extension of the test file it encounters. It supports files with the following extensions: FOO.pass.cpp -Compiles, links and runs successfully FOO.pass.mm -Same as.pass.cpp, but for Objective-C++ FOO.compile.pass.cpp -Compiles successfully, link and run not attempted FOO.compile.pass.mm -Same as.compile.pass.cpp, but for Objective-C++ FOO.compile.fail.cpp -Does not compile successfully FOO.link.pass.cpp -Compiles and links successfully, run not attempted FOO.link.pass.mm -Same as.link.pass.cpp, but for Objective-C++ FOO.link.fail.cpp -Compiles successfully, but fails to link FOO.sh.<anything> -A builtin Lit Shell test FOO.gen.<anything> -A.sh test that generates one or more Lit tests on the fly. Executing this test must generate one or more files as expected by LLVM split-file, and each generated file leads to a separate Lit test that runs that file as defined by the test format. This can be used to generate multiple Lit tests from a single source file, which is useful for testing repetitive properties in the library. Be careful not to abuse this since this is not a replacement for usual code reuse techniques. FOO.verify.cpp -Compiles with clang-verify. This type of test is automatically marked as UNSUPPORTED if the compiler does not support Clang-verify. Substitution requirements =============================== The test format operates by assuming that each test's configuration provides the following substitutions, which it will reuse in the shell scripts it constructs: %{cxx} -A command that can be used to invoke the compiler %{compile_flags} -Flags to use when compiling a test case %{link_flags} -Flags to use when linking a test case %{flags} -Flags to use either when compiling or linking a test case %{exec} -A command to prefix the execution of executables Note that when building an executable(as opposed to only compiling a source file), all three of %{flags}, %{compile_flags} and %{link_flags} will be used in the same command line. In other words, the test format doesn't perform separate compilation and linking steps in this case. Additional supported directives =============================== In addition to everything that's supported in Lit ShTests, this test format also understands the following directives inside test files: // FILE_DEPENDENCIES: file, directory, /path/to/file This directive expresses that the test requires the provided files or directories in order to run. An example is a test that requires some test input stored in a data file. When a test file contains such a directive, this test format will collect them and copy them to the directory represented by %T. The intent is that %T contains all the inputs necessary to run the test, such that e.g. execution on a remote host can be done by simply copying %T to the host. // ADDITIONAL_COMPILE_FLAGS: flag1, flag2, flag3 This directive will cause the provided flags to be added to the %{compile_flags} substitution for the test that contains it. This allows adding special compilation flags without having to use a .sh.cpp test, which would be more powerful but perhaps overkill. Additional provided substitutions and features ============================================== The test format will define the following substitutions for use inside tests: %{build} Expands to a command-line that builds the current source file with the %{flags}, %{compile_flags} and %{link_flags} substitutions, and that produces an executable named %t.exe. %{run} Equivalent to `%{exec} %t.exe`. This is intended to be used in conjunction with the %{build} substitution. \"\"\" def getTestsForPath(self, testSuite, pathInSuite, litConfig, localConfig): SUPPORTED_SUFFIXES=[ \"[.]pass[.]cpp$\", \"[.]pass[.]mm$\", \"[.]compile[.]pass[.]cpp$\", \"[.]compile[.]pass[.]mm$\", \"[.]compile[.]fail[.]cpp$\", \"[.]link[.]pass[.]cpp$\", \"[.]link[.]pass[.]mm$\", \"[.]link[.]fail[.]cpp$\", \"[.]sh[.][^.]+$\", \"[.]gen[.][^.]+$\", \"[.]verify[.]cpp$\", \"[.]fail[.]cpp$\", ] sourcePath=testSuite.getSourcePath(pathInSuite) filename=os.path.basename(sourcePath) hasSupportedSuffix=lambda f: any([re.search(ext, f) for ext in SUPPORTED_SUFFIXES]) if filename.startswith(\".\") or filename in localConfig.excludes or not hasSupportedSuffix(filename): return if re.search('[.]gen[.][^.]+$', filename): for test in self._generateGenTest(testSuite, pathInSuite, litConfig, localConfig): yield test else: yield lit.Test.Test(testSuite, pathInSuite, localConfig) def execute(self, test, litConfig): VERIFY_FLAGS=( \"-Xclang -verify -Xclang -verify-ignore-unexpected=note -ferror-limit=0\" ) supportsVerify=\"verify-support\" in test.config.available_features filename=test.path_in_suite[-1] if re.search(\"[.]sh[.][^.]+$\", filename): steps=[] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".compile.pass.cpp\") or filename.endswith( \".compile.pass.mm\" ): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".compile.fail.cpp\"): steps=[ \"%dbg(COMPILED WITH) ! %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".link.pass.cpp\") or filename.endswith(\".link.pass.mm\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".link.fail.cpp\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -c -o %t.o\", \"%dbg(LINKED WITH) ! %{cxx} %t.o %{flags} %{link_flags} -o %t.exe\", ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".verify.cpp\"): if not supportsVerify: return lit.Test.Result( lit.Test.UNSUPPORTED, \"Test{} requires support for Clang-verify, which isn't supported by the compiler\".format( test.getFullName() ), ) steps=[ \"%dbg(COMPILED WITH) %{{cxx}} %s %{{flags}} %{{compile_flags}} -fsyntax-only -Wno-error{}\".format( VERIFY_FLAGS ) ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".pass.cpp\") or filename.endswith(\".pass.mm\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\", \"%dbg(EXECUTED AS) %{exec} %t.exe\", ] return self._executeShTest(test, litConfig, steps) else: return lit.Test.Result( lit.Test.UNRESOLVED, \"Unknown test suffix for '{}'\".format(filename) ) def _executeShTest(self, test, litConfig, steps): if test.config.unsupported: return lit.Test.Result(lit.Test.UNSUPPORTED, \"Test is unsupported\") script=parseScript(test, steps) if isinstance(script, lit.Test.Result): return script if litConfig.noExecute: return lit.Test.Result( lit.Test.XFAIL if test.isExpectedToFail() else lit.Test.PASS ) else: _, tmpBase=_getTempPaths(test) useExternalSh=False return lit.TestRunner._runShTest( test, litConfig, useExternalSh, script, tmpBase ) def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig): generator=lit.Test.Test(testSuite, pathInSuite, localConfig) generatorExecDir=os.path.dirname(testSuite.getExecPath(pathInSuite)) os.makedirs(generatorExecDir, exist_ok=True) steps=[] (out, err, exitCode, _, _)=_executeScriptInternal(generator, litConfig, steps) if exitCode !=0: raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\") parsed=_parseLitOutput(out) for(subfile, content) in self._splitFile(parsed): generatedFile=testSuite.getExecPath(pathInSuite +(subfile,)) os.makedirs(os.path.dirname(generatedFile), exist_ok=True) with open(generatedFile, 'w') as f: f.write(content) yield lit.Test.Test(testSuite,(generatedFile,), localConfig) def _splitFile(self, input): DELIM=r'^(//| lines=input.splitlines() currentFile=None thisFileContent=[] for line in lines: match=re.match(DELIM, line) if match: if currentFile is not None: yield(currentFile, '\\n'.join(thisFileContent)) currentFile=match.group(2).strip() thisFileContent=[] assert currentFile is not None, f\"Some input to split-file doesn't belong to any file, input was:\\n{input}\" thisFileContent.append(line) if currentFile is not None: yield(currentFile, '\\n'.join(thisFileContent)) ", "sourceWithComments": "# ===----------------------------------------------------------------------===##\n#\n# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n# See https://llvm.org/LICENSE.txt for license information.\n# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n#\n# ===----------------------------------------------------------------------===##\n\nimport contextlib\nimport io\nimport lit\nimport lit.formats\nimport os\nimport pipes\nimport re\nimport shutil\n\n\ndef _getTempPaths(test):\n    \"\"\"\n    Return the values to use for the %T and %t substitutions, respectively.\n\n    The difference between this and Lit's default behavior is that we guarantee\n    that %T is a path unique to the test being run.\n    \"\"\"\n    tmpDir, _ = lit.TestRunner.getTempPaths(test)\n    _, testName = os.path.split(test.getExecPath())\n    tmpDir = os.path.join(tmpDir, testName + \".dir\")\n    tmpBase = os.path.join(tmpDir, \"t\")\n    return tmpDir, tmpBase\n\n\ndef _checkBaseSubstitutions(substitutions):\n    substitutions = [s for (s, _) in substitutions]\n    for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n        assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n\ndef _parseLitOutput(fullOutput):\n    \"\"\"\n    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n\n    This takes output of the form\n\n        $ \":\" \"RUN: at line 11\"\n        $ \"echo\" \"OUTPUT1\"\n        # command output:\n        OUTPUT1\n\n        $ \":\" \"RUN: at line 12\"\n        $ \"echo\" \"OUTPUT2\"\n        # command output:\n        OUTPUT2\n\n    and returns a string containing\n\n        OUTPUT1\n        OUTPUT2\n\n    as-if the commands had been run directly. This is a workaround for the fact\n    that Lit doesn't let us execute ShTest and retrieve the raw output without\n    injecting additional Lit output around it.\n    \"\"\"\n    parsed = ''\n    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n        if output: # skip blank lines\n            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n            if commandOutput:\n                parsed += commandOutput.group(1)\n    return parsed\n\ndef _executeScriptInternal(test, litConfig, commands):\n    \"\"\"\n    Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n\n    TODO: This really should be easier to access from Lit itself\n    \"\"\"\n    parsedCommands = parseScript(test, preamble=commands)\n\n    _, tmpBase = _getTempPaths(test)\n    execDir = os.path.dirname(test.getExecPath())\n    res = lit.TestRunner.executeScriptInternal(\n        test, litConfig, tmpBase, parsedCommands, execDir\n    )\n    if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n        res = (\"\", res.output, 127, None)\n    (out, err, exitCode, timeoutInfo) = res\n\n    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n    #       split any stderr output that is included in stdout. It shouldn't be there, but\n    #       the Lit internal shell conflates stderr and stdout.\n    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n    if conflatedErrorOutput:\n        conflatedErrorOutput = conflatedErrorOutput.group(0)\n        out = out[: -len(conflatedErrorOutput)]\n        err += conflatedErrorOutput\n\n    return (out, err, exitCode, timeoutInfo, parsedCommands)\n\n\ndef parseScript(test, preamble):\n    \"\"\"\n    Extract the script from a test, with substitutions applied.\n\n    Returns a list of commands ready to be executed.\n\n    - test\n        The lit.Test to parse.\n\n    - preamble\n        A list of commands to perform before any command in the test.\n        These commands can contain unexpanded substitutions, but they\n        must not be of the form 'RUN:' -- they must be proper commands\n        once substituted.\n    \"\"\"\n    # Get the default substitutions\n    tmpDir, tmpBase = _getTempPaths(test)\n    substitutions = lit.TestRunner.getDefaultSubstitutions(test, tmpDir, tmpBase)\n\n    # Check base substitutions and add the %{build} and %{run} convenience substitutions\n    _checkBaseSubstitutions(substitutions)\n    substitutions.append(\n        (\"%{build}\", \"%{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\")\n    )\n    substitutions.append((\"%{run}\", \"%{exec} %t.exe\"))\n\n    # Parse the test file, including custom directives\n    additionalCompileFlags = []\n    fileDependencies = []\n    parsers = [\n        lit.TestRunner.IntegratedTestKeywordParser(\n            \"FILE_DEPENDENCIES:\",\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=fileDependencies,\n        ),\n        lit.TestRunner.IntegratedTestKeywordParser(\n            \"ADDITIONAL_COMPILE_FLAGS:\",\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=additionalCompileFlags,\n        ),\n    ]\n\n    # Add conditional parsers for ADDITIONAL_COMPILE_FLAGS. This should be replaced by first\n    # class support for conditional keywords in Lit, which would allow evaluating arbitrary\n    # Lit boolean expressions instead.\n    for feature in test.config.available_features:\n        parser = lit.TestRunner.IntegratedTestKeywordParser(\n            \"ADDITIONAL_COMPILE_FLAGS({}):\".format(feature),\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=additionalCompileFlags,\n        )\n        parsers.append(parser)\n\n    scriptInTest = lit.TestRunner.parseIntegratedTestScript(\n        test, additional_parsers=parsers, require_script=not preamble\n    )\n    if isinstance(scriptInTest, lit.Test.Result):\n        return scriptInTest\n\n    script = []\n\n    # For each file dependency in FILE_DEPENDENCIES, inject a command to copy\n    # that file to the execution directory. Execute the copy from %S to allow\n    # relative paths from the test directory.\n    for dep in fileDependencies:\n        script += [\"%dbg(SETUP) cd %S && cp {} %T\".format(dep)]\n    script += preamble\n    script += scriptInTest\n\n    # Add compile flags specified with ADDITIONAL_COMPILE_FLAGS.\n    substitutions = [\n        (s, x + \" \" + \" \".join(additionalCompileFlags))\n        if s == \"%{compile_flags}\"\n        else (s, x)\n        for (s, x) in substitutions\n    ]\n\n    # Perform substitutions in the script itself.\n    script = lit.TestRunner.applySubstitutions(\n        script, substitutions, recursion_limit=test.config.recursiveExpansionLimit\n    )\n\n    return script\n\n\nclass CxxStandardLibraryTest(lit.formats.FileBasedTest):\n    \"\"\"\n    Lit test format for the C++ Standard Library conformance test suite.\n\n    This test format is based on top of the ShTest format -- it basically\n    creates a shell script performing the right operations (compile/link/run)\n    based on the extension of the test file it encounters. It supports files\n    with the following extensions:\n\n    FOO.pass.cpp            - Compiles, links and runs successfully\n    FOO.pass.mm             - Same as .pass.cpp, but for Objective-C++\n\n    FOO.compile.pass.cpp    - Compiles successfully, link and run not attempted\n    FOO.compile.pass.mm     - Same as .compile.pass.cpp, but for Objective-C++\n    FOO.compile.fail.cpp    - Does not compile successfully\n\n    FOO.link.pass.cpp       - Compiles and links successfully, run not attempted\n    FOO.link.pass.mm        - Same as .link.pass.cpp, but for Objective-C++\n    FOO.link.fail.cpp       - Compiles successfully, but fails to link\n\n    FOO.sh.<anything>       - A builtin Lit Shell test\n\n    FOO.gen.<anything>      - A .sh test that generates one or more Lit tests on the\n                              fly. Executing this test must generate one or more files\n                              as expected by LLVM split-file, and each generated file\n                              leads to a separate Lit test that runs that file as\n                              defined by the test format. This can be used to generate\n                              multiple Lit tests from a single source file, which is\n                              useful for testing repetitive properties in the library.\n                              Be careful not to abuse this since this is not a replacement\n                              for usual code reuse techniques.\n\n    FOO.verify.cpp          - Compiles with clang-verify. This type of test is\n                              automatically marked as UNSUPPORTED if the compiler\n                              does not support Clang-verify.\n\n\n    Substitution requirements\n    ===============================\n    The test format operates by assuming that each test's configuration provides\n    the following substitutions, which it will reuse in the shell scripts it\n    constructs:\n        %{cxx}           - A command that can be used to invoke the compiler\n        %{compile_flags} - Flags to use when compiling a test case\n        %{link_flags}    - Flags to use when linking a test case\n        %{flags}         - Flags to use either when compiling or linking a test case\n        %{exec}          - A command to prefix the execution of executables\n\n    Note that when building an executable (as opposed to only compiling a source\n    file), all three of %{flags}, %{compile_flags} and %{link_flags} will be used\n    in the same command line. In other words, the test format doesn't perform\n    separate compilation and linking steps in this case.\n\n\n    Additional supported directives\n    ===============================\n    In addition to everything that's supported in Lit ShTests, this test format\n    also understands the following directives inside test files:\n\n        // FILE_DEPENDENCIES: file, directory, /path/to/file\n\n            This directive expresses that the test requires the provided files\n            or directories in order to run. An example is a test that requires\n            some test input stored in a data file. When a test file contains\n            such a directive, this test format will collect them and copy them\n            to the directory represented by %T. The intent is that %T contains\n            all the inputs necessary to run the test, such that e.g. execution\n            on a remote host can be done by simply copying %T to the host.\n\n        // ADDITIONAL_COMPILE_FLAGS: flag1, flag2, flag3\n\n            This directive will cause the provided flags to be added to the\n            %{compile_flags} substitution for the test that contains it. This\n            allows adding special compilation flags without having to use a\n            .sh.cpp test, which would be more powerful but perhaps overkill.\n\n\n    Additional provided substitutions and features\n    ==============================================\n    The test format will define the following substitutions for use inside tests:\n\n        %{build}\n            Expands to a command-line that builds the current source\n            file with the %{flags}, %{compile_flags} and %{link_flags}\n            substitutions, and that produces an executable named %t.exe.\n\n        %{run}\n            Equivalent to `%{exec} %t.exe`. This is intended to be used\n            in conjunction with the %{build} substitution.\n    \"\"\"\n\n    def getTestsForPath(self, testSuite, pathInSuite, litConfig, localConfig):\n        SUPPORTED_SUFFIXES = [\n            \"[.]pass[.]cpp$\",\n            \"[.]pass[.]mm$\",\n            \"[.]compile[.]pass[.]cpp$\",\n            \"[.]compile[.]pass[.]mm$\",\n            \"[.]compile[.]fail[.]cpp$\",\n            \"[.]link[.]pass[.]cpp$\",\n            \"[.]link[.]pass[.]mm$\",\n            \"[.]link[.]fail[.]cpp$\",\n            \"[.]sh[.][^.]+$\",\n            \"[.]gen[.][^.]+$\",\n            \"[.]verify[.]cpp$\",\n            \"[.]fail[.]cpp$\",\n        ]\n\n        sourcePath = testSuite.getSourcePath(pathInSuite)\n        filename = os.path.basename(sourcePath)\n\n        # Ignore dot files, excluded tests and tests with an unsupported suffix\n        hasSupportedSuffix = lambda f: any([re.search(ext, f) for ext in SUPPORTED_SUFFIXES])\n        if filename.startswith(\".\") or filename in localConfig.excludes or not hasSupportedSuffix(filename):\n            return\n\n        # If this is a generated test, run the generation step and add\n        # as many Lit tests as necessary.\n        if re.search('[.]gen[.][^.]+$', filename):\n            for test in self._generateGenTest(testSuite, pathInSuite, litConfig, localConfig):\n                yield test\n        else:\n            yield lit.Test.Test(testSuite, pathInSuite, localConfig)\n\n    def execute(self, test, litConfig):\n        VERIFY_FLAGS = (\n            \"-Xclang -verify -Xclang -verify-ignore-unexpected=note -ferror-limit=0\"\n        )\n        supportsVerify = \"verify-support\" in test.config.available_features\n        filename = test.path_in_suite[-1]\n\n        if re.search(\"[.]sh[.][^.]+$\", filename):\n            steps = []  # The steps are already in the script\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".compile.pass.cpp\") or filename.endswith(\n            \".compile.pass.mm\"\n        ):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".compile.fail.cpp\"):\n            steps = [\n                \"%dbg(COMPILED WITH) ! %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".link.pass.cpp\") or filename.endswith(\".link.pass.mm\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".link.fail.cpp\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -c -o %t.o\",\n                \"%dbg(LINKED WITH) ! %{cxx} %t.o %{flags} %{link_flags} -o %t.exe\",\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".verify.cpp\"):\n            if not supportsVerify:\n                return lit.Test.Result(\n                    lit.Test.UNSUPPORTED,\n                    \"Test {} requires support for Clang-verify, which isn't supported by the compiler\".format(\n                        test.getFullName()\n                    ),\n                )\n            steps = [\n                # Note: Use -Wno-error to make sure all diagnostics are not treated as errors,\n                #       which doesn't make sense for clang-verify tests.\n                \"%dbg(COMPILED WITH) %{{cxx}} %s %{{flags}} %{{compile_flags}} -fsyntax-only -Wno-error {}\".format(\n                    VERIFY_FLAGS\n                )\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        # Make sure to check these ones last, since they will match other\n        # suffixes above too.\n        elif filename.endswith(\".pass.cpp\") or filename.endswith(\".pass.mm\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\",\n                \"%dbg(EXECUTED AS) %{exec} %t.exe\",\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        else:\n            return lit.Test.Result(\n                lit.Test.UNRESOLVED, \"Unknown test suffix for '{}'\".format(filename)\n            )\n\n    def _executeShTest(self, test, litConfig, steps):\n        if test.config.unsupported:\n            return lit.Test.Result(lit.Test.UNSUPPORTED, \"Test is unsupported\")\n\n        script = parseScript(test, steps)\n        if isinstance(script, lit.Test.Result):\n            return script\n\n        if litConfig.noExecute:\n            return lit.Test.Result(\n                lit.Test.XFAIL if test.isExpectedToFail() else lit.Test.PASS\n            )\n        else:\n            _, tmpBase = _getTempPaths(test)\n            useExternalSh = False\n            return lit.TestRunner._runShTest(\n                test, litConfig, useExternalSh, script, tmpBase\n            )\n\n    def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig):\n        generator = lit.Test.Test(testSuite, pathInSuite, localConfig)\n\n        # Make sure we have a directory to execute the generator test in\n        generatorExecDir = os.path.dirname(testSuite.getExecPath(pathInSuite))\n        os.makedirs(generatorExecDir, exist_ok=True)\n\n        # Run the generator test\n        steps = [] # Steps must already be in the script\n        (out, err, exitCode, _, _) = _executeScriptInternal(generator, litConfig, steps)\n        if exitCode != 0:\n            raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n\n        # Split the generated output into multiple files and generate one test for each file\n        parsed = _parseLitOutput(out)\n        for (subfile, content) in self._splitFile(parsed):\n            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n            os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n            with open(generatedFile, 'w') as f:\n                f.write(content)\n            yield lit.Test.Test(testSuite, (generatedFile,), localConfig)\n\n    def _splitFile(self, input):\n        DELIM = r'^(//|#)---(.+)'\n        lines = input.splitlines()\n        currentFile = None\n        thisFileContent = []\n        for line in lines:\n            match = re.match(DELIM, line)\n            if match:\n                if currentFile is not None:\n                    yield (currentFile, '\\n'.join(thisFileContent))\n                currentFile = match.group(2).strip()\n                thisFileContent = []\n            assert currentFile is not None, f\"Some input to split-file doesn't belong to any file, input was:\\n{input}\"\n            thisFileContent.append(line)\n        if currentFile is not None:\n            yield (currentFile, '\\n'.join(thisFileContent))\n"}}, "msg": "[lit] Improve test output from lit's internal shell\n\nThis patch and D154984 were discussed in\n<https://discourse.llvm.org/t/rfc-improving-lits-debug-output/72839>.\n\nMotivation\n----------\n\nD154984 removes the \"Script:\" section that lit prints along with a\ntest's output, and it makes -v and -a imply -vv.  For example, after\nD154984, the \"Script:\" section below is never shown, but -v is enough\nto produce the execution trace following it:\n\n```\n Script:\n --\n : 'RUN: at line 1'; echo hello | FileCheck bogus.txt && echo success\n --\n Exit Code: 2\n\n Command Output (stdout):\n --\n $ \":\" \"RUN: at line 1\"\n $ \"echo\" \"hello\"\n # command output:\n hello\n\n $ \"FileCheck\" \"bogus.txt\"\n # command stderr:\n Could not open check file 'bogus.txt': No such file or directory\n\n error: command failed with exit status: 2\n\n --\n```\n\nIn the D154984 review, some reviewers point out that they have been\nusing the \"Script:\" section for copying and pasting a test's shell\ncommands to a terminal window.  The shell commands as printed in the\nexecution trace can be harder to copy and paste for the following\nreasons:\n\n- They drop redirections and break apart RUN lines at `&&`, `|`, etc.\n- They add `$` at the start of every command, which makes it hard to\n  copy and paste multiple commands in bulk.\n- Command stdout, stderr, etc. are interleaved with the commands and\n  are not clearly delineated.\n- They don't always use proper shell quoting.  Instead, they blindly\n  enclose all command-line arguments in double quotes.\n\nChanges\n-------\n\nD154984 plus this patch converts the above example into:\n\n```\n Exit Code: 2\n\n Command Output (stdout):\n --\n # RUN: at line 1\n echo hello | FileCheck bogus-file.txt && echo success\n # executed command: echo hello\n # .---command stdout------------\n # | hello\n # `-----------------------------\n # executed command: FileCheck bogus-file.txt\n # .---command stderr------------\n # | Could not open check file 'bogus-file.txt': No such file or directory\n # `-----------------------------\n # error: command failed with exit status: 2\n\n --\n```\n\nThus, this patch addresses the above issues as follows:\n\n- The entire execution trace can be copied and pasted in bulk to a\n  terminal for correct execution of the RUN lines, which are printed\n  intact as they appeared in the original RUN lines except lit\n  substitutions are expanded.  Everything else in the execution trace\n  appears in shell comments so it has no effect in a terminal.\n- Each of the RUN line's commands is repeated (in shell comments) as\n  it executes to show (1) that the command actually executed (e.g.,\n  `echo success` above didn't) and (2) what stdout, stderr, non-zero\n  exit status, and output files are associated with the command, if\n  any.  Shell quoting in the command is now correct and minimal but is\n  not necessarily the original shell quoting from the RUN line.\n- The start and end of the contents of stdout, stderr, or an output\n  file is now delineated clearly in the trace.\n\nTo help produce some of the above output, this patch extends lit's\ninternal shell with a built-in `@echo` command.  It's like `echo`\nexcept lit suppresses the normal execution trace for `@echo` and just\nprints its stdout directly.  For now, `@echo` isn't documented for use\nin lit tests.\n\nWithout this patch, libcxx's custom lit test format tries to parse the\nstdout from `lit.TestRunner.executeScriptInternal` (which runs lit's\ninternal shell) to extract the stdout and stderr produced by shell\ncommands, and that parse no longer works after the above changes.\nThis patch makes a small adjustment to\n`lit.TestRunner.executeScriptInternal` so libcxx can just request\nstdout and stderr without an execution trace.\n\n(As a minor drive-by fix that came up in testing: lit's internal `not`\ncommand now always produces a numeric exit status and never `True`.)\n\nCaveat\n------\n\nThis patch only makes the above changes for lit's internal shell.  In\nmost cases, we do not know how to force external shells (e.g., bash,\nsh, window's `cmd`) to produce execution traces in the manner we want.\n\nTo configure a test suite to use lit's internal shell (which is\nusually better for test portability than external shells anyway), add\nthis to the test suite's `lit.cfg` or other configuration file:\n\n```\nconfig.test_format = lit.formats.ShTest(execute_external=False)\n```\n\nReviewed By: MaskRay, awarzynski\n\nDifferential Revision: https://reviews.llvm.org/D156954"}}, "https://github.com/MIPS/llvm": {"c981c533055e14302e7bff5d6898c9308065f665": {"url": "https://api.github.com/repos/MIPS/llvm/commits/c981c533055e14302e7bff5d6898c9308065f665", "html_url": "https://github.com/MIPS/llvm/commit/c981c533055e14302e7bff5d6898c9308065f665", "sha": "c981c533055e14302e7bff5d6898c9308065f665", "keyword": "execution after redirect correct", "diff": "diff --git a/libcxx/utils/libcxx/test/dsl.py b/libcxx/utils/libcxx/test/dsl.py\nindex 847cebf5962f..4c2217ec3142 100644\n--- a/libcxx/utils/libcxx/test/dsl.py\n+++ b/libcxx/utils/libcxx/test/dsl.py\n@@ -180,7 +180,7 @@ def programOutput(config, program, args=None):\n                 \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n             )\n \n-        return libcxx.test.format._parseLitOutput(out)\n+        return out\n \n \n @_memoizeExpensiveOperation(\ndiff --git a/libcxx/utils/libcxx/test/format.py b/libcxx/utils/libcxx/test/format.py\nindex ddd88f25646e..2be42d293280 100644\n--- a/libcxx/utils/libcxx/test/format.py\n+++ b/libcxx/utils/libcxx/test/format.py\n@@ -35,39 +35,6 @@ def _checkBaseSubstitutions(substitutions):\n     for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n         assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n \n-def _parseLitOutput(fullOutput):\n-    \"\"\"\n-    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n-\n-    This takes output of the form\n-\n-        $ \":\" \"RUN: at line 11\"\n-        $ \"echo\" \"OUTPUT1\"\n-        # command output:\n-        OUTPUT1\n-\n-        $ \":\" \"RUN: at line 12\"\n-        $ \"echo\" \"OUTPUT2\"\n-        # command output:\n-        OUTPUT2\n-\n-    and returns a string containing\n-\n-        OUTPUT1\n-        OUTPUT2\n-\n-    as-if the commands had been run directly. This is a workaround for the fact\n-    that Lit doesn't let us execute ShTest and retrieve the raw output without\n-    injecting additional Lit output around it.\n-    \"\"\"\n-    parsed = ''\n-    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n-        if output: # skip blank lines\n-            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n-            if commandOutput:\n-                parsed += commandOutput.group(1)\n-    return parsed\n-\n def _executeScriptInternal(test, litConfig, commands):\n     \"\"\"\n     Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n@@ -79,21 +46,12 @@ def _executeScriptInternal(test, litConfig, commands):\n     _, tmpBase = _getTempPaths(test)\n     execDir = os.path.dirname(test.getExecPath())\n     res = lit.TestRunner.executeScriptInternal(\n-        test, litConfig, tmpBase, parsedCommands, execDir\n+        test, litConfig, tmpBase, parsedCommands, execDir, debug=False\n     )\n     if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n         res = (\"\", res.output, 127, None)\n     (out, err, exitCode, timeoutInfo) = res\n \n-    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n-    #       split any stderr output that is included in stdout. It shouldn't be there, but\n-    #       the Lit internal shell conflates stderr and stdout.\n-    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n-    if conflatedErrorOutput:\n-        conflatedErrorOutput = conflatedErrorOutput.group(0)\n-        out = out[: -len(conflatedErrorOutput)]\n-        err += conflatedErrorOutput\n-\n     return (out, err, exitCode, timeoutInfo, parsedCommands)\n \n \n@@ -400,8 +358,7 @@ def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig):\n             raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n \n         # Split the generated output into multiple files and generate one test for each file\n-        parsed = _parseLitOutput(out)\n-        for (subfile, content) in self._splitFile(parsed):\n+        for (subfile, content) in self._splitFile(out):\n             generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n             os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n             with open(generatedFile, 'w') as f:\ndiff --git a/llvm/utils/lit/lit/TestRunner.py b/llvm/utils/lit/lit/TestRunner.py\nindex 0629eca42049..461cf63d6b96 100644\n--- a/llvm/utils/lit/lit/TestRunner.py\n+++ b/llvm/utils/lit/lit/TestRunner.py\n@@ -8,6 +8,7 @@\n import stat\n import pathlib\n import platform\n+import shlex\n import shutil\n import tempfile\n import threading\n@@ -57,6 +58,14 @@ def __init__(self, command, message):\n kPdbgRegex = \"%dbg\\\\(([^)'\\\"]*)\\\\)(.*)\"\n \n \n+def buildPdbgCommand(msg, cmd):\n+    res = f\"%dbg({msg}) {cmd}\"\n+    assert re.match(\n+        kPdbgRegex, res\n+    ), f\"kPdbgRegex expected to match actual %dbg usage: {res}\"\n+    return res\n+\n+\n class ShellEnvironment(object):\n \n     \"\"\"Mutable shell environment containing things like CWD and env vars.\n@@ -340,12 +349,12 @@ def executeBuiltinExport(cmd, shenv):\n \n \n def executeBuiltinEcho(cmd, shenv):\n-    \"\"\"Interpret a redirected echo command\"\"\"\n+    \"\"\"Interpret a redirected echo or @echo command\"\"\"\n     opened_files = []\n     stdin, stdout, stderr = processRedirects(cmd, subprocess.PIPE, shenv, opened_files)\n     if stdin != subprocess.PIPE or stderr != subprocess.PIPE:\n         raise InternalShellError(\n-            cmd, \"stdin and stderr redirects not supported for echo\"\n+            cmd, f\"stdin and stderr redirects not supported for {cmd.args[0]}\"\n         )\n \n     # Some tests have un-redirected echo commands to help debug test failures.\n@@ -692,6 +701,7 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n         \"cd\": executeBuiltinCd,\n         \"export\": executeBuiltinExport,\n         \"echo\": executeBuiltinEcho,\n+        \"@echo\": executeBuiltinEcho,\n         \"mkdir\": executeBuiltinMkdir,\n         \"popd\": executeBuiltinPopd,\n         \"pushd\": executeBuiltinPushd,\n@@ -919,7 +929,7 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n         if res == -signal.SIGINT:\n             raise KeyboardInterrupt\n         if proc_not_counts[i] % 2:\n-            res = not res\n+            res = 1 if res == 0 else 0\n         elif proc_not_counts[i] > 1:\n             res = 1 if res != 0 else 0\n \n@@ -982,19 +992,58 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n     return exitCode\n \n \n-def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n+def formatOutput(title, data, limit=None):\n+    if not data.strip():\n+        return \"\"\n+    if not limit is None and len(data) > limit:\n+        data = data[:limit] + \"\\n...\\n\"\n+        msg = \"data was truncated\"\n+    else:\n+        msg = \"\"\n+    ndashes = 30\n+    out =  f\"# .---{title}{'-' * (ndashes - 4 - len(title))}\\n\"\n+    out += f\"# | \" + \"\\n# | \".join(data.splitlines()) + \"\\n\"\n+    out += f\"# `---{msg}{'-' * (ndashes - 4 - len(msg))}\\n\"\n+    return out\n+\n+# Normally returns out, err, exitCode, timeoutInfo.\n+#\n+# If debug is True (the normal lit behavior), err is empty, and out contains an\n+# execution trace, including stdout and stderr shown per command executed.\n+#\n+# If debug is False (set by some custom lit test formats that call this\n+# function), out contains only stdout from the script, err contains only stderr\n+# from the script, and there is no execution trace.\n+def executeScriptInternal(test, litConfig, tmpBase, commands, cwd,\n+                          debug=True):\n     cmds = []\n     for i, ln in enumerate(commands):\n+        # Within lit, we try to always add '%dbg(...)' to command lines in order\n+        # to maximize debuggability.  However, custom lit test formats might not\n+        # always add it, so add a generic debug message in that case.\n         match = re.match(kPdbgRegex, ln)\n         if match:\n+            dbg = match.group(1)\n             command = match.group(2)\n-            ln = commands[i] = match.expand(\": '\\\\1'; \\\\2\" if command else \": '\\\\1'\")\n+        else:\n+            dbg = \"command line\"\n+            command = ln\n+        if debug:\n+            ln = f\"@echo '# {dbg}' \"\n+            if command:\n+                ln += f\"&& @echo {shlex.quote(command.lstrip())} && {command}\"\n+            else:\n+                ln += \"has no command after substitutions\"\n+        else:\n+            ln = command\n         try:\n             cmds.append(\n                 ShUtil.ShParser(ln, litConfig.isWindows, test.config.pipefail).parse()\n             )\n         except:\n-            return lit.Test.Result(Test.FAIL, \"shell parser error on: %r\" % ln)\n+            return lit.Test.Result(\n+                Test.FAIL, f\"shell parser error on {dbg}: {command.lstrip()}\\n\"\n+            )\n \n     cmd = cmds[0]\n     for c in cmds[1:]:\n@@ -1014,8 +1063,42 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n \n     out = err = \"\"\n     for i, result in enumerate(results):\n-        # Write the command line run.\n-        out += \"$ %s\\n\" % (\" \".join('\"%s\"' % s for s in result.command.args),)\n+        if not debug:\n+            out += result.stdout\n+            err += result.stderr\n+            continue\n+\n+        # The purpose of an \"@echo\" command is merely to add a debugging message\n+        # directly to lit's output.  It is used internally by lit's internal\n+        # shell and is not currently documented for use in lit tests.  However,\n+        # if someone misuses it (e.g., both \"echo\" and \"@echo\" complain about\n+        # stdin redirection), produce the normal execution trace to facilitate\n+        # debugging.\n+        if (\n+            result.command.args[0] == \"@echo\"\n+            and result.exitCode == 0\n+            and not result.stderr\n+            and not result.outputFiles\n+            and not result.timeoutReached\n+        ):\n+            out += result.stdout\n+            continue\n+\n+        # Write the command line that was run.  Properly quote it.  Leading\n+        # \"!\" commands should not be quoted as that would indicate they are not\n+        # the builtins.\n+        out += \"# executed command: \"\n+        nLeadingBangs = next(\n+            (i for i, cmd in enumerate(result.command.args) if cmd != \"!\"),\n+            len(result.command.args),\n+        )\n+        out += \"! \" * nLeadingBangs\n+        out += \" \".join(\n+            shlex.quote(str(s))\n+            for i, s in enumerate(result.command.args)\n+            if i >= nLeadingBangs\n+        )\n+        out += \"\\n\"\n \n         # If nothing interesting happened, move on.\n         if (\n@@ -1030,22 +1113,16 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n \n         # Add the command output, if redirected.\n         for (name, path, data) in result.outputFiles:\n-            if data.strip():\n-                out += \"# redirected output from %r:\\n\" % (name,)\n-                data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n-                if len(data) > 1024:\n-                    out += data[:1024] + \"\\n...\\n\"\n-                    out += \"note: data was truncated\\n\"\n-                else:\n-                    out += data\n-                out += \"\\n\"\n-\n+            data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n+            out += formatOutput(\n+                f\"redirected output from '{name}'\", data, limit=1024\n+            )\n         if result.stdout.strip():\n-            out += \"# command output:\\n%s\\n\" % (result.stdout,)\n+            out += formatOutput(\"command stdout\", result.stdout)\n         if result.stderr.strip():\n-            out += \"# command stderr:\\n%s\\n\" % (result.stderr,)\n+            out += formatOutput(\"command stderr\", result.stderr)\n         if not result.stdout.strip() and not result.stderr.strip():\n-            out += \"note: command had no output on stdout or stderr\\n\"\n+            out += \"# note: command had no output on stdout or stderr\\n\"\n \n         # Show the error conditions:\n         if result.exitCode != 0:\n@@ -1055,9 +1132,9 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n                 codeStr = hex(int(result.exitCode & 0xFFFFFFFF)).rstrip(\"L\")\n             else:\n                 codeStr = str(result.exitCode)\n-            out += \"error: command failed with exit status: %s\\n\" % (codeStr,)\n+            out += \"# error: command failed with exit status: %s\\n\" % (codeStr,)\n         if litConfig.maxIndividualTestTime > 0 and result.timeoutReached:\n-            out += \"error: command reached timeout: %s\\n\" % (\n+            out += \"# error: command reached timeout: %s\\n\" % (\n                 str(result.timeoutReached),\n             )\n \n@@ -1833,13 +1910,7 @@ def _handleCommand(cls, line_number, line, output, keyword):\n         if not output or not output[-1].add_continuation(line_number, keyword, line):\n             if output is None:\n                 output = []\n-            pdbg = \"%dbg({keyword} at line {line_number})\".format(\n-                keyword=keyword, line_number=line_number\n-            )\n-            assert re.match(\n-                kPdbgRegex + \"$\", pdbg\n-            ), \"kPdbgRegex expected to match actual %dbg usage\"\n-            line = \"{pdbg} {real_command}\".format(pdbg=pdbg, real_command=line)\n+            line = buildPdbgCommand(f\"{keyword} at line {line_number}\", line)\n             output.append(CommandDirective(line_number, line_number, keyword, line))\n         return output\n \n@@ -2104,6 +2175,8 @@ def executeShTest(\n         return lit.Test.Result(Test.UNSUPPORTED, \"Test is unsupported\")\n \n     script = list(preamble_commands)\n+    script = [buildPdbgCommand(f\"preamble command line\", ln) for ln in script]\n+\n     parsed = parseIntegratedTestScript(test, require_script=not script)\n     if isinstance(parsed, lit.Test.Result):\n         return parsed\ndiff --git a/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg b/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\nindex cf1a4f1ba1ec..301208c25bdc 100644\n--- a/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\n+++ b/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\n@@ -5,4 +5,4 @@ config.suffixes = [\".txt\"]\n config.test_format = lit.formats.ShTest()\n config.test_source_root = None\n config.test_exec_root = None\n-config.substitutions.append((\"%var\", lit_config.params.get(\"var\", \"\")))\n+config.substitutions.append((\"%var\", lit_config.params.get(\"var\", \"default\")))\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt b/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\nindex 6dd9b16304e0..1d94c1213723 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\n@@ -14,21 +14,21 @@\n ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0 -fopenmp-simd\n ; REDEFINE: %{fcflags} = -check-prefix=SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu -fopenmp-simd\n ; REDEFINE: %{fcflags} = -check-prefix=SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0\n ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu\n ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n \n ; CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt b/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\nindex 3bf057151afb..23c0a6d50753 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\n@@ -7,7 +7,7 @@\n #\n # REDEFINE: %{global:greeting}=Hello\n # RUN: %{global:echo}\n-# CHECK: GLOBAL: Hello World\n+# CHECK:# | GLOBAL: Hello World\n \n # We can redefine the test suite config's substitutions multiple times.  Again,\n # the expansion order remains the same (%{global:echo} before %{global:greeting}\n@@ -17,7 +17,7 @@\n # REDEFINE: %{global:greeting}=Goodbye %{global:what}\n # REDEFINE: %{global:what}=Sleep\n # RUN: %{global:echo}\n-# CHECK: GLOBAL: Goodbye Sleep Sleep\n+# CHECK:# | GLOBAL: Goodbye Sleep Sleep\n \n # A new local substitution is prepended to the substitution list so that it can\n # depend on all substitutions that were defined previously, including those from\n@@ -26,7 +26,7 @@\n # DEFINE: %{local:greeting}=Hey %{global:what}\n # DEFINE: %{local:echo}=echo \"LOCAL: %{local:greeting} %{global:what}\"\n # RUN: %{local:echo}\n-# CHECK: LOCAL: Hey Sleep Sleep\n+# CHECK:# | LOCAL: Hey Sleep Sleep\n \n # As for substitutions from the test suite config, redefining local\n # substitutions should not change the expansion order.  Again, the expansion\n@@ -36,6 +36,6 @@\n # REDEFINE: %{local:greeting}=So Long %{global:what}\n # REDEFINE: %{global:what}=World\n # RUN: %{local:echo}\n-# CHECK: LOCAL: So Long World World\n+# CHECK:# | LOCAL: So Long World World\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt b/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\nindex 65f90792ff7b..5a1d7f2e1987 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\n@@ -1,19 +1,19 @@\n # Does it work as expected directly in RUN lines?\n # RUN: echo %(line), %(line-1), %(line+2)\n-# CHECK: [[#@LINE-1]], [[#@LINE-2]], [[#@LINE+1]]\n+# CHECK:# | [[#@LINE-1]], [[#@LINE-2]], [[#@LINE+1]]\n \n # %(line) substitutions refer to the original DEFINE/REDEFINE line not the RUN\n # line they eventually appear within.\n #\n # DEFINE: %{lines} = %(line)\n # RUN: echo '%{lines}'\n-# CHECK: [[#@LINE-2]]\n+# CHECK:# | [[#@LINE-2]]\n #\n # REDEFINE: %{lines} = %(line),                                                \\\n # REDEFINE:            %(line),                                                \\\n # REDEFINE:            %(line)\n # RUN: echo '%{lines}'\n-# CHECK: [[#@LINE-4]], [[#@LINE-3]], [[#@LINE-2]]\n+# CHECK:# | [[#@LINE-4]], [[#@LINE-3]], [[#@LINE-2]]\n \n # %(line+N) and %{line-N) should work too.\n #\n@@ -21,12 +21,12 @@\n # DEFINE:                %(line),                                              \\\n # DEFINE:                %(line-1)\n # RUN: echo '%{lines-rel}'\n-# CHECK: [[#@LINE-3]], [[#@LINE-3]], [[#@LINE-3]]\n+# CHECK:# | [[#@LINE-3]], [[#@LINE-3]], [[#@LINE-3]]\n #\n # REDEFINE: %{lines-rel} = %(line+5),                                          \\\n # REDEFINE:                %(line+0),                                          \\\n # REDEFINE:                %(line-10)\n # RUN: echo '%{lines-rel}'\n-# CHECK: [[#@LINE+1]], [[#@LINE-3]], [[#@LINE-12]]\n+# CHECK:# | [[#@LINE+1]], [[#@LINE-3]], [[#@LINE-12]]\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt b/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\nindex 18a27cdd72fa..d27fda2e2fe6 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\n@@ -1,25 +1,25 @@\n # DEFINE: %{abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789} = ok\n # RUN: echo '%{abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789}'\n-# CHECK: ok\n+# CHECK:# | ok\n \n # DEFINE: %{FooBar} = ok at %(line)\n # RUN: echo '%{FooBar}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{fooBar} = ok at %(line)\n # RUN: echo '%{fooBar}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{foo-bar-} = ok at %(line)\n # RUN: echo '%{foo-bar-}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{foo:bar:} = ok at %(line)\n # RUN: echo '%{foo:bar:}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{_foo_bar_} = ok at %(line)\n # RUN: echo '%{_foo_bar_}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt b/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\nindex eb5f0b918fd1..e504b822ace8 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\n@@ -6,7 +6,7 @@\n \n # RUN: echo '%{outer}'\n \n-# CHECK-NON-RECUR:%{inner}\n-# CHECK-RECUR:expanded\n+# CHECK-NON-RECUR:# | %{inner}\n+# CHECK-RECUR:# | expanded\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt b/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\nindex 9d2e7197fb3a..c1bdfef30b1a 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\n@@ -2,21 +2,21 @@\n \n # DEFINE: %{equals} = FileCheck -check-prefixes=FOO,BAR\n # RUN: echo '%{equals}'\n-# CHECK: FileCheck -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -check-prefixes=FOO,BAR\n #\n # REDEFINE: %{equals} == == =\n # RUN: echo '%{equals}'\n-# CHECK: = == =\n+# CHECK:# | = == =\n \n # DEFINE: %{continue-equals} = FileCheck -strict-whitespace -match-full-lines \\\n # DEFINE:                      -check-prefixes=FOO,BAR\n # RUN: echo '%{continue-equals}'\n-# CHECK: FileCheck -strict-whitespace -match-full-lines -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -strict-whitespace -match-full-lines -check-prefixes=FOO,BAR\n #\n # REDEFINE: %{continue-equals} = FileCheck -input-file=test.txt                \\\n # REDEFINE:                      -implicit-check-not=foobar                    \\\n # REDEFINE:                      -check-prefixes=FOO,BAR\n # RUN: echo '%{continue-equals}'\n-# CHECK: FileCheck -input-file=test.txt -implicit-check-not=foobar -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -input-file=test.txt -implicit-check-not=foobar -check-prefixes=FOO,BAR\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt b/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\nindex 58d5c1a34ce8..9143796edd32 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\n@@ -6,11 +6,11 @@\n \n # DEFINE: %{escape} = \\g<0>\\n\n # RUN: echo '%{escape}'\n-# CHECK: {{\\\\?}}\\g<0>{{\\\\?}}\\n\n+# CHECK:# | {{\\\\?}}\\g<0>{{\\\\?}}\\n\n \n # REDEFINE: %{escape} = \\n                                                     \\\n # REDEFINE:             \\g<param>\n # RUN: echo '%{escape}'\n-# CHECK: {{\\\\?}}\\n {{\\\\?}}\\g<param>\n+# CHECK:# | {{\\\\?}}\\n {{\\\\?}}\\g<param>\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt b/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\nindex 1259e511ba70..3e4db1b15d92 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\n@@ -3,33 +3,33 @@\n #\n # DEFINE: %{empty}=\n # RUN: echo \"'%{empty}'\"\n-# CHECK:''\n+# CHECK:# | ''\n #\n # REDEFINE: %{empty}=\n # RUN: echo \"'%{empty}'\"\n-# CHECK:''\n+# CHECK:# | ''\n \n # A value consisting only of whitespace is trimmed to the empty string.\n #\n #               v~~ intentional whitespace\n # DEFINE: %{ws}=   \n # RUN: echo \"'%{ws}'\"\n-# CHECK:''\n+# CHECK:# | ''\n #\n #                 v intentional whitespace\n # REDEFINE: %{ws}= \n # RUN: echo \"'%{ws}'\"\n-# CHECK:''\n+# CHECK:# | ''\n \n # Whitespace is not required around the name or value.\n #\n # DEFINE:%{no-whitespace}=abc\n # RUN: echo \"'%{no-whitespace}'\"\n-# CHECK:'abc'\n+# CHECK:# | 'abc'\n #\n # REDEFINE:%{no-whitespace}=HelloWorld\n # RUN: echo \"'%{no-whitespace}'\"\n-# CHECK:'HelloWorld'\n+# CHECK:# | 'HelloWorld'\n \n # Whitespace is not required between substitutions in a value.\n #\n@@ -37,11 +37,11 @@\n # DEFINE: %{adjacent1} = bar\n # DEFINE: %{has-adjacent-substs} = %{adjacent0}%{adjacent1}\n # RUN: echo \"'%{has-adjacent-substs}'\"\n-# CHECK:'foobar'\n+# CHECK:# | 'foobar'\n #\n # REDEFINE: %{has-adjacent-substs} = %{adjacent0}%{adjacent1}%{adjacent0}\n # RUN: echo \"'%{has-adjacent-substs}'\"\n-# CHECK:'foobarfoo'\n+# CHECK:# | 'foobarfoo'\n \n # Exact whitespace is preserved within the value, but whitespace enclosing the\n # name or value is discarded.  ('%{' and '}' are part of the name, and\n@@ -50,11 +50,11 @@\n #                                       v~~ intentional whitespace\n # DEFINE:   %{whitespace}  =  abc    def   \n # RUN: echo \"'%{whitespace}'\"\n-# CHECK:'abc    def'\n+# CHECK:# | 'abc    def'\n #                                      v intentional whitespace\n # REDEFINE: %{whitespace} = Hello World \n # RUN: echo \"'%{whitespace}'\"\n-# CHECK:'Hello World'\n+# CHECK:# | 'Hello World'\n \n # Line continuations in the value are permitted and collapse whitespace.\n #\n@@ -66,12 +66,12 @@\n # DEFINE:  pqr \n #             ^ intentional whitespace\n # RUN: echo \"'%{continue}'\"\n-# CHECK:'abc def ghi jkl mno pqr'\n+# CHECK:# | 'abc def ghi jkl mno pqr'\n #\n # REDEFINE: %{continue} =  abc  \\\n # REDEFINE: def\n # RUN: echo \"'%{continue}'\"\n-# CHECK:'abc def'\n+# CHECK:# | 'abc def'\n \n # Whitespace at the end of the line after a '\\' is ignored, and it's treated as\n # a line continuation.  Otherwise, the behavior would be hard to understand\n@@ -83,7 +83,7 @@\n #                                   ^ intentional whitespace\n # DEFINE: baz\n # RUN: echo \"'%{ws-after-continue}'\"\n-# CHECK:'foo bar baz'\n+# CHECK:# | 'foo bar baz'\n #\n #                                     v intentional whitespace\n # REDEFINE: %{ws-after-continue}=foo \\ \n@@ -91,7 +91,7 @@\n #                                     ^~~~~~~~~~~~ intentional whitespace\n # REDEFINE: baz\n # RUN: echo \"'%{ws-after-continue}'\"\n-# CHECK:'foo bar baz'\n+# CHECK:# | 'foo bar baz'\n \n # A line continuation is recognized anywhere.  It should be used only where\n # whitespace is permitted because it reduces to a single space.\n@@ -107,7 +107,7 @@\n # DEFINE:\\\n # DEFINE:a\n # RUN: echo \"'%{blank-lines}'\"\n-# CHECK:'a'\n+# CHECK:# | 'a'\n #\n # REDEFINE:                  \\\n # REDEFINE: %{blank-lines}   \\\n@@ -120,7 +120,7 @@\n # REDEFINE:                  \\\n # REDEFINE:      c\n # RUN: echo \"'%{blank-lines}'\"\n-# CHECK:'a b c'\n+# CHECK:# | 'a b c'\n \n # The fourth DEFINE line is deceptive because it looks like a new substitution,\n # but it's actually a continuation of the previous value.\n@@ -130,6 +130,6 @@\n # DEFINE: %{deceptive-continue}=echo \\\n # DEFINE: %{name}=%{value}\n # RUN: %{deceptive-continue}\n-# CHECK:x=3\n+# CHECK:# | x=3\n \n # CHECK:{{ *}}Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt b/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\nindex b0a7cfd97941..b5fc1b49fcc5 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\n@@ -1,46 +1,34 @@\n-#       CHECK: -- Testing:{{.*}}\n-#  CHECK-NEXT: PASS: shtest-if-else :: test.txt (1 of 1)\n-#  CHECK-NEXT: Exit Code: 0\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: Command Output (stdout):\n-#  CHECK-NEXT: --\n+# CHECK: -- Testing:{{.*}}\n+# CHECK-NEXT: PASS: shtest-if-else :: test.txt (1 of 1)\n+#      CHECK: Command Output (stdout):\n+# CHECK-NEXT: --\n \n # RUN: %if feature %{ echo \"test-1\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-1\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-1\"\n \n # If %else is not present it is treated like %else %{%}. Empty commands\n # are ignored.\n #\n # RUN: %if nofeature %{ echo \"fail\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#   CHECK-NOT: fail\n+#     CHECK: # {{RUN}}: at line [[#@LINE-1]] has no command after substitutions\n+# CHECK-NOT: fail\n \n # RUN: %if nofeature %{ echo \"fail\" %} %else %{ echo \"test-2\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-2\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-2\"\n \n # Spaces inside curly braces are not ignored\n #\n # RUN: echo test-%if feature %{ 3 %} %else %{ fail %}-test\n # RUN: echo test-%if feature %{ 4 4 %} %else %{ fail %}-test\n # RUN: echo test-%if nofeature %{ fail %} %else %{ 5 5 %}-test\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 3 -test\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 4 4 -test\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 5 5 -test\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo test- 3 -test\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo test- 4 4 -test\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo test- 5 5 -test\n \n # Escape line breaks for multi-line expressions\n #\n@@ -48,42 +36,32 @@\n # RUN:   %{ echo     \\\n # RUN:     \"test-5\" \\\n # RUN:   %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-4]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-5\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-5\"\n \n # RUN: %if nofeature       \\\n # RUN:   %{ echo \"fail\" %}   \\\n # RUN: %else               \\\n # RUN:   %{ echo \"test-6\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-4]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-6\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-6\"\n \n # RUN: echo \"test%if feature %{%} %else %{%}-7\"\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-7\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-7\"\n \n # Escape %if. Without %if..%else context '%{' and '%}' are treated\n # literally.\n #\n # RUN: echo %%if feature %{ echo \"test-8\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: %if feature %{ echo test-8 %}\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo %if feature %{ echo \"test-8\" %}\n \n # Nested expressions are supported:\n #\n # RUN: echo %if feature %{ %if feature %{ %if nofeature %{\"fail\"%} %else %{\"test-9\"%} %} %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-9\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-9\"\n \n # Binary expression evaluation and regex match can be used as\n # conditions.\n@@ -91,18 +69,12 @@\n # RUN: echo %if feature && !nofeature %{ \"test-10\" %}\n # RUN: echo %if feature && nofeature %{ \"fail\" %} %else %{ \"test-11\" %}\n # RUN: echo %if {{fea.+}} %{ \"test-12\" %} %else %{ \"fail\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-10\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-11\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-12\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo \"test-10\"\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-11\"\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo \"test-12\"\n \n # Spaces between %if and %else are ignored. If there is no %else -\n # space after %if %{...%} is not ignored.\n@@ -110,39 +82,27 @@\n # RUN: echo XX %if feature %{YY%} ZZ\n # RUN: echo AA %if feature %{BB%} %else %{CC%} DD\n # RUN: echo AA %if nofeature %{BB%} %else %{CC%} DD\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: XX YY ZZ\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: AA BB DD\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: AA CC DD\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo XX YY ZZ\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo AA BB DD\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo AA CC DD\n \n # '{' and '}' can be used without escaping\n #\n # RUN: %if feature %{echo {}%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: {}\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo {}\n \n # Spaces are not required\n #\n # RUN: echo %if feature%{\"ok\"%}%else%{\"fail\"%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: ok\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"ok\"\n \n # Substitutions with braces are handled correctly\n #\n # RUN: echo %{sub} %if feature%{test-%{sub}%}%else%{\"fail\"%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: ok test-ok\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo ok test-ok\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt b/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\nindex fb3a3e000789..5ff0c891450b 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\n@@ -1,3 +1,4 @@\n # RUN: true\n # RUN: echo hi\n-# RUN: not not wc missing-file &> %t.out\n+# RUN: not not wc missing-file &> %t.out || true\n+# RUN: not %{python} %S/write-a-lot.py &> %t.out\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg b/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\nindex b872854d21e6..c53fd157b6ae 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\n@@ -2,4 +2,5 @@ import lit.formats\n \n config.name = \"shtest-output-printing\"\n config.suffixes = [\".txt\"]\n+config.substitutions.append((\"%{python}\", sys.executable))\n config.test_format = lit.formats.ShTest(execute_external=False)\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py b/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py\nnew file mode 100644\nindex 000000000000..ffcba7d517cd\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py\n@@ -0,0 +1,6 @@\n+#!/usr/bin/env python\n+\n+import sys\n+\n+sys.stdout.write(\"All work and no play makes Jack a dull boy.\\n\" * 1000);\n+sys.stdout.flush()\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt\nnew file mode 100644\nindex 000000000000..15a87aee46a3\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt\n@@ -0,0 +1 @@\n+RUN: @echo 2> %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt\nnew file mode 100644\nindex 000000000000..27fd0c4209fd\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt\n@@ -0,0 +1,2 @@\n+RUN: touch %t\n+RUN: @echo < %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt\nnew file mode 100644\nindex 000000000000..9611918f7e12\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt\n@@ -0,0 +1 @@\n+RUN: echo 2> %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt\nnew file mode 100644\nindex 000000000000..bc771be6b22a\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt\n@@ -0,0 +1,2 @@\n+RUN: touch %t\n+RUN: echo < %t\ndiff --git a/llvm/utils/lit/tests/allow-retries.py b/llvm/utils/lit/tests/allow-retries.py\nindex b8abe0ba4fee..ef548534f082 100644\n--- a/llvm/utils/lit/tests/allow-retries.py\n+++ b/llvm/utils/lit/tests/allow-retries.py\n@@ -15,9 +15,28 @@\n \n # This test does not succeed within the allowed retry limit\n #\n-# RUN: not %{lit} %{inputs}/allow-retries/does-not-succeed-within-limit.py | FileCheck --check-prefix=CHECK-TEST3 %s\n-# CHECK-TEST3: Failed Tests (1):\n-# CHECK-TEST3: allow-retries :: does-not-succeed-within-limit.py\n+# Check that the execution trace isn't corrupt due to reprocessing the script\n+# multiple times (e.g., '%dbg(...)' processing used to accumulate across\n+# retries).\n+#\n+# RUN: not %{lit} %{inputs}/allow-retries/does-not-succeed-within-limit.py -v |\\\n+# RUN:   FileCheck --check-prefix=CHECK-TEST3 -match-full-lines %s\n+#\n+#       CHECK-TEST3: FAIL: allow-retries :: does-not-succeed-within-limit.py (1 of 1)\n+#  CHECK-TEST3-NEXT: {{\\**}} TEST 'allow-retries :: does-not-succeed-within-limit.py' FAILED {{\\**}}\n+#  CHECK-TEST3-NEXT: Exit Code: 1\n+# CHECK-TEST3-EMPTY:\n+#  CHECK-TEST3-NEXT: Command Output (stdout):\n+#  CHECK-TEST3-NEXT: --\n+#  CHECK-TEST3-NEXT: # {{RUN}}: at line 3\n+#  CHECK-TEST3-NEXT: false\n+#  CHECK-TEST3-NEXT: # executed command: false\n+#  CHECK-TEST3-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-TEST3-NEXT: # error: command failed with exit status: 1\n+# CHECK-TEST3-EMPTY:\n+#  CHECK-TEST3-NEXT: --\n+#       CHECK-TEST3: Failed Tests (1):\n+#       CHECK-TEST3: allow-retries :: does-not-succeed-within-limit.py\n \n # This test should be UNRESOLVED since it has more than one ALLOW_RETRIES\n # lines, and that is not allowed.\ndiff --git a/llvm/utils/lit/tests/lit-opts.py b/llvm/utils/lit/tests/lit-opts.py\nindex d292ca74f3b9..a533a59d9d12 100644\n--- a/llvm/utils/lit/tests/lit-opts.py\n+++ b/llvm/utils/lit/tests/lit-opts.py\n@@ -8,7 +8,7 @@\n #\n # RUN: env LIT_OPTS=-a \\\n # RUN: %{lit} -s %{inputs}/lit-opts \\\n-# RUN: | FileCheck -check-prefix=SHOW-ALL -DVAR= %s\n+# RUN: | FileCheck -check-prefix=SHOW-ALL -DVAR=default %s\n \n # Check that LIT_OPTS understands multiple options with arbitrary spacing.\n #\n@@ -28,6 +28,6 @@\n \n # SHOW-ALL:     Testing: 1 tests\n # SHOW-ALL:     PASS: lit-opts :: test.txt (1 of 1)\n-# SHOW-ALL:     {{^}}[[VAR]]\n+# SHOW-ALL:     echo [[VAR]]\n # SHOW-ALL-NOT: PASS\n # SHOW-ALL:     Passed: 1\ndiff --git a/llvm/utils/lit/tests/shtest-define.py b/llvm/utils/lit/tests/shtest-define.py\nindex 1d0997bbbaf8..8c9309804cce 100644\n--- a/llvm/utils/lit/tests/shtest-define.py\n+++ b/llvm/utils/lit/tests/shtest-define.py\n@@ -136,15 +136,15 @@\n # RUN: %{lit} -va %{my-inputs}/shared-substs-*.txt 2>&1 |                      \\\n # RUN:   FileCheck -check-prefix=SHARED-SUBSTS -match-full-lines %s\n #\n-# SHARED-SUBSTS: shared-substs-0.txt\n-# SHARED-SUBSTS: GLOBAL: World\n-# SHARED-SUBSTS: LOCAL0: LOCAL0:Hello LOCAL0:World\n-# SHARED-SUBSTS: LOCAL0: subst\n+# SHARED-SUBSTS:# | shared-substs-0.txt\n+# SHARED-SUBSTS:# | GLOBAL: World\n+# SHARED-SUBSTS:# | LOCAL0: LOCAL0:Hello LOCAL0:World\n+# SHARED-SUBSTS:# | LOCAL0: subst\n #\n-# SHARED-SUBSTS: shared-substs-1.txt\n-# SHARED-SUBSTS: GLOBAL: World\n-# SHARED-SUBSTS: LOCAL1: LOCAL1:Hello LOCAL1:World\n-# SHARED-SUBSTS: LOCAL1: subst\n+# SHARED-SUBSTS:# | shared-substs-1.txt\n+# SHARED-SUBSTS:# | GLOBAL: World\n+# SHARED-SUBSTS:# | LOCAL1: LOCAL1:Hello LOCAL1:World\n+# SHARED-SUBSTS:# | LOCAL1: subst\n #\n # REDEFINE: %{test} = shared-substs-0.txt\n # RUN: %{record-test}\ndiff --git a/llvm/utils/lit/tests/shtest-env.py b/llvm/utils/lit/tests/shtest-env.py\nindex f2e8216f7f4a..a4775ac6688d 100644\n--- a/llvm/utils/lit/tests/shtest-env.py\n+++ b/llvm/utils/lit/tests/shtest-env.py\n@@ -10,88 +10,115 @@\n # CHECK: -- Testing: 16 tests{{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-assign.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"FOO=1\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env FOO=1\n+# CHECK: # executed command: env FOO=1\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-u-arg.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO\n+# CHECK: # executed command: env -u FOO\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-u.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u\n+# CHECK: # executed command: env -u\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-nested-none.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"env\" \"env\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env env env\n+# CHECK: # executed command: env env env\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-none.txt ({{[^)]*}})\n-# CHECK: $ \"env\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env\n+# CHECK: # executed command: env\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-cd.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"cd\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'cd'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 cd foobar\n+# CHECK: # executed command: env -u FOO BAR=3 cd foobar\n+# CHECK: # | Error: 'env' cannot call 'cd'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-colon.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \":\"\n-# CHECK: Error: 'env' cannot call ':'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 :\n+# CHECK: # executed command: env -u FOO BAR=3 :\n+# CHECK: # | Error: 'env' cannot call ':'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-echo.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"echo\" \"hello\" \"world\"\n-# CHECK: Error: 'env' cannot call 'echo'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 echo hello world\n+# CHECK: # executed command: env -u FOO BAR=3 echo hello world\n+# CHECK: # | Error: 'env' cannot call 'echo'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: PASS: shtest-env :: env-calls-env.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"env\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"FOO=2\" \"env\" \"BAR=1\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"env\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=1\" \"env\" \"-u\" \"BAR\" \"FOO=2\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=1\" \"env\" \"-u\" \"BAR\" \"FOO=2\" \"env\" \"BAZ=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env env [[PYTHON:.+]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env env [[PYTHON_BARE:.+]] print_environment.py\n+# CHECK: env FOO=2 env BAR=1 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env FOO=2 env BAR=1 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO env -u BAR [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO env -u BAR [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO BAR=1 env -u BAR FOO=2 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO BAR=1 env -u BAR FOO=2 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO BAR=1 env -u BAR FOO=2 env BAZ=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO BAR=1 env -u BAR FOO=2 env BAZ=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: FAIL: shtest-env :: env-calls-export.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"export\" \"BAZ=3\"\n-# CHECK: Error: 'env' cannot call 'export'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 export BAZ=3\n+# CHECK: # executed command: env -u FOO BAR=3 export BAZ=3\n+# CHECK: # | Error: 'env' cannot call 'export'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-mkdir.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"mkdir\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'mkdir'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 mkdir foobar\n+# CHECK: # executed command: env -u FOO BAR=3 mkdir foobar\n+# CHECK: # | Error: 'env' cannot call 'mkdir'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-not-builtin.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"not\" \"rm\" \"{{.*}}.no-such-file\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 not rm {{.+}}.no-such-file\n+# CHECK: # executed command: env -u FOO BAR=3 not rm {{.+}}.no-such-file\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-rm.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"rm\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 rm foobar\n+# CHECK: # executed command: env -u FOO BAR=3 rm foobar\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: PASS: shtest-env :: env-u.txt ({{[^)]*}})\n-# CHECK: $ \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: env -u FOO [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO -u BAR [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO -u BAR [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: PASS: shtest-env :: env.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"A_FOO=999\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"A_FOO=1\" \"B_BAR=2\" \"C_OOF=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env A_FOO=999 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=999 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env A_FOO=1 B_BAR=2 C_OOF=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=1 B_BAR=2 C_OOF=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: PASS: shtest-env :: mixed.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"A_FOO=999\" \"-u\" \"FOO\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"A_FOO=1\" \"-u\" \"FOO\" \"B_BAR=2\" \"-u\" \"BAR\" \"C_OOF=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env A_FOO=999 -u FOO [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=999 -u FOO [[PYTHON_BARE]] print_environment.py\n+# CHECK: env A_FOO=1 -u FOO B_BAR=2 -u BAR C_OOF=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=1 -u FOO B_BAR=2 -u BAR C_OOF=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: Passed:  4\n # CHECK: Failed: 12\ndiff --git a/llvm/utils/lit/tests/shtest-format.py b/llvm/utils/lit/tests/shtest-format.py\nindex 621776ab7bc2..4a3d65b7bce4 100644\n--- a/llvm/utils/lit/tests/shtest-format.py\n+++ b/llvm/utils/lit/tests/shtest-format.py\n@@ -43,13 +43,21 @@\n # CHECK-EMPTY:\n #  CHECK-NEXT: Command Output (stdout):\n #  CHECK-NEXT: --\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-#  CHECK-NEXT: $ \"printf\"\n-#  CHECK-NEXT: # command output:\n-#  CHECK-NEXT: line 1: failed test output on stdout\n-#  CHECK-NEXT: line 2: failed test output on stdout\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-#  CHECK-NEXT: $ \"false\"\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: printf \"line 1: failed test output on stdout\\nline 2: failed test output on stdout\"\n+#  CHECK-NEXT: executed command: printf 'line 1: failed test output on stdout\\nline 2: failed test output on stdout'\n+#  CHECK-NEXT: # .---command stdout------------\n+#  CHECK-NEXT: # | line 1: failed test output on stdout\n+#  CHECK-NEXT: # | line 2: failed test output on stdout\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # RUN: at line 2\n+#  CHECK-NEXT: false\n+#  CHECK-NEXT: # executed command: false\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: --\n+\n \n # CHECK: UNRESOLVED: shtest-format :: no-test-line.txt\n # CHECK: PASS: shtest-format :: pass.txt\n@@ -73,8 +81,11 @@\n # CHECK-EMPTY:\n #  CHECK-NEXT: Command Output (stdout):\n #  CHECK-NEXT: --\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-#  CHECK-NEXT: $ \"true\"\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: true\n+#  CHECK-NEXT: # executed command: true\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: --\n \n # CHECK: Failed Tests (4)\n # CHECK: shtest-format :: external_shell/fail.txt\ndiff --git a/llvm/utils/lit/tests/shtest-if-else.py b/llvm/utils/lit/tests/shtest-if-else.py\nindex aaf94a6e2437..c18da4abbcca 100644\n--- a/llvm/utils/lit/tests/shtest-if-else.py\n+++ b/llvm/utils/lit/tests/shtest-if-else.py\n@@ -1,5 +1,6 @@\n # RUN: %{lit} -v --show-all %{inputs}/shtest-if-else/test.txt \\\n-# RUN:    | FileCheck %{inputs}/shtest-if-else/test.txt --match-full-lines\n+# RUN:    | FileCheck %{inputs}/shtest-if-else/test.txt --match-full-lines \\\n+# RUN:                --implicit-check-not='RUN:'\n \n # RUN: not %{lit} -v --show-all %{inputs}/shtest-if-else/test-neg1.txt 2>&1 \\\n # RUN:    | FileCheck %{inputs}/shtest-if-else/test-neg1.txt\ndiff --git a/llvm/utils/lit/tests/shtest-inject.py b/llvm/utils/lit/tests/shtest-inject.py\nindex 17e293ea1a12..3d34eb7161d4 100644\n--- a/llvm/utils/lit/tests/shtest-inject.py\n+++ b/llvm/utils/lit/tests/shtest-inject.py\n@@ -1,9 +1,26 @@\n-# Check that we can inject commands at the beginning of a ShTest.\n+# Check that we can inject preamble commands at the beginning of a ShTest.\n+#\n+# For one case, check the execution trace as these preamble commands have\n+# \"preamble command\" instead of the usual \"{{RUN}}: at line N\".\n \n # RUN: %{lit} %{inputs}/shtest-inject/test-empty.txt --show-all | FileCheck --check-prefix=CHECK-TEST1 %s\n #\n-# CHECK-TEST1: THIS WAS\n-# CHECK-TEST1: INJECTED\n+#       CHECK-TEST1: Command Output (stdout):\n+#  CHECK-TEST1-NEXT: --\n+#  CHECK-TEST1-NEXT: # preamble command line\n+#  CHECK-TEST1-NEXT: echo \"THIS WAS\"\n+#  CHECK-TEST1-NEXT: # executed command: echo 'THIS WAS'\n+#  CHECK-TEST1-NEXT: # .---command stdout{{-*}}\n+#  CHECK-TEST1-NEXT: # | THIS WAS\n+#  CHECK-TEST1-NEXT: # `---{{-*}}\n+#  CHECK-TEST1-NEXT: # preamble command line\n+#  CHECK-TEST1-NEXT: echo \"INJECTED\"\n+#  CHECK-TEST1-NEXT: # executed command: echo INJECTED\n+#  CHECK-TEST1-NEXT: # .---command stdout{{-*}}\n+#  CHECK-TEST1-NEXT: # | INJECTED\n+#  CHECK-TEST1-NEXT: # `---{{-*}}\n+# CHECK-TEST1-EMPTY:\n+#  CHECK-TEST1-NEXT: --\n #\n # CHECK-TEST1: Passed: 1\n \ndiff --git a/llvm/utils/lit/tests/shtest-not.py b/llvm/utils/lit/tests/shtest-not.py\nindex d23c9d0cffaf..4590b9664b84 100644\n--- a/llvm/utils/lit/tests/shtest-not.py\n+++ b/llvm/utils/lit/tests/shtest-not.py\n@@ -10,112 +10,158 @@\n # CHECK: -- Testing: 17 tests{{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-args-nested-none.txt {{.*}}\n-# CHECK: $ \"!\" \"!\" \"!\"\n-# CHECK: Error: '!' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: ! ! !\n+# CHECK: # executed command: ! ! !\n+# CHECK: # | Error: '!' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-args-none.txt {{.*}}\n-# CHECK: $ \"!\"\n-# CHECK: Error: '!' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: !\n+# CHECK: # executed command: !\n+# CHECK: # | Error: '!' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-calls-external.txt {{.*}}\n \n-# CHECK: $ \"!\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"!\" \"!\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"!\" \"!\" \"!\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"!\" \"!\" \"!\" \"!\" \"{{[^\"]*}}\" \"pass.py\"\n+# CHECK: ! [[PYTHON:.*]] fail.py\n+# CHECK: # executed command: ! [[PYTHON_BARE:.*]] fail.py\n+# CHECK: ! ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! ! [[PYTHON_BARE]] pass.py\n+# CHECK: ! ! ! [[PYTHON]] fail.py\n+# CHECK: # executed command: ! ! ! [[PYTHON_BARE]] fail.py\n+# CHECK: ! ! ! ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! ! ! ! [[PYTHON_BARE]] pass.py\n \n-# CHECK: $ \"!\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! [[PYTHON_BARE]] pass.py\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-last-is-crash.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not --crash\n+# CHECK: # executed command: not --crash\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-nested-none.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not not\n+# CHECK: # executed command: not not not\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-none.txt {{.*}}\n-# CHECK: $ \"not\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not\n+# CHECK: # executed command: not\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-cd.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"cd\" \"foobar\"\n-# CHECK: $ \"not\" \"--crash\" \"cd\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'cd'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not cd foobar\n+# CHECK: # executed command: not not cd foobar\n+# CHECK: not --crash cd foobar\n+# CHECK: # executed command: not --crash cd foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'cd'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-colon.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \":\" \"foobar\"\n-# CHECK: $ \"not\" \"--crash\" \":\"\n-# CHECK: Error: 'not --crash' cannot call ':'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not : foobar\n+# CHECK: # executed command: not not : foobar\n+# CHECK: not --crash :\n+# CHECK: # executed command: not --crash :\n+# CHECK: # | Error: 'not --crash' cannot call ':'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-diff-with-crash.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"diff\" \"-u\" {{.*}}\n-# CHECK-NOT: \"$\"\n+# CHECK: not --crash diff -u {{.*}}\n+# CHECK: # executed command: not --crash diff -u {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n # CHECK-NOT: {{[Ee]rror}}\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: # error: command failed with exit status: {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n # CHECK-NOT: {{[Ee]rror}}\n-# CHECK-NOT: \"$\"\n \n # CHECK: FAIL: shtest-not :: not-calls-diff.txt {{.*}}\n-# CHECK: $ \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"diff\" {{.*}}\n-# CHECK-NOT: \"$\"\n+# CHECK: not diff {{.*}}\n+# CHECK: # executed command: not diff {{.*}}\n+# CHECK: not not not diff {{.*}}\n+# CHECK: # executed command: not not not diff {{.*}}\n+# CHECK: not not not not not diff {{.*}}\n+# CHECK: # executed command: not not not not not diff {{.*}}\n+# CHECK: diff {{.*}}\n+# CHECK: # executed command: diff {{.*}}\n+# CHECK: not not diff {{.*}}\n+# CHECK: # executed command: not not diff {{.*}}\n+# CHECK: not not not not diff {{.*}}\n+# CHECK: # executed command: not not not not diff {{.*}}\n+# CHECK: not diff {{.*}}\n+# CHECK: # executed command: not diff {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-echo.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"echo\" \"hello\" \"world\"\n-# CHECK: $ \"not\" \"--crash\" \"echo\" \"hello\" \"world\"\n-# CHECK: Error: 'not --crash' cannot call 'echo'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not echo hello world\n+# CHECK: # executed command: not not echo hello world\n+# CHECK: not --crash echo hello world\n+# CHECK: # executed command: not --crash echo hello world\n+# CHECK: # | Error: 'not --crash' cannot call 'echo'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-env-builtin.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"env\" \"-u\" \"FOO\" \"BAR=3\" \"rm\" \"{{.*}}.no-such-file\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not --crash env -u FOO BAR=3 rm {{.*}}.no-such-file\n+# CHECK: # executed command: not --crash env -u FOO BAR=3 rm {{.*}}.no-such-file\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-export.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"export\" \"FOO=1\"\n-# CHECK: $ \"not\" \"--crash\" \"export\" \"BAZ=3\"\n-# CHECK: Error: 'not --crash' cannot call 'export'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not export FOO=1\n+# CHECK: # executed command: not not export FOO=1\n+# CHECK: not --crash export BAZ=3\n+# CHECK: # executed command: not --crash export BAZ=3\n+# CHECK: # | Error: 'not --crash' cannot call 'export'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n \n # CHECK: PASS: shtest-not :: not-calls-external.txt {{.*}}\n \n-# CHECK: $ \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-\n-# CHECK: $ \"env\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"env\" \"-u\" \"FOO\" \"BAR=2\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"env\" \"-u\" \"FOO\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"env\" \"FOO=1\" \"env\" \"FOO=2\" \"BAR=1\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"-u\" \"BAR\" \"env\" \"-u\" \"FOO\" \"BAR=1\" \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"env\" \"FOO=2\" \"BAR=2\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"env\" \"-u\" \"BAR\" \"not\" \"env\" \"-u\" \"FOO\" \"BAR=1\" \"{{[^\"]*}}\" \"pass.py\"\n+# CHECK: not [[PYTHON]] fail.py\n+# CHECK: # executed command: not [[PYTHON_BARE]] fail.py\n+# CHECK: not not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not [[PYTHON_BARE]] pass.py\n+# CHECK: not not not [[PYTHON]] fail.py\n+# CHECK: # executed command: not not not [[PYTHON_BARE]] fail.py\n+# CHECK: not not not not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not not not [[PYTHON_BARE]] pass.py\n+\n+# CHECK: not not --crash [[PYTHON]] pass.py\n+# CHECK: # executed command: not not --crash [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash [[PYTHON]] fail.py\n+# CHECK: # executed command: not not --crash [[PYTHON_BARE]] fail.py\n+# CHECK: not not --crash not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not --crash not [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash not [[PYTHON]] fail.py\n+# CHECK: # executed command: not not --crash not [[PYTHON_BARE]] fail.py\n+\n+# CHECK: env not [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env not [[PYTHON_BARE]] fail.py\n+# CHECK: not env [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: not env [[PYTHON_BARE]] fail.py\n+# CHECK: env FOO=1 not [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 not [[PYTHON_BARE]] fail.py\n+# CHECK: not env FOO=1 BAR=1 [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 [[PYTHON_BARE]] fail.py\n+# CHECK: env FOO=1 BAR=1 not env -u FOO BAR=2 [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 BAR=1 not env -u FOO BAR=2 [[PYTHON_BARE]] fail.py\n+# CHECK: not env FOO=1 BAR=1 not env -u FOO -u BAR [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 not env -u FOO -u BAR [[PYTHON_BARE]] pass.py\n+# CHECK: not not env FOO=1 env FOO=2 BAR=1 [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not not env FOO=1 env FOO=2 BAR=1 [[PYTHON_BARE]] pass.py\n+# CHECK: env FOO=1 -u BAR env -u FOO BAR=1 not not [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 -u BAR env -u FOO BAR=1 not not [[PYTHON_BARE]] pass.py\n+\n+# CHECK: not env FOO=1 BAR=1 env FOO=2 BAR=2 not --crash [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 env FOO=2 BAR=2 not --crash [[PYTHON_BARE]] pass.py\n+# CHECK: not env FOO=1 BAR=1 not --crash not [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 not --crash not [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash env -u BAR not env -u FOO BAR=1 [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not not --crash env -u BAR not env -u FOO BAR=1 [[PYTHON_BARE]] pass.py\n \n \n # CHECK: FAIL: shtest-not :: not-calls-fail2.txt {{.*}}\n@@ -123,16 +169,20 @@\n # CHECK-NEXT: Exit Code: 1\n \n # CHECK: FAIL: shtest-not :: not-calls-mkdir.txt {{.*}}\n-# CHECK: $ \"not\" \"mkdir\" {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"mkdir\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'mkdir'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not mkdir {{.*}}\n+# CHECK: # executed command: not mkdir {{.*}}\n+# CHECK: not --crash mkdir foobar\n+# CHECK: # executed command: not --crash mkdir foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'mkdir'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-rm.txt {{.*}}\n-# CHECK: $ \"not\" \"rm\" {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"rm\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not rm {{.*}}\n+# CHECK: # executed command: not rm {{.*}}\n+# CHECK: not --crash rm foobar\n+# CHECK: # executed command: not --crash rm foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: Passed:  1\n # CHECK: Failed: 16\ndiff --git a/llvm/utils/lit/tests/shtest-output-printing.py b/llvm/utils/lit/tests/shtest-output-printing.py\nindex 7cd975ba8d3c..3e49197520a9 100644\n--- a/llvm/utils/lit/tests/shtest-output-printing.py\n+++ b/llvm/utils/lit/tests/shtest-output-printing.py\n@@ -1,28 +1,45 @@\n # Check the various features of the ShTest format.\n #\n # RUN: not %{lit} -v %{inputs}/shtest-output-printing > %t.out\n-# RUN: FileCheck --input-file %t.out %s\n+# RUN: FileCheck --input-file %t.out --match-full-lines %s\n #\n # END.\n \n-# CHECK: -- Testing:\n-\n-# CHECK: FAIL: shtest-output-printing :: basic.txt\n-# CHECK-NEXT: *** TEST 'shtest-output-printing :: basic.txt' FAILED ***\n-# CHECK-NEXT: Exit Code: 1\n-#\n-# CHECK:      Command Output\n-# CHECK-NEXT: --\n-# CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \"true\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-# CHECK-NEXT: $ \"echo\" \"hi\"\n-# CHECK-NEXT: # command output:\n-# CHECK-NEXT: hi\n-#\n-# CHECK:      $ \":\" \"RUN: at line 3\"\n-# CHECK-NEXT: $ \"not\" \"not\" \"wc\" \"missing-file\"\n-# CHECK-NEXT: # redirected output from '{{.*(/|\\\\\\\\)}}basic.txt.tmp.out':\n-# CHECK-NEXT: {{cannot open missing-file|missing-file.* No such file or directory}}\n-# CHECK:      note: command had no output on stdout or stderr\n-# CHECK-NEXT: error: command failed with exit status: 1\n+#       CHECK: -- Testing: {{.*}}\n+#       CHECK: FAIL: shtest-output-printing :: basic.txt {{.*}}\n+#  CHECK-NEXT: ***{{\\**}} TEST 'shtest-output-printing :: basic.txt' FAILED ***{{\\**}}\n+#  CHECK-NEXT: Exit Code: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: Command Output (stdout):\n+#  CHECK-NEXT: --\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: true\n+#  CHECK-NEXT: # executed command: true\n+#  CHECK-NEXT: # RUN: at line 2\n+#  CHECK-NEXT: echo hi\n+#  CHECK-NEXT: # executed command: echo hi\n+#  CHECK-NEXT: # .---command stdout------------\n+#  CHECK-NEXT: # | hi\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # RUN: at line 3\n+#  CHECK-NEXT: not not wc missing-file &> [[FILE:.*]] || true\n+#  CHECK-NEXT: # executed command: not not wc missing-file\n+#  CHECK-NEXT: # .---redirected output from '[[FILE]]'\n+#  CHECK-NEXT: # | wc: {{cannot open missing-file|missing-file.* No such file or directory}}\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+#  CHECK-NEXT: # executed command: true\n+#  CHECK-NEXT: # RUN: at line 4\n+#  CHECK-NEXT: not {{.*}}/python{{.*}} {{.*}}/write-a-lot.py &> [[FILE:.*]]\n+#  CHECK-NEXT: # executed command: not {{.*}}/python{{.*}} {{.*}}/write-a-lot.py\n+#  CHECK-NEXT: # .---redirected output from '[[FILE]]'\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#       CHECK: # | ...\n+#  CHECK-NEXT: # `---data was truncated--------\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT:--\ndiff --git a/llvm/utils/lit/tests/shtest-pushd-popd.py b/llvm/utils/lit/tests/shtest-pushd-popd.py\nindex 26296a7ffcf5..6d7e93c74a05 100644\n--- a/llvm/utils/lit/tests/shtest-pushd-popd.py\n+++ b/llvm/utils/lit/tests/shtest-pushd-popd.py\n@@ -8,16 +8,16 @@\n # CHECK: -- Testing: 4 tests{{.*}}\n \n # CHECK: FAIL: shtest-pushd-popd :: popd-args.txt ({{[^)]*}})\n-# CHECK: $ \"popd\" \"invalid\"\n-# CHECK: 'popd' does not support arguments\n+# CHECK: popd invalid\n+# CHECK: # | 'popd' does not support arguments\n \n # CHECK: FAIL: shtest-pushd-popd :: popd-no-stack.txt ({{[^)]*}})\n-# CHECK: $ \"popd\"\n-# CHECK: popd: directory stack empty\n+# CHECK: popd\n+# CHECK: # | popd: directory stack empty\n \n # CHECK: FAIL: shtest-pushd-popd :: pushd-too-many-args.txt ({{[^)]*}})\n-# CHECK: $ \"pushd\" \"a\" \"b\"\n-# CHECK: 'pushd' supports only one argument\n+# CHECK: pushd a b\n+# CHECK: # | 'pushd' supports only one argument\n \n # CHECK: Passed:  1\n # CHECK: Failed:  3\ndiff --git a/llvm/utils/lit/tests/shtest-recursive-substitution.py b/llvm/utils/lit/tests/shtest-recursive-substitution.py\nindex 48f4b5b12491..65c177e65a3c 100644\n--- a/llvm/utils/lit/tests/shtest-recursive-substitution.py\n+++ b/llvm/utils/lit/tests/shtest-recursive-substitution.py\n@@ -3,7 +3,7 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/substitutes-within-limit --show-all | FileCheck --check-prefix=CHECK-TEST1 %s\n # CHECK-TEST1: PASS: substitutes-within-limit :: test.py\n-# CHECK-TEST1: $ \"echo\" \"STOP\"\n+# CHECK-TEST1: echo STOP\n \n # RUN: not %{lit} %{inputs}/shtest-recursive-substitution/does-not-substitute-within-limit --show-all | FileCheck --check-prefix=CHECK-TEST2 %s\n # CHECK-TEST2: UNRESOLVED: does-not-substitute-within-limit :: test.py\n@@ -11,7 +11,7 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/does-not-substitute-no-limit --show-all | FileCheck --check-prefix=CHECK-TEST3 %s\n # CHECK-TEST3: PASS: does-not-substitute-no-limit :: test.py\n-# CHECK-TEST3: $ \"echo\" \"%rec4\"\n+# CHECK-TEST3: echo %rec4\n \n # RUN: not %{lit} %{inputs}/shtest-recursive-substitution/not-an-integer --show-all 2>&1 | FileCheck --check-prefix=CHECK-TEST4 %s\n # CHECK-TEST4: recursiveExpansionLimit must be either None or an integer\n@@ -24,4 +24,4 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/escaping --show-all | FileCheck --check-prefix=CHECK-TEST7 %s\n # CHECK-TEST7: PASS: escaping :: test.py\n-# CHECK-TEST7: $ \"echo\" \"%s\" \"%s\" \"%%s\"\n+# CHECK-TEST7: echo %s %s %%s\ndiff --git a/llvm/utils/lit/tests/shtest-run-at-line.py b/llvm/utils/lit/tests/shtest-run-at-line.py\nindex 879cd64ebf6e..a0626f872c4c 100644\n--- a/llvm/utils/lit/tests/shtest-run-at-line.py\n+++ b/llvm/utils/lit/tests/shtest-run-at-line.py\n@@ -28,21 +28,28 @@\n # CHECK-LABEL: FAIL: shtest-run-at-line :: internal-shell/basic.txt\n \n # CHECK:      Command Output (stdout)\n-# CHECK:      $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \"true\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-# CHECK-NEXT: $ \"false\"\n+# CHECK-NEXT: --\n+# CHECK-NEXT: # RUN: at line 1\n+# CHECK-NEXT: true\n+# CHECK-NEXT: # executed command: true\n+# CHECK-NEXT: # RUN: at line 2\n+# CHECK-NEXT: false\n+# CHECK-NEXT: # executed command: false\n # CHECK-NOT:  RUN\n \n # CHECK-LABEL: FAIL: shtest-run-at-line :: internal-shell/line-continuation.txt\n \n # CHECK:      Command Output (stdout)\n-# CHECK:      $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \":\" \"first\" \"line\" \"continued\" \"to\" \"second\" \"line\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 3\"\n-# CHECK-NEXT: $ \"echo\" \"foo bar\"\n-# CHECK-NEXT: $ \"FileCheck\" \"{{.*}}\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 5\"\n-# CHECK-NEXT: $ \"echo\" \"foo baz\"\n-# CHECK-NEXT: $ \"FileCheck\" \"{{.*}}\"\n+# CHECK-NEXT: --\n+# CHECK-NEXT: # RUN: at line 1\n+# CHECK-NEXT: : first line continued to second line\n+# CHECK-NEXT: # executed command: : first line continued to second line\n+# CHECK-NEXT: # RUN: at line 3\n+# CHECK-NEXT: echo 'foo bar' | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: echo 'foo bar'\n+# CHECK-NEXT: # executed command: FileCheck {{.*}}\n+# CHECK-NEXT: # RUN: at line 5\n+# CHECK-NEXT: echo 'foo baz' | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: echo 'foo baz'\n+# CHECK-NEXT: # executed command: FileCheck {{.*}}\n # CHECK-NOT:  RUN\ndiff --git a/llvm/utils/lit/tests/shtest-shell.py b/llvm/utils/lit/tests/shtest-shell.py\nindex 93f05dbd35d0..8ce71296c144 100644\n--- a/llvm/utils/lit/tests/shtest-shell.py\n+++ b/llvm/utils/lit/tests/shtest-shell.py\n@@ -20,202 +20,212 @@\n \n # CHECK: FAIL: shtest-shell :: cat-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: cat-error-0.txt' FAILED ***\n-# CHECK: $ \"cat\" \"-b\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'cat':  option -b not recognized\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: cat -b temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'cat':  option -b not recognized\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: cat-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: cat-error-1.txt' FAILED ***\n-# CHECK: $ \"cat\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: [Errno 2] No such file or directory: 'temp1.txt'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: cat temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | [Errno 2] No such file or directory: 'temp1.txt'\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: colon-error.txt\n # CHECK: *** TEST 'shtest-shell :: colon-error.txt' FAILED ***\n-# CHECK: $ \":\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: ':' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: :\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: ':' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: PASS: shtest-shell :: continuations.txt\n \n # CHECK: PASS: shtest-shell :: dev-null.txt\n \n-# CHECK: FAIL: shtest-shell :: diff-b.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-b.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-b\" \"{{[^\"]*}}.0\" \"{{[^\"]*}}.1\"\n-# CHECK: # command output:\n-# CHECK: 1,2\n-# CHECK-NEXT: {{^  }}f o o\n-# CHECK-NEXT: ! b a r\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: {{^  }}f o o\n-# CHECK-NEXT: ! bar\n-# CHECK-EMPTY:\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-b.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-b.txt' FAILED ***\n+#      CHECK: diff -b {{[^\"]*}}.0 {{[^\"]*}}.1\n+#      CHECK: # .---command stdout{{-*}}\n+#      CHECK: # | {{.*}}1,2\n+# CHECK-NEXT: # |   f o o\n+# CHECK-NEXT: # | ! b a r\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # |   f o o\n+# CHECK-NEXT: # | ! bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+#      CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-encodings.txt\n # CHECK: *** TEST 'shtest-shell :: diff-encodings.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"diff-in.bin\"\n+#      CHECK: diff -u diff-in.bin diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.bin diff-in.bin\n+#  CHECK-NOT: error\n+\n+#      CHECK: diff -u diff-in.utf16 diff-in.bin && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf16 diff-in.bin\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.utf8 diff-in.bin && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf8 diff-in.bin\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | -baz\n+# CHECK-NEXT: # | {{\\+.f.o.o.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{\\+.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.bin diff-in.utf8 && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.bin diff-in.utf8\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{-.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.}}\n+# CHECK-NEXT: # | {{-.b.a.z.$}}\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # | +baz\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#     CHECK: cat diff-in.bin | diff -u - diff-in.bin\n # CHECK-NOT: error\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf16\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^ .f.o.o.$}}\n-# CHECK-NEXT: {{^-.b.a.r.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^ .b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf8\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: -baz\n-# CHECK-NEXT: {{^\\+.f.o.o.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^\\+.b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"diff-in.utf8\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^\\-.f.o.o.$}}\n-# CHECK-NEXT: {{^\\-.b.a.r.}}\n-# CHECK-NEXT: {{^\\-.b.a.z.$}}\n-# CHECK-NEXT: +foo\n-# CHECK-NEXT: +bar\n-# CHECK-NEXT: +baz\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"-\"\n-# CHECK-NOT: error\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf16\" \"-\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^ .f.o.o.$}}\n-# CHECK-NEXT: {{^-.b.a.r.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^ .b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n+#     CHECK: cat diff-in.bin | diff -u diff-in.bin -\n # CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf8\" \"-\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: -baz\n-# CHECK-NEXT: {{^\\+.f.o.o.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^\\+.b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"diff-in.utf8\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^\\-.f.o.o.$}}\n-# CHECK-NEXT: {{^\\-.b.a.r.}}\n-# CHECK-NEXT: {{^\\-.b.a.z.$}}\n-# CHECK-NEXT: +foo\n-# CHECK-NEXT: +bar\n-# CHECK-NEXT: +baz\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n \n-# CHECK: $ \"false\"\n+#      CHECK: cat diff-in.bin | diff -u diff-in.utf16 - && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf16 -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat diff-in.bin | diff -u diff-in.utf8 - && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf8 -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | -baz\n+# CHECK-NEXT: # | {{\\+.f.o.o.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{\\+.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat diff-in.bin | diff -u - diff-in.utf8 && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u - diff-in.utf8\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{-.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.}}\n+# CHECK-NEXT: # | {{-.b.a.z.$}}\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # | +baz\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-1.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-B\" \"temp1.txt\" \"temp2.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'diff': option -B not recognized\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -B temp1.txt temp2.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'diff': option -B not recognized\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-2.txt' FAILED ***\n-# CHECK: $ \"diff\" \"temp.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff temp.txt \n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-3.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-3.txt' FAILED ***\n-# CHECK: $ \"diff\" \"temp.txt\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'diff' command failed\n+# CHECK: diff temp.txt temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'diff' command failed\n # CHECK: error: command failed with exit status: 1\n # CHECK: ***\n \n-# CHECK: FAIL: shtest-shell :: diff-error-4.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-error-4.txt' FAILED ***\n-# CHECK: Exit Code: 1\n-# CHECK: # command output:\n-# CHECK: diff-error-4.txt.tmp\n-# CHECK: diff-error-4.txt.tmp1\n-# CHECK: *** 1 ****\n-# CHECK: ! hello-first\n-# CHECK: --- 1 ----\n-# CHECK: ! hello-second\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-error-4.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-error-4.txt' FAILED ***\n+#      CHECK: Exit Code: 1\n+#      CHECK: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | {{.*}}diff-error-4.txt.tmp\n+# CHECK-NEXT: # | {{.*}}diff-error-4.txt.tmp1\n+# CHECK-NEXT: # | {{\\*+}}\n+# CHECK-NEXT: # | *** 1 ****\n+# CHECK-NEXT: # | ! hello-first\n+# CHECK-NEXT: # | --- 1 ----\n+# CHECK-NEXT: # | ! hello-second\n+# CHECK-NEXT: # `---{{-*}}\n+#      CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-5.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-5.txt' FAILED ***\n-# CHECK: $ \"diff\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-6.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-6.txt' FAILED ***\n-# CHECK: $ \"diff\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n \n@@ -223,137 +233,130 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-pipes.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.foo\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"FileCheck\"\n+# CHECK: diff {{[^ ]*}}.foo {{.*}}.foo | FileCheck {{.*}}\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: note: command had no output on stdout or stderr\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"FileCheck\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"true\"\n+#      CHECK: diff -u {{.*}}.foo {{.*}}.bar | FileCheck {{.*}} && false || true\n+# CHECK-NEXT: # executed command: diff -u {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # note: command had no output on stdout or stderr\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: FileCheck\n+# CHECK-NEXT: # executed command: true\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"{{[^\"]*}}.foo\"\n+#     CHECK: cat {{.*}}.foo | diff -u - {{.*}}.foo\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n+#     CHECK: cat {{.*}}.foo | diff -u {{.*}}.foo -\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: +bar\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"{{[^\"]*}}.foo\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: +foo\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-\" \"{{[^\"]*}}.foo\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"FileCheck\"\n+#      CHECK: cat {{.*}}.bar | diff -u {{.*}}.foo - && false || true\n+# CHECK-NEXT: # executed command: cat {{.*}}.bar\n+# CHECK-NEXT: # executed command: diff -u {{.*}}.foo -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat {{.*}}.bar | diff -u - {{.*}}.foo && false || true\n+# CHECK-NEXT: # executed command: cat {{.*}}.bar\n+# CHECK-NEXT: # executed command: diff -u - {{.*}}.foo\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#     CHECK: cat {{.*}}.foo | diff - {{.*}}.foo | FileCheck {{.*}}\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n-# CHECK: note: command had no output on stdout or stderr\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"FileCheck\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"true\"\n+#      CHECK: cat {{.*}}.bar | diff -u {{.*}}.foo - | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: cat {{.*}}.bar\n+# CHECK-NEXT: # executed command: diff -u {{.*}}.foo -\n+# CHECK-NEXT: note: command had no output on stdout or stderr\n+# CHECK-NEXT: error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: FileCheck\n+# CHECK-NEXT: # executed command: true\n \n-# CHECK: $ \"false\"\n+# CHECK: false\n \n # CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-r-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-0.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: dir1unique\n-# CHECK: Only in {{.*}}dir2: dir2unique\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: dir1unique\n+# CHECK: # | Only in {{.*}}dir2: dir2unique\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-1.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: *** {{.*}}dir1{{.*}}subdir{{.*}}f01\n-# CHECK: --- {{.*}}dir2{{.*}}subdir{{.*}}f01\n-# CHECK: 12345\n-# CHECK: 00000\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | *** {{.*}}dir1{{.*}}subdir{{.*}}f01\n+# CHECK: # | --- {{.*}}dir2{{.*}}subdir{{.*}}f01\n+# CHECK: # | ! 12345\n+# CHECK: # | ! 00000\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-2.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir2: extrafile\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir2: extrafile\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-3.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-3.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: extra_subdir\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: extra_subdir\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-4.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-4.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: File {{.*}}dir1{{.*}}extra_subdir is a directory while file {{.*}}dir2{{.*}}extra_subdir is a regular file\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | File {{.*}}dir1{{.*}}extra_subdir is a directory while file {{.*}}dir2{{.*}}extra_subdir is a regular file\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-5.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-5.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: extra_subdir\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: extra_subdir\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-6.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-6.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: File {{.*}}dir1{{.*}}extra_file is a regular empty file while file {{.*}}dir2{{.*}}extra_file is a directory\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | File {{.*}}dir1{{.*}}extra_file is a regular empty file while file {{.*}}dir2{{.*}}extra_file is a directory\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-7.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-7.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\" \"-\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: cannot recursively compare '-'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r - {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: cannot recursively compare '-'\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-8.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-8.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\" \"{{[^\"]*}}\" \"-\"\n-# CHECK: # command stderr:\n-# CHECK: Error: cannot recursively compare '-'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r {{.*}} -\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: cannot recursively compare '-'\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: PASS: shtest-shell :: diff-r.txt\n \n@@ -362,51 +365,59 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-strip-trailing-cr.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.dos\" \"diff-in.unix\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -In this file, the\n-# CHECK-NEXT: -sequence \"\\r\\n\"\n-# CHECK-NEXT: -terminates lines.\n-# CHECK-NEXT: +In this file, the\n-# CHECK-NEXT: +sequence \"\\n\"\n-# CHECK-NEXT: +terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.unix\" \"diff-in.dos\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -In this file, the\n-# CHECK-NEXT: -sequence \"\\n\"\n-# CHECK-NEXT: -terminates lines.\n-# CHECK-NEXT: +In this file, the\n-# CHECK-NEXT: +sequence \"\\r\\n\"\n-# CHECK-NEXT: +terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"--strip-trailing-cr\" \"diff-in.dos\" \"diff-in.unix\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT:  In this file, the\n-# CHECK-NEXT: -sequence \"\\r\\n\"\n-# CHECK-NEXT: +sequence \"\\n\"\n-# CHECK-NEXT:  terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"--strip-trailing-cr\" \"diff-in.unix\" \"diff-in.dos\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT:  In this file, the\n-# CHECK-NEXT: -sequence \"\\n\"\n-# CHECK-NEXT: +sequence \"\\r\\n\"\n-# CHECK-NEXT:  terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"false\"\n+#      CHECK: diff -u diff-in.dos diff-in.unix && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.dos diff-in.unix\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -In this file, the\n+# CHECK-NEXT: # | -sequence \"\\r\\n\"\n+# CHECK-NEXT: # | -terminates lines.\n+# CHECK-NEXT: # | +In this file, the\n+# CHECK-NEXT: # | +sequence \"\\n\"\n+# CHECK-NEXT: # | +terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.unix diff-in.dos && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.unix diff-in.dos\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -In this file, the\n+# CHECK-NEXT: # | -sequence \"\\n\"\n+# CHECK-NEXT: # | -terminates lines.\n+# CHECK-NEXT: # | +In this file, the\n+# CHECK-NEXT: # | +sequence \"\\r\\n\"\n+# CHECK-NEXT: # | +terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u --strip-trailing-cr diff-in.dos diff-in.unix && false || true\n+# CHECK-NEXT: executed command: diff -u --strip-trailing-cr diff-in.dos diff-in.unix\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # |  In this file, the\n+# CHECK-NEXT: # | -sequence \"\\r\\n\"\n+# CHECK-NEXT: # | +sequence \"\\n\"\n+# CHECK-NEXT: # |  terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u --strip-trailing-cr diff-in.unix diff-in.dos && false || true\n+# CHECK-NEXT: # executed command: diff -u --strip-trailing-cr diff-in.unix diff-in.dos\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # |  In this file, the\n+# CHECK-NEXT: # | -sequence \"\\n\"\n+# CHECK-NEXT: # | +sequence \"\\r\\n\"\n+# CHECK-NEXT: # |  terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n@@ -415,106 +426,144 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-unified.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 3\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-NEXT: 9\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U\" \"2\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U4\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 2\n-# CHECK-NEXT: 3\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-NEXT: 9\n-# CHECK-NEXT: 10\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U0\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U\" \"30.1\" \"{{[^\"]*}}\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: invalid '-U' argument: 30.1\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U-1\" \"{{[^\"]*}}\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: invalid '-U' argument: -1\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"false\"\n+#      CHECK: diff -u {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -u {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 3\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # | 9\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U 2 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U 2 {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U4 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U4 {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 2\n+# CHECK-NEXT: # | 3\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # | 9\n+# CHECK-NEXT: # | 10\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U0 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: diff -U0 {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: diff -U 30.1 {{.*}} {{.*}} && false || true\n+# CHECK: # executed command: diff -U 30.1 {{.*}} {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: invalid '-U' argument: 30.1\n+# CHECK: # error: command failed with exit status: 1\n+# CHECK: # executed command: true\n+\n+# CHECK: diff -U-1 {{.*}} {{.*}} && false || true\n+# CHECK: # executed command: diff -U-1 {{.*}} {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: invalid '-U' argument: -1\n+# CHECK: # error: command failed with exit status: 1\n+# CHECK: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n \n-# CHECK: FAIL: shtest-shell :: diff-w.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-w.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-w\" \"{{[^\"]*}}.0\" \"{{[^\"]*}}.1\"\n-# CHECK: # command output:\n-# CHECK: 1,3\n-# CHECK-NEXT: {{^  }}foo\n-# CHECK-NEXT: {{^  }}bar\n-# CHECK-NEXT: ! baz\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: {{^  }}foo\n-# CHECK-NEXT: {{^  }}bar\n-# CHECK-NEXT: ! bat\n-# CHECK-EMPTY:\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-w.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-w.txt' FAILED ***\n+#      CHECK: diff -w {{.*}}.0 {{.*}}.1\n+#      CHECK: # .---command stdout{{-*}}\n+#      CHECK: # | {{\\*+}} 1,3\n+# CHECK-NEXT: # |   foo\n+# CHECK-NEXT: # |   bar\n+# CHECK-NEXT: # | ! baz\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # |   foo\n+# CHECK-NEXT: # |   bar\n+# CHECK-NEXT: # | ! bat\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+#      CHECK: ***\n+\n+# CHECK: FAIL: shtest-shell :: echo-at-redirect-stderr.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-at-redirect-stderr.txt' FAILED ***\n+# CHECK: @echo 2> {{.*}}\n+# CHECK: # executed command: @echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for @echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-at-redirect-stdin.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-at-redirect-stdin.txt' FAILED ***\n+# CHECK: @echo < {{.*}}\n+# CHECK: # executed command: @echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for @echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-redirect-stderr.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-redirect-stderr.txt' FAILED ***\n+# CHECK: echo 2> {{.*}}\n+# CHECK: # executed command: echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-redirect-stdin.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-redirect-stdin.txt' FAILED ***\n+# CHECK: echo < {{.*}}\n+# CHECK: # executed command: echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for echo\n+# CHECK: error: command failed with exit status:\n \n # CHECK: FAIL: shtest-shell :: error-0.txt\n # CHECK: *** TEST 'shtest-shell :: error-0.txt' FAILED ***\n-# CHECK: $ \"not-a-real-command\"\n-# CHECK: # command stderr:\n-# CHECK: 'not-a-real-command': command not found\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: not-a-real-command\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | 'not-a-real-command': command not found\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # FIXME: The output here sucks.\n #\n # CHECK: FAIL: shtest-shell :: error-1.txt\n # CHECK: *** TEST 'shtest-shell :: error-1.txt' FAILED ***\n-# CHECK: shell parser error on: ': \\'RUN: at line 3\\'; echo \"missing quote'\n+# CHECK: shell parser error on RUN: at line 3: echo \"missing quote\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: error-2.txt\n@@ -524,52 +573,52 @@\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-0.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'mkdir' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p temp | rm -rf temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'mkdir' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-1.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\" \"-m\" \"777\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'mkdir': option -m not recognized\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p -m 777 temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'mkdir': option -m not recognized\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-2.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'mkdir' is missing an operand\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'mkdir' is missing an operand\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: PASS: shtest-shell :: redirects.txt\n \n # CHECK: FAIL: shtest-shell :: rm-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-0.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-rf\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'rm' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: rm -rf temp | echo \"hello\"\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'rm' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-1.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-f\" \"-v\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'rm': option -v not recognized\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: rm -f -v temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'rm': option -v not recognized\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-2.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-r\" \"hello\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'rm' command failed\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: rm -r hello\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'rm' command failed\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-3.txt\n@@ -581,16 +630,17 @@\n # CHECK: PASS: shtest-shell :: sequencing-0.txt\n # CHECK: XFAIL: shtest-shell :: sequencing-1.txt\n \n-# CHECK: FAIL: shtest-shell :: stdout-encoding.txt\n-# CHECK: *** TEST 'shtest-shell :: stdout-encoding.txt' FAILED ***\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: {{^.f.o.o.$}}\n-# CHECK-NEXT: {{^.b.a.r.}}\n-# CHECK-NEXT: {{^.b.a.z.$}}\n-# CHECK-NOT: error\n-# CHECK: $ \"false\"\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: stdout-encoding.txt\n+#      CHECK: *** TEST 'shtest-shell :: stdout-encoding.txt' FAILED ***\n+#      CHECK: cat diff-in.bin\n+#      CHECK: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+#  CHECK-NOT: error\n+#      CHECK: false\n+#      CHECK: ***\n \n # CHECK: PASS: shtest-shell :: valid-shell.txt\n-# CHECK: Failed Tests (35)\n+# CHECK: Failed Tests (39)\n", "message": "", "files": {"/libcxx/utils/libcxx/test/dsl.py": {"changes": [{"diff": "\n                 \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n             )\n \n-        return libcxx.test.format._parseLitOutput(out)\n+        return out\n \n \n @_memoizeExpensiveOperation(", "add": 1, "remove": 1, "filename": "/libcxx/utils/libcxx/test/dsl.py", "badparts": ["        return libcxx.test.format._parseLitOutput(out)"], "goodparts": ["        return out"]}], "source": "\n import os import pickle import pipes import platform import re import shutil import subprocess import tempfile import libcxx.test.format import lit import lit.LitConfig import lit.Test import lit.TestRunner import lit.util class ConfigurationError(Exception): pass class ConfigurationCompilationError(ConfigurationError): pass class ConfigurationRuntimeError(ConfigurationError): pass def _memoizeExpensiveOperation(extractCacheKey): \"\"\" Allows memoizing a very expensive operation. We pickle the cache key to make sure we store an immutable representation of it. If we stored an object and the object was referenced elsewhere, it could be changed from under our feet, which would break the cache. We also store the cache for a given function persistently across invocations of Lit. This dramatically speeds up the configuration of the test suite when invoking Lit repeatedly, which is important for developer workflow. However, with the current implementation that does not synchronize updates to the persistent cache, this also means that one should not call a memoized operation from multiple threads. This should normally not be a problem since Lit configuration is single-threaded. \"\"\" def decorator(function): def f(config, *args, **kwargs): cacheRoot=os.path.join(config.test_exec_root, \"__config_cache__\") persistentCache=os.path.join(cacheRoot, function.__name__) if not os.path.exists(cacheRoot): os.makedirs(cacheRoot) cache={} if os.path.exists(persistentCache): with open(persistentCache, \"rb\") as cacheFile: cache=pickle.load(cacheFile) cacheKey=pickle.dumps(extractCacheKey(config, *args, **kwargs)) if cacheKey not in cache: cache[cacheKey]=function(config, *args, **kwargs) with open(persistentCache, \"wb\") as cacheFile: pickle.dump(cache, cacheFile) return cache[cacheKey] return f return decorator def _executeWithFakeConfig(test, commands): \"\"\" Returns(stdout, stderr, exitCode, timeoutInfo, parsedCommands) \"\"\" litConfig=lit.LitConfig.LitConfig( progname=\"lit\", path=[], quiet=False, useValgrind=False, valgrindLeakCheck=False, valgrindArgs=[], noExecute=False, debug=False, isWindows=platform.system()==\"Windows\", order=\"smart\", params={}, ) return libcxx.test.format._executeScriptInternal(test, litConfig, commands) def _makeConfigTest(config): sourceRoot=os.path.join(config.test_exec_root, \"__config_src__\") execRoot=os.path.join(config.test_exec_root, \"__config_exec__\") for supportDir in(sourceRoot, execRoot): if not os.path.exists(supportDir): os.makedirs(supportDir) suite=lit.Test.TestSuite(\"__config__\", sourceRoot, execRoot, config) tmp=tempfile.NamedTemporaryFile(dir=sourceRoot, delete=False, suffix=\".cpp\") tmp.close() pathInSuite=[os.path.relpath(tmp.name, sourceRoot)] class TestWrapper(lit.Test.Test): def __enter__(self): testDir, _=libcxx.test.format._getTempPaths(self) os.makedirs(testDir) return self def __exit__(self, *args): testDir, _=libcxx.test.format._getTempPaths(self) shutil.rmtree(testDir) os.remove(tmp.name) return TestWrapper(suite, pathInSuite, config) @_memoizeExpensiveOperation(lambda c, s, f=[]:(c.substitutions, c.environment, s, f)) def sourceBuilds(config, source, additionalFlags=[]): \"\"\" Return whether the program in the given string builds successfully. This is done by compiling and linking a program that consists of the given source with the %{cxx} substitution, and seeing whether that succeeds. If any additional flags are passed, they are appended to the compiler invocation. \"\"\" with _makeConfigTest(config) as test: with open(test.getSourcePath(), \"w\") as sourceFile: sourceFile.write(source) _, _, exitCode, _, _=_executeWithFakeConfig( test,[\"%{{build}}{}\".format(\" \".join(additionalFlags))] ) return exitCode==0 @_memoizeExpensiveOperation( lambda c, p, args=None:(c.substitutions, c.environment, p, args) ) def programOutput(config, program, args=None): \"\"\" Compiles a program for the test target, run it on the test target and return the output. Note that execution of the program is done through the %{exec} substitution, which means that the program may be run on a remote host depending on what %{exec} does. \"\"\" if args is None: args=[] with _makeConfigTest(config) as test: with open(test.getSourcePath(), \"w\") as source: source.write(program) _, err, exitCode, _, buildcmd=_executeWithFakeConfig(test,[\"%{build}\"]) if exitCode !=0: raise ConfigurationCompilationError( \"Failed to build program, cmd:\\n{}\\nstderr is:\\n{}\".format( buildcmd, err ) ) out, err, exitCode, _, runcmd=_executeWithFakeConfig( test,[\"%{{run}}{}\".format(\" \".join(args))] ) if exitCode !=0: raise ConfigurationRuntimeError( \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err) ) return libcxx.test.format._parseLitOutput(out) @_memoizeExpensiveOperation( lambda c, p, args=None:(c.substitutions, c.environment, p, args) ) def programSucceeds(config, program, args=None): \"\"\" Compiles a program for the test target, run it on the test target and return whether it completed successfully. Note that execution of the program is done through the %{exec} substitution, which means that the program may be run on a remote host depending on what %{exec} does. \"\"\" try: programOutput(config, program, args) except ConfigurationRuntimeError: return False return True @_memoizeExpensiveOperation(lambda c, f:(c.substitutions, c.environment, f)) def hasCompileFlag(config, flag): \"\"\" Return whether the compiler in the configuration supports a given compiler flag. This is done by executing the %{cxx} substitution with the given flag and checking whether that succeeds. \"\"\" with _makeConfigTest(config) as test: out, err, exitCode, timeoutInfo, _=_executeWithFakeConfig( test, [ \"%{{cxx}} -xc++{} -Werror -fsyntax-only %{{flags}} %{{compile_flags}}{}\".format( os.devnull, flag ) ], ) return exitCode==0 @_memoizeExpensiveOperation(lambda c, s:(c.substitutions, c.environment, s)) def runScriptExitCode(config, script): \"\"\" Runs the given script as a Lit test, and returns the exit code of the execution. The script must be a list of commands, each of which being something that could appear on the right-hand-side of a `RUN:` keyword. \"\"\" with _makeConfigTest(config) as test: _, _, exitCode, _, _=_executeWithFakeConfig(test, script) return exitCode @_memoizeExpensiveOperation(lambda c, s:(c.substitutions, c.environment, s)) def commandOutput(config, command): \"\"\" Runs the given script as a Lit test, and returns the output. If the exit code isn't 0 an exception is raised. The script must be a list of commands, each of which being something that could appear on the right-hand-side of a `RUN:` keyword. \"\"\" with _makeConfigTest(config) as test: out, err, exitCode, _, cmd=_executeWithFakeConfig(test, command) if exitCode !=0: raise ConfigurationRuntimeError( \"Failed to run command:{}\\nstderr is:\\n{}\".format(cmd, err) ) return out @_memoizeExpensiveOperation(lambda c, l:(c.substitutions, c.environment, l)) def hasAnyLocale(config, locales): \"\"\" Return whether the runtime execution environment supports a given locale. Different systems may use different names for a locale, so this function checks whether any of the passed locale names is supported by setlocale() and returns true if one of them works. This is done by executing a program that tries to set the given locale using %{exec} --this means that the command may be executed on a remote host depending on the %{exec} substitution. \"\"\" program=\"\"\" int main(int, char**){ return 1;} int main(int argc, char** argv){ for(int i=1; i < argc; i++){ if(::setlocale(LC_ALL, argv[i]) !=NULL){ return 0; } } return 1; } \"\"\" return programSucceeds(config, program, args=[pipes.quote(l) for l in locales]) @_memoizeExpensiveOperation(lambda c, flags=\"\":(c.substitutions, c.environment, flags)) def compilerMacros(config, flags=\"\"): \"\"\" Return a dictionary of predefined compiler macros. The keys are strings representing macros, and the values are strings representing what each macro is defined to. If the optional `flags` argument(a string) is provided, these flags will be added to the compiler invocation when generating the macros. \"\"\" with _makeConfigTest(config) as test: with open(test.getSourcePath(), \"w\") as sourceFile: sourceFile.write( \"\"\" \"\"\" ) unparsedOutput, err, exitCode, _, cmd=_executeWithFakeConfig( test,[\"%{{cxx}} %s -dM -E %{{flags}} %{{compile_flags}}{}\".format(flags)] ) if exitCode !=0: raise ConfigurationCompilationError( \"Failed to retrieve compiler macros, compiler invocation is:\\n{}\\nstderr is:\\n{}\".format( cmd, err ) ) parsedMacros=dict() defines=( l.strip() for l in unparsedOutput.split(\"\\n\") if l.startswith(\" ) for line in defines: line=line[len(\" macro, _, value=line.partition(\" \") parsedMacros[macro]=value return parsedMacros def featureTestMacros(config, flags=\"\"): \"\"\" Return a dictionary of feature test macros. The keys are strings representing feature test macros, and the values are integers representing the value of the macro. \"\"\" allMacros=compilerMacros(config, flags) return{ m: int(v.rstrip(\"LlUu\")) for(m, v) in allMacros.items() if m.startswith(\"__cpp_\") } def _getSubstitution(substitution, config): for(orig, replacement) in config.substitutions: if orig==substitution: return replacement raise ValueError('Substitution{} is not in the config.'.format(substitution)) def _appendToSubstitution(substitutions, key, value): return[(k, v +\" \" +value) if k==key else(k, v) for(k, v) in substitutions] def _prependToSubstitution(substitutions, key, value): return[(k, value +\" \" +v) if k==key else(k, v) for(k, v) in substitutions] class ConfigAction(object): \"\"\" This class represents an action that can be performed on a Lit TestingConfig object. Examples of such actions are adding or modifying substitutions, Lit features, etc. This class only provides the interface of such actions, and it is meant to be subclassed appropriately to create new actions. \"\"\" def applyTo(self, config): \"\"\" Applies the action to the given configuration. This should modify the configuration object in place, and return nothing. If applying the action to the configuration would yield an invalid configuration, and it is possible to diagnose it here, this method should produce an error. For example, it should be an error to modify a substitution in a way that we know for sure is invalid(e.g. adding a compiler flag when we know the compiler doesn't support it). Failure to do so early may lead to difficult-to-diagnose issues down the road. \"\"\" pass def pretty(self, config, litParams): \"\"\" Returns a short and human-readable string describing what this action does. This is used for logging purposes when running the test suite, so it should be kept concise. \"\"\" pass class AddFeature(ConfigAction): \"\"\" This action defines the given Lit feature when running the test suite. The name of the feature can be a string or a callable, in which case it is called with the configuration to produce the feature name(as a string). \"\"\" def __init__(self, name): self._name=name def _getName(self, config): name=self._name(config) if callable(self._name) else self._name if not isinstance(name, str): raise ValueError( \"Lit feature did not resolve to a string(got{})\".format(name) ) return name def applyTo(self, config): config.available_features.add(self._getName(config)) def pretty(self, config, litParams): return \"add Lit feature{}\".format(self._getName(config)) class AddFlag(ConfigAction): \"\"\" This action adds the given flag to the %{flags} substitution. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) assert hasCompileFlag( config, flag ), \"Trying to enable flag{}, which is not supported\".format(flag) config.substitutions=_appendToSubstitution( config.substitutions, \"%{flags}\", flag ) def pretty(self, config, litParams): return \"add{} to %{{flags}}\".format(self._getFlag(config)) class AddFlagIfSupported(ConfigAction): \"\"\" This action adds the given flag to the %{flags} substitution, only if the compiler supports the flag. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) if hasCompileFlag(config, flag): config.substitutions=_appendToSubstitution( config.substitutions, \"%{flags}\", flag ) def pretty(self, config, litParams): return \"add{} to %{{flags}}\".format(self._getFlag(config)) class AddCompileFlag(ConfigAction): \"\"\" This action adds the given flag to the %{compile_flags} substitution. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) assert hasCompileFlag( config, flag ), \"Trying to enable compile flag{}, which is not supported\".format(flag) config.substitutions=_appendToSubstitution( config.substitutions, \"%{compile_flags}\", flag ) def pretty(self, config, litParams): return \"add{} to %{{compile_flags}}\".format(self._getFlag(config)) class AddLinkFlag(ConfigAction): \"\"\" This action appends the given flag to the %{link_flags} substitution. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) assert hasCompileFlag( config, flag ), \"Trying to enable link flag{}, which is not supported\".format(flag) config.substitutions=_appendToSubstitution( config.substitutions, \"%{link_flags}\", flag ) def pretty(self, config, litParams): return \"append{} to %{{link_flags}}\".format(self._getFlag(config)) class PrependLinkFlag(ConfigAction): \"\"\" This action prepends the given flag to the %{link_flags} substitution. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) assert hasCompileFlag( config, flag ), \"Trying to enable link flag{}, which is not supported\".format(flag) config.substitutions=_prependToSubstitution( config.substitutions, \"%{link_flags}\", flag ) def pretty(self, config, litParams): return \"prepend{} to %{{link_flags}}\".format(self._getFlag(config)) class AddOptionalWarningFlag(ConfigAction): \"\"\" This action adds the given warning flag to the %{compile_flags} substitution, if it is supported by the compiler. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) if hasCompileFlag(config, \"-Werror \" +flag): config.substitutions=_appendToSubstitution( config.substitutions, \"%{compile_flags}\", flag ) def pretty(self, config, litParams): return \"add{} to %{{compile_flags}}\".format(self._getFlag(config)) class AddSubstitution(ConfigAction): \"\"\" This action adds the given substitution to the Lit configuration. The substitution can be a string or a callable, in which case it is called with the configuration to produce the actual substitution(as a string). \"\"\" def __init__(self, key, substitution): self._key=key self._getSub=( lambda config: substitution(config) if callable(substitution) else substitution ) def applyTo(self, config): key=self._key sub=self._getSub(config) config.substitutions.append((key, sub)) def pretty(self, config, litParams): return \"add substitution{}={}\".format(self._key, self._getSub(config)) class Feature(object): \"\"\" Represents a Lit available feature that is enabled whenever it is supported. A feature like this informs the test suite about a capability of the compiler, platform, etc. Unlike Parameters, it does not make sense to explicitly control whether a Feature is enabled --it should be enabled whenever it is supported. \"\"\" def __init__(self, name, actions=None, when=lambda _: True): \"\"\" Create a Lit feature for consumption by a test suite. -name The name of the feature. This is what will end up in Lit's available features if the feature is enabled. This can be either a string or a callable, in which case it is passed the TestingConfig and should generate a string representing the name of the feature. -actions An optional list of ConfigActions to apply when the feature is supported. An AddFeature action is always created regardless of any actions supplied here --these actions are meant to perform more than setting a corresponding Lit feature(e.g. adding compiler flags). If 'actions' is a callable, it is called with the current configuration object to generate the actual list of actions. -when A callable that gets passed a TestingConfig and should return a boolean representing whether the feature is supported in that configuration. For example, this can use `hasCompileFlag` to check whether the compiler supports the flag that the feature represents. If omitted, the feature will always be considered supported. \"\"\" self._name=name self._actions=[] if actions is None else actions self._isSupported=when def _getName(self, config): name=self._name(config) if callable(self._name) else self._name if not isinstance(name, str): raise ValueError( \"Feature did not resolve to a name that's a string, got{}\".format(name) ) return name def getActions(self, config): \"\"\" Return the list of actions associated to this feature. If the feature is not supported, an empty list is returned. If the feature is supported, an `AddFeature` action is automatically added to the returned list of actions, in addition to any actions provided on construction. \"\"\" if not self._isSupported(config): return[] else: actions=( self._actions(config) if callable(self._actions) else self._actions ) return[AddFeature(self._getName(config))] +actions def pretty(self, config): \"\"\" Returns the Feature's name. \"\"\" return self._getName(config) def _str_to_bool(s): \"\"\" Convert a string value to a boolean. True values are \"y\", \"yes\", \"t\", \"true\", \"on\" and \"1\", regardless of capitalization. False values are \"n\", \"no\", \"f\", \"false\", \"off\" and \"0\", regardless of capitalization. \"\"\" trueVals=[\"y\", \"yes\", \"t\", \"true\", \"on\", \"1\"] falseVals=[\"n\", \"no\", \"f\", \"false\", \"off\", \"0\"] lower=s.lower() if lower in trueVals: return True elif lower in falseVals: return False else: raise ValueError(\"Got string '{}', which isn't a valid boolean\".format(s)) def _parse_parameter(s, type): if type is bool and isinstance(s, str): return _str_to_bool(s) elif type is list and isinstance(s, str): return[x.strip() for x in s.split(\",\") if x.strip()] return type(s) class Parameter(object): \"\"\" Represents a parameter of a Lit test suite. Parameters are used to customize the behavior of test suites in a user controllable way. There are two ways of setting the value of a Parameter. The first one is to pass `--param <KEY>=<VALUE>` when running Lit(or equivalently to set `litConfig.params[KEY]=VALUE` somewhere in the Lit configuration files. This method will set the parameter globally for all test suites being run. The second method is to set `config.KEY=VALUE` somewhere in the Lit configuration files, which sets the parameter only for the test suite(s) that use that `config` object. Parameters can have multiple possible values, and they can have a default value when left unspecified. They can also have any number of ConfigActions associated to them, in which case the actions will be performed on the TestingConfig if the parameter is enabled. Depending on the actions associated to a Parameter, it may be an error to enable the Parameter if some actions are not supported in the given configuration. For example, trying to set the compilation standard to C++23 when `-std=c++23` is not supported by the compiler would be an error. \"\"\" def __init__(self, name, type, help, actions, choices=None, default=None): \"\"\" Create a Lit parameter to customize the behavior of a test suite. -name The name of the parameter that can be used to set it on the command-line. On the command-line, the parameter can be set using `--param <name>=<value>` when running Lit. This must be non-empty. -choices An optional non-empty set of possible values for this parameter. If provided, this must be anything that can be iterated. It is an error if the parameter is given a value that is not in that set, whether explicitly or through a default value. -type A callable that can be used to parse the value of the parameter given on the command-line. As a special case, using the type `bool` also allows parsing strings with boolean-like contents, and the type `list` will parse a string delimited by commas into a list of the substrings. -help A string explaining the parameter, for documentation purposes. TODO: We should be able to surface those from the Lit command-line. -actions A callable that gets passed the parsed value of the parameter(either the one passed on the command-line or the default one), and that returns a list of ConfigAction to perform given the value of the parameter. All the ConfigAction must be supported in the given configuration. -default An optional default value to use for the parameter when no value is provided on the command-line. If the default value is a callable, it is called with the TestingConfig and should return the default value for the parameter. Whether the default value is computed or specified directly, it must be in the 'choices' provided for that Parameter. \"\"\" self._name=name if len(self._name)==0: raise ValueError(\"Parameter name must not be the empty string\") if choices is not None: self._choices=list(choices) if len(self._choices)==0: raise ValueError( \"Parameter '{}' must be given at least one possible value\".format( self._name ) ) else: self._choices=None self._parse=lambda x: _parse_parameter(x, type) self._help=help self._actions=actions self._default=default def _getValue(self, config, litParams): \"\"\" Return the value of the parameter given the configuration objects. \"\"\" param=getattr(config, self.name, None) param=litParams.get(self.name, param) if param is None and self._default is None: raise ValueError( \"Parameter{} doesn't have a default value, but it was not specified in the Lit parameters or in the Lit config\".format( self.name ) ) getDefault=( lambda: self._default(config) if callable(self._default) else self._default ) if param is not None: (pretty, value)=(param, self._parse(param)) else: value=getDefault() pretty=\"{}(default)\".format(value) if self._choices and value not in self._choices: raise ValueError( \"Got value '{}' for parameter '{}', which is not in the provided set of possible choices:{}\".format( value, self.name, self._choices ) ) return(pretty, value) @property def name(self): \"\"\" Return the name of the parameter. This is the name that can be used to set the parameter on the command-line when running Lit. \"\"\" return self._name def getActions(self, config, litParams): \"\"\" Return the list of actions associated to this value of the parameter. \"\"\" (_, parameterValue)=self._getValue(config, litParams) return self._actions(parameterValue) def pretty(self, config, litParams): \"\"\" Return a pretty representation of the parameter's name and value. \"\"\" (prettyParameterValue, _)=self._getValue(config, litParams) return \"{}={}\".format(self.name, prettyParameterValue) ", "sourceWithComments": "# ===----------------------------------------------------------------------===##\n#\n# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n# See https://llvm.org/LICENSE.txt for license information.\n# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n#\n# ===----------------------------------------------------------------------===##\n\nimport os\nimport pickle\nimport pipes\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport tempfile\n\nimport libcxx.test.format\nimport lit\nimport lit.LitConfig\nimport lit.Test\nimport lit.TestRunner\nimport lit.util\n\n\nclass ConfigurationError(Exception):\n    pass\n\n\nclass ConfigurationCompilationError(ConfigurationError):\n    pass\n\n\nclass ConfigurationRuntimeError(ConfigurationError):\n    pass\n\n\ndef _memoizeExpensiveOperation(extractCacheKey):\n    \"\"\"\n    Allows memoizing a very expensive operation.\n\n    We pickle the cache key to make sure we store an immutable representation\n    of it. If we stored an object and the object was referenced elsewhere, it\n    could be changed from under our feet, which would break the cache.\n\n    We also store the cache for a given function persistently across invocations\n    of Lit. This dramatically speeds up the configuration of the test suite when\n    invoking Lit repeatedly, which is important for developer workflow. However,\n    with the current implementation that does not synchronize updates to the\n    persistent cache, this also means that one should not call a memoized\n    operation from multiple threads. This should normally not be a problem\n    since Lit configuration is single-threaded.\n    \"\"\"\n\n    def decorator(function):\n        def f(config, *args, **kwargs):\n            cacheRoot = os.path.join(config.test_exec_root, \"__config_cache__\")\n            persistentCache = os.path.join(cacheRoot, function.__name__)\n            if not os.path.exists(cacheRoot):\n                os.makedirs(cacheRoot)\n\n            cache = {}\n            # Load a cache from a previous Lit invocation if there is one.\n            if os.path.exists(persistentCache):\n                with open(persistentCache, \"rb\") as cacheFile:\n                    cache = pickle.load(cacheFile)\n\n            cacheKey = pickle.dumps(extractCacheKey(config, *args, **kwargs))\n            if cacheKey not in cache:\n                cache[cacheKey] = function(config, *args, **kwargs)\n                # Update the persistent cache so it knows about the new key\n                with open(persistentCache, \"wb\") as cacheFile:\n                    pickle.dump(cache, cacheFile)\n            return cache[cacheKey]\n\n        return f\n\n    return decorator\n\n\ndef _executeWithFakeConfig(test, commands):\n    \"\"\"\n    Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n    \"\"\"\n    litConfig = lit.LitConfig.LitConfig(\n        progname=\"lit\",\n        path=[],\n        quiet=False,\n        useValgrind=False,\n        valgrindLeakCheck=False,\n        valgrindArgs=[],\n        noExecute=False,\n        debug=False,\n        isWindows=platform.system() == \"Windows\",\n        order=\"smart\",\n        params={},\n    )\n    return libcxx.test.format._executeScriptInternal(test, litConfig, commands)\n\n\ndef _makeConfigTest(config):\n    # Make sure the support directories exist, which is needed to create\n    # the temporary file %t below.\n    sourceRoot = os.path.join(config.test_exec_root, \"__config_src__\")\n    execRoot = os.path.join(config.test_exec_root, \"__config_exec__\")\n    for supportDir in (sourceRoot, execRoot):\n        if not os.path.exists(supportDir):\n            os.makedirs(supportDir)\n\n    # Create a dummy test suite and single dummy test inside it. As part of\n    # the Lit configuration, automatically do the equivalent of 'mkdir %T'\n    # and 'rm -r %T' to avoid cluttering the build directory.\n    suite = lit.Test.TestSuite(\"__config__\", sourceRoot, execRoot, config)\n    tmp = tempfile.NamedTemporaryFile(dir=sourceRoot, delete=False, suffix=\".cpp\")\n    tmp.close()\n    pathInSuite = [os.path.relpath(tmp.name, sourceRoot)]\n\n    class TestWrapper(lit.Test.Test):\n        def __enter__(self):\n            testDir, _ = libcxx.test.format._getTempPaths(self)\n            os.makedirs(testDir)\n            return self\n\n        def __exit__(self, *args):\n            testDir, _ = libcxx.test.format._getTempPaths(self)\n            shutil.rmtree(testDir)\n            os.remove(tmp.name)\n\n    return TestWrapper(suite, pathInSuite, config)\n\n\n@_memoizeExpensiveOperation(lambda c, s, f=[]: (c.substitutions, c.environment, s, f))\ndef sourceBuilds(config, source, additionalFlags=[]):\n    \"\"\"\n    Return whether the program in the given string builds successfully.\n\n    This is done by compiling and linking a program that consists of the given\n    source with the %{cxx} substitution, and seeing whether that succeeds. If\n    any additional flags are passed, they are appended to the compiler invocation.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        with open(test.getSourcePath(), \"w\") as sourceFile:\n            sourceFile.write(source)\n        _, _, exitCode, _, _ = _executeWithFakeConfig(\n            test, [\"%{{build}} {}\".format(\" \".join(additionalFlags))]\n        )\n        return exitCode == 0\n\n\n@_memoizeExpensiveOperation(\n    lambda c, p, args=None: (c.substitutions, c.environment, p, args)\n)\ndef programOutput(config, program, args=None):\n    \"\"\"\n    Compiles a program for the test target, run it on the test target and return\n    the output.\n\n    Note that execution of the program is done through the %{exec} substitution,\n    which means that the program may be run on a remote host depending on what\n    %{exec} does.\n    \"\"\"\n    if args is None:\n        args = []\n    with _makeConfigTest(config) as test:\n        with open(test.getSourcePath(), \"w\") as source:\n            source.write(program)\n        _, err, exitCode, _, buildcmd = _executeWithFakeConfig(test, [\"%{build}\"])\n        if exitCode != 0:\n            raise ConfigurationCompilationError(\n                \"Failed to build program, cmd:\\n{}\\nstderr is:\\n{}\".format(\n                    buildcmd, err\n                )\n            )\n\n        out, err, exitCode, _, runcmd = _executeWithFakeConfig(\n            test, [\"%{{run}} {}\".format(\" \".join(args))]\n        )\n        if exitCode != 0:\n            raise ConfigurationRuntimeError(\n                \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n            )\n\n        return libcxx.test.format._parseLitOutput(out)\n\n\n@_memoizeExpensiveOperation(\n    lambda c, p, args=None: (c.substitutions, c.environment, p, args)\n)\ndef programSucceeds(config, program, args=None):\n    \"\"\"\n    Compiles a program for the test target, run it on the test target and return\n    whether it completed successfully.\n\n    Note that execution of the program is done through the %{exec} substitution,\n    which means that the program may be run on a remote host depending on what\n    %{exec} does.\n    \"\"\"\n    try:\n        programOutput(config, program, args)\n    except ConfigurationRuntimeError:\n        return False\n    return True\n\n\n@_memoizeExpensiveOperation(lambda c, f: (c.substitutions, c.environment, f))\ndef hasCompileFlag(config, flag):\n    \"\"\"\n    Return whether the compiler in the configuration supports a given compiler flag.\n\n    This is done by executing the %{cxx} substitution with the given flag and\n    checking whether that succeeds.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        out, err, exitCode, timeoutInfo, _ = _executeWithFakeConfig(\n            test,\n            [\n                \"%{{cxx}} -xc++ {} -Werror -fsyntax-only %{{flags}} %{{compile_flags}} {}\".format(\n                    os.devnull, flag\n                )\n            ],\n        )\n        return exitCode == 0\n\n\n@_memoizeExpensiveOperation(lambda c, s: (c.substitutions, c.environment, s))\ndef runScriptExitCode(config, script):\n    \"\"\"\n    Runs the given script as a Lit test, and returns the exit code of the execution.\n\n    The script must be a list of commands, each of which being something that\n    could appear on the right-hand-side of a `RUN:` keyword.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        _, _, exitCode, _, _ = _executeWithFakeConfig(test, script)\n        return exitCode\n\n\n@_memoizeExpensiveOperation(lambda c, s: (c.substitutions, c.environment, s))\ndef commandOutput(config, command):\n    \"\"\"\n    Runs the given script as a Lit test, and returns the output.\n    If the exit code isn't 0 an exception is raised.\n\n    The script must be a list of commands, each of which being something that\n    could appear on the right-hand-side of a `RUN:` keyword.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        out, err, exitCode, _, cmd = _executeWithFakeConfig(test, command)\n        if exitCode != 0:\n            raise ConfigurationRuntimeError(\n                \"Failed to run command: {}\\nstderr is:\\n{}\".format(cmd, err)\n            )\n        return out\n\n\n@_memoizeExpensiveOperation(lambda c, l: (c.substitutions, c.environment, l))\ndef hasAnyLocale(config, locales):\n    \"\"\"\n    Return whether the runtime execution environment supports a given locale.\n    Different systems may use different names for a locale, so this function checks\n    whether any of the passed locale names is supported by setlocale() and returns\n    true if one of them works.\n\n    This is done by executing a program that tries to set the given locale using\n    %{exec} -- this means that the command may be executed on a remote host\n    depending on the %{exec} substitution.\n    \"\"\"\n    program = \"\"\"\n    #include <stddef.h>\n    #if defined(_LIBCPP_HAS_NO_LOCALIZATION)\n      int main(int, char**) { return 1; }\n    #else\n      #include <locale.h>\n      int main(int argc, char** argv) {\n        for (int i = 1; i < argc; i++) {\n          if (::setlocale(LC_ALL, argv[i]) != NULL) {\n            return 0;\n          }\n        }\n        return 1;\n      }\n    #endif\n  \"\"\"\n    return programSucceeds(config, program, args=[pipes.quote(l) for l in locales])\n\n\n@_memoizeExpensiveOperation(lambda c, flags=\"\": (c.substitutions, c.environment, flags))\ndef compilerMacros(config, flags=\"\"):\n    \"\"\"\n    Return a dictionary of predefined compiler macros.\n\n    The keys are strings representing macros, and the values are strings\n    representing what each macro is defined to.\n\n    If the optional `flags` argument (a string) is provided, these flags will\n    be added to the compiler invocation when generating the macros.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        with open(test.getSourcePath(), \"w\") as sourceFile:\n            sourceFile.write(\n                \"\"\"\n      #if __has_include(<__config_site>)\n      #  include <__config_site>\n      #endif\n      \"\"\"\n            )\n        unparsedOutput, err, exitCode, _, cmd = _executeWithFakeConfig(\n            test, [\"%{{cxx}} %s -dM -E %{{flags}} %{{compile_flags}} {}\".format(flags)]\n        )\n        if exitCode != 0:\n            raise ConfigurationCompilationError(\n                \"Failed to retrieve compiler macros, compiler invocation is:\\n{}\\nstderr is:\\n{}\".format(\n                    cmd, err\n                )\n            )\n        parsedMacros = dict()\n        defines = (\n            l.strip() for l in unparsedOutput.split(\"\\n\") if l.startswith(\"#define \")\n        )\n        for line in defines:\n            line = line[len(\"#define \") :]\n            macro, _, value = line.partition(\" \")\n            parsedMacros[macro] = value\n        return parsedMacros\n\n\ndef featureTestMacros(config, flags=\"\"):\n    \"\"\"\n    Return a dictionary of feature test macros.\n\n    The keys are strings representing feature test macros, and the values are\n    integers representing the value of the macro.\n    \"\"\"\n    allMacros = compilerMacros(config, flags)\n    return {\n        m: int(v.rstrip(\"LlUu\"))\n        for (m, v) in allMacros.items()\n        if m.startswith(\"__cpp_\")\n    }\n\n\ndef _getSubstitution(substitution, config):\n  for (orig, replacement) in config.substitutions:\n    if orig == substitution:\n      return replacement\n  raise ValueError('Substitution {} is not in the config.'.format(substitution))\n\ndef _appendToSubstitution(substitutions, key, value):\n    return [(k, v + \" \" + value) if k == key else (k, v) for (k, v) in substitutions]\n\n\ndef _prependToSubstitution(substitutions, key, value):\n    return [(k, value + \" \" + v) if k == key else (k, v) for (k, v) in substitutions]\n\n\nclass ConfigAction(object):\n    \"\"\"\n    This class represents an action that can be performed on a Lit TestingConfig\n    object.\n\n    Examples of such actions are adding or modifying substitutions, Lit features,\n    etc. This class only provides the interface of such actions, and it is meant\n    to be subclassed appropriately to create new actions.\n    \"\"\"\n\n    def applyTo(self, config):\n        \"\"\"\n        Applies the action to the given configuration.\n\n        This should modify the configuration object in place, and return nothing.\n\n        If applying the action to the configuration would yield an invalid\n        configuration, and it is possible to diagnose it here, this method\n        should produce an error. For example, it should be an error to modify\n        a substitution in a way that we know for sure is invalid (e.g. adding\n        a compiler flag when we know the compiler doesn't support it). Failure\n        to do so early may lead to difficult-to-diagnose issues down the road.\n        \"\"\"\n        pass\n\n    def pretty(self, config, litParams):\n        \"\"\"\n        Returns a short and human-readable string describing what this action does.\n\n        This is used for logging purposes when running the test suite, so it should\n        be kept concise.\n        \"\"\"\n        pass\n\n\nclass AddFeature(ConfigAction):\n    \"\"\"\n    This action defines the given Lit feature when running the test suite.\n\n    The name of the feature can be a string or a callable, in which case it is\n    called with the configuration to produce the feature name (as a string).\n    \"\"\"\n\n    def __init__(self, name):\n        self._name = name\n\n    def _getName(self, config):\n        name = self._name(config) if callable(self._name) else self._name\n        if not isinstance(name, str):\n            raise ValueError(\n                \"Lit feature did not resolve to a string (got {})\".format(name)\n            )\n        return name\n\n    def applyTo(self, config):\n        config.available_features.add(self._getName(config))\n\n    def pretty(self, config, litParams):\n        return \"add Lit feature {}\".format(self._getName(config))\n\n\nclass AddFlag(ConfigAction):\n    \"\"\"\n    This action adds the given flag to the %{flags} substitution.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        assert hasCompileFlag(\n            config, flag\n        ), \"Trying to enable flag {}, which is not supported\".format(flag)\n        config.substitutions = _appendToSubstitution(\n            config.substitutions, \"%{flags}\", flag\n        )\n\n    def pretty(self, config, litParams):\n        return \"add {} to %{{flags}}\".format(self._getFlag(config))\n\nclass AddFlagIfSupported(ConfigAction):\n    \"\"\"\n    This action adds the given flag to the %{flags} substitution, only if\n    the compiler supports the flag.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        if hasCompileFlag(config, flag):\n            config.substitutions = _appendToSubstitution(\n                config.substitutions, \"%{flags}\", flag\n            )\n\n    def pretty(self, config, litParams):\n        return \"add {} to %{{flags}}\".format(self._getFlag(config))\n\n\nclass AddCompileFlag(ConfigAction):\n    \"\"\"\n    This action adds the given flag to the %{compile_flags} substitution.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        assert hasCompileFlag(\n            config, flag\n        ), \"Trying to enable compile flag {}, which is not supported\".format(flag)\n        config.substitutions = _appendToSubstitution(\n            config.substitutions, \"%{compile_flags}\", flag\n        )\n\n    def pretty(self, config, litParams):\n        return \"add {} to %{{compile_flags}}\".format(self._getFlag(config))\n\n\nclass AddLinkFlag(ConfigAction):\n    \"\"\"\n    This action appends the given flag to the %{link_flags} substitution.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        assert hasCompileFlag(\n            config, flag\n        ), \"Trying to enable link flag {}, which is not supported\".format(flag)\n        config.substitutions = _appendToSubstitution(\n            config.substitutions, \"%{link_flags}\", flag\n        )\n\n    def pretty(self, config, litParams):\n        return \"append {} to %{{link_flags}}\".format(self._getFlag(config))\n\n\nclass PrependLinkFlag(ConfigAction):\n    \"\"\"\n    This action prepends the given flag to the %{link_flags} substitution.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        assert hasCompileFlag(\n            config, flag\n        ), \"Trying to enable link flag {}, which is not supported\".format(flag)\n        config.substitutions = _prependToSubstitution(\n            config.substitutions, \"%{link_flags}\", flag\n        )\n\n    def pretty(self, config, litParams):\n        return \"prepend {} to %{{link_flags}}\".format(self._getFlag(config))\n\n\nclass AddOptionalWarningFlag(ConfigAction):\n    \"\"\"\n    This action adds the given warning flag to the %{compile_flags} substitution,\n    if it is supported by the compiler.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        # Use -Werror to make sure we see an error about the flag being unsupported.\n        if hasCompileFlag(config, \"-Werror \" + flag):\n            config.substitutions = _appendToSubstitution(\n                config.substitutions, \"%{compile_flags}\", flag\n            )\n\n    def pretty(self, config, litParams):\n        return \"add {} to %{{compile_flags}}\".format(self._getFlag(config))\n\n\nclass AddSubstitution(ConfigAction):\n    \"\"\"\n    This action adds the given substitution to the Lit configuration.\n\n    The substitution can be a string or a callable, in which case it is called\n    with the configuration to produce the actual substitution (as a string).\n    \"\"\"\n\n    def __init__(self, key, substitution):\n        self._key = key\n        self._getSub = (\n            lambda config: substitution(config)\n            if callable(substitution)\n            else substitution\n        )\n\n    def applyTo(self, config):\n        key = self._key\n        sub = self._getSub(config)\n        config.substitutions.append((key, sub))\n\n    def pretty(self, config, litParams):\n        return \"add substitution {} = {}\".format(self._key, self._getSub(config))\n\n\nclass Feature(object):\n    \"\"\"\n    Represents a Lit available feature that is enabled whenever it is supported.\n\n    A feature like this informs the test suite about a capability of the compiler,\n    platform, etc. Unlike Parameters, it does not make sense to explicitly\n    control whether a Feature is enabled -- it should be enabled whenever it\n    is supported.\n    \"\"\"\n\n    def __init__(self, name, actions=None, when=lambda _: True):\n        \"\"\"\n        Create a Lit feature for consumption by a test suite.\n\n        - name\n            The name of the feature. This is what will end up in Lit's available\n            features if the feature is enabled. This can be either a string or a\n            callable, in which case it is passed the TestingConfig and should\n            generate a string representing the name of the feature.\n\n        - actions\n            An optional list of ConfigActions to apply when the feature is supported.\n            An AddFeature action is always created regardless of any actions supplied\n            here -- these actions are meant to perform more than setting a corresponding\n            Lit feature (e.g. adding compiler flags). If 'actions' is a callable, it\n            is called with the current configuration object to generate the actual\n            list of actions.\n\n        - when\n            A callable that gets passed a TestingConfig and should return a\n            boolean representing whether the feature is supported in that\n            configuration. For example, this can use `hasCompileFlag` to\n            check whether the compiler supports the flag that the feature\n            represents. If omitted, the feature will always be considered\n            supported.\n        \"\"\"\n        self._name = name\n        self._actions = [] if actions is None else actions\n        self._isSupported = when\n\n    def _getName(self, config):\n        name = self._name(config) if callable(self._name) else self._name\n        if not isinstance(name, str):\n            raise ValueError(\n                \"Feature did not resolve to a name that's a string, got {}\".format(name)\n            )\n        return name\n\n    def getActions(self, config):\n        \"\"\"\n        Return the list of actions associated to this feature.\n\n        If the feature is not supported, an empty list is returned.\n        If the feature is supported, an `AddFeature` action is automatically added\n        to the returned list of actions, in addition to any actions provided on\n        construction.\n        \"\"\"\n        if not self._isSupported(config):\n            return []\n        else:\n            actions = (\n                self._actions(config) if callable(self._actions) else self._actions\n            )\n            return [AddFeature(self._getName(config))] + actions\n\n    def pretty(self, config):\n        \"\"\"\n        Returns the Feature's name.\n        \"\"\"\n        return self._getName(config)\n\n\ndef _str_to_bool(s):\n    \"\"\"\n    Convert a string value to a boolean.\n\n    True values are \"y\", \"yes\", \"t\", \"true\", \"on\" and \"1\", regardless of capitalization.\n    False values are \"n\", \"no\", \"f\", \"false\", \"off\" and \"0\", regardless of capitalization.\n    \"\"\"\n    trueVals = [\"y\", \"yes\", \"t\", \"true\", \"on\", \"1\"]\n    falseVals = [\"n\", \"no\", \"f\", \"false\", \"off\", \"0\"]\n    lower = s.lower()\n    if lower in trueVals:\n        return True\n    elif lower in falseVals:\n        return False\n    else:\n        raise ValueError(\"Got string '{}', which isn't a valid boolean\".format(s))\n\n\ndef _parse_parameter(s, type):\n    if type is bool and isinstance(s, str):\n        return _str_to_bool(s)\n    elif type is list and isinstance(s, str):\n        return [x.strip() for x in s.split(\",\") if x.strip()]\n    return type(s)\n\n\nclass Parameter(object):\n    \"\"\"\n    Represents a parameter of a Lit test suite.\n\n    Parameters are used to customize the behavior of test suites in a user\n    controllable way. There are two ways of setting the value of a Parameter.\n    The first one is to pass `--param <KEY>=<VALUE>` when running Lit (or\n    equivalently to set `litConfig.params[KEY] = VALUE` somewhere in the\n    Lit configuration files. This method will set the parameter globally for\n    all test suites being run.\n\n    The second method is to set `config.KEY = VALUE` somewhere in the Lit\n    configuration files, which sets the parameter only for the test suite(s)\n    that use that `config` object.\n\n    Parameters can have multiple possible values, and they can have a default\n    value when left unspecified. They can also have any number of ConfigActions\n    associated to them, in which case the actions will be performed on the\n    TestingConfig if the parameter is enabled. Depending on the actions\n    associated to a Parameter, it may be an error to enable the Parameter\n    if some actions are not supported in the given configuration. For example,\n    trying to set the compilation standard to C++23 when `-std=c++23` is not\n    supported by the compiler would be an error.\n    \"\"\"\n\n    def __init__(self, name, type, help, actions, choices=None, default=None):\n        \"\"\"\n        Create a Lit parameter to customize the behavior of a test suite.\n\n        - name\n            The name of the parameter that can be used to set it on the command-line.\n            On the command-line, the parameter can be set using `--param <name>=<value>`\n            when running Lit. This must be non-empty.\n\n        - choices\n            An optional non-empty set of possible values for this parameter. If provided,\n            this must be anything that can be iterated. It is an error if the parameter\n            is given a value that is not in that set, whether explicitly or through a\n            default value.\n\n        - type\n            A callable that can be used to parse the value of the parameter given\n            on the command-line. As a special case, using the type `bool` also\n            allows parsing strings with boolean-like contents, and the type `list`\n            will parse a string delimited by commas into a list of the substrings.\n\n        - help\n            A string explaining the parameter, for documentation purposes.\n            TODO: We should be able to surface those from the Lit command-line.\n\n        - actions\n            A callable that gets passed the parsed value of the parameter (either\n            the one passed on the command-line or the default one), and that returns\n            a list of ConfigAction to perform given the value of the parameter.\n            All the ConfigAction must be supported in the given configuration.\n\n        - default\n            An optional default value to use for the parameter when no value is\n            provided on the command-line. If the default value is a callable, it\n            is called with the TestingConfig and should return the default value\n            for the parameter. Whether the default value is computed or specified\n            directly, it must be in the 'choices' provided for that Parameter.\n        \"\"\"\n        self._name = name\n        if len(self._name) == 0:\n            raise ValueError(\"Parameter name must not be the empty string\")\n\n        if choices is not None:\n            self._choices = list(choices)  # should be finite\n            if len(self._choices) == 0:\n                raise ValueError(\n                    \"Parameter '{}' must be given at least one possible value\".format(\n                        self._name\n                    )\n                )\n        else:\n            self._choices = None\n\n        self._parse = lambda x: _parse_parameter(x, type)\n        self._help = help\n        self._actions = actions\n        self._default = default\n\n    def _getValue(self, config, litParams):\n        \"\"\"\n        Return the value of the parameter given the configuration objects.\n        \"\"\"\n        param = getattr(config, self.name, None)\n        param = litParams.get(self.name, param)\n        if param is None and self._default is None:\n            raise ValueError(\n                \"Parameter {} doesn't have a default value, but it was not specified in the Lit parameters or in the Lit config\".format(\n                    self.name\n                )\n            )\n        getDefault = (\n            lambda: self._default(config) if callable(self._default) else self._default\n        )\n\n        if param is not None:\n            (pretty, value) = (param, self._parse(param))\n        else:\n            value = getDefault()\n            pretty = \"{} (default)\".format(value)\n\n        if self._choices and value not in self._choices:\n            raise ValueError(\n                \"Got value '{}' for parameter '{}', which is not in the provided set of possible choices: {}\".format(\n                    value, self.name, self._choices\n                )\n            )\n        return (pretty, value)\n\n    @property\n    def name(self):\n        \"\"\"\n        Return the name of the parameter.\n\n        This is the name that can be used to set the parameter on the command-line\n        when running Lit.\n        \"\"\"\n        return self._name\n\n    def getActions(self, config, litParams):\n        \"\"\"\n        Return the list of actions associated to this value of the parameter.\n        \"\"\"\n        (_, parameterValue) = self._getValue(config, litParams)\n        return self._actions(parameterValue)\n\n    def pretty(self, config, litParams):\n        \"\"\"\n        Return a pretty representation of the parameter's name and value.\n        \"\"\"\n        (prettyParameterValue, _) = self._getValue(config, litParams)\n        return \"{}={}\".format(self.name, prettyParameterValue)\n"}, "/libcxx/utils/libcxx/test/format.py": {"changes": [{"diff": "\n     for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n         assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n \n-def _parseLitOutput(fullOutput):\n-    \"\"\"\n-    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n-\n-    This takes output of the form\n-\n-        $ \":\" \"RUN: at line 11\"\n-        $ \"echo\" \"OUTPUT1\"\n-        # command output:\n-        OUTPUT1\n-\n-        $ \":\" \"RUN: at line 12\"\n-        $ \"echo\" \"OUTPUT2\"\n-        # command output:\n-        OUTPUT2\n-\n-    and returns a string containing\n-\n-        OUTPUT1\n-        OUTPUT2\n-\n-    as-if the commands had been run directly. This is a workaround for the fact\n-    that Lit doesn't let us execute ShTest and retrieve the raw output without\n-    injecting additional Lit output around it.\n-    \"\"\"\n-    parsed = ''\n-    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n-        if output: # skip blank lines\n-            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n-            if commandOutput:\n-                parsed += commandOutput.group(1)\n-    return parsed\n-\n def _executeScriptInternal(test, litConfig, commands):\n     \"\"\"\n     Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n", "add": 0, "remove": 33, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["def _parseLitOutput(fullOutput):", "    \"\"\"", "    Parse output of a Lit ShTest to extract the actual output of the contained commands.", "    This takes output of the form", "        $ \":\" \"RUN: at line 11\"", "        $ \"echo\" \"OUTPUT1\"", "        OUTPUT1", "        $ \":\" \"RUN: at line 12\"", "        $ \"echo\" \"OUTPUT2\"", "        OUTPUT2", "    and returns a string containing", "        OUTPUT1", "        OUTPUT2", "    as-if the commands had been run directly. This is a workaround for the fact", "    that Lit doesn't let us execute ShTest and retrieve the raw output without", "    injecting additional Lit output around it.", "    \"\"\"", "    parsed = ''", "    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):", "        if output: # skip blank lines", "            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)", "            if commandOutput:", "                parsed += commandOutput.group(1)", "    return parsed"], "goodparts": []}, {"diff": "\n     _, tmpBase = _getTempPaths(test)\n     execDir = os.path.dirname(test.getExecPath())\n     res = lit.TestRunner.executeScriptInternal(\n-        test, litConfig, tmpBase, parsedCommands, execDir\n+        test, litConfig, tmpBase, parsedCommands, execDir, debug=False\n     )\n     if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n         res = (\"\", res.output, 127, None)\n     (out, err, exitCode, timeoutInfo) = res\n \n-    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n-    #       split any stderr output that is included in stdout. It shouldn't be there, but\n-    #       the Lit internal shell conflates stderr and stdout.\n-    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n-    if conflatedErrorOutput:\n-        conflatedErrorOutput = conflatedErrorOutput.group(0)\n-        out = out[: -len(conflatedErrorOutput)]\n-        err += conflatedErrorOutput\n-\n     return (out, err, exitCode, timeoutInfo, parsedCommands)\n \n \n", "add": 1, "remove": 10, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["        test, litConfig, tmpBase, parsedCommands, execDir", "    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)", "    if conflatedErrorOutput:", "        conflatedErrorOutput = conflatedErrorOutput.group(0)", "        out = out[: -len(conflatedErrorOutput)]", "        err += conflatedErrorOutput"], "goodparts": ["        test, litConfig, tmpBase, parsedCommands, execDir, debug=False"]}, {"diff": "\n             raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n \n         # Split the generated output into multiple files and generate one test for each file\n-        parsed = _parseLitOutput(out)\n-        for (subfile, content) in self._splitFile(parsed):\n+        for (subfile, content) in self._splitFile(out):\n             generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n             os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n             with open(generatedFile, 'w') as f", "add": 1, "remove": 2, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["        parsed = _parseLitOutput(out)", "        for (subfile, content) in self._splitFile(parsed):"], "goodparts": ["        for (subfile, content) in self._splitFile(out):"]}], "source": "\n import contextlib import io import lit import lit.formats import os import pipes import re import shutil def _getTempPaths(test): \"\"\" Return the values to use for the %T and %t substitutions, respectively. The difference between this and Lit's default behavior is that we guarantee that %T is a path unique to the test being run. \"\"\" tmpDir, _=lit.TestRunner.getTempPaths(test) _, testName=os.path.split(test.getExecPath()) tmpDir=os.path.join(tmpDir, testName +\".dir\") tmpBase=os.path.join(tmpDir, \"t\") return tmpDir, tmpBase def _checkBaseSubstitutions(substitutions): substitutions=[s for(s, _) in substitutions] for s in[\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]: assert s in substitutions, \"Required substitution{} was not provided\".format(s) def _parseLitOutput(fullOutput): \"\"\" Parse output of a Lit ShTest to extract the actual output of the contained commands. This takes output of the form $ \":\" \"RUN: at line 11\" $ \"echo\" \"OUTPUT1\" OUTPUT1 $ \":\" \"RUN: at line 12\" $ \"echo\" \"OUTPUT2\" OUTPUT2 and returns a string containing OUTPUT1 OUTPUT2 as-if the commands had been run directly. This is a workaround for the fact that Lit doesn't let us execute ShTest and retrieve the raw output without injecting additional Lit output around it. \"\"\" parsed='' for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput): if output: commandOutput=re.search(\" if commandOutput: parsed +=commandOutput.group(1) return parsed def _executeScriptInternal(test, litConfig, commands): \"\"\" Returns(stdout, stderr, exitCode, timeoutInfo, parsedCommands) TODO: This really should be easier to access from Lit itself \"\"\" parsedCommands=parseScript(test, preamble=commands) _, tmpBase=_getTempPaths(test) execDir=os.path.dirname(test.getExecPath()) res=lit.TestRunner.executeScriptInternal( test, litConfig, tmpBase, parsedCommands, execDir ) if isinstance(res, lit.Test.Result): res=(\"\", res.output, 127, None) (out, err, exitCode, timeoutInfo)=res conflatedErrorOutput=re.search(\"( if conflatedErrorOutput: conflatedErrorOutput=conflatedErrorOutput.group(0) out=out[: -len(conflatedErrorOutput)] err +=conflatedErrorOutput return(out, err, exitCode, timeoutInfo, parsedCommands) def parseScript(test, preamble): \"\"\" Extract the script from a test, with substitutions applied. Returns a list of commands ready to be executed. -test The lit.Test to parse. -preamble A list of commands to perform before any command in the test. These commands can contain unexpanded substitutions, but they must not be of the form 'RUN:' --they must be proper commands once substituted. \"\"\" tmpDir, tmpBase=_getTempPaths(test) substitutions=lit.TestRunner.getDefaultSubstitutions(test, tmpDir, tmpBase) _checkBaseSubstitutions(substitutions) substitutions.append( (\"%{build}\", \"%{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\") ) substitutions.append((\"%{run}\", \"%{exec} %t.exe\")) additionalCompileFlags=[] fileDependencies=[] parsers=[ lit.TestRunner.IntegratedTestKeywordParser( \"FILE_DEPENDENCIES:\", lit.TestRunner.ParserKind.LIST, initial_value=fileDependencies, ), lit.TestRunner.IntegratedTestKeywordParser( \"ADDITIONAL_COMPILE_FLAGS:\", lit.TestRunner.ParserKind.LIST, initial_value=additionalCompileFlags, ), ] for feature in test.config.available_features: parser=lit.TestRunner.IntegratedTestKeywordParser( \"ADDITIONAL_COMPILE_FLAGS({}):\".format(feature), lit.TestRunner.ParserKind.LIST, initial_value=additionalCompileFlags, ) parsers.append(parser) scriptInTest=lit.TestRunner.parseIntegratedTestScript( test, additional_parsers=parsers, require_script=not preamble ) if isinstance(scriptInTest, lit.Test.Result): return scriptInTest script=[] for dep in fileDependencies: script +=[\"%dbg(SETUP) cd %S && cp{} %T\".format(dep)] script +=preamble script +=scriptInTest substitutions=[ (s, x +\" \" +\" \".join(additionalCompileFlags)) if s==\"%{compile_flags}\" else(s, x) for(s, x) in substitutions ] script=lit.TestRunner.applySubstitutions( script, substitutions, recursion_limit=test.config.recursiveExpansionLimit ) return script class CxxStandardLibraryTest(lit.formats.FileBasedTest): \"\"\" Lit test format for the C++Standard Library conformance test suite. This test format is based on top of the ShTest format --it basically creates a shell script performing the right operations(compile/link/run) based on the extension of the test file it encounters. It supports files with the following extensions: FOO.pass.cpp -Compiles, links and runs successfully FOO.pass.mm -Same as.pass.cpp, but for Objective-C++ FOO.compile.pass.cpp -Compiles successfully, link and run not attempted FOO.compile.pass.mm -Same as.compile.pass.cpp, but for Objective-C++ FOO.compile.fail.cpp -Does not compile successfully FOO.link.pass.cpp -Compiles and links successfully, run not attempted FOO.link.pass.mm -Same as.link.pass.cpp, but for Objective-C++ FOO.link.fail.cpp -Compiles successfully, but fails to link FOO.sh.<anything> -A builtin Lit Shell test FOO.gen.<anything> -A.sh test that generates one or more Lit tests on the fly. Executing this test must generate one or more files as expected by LLVM split-file, and each generated file leads to a separate Lit test that runs that file as defined by the test format. This can be used to generate multiple Lit tests from a single source file, which is useful for testing repetitive properties in the library. Be careful not to abuse this since this is not a replacement for usual code reuse techniques. FOO.verify.cpp -Compiles with clang-verify. This type of test is automatically marked as UNSUPPORTED if the compiler does not support Clang-verify. Substitution requirements =============================== The test format operates by assuming that each test's configuration provides the following substitutions, which it will reuse in the shell scripts it constructs: %{cxx} -A command that can be used to invoke the compiler %{compile_flags} -Flags to use when compiling a test case %{link_flags} -Flags to use when linking a test case %{flags} -Flags to use either when compiling or linking a test case %{exec} -A command to prefix the execution of executables Note that when building an executable(as opposed to only compiling a source file), all three of %{flags}, %{compile_flags} and %{link_flags} will be used in the same command line. In other words, the test format doesn't perform separate compilation and linking steps in this case. Additional supported directives =============================== In addition to everything that's supported in Lit ShTests, this test format also understands the following directives inside test files: // FILE_DEPENDENCIES: file, directory, /path/to/file This directive expresses that the test requires the provided files or directories in order to run. An example is a test that requires some test input stored in a data file. When a test file contains such a directive, this test format will collect them and copy them to the directory represented by %T. The intent is that %T contains all the inputs necessary to run the test, such that e.g. execution on a remote host can be done by simply copying %T to the host. // ADDITIONAL_COMPILE_FLAGS: flag1, flag2, flag3 This directive will cause the provided flags to be added to the %{compile_flags} substitution for the test that contains it. This allows adding special compilation flags without having to use a .sh.cpp test, which would be more powerful but perhaps overkill. Additional provided substitutions and features ============================================== The test format will define the following substitutions for use inside tests: %{build} Expands to a command-line that builds the current source file with the %{flags}, %{compile_flags} and %{link_flags} substitutions, and that produces an executable named %t.exe. %{run} Equivalent to `%{exec} %t.exe`. This is intended to be used in conjunction with the %{build} substitution. \"\"\" def getTestsForPath(self, testSuite, pathInSuite, litConfig, localConfig): SUPPORTED_SUFFIXES=[ \"[.]pass[.]cpp$\", \"[.]pass[.]mm$\", \"[.]compile[.]pass[.]cpp$\", \"[.]compile[.]pass[.]mm$\", \"[.]compile[.]fail[.]cpp$\", \"[.]link[.]pass[.]cpp$\", \"[.]link[.]pass[.]mm$\", \"[.]link[.]fail[.]cpp$\", \"[.]sh[.][^.]+$\", \"[.]gen[.][^.]+$\", \"[.]verify[.]cpp$\", \"[.]fail[.]cpp$\", ] sourcePath=testSuite.getSourcePath(pathInSuite) filename=os.path.basename(sourcePath) hasSupportedSuffix=lambda f: any([re.search(ext, f) for ext in SUPPORTED_SUFFIXES]) if filename.startswith(\".\") or filename in localConfig.excludes or not hasSupportedSuffix(filename): return if re.search('[.]gen[.][^.]+$', filename): for test in self._generateGenTest(testSuite, pathInSuite, litConfig, localConfig): yield test else: yield lit.Test.Test(testSuite, pathInSuite, localConfig) def execute(self, test, litConfig): VERIFY_FLAGS=( \"-Xclang -verify -Xclang -verify-ignore-unexpected=note -ferror-limit=0\" ) supportsVerify=\"verify-support\" in test.config.available_features filename=test.path_in_suite[-1] if re.search(\"[.]sh[.][^.]+$\", filename): steps=[] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".compile.pass.cpp\") or filename.endswith( \".compile.pass.mm\" ): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".compile.fail.cpp\"): steps=[ \"%dbg(COMPILED WITH) ! %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".link.pass.cpp\") or filename.endswith(\".link.pass.mm\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".link.fail.cpp\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -c -o %t.o\", \"%dbg(LINKED WITH) ! %{cxx} %t.o %{flags} %{link_flags} -o %t.exe\", ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".verify.cpp\"): if not supportsVerify: return lit.Test.Result( lit.Test.UNSUPPORTED, \"Test{} requires support for Clang-verify, which isn't supported by the compiler\".format( test.getFullName() ), ) steps=[ \"%dbg(COMPILED WITH) %{{cxx}} %s %{{flags}} %{{compile_flags}} -fsyntax-only -Wno-error{}\".format( VERIFY_FLAGS ) ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".pass.cpp\") or filename.endswith(\".pass.mm\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\", \"%dbg(EXECUTED AS) %{exec} %t.exe\", ] return self._executeShTest(test, litConfig, steps) else: return lit.Test.Result( lit.Test.UNRESOLVED, \"Unknown test suffix for '{}'\".format(filename) ) def _executeShTest(self, test, litConfig, steps): if test.config.unsupported: return lit.Test.Result(lit.Test.UNSUPPORTED, \"Test is unsupported\") script=parseScript(test, steps) if isinstance(script, lit.Test.Result): return script if litConfig.noExecute: return lit.Test.Result( lit.Test.XFAIL if test.isExpectedToFail() else lit.Test.PASS ) else: _, tmpBase=_getTempPaths(test) useExternalSh=False return lit.TestRunner._runShTest( test, litConfig, useExternalSh, script, tmpBase ) def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig): generator=lit.Test.Test(testSuite, pathInSuite, localConfig) generatorExecDir=os.path.dirname(testSuite.getExecPath(pathInSuite)) os.makedirs(generatorExecDir, exist_ok=True) steps=[] (out, err, exitCode, _, _)=_executeScriptInternal(generator, litConfig, steps) if exitCode !=0: raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\") parsed=_parseLitOutput(out) for(subfile, content) in self._splitFile(parsed): generatedFile=testSuite.getExecPath(pathInSuite +(subfile,)) os.makedirs(os.path.dirname(generatedFile), exist_ok=True) with open(generatedFile, 'w') as f: f.write(content) yield lit.Test.Test(testSuite,(generatedFile,), localConfig) def _splitFile(self, input): DELIM=r'^(//| lines=input.splitlines() currentFile=None thisFileContent=[] for line in lines: match=re.match(DELIM, line) if match: if currentFile is not None: yield(currentFile, '\\n'.join(thisFileContent)) currentFile=match.group(2).strip() thisFileContent=[] assert currentFile is not None, f\"Some input to split-file doesn't belong to any file, input was:\\n{input}\" thisFileContent.append(line) if currentFile is not None: yield(currentFile, '\\n'.join(thisFileContent)) ", "sourceWithComments": "# ===----------------------------------------------------------------------===##\n#\n# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n# See https://llvm.org/LICENSE.txt for license information.\n# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n#\n# ===----------------------------------------------------------------------===##\n\nimport contextlib\nimport io\nimport lit\nimport lit.formats\nimport os\nimport pipes\nimport re\nimport shutil\n\n\ndef _getTempPaths(test):\n    \"\"\"\n    Return the values to use for the %T and %t substitutions, respectively.\n\n    The difference between this and Lit's default behavior is that we guarantee\n    that %T is a path unique to the test being run.\n    \"\"\"\n    tmpDir, _ = lit.TestRunner.getTempPaths(test)\n    _, testName = os.path.split(test.getExecPath())\n    tmpDir = os.path.join(tmpDir, testName + \".dir\")\n    tmpBase = os.path.join(tmpDir, \"t\")\n    return tmpDir, tmpBase\n\n\ndef _checkBaseSubstitutions(substitutions):\n    substitutions = [s for (s, _) in substitutions]\n    for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n        assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n\ndef _parseLitOutput(fullOutput):\n    \"\"\"\n    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n\n    This takes output of the form\n\n        $ \":\" \"RUN: at line 11\"\n        $ \"echo\" \"OUTPUT1\"\n        # command output:\n        OUTPUT1\n\n        $ \":\" \"RUN: at line 12\"\n        $ \"echo\" \"OUTPUT2\"\n        # command output:\n        OUTPUT2\n\n    and returns a string containing\n\n        OUTPUT1\n        OUTPUT2\n\n    as-if the commands had been run directly. This is a workaround for the fact\n    that Lit doesn't let us execute ShTest and retrieve the raw output without\n    injecting additional Lit output around it.\n    \"\"\"\n    parsed = ''\n    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n        if output: # skip blank lines\n            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n            if commandOutput:\n                parsed += commandOutput.group(1)\n    return parsed\n\ndef _executeScriptInternal(test, litConfig, commands):\n    \"\"\"\n    Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n\n    TODO: This really should be easier to access from Lit itself\n    \"\"\"\n    parsedCommands = parseScript(test, preamble=commands)\n\n    _, tmpBase = _getTempPaths(test)\n    execDir = os.path.dirname(test.getExecPath())\n    res = lit.TestRunner.executeScriptInternal(\n        test, litConfig, tmpBase, parsedCommands, execDir\n    )\n    if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n        res = (\"\", res.output, 127, None)\n    (out, err, exitCode, timeoutInfo) = res\n\n    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n    #       split any stderr output that is included in stdout. It shouldn't be there, but\n    #       the Lit internal shell conflates stderr and stdout.\n    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n    if conflatedErrorOutput:\n        conflatedErrorOutput = conflatedErrorOutput.group(0)\n        out = out[: -len(conflatedErrorOutput)]\n        err += conflatedErrorOutput\n\n    return (out, err, exitCode, timeoutInfo, parsedCommands)\n\n\ndef parseScript(test, preamble):\n    \"\"\"\n    Extract the script from a test, with substitutions applied.\n\n    Returns a list of commands ready to be executed.\n\n    - test\n        The lit.Test to parse.\n\n    - preamble\n        A list of commands to perform before any command in the test.\n        These commands can contain unexpanded substitutions, but they\n        must not be of the form 'RUN:' -- they must be proper commands\n        once substituted.\n    \"\"\"\n    # Get the default substitutions\n    tmpDir, tmpBase = _getTempPaths(test)\n    substitutions = lit.TestRunner.getDefaultSubstitutions(test, tmpDir, tmpBase)\n\n    # Check base substitutions and add the %{build} and %{run} convenience substitutions\n    _checkBaseSubstitutions(substitutions)\n    substitutions.append(\n        (\"%{build}\", \"%{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\")\n    )\n    substitutions.append((\"%{run}\", \"%{exec} %t.exe\"))\n\n    # Parse the test file, including custom directives\n    additionalCompileFlags = []\n    fileDependencies = []\n    parsers = [\n        lit.TestRunner.IntegratedTestKeywordParser(\n            \"FILE_DEPENDENCIES:\",\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=fileDependencies,\n        ),\n        lit.TestRunner.IntegratedTestKeywordParser(\n            \"ADDITIONAL_COMPILE_FLAGS:\",\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=additionalCompileFlags,\n        ),\n    ]\n\n    # Add conditional parsers for ADDITIONAL_COMPILE_FLAGS. This should be replaced by first\n    # class support for conditional keywords in Lit, which would allow evaluating arbitrary\n    # Lit boolean expressions instead.\n    for feature in test.config.available_features:\n        parser = lit.TestRunner.IntegratedTestKeywordParser(\n            \"ADDITIONAL_COMPILE_FLAGS({}):\".format(feature),\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=additionalCompileFlags,\n        )\n        parsers.append(parser)\n\n    scriptInTest = lit.TestRunner.parseIntegratedTestScript(\n        test, additional_parsers=parsers, require_script=not preamble\n    )\n    if isinstance(scriptInTest, lit.Test.Result):\n        return scriptInTest\n\n    script = []\n\n    # For each file dependency in FILE_DEPENDENCIES, inject a command to copy\n    # that file to the execution directory. Execute the copy from %S to allow\n    # relative paths from the test directory.\n    for dep in fileDependencies:\n        script += [\"%dbg(SETUP) cd %S && cp {} %T\".format(dep)]\n    script += preamble\n    script += scriptInTest\n\n    # Add compile flags specified with ADDITIONAL_COMPILE_FLAGS.\n    substitutions = [\n        (s, x + \" \" + \" \".join(additionalCompileFlags))\n        if s == \"%{compile_flags}\"\n        else (s, x)\n        for (s, x) in substitutions\n    ]\n\n    # Perform substitutions in the script itself.\n    script = lit.TestRunner.applySubstitutions(\n        script, substitutions, recursion_limit=test.config.recursiveExpansionLimit\n    )\n\n    return script\n\n\nclass CxxStandardLibraryTest(lit.formats.FileBasedTest):\n    \"\"\"\n    Lit test format for the C++ Standard Library conformance test suite.\n\n    This test format is based on top of the ShTest format -- it basically\n    creates a shell script performing the right operations (compile/link/run)\n    based on the extension of the test file it encounters. It supports files\n    with the following extensions:\n\n    FOO.pass.cpp            - Compiles, links and runs successfully\n    FOO.pass.mm             - Same as .pass.cpp, but for Objective-C++\n\n    FOO.compile.pass.cpp    - Compiles successfully, link and run not attempted\n    FOO.compile.pass.mm     - Same as .compile.pass.cpp, but for Objective-C++\n    FOO.compile.fail.cpp    - Does not compile successfully\n\n    FOO.link.pass.cpp       - Compiles and links successfully, run not attempted\n    FOO.link.pass.mm        - Same as .link.pass.cpp, but for Objective-C++\n    FOO.link.fail.cpp       - Compiles successfully, but fails to link\n\n    FOO.sh.<anything>       - A builtin Lit Shell test\n\n    FOO.gen.<anything>      - A .sh test that generates one or more Lit tests on the\n                              fly. Executing this test must generate one or more files\n                              as expected by LLVM split-file, and each generated file\n                              leads to a separate Lit test that runs that file as\n                              defined by the test format. This can be used to generate\n                              multiple Lit tests from a single source file, which is\n                              useful for testing repetitive properties in the library.\n                              Be careful not to abuse this since this is not a replacement\n                              for usual code reuse techniques.\n\n    FOO.verify.cpp          - Compiles with clang-verify. This type of test is\n                              automatically marked as UNSUPPORTED if the compiler\n                              does not support Clang-verify.\n\n\n    Substitution requirements\n    ===============================\n    The test format operates by assuming that each test's configuration provides\n    the following substitutions, which it will reuse in the shell scripts it\n    constructs:\n        %{cxx}           - A command that can be used to invoke the compiler\n        %{compile_flags} - Flags to use when compiling a test case\n        %{link_flags}    - Flags to use when linking a test case\n        %{flags}         - Flags to use either when compiling or linking a test case\n        %{exec}          - A command to prefix the execution of executables\n\n    Note that when building an executable (as opposed to only compiling a source\n    file), all three of %{flags}, %{compile_flags} and %{link_flags} will be used\n    in the same command line. In other words, the test format doesn't perform\n    separate compilation and linking steps in this case.\n\n\n    Additional supported directives\n    ===============================\n    In addition to everything that's supported in Lit ShTests, this test format\n    also understands the following directives inside test files:\n\n        // FILE_DEPENDENCIES: file, directory, /path/to/file\n\n            This directive expresses that the test requires the provided files\n            or directories in order to run. An example is a test that requires\n            some test input stored in a data file. When a test file contains\n            such a directive, this test format will collect them and copy them\n            to the directory represented by %T. The intent is that %T contains\n            all the inputs necessary to run the test, such that e.g. execution\n            on a remote host can be done by simply copying %T to the host.\n\n        // ADDITIONAL_COMPILE_FLAGS: flag1, flag2, flag3\n\n            This directive will cause the provided flags to be added to the\n            %{compile_flags} substitution for the test that contains it. This\n            allows adding special compilation flags without having to use a\n            .sh.cpp test, which would be more powerful but perhaps overkill.\n\n\n    Additional provided substitutions and features\n    ==============================================\n    The test format will define the following substitutions for use inside tests:\n\n        %{build}\n            Expands to a command-line that builds the current source\n            file with the %{flags}, %{compile_flags} and %{link_flags}\n            substitutions, and that produces an executable named %t.exe.\n\n        %{run}\n            Equivalent to `%{exec} %t.exe`. This is intended to be used\n            in conjunction with the %{build} substitution.\n    \"\"\"\n\n    def getTestsForPath(self, testSuite, pathInSuite, litConfig, localConfig):\n        SUPPORTED_SUFFIXES = [\n            \"[.]pass[.]cpp$\",\n            \"[.]pass[.]mm$\",\n            \"[.]compile[.]pass[.]cpp$\",\n            \"[.]compile[.]pass[.]mm$\",\n            \"[.]compile[.]fail[.]cpp$\",\n            \"[.]link[.]pass[.]cpp$\",\n            \"[.]link[.]pass[.]mm$\",\n            \"[.]link[.]fail[.]cpp$\",\n            \"[.]sh[.][^.]+$\",\n            \"[.]gen[.][^.]+$\",\n            \"[.]verify[.]cpp$\",\n            \"[.]fail[.]cpp$\",\n        ]\n\n        sourcePath = testSuite.getSourcePath(pathInSuite)\n        filename = os.path.basename(sourcePath)\n\n        # Ignore dot files, excluded tests and tests with an unsupported suffix\n        hasSupportedSuffix = lambda f: any([re.search(ext, f) for ext in SUPPORTED_SUFFIXES])\n        if filename.startswith(\".\") or filename in localConfig.excludes or not hasSupportedSuffix(filename):\n            return\n\n        # If this is a generated test, run the generation step and add\n        # as many Lit tests as necessary.\n        if re.search('[.]gen[.][^.]+$', filename):\n            for test in self._generateGenTest(testSuite, pathInSuite, litConfig, localConfig):\n                yield test\n        else:\n            yield lit.Test.Test(testSuite, pathInSuite, localConfig)\n\n    def execute(self, test, litConfig):\n        VERIFY_FLAGS = (\n            \"-Xclang -verify -Xclang -verify-ignore-unexpected=note -ferror-limit=0\"\n        )\n        supportsVerify = \"verify-support\" in test.config.available_features\n        filename = test.path_in_suite[-1]\n\n        if re.search(\"[.]sh[.][^.]+$\", filename):\n            steps = []  # The steps are already in the script\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".compile.pass.cpp\") or filename.endswith(\n            \".compile.pass.mm\"\n        ):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".compile.fail.cpp\"):\n            steps = [\n                \"%dbg(COMPILED WITH) ! %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".link.pass.cpp\") or filename.endswith(\".link.pass.mm\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".link.fail.cpp\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -c -o %t.o\",\n                \"%dbg(LINKED WITH) ! %{cxx} %t.o %{flags} %{link_flags} -o %t.exe\",\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".verify.cpp\"):\n            if not supportsVerify:\n                return lit.Test.Result(\n                    lit.Test.UNSUPPORTED,\n                    \"Test {} requires support for Clang-verify, which isn't supported by the compiler\".format(\n                        test.getFullName()\n                    ),\n                )\n            steps = [\n                # Note: Use -Wno-error to make sure all diagnostics are not treated as errors,\n                #       which doesn't make sense for clang-verify tests.\n                \"%dbg(COMPILED WITH) %{{cxx}} %s %{{flags}} %{{compile_flags}} -fsyntax-only -Wno-error {}\".format(\n                    VERIFY_FLAGS\n                )\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        # Make sure to check these ones last, since they will match other\n        # suffixes above too.\n        elif filename.endswith(\".pass.cpp\") or filename.endswith(\".pass.mm\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\",\n                \"%dbg(EXECUTED AS) %{exec} %t.exe\",\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        else:\n            return lit.Test.Result(\n                lit.Test.UNRESOLVED, \"Unknown test suffix for '{}'\".format(filename)\n            )\n\n    def _executeShTest(self, test, litConfig, steps):\n        if test.config.unsupported:\n            return lit.Test.Result(lit.Test.UNSUPPORTED, \"Test is unsupported\")\n\n        script = parseScript(test, steps)\n        if isinstance(script, lit.Test.Result):\n            return script\n\n        if litConfig.noExecute:\n            return lit.Test.Result(\n                lit.Test.XFAIL if test.isExpectedToFail() else lit.Test.PASS\n            )\n        else:\n            _, tmpBase = _getTempPaths(test)\n            useExternalSh = False\n            return lit.TestRunner._runShTest(\n                test, litConfig, useExternalSh, script, tmpBase\n            )\n\n    def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig):\n        generator = lit.Test.Test(testSuite, pathInSuite, localConfig)\n\n        # Make sure we have a directory to execute the generator test in\n        generatorExecDir = os.path.dirname(testSuite.getExecPath(pathInSuite))\n        os.makedirs(generatorExecDir, exist_ok=True)\n\n        # Run the generator test\n        steps = [] # Steps must already be in the script\n        (out, err, exitCode, _, _) = _executeScriptInternal(generator, litConfig, steps)\n        if exitCode != 0:\n            raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n\n        # Split the generated output into multiple files and generate one test for each file\n        parsed = _parseLitOutput(out)\n        for (subfile, content) in self._splitFile(parsed):\n            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n            os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n            with open(generatedFile, 'w') as f:\n                f.write(content)\n            yield lit.Test.Test(testSuite, (generatedFile,), localConfig)\n\n    def _splitFile(self, input):\n        DELIM = r'^(//|#)---(.+)'\n        lines = input.splitlines()\n        currentFile = None\n        thisFileContent = []\n        for line in lines:\n            match = re.match(DELIM, line)\n            if match:\n                if currentFile is not None:\n                    yield (currentFile, '\\n'.join(thisFileContent))\n                currentFile = match.group(2).strip()\n                thisFileContent = []\n            assert currentFile is not None, f\"Some input to split-file doesn't belong to any file, input was:\\n{input}\"\n            thisFileContent.append(line)\n        if currentFile is not None:\n            yield (currentFile, '\\n'.join(thisFileContent))\n"}, "/llvm/utils/lit/lit/TestRunner.py": {"changes": [{"diff": "\n \n \n def executeBuiltinEcho(cmd, shenv):\n-    \"\"\"Interpret a redirected echo command\"\"\"\n+    \"\"\"Interpret a redirected echo or @echo command\"\"\"\n     opened_files = []\n     stdin, stdout, stderr = processRedirects(cmd, subprocess.PIPE, shenv, opened_files)\n     if stdin != subprocess.PIPE or stderr != subprocess.PIPE:\n         raise InternalShellError(\n-            cmd, \"stdin and stderr redirects not supported for echo\"\n+            cmd, f\"stdin and stderr redirects not supported for {cmd.args[0]}\"\n         )\n \n     # Some tests have un-redirected echo commands to help debug test failures.\n", "add": 2, "remove": 2, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["    \"\"\"Interpret a redirected echo command\"\"\"", "            cmd, \"stdin and stderr redirects not supported for echo\""], "goodparts": ["    \"\"\"Interpret a redirected echo or @echo command\"\"\"", "            cmd, f\"stdin and stderr redirects not supported for {cmd.args[0]}\""]}, {"diff": "\n         if res == -signal.SIGINT:\n             raise KeyboardInterrupt\n         if proc_not_counts[i] % 2:\n-            res = not res\n+            res = 1 if res == 0 else 0\n         elif proc_not_counts[i] > 1:\n             res = 1 if res != 0 else 0\n \n", "add": 1, "remove": 1, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["            res = not res"], "goodparts": ["            res = 1 if res == 0 else 0"]}, {"diff": "\n     return exitCode\n \n \n-def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n+def formatOutput(title, data, limit=None):\n+    if not data.strip():\n+        return \"\"\n+    if not limit is None and len(data) > limit:\n+        data = data[:limit] + \"\\n...\\n\"\n+        msg = \"data was truncated\"\n+    else:\n+        msg = \"\"\n+    ndashes = 30\n+    out =  f\"# .---{title}{'-' * (ndashes - 4 - len(title))}\\n\"\n+    out += f\"# | \" + \"\\n# | \".join(data.splitlines()) + \"\\n\"\n+    out += f\"# `---{msg}{'-' * (ndashes - 4 - len(msg))}\\n\"\n+    return out\n+\n+# Normally returns out, err, exitCode, timeoutInfo.\n+#\n+# If debug is True (the normal lit behavior), err is empty, and out contains an\n+# execution trace, including stdout and stderr shown per command executed.\n+#\n+# If debug is False (set by some custom lit test formats that call this\n+# function), out contains only stdout from the script, err contains only stderr\n+# from the script, and there is no execution trace.\n+def executeScriptInternal(test, litConfig, tmpBase, commands, cwd,\n+                          debug=True):\n     cmds = []\n     for i, ln in enumerate(commands):\n+        # Within lit, we try to always add '%dbg(...)' to command lines in order\n+        # to maximize debuggability.  However, custom lit test formats might not\n+        # always add it, so add a generic debug message in that case.\n         match = re.match(kPdbgRegex, ln)\n         if match:\n+            dbg = match.group(1)\n             command = match.group(2)\n-            ln = commands[i] = match.expand(\": '\\\\1'; \\\\2\" if command else \": '\\\\1'\")\n+        else:\n+            dbg = \"command line\"\n+            command = ln\n+        if debug:\n+            ln = f\"@echo '# {dbg}' \"\n+            if command:\n+                ln += f\"&& @echo {shlex.quote(command.lstrip())} && {command}\"\n+            else:\n+                ln += \"has no command after substitutions\"\n+        else:\n+            ln = command\n         try:\n             cmds.append(\n                 ShUtil.ShParser(ln, litConfig.isWindows, test.config.pipefail).parse()\n             )\n         except:\n-            return lit.Test.Result(Test.FAIL, \"shell parser error on: %r\" % ln)\n+            return lit.Test.Result(\n+                Test.FAIL, f\"shell parser error on {dbg}: {command.lstrip()}\\n\"\n+            )\n \n     cmd = cmds[0]\n     for c in cmds[1:]:\n", "add": 42, "remove": 3, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):", "            ln = commands[i] = match.expand(\": '\\\\1'; \\\\2\" if command else \": '\\\\1'\")", "            return lit.Test.Result(Test.FAIL, \"shell parser error on: %r\" % ln)"], "goodparts": ["def formatOutput(title, data, limit=None):", "    if not data.strip():", "        return \"\"", "    if not limit is None and len(data) > limit:", "        data = data[:limit] + \"\\n...\\n\"", "        msg = \"data was truncated\"", "    else:", "        msg = \"\"", "    ndashes = 30", "    out =  f\"# .---{title}{'-' * (ndashes - 4 - len(title))}\\n\"", "    out += f\"# | \" + \"\\n# | \".join(data.splitlines()) + \"\\n\"", "    out += f\"# `---{msg}{'-' * (ndashes - 4 - len(msg))}\\n\"", "    return out", "def executeScriptInternal(test, litConfig, tmpBase, commands, cwd,", "                          debug=True):", "            dbg = match.group(1)", "        else:", "            dbg = \"command line\"", "            command = ln", "        if debug:", "            ln = f\"@echo '# {dbg}' \"", "            if command:", "                ln += f\"&& @echo {shlex.quote(command.lstrip())} && {command}\"", "            else:", "                ln += \"has no command after substitutions\"", "        else:", "            ln = command", "            return lit.Test.Result(", "                Test.FAIL, f\"shell parser error on {dbg}: {command.lstrip()}\\n\"", "            )"]}, {"diff": "\n \n     out = err = \"\"\n     for i, result in enumerate(results):\n-        # Write the command line run.\n-        out += \"$ %s\\n\" % (\" \".join('\"%s\"' % s for s in result.command.args),)\n+        if not debug:\n+            out += result.stdout\n+            err += result.stderr\n+            continue\n+\n+        # The purpose of an \"@echo\" command is merely to add a debugging message\n+        # directly to lit's output.  It is used internally by lit's internal\n+        # shell and is not currently documented for use in lit tests.  However,\n+        # if someone misuses it (e.g., both \"echo\" and \"@echo\" complain about\n+        # stdin redirection), produce the normal execution trace to facilitate\n+        # debugging.\n+        if (\n+            result.command.args[0] == \"@echo\"\n+            and result.exitCode == 0\n+            and not result.stderr\n+            and not result.outputFiles\n+            and not result.timeoutReached\n+        ):\n+            out += result.stdout\n+            continue\n+\n+        # Write the command line that was run.  Properly quote it.  Leading\n+        # \"!\" commands should not be quoted as that would indicate they are not\n+        # the builtins.\n+        out += \"# executed command: \"\n+        nLeadingBangs = next(\n+            (i for i, cmd in enumerate(result.command.args) if cmd != \"!\"),\n+            len(result.command.args),\n+        )\n+        out += \"! \" * nLeadingBangs\n+        out += \" \".join(\n+            shlex.quote(str(s))\n+            for i, s in enumerate(result.command.args)\n+            if i >= nLeadingBangs\n+        )\n+        out += \"\\n\"\n \n         # If nothing interesting happened, move on.\n         if (\n", "add": 36, "remove": 2, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["        out += \"$ %s\\n\" % (\" \".join('\"%s\"' % s for s in result.command.args),)"], "goodparts": ["        if not debug:", "            out += result.stdout", "            err += result.stderr", "            continue", "        if (", "            result.command.args[0] == \"@echo\"", "            and result.exitCode == 0", "            and not result.stderr", "            and not result.outputFiles", "            and not result.timeoutReached", "        ):", "            out += result.stdout", "            continue", "        out += \"# executed command: \"", "        nLeadingBangs = next(", "            (i for i, cmd in enumerate(result.command.args) if cmd != \"!\"),", "            len(result.command.args),", "        )", "        out += \"! \" * nLeadingBangs", "        out += \" \".join(", "            shlex.quote(str(s))", "            for i, s in enumerate(result.command.args)", "            if i >= nLeadingBangs", "        )", "        out += \"\\n\""]}, {"diff": "\n \n         # Add the command output, if redirected.\n         for (name, path, data) in result.outputFiles:\n-            if data.strip():\n-                out += \"# redirected output from %r:\\n\" % (name,)\n-                data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n-                if len(data) > 1024:\n-                    out += data[:1024] + \"\\n...\\n\"\n-                    out += \"note: data was truncated\\n\"\n-                else:\n-                    out += data\n-                out += \"\\n\"\n-\n+            data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n+            out += formatOutput(\n+                f\"redirected output from '{name}'\", data, limit=1024\n+            )\n         if result.stdout.strip():\n-            out += \"# command output:\\n%s\\n\" % (result.stdout,)\n+            out += formatOutput(\"command stdout\", result.stdout)\n         if result.stderr.strip():\n-            out += \"# command stderr:\\n%s\\n\" % (result.stderr,)\n+            out += formatOutput(\"command stderr\", result.stderr)\n         if not result.stdout.strip() and not result.stderr.strip():\n-            out += \"note: command had no output on stdout or stderr\\n\"\n+            out += \"# note: command had no output on stdout or stderr\\n\"\n \n         # Show the error conditions:\n         if result.exitCode != 0:\n", "add": 7, "remove": 13, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["            if data.strip():", "                out += \"# redirected output from %r:\\n\" % (name,)", "                data = to_string(data.decode(\"utf-8\", errors=\"replace\"))", "                if len(data) > 1024:", "                    out += data[:1024] + \"\\n...\\n\"", "                    out += \"note: data was truncated\\n\"", "                else:", "                    out += data", "                out += \"\\n\"", "            out += \"# command output:\\n%s\\n\" % (result.stdout,)", "            out += \"# command stderr:\\n%s\\n\" % (result.stderr,)", "            out += \"note: command had no output on stdout or stderr\\n\""], "goodparts": ["            data = to_string(data.decode(\"utf-8\", errors=\"replace\"))", "            out += formatOutput(", "                f\"redirected output from '{name}'\", data, limit=1024", "            )", "            out += formatOutput(\"command stdout\", result.stdout)", "            out += formatOutput(\"command stderr\", result.stderr)", "            out += \"# note: command had no output on stdout or stderr\\n\""]}, {"diff": "\n                 codeStr = hex(int(result.exitCode & 0xFFFFFFFF)).rstrip(\"L\")\n             else:\n                 codeStr = str(result.exitCode)\n-            out += \"error: command failed with exit status: %s\\n\" % (codeStr,)\n+            out += \"# error: command failed with exit status: %s\\n\" % (codeStr,)\n         if litConfig.maxIndividualTestTime > 0 and result.timeoutReached:\n-            out += \"error: command reached timeout: %s\\n\" % (\n+            out += \"# error: command reached timeout: %s\\n\" % (\n                 str(result.timeoutReached),\n             )\n \n", "add": 2, "remove": 2, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["            out += \"error: command failed with exit status: %s\\n\" % (codeStr,)", "            out += \"error: command reached timeout: %s\\n\" % ("], "goodparts": ["            out += \"# error: command failed with exit status: %s\\n\" % (codeStr,)", "            out += \"# error: command reached timeout: %s\\n\" % ("]}, {"diff": "\n         if not output or not output[-1].add_continuation(line_number, keyword, line):\n             if output is None:\n                 output = []\n-            pdbg = \"%dbg({keyword} at line {line_number})\".format(\n-                keyword=keyword, line_number=line_number\n-            )\n-            assert re.match(\n-                kPdbgRegex + \"$\", pdbg\n-            ), \"kPdbgRegex expected to match actual %dbg usage\"\n-            line = \"{pdbg} {real_command}\".format(pdbg=pdbg, real_command=line)\n+            line = buildPdbgCommand(f\"{keyword} at line {line_number}\", line)\n             output.append(CommandDirective(line_number, line_number, keyword, line))\n         return output\n \n", "add": 1, "remove": 7, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["            pdbg = \"%dbg({keyword} at line {line_number})\".format(", "                keyword=keyword, line_number=line_number", "            )", "            assert re.match(", "                kPdbgRegex + \"$\", pdbg", "            ), \"kPdbgRegex expected to match actual %dbg usage\"", "            line = \"{pdbg} {real_command}\".format(pdbg=pdbg, real_command=line)"], "goodparts": ["            line = buildPdbgCommand(f\"{keyword} at line {line_number}\", line)"]}]}}, "msg": "[lit] Improve test output from lit's internal shell\n\nThis patch and D154984 were discussed in\n<https://discourse.llvm.org/t/rfc-improving-lits-debug-output/72839>.\n\nMotivation\n----------\n\nD154984 removes the \"Script:\" section that lit prints along with a\ntest's output, and it makes -v and -a imply -vv.  For example, after\nD154984, the \"Script:\" section below is never shown, but -v is enough\nto produce the execution trace following it:\n\n```\n Script:\n --\n : 'RUN: at line 1'; echo hello | FileCheck bogus.txt && echo success\n --\n Exit Code: 2\n\n Command Output (stdout):\n --\n $ \":\" \"RUN: at line 1\"\n $ \"echo\" \"hello\"\n # command output:\n hello\n\n $ \"FileCheck\" \"bogus.txt\"\n # command stderr:\n Could not open check file 'bogus.txt': No such file or directory\n\n error: command failed with exit status: 2\n\n --\n```\n\nIn the D154984 review, some reviewers point out that they have been\nusing the \"Script:\" section for copying and pasting a test's shell\ncommands to a terminal window.  The shell commands as printed in the\nexecution trace can be harder to copy and paste for the following\nreasons:\n\n- They drop redirections and break apart RUN lines at `&&`, `|`, etc.\n- They add `$` at the start of every command, which makes it hard to\n  copy and paste multiple commands in bulk.\n- Command stdout, stderr, etc. are interleaved with the commands and\n  are not clearly delineated.\n- They don't always use proper shell quoting.  Instead, they blindly\n  enclose all command-line arguments in double quotes.\n\nChanges\n-------\n\nD154984 plus this patch converts the above example into:\n\n```\n Exit Code: 2\n\n Command Output (stdout):\n --\n # RUN: at line 1\n echo hello | FileCheck bogus-file.txt && echo success\n # executed command: echo hello\n # .---command stdout------------\n # | hello\n # `-----------------------------\n # executed command: FileCheck bogus-file.txt\n # .---command stderr------------\n # | Could not open check file 'bogus-file.txt': No such file or directory\n # `-----------------------------\n # error: command failed with exit status: 2\n\n --\n```\n\nThus, this patch addresses the above issues as follows:\n\n- The entire execution trace can be copied and pasted in bulk to a\n  terminal for correct execution of the RUN lines, which are printed\n  intact as they appeared in the original RUN lines except lit\n  substitutions are expanded.  Everything else in the execution trace\n  appears in shell comments so it has no effect in a terminal.\n- Each of the RUN line's commands is repeated (in shell comments) as\n  it executes to show (1) that the command actually executed (e.g.,\n  `echo success` above didn't) and (2) what stdout, stderr, non-zero\n  exit status, and output files are associated with the command, if\n  any.  Shell quoting in the command is now correct and minimal but is\n  not necessarily the original shell quoting from the RUN line.\n- The start and end of the contents of stdout, stderr, or an output\n  file is now delineated clearly in the trace.\n\nTo help produce some of the above output, this patch extends lit's\ninternal shell with a built-in `@echo` command.  It's like `echo`\nexcept lit suppresses the normal execution trace for `@echo` and just\nprints its stdout directly.  For now, `@echo` isn't documented for use\nin lit tests.\n\nWithout this patch, libcxx's custom lit test format tries to parse the\nstdout from `lit.TestRunner.executeScriptInternal` (which runs lit's\ninternal shell) to extract the stdout and stderr produced by shell\ncommands, and that parse no longer works after the above changes.\nThis patch makes a small adjustment to\n`lit.TestRunner.executeScriptInternal` so libcxx can just request\nstdout and stderr without an execution trace.\n\n(As a minor drive-by fix that came up in testing: lit's internal `not`\ncommand now always produces a numeric exit status and never `True`.)\n\nCaveat\n------\n\nThis patch only makes the above changes for lit's internal shell.  In\nmost cases, we do not know how to force external shells (e.g., bash,\nsh, window's `cmd`) to produce execution traces in the manner we want.\n\nTo configure a test suite to use lit's internal shell (which is\nusually better for test portability than external shells anyway), add\nthis to the test suite's `lit.cfg` or other configuration file:\n\n```\nconfig.test_format = lit.formats.ShTest(execute_external=False)\n```\n\nReviewed By: MaskRay, awarzynski\n\nDifferential Revision: https://reviews.llvm.org/D156954"}, "f223022a4c521296a6d058862d66443ab9e355bf": {"url": "https://api.github.com/repos/MIPS/llvm/commits/f223022a4c521296a6d058862d66443ab9e355bf", "html_url": "https://github.com/MIPS/llvm/commit/f223022a4c521296a6d058862d66443ab9e355bf", "sha": "f223022a4c521296a6d058862d66443ab9e355bf", "keyword": "execution after redirect correct", "diff": "diff --git a/libcxx/utils/libcxx/test/dsl.py b/libcxx/utils/libcxx/test/dsl.py\nindex d2e0c6036dd3..5d4ca83be130 100644\n--- a/libcxx/utils/libcxx/test/dsl.py\n+++ b/libcxx/utils/libcxx/test/dsl.py\n@@ -186,7 +186,7 @@ def programOutput(config, program, args=None):\n                 \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n             )\n \n-        return libcxx.test.format._parseLitOutput(out)\n+        return out\n \n \n @_memoizeExpensiveOperation(\ndiff --git a/libcxx/utils/libcxx/test/format.py b/libcxx/utils/libcxx/test/format.py\nindex ddd88f25646e..c7c0bad681dd 100644\n--- a/libcxx/utils/libcxx/test/format.py\n+++ b/libcxx/utils/libcxx/test/format.py\n@@ -35,39 +35,6 @@ def _checkBaseSubstitutions(substitutions):\n     for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n         assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n \n-def _parseLitOutput(fullOutput):\n-    \"\"\"\n-    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n-\n-    This takes output of the form\n-\n-        $ \":\" \"RUN: at line 11\"\n-        $ \"echo\" \"OUTPUT1\"\n-        # command output:\n-        OUTPUT1\n-\n-        $ \":\" \"RUN: at line 12\"\n-        $ \"echo\" \"OUTPUT2\"\n-        # command output:\n-        OUTPUT2\n-\n-    and returns a string containing\n-\n-        OUTPUT1\n-        OUTPUT2\n-\n-    as-if the commands had been run directly. This is a workaround for the fact\n-    that Lit doesn't let us execute ShTest and retrieve the raw output without\n-    injecting additional Lit output around it.\n-    \"\"\"\n-    parsed = ''\n-    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n-        if output: # skip blank lines\n-            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n-            if commandOutput:\n-                parsed += commandOutput.group(1)\n-    return parsed\n-\n def _executeScriptInternal(test, litConfig, commands):\n     \"\"\"\n     Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n@@ -79,21 +46,12 @@ def _executeScriptInternal(test, litConfig, commands):\n     _, tmpBase = _getTempPaths(test)\n     execDir = os.path.dirname(test.getExecPath())\n     res = lit.TestRunner.executeScriptInternal(\n-        test, litConfig, tmpBase, parsedCommands, execDir\n+        test, litConfig, tmpBase, parsedCommands, execDir, debug=False\n     )\n     if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n         res = (\"\", res.output, 127, None)\n     (out, err, exitCode, timeoutInfo) = res\n \n-    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n-    #       split any stderr output that is included in stdout. It shouldn't be there, but\n-    #       the Lit internal shell conflates stderr and stdout.\n-    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n-    if conflatedErrorOutput:\n-        conflatedErrorOutput = conflatedErrorOutput.group(0)\n-        out = out[: -len(conflatedErrorOutput)]\n-        err += conflatedErrorOutput\n-\n     return (out, err, exitCode, timeoutInfo, parsedCommands)\n \n \n@@ -400,9 +358,8 @@ def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig):\n             raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n \n         # Split the generated output into multiple files and generate one test for each file\n-        parsed = _parseLitOutput(out)\n-        for (subfile, content) in self._splitFile(parsed):\n-            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n+        for subfile, content in self._splitFile(out):\n+            generatedFile = testSuite.getExecPath(pathInSuite + (subfile,))\n             os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n             with open(generatedFile, 'w') as f:\n                 f.write(content)\ndiff --git a/llvm/docs/CommandGuide/lit.rst b/llvm/docs/CommandGuide/lit.rst\nindex b494c74889aa..5e2443cb612a 100644\n--- a/llvm/docs/CommandGuide/lit.rst\n+++ b/llvm/docs/CommandGuide/lit.rst\n@@ -96,10 +96,9 @@ OUTPUT OPTIONS\n \n  Each command is printed before it is executed. This can be valuable for\n  debugging test failures, as the last printed command is the one that failed.\n- Moreover, :program:`lit` inserts a no-op command (``:`` in the case of bash)\n- with argument ``'RUN: at line N'`` before each command pipeline, and those\n- no-op commands are also printed to help you locate the source line of the\n- failed command.\n+ Moreover, :program:`lit` inserts ``'RUN: at line N'`` before each\n+ command pipeline in the output to help you locate the source line of\n+ the failed command.\n \n .. option:: -vv, --echo-all-commands\n \ndiff --git a/llvm/utils/lit/lit/TestRunner.py b/llvm/utils/lit/lit/TestRunner.py\nindex 0539b280a176..f85627eaf3de 100644\n--- a/llvm/utils/lit/lit/TestRunner.py\n+++ b/llvm/utils/lit/lit/TestRunner.py\n@@ -8,6 +8,7 @@\n import stat\n import pathlib\n import platform\n+import shlex\n import shutil\n import tempfile\n import threading\n@@ -348,12 +349,12 @@ def executeBuiltinExport(cmd, shenv):\n \n \n def executeBuiltinEcho(cmd, shenv):\n-    \"\"\"Interpret a redirected echo command\"\"\"\n+    \"\"\"Interpret a redirected echo or @echo command\"\"\"\n     opened_files = []\n     stdin, stdout, stderr = processRedirects(cmd, subprocess.PIPE, shenv, opened_files)\n     if stdin != subprocess.PIPE or stderr != subprocess.PIPE:\n         raise InternalShellError(\n-            cmd, \"stdin and stderr redirects not supported for echo\"\n+            cmd, f\"stdin and stderr redirects not supported for {cmd.args[0]}\"\n         )\n \n     # Some tests have un-redirected echo commands to help debug test failures.\n@@ -700,6 +701,7 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n         \"cd\": executeBuiltinCd,\n         \"export\": executeBuiltinExport,\n         \"echo\": executeBuiltinEcho,\n+        \"@echo\": executeBuiltinEcho,\n         \"mkdir\": executeBuiltinMkdir,\n         \"popd\": executeBuiltinPopd,\n         \"pushd\": executeBuiltinPushd,\n@@ -927,7 +929,7 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n         if res == -signal.SIGINT:\n             raise KeyboardInterrupt\n         if proc_not_counts[i] % 2:\n-            res = not res\n+            res = 1 if res == 0 else 0\n         elif proc_not_counts[i] > 1:\n             res = 1 if res != 0 else 0\n \n@@ -990,19 +992,60 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n     return exitCode\n \n \n-def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n+def formatOutput(title, data, limit=None):\n+    if not data.strip():\n+        return \"\"\n+    if not limit is None and len(data) > limit:\n+        data = data[:limit] + \"\\n...\\n\"\n+        msg = \"data was truncated\"\n+    else:\n+        msg = \"\"\n+    ndashes = 30\n+    # fmt: off\n+    out =  f\"# .---{title}{'-' * (ndashes - 4 - len(title))}\\n\"\n+    out += f\"# | \" + \"\\n# | \".join(data.splitlines()) + \"\\n\"\n+    out += f\"# `---{msg}{'-' * (ndashes - 4 - len(msg))}\\n\"\n+    # fmt: on\n+    return out\n+\n+\n+# Normally returns out, err, exitCode, timeoutInfo.\n+#\n+# If debug is True (the normal lit behavior), err is empty, and out contains an\n+# execution trace, including stdout and stderr shown per command executed.\n+#\n+# If debug is False (set by some custom lit test formats that call this\n+# function), out contains only stdout from the script, err contains only stderr\n+# from the script, and there is no execution trace.\n+def executeScriptInternal(test, litConfig, tmpBase, commands, cwd, debug=True):\n     cmds = []\n     for i, ln in enumerate(commands):\n+        # Within lit, we try to always add '%dbg(...)' to command lines in order\n+        # to maximize debuggability.  However, custom lit test formats might not\n+        # always add it, so add a generic debug message in that case.\n         match = re.fullmatch(kPdbgRegex, ln)\n         if match:\n+            dbg = match.group(1)\n             command = match.group(2)\n-            ln = commands[i] = match.expand(\": '\\\\1'; \\\\2\" if command else \": '\\\\1'\")\n+        else:\n+            dbg = \"command line\"\n+            command = ln\n+        if debug:\n+            ln = f\"@echo '# {dbg}' \"\n+            if command:\n+                ln += f\"&& @echo {shlex.quote(command.lstrip())} && {command}\"\n+            else:\n+                ln += \"has no command after substitutions\"\n+        else:\n+            ln = command\n         try:\n             cmds.append(\n                 ShUtil.ShParser(ln, litConfig.isWindows, test.config.pipefail).parse()\n             )\n         except:\n-            return lit.Test.Result(Test.FAIL, \"shell parser error on: %r\" % ln)\n+            return lit.Test.Result(\n+                Test.FAIL, f\"shell parser error on {dbg}: {command.lstrip()}\\n\"\n+            )\n \n     cmd = cmds[0]\n     for c in cmds[1:]:\n@@ -1022,8 +1065,42 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n \n     out = err = \"\"\n     for i, result in enumerate(results):\n-        # Write the command line run.\n-        out += \"$ %s\\n\" % (\" \".join('\"%s\"' % s for s in result.command.args),)\n+        if not debug:\n+            out += result.stdout\n+            err += result.stderr\n+            continue\n+\n+        # The purpose of an \"@echo\" command is merely to add a debugging message\n+        # directly to lit's output.  It is used internally by lit's internal\n+        # shell and is not currently documented for use in lit tests.  However,\n+        # if someone misuses it (e.g., both \"echo\" and \"@echo\" complain about\n+        # stdin redirection), produce the normal execution trace to facilitate\n+        # debugging.\n+        if (\n+            result.command.args[0] == \"@echo\"\n+            and result.exitCode == 0\n+            and not result.stderr\n+            and not result.outputFiles\n+            and not result.timeoutReached\n+        ):\n+            out += result.stdout\n+            continue\n+\n+        # Write the command line that was run.  Properly quote it.  Leading\n+        # \"!\" commands should not be quoted as that would indicate they are not\n+        # the builtins.\n+        out += \"# executed command: \"\n+        nLeadingBangs = next(\n+            (i for i, cmd in enumerate(result.command.args) if cmd != \"!\"),\n+            len(result.command.args),\n+        )\n+        out += \"! \" * nLeadingBangs\n+        out += \" \".join(\n+            shlex.quote(str(s))\n+            for i, s in enumerate(result.command.args)\n+            if i >= nLeadingBangs\n+        )\n+        out += \"\\n\"\n \n         # If nothing interesting happened, move on.\n         if (\n@@ -1038,22 +1115,14 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n \n         # Add the command output, if redirected.\n         for (name, path, data) in result.outputFiles:\n-            if data.strip():\n-                out += \"# redirected output from %r:\\n\" % (name,)\n-                data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n-                if len(data) > 1024:\n-                    out += data[:1024] + \"\\n...\\n\"\n-                    out += \"note: data was truncated\\n\"\n-                else:\n-                    out += data\n-                out += \"\\n\"\n-\n+            data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n+            out += formatOutput(f\"redirected output from '{name}'\", data, limit=1024)\n         if result.stdout.strip():\n-            out += \"# command output:\\n%s\\n\" % (result.stdout,)\n+            out += formatOutput(\"command stdout\", result.stdout)\n         if result.stderr.strip():\n-            out += \"# command stderr:\\n%s\\n\" % (result.stderr,)\n+            out += formatOutput(\"command stderr\", result.stderr)\n         if not result.stdout.strip() and not result.stderr.strip():\n-            out += \"note: command had no output on stdout or stderr\\n\"\n+            out += \"# note: command had no output on stdout or stderr\\n\"\n \n         # Show the error conditions:\n         if result.exitCode != 0:\n@@ -1063,9 +1132,9 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n                 codeStr = hex(int(result.exitCode & 0xFFFFFFFF)).rstrip(\"L\")\n             else:\n                 codeStr = str(result.exitCode)\n-            out += \"error: command failed with exit status: %s\\n\" % (codeStr,)\n+            out += \"# error: command failed with exit status: %s\\n\" % (codeStr,)\n         if litConfig.maxIndividualTestTime > 0 and result.timeoutReached:\n-            out += \"error: command reached timeout: %s\\n\" % (\n+            out += \"# error: command reached timeout: %s\\n\" % (\n                 str(result.timeoutReached),\n             )\n \n@@ -2117,6 +2186,8 @@ def executeShTest(\n         return lit.Test.Result(Test.UNSUPPORTED, \"Test is unsupported\")\n \n     script = list(preamble_commands)\n+    script = [buildPdbgCommand(f\"preamble command line\", ln) for ln in script]\n+\n     parsed = parseIntegratedTestScript(test, require_script=not script)\n     if isinstance(parsed, lit.Test.Result):\n         return parsed\ndiff --git a/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg b/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\nindex cf1a4f1ba1ec..301208c25bdc 100644\n--- a/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\n+++ b/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\n@@ -5,4 +5,4 @@ config.suffixes = [\".txt\"]\n config.test_format = lit.formats.ShTest()\n config.test_source_root = None\n config.test_exec_root = None\n-config.substitutions.append((\"%var\", lit_config.params.get(\"var\", \"\")))\n+config.substitutions.append((\"%var\", lit_config.params.get(\"var\", \"default\")))\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt b/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\nindex 6dd9b16304e0..1d94c1213723 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\n@@ -14,21 +14,21 @@\n ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0 -fopenmp-simd\n ; REDEFINE: %{fcflags} = -check-prefix=SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu -fopenmp-simd\n ; REDEFINE: %{fcflags} = -check-prefix=SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0\n ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu\n ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n \n ; CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt b/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\nindex 3bf057151afb..23c0a6d50753 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\n@@ -7,7 +7,7 @@\n #\n # REDEFINE: %{global:greeting}=Hello\n # RUN: %{global:echo}\n-# CHECK: GLOBAL: Hello World\n+# CHECK:# | GLOBAL: Hello World\n \n # We can redefine the test suite config's substitutions multiple times.  Again,\n # the expansion order remains the same (%{global:echo} before %{global:greeting}\n@@ -17,7 +17,7 @@\n # REDEFINE: %{global:greeting}=Goodbye %{global:what}\n # REDEFINE: %{global:what}=Sleep\n # RUN: %{global:echo}\n-# CHECK: GLOBAL: Goodbye Sleep Sleep\n+# CHECK:# | GLOBAL: Goodbye Sleep Sleep\n \n # A new local substitution is prepended to the substitution list so that it can\n # depend on all substitutions that were defined previously, including those from\n@@ -26,7 +26,7 @@\n # DEFINE: %{local:greeting}=Hey %{global:what}\n # DEFINE: %{local:echo}=echo \"LOCAL: %{local:greeting} %{global:what}\"\n # RUN: %{local:echo}\n-# CHECK: LOCAL: Hey Sleep Sleep\n+# CHECK:# | LOCAL: Hey Sleep Sleep\n \n # As for substitutions from the test suite config, redefining local\n # substitutions should not change the expansion order.  Again, the expansion\n@@ -36,6 +36,6 @@\n # REDEFINE: %{local:greeting}=So Long %{global:what}\n # REDEFINE: %{global:what}=World\n # RUN: %{local:echo}\n-# CHECK: LOCAL: So Long World World\n+# CHECK:# | LOCAL: So Long World World\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt b/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\nindex 65f90792ff7b..5a1d7f2e1987 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\n@@ -1,19 +1,19 @@\n # Does it work as expected directly in RUN lines?\n # RUN: echo %(line), %(line-1), %(line+2)\n-# CHECK: [[#@LINE-1]], [[#@LINE-2]], [[#@LINE+1]]\n+# CHECK:# | [[#@LINE-1]], [[#@LINE-2]], [[#@LINE+1]]\n \n # %(line) substitutions refer to the original DEFINE/REDEFINE line not the RUN\n # line they eventually appear within.\n #\n # DEFINE: %{lines} = %(line)\n # RUN: echo '%{lines}'\n-# CHECK: [[#@LINE-2]]\n+# CHECK:# | [[#@LINE-2]]\n #\n # REDEFINE: %{lines} = %(line),                                                \\\n # REDEFINE:            %(line),                                                \\\n # REDEFINE:            %(line)\n # RUN: echo '%{lines}'\n-# CHECK: [[#@LINE-4]], [[#@LINE-3]], [[#@LINE-2]]\n+# CHECK:# | [[#@LINE-4]], [[#@LINE-3]], [[#@LINE-2]]\n \n # %(line+N) and %{line-N) should work too.\n #\n@@ -21,12 +21,12 @@\n # DEFINE:                %(line),                                              \\\n # DEFINE:                %(line-1)\n # RUN: echo '%{lines-rel}'\n-# CHECK: [[#@LINE-3]], [[#@LINE-3]], [[#@LINE-3]]\n+# CHECK:# | [[#@LINE-3]], [[#@LINE-3]], [[#@LINE-3]]\n #\n # REDEFINE: %{lines-rel} = %(line+5),                                          \\\n # REDEFINE:                %(line+0),                                          \\\n # REDEFINE:                %(line-10)\n # RUN: echo '%{lines-rel}'\n-# CHECK: [[#@LINE+1]], [[#@LINE-3]], [[#@LINE-12]]\n+# CHECK:# | [[#@LINE+1]], [[#@LINE-3]], [[#@LINE-12]]\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt b/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\nindex 18a27cdd72fa..d27fda2e2fe6 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\n@@ -1,25 +1,25 @@\n # DEFINE: %{abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789} = ok\n # RUN: echo '%{abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789}'\n-# CHECK: ok\n+# CHECK:# | ok\n \n # DEFINE: %{FooBar} = ok at %(line)\n # RUN: echo '%{FooBar}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{fooBar} = ok at %(line)\n # RUN: echo '%{fooBar}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{foo-bar-} = ok at %(line)\n # RUN: echo '%{foo-bar-}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{foo:bar:} = ok at %(line)\n # RUN: echo '%{foo:bar:}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{_foo_bar_} = ok at %(line)\n # RUN: echo '%{_foo_bar_}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt b/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\nindex eb5f0b918fd1..e504b822ace8 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\n@@ -6,7 +6,7 @@\n \n # RUN: echo '%{outer}'\n \n-# CHECK-NON-RECUR:%{inner}\n-# CHECK-RECUR:expanded\n+# CHECK-NON-RECUR:# | %{inner}\n+# CHECK-RECUR:# | expanded\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt b/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\nindex 9d2e7197fb3a..c1bdfef30b1a 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\n@@ -2,21 +2,21 @@\n \n # DEFINE: %{equals} = FileCheck -check-prefixes=FOO,BAR\n # RUN: echo '%{equals}'\n-# CHECK: FileCheck -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -check-prefixes=FOO,BAR\n #\n # REDEFINE: %{equals} == == =\n # RUN: echo '%{equals}'\n-# CHECK: = == =\n+# CHECK:# | = == =\n \n # DEFINE: %{continue-equals} = FileCheck -strict-whitespace -match-full-lines \\\n # DEFINE:                      -check-prefixes=FOO,BAR\n # RUN: echo '%{continue-equals}'\n-# CHECK: FileCheck -strict-whitespace -match-full-lines -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -strict-whitespace -match-full-lines -check-prefixes=FOO,BAR\n #\n # REDEFINE: %{continue-equals} = FileCheck -input-file=test.txt                \\\n # REDEFINE:                      -implicit-check-not=foobar                    \\\n # REDEFINE:                      -check-prefixes=FOO,BAR\n # RUN: echo '%{continue-equals}'\n-# CHECK: FileCheck -input-file=test.txt -implicit-check-not=foobar -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -input-file=test.txt -implicit-check-not=foobar -check-prefixes=FOO,BAR\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt b/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\nindex 58d5c1a34ce8..9143796edd32 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\n@@ -6,11 +6,11 @@\n \n # DEFINE: %{escape} = \\g<0>\\n\n # RUN: echo '%{escape}'\n-# CHECK: {{\\\\?}}\\g<0>{{\\\\?}}\\n\n+# CHECK:# | {{\\\\?}}\\g<0>{{\\\\?}}\\n\n \n # REDEFINE: %{escape} = \\n                                                     \\\n # REDEFINE:             \\g<param>\n # RUN: echo '%{escape}'\n-# CHECK: {{\\\\?}}\\n {{\\\\?}}\\g<param>\n+# CHECK:# | {{\\\\?}}\\n {{\\\\?}}\\g<param>\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt b/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\nindex 1259e511ba70..3e4db1b15d92 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\n@@ -3,33 +3,33 @@\n #\n # DEFINE: %{empty}=\n # RUN: echo \"'%{empty}'\"\n-# CHECK:''\n+# CHECK:# | ''\n #\n # REDEFINE: %{empty}=\n # RUN: echo \"'%{empty}'\"\n-# CHECK:''\n+# CHECK:# | ''\n \n # A value consisting only of whitespace is trimmed to the empty string.\n #\n #               v~~ intentional whitespace\n # DEFINE: %{ws}=   \n # RUN: echo \"'%{ws}'\"\n-# CHECK:''\n+# CHECK:# | ''\n #\n #                 v intentional whitespace\n # REDEFINE: %{ws}= \n # RUN: echo \"'%{ws}'\"\n-# CHECK:''\n+# CHECK:# | ''\n \n # Whitespace is not required around the name or value.\n #\n # DEFINE:%{no-whitespace}=abc\n # RUN: echo \"'%{no-whitespace}'\"\n-# CHECK:'abc'\n+# CHECK:# | 'abc'\n #\n # REDEFINE:%{no-whitespace}=HelloWorld\n # RUN: echo \"'%{no-whitespace}'\"\n-# CHECK:'HelloWorld'\n+# CHECK:# | 'HelloWorld'\n \n # Whitespace is not required between substitutions in a value.\n #\n@@ -37,11 +37,11 @@\n # DEFINE: %{adjacent1} = bar\n # DEFINE: %{has-adjacent-substs} = %{adjacent0}%{adjacent1}\n # RUN: echo \"'%{has-adjacent-substs}'\"\n-# CHECK:'foobar'\n+# CHECK:# | 'foobar'\n #\n # REDEFINE: %{has-adjacent-substs} = %{adjacent0}%{adjacent1}%{adjacent0}\n # RUN: echo \"'%{has-adjacent-substs}'\"\n-# CHECK:'foobarfoo'\n+# CHECK:# | 'foobarfoo'\n \n # Exact whitespace is preserved within the value, but whitespace enclosing the\n # name or value is discarded.  ('%{' and '}' are part of the name, and\n@@ -50,11 +50,11 @@\n #                                       v~~ intentional whitespace\n # DEFINE:   %{whitespace}  =  abc    def   \n # RUN: echo \"'%{whitespace}'\"\n-# CHECK:'abc    def'\n+# CHECK:# | 'abc    def'\n #                                      v intentional whitespace\n # REDEFINE: %{whitespace} = Hello World \n # RUN: echo \"'%{whitespace}'\"\n-# CHECK:'Hello World'\n+# CHECK:# | 'Hello World'\n \n # Line continuations in the value are permitted and collapse whitespace.\n #\n@@ -66,12 +66,12 @@\n # DEFINE:  pqr \n #             ^ intentional whitespace\n # RUN: echo \"'%{continue}'\"\n-# CHECK:'abc def ghi jkl mno pqr'\n+# CHECK:# | 'abc def ghi jkl mno pqr'\n #\n # REDEFINE: %{continue} =  abc  \\\n # REDEFINE: def\n # RUN: echo \"'%{continue}'\"\n-# CHECK:'abc def'\n+# CHECK:# | 'abc def'\n \n # Whitespace at the end of the line after a '\\' is ignored, and it's treated as\n # a line continuation.  Otherwise, the behavior would be hard to understand\n@@ -83,7 +83,7 @@\n #                                   ^ intentional whitespace\n # DEFINE: baz\n # RUN: echo \"'%{ws-after-continue}'\"\n-# CHECK:'foo bar baz'\n+# CHECK:# | 'foo bar baz'\n #\n #                                     v intentional whitespace\n # REDEFINE: %{ws-after-continue}=foo \\ \n@@ -91,7 +91,7 @@\n #                                     ^~~~~~~~~~~~ intentional whitespace\n # REDEFINE: baz\n # RUN: echo \"'%{ws-after-continue}'\"\n-# CHECK:'foo bar baz'\n+# CHECK:# | 'foo bar baz'\n \n # A line continuation is recognized anywhere.  It should be used only where\n # whitespace is permitted because it reduces to a single space.\n@@ -107,7 +107,7 @@\n # DEFINE:\\\n # DEFINE:a\n # RUN: echo \"'%{blank-lines}'\"\n-# CHECK:'a'\n+# CHECK:# | 'a'\n #\n # REDEFINE:                  \\\n # REDEFINE: %{blank-lines}   \\\n@@ -120,7 +120,7 @@\n # REDEFINE:                  \\\n # REDEFINE:      c\n # RUN: echo \"'%{blank-lines}'\"\n-# CHECK:'a b c'\n+# CHECK:# | 'a b c'\n \n # The fourth DEFINE line is deceptive because it looks like a new substitution,\n # but it's actually a continuation of the previous value.\n@@ -130,6 +130,6 @@\n # DEFINE: %{deceptive-continue}=echo \\\n # DEFINE: %{name}=%{value}\n # RUN: %{deceptive-continue}\n-# CHECK:x=3\n+# CHECK:# | x=3\n \n # CHECK:{{ *}}Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt b/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\nindex b0a7cfd97941..b5fc1b49fcc5 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\n@@ -1,46 +1,34 @@\n-#       CHECK: -- Testing:{{.*}}\n-#  CHECK-NEXT: PASS: shtest-if-else :: test.txt (1 of 1)\n-#  CHECK-NEXT: Exit Code: 0\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: Command Output (stdout):\n-#  CHECK-NEXT: --\n+# CHECK: -- Testing:{{.*}}\n+# CHECK-NEXT: PASS: shtest-if-else :: test.txt (1 of 1)\n+#      CHECK: Command Output (stdout):\n+# CHECK-NEXT: --\n \n # RUN: %if feature %{ echo \"test-1\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-1\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-1\"\n \n # If %else is not present it is treated like %else %{%}. Empty commands\n # are ignored.\n #\n # RUN: %if nofeature %{ echo \"fail\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#   CHECK-NOT: fail\n+#     CHECK: # {{RUN}}: at line [[#@LINE-1]] has no command after substitutions\n+# CHECK-NOT: fail\n \n # RUN: %if nofeature %{ echo \"fail\" %} %else %{ echo \"test-2\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-2\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-2\"\n \n # Spaces inside curly braces are not ignored\n #\n # RUN: echo test-%if feature %{ 3 %} %else %{ fail %}-test\n # RUN: echo test-%if feature %{ 4 4 %} %else %{ fail %}-test\n # RUN: echo test-%if nofeature %{ fail %} %else %{ 5 5 %}-test\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 3 -test\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 4 4 -test\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 5 5 -test\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo test- 3 -test\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo test- 4 4 -test\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo test- 5 5 -test\n \n # Escape line breaks for multi-line expressions\n #\n@@ -48,42 +36,32 @@\n # RUN:   %{ echo     \\\n # RUN:     \"test-5\" \\\n # RUN:   %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-4]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-5\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-5\"\n \n # RUN: %if nofeature       \\\n # RUN:   %{ echo \"fail\" %}   \\\n # RUN: %else               \\\n # RUN:   %{ echo \"test-6\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-4]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-6\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-6\"\n \n # RUN: echo \"test%if feature %{%} %else %{%}-7\"\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-7\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-7\"\n \n # Escape %if. Without %if..%else context '%{' and '%}' are treated\n # literally.\n #\n # RUN: echo %%if feature %{ echo \"test-8\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: %if feature %{ echo test-8 %}\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo %if feature %{ echo \"test-8\" %}\n \n # Nested expressions are supported:\n #\n # RUN: echo %if feature %{ %if feature %{ %if nofeature %{\"fail\"%} %else %{\"test-9\"%} %} %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-9\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-9\"\n \n # Binary expression evaluation and regex match can be used as\n # conditions.\n@@ -91,18 +69,12 @@\n # RUN: echo %if feature && !nofeature %{ \"test-10\" %}\n # RUN: echo %if feature && nofeature %{ \"fail\" %} %else %{ \"test-11\" %}\n # RUN: echo %if {{fea.+}} %{ \"test-12\" %} %else %{ \"fail\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-10\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-11\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-12\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo \"test-10\"\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-11\"\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo \"test-12\"\n \n # Spaces between %if and %else are ignored. If there is no %else -\n # space after %if %{...%} is not ignored.\n@@ -110,39 +82,27 @@\n # RUN: echo XX %if feature %{YY%} ZZ\n # RUN: echo AA %if feature %{BB%} %else %{CC%} DD\n # RUN: echo AA %if nofeature %{BB%} %else %{CC%} DD\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: XX YY ZZ\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: AA BB DD\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: AA CC DD\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo XX YY ZZ\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo AA BB DD\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo AA CC DD\n \n # '{' and '}' can be used without escaping\n #\n # RUN: %if feature %{echo {}%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: {}\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo {}\n \n # Spaces are not required\n #\n # RUN: echo %if feature%{\"ok\"%}%else%{\"fail\"%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: ok\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"ok\"\n \n # Substitutions with braces are handled correctly\n #\n # RUN: echo %{sub} %if feature%{test-%{sub}%}%else%{\"fail\"%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: ok test-ok\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo ok test-ok\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt b/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\nindex fb3a3e000789..5ff0c891450b 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\n@@ -1,3 +1,4 @@\n # RUN: true\n # RUN: echo hi\n-# RUN: not not wc missing-file &> %t.out\n+# RUN: not not wc missing-file &> %t.out || true\n+# RUN: not %{python} %S/write-a-lot.py &> %t.out\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg b/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\nindex b872854d21e6..141fc3a596e7 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\n@@ -2,4 +2,5 @@ import lit.formats\n \n config.name = \"shtest-output-printing\"\n config.suffixes = [\".txt\"]\n+config.substitutions.append((\"%{python}\", f'\"{sys.executable}\"'))\n config.test_format = lit.formats.ShTest(execute_external=False)\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py b/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py\nnew file mode 100644\nindex 000000000000..5dbb94a41cbf\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py\n@@ -0,0 +1,6 @@\n+#!/usr/bin/env python\n+\n+import sys\n+\n+sys.stdout.write(\"All work and no play makes Jack a dull boy.\\n\" * 1000)\n+sys.stdout.flush()\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt\nnew file mode 100644\nindex 000000000000..15a87aee46a3\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt\n@@ -0,0 +1 @@\n+RUN: @echo 2> %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt\nnew file mode 100644\nindex 000000000000..27fd0c4209fd\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt\n@@ -0,0 +1,2 @@\n+RUN: touch %t\n+RUN: @echo < %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt\nnew file mode 100644\nindex 000000000000..9611918f7e12\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt\n@@ -0,0 +1 @@\n+RUN: echo 2> %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt\nnew file mode 100644\nindex 000000000000..bc771be6b22a\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt\n@@ -0,0 +1,2 @@\n+RUN: touch %t\n+RUN: echo < %t\ndiff --git a/llvm/utils/lit/tests/allow-retries.py b/llvm/utils/lit/tests/allow-retries.py\nindex bf6c04193388..45610fb70d34 100644\n--- a/llvm/utils/lit/tests/allow-retries.py\n+++ b/llvm/utils/lit/tests/allow-retries.py\n@@ -15,9 +15,28 @@\n \n # This test does not succeed within the allowed retry limit\n #\n-# RUN: not %{lit} %{inputs}/allow-retries/does-not-succeed-within-limit.py | FileCheck --check-prefix=CHECK-TEST3 %s\n-# CHECK-TEST3: Failed Tests (1):\n-# CHECK-TEST3: allow-retries :: does-not-succeed-within-limit.py\n+# Check that the execution trace isn't corrupt due to reprocessing the script\n+# multiple times (e.g., '%dbg(...)' processing used to accumulate across\n+# retries).\n+#\n+# RUN: not %{lit} %{inputs}/allow-retries/does-not-succeed-within-limit.py -v |\\\n+# RUN:   FileCheck --check-prefix=CHECK-TEST3 -match-full-lines %s\n+#\n+#       CHECK-TEST3: FAIL: allow-retries :: does-not-succeed-within-limit.py (1 of 1)\n+#  CHECK-TEST3-NEXT: {{\\**}} TEST 'allow-retries :: does-not-succeed-within-limit.py' FAILED {{\\**}}\n+#  CHECK-TEST3-NEXT: Exit Code: 1\n+# CHECK-TEST3-EMPTY:\n+#  CHECK-TEST3-NEXT: Command Output (stdout):\n+#  CHECK-TEST3-NEXT: --\n+#  CHECK-TEST3-NEXT: # {{RUN}}: at line 3\n+#  CHECK-TEST3-NEXT: false\n+#  CHECK-TEST3-NEXT: # executed command: false\n+#  CHECK-TEST3-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-TEST3-NEXT: # error: command failed with exit status: 1\n+# CHECK-TEST3-EMPTY:\n+#  CHECK-TEST3-NEXT: --\n+#       CHECK-TEST3: Failed Tests (1):\n+#       CHECK-TEST3: allow-retries :: does-not-succeed-within-limit.py\n \n # This test should be UNRESOLVED since it has more than one ALLOW_RETRIES\n # lines, and that is not allowed.\n@@ -48,6 +67,6 @@\n # RUN:     -Dcounter=%t.counter -Dpython=%{python} | \\\n # RUN:   FileCheck --check-prefix=CHECK-TEST7 %s\n #     CHECK-TEST7: Command Output (stdout):\n-#     CHECK-TEST7: LLVM_PROFILE_FILE=\n-# CHECK-TEST7-NOT: LLVM_PROFILE_FILE=\n+#     CHECK-TEST7: # executed command: export LLVM_PROFILE_FILE=\n+# CHECK-TEST7-NOT: # executed command: export LLVM_PROFILE_FILE=\n #     CHECK-TEST7: Passed With Retry: 1\ndiff --git a/llvm/utils/lit/tests/lit-opts.py b/llvm/utils/lit/tests/lit-opts.py\nindex d292ca74f3b9..a533a59d9d12 100644\n--- a/llvm/utils/lit/tests/lit-opts.py\n+++ b/llvm/utils/lit/tests/lit-opts.py\n@@ -8,7 +8,7 @@\n #\n # RUN: env LIT_OPTS=-a \\\n # RUN: %{lit} -s %{inputs}/lit-opts \\\n-# RUN: | FileCheck -check-prefix=SHOW-ALL -DVAR= %s\n+# RUN: | FileCheck -check-prefix=SHOW-ALL -DVAR=default %s\n \n # Check that LIT_OPTS understands multiple options with arbitrary spacing.\n #\n@@ -28,6 +28,6 @@\n \n # SHOW-ALL:     Testing: 1 tests\n # SHOW-ALL:     PASS: lit-opts :: test.txt (1 of 1)\n-# SHOW-ALL:     {{^}}[[VAR]]\n+# SHOW-ALL:     echo [[VAR]]\n # SHOW-ALL-NOT: PASS\n # SHOW-ALL:     Passed: 1\ndiff --git a/llvm/utils/lit/tests/shtest-define.py b/llvm/utils/lit/tests/shtest-define.py\nindex 1d0997bbbaf8..8c9309804cce 100644\n--- a/llvm/utils/lit/tests/shtest-define.py\n+++ b/llvm/utils/lit/tests/shtest-define.py\n@@ -136,15 +136,15 @@\n # RUN: %{lit} -va %{my-inputs}/shared-substs-*.txt 2>&1 |                      \\\n # RUN:   FileCheck -check-prefix=SHARED-SUBSTS -match-full-lines %s\n #\n-# SHARED-SUBSTS: shared-substs-0.txt\n-# SHARED-SUBSTS: GLOBAL: World\n-# SHARED-SUBSTS: LOCAL0: LOCAL0:Hello LOCAL0:World\n-# SHARED-SUBSTS: LOCAL0: subst\n+# SHARED-SUBSTS:# | shared-substs-0.txt\n+# SHARED-SUBSTS:# | GLOBAL: World\n+# SHARED-SUBSTS:# | LOCAL0: LOCAL0:Hello LOCAL0:World\n+# SHARED-SUBSTS:# | LOCAL0: subst\n #\n-# SHARED-SUBSTS: shared-substs-1.txt\n-# SHARED-SUBSTS: GLOBAL: World\n-# SHARED-SUBSTS: LOCAL1: LOCAL1:Hello LOCAL1:World\n-# SHARED-SUBSTS: LOCAL1: subst\n+# SHARED-SUBSTS:# | shared-substs-1.txt\n+# SHARED-SUBSTS:# | GLOBAL: World\n+# SHARED-SUBSTS:# | LOCAL1: LOCAL1:Hello LOCAL1:World\n+# SHARED-SUBSTS:# | LOCAL1: subst\n #\n # REDEFINE: %{test} = shared-substs-0.txt\n # RUN: %{record-test}\ndiff --git a/llvm/utils/lit/tests/shtest-env.py b/llvm/utils/lit/tests/shtest-env.py\nindex f2e8216f7f4a..c093b62e5420 100644\n--- a/llvm/utils/lit/tests/shtest-env.py\n+++ b/llvm/utils/lit/tests/shtest-env.py\n@@ -10,88 +10,115 @@\n # CHECK: -- Testing: 16 tests{{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-assign.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"FOO=1\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env FOO=1\n+# CHECK: # executed command: env FOO=1\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-u-arg.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO\n+# CHECK: # executed command: env -u FOO\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-u.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u\n+# CHECK: # executed command: env -u\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-nested-none.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"env\" \"env\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env env env\n+# CHECK: # executed command: env env env\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-none.txt ({{[^)]*}})\n-# CHECK: $ \"env\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env\n+# CHECK: # executed command: env\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-cd.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"cd\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'cd'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 cd foobar\n+# CHECK: # executed command: env -u FOO BAR=3 cd foobar\n+# CHECK: # | Error: 'env' cannot call 'cd'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-colon.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \":\"\n-# CHECK: Error: 'env' cannot call ':'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 :\n+# CHECK: # executed command: env -u FOO BAR=3 :\n+# CHECK: # | Error: 'env' cannot call ':'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-echo.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"echo\" \"hello\" \"world\"\n-# CHECK: Error: 'env' cannot call 'echo'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 echo hello world\n+# CHECK: # executed command: env -u FOO BAR=3 echo hello world\n+# CHECK: # | Error: 'env' cannot call 'echo'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: PASS: shtest-env :: env-calls-env.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"env\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"FOO=2\" \"env\" \"BAR=1\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"env\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=1\" \"env\" \"-u\" \"BAR\" \"FOO=2\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=1\" \"env\" \"-u\" \"BAR\" \"FOO=2\" \"env\" \"BAZ=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env env [[PYTHON:.+]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env env [[PYTHON_BARE:.+]] print_environment.py\n+# CHECK: env FOO=2 env BAR=1 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env FOO=2 env BAR=1 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO env -u BAR [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO env -u BAR [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO BAR=1 env -u BAR FOO=2 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO BAR=1 env -u BAR FOO=2 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO BAR=1 env -u BAR FOO=2 env BAZ=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO BAR=1 env -u BAR FOO=2 env BAZ=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: FAIL: shtest-env :: env-calls-export.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"export\" \"BAZ=3\"\n-# CHECK: Error: 'env' cannot call 'export'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 export BAZ=3\n+# CHECK: # executed command: env -u FOO BAR=3 export BAZ=3\n+# CHECK: # | Error: 'env' cannot call 'export'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-mkdir.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"mkdir\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'mkdir'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 mkdir foobar\n+# CHECK: # executed command: env -u FOO BAR=3 mkdir foobar\n+# CHECK: # | Error: 'env' cannot call 'mkdir'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-not-builtin.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"not\" \"rm\" \"{{.*}}.no-such-file\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 not rm {{.+}}.no-such-file\n+# CHECK: # executed command: env -u FOO BAR=3 not rm {{.+}}.no-such-file{{.*}}\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-rm.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"rm\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 rm foobar\n+# CHECK: # executed command: env -u FOO BAR=3 rm foobar\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: PASS: shtest-env :: env-u.txt ({{[^)]*}})\n-# CHECK: $ \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: env -u FOO [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO -u BAR [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO -u BAR [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: PASS: shtest-env :: env.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"A_FOO=999\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"A_FOO=1\" \"B_BAR=2\" \"C_OOF=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env A_FOO=999 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=999 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env A_FOO=1 B_BAR=2 C_OOF=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=1 B_BAR=2 C_OOF=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: PASS: shtest-env :: mixed.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"A_FOO=999\" \"-u\" \"FOO\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"A_FOO=1\" \"-u\" \"FOO\" \"B_BAR=2\" \"-u\" \"BAR\" \"C_OOF=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env A_FOO=999 -u FOO [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=999 -u FOO [[PYTHON_BARE]] print_environment.py\n+# CHECK: env A_FOO=1 -u FOO B_BAR=2 -u BAR C_OOF=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=1 -u FOO B_BAR=2 -u BAR C_OOF=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: Passed:  4\n # CHECK: Failed: 12\ndiff --git a/llvm/utils/lit/tests/shtest-format.py b/llvm/utils/lit/tests/shtest-format.py\nindex 621776ab7bc2..4a3d65b7bce4 100644\n--- a/llvm/utils/lit/tests/shtest-format.py\n+++ b/llvm/utils/lit/tests/shtest-format.py\n@@ -43,13 +43,21 @@\n # CHECK-EMPTY:\n #  CHECK-NEXT: Command Output (stdout):\n #  CHECK-NEXT: --\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-#  CHECK-NEXT: $ \"printf\"\n-#  CHECK-NEXT: # command output:\n-#  CHECK-NEXT: line 1: failed test output on stdout\n-#  CHECK-NEXT: line 2: failed test output on stdout\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-#  CHECK-NEXT: $ \"false\"\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: printf \"line 1: failed test output on stdout\\nline 2: failed test output on stdout\"\n+#  CHECK-NEXT: executed command: printf 'line 1: failed test output on stdout\\nline 2: failed test output on stdout'\n+#  CHECK-NEXT: # .---command stdout------------\n+#  CHECK-NEXT: # | line 1: failed test output on stdout\n+#  CHECK-NEXT: # | line 2: failed test output on stdout\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # RUN: at line 2\n+#  CHECK-NEXT: false\n+#  CHECK-NEXT: # executed command: false\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: --\n+\n \n # CHECK: UNRESOLVED: shtest-format :: no-test-line.txt\n # CHECK: PASS: shtest-format :: pass.txt\n@@ -73,8 +81,11 @@\n # CHECK-EMPTY:\n #  CHECK-NEXT: Command Output (stdout):\n #  CHECK-NEXT: --\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-#  CHECK-NEXT: $ \"true\"\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: true\n+#  CHECK-NEXT: # executed command: true\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: --\n \n # CHECK: Failed Tests (4)\n # CHECK: shtest-format :: external_shell/fail.txt\ndiff --git a/llvm/utils/lit/tests/shtest-if-else.py b/llvm/utils/lit/tests/shtest-if-else.py\nindex aaf94a6e2437..c18da4abbcca 100644\n--- a/llvm/utils/lit/tests/shtest-if-else.py\n+++ b/llvm/utils/lit/tests/shtest-if-else.py\n@@ -1,5 +1,6 @@\n # RUN: %{lit} -v --show-all %{inputs}/shtest-if-else/test.txt \\\n-# RUN:    | FileCheck %{inputs}/shtest-if-else/test.txt --match-full-lines\n+# RUN:    | FileCheck %{inputs}/shtest-if-else/test.txt --match-full-lines \\\n+# RUN:                --implicit-check-not='RUN:'\n \n # RUN: not %{lit} -v --show-all %{inputs}/shtest-if-else/test-neg1.txt 2>&1 \\\n # RUN:    | FileCheck %{inputs}/shtest-if-else/test-neg1.txt\ndiff --git a/llvm/utils/lit/tests/shtest-inject.py b/llvm/utils/lit/tests/shtest-inject.py\nindex 17e293ea1a12..3d34eb7161d4 100644\n--- a/llvm/utils/lit/tests/shtest-inject.py\n+++ b/llvm/utils/lit/tests/shtest-inject.py\n@@ -1,9 +1,26 @@\n-# Check that we can inject commands at the beginning of a ShTest.\n+# Check that we can inject preamble commands at the beginning of a ShTest.\n+#\n+# For one case, check the execution trace as these preamble commands have\n+# \"preamble command\" instead of the usual \"{{RUN}}: at line N\".\n \n # RUN: %{lit} %{inputs}/shtest-inject/test-empty.txt --show-all | FileCheck --check-prefix=CHECK-TEST1 %s\n #\n-# CHECK-TEST1: THIS WAS\n-# CHECK-TEST1: INJECTED\n+#       CHECK-TEST1: Command Output (stdout):\n+#  CHECK-TEST1-NEXT: --\n+#  CHECK-TEST1-NEXT: # preamble command line\n+#  CHECK-TEST1-NEXT: echo \"THIS WAS\"\n+#  CHECK-TEST1-NEXT: # executed command: echo 'THIS WAS'\n+#  CHECK-TEST1-NEXT: # .---command stdout{{-*}}\n+#  CHECK-TEST1-NEXT: # | THIS WAS\n+#  CHECK-TEST1-NEXT: # `---{{-*}}\n+#  CHECK-TEST1-NEXT: # preamble command line\n+#  CHECK-TEST1-NEXT: echo \"INJECTED\"\n+#  CHECK-TEST1-NEXT: # executed command: echo INJECTED\n+#  CHECK-TEST1-NEXT: # .---command stdout{{-*}}\n+#  CHECK-TEST1-NEXT: # | INJECTED\n+#  CHECK-TEST1-NEXT: # `---{{-*}}\n+# CHECK-TEST1-EMPTY:\n+#  CHECK-TEST1-NEXT: --\n #\n # CHECK-TEST1: Passed: 1\n \ndiff --git a/llvm/utils/lit/tests/shtest-not.py b/llvm/utils/lit/tests/shtest-not.py\nindex d23c9d0cffaf..f514cddf1def 100644\n--- a/llvm/utils/lit/tests/shtest-not.py\n+++ b/llvm/utils/lit/tests/shtest-not.py\n@@ -10,112 +10,158 @@\n # CHECK: -- Testing: 17 tests{{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-args-nested-none.txt {{.*}}\n-# CHECK: $ \"!\" \"!\" \"!\"\n-# CHECK: Error: '!' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: ! ! !\n+# CHECK: # executed command: ! ! !\n+# CHECK: # | Error: '!' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-args-none.txt {{.*}}\n-# CHECK: $ \"!\"\n-# CHECK: Error: '!' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: !\n+# CHECK: # executed command: !\n+# CHECK: # | Error: '!' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-calls-external.txt {{.*}}\n \n-# CHECK: $ \"!\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"!\" \"!\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"!\" \"!\" \"!\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"!\" \"!\" \"!\" \"!\" \"{{[^\"]*}}\" \"pass.py\"\n+# CHECK: ! [[PYTHON:.*]] fail.py\n+# CHECK: # executed command: ! [[PYTHON_BARE:.*]] fail.py\n+# CHECK: ! ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! ! [[PYTHON_BARE]] pass.py\n+# CHECK: ! ! ! [[PYTHON]] fail.py\n+# CHECK: # executed command: ! ! ! [[PYTHON_BARE]] fail.py\n+# CHECK: ! ! ! ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! ! ! ! [[PYTHON_BARE]] pass.py\n \n-# CHECK: $ \"!\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! [[PYTHON_BARE]] pass.py\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-last-is-crash.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not --crash\n+# CHECK: # executed command: not --crash\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-nested-none.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not not\n+# CHECK: # executed command: not not not\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-none.txt {{.*}}\n-# CHECK: $ \"not\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not\n+# CHECK: # executed command: not\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-cd.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"cd\" \"foobar\"\n-# CHECK: $ \"not\" \"--crash\" \"cd\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'cd'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not cd foobar\n+# CHECK: # executed command: not not cd foobar\n+# CHECK: not --crash cd foobar\n+# CHECK: # executed command: not --crash cd foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'cd'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-colon.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \":\" \"foobar\"\n-# CHECK: $ \"not\" \"--crash\" \":\"\n-# CHECK: Error: 'not --crash' cannot call ':'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not : foobar\n+# CHECK: # executed command: not not : foobar\n+# CHECK: not --crash :\n+# CHECK: # executed command: not --crash :\n+# CHECK: # | Error: 'not --crash' cannot call ':'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-diff-with-crash.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"diff\" \"-u\" {{.*}}\n-# CHECK-NOT: \"$\"\n+# CHECK: not --crash diff -u {{.*}}\n+# CHECK: # executed command: not --crash diff -u {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n # CHECK-NOT: {{[Ee]rror}}\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: # error: command failed with exit status: {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n # CHECK-NOT: {{[Ee]rror}}\n-# CHECK-NOT: \"$\"\n \n # CHECK: FAIL: shtest-not :: not-calls-diff.txt {{.*}}\n-# CHECK: $ \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"diff\" {{.*}}\n-# CHECK-NOT: \"$\"\n+# CHECK: not diff {{.*}}\n+# CHECK: # executed command: not diff {{.*}}\n+# CHECK: not not not diff {{.*}}\n+# CHECK: # executed command: not not not diff {{.*}}\n+# CHECK: not not not not not diff {{.*}}\n+# CHECK: # executed command: not not not not not diff {{.*}}\n+# CHECK: diff {{.*}}\n+# CHECK: # executed command: diff {{.*}}\n+# CHECK: not not diff {{.*}}\n+# CHECK: # executed command: not not diff {{.*}}\n+# CHECK: not not not not diff {{.*}}\n+# CHECK: # executed command: not not not not diff {{.*}}\n+# CHECK: not diff {{.*}}\n+# CHECK: # executed command: not diff {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-echo.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"echo\" \"hello\" \"world\"\n-# CHECK: $ \"not\" \"--crash\" \"echo\" \"hello\" \"world\"\n-# CHECK: Error: 'not --crash' cannot call 'echo'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not echo hello world\n+# CHECK: # executed command: not not echo hello world\n+# CHECK: not --crash echo hello world\n+# CHECK: # executed command: not --crash echo hello world\n+# CHECK: # | Error: 'not --crash' cannot call 'echo'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-env-builtin.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"env\" \"-u\" \"FOO\" \"BAR=3\" \"rm\" \"{{.*}}.no-such-file\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not --crash env -u FOO BAR=3 rm {{.*}}.no-such-file\n+# CHECK: # executed command: not --crash env -u FOO BAR=3 rm {{.+}}.no-such-file{{.*}}\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-export.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"export\" \"FOO=1\"\n-# CHECK: $ \"not\" \"--crash\" \"export\" \"BAZ=3\"\n-# CHECK: Error: 'not --crash' cannot call 'export'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not export FOO=1\n+# CHECK: # executed command: not not export FOO=1\n+# CHECK: not --crash export BAZ=3\n+# CHECK: # executed command: not --crash export BAZ=3\n+# CHECK: # | Error: 'not --crash' cannot call 'export'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n \n # CHECK: PASS: shtest-not :: not-calls-external.txt {{.*}}\n \n-# CHECK: $ \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-\n-# CHECK: $ \"env\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"env\" \"-u\" \"FOO\" \"BAR=2\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"env\" \"-u\" \"FOO\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"env\" \"FOO=1\" \"env\" \"FOO=2\" \"BAR=1\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"-u\" \"BAR\" \"env\" \"-u\" \"FOO\" \"BAR=1\" \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"env\" \"FOO=2\" \"BAR=2\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"env\" \"-u\" \"BAR\" \"not\" \"env\" \"-u\" \"FOO\" \"BAR=1\" \"{{[^\"]*}}\" \"pass.py\"\n+# CHECK: not [[PYTHON]] fail.py\n+# CHECK: # executed command: not [[PYTHON_BARE]] fail.py\n+# CHECK: not not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not [[PYTHON_BARE]] pass.py\n+# CHECK: not not not [[PYTHON]] fail.py\n+# CHECK: # executed command: not not not [[PYTHON_BARE]] fail.py\n+# CHECK: not not not not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not not not [[PYTHON_BARE]] pass.py\n+\n+# CHECK: not not --crash [[PYTHON]] pass.py\n+# CHECK: # executed command: not not --crash [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash [[PYTHON]] fail.py\n+# CHECK: # executed command: not not --crash [[PYTHON_BARE]] fail.py\n+# CHECK: not not --crash not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not --crash not [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash not [[PYTHON]] fail.py\n+# CHECK: # executed command: not not --crash not [[PYTHON_BARE]] fail.py\n+\n+# CHECK: env not [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env not [[PYTHON_BARE]] fail.py\n+# CHECK: not env [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: not env [[PYTHON_BARE]] fail.py\n+# CHECK: env FOO=1 not [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 not [[PYTHON_BARE]] fail.py\n+# CHECK: not env FOO=1 BAR=1 [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 [[PYTHON_BARE]] fail.py\n+# CHECK: env FOO=1 BAR=1 not env -u FOO BAR=2 [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 BAR=1 not env -u FOO BAR=2 [[PYTHON_BARE]] fail.py\n+# CHECK: not env FOO=1 BAR=1 not env -u FOO -u BAR [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 not env -u FOO -u BAR [[PYTHON_BARE]] pass.py\n+# CHECK: not not env FOO=1 env FOO=2 BAR=1 [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not not env FOO=1 env FOO=2 BAR=1 [[PYTHON_BARE]] pass.py\n+# CHECK: env FOO=1 -u BAR env -u FOO BAR=1 not not [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 -u BAR env -u FOO BAR=1 not not [[PYTHON_BARE]] pass.py\n+\n+# CHECK: not env FOO=1 BAR=1 env FOO=2 BAR=2 not --crash [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 env FOO=2 BAR=2 not --crash [[PYTHON_BARE]] pass.py\n+# CHECK: not env FOO=1 BAR=1 not --crash not [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 not --crash not [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash env -u BAR not env -u FOO BAR=1 [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not not --crash env -u BAR not env -u FOO BAR=1 [[PYTHON_BARE]] pass.py\n \n \n # CHECK: FAIL: shtest-not :: not-calls-fail2.txt {{.*}}\n@@ -123,16 +169,20 @@\n # CHECK-NEXT: Exit Code: 1\n \n # CHECK: FAIL: shtest-not :: not-calls-mkdir.txt {{.*}}\n-# CHECK: $ \"not\" \"mkdir\" {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"mkdir\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'mkdir'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not mkdir {{.*}}\n+# CHECK: # executed command: not mkdir {{.*}}\n+# CHECK: not --crash mkdir foobar\n+# CHECK: # executed command: not --crash mkdir foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'mkdir'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-rm.txt {{.*}}\n-# CHECK: $ \"not\" \"rm\" {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"rm\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not rm {{.*}}\n+# CHECK: # executed command: not rm {{.*}}\n+# CHECK: not --crash rm foobar\n+# CHECK: # executed command: not --crash rm foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: Passed:  1\n # CHECK: Failed: 16\ndiff --git a/llvm/utils/lit/tests/shtest-output-printing.py b/llvm/utils/lit/tests/shtest-output-printing.py\nindex 7cd975ba8d3c..129cff981eb5 100644\n--- a/llvm/utils/lit/tests/shtest-output-printing.py\n+++ b/llvm/utils/lit/tests/shtest-output-printing.py\n@@ -1,28 +1,45 @@\n # Check the various features of the ShTest format.\n #\n # RUN: not %{lit} -v %{inputs}/shtest-output-printing > %t.out\n-# RUN: FileCheck --input-file %t.out %s\n+# RUN: FileCheck --input-file %t.out --match-full-lines %s\n #\n # END.\n \n-# CHECK: -- Testing:\n-\n-# CHECK: FAIL: shtest-output-printing :: basic.txt\n-# CHECK-NEXT: *** TEST 'shtest-output-printing :: basic.txt' FAILED ***\n-# CHECK-NEXT: Exit Code: 1\n-#\n-# CHECK:      Command Output\n-# CHECK-NEXT: --\n-# CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \"true\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-# CHECK-NEXT: $ \"echo\" \"hi\"\n-# CHECK-NEXT: # command output:\n-# CHECK-NEXT: hi\n-#\n-# CHECK:      $ \":\" \"RUN: at line 3\"\n-# CHECK-NEXT: $ \"not\" \"not\" \"wc\" \"missing-file\"\n-# CHECK-NEXT: # redirected output from '{{.*(/|\\\\\\\\)}}basic.txt.tmp.out':\n-# CHECK-NEXT: {{cannot open missing-file|missing-file.* No such file or directory}}\n-# CHECK:      note: command had no output on stdout or stderr\n-# CHECK-NEXT: error: command failed with exit status: 1\n+#       CHECK: -- Testing: {{.*}}\n+#       CHECK: FAIL: shtest-output-printing :: basic.txt {{.*}}\n+#  CHECK-NEXT: ***{{\\**}} TEST 'shtest-output-printing :: basic.txt' FAILED ***{{\\**}}\n+#  CHECK-NEXT: Exit Code: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: Command Output (stdout):\n+#  CHECK-NEXT: --\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: true\n+#  CHECK-NEXT: # executed command: true\n+#  CHECK-NEXT: # RUN: at line 2\n+#  CHECK-NEXT: echo hi\n+#  CHECK-NEXT: # executed command: echo hi\n+#  CHECK-NEXT: # .---command stdout------------\n+#  CHECK-NEXT: # | hi\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # RUN: at line 3\n+#  CHECK-NEXT: not not wc missing-file &> [[FILE:.*]] || true\n+#  CHECK-NEXT: # executed command: not not wc missing-file\n+#  CHECK-NEXT: # .---redirected output from '[[FILE]]'\n+#  CHECK-NEXT: # | wc: {{cannot open missing-file|missing-file.* No such file or directory}}\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+#  CHECK-NEXT: # executed command: true\n+#  CHECK-NEXT: # RUN: at line 4\n+#  CHECK-NEXT: not {{.*}}python{{.*}} {{.*}}write-a-lot.py &> [[FILE:.*]]\n+#  CHECK-NEXT: # executed command: not {{.*}}python{{.*}} {{.*}}write-a-lot.py{{.*}}\n+#  CHECK-NEXT: # .---redirected output from '[[FILE]]'\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#       CHECK: # | ...\n+#  CHECK-NEXT: # `---data was truncated--------\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT:--\ndiff --git a/llvm/utils/lit/tests/shtest-pushd-popd.py b/llvm/utils/lit/tests/shtest-pushd-popd.py\nindex 26296a7ffcf5..6d7e93c74a05 100644\n--- a/llvm/utils/lit/tests/shtest-pushd-popd.py\n+++ b/llvm/utils/lit/tests/shtest-pushd-popd.py\n@@ -8,16 +8,16 @@\n # CHECK: -- Testing: 4 tests{{.*}}\n \n # CHECK: FAIL: shtest-pushd-popd :: popd-args.txt ({{[^)]*}})\n-# CHECK: $ \"popd\" \"invalid\"\n-# CHECK: 'popd' does not support arguments\n+# CHECK: popd invalid\n+# CHECK: # | 'popd' does not support arguments\n \n # CHECK: FAIL: shtest-pushd-popd :: popd-no-stack.txt ({{[^)]*}})\n-# CHECK: $ \"popd\"\n-# CHECK: popd: directory stack empty\n+# CHECK: popd\n+# CHECK: # | popd: directory stack empty\n \n # CHECK: FAIL: shtest-pushd-popd :: pushd-too-many-args.txt ({{[^)]*}})\n-# CHECK: $ \"pushd\" \"a\" \"b\"\n-# CHECK: 'pushd' supports only one argument\n+# CHECK: pushd a b\n+# CHECK: # | 'pushd' supports only one argument\n \n # CHECK: Passed:  1\n # CHECK: Failed:  3\ndiff --git a/llvm/utils/lit/tests/shtest-recursive-substitution.py b/llvm/utils/lit/tests/shtest-recursive-substitution.py\nindex 48f4b5b12491..65c177e65a3c 100644\n--- a/llvm/utils/lit/tests/shtest-recursive-substitution.py\n+++ b/llvm/utils/lit/tests/shtest-recursive-substitution.py\n@@ -3,7 +3,7 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/substitutes-within-limit --show-all | FileCheck --check-prefix=CHECK-TEST1 %s\n # CHECK-TEST1: PASS: substitutes-within-limit :: test.py\n-# CHECK-TEST1: $ \"echo\" \"STOP\"\n+# CHECK-TEST1: echo STOP\n \n # RUN: not %{lit} %{inputs}/shtest-recursive-substitution/does-not-substitute-within-limit --show-all | FileCheck --check-prefix=CHECK-TEST2 %s\n # CHECK-TEST2: UNRESOLVED: does-not-substitute-within-limit :: test.py\n@@ -11,7 +11,7 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/does-not-substitute-no-limit --show-all | FileCheck --check-prefix=CHECK-TEST3 %s\n # CHECK-TEST3: PASS: does-not-substitute-no-limit :: test.py\n-# CHECK-TEST3: $ \"echo\" \"%rec4\"\n+# CHECK-TEST3: echo %rec4\n \n # RUN: not %{lit} %{inputs}/shtest-recursive-substitution/not-an-integer --show-all 2>&1 | FileCheck --check-prefix=CHECK-TEST4 %s\n # CHECK-TEST4: recursiveExpansionLimit must be either None or an integer\n@@ -24,4 +24,4 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/escaping --show-all | FileCheck --check-prefix=CHECK-TEST7 %s\n # CHECK-TEST7: PASS: escaping :: test.py\n-# CHECK-TEST7: $ \"echo\" \"%s\" \"%s\" \"%%s\"\n+# CHECK-TEST7: echo %s %s %%s\ndiff --git a/llvm/utils/lit/tests/shtest-run-at-line.py b/llvm/utils/lit/tests/shtest-run-at-line.py\nindex 879cd64ebf6e..a0626f872c4c 100644\n--- a/llvm/utils/lit/tests/shtest-run-at-line.py\n+++ b/llvm/utils/lit/tests/shtest-run-at-line.py\n@@ -28,21 +28,28 @@\n # CHECK-LABEL: FAIL: shtest-run-at-line :: internal-shell/basic.txt\n \n # CHECK:      Command Output (stdout)\n-# CHECK:      $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \"true\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-# CHECK-NEXT: $ \"false\"\n+# CHECK-NEXT: --\n+# CHECK-NEXT: # RUN: at line 1\n+# CHECK-NEXT: true\n+# CHECK-NEXT: # executed command: true\n+# CHECK-NEXT: # RUN: at line 2\n+# CHECK-NEXT: false\n+# CHECK-NEXT: # executed command: false\n # CHECK-NOT:  RUN\n \n # CHECK-LABEL: FAIL: shtest-run-at-line :: internal-shell/line-continuation.txt\n \n # CHECK:      Command Output (stdout)\n-# CHECK:      $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \":\" \"first\" \"line\" \"continued\" \"to\" \"second\" \"line\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 3\"\n-# CHECK-NEXT: $ \"echo\" \"foo bar\"\n-# CHECK-NEXT: $ \"FileCheck\" \"{{.*}}\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 5\"\n-# CHECK-NEXT: $ \"echo\" \"foo baz\"\n-# CHECK-NEXT: $ \"FileCheck\" \"{{.*}}\"\n+# CHECK-NEXT: --\n+# CHECK-NEXT: # RUN: at line 1\n+# CHECK-NEXT: : first line continued to second line\n+# CHECK-NEXT: # executed command: : first line continued to second line\n+# CHECK-NEXT: # RUN: at line 3\n+# CHECK-NEXT: echo 'foo bar' | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: echo 'foo bar'\n+# CHECK-NEXT: # executed command: FileCheck {{.*}}\n+# CHECK-NEXT: # RUN: at line 5\n+# CHECK-NEXT: echo 'foo baz' | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: echo 'foo baz'\n+# CHECK-NEXT: # executed command: FileCheck {{.*}}\n # CHECK-NOT:  RUN\ndiff --git a/llvm/utils/lit/tests/shtest-shell.py b/llvm/utils/lit/tests/shtest-shell.py\nindex 93f05dbd35d0..a043582d6ae2 100644\n--- a/llvm/utils/lit/tests/shtest-shell.py\n+++ b/llvm/utils/lit/tests/shtest-shell.py\n@@ -20,202 +20,212 @@\n \n # CHECK: FAIL: shtest-shell :: cat-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: cat-error-0.txt' FAILED ***\n-# CHECK: $ \"cat\" \"-b\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'cat':  option -b not recognized\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: cat -b temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'cat':  option -b not recognized\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: cat-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: cat-error-1.txt' FAILED ***\n-# CHECK: $ \"cat\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: [Errno 2] No such file or directory: 'temp1.txt'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: cat temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | [Errno 2] No such file or directory: 'temp1.txt'\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: colon-error.txt\n # CHECK: *** TEST 'shtest-shell :: colon-error.txt' FAILED ***\n-# CHECK: $ \":\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: ':' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: :\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: ':' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: PASS: shtest-shell :: continuations.txt\n \n # CHECK: PASS: shtest-shell :: dev-null.txt\n \n-# CHECK: FAIL: shtest-shell :: diff-b.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-b.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-b\" \"{{[^\"]*}}.0\" \"{{[^\"]*}}.1\"\n-# CHECK: # command output:\n-# CHECK: 1,2\n-# CHECK-NEXT: {{^  }}f o o\n-# CHECK-NEXT: ! b a r\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: {{^  }}f o o\n-# CHECK-NEXT: ! bar\n-# CHECK-EMPTY:\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-b.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-b.txt' FAILED ***\n+#      CHECK: diff -b {{[^\"]*}}.0 {{[^\"]*}}.1\n+#      CHECK: # .---command stdout{{-*}}\n+#      CHECK: # | {{.*}}1,2\n+# CHECK-NEXT: # |   f o o\n+# CHECK-NEXT: # | ! b a r\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # |   f o o\n+# CHECK-NEXT: # | ! bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+#      CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-encodings.txt\n # CHECK: *** TEST 'shtest-shell :: diff-encodings.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"diff-in.bin\"\n+#      CHECK: diff -u diff-in.bin diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.bin diff-in.bin\n+#  CHECK-NOT: error\n+\n+#      CHECK: diff -u diff-in.utf16 diff-in.bin && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf16 diff-in.bin\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.utf8 diff-in.bin && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf8 diff-in.bin\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | -baz\n+# CHECK-NEXT: # | {{\\+.f.o.o.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{\\+.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.bin diff-in.utf8 && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.bin diff-in.utf8\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{-.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.}}\n+# CHECK-NEXT: # | {{-.b.a.z.$}}\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # | +baz\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#     CHECK: cat diff-in.bin | diff -u - diff-in.bin\n # CHECK-NOT: error\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf16\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^ .f.o.o.$}}\n-# CHECK-NEXT: {{^-.b.a.r.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^ .b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf8\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: -baz\n-# CHECK-NEXT: {{^\\+.f.o.o.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^\\+.b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"diff-in.utf8\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^\\-.f.o.o.$}}\n-# CHECK-NEXT: {{^\\-.b.a.r.}}\n-# CHECK-NEXT: {{^\\-.b.a.z.$}}\n-# CHECK-NEXT: +foo\n-# CHECK-NEXT: +bar\n-# CHECK-NEXT: +baz\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"-\"\n-# CHECK-NOT: error\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf16\" \"-\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^ .f.o.o.$}}\n-# CHECK-NEXT: {{^-.b.a.r.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^ .b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n+#     CHECK: cat diff-in.bin | diff -u diff-in.bin -\n # CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf8\" \"-\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: -baz\n-# CHECK-NEXT: {{^\\+.f.o.o.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^\\+.b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"diff-in.utf8\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^\\-.f.o.o.$}}\n-# CHECK-NEXT: {{^\\-.b.a.r.}}\n-# CHECK-NEXT: {{^\\-.b.a.z.$}}\n-# CHECK-NEXT: +foo\n-# CHECK-NEXT: +bar\n-# CHECK-NEXT: +baz\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n \n-# CHECK: $ \"false\"\n+#      CHECK: cat diff-in.bin | diff -u diff-in.utf16 - && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf16 -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat diff-in.bin | diff -u diff-in.utf8 - && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf8 -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | -baz\n+# CHECK-NEXT: # | {{\\+.f.o.o.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{\\+.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat diff-in.bin | diff -u - diff-in.utf8 && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u - diff-in.utf8\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{-.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.}}\n+# CHECK-NEXT: # | {{-.b.a.z.$}}\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # | +baz\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-1.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-B\" \"temp1.txt\" \"temp2.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'diff': option -B not recognized\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -B temp1.txt temp2.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'diff': option -B not recognized\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-2.txt' FAILED ***\n-# CHECK: $ \"diff\" \"temp.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff temp.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-3.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-3.txt' FAILED ***\n-# CHECK: $ \"diff\" \"temp.txt\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'diff' command failed\n+# CHECK: diff temp.txt temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'diff' command failed\n # CHECK: error: command failed with exit status: 1\n # CHECK: ***\n \n-# CHECK: FAIL: shtest-shell :: diff-error-4.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-error-4.txt' FAILED ***\n-# CHECK: Exit Code: 1\n-# CHECK: # command output:\n-# CHECK: diff-error-4.txt.tmp\n-# CHECK: diff-error-4.txt.tmp1\n-# CHECK: *** 1 ****\n-# CHECK: ! hello-first\n-# CHECK: --- 1 ----\n-# CHECK: ! hello-second\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-error-4.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-error-4.txt' FAILED ***\n+#      CHECK: Exit Code: 1\n+#      CHECK: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | {{.*}}diff-error-4.txt.tmp\n+# CHECK-NEXT: # | {{.*}}diff-error-4.txt.tmp1\n+# CHECK-NEXT: # | {{\\*+}}\n+# CHECK-NEXT: # | *** 1 ****\n+# CHECK-NEXT: # | ! hello-first\n+# CHECK-NEXT: # | --- 1 ----\n+# CHECK-NEXT: # | ! hello-second\n+# CHECK-NEXT: # `---{{-*}}\n+#      CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-5.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-5.txt' FAILED ***\n-# CHECK: $ \"diff\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-6.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-6.txt' FAILED ***\n-# CHECK: $ \"diff\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n \n@@ -223,137 +233,130 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-pipes.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.foo\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"FileCheck\"\n+# CHECK: diff {{[^ ]*}}.foo {{.*}}.foo | FileCheck {{.*}}\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: note: command had no output on stdout or stderr\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"FileCheck\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"true\"\n+#      CHECK: diff -u {{.*}}.foo {{.*}}.bar | FileCheck {{.*}} && false || true\n+# CHECK-NEXT: # executed command: diff -u {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # note: command had no output on stdout or stderr\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: FileCheck\n+# CHECK-NEXT: # executed command: true\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"{{[^\"]*}}.foo\"\n+#     CHECK: cat {{.*}}.foo | diff -u - {{.*}}.foo\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n+#     CHECK: cat {{.*}}.foo | diff -u {{.*}}.foo -\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: +bar\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"{{[^\"]*}}.foo\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: +foo\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-\" \"{{[^\"]*}}.foo\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"FileCheck\"\n+#      CHECK: cat {{.*}}.bar | diff -u {{.*}}.foo - && false || true\n+# CHECK-NEXT: # executed command: cat {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # executed command: diff -u {{.+}}.foo{{.*}} -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat {{.*}}.bar | diff -u - {{.*}}.foo && false || true\n+# CHECK-NEXT: # executed command: cat {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # executed command: diff -u - {{.+}}.foo{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#     CHECK: cat {{.*}}.foo | diff - {{.*}}.foo | FileCheck {{.*}}\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n-# CHECK: note: command had no output on stdout or stderr\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"FileCheck\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"true\"\n+#      CHECK: cat {{.*}}.bar | diff -u {{.*}}.foo - | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: cat {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # executed command: diff -u {{.+}}.foo{{.*}} -\n+# CHECK-NEXT: note: command had no output on stdout or stderr\n+# CHECK-NEXT: error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: FileCheck\n+# CHECK-NEXT: # executed command: true\n \n-# CHECK: $ \"false\"\n+# CHECK: false\n \n # CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-r-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-0.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: dir1unique\n-# CHECK: Only in {{.*}}dir2: dir2unique\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: dir1unique\n+# CHECK: # | Only in {{.*}}dir2: dir2unique\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-1.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: *** {{.*}}dir1{{.*}}subdir{{.*}}f01\n-# CHECK: --- {{.*}}dir2{{.*}}subdir{{.*}}f01\n-# CHECK: 12345\n-# CHECK: 00000\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | *** {{.*}}dir1{{.*}}subdir{{.*}}f01\n+# CHECK: # | --- {{.*}}dir2{{.*}}subdir{{.*}}f01\n+# CHECK: # | ! 12345\n+# CHECK: # | ! 00000\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-2.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir2: extrafile\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir2: extrafile\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-3.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-3.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: extra_subdir\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: extra_subdir\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-4.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-4.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: File {{.*}}dir1{{.*}}extra_subdir is a directory while file {{.*}}dir2{{.*}}extra_subdir is a regular file\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | File {{.*}}dir1{{.*}}extra_subdir is a directory while file {{.*}}dir2{{.*}}extra_subdir is a regular file\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-5.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-5.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: extra_subdir\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: extra_subdir\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-6.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-6.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: File {{.*}}dir1{{.*}}extra_file is a regular empty file while file {{.*}}dir2{{.*}}extra_file is a directory\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | File {{.*}}dir1{{.*}}extra_file is a regular empty file while file {{.*}}dir2{{.*}}extra_file is a directory\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-7.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-7.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\" \"-\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: cannot recursively compare '-'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r - {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: cannot recursively compare '-'\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-8.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-8.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\" \"{{[^\"]*}}\" \"-\"\n-# CHECK: # command stderr:\n-# CHECK: Error: cannot recursively compare '-'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r {{.*}} -\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: cannot recursively compare '-'\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: PASS: shtest-shell :: diff-r.txt\n \n@@ -362,51 +365,59 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-strip-trailing-cr.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.dos\" \"diff-in.unix\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -In this file, the\n-# CHECK-NEXT: -sequence \"\\r\\n\"\n-# CHECK-NEXT: -terminates lines.\n-# CHECK-NEXT: +In this file, the\n-# CHECK-NEXT: +sequence \"\\n\"\n-# CHECK-NEXT: +terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.unix\" \"diff-in.dos\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -In this file, the\n-# CHECK-NEXT: -sequence \"\\n\"\n-# CHECK-NEXT: -terminates lines.\n-# CHECK-NEXT: +In this file, the\n-# CHECK-NEXT: +sequence \"\\r\\n\"\n-# CHECK-NEXT: +terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"--strip-trailing-cr\" \"diff-in.dos\" \"diff-in.unix\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT:  In this file, the\n-# CHECK-NEXT: -sequence \"\\r\\n\"\n-# CHECK-NEXT: +sequence \"\\n\"\n-# CHECK-NEXT:  terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"--strip-trailing-cr\" \"diff-in.unix\" \"diff-in.dos\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT:  In this file, the\n-# CHECK-NEXT: -sequence \"\\n\"\n-# CHECK-NEXT: +sequence \"\\r\\n\"\n-# CHECK-NEXT:  terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"false\"\n+#      CHECK: diff -u diff-in.dos diff-in.unix && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.dos diff-in.unix\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -In this file, the\n+# CHECK-NEXT: # | -sequence \"\\r\\n\"\n+# CHECK-NEXT: # | -terminates lines.\n+# CHECK-NEXT: # | +In this file, the\n+# CHECK-NEXT: # | +sequence \"\\n\"\n+# CHECK-NEXT: # | +terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.unix diff-in.dos && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.unix diff-in.dos\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -In this file, the\n+# CHECK-NEXT: # | -sequence \"\\n\"\n+# CHECK-NEXT: # | -terminates lines.\n+# CHECK-NEXT: # | +In this file, the\n+# CHECK-NEXT: # | +sequence \"\\r\\n\"\n+# CHECK-NEXT: # | +terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u --strip-trailing-cr diff-in.dos diff-in.unix && false || true\n+# CHECK-NEXT: executed command: diff -u --strip-trailing-cr diff-in.dos diff-in.unix\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # |  In this file, the\n+# CHECK-NEXT: # | -sequence \"\\r\\n\"\n+# CHECK-NEXT: # | +sequence \"\\n\"\n+# CHECK-NEXT: # |  terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u --strip-trailing-cr diff-in.unix diff-in.dos && false || true\n+# CHECK-NEXT: # executed command: diff -u --strip-trailing-cr diff-in.unix diff-in.dos\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # |  In this file, the\n+# CHECK-NEXT: # | -sequence \"\\n\"\n+# CHECK-NEXT: # | +sequence \"\\r\\n\"\n+# CHECK-NEXT: # |  terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n@@ -415,106 +426,144 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-unified.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 3\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-NEXT: 9\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U\" \"2\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U4\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 2\n-# CHECK-NEXT: 3\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-NEXT: 9\n-# CHECK-NEXT: 10\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U0\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U\" \"30.1\" \"{{[^\"]*}}\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: invalid '-U' argument: 30.1\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U-1\" \"{{[^\"]*}}\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: invalid '-U' argument: -1\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"false\"\n+#      CHECK: diff -u {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -u {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 3\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # | 9\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U 2 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U 2 {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U4 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U4 {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 2\n+# CHECK-NEXT: # | 3\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # | 9\n+# CHECK-NEXT: # | 10\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U0 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U0 {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: diff -U 30.1 {{.*}} {{.*}} && false || true\n+# CHECK: # executed command: diff -U 30.1 {{.*}} {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: invalid '-U' argument: 30.1\n+# CHECK: # error: command failed with exit status: 1\n+# CHECK: # executed command: true\n+\n+# CHECK: diff -U-1 {{.*}} {{.*}} && false || true\n+# CHECK: # executed command: diff -U-1 {{.*}} {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: invalid '-U' argument: -1\n+# CHECK: # error: command failed with exit status: 1\n+# CHECK: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n \n-# CHECK: FAIL: shtest-shell :: diff-w.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-w.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-w\" \"{{[^\"]*}}.0\" \"{{[^\"]*}}.1\"\n-# CHECK: # command output:\n-# CHECK: 1,3\n-# CHECK-NEXT: {{^  }}foo\n-# CHECK-NEXT: {{^  }}bar\n-# CHECK-NEXT: ! baz\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: {{^  }}foo\n-# CHECK-NEXT: {{^  }}bar\n-# CHECK-NEXT: ! bat\n-# CHECK-EMPTY:\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-w.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-w.txt' FAILED ***\n+#      CHECK: diff -w {{.*}}.0 {{.*}}.1\n+#      CHECK: # .---command stdout{{-*}}\n+#      CHECK: # | {{\\*+}} 1,3\n+# CHECK-NEXT: # |   foo\n+# CHECK-NEXT: # |   bar\n+# CHECK-NEXT: # | ! baz\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # |   foo\n+# CHECK-NEXT: # |   bar\n+# CHECK-NEXT: # | ! bat\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+#      CHECK: ***\n+\n+# CHECK: FAIL: shtest-shell :: echo-at-redirect-stderr.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-at-redirect-stderr.txt' FAILED ***\n+# CHECK: @echo 2> {{.*}}\n+# CHECK: # executed command: @echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for @echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-at-redirect-stdin.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-at-redirect-stdin.txt' FAILED ***\n+# CHECK: @echo < {{.*}}\n+# CHECK: # executed command: @echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for @echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-redirect-stderr.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-redirect-stderr.txt' FAILED ***\n+# CHECK: echo 2> {{.*}}\n+# CHECK: # executed command: echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-redirect-stdin.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-redirect-stdin.txt' FAILED ***\n+# CHECK: echo < {{.*}}\n+# CHECK: # executed command: echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for echo\n+# CHECK: error: command failed with exit status:\n \n # CHECK: FAIL: shtest-shell :: error-0.txt\n # CHECK: *** TEST 'shtest-shell :: error-0.txt' FAILED ***\n-# CHECK: $ \"not-a-real-command\"\n-# CHECK: # command stderr:\n-# CHECK: 'not-a-real-command': command not found\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: not-a-real-command\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | 'not-a-real-command': command not found\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # FIXME: The output here sucks.\n #\n # CHECK: FAIL: shtest-shell :: error-1.txt\n # CHECK: *** TEST 'shtest-shell :: error-1.txt' FAILED ***\n-# CHECK: shell parser error on: ': \\'RUN: at line 3\\'; echo \"missing quote'\n+# CHECK: shell parser error on RUN: at line 3: echo \"missing quote\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: error-2.txt\n@@ -524,52 +573,52 @@\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-0.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'mkdir' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p temp | rm -rf temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'mkdir' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-1.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\" \"-m\" \"777\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'mkdir': option -m not recognized\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p -m 777 temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'mkdir': option -m not recognized\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-2.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'mkdir' is missing an operand\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'mkdir' is missing an operand\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: PASS: shtest-shell :: redirects.txt\n \n # CHECK: FAIL: shtest-shell :: rm-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-0.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-rf\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'rm' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: rm -rf temp | echo \"hello\"\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'rm' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-1.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-f\" \"-v\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'rm': option -v not recognized\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: rm -f -v temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'rm': option -v not recognized\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-2.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-r\" \"hello\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'rm' command failed\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: rm -r hello\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'rm' command failed\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-3.txt\n@@ -581,16 +630,17 @@\n # CHECK: PASS: shtest-shell :: sequencing-0.txt\n # CHECK: XFAIL: shtest-shell :: sequencing-1.txt\n \n-# CHECK: FAIL: shtest-shell :: stdout-encoding.txt\n-# CHECK: *** TEST 'shtest-shell :: stdout-encoding.txt' FAILED ***\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: {{^.f.o.o.$}}\n-# CHECK-NEXT: {{^.b.a.r.}}\n-# CHECK-NEXT: {{^.b.a.z.$}}\n-# CHECK-NOT: error\n-# CHECK: $ \"false\"\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: stdout-encoding.txt\n+#      CHECK: *** TEST 'shtest-shell :: stdout-encoding.txt' FAILED ***\n+#      CHECK: cat diff-in.bin\n+#      CHECK: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+#  CHECK-NOT: error\n+#      CHECK: false\n+#      CHECK: ***\n \n # CHECK: PASS: shtest-shell :: valid-shell.txt\n-# CHECK: Failed Tests (35)\n+# CHECK: Failed Tests (39)\n", "message": "", "files": {"/libcxx/utils/libcxx/test/dsl.py": {"changes": [{"diff": "\n                 \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n             )\n \n-        return libcxx.test.format._parseLitOutput(out)\n+        return out\n \n \n @_memoizeExpensiveOperation(", "add": 1, "remove": 1, "filename": "/libcxx/utils/libcxx/test/dsl.py", "badparts": ["        return libcxx.test.format._parseLitOutput(out)"], "goodparts": ["        return out"]}]}, "/libcxx/utils/libcxx/test/format.py": {"changes": [{"diff": "\n     for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n         assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n \n-def _parseLitOutput(fullOutput):\n-    \"\"\"\n-    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n-\n-    This takes output of the form\n-\n-        $ \":\" \"RUN: at line 11\"\n-        $ \"echo\" \"OUTPUT1\"\n-        # command output:\n-        OUTPUT1\n-\n-        $ \":\" \"RUN: at line 12\"\n-        $ \"echo\" \"OUTPUT2\"\n-        # command output:\n-        OUTPUT2\n-\n-    and returns a string containing\n-\n-        OUTPUT1\n-        OUTPUT2\n-\n-    as-if the commands had been run directly. This is a workaround for the fact\n-    that Lit doesn't let us execute ShTest and retrieve the raw output without\n-    injecting additional Lit output around it.\n-    \"\"\"\n-    parsed = ''\n-    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n-        if output: # skip blank lines\n-            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n-            if commandOutput:\n-                parsed += commandOutput.group(1)\n-    return parsed\n-\n def _executeScriptInternal(test, litConfig, commands):\n     \"\"\"\n     Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n", "add": 0, "remove": 33, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["def _parseLitOutput(fullOutput):", "    \"\"\"", "    Parse output of a Lit ShTest to extract the actual output of the contained commands.", "    This takes output of the form", "        $ \":\" \"RUN: at line 11\"", "        $ \"echo\" \"OUTPUT1\"", "        OUTPUT1", "        $ \":\" \"RUN: at line 12\"", "        $ \"echo\" \"OUTPUT2\"", "        OUTPUT2", "    and returns a string containing", "        OUTPUT1", "        OUTPUT2", "    as-if the commands had been run directly. This is a workaround for the fact", "    that Lit doesn't let us execute ShTest and retrieve the raw output without", "    injecting additional Lit output around it.", "    \"\"\"", "    parsed = ''", "    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):", "        if output: # skip blank lines", "            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)", "            if commandOutput:", "                parsed += commandOutput.group(1)", "    return parsed"], "goodparts": []}, {"diff": "\n     _, tmpBase = _getTempPaths(test)\n     execDir = os.path.dirname(test.getExecPath())\n     res = lit.TestRunner.executeScriptInternal(\n-        test, litConfig, tmpBase, parsedCommands, execDir\n+        test, litConfig, tmpBase, parsedCommands, execDir, debug=False\n     )\n     if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n         res = (\"\", res.output, 127, None)\n     (out, err, exitCode, timeoutInfo) = res\n \n-    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n-    #       split any stderr output that is included in stdout. It shouldn't be there, but\n-    #       the Lit internal shell conflates stderr and stdout.\n-    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n-    if conflatedErrorOutput:\n-        conflatedErrorOutput = conflatedErrorOutput.group(0)\n-        out = out[: -len(conflatedErrorOutput)]\n-        err += conflatedErrorOutput\n-\n     return (out, err, exitCode, timeoutInfo, parsedCommands)\n \n \n", "add": 1, "remove": 10, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["        test, litConfig, tmpBase, parsedCommands, execDir", "    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)", "    if conflatedErrorOutput:", "        conflatedErrorOutput = conflatedErrorOutput.group(0)", "        out = out[: -len(conflatedErrorOutput)]", "        err += conflatedErrorOutput"], "goodparts": ["        test, litConfig, tmpBase, parsedCommands, execDir, debug=False"]}, {"diff": "\n             raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n \n         # Split the generated output into multiple files and generate one test for each file\n-        parsed = _parseLitOutput(out)\n-        for (subfile, content) in self._splitFile(parsed):\n-            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n+        for subfile, content in self._splitFile(out):\n+            generatedFile = testSuite.getExecPath(pathInSuite + (subfile,))\n             os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n             with open(generatedFile, 'w') as f:\n                 f.write(content", "add": 2, "remove": 3, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["        parsed = _parseLitOutput(out)", "        for (subfile, content) in self._splitFile(parsed):", "            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))"], "goodparts": ["        for subfile, content in self._splitFile(out):", "            generatedFile = testSuite.getExecPath(pathInSuite + (subfile,))"]}], "source": "\n import contextlib import io import lit import lit.formats import os import pipes import re import shutil def _getTempPaths(test): \"\"\" Return the values to use for the %T and %t substitutions, respectively. The difference between this and Lit's default behavior is that we guarantee that %T is a path unique to the test being run. \"\"\" tmpDir, _=lit.TestRunner.getTempPaths(test) _, testName=os.path.split(test.getExecPath()) tmpDir=os.path.join(tmpDir, testName +\".dir\") tmpBase=os.path.join(tmpDir, \"t\") return tmpDir, tmpBase def _checkBaseSubstitutions(substitutions): substitutions=[s for(s, _) in substitutions] for s in[\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]: assert s in substitutions, \"Required substitution{} was not provided\".format(s) def _parseLitOutput(fullOutput): \"\"\" Parse output of a Lit ShTest to extract the actual output of the contained commands. This takes output of the form $ \":\" \"RUN: at line 11\" $ \"echo\" \"OUTPUT1\" OUTPUT1 $ \":\" \"RUN: at line 12\" $ \"echo\" \"OUTPUT2\" OUTPUT2 and returns a string containing OUTPUT1 OUTPUT2 as-if the commands had been run directly. This is a workaround for the fact that Lit doesn't let us execute ShTest and retrieve the raw output without injecting additional Lit output around it. \"\"\" parsed='' for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput): if output: commandOutput=re.search(\" if commandOutput: parsed +=commandOutput.group(1) return parsed def _executeScriptInternal(test, litConfig, commands): \"\"\" Returns(stdout, stderr, exitCode, timeoutInfo, parsedCommands) TODO: This really should be easier to access from Lit itself \"\"\" parsedCommands=parseScript(test, preamble=commands) _, tmpBase=_getTempPaths(test) execDir=os.path.dirname(test.getExecPath()) res=lit.TestRunner.executeScriptInternal( test, litConfig, tmpBase, parsedCommands, execDir ) if isinstance(res, lit.Test.Result): res=(\"\", res.output, 127, None) (out, err, exitCode, timeoutInfo)=res conflatedErrorOutput=re.search(\"( if conflatedErrorOutput: conflatedErrorOutput=conflatedErrorOutput.group(0) out=out[: -len(conflatedErrorOutput)] err +=conflatedErrorOutput return(out, err, exitCode, timeoutInfo, parsedCommands) def parseScript(test, preamble): \"\"\" Extract the script from a test, with substitutions applied. Returns a list of commands ready to be executed. -test The lit.Test to parse. -preamble A list of commands to perform before any command in the test. These commands can contain unexpanded substitutions, but they must not be of the form 'RUN:' --they must be proper commands once substituted. \"\"\" tmpDir, tmpBase=_getTempPaths(test) substitutions=lit.TestRunner.getDefaultSubstitutions(test, tmpDir, tmpBase) _checkBaseSubstitutions(substitutions) substitutions.append( (\"%{build}\", \"%{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\") ) substitutions.append((\"%{run}\", \"%{exec} %t.exe\")) additionalCompileFlags=[] fileDependencies=[] parsers=[ lit.TestRunner.IntegratedTestKeywordParser( \"FILE_DEPENDENCIES:\", lit.TestRunner.ParserKind.LIST, initial_value=fileDependencies, ), lit.TestRunner.IntegratedTestKeywordParser( \"ADDITIONAL_COMPILE_FLAGS:\", lit.TestRunner.ParserKind.LIST, initial_value=additionalCompileFlags, ), ] for feature in test.config.available_features: parser=lit.TestRunner.IntegratedTestKeywordParser( \"ADDITIONAL_COMPILE_FLAGS({}):\".format(feature), lit.TestRunner.ParserKind.LIST, initial_value=additionalCompileFlags, ) parsers.append(parser) scriptInTest=lit.TestRunner.parseIntegratedTestScript( test, additional_parsers=parsers, require_script=not preamble ) if isinstance(scriptInTest, lit.Test.Result): return scriptInTest script=[] for dep in fileDependencies: script +=[\"%dbg(SETUP) cd %S && cp{} %T\".format(dep)] script +=preamble script +=scriptInTest substitutions=[ (s, x +\" \" +\" \".join(additionalCompileFlags)) if s==\"%{compile_flags}\" else(s, x) for(s, x) in substitutions ] script=lit.TestRunner.applySubstitutions( script, substitutions, recursion_limit=test.config.recursiveExpansionLimit ) return script class CxxStandardLibraryTest(lit.formats.FileBasedTest): \"\"\" Lit test format for the C++Standard Library conformance test suite. This test format is based on top of the ShTest format --it basically creates a shell script performing the right operations(compile/link/run) based on the extension of the test file it encounters. It supports files with the following extensions: FOO.pass.cpp -Compiles, links and runs successfully FOO.pass.mm -Same as.pass.cpp, but for Objective-C++ FOO.compile.pass.cpp -Compiles successfully, link and run not attempted FOO.compile.pass.mm -Same as.compile.pass.cpp, but for Objective-C++ FOO.compile.fail.cpp -Does not compile successfully FOO.link.pass.cpp -Compiles and links successfully, run not attempted FOO.link.pass.mm -Same as.link.pass.cpp, but for Objective-C++ FOO.link.fail.cpp -Compiles successfully, but fails to link FOO.sh.<anything> -A builtin Lit Shell test FOO.gen.<anything> -A.sh test that generates one or more Lit tests on the fly. Executing this test must generate one or more files as expected by LLVM split-file, and each generated file leads to a separate Lit test that runs that file as defined by the test format. This can be used to generate multiple Lit tests from a single source file, which is useful for testing repetitive properties in the library. Be careful not to abuse this since this is not a replacement for usual code reuse techniques. FOO.verify.cpp -Compiles with clang-verify. This type of test is automatically marked as UNSUPPORTED if the compiler does not support Clang-verify. Substitution requirements =============================== The test format operates by assuming that each test's configuration provides the following substitutions, which it will reuse in the shell scripts it constructs: %{cxx} -A command that can be used to invoke the compiler %{compile_flags} -Flags to use when compiling a test case %{link_flags} -Flags to use when linking a test case %{flags} -Flags to use either when compiling or linking a test case %{exec} -A command to prefix the execution of executables Note that when building an executable(as opposed to only compiling a source file), all three of %{flags}, %{compile_flags} and %{link_flags} will be used in the same command line. In other words, the test format doesn't perform separate compilation and linking steps in this case. Additional supported directives =============================== In addition to everything that's supported in Lit ShTests, this test format also understands the following directives inside test files: // FILE_DEPENDENCIES: file, directory, /path/to/file This directive expresses that the test requires the provided files or directories in order to run. An example is a test that requires some test input stored in a data file. When a test file contains such a directive, this test format will collect them and copy them to the directory represented by %T. The intent is that %T contains all the inputs necessary to run the test, such that e.g. execution on a remote host can be done by simply copying %T to the host. // ADDITIONAL_COMPILE_FLAGS: flag1, flag2, flag3 This directive will cause the provided flags to be added to the %{compile_flags} substitution for the test that contains it. This allows adding special compilation flags without having to use a .sh.cpp test, which would be more powerful but perhaps overkill. Additional provided substitutions and features ============================================== The test format will define the following substitutions for use inside tests: %{build} Expands to a command-line that builds the current source file with the %{flags}, %{compile_flags} and %{link_flags} substitutions, and that produces an executable named %t.exe. %{run} Equivalent to `%{exec} %t.exe`. This is intended to be used in conjunction with the %{build} substitution. \"\"\" def getTestsForPath(self, testSuite, pathInSuite, litConfig, localConfig): SUPPORTED_SUFFIXES=[ \"[.]pass[.]cpp$\", \"[.]pass[.]mm$\", \"[.]compile[.]pass[.]cpp$\", \"[.]compile[.]pass[.]mm$\", \"[.]compile[.]fail[.]cpp$\", \"[.]link[.]pass[.]cpp$\", \"[.]link[.]pass[.]mm$\", \"[.]link[.]fail[.]cpp$\", \"[.]sh[.][^.]+$\", \"[.]gen[.][^.]+$\", \"[.]verify[.]cpp$\", \"[.]fail[.]cpp$\", ] sourcePath=testSuite.getSourcePath(pathInSuite) filename=os.path.basename(sourcePath) hasSupportedSuffix=lambda f: any([re.search(ext, f) for ext in SUPPORTED_SUFFIXES]) if filename.startswith(\".\") or filename in localConfig.excludes or not hasSupportedSuffix(filename): return if re.search('[.]gen[.][^.]+$', filename): for test in self._generateGenTest(testSuite, pathInSuite, litConfig, localConfig): yield test else: yield lit.Test.Test(testSuite, pathInSuite, localConfig) def execute(self, test, litConfig): VERIFY_FLAGS=( \"-Xclang -verify -Xclang -verify-ignore-unexpected=note -ferror-limit=0\" ) supportsVerify=\"verify-support\" in test.config.available_features filename=test.path_in_suite[-1] if re.search(\"[.]sh[.][^.]+$\", filename): steps=[] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".compile.pass.cpp\") or filename.endswith( \".compile.pass.mm\" ): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".compile.fail.cpp\"): steps=[ \"%dbg(COMPILED WITH) ! %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".link.pass.cpp\") or filename.endswith(\".link.pass.mm\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".link.fail.cpp\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -c -o %t.o\", \"%dbg(LINKED WITH) ! %{cxx} %t.o %{flags} %{link_flags} -o %t.exe\", ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".verify.cpp\"): if not supportsVerify: return lit.Test.Result( lit.Test.UNSUPPORTED, \"Test{} requires support for Clang-verify, which isn't supported by the compiler\".format( test.getFullName() ), ) steps=[ \"%dbg(COMPILED WITH) %{{cxx}} %s %{{flags}} %{{compile_flags}} -fsyntax-only -Wno-error{}\".format( VERIFY_FLAGS ) ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".pass.cpp\") or filename.endswith(\".pass.mm\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\", \"%dbg(EXECUTED AS) %{exec} %t.exe\", ] return self._executeShTest(test, litConfig, steps) else: return lit.Test.Result( lit.Test.UNRESOLVED, \"Unknown test suffix for '{}'\".format(filename) ) def _executeShTest(self, test, litConfig, steps): if test.config.unsupported: return lit.Test.Result(lit.Test.UNSUPPORTED, \"Test is unsupported\") script=parseScript(test, steps) if isinstance(script, lit.Test.Result): return script if litConfig.noExecute: return lit.Test.Result( lit.Test.XFAIL if test.isExpectedToFail() else lit.Test.PASS ) else: _, tmpBase=_getTempPaths(test) useExternalSh=False return lit.TestRunner._runShTest( test, litConfig, useExternalSh, script, tmpBase ) def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig): generator=lit.Test.Test(testSuite, pathInSuite, localConfig) generatorExecDir=os.path.dirname(testSuite.getExecPath(pathInSuite)) os.makedirs(generatorExecDir, exist_ok=True) steps=[] (out, err, exitCode, _, _)=_executeScriptInternal(generator, litConfig, steps) if exitCode !=0: raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\") parsed=_parseLitOutput(out) for(subfile, content) in self._splitFile(parsed): generatedFile=testSuite.getExecPath(pathInSuite +(subfile,)) os.makedirs(os.path.dirname(generatedFile), exist_ok=True) with open(generatedFile, 'w') as f: f.write(content) yield lit.Test.Test(testSuite,(generatedFile,), localConfig) def _splitFile(self, input): DELIM=r'^(//| lines=input.splitlines() currentFile=None thisFileContent=[] for line in lines: match=re.match(DELIM, line) if match: if currentFile is not None: yield(currentFile, '\\n'.join(thisFileContent)) currentFile=match.group(2).strip() thisFileContent=[] assert currentFile is not None, f\"Some input to split-file doesn't belong to any file, input was:\\n{input}\" thisFileContent.append(line) if currentFile is not None: yield(currentFile, '\\n'.join(thisFileContent)) ", "sourceWithComments": "# ===----------------------------------------------------------------------===##\n#\n# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n# See https://llvm.org/LICENSE.txt for license information.\n# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n#\n# ===----------------------------------------------------------------------===##\n\nimport contextlib\nimport io\nimport lit\nimport lit.formats\nimport os\nimport pipes\nimport re\nimport shutil\n\n\ndef _getTempPaths(test):\n    \"\"\"\n    Return the values to use for the %T and %t substitutions, respectively.\n\n    The difference between this and Lit's default behavior is that we guarantee\n    that %T is a path unique to the test being run.\n    \"\"\"\n    tmpDir, _ = lit.TestRunner.getTempPaths(test)\n    _, testName = os.path.split(test.getExecPath())\n    tmpDir = os.path.join(tmpDir, testName + \".dir\")\n    tmpBase = os.path.join(tmpDir, \"t\")\n    return tmpDir, tmpBase\n\n\ndef _checkBaseSubstitutions(substitutions):\n    substitutions = [s for (s, _) in substitutions]\n    for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n        assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n\ndef _parseLitOutput(fullOutput):\n    \"\"\"\n    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n\n    This takes output of the form\n\n        $ \":\" \"RUN: at line 11\"\n        $ \"echo\" \"OUTPUT1\"\n        # command output:\n        OUTPUT1\n\n        $ \":\" \"RUN: at line 12\"\n        $ \"echo\" \"OUTPUT2\"\n        # command output:\n        OUTPUT2\n\n    and returns a string containing\n\n        OUTPUT1\n        OUTPUT2\n\n    as-if the commands had been run directly. This is a workaround for the fact\n    that Lit doesn't let us execute ShTest and retrieve the raw output without\n    injecting additional Lit output around it.\n    \"\"\"\n    parsed = ''\n    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n        if output: # skip blank lines\n            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n            if commandOutput:\n                parsed += commandOutput.group(1)\n    return parsed\n\ndef _executeScriptInternal(test, litConfig, commands):\n    \"\"\"\n    Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n\n    TODO: This really should be easier to access from Lit itself\n    \"\"\"\n    parsedCommands = parseScript(test, preamble=commands)\n\n    _, tmpBase = _getTempPaths(test)\n    execDir = os.path.dirname(test.getExecPath())\n    res = lit.TestRunner.executeScriptInternal(\n        test, litConfig, tmpBase, parsedCommands, execDir\n    )\n    if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n        res = (\"\", res.output, 127, None)\n    (out, err, exitCode, timeoutInfo) = res\n\n    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n    #       split any stderr output that is included in stdout. It shouldn't be there, but\n    #       the Lit internal shell conflates stderr and stdout.\n    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n    if conflatedErrorOutput:\n        conflatedErrorOutput = conflatedErrorOutput.group(0)\n        out = out[: -len(conflatedErrorOutput)]\n        err += conflatedErrorOutput\n\n    return (out, err, exitCode, timeoutInfo, parsedCommands)\n\n\ndef parseScript(test, preamble):\n    \"\"\"\n    Extract the script from a test, with substitutions applied.\n\n    Returns a list of commands ready to be executed.\n\n    - test\n        The lit.Test to parse.\n\n    - preamble\n        A list of commands to perform before any command in the test.\n        These commands can contain unexpanded substitutions, but they\n        must not be of the form 'RUN:' -- they must be proper commands\n        once substituted.\n    \"\"\"\n    # Get the default substitutions\n    tmpDir, tmpBase = _getTempPaths(test)\n    substitutions = lit.TestRunner.getDefaultSubstitutions(test, tmpDir, tmpBase)\n\n    # Check base substitutions and add the %{build} and %{run} convenience substitutions\n    _checkBaseSubstitutions(substitutions)\n    substitutions.append(\n        (\"%{build}\", \"%{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\")\n    )\n    substitutions.append((\"%{run}\", \"%{exec} %t.exe\"))\n\n    # Parse the test file, including custom directives\n    additionalCompileFlags = []\n    fileDependencies = []\n    parsers = [\n        lit.TestRunner.IntegratedTestKeywordParser(\n            \"FILE_DEPENDENCIES:\",\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=fileDependencies,\n        ),\n        lit.TestRunner.IntegratedTestKeywordParser(\n            \"ADDITIONAL_COMPILE_FLAGS:\",\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=additionalCompileFlags,\n        ),\n    ]\n\n    # Add conditional parsers for ADDITIONAL_COMPILE_FLAGS. This should be replaced by first\n    # class support for conditional keywords in Lit, which would allow evaluating arbitrary\n    # Lit boolean expressions instead.\n    for feature in test.config.available_features:\n        parser = lit.TestRunner.IntegratedTestKeywordParser(\n            \"ADDITIONAL_COMPILE_FLAGS({}):\".format(feature),\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=additionalCompileFlags,\n        )\n        parsers.append(parser)\n\n    scriptInTest = lit.TestRunner.parseIntegratedTestScript(\n        test, additional_parsers=parsers, require_script=not preamble\n    )\n    if isinstance(scriptInTest, lit.Test.Result):\n        return scriptInTest\n\n    script = []\n\n    # For each file dependency in FILE_DEPENDENCIES, inject a command to copy\n    # that file to the execution directory. Execute the copy from %S to allow\n    # relative paths from the test directory.\n    for dep in fileDependencies:\n        script += [\"%dbg(SETUP) cd %S && cp {} %T\".format(dep)]\n    script += preamble\n    script += scriptInTest\n\n    # Add compile flags specified with ADDITIONAL_COMPILE_FLAGS.\n    substitutions = [\n        (s, x + \" \" + \" \".join(additionalCompileFlags))\n        if s == \"%{compile_flags}\"\n        else (s, x)\n        for (s, x) in substitutions\n    ]\n\n    # Perform substitutions in the script itself.\n    script = lit.TestRunner.applySubstitutions(\n        script, substitutions, recursion_limit=test.config.recursiveExpansionLimit\n    )\n\n    return script\n\n\nclass CxxStandardLibraryTest(lit.formats.FileBasedTest):\n    \"\"\"\n    Lit test format for the C++ Standard Library conformance test suite.\n\n    This test format is based on top of the ShTest format -- it basically\n    creates a shell script performing the right operations (compile/link/run)\n    based on the extension of the test file it encounters. It supports files\n    with the following extensions:\n\n    FOO.pass.cpp            - Compiles, links and runs successfully\n    FOO.pass.mm             - Same as .pass.cpp, but for Objective-C++\n\n    FOO.compile.pass.cpp    - Compiles successfully, link and run not attempted\n    FOO.compile.pass.mm     - Same as .compile.pass.cpp, but for Objective-C++\n    FOO.compile.fail.cpp    - Does not compile successfully\n\n    FOO.link.pass.cpp       - Compiles and links successfully, run not attempted\n    FOO.link.pass.mm        - Same as .link.pass.cpp, but for Objective-C++\n    FOO.link.fail.cpp       - Compiles successfully, but fails to link\n\n    FOO.sh.<anything>       - A builtin Lit Shell test\n\n    FOO.gen.<anything>      - A .sh test that generates one or more Lit tests on the\n                              fly. Executing this test must generate one or more files\n                              as expected by LLVM split-file, and each generated file\n                              leads to a separate Lit test that runs that file as\n                              defined by the test format. This can be used to generate\n                              multiple Lit tests from a single source file, which is\n                              useful for testing repetitive properties in the library.\n                              Be careful not to abuse this since this is not a replacement\n                              for usual code reuse techniques.\n\n    FOO.verify.cpp          - Compiles with clang-verify. This type of test is\n                              automatically marked as UNSUPPORTED if the compiler\n                              does not support Clang-verify.\n\n\n    Substitution requirements\n    ===============================\n    The test format operates by assuming that each test's configuration provides\n    the following substitutions, which it will reuse in the shell scripts it\n    constructs:\n        %{cxx}           - A command that can be used to invoke the compiler\n        %{compile_flags} - Flags to use when compiling a test case\n        %{link_flags}    - Flags to use when linking a test case\n        %{flags}         - Flags to use either when compiling or linking a test case\n        %{exec}          - A command to prefix the execution of executables\n\n    Note that when building an executable (as opposed to only compiling a source\n    file), all three of %{flags}, %{compile_flags} and %{link_flags} will be used\n    in the same command line. In other words, the test format doesn't perform\n    separate compilation and linking steps in this case.\n\n\n    Additional supported directives\n    ===============================\n    In addition to everything that's supported in Lit ShTests, this test format\n    also understands the following directives inside test files:\n\n        // FILE_DEPENDENCIES: file, directory, /path/to/file\n\n            This directive expresses that the test requires the provided files\n            or directories in order to run. An example is a test that requires\n            some test input stored in a data file. When a test file contains\n            such a directive, this test format will collect them and copy them\n            to the directory represented by %T. The intent is that %T contains\n            all the inputs necessary to run the test, such that e.g. execution\n            on a remote host can be done by simply copying %T to the host.\n\n        // ADDITIONAL_COMPILE_FLAGS: flag1, flag2, flag3\n\n            This directive will cause the provided flags to be added to the\n            %{compile_flags} substitution for the test that contains it. This\n            allows adding special compilation flags without having to use a\n            .sh.cpp test, which would be more powerful but perhaps overkill.\n\n\n    Additional provided substitutions and features\n    ==============================================\n    The test format will define the following substitutions for use inside tests:\n\n        %{build}\n            Expands to a command-line that builds the current source\n            file with the %{flags}, %{compile_flags} and %{link_flags}\n            substitutions, and that produces an executable named %t.exe.\n\n        %{run}\n            Equivalent to `%{exec} %t.exe`. This is intended to be used\n            in conjunction with the %{build} substitution.\n    \"\"\"\n\n    def getTestsForPath(self, testSuite, pathInSuite, litConfig, localConfig):\n        SUPPORTED_SUFFIXES = [\n            \"[.]pass[.]cpp$\",\n            \"[.]pass[.]mm$\",\n            \"[.]compile[.]pass[.]cpp$\",\n            \"[.]compile[.]pass[.]mm$\",\n            \"[.]compile[.]fail[.]cpp$\",\n            \"[.]link[.]pass[.]cpp$\",\n            \"[.]link[.]pass[.]mm$\",\n            \"[.]link[.]fail[.]cpp$\",\n            \"[.]sh[.][^.]+$\",\n            \"[.]gen[.][^.]+$\",\n            \"[.]verify[.]cpp$\",\n            \"[.]fail[.]cpp$\",\n        ]\n\n        sourcePath = testSuite.getSourcePath(pathInSuite)\n        filename = os.path.basename(sourcePath)\n\n        # Ignore dot files, excluded tests and tests with an unsupported suffix\n        hasSupportedSuffix = lambda f: any([re.search(ext, f) for ext in SUPPORTED_SUFFIXES])\n        if filename.startswith(\".\") or filename in localConfig.excludes or not hasSupportedSuffix(filename):\n            return\n\n        # If this is a generated test, run the generation step and add\n        # as many Lit tests as necessary.\n        if re.search('[.]gen[.][^.]+$', filename):\n            for test in self._generateGenTest(testSuite, pathInSuite, litConfig, localConfig):\n                yield test\n        else:\n            yield lit.Test.Test(testSuite, pathInSuite, localConfig)\n\n    def execute(self, test, litConfig):\n        VERIFY_FLAGS = (\n            \"-Xclang -verify -Xclang -verify-ignore-unexpected=note -ferror-limit=0\"\n        )\n        supportsVerify = \"verify-support\" in test.config.available_features\n        filename = test.path_in_suite[-1]\n\n        if re.search(\"[.]sh[.][^.]+$\", filename):\n            steps = []  # The steps are already in the script\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".compile.pass.cpp\") or filename.endswith(\n            \".compile.pass.mm\"\n        ):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".compile.fail.cpp\"):\n            steps = [\n                \"%dbg(COMPILED WITH) ! %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".link.pass.cpp\") or filename.endswith(\".link.pass.mm\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".link.fail.cpp\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -c -o %t.o\",\n                \"%dbg(LINKED WITH) ! %{cxx} %t.o %{flags} %{link_flags} -o %t.exe\",\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".verify.cpp\"):\n            if not supportsVerify:\n                return lit.Test.Result(\n                    lit.Test.UNSUPPORTED,\n                    \"Test {} requires support for Clang-verify, which isn't supported by the compiler\".format(\n                        test.getFullName()\n                    ),\n                )\n            steps = [\n                # Note: Use -Wno-error to make sure all diagnostics are not treated as errors,\n                #       which doesn't make sense for clang-verify tests.\n                \"%dbg(COMPILED WITH) %{{cxx}} %s %{{flags}} %{{compile_flags}} -fsyntax-only -Wno-error {}\".format(\n                    VERIFY_FLAGS\n                )\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        # Make sure to check these ones last, since they will match other\n        # suffixes above too.\n        elif filename.endswith(\".pass.cpp\") or filename.endswith(\".pass.mm\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\",\n                \"%dbg(EXECUTED AS) %{exec} %t.exe\",\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        else:\n            return lit.Test.Result(\n                lit.Test.UNRESOLVED, \"Unknown test suffix for '{}'\".format(filename)\n            )\n\n    def _executeShTest(self, test, litConfig, steps):\n        if test.config.unsupported:\n            return lit.Test.Result(lit.Test.UNSUPPORTED, \"Test is unsupported\")\n\n        script = parseScript(test, steps)\n        if isinstance(script, lit.Test.Result):\n            return script\n\n        if litConfig.noExecute:\n            return lit.Test.Result(\n                lit.Test.XFAIL if test.isExpectedToFail() else lit.Test.PASS\n            )\n        else:\n            _, tmpBase = _getTempPaths(test)\n            useExternalSh = False\n            return lit.TestRunner._runShTest(\n                test, litConfig, useExternalSh, script, tmpBase\n            )\n\n    def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig):\n        generator = lit.Test.Test(testSuite, pathInSuite, localConfig)\n\n        # Make sure we have a directory to execute the generator test in\n        generatorExecDir = os.path.dirname(testSuite.getExecPath(pathInSuite))\n        os.makedirs(generatorExecDir, exist_ok=True)\n\n        # Run the generator test\n        steps = [] # Steps must already be in the script\n        (out, err, exitCode, _, _) = _executeScriptInternal(generator, litConfig, steps)\n        if exitCode != 0:\n            raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n\n        # Split the generated output into multiple files and generate one test for each file\n        parsed = _parseLitOutput(out)\n        for (subfile, content) in self._splitFile(parsed):\n            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n            os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n            with open(generatedFile, 'w') as f:\n                f.write(content)\n            yield lit.Test.Test(testSuite, (generatedFile,), localConfig)\n\n    def _splitFile(self, input):\n        DELIM = r'^(//|#)---(.+)'\n        lines = input.splitlines()\n        currentFile = None\n        thisFileContent = []\n        for line in lines:\n            match = re.match(DELIM, line)\n            if match:\n                if currentFile is not None:\n                    yield (currentFile, '\\n'.join(thisFileContent))\n                currentFile = match.group(2).strip()\n                thisFileContent = []\n            assert currentFile is not None, f\"Some input to split-file doesn't belong to any file, input was:\\n{input}\"\n            thisFileContent.append(line)\n        if currentFile is not None:\n            yield (currentFile, '\\n'.join(thisFileContent))\n"}}, "msg": "[lit] Improve test output from lit's internal shell\n\nThis patch and D154984 were discussed in\n<https://discourse.llvm.org/t/rfc-improving-lits-debug-output/72839>.\n\nMotivation\n----------\n\nD154984 removes the \"Script:\" section that lit prints along with a\ntest's output, and it makes -v and -a imply -vv.  For example, after\nD154984, the \"Script:\" section below is never shown, but -v is enough\nto produce the execution trace following it:\n\n```\n Script:\n --\n : 'RUN: at line 1'; echo hello | FileCheck bogus.txt && echo success\n --\n Exit Code: 2\n\n Command Output (stdout):\n --\n $ \":\" \"RUN: at line 1\"\n $ \"echo\" \"hello\"\n # command output:\n hello\n\n $ \"FileCheck\" \"bogus.txt\"\n # command stderr:\n Could not open check file 'bogus.txt': No such file or directory\n\n error: command failed with exit status: 2\n\n --\n```\n\nIn the D154984 review, some reviewers point out that they have been\nusing the \"Script:\" section for copying and pasting a test's shell\ncommands to a terminal window.  The shell commands as printed in the\nexecution trace can be harder to copy and paste for the following\nreasons:\n\n- They drop redirections and break apart RUN lines at `&&`, `|`, etc.\n- They add `$` at the start of every command, which makes it hard to\n  copy and paste multiple commands in bulk.\n- Command stdout, stderr, etc. are interleaved with the commands and\n  are not clearly delineated.\n- They don't always use proper shell quoting.  Instead, they blindly\n  enclose all command-line arguments in double quotes.\n\nChanges\n-------\n\nD154984 plus this patch converts the above example into:\n\n```\n Exit Code: 2\n\n Command Output (stdout):\n --\n # RUN: at line 1\n echo hello | FileCheck bogus-file.txt && echo success\n # executed command: echo hello\n # .---command stdout------------\n # | hello\n # `-----------------------------\n # executed command: FileCheck bogus-file.txt\n # .---command stderr------------\n # | Could not open check file 'bogus-file.txt': No such file or directory\n # `-----------------------------\n # error: command failed with exit status: 2\n\n --\n```\n\nThus, this patch addresses the above issues as follows:\n\n- The entire execution trace can be copied and pasted in bulk to a\n  terminal for correct execution of the RUN lines, which are printed\n  intact as they appeared in the original RUN lines except lit\n  substitutions are expanded.  Everything else in the execution trace\n  appears in shell comments so it has no effect in a terminal.\n- Each of the RUN line's commands is repeated (in shell comments) as\n  it executes to show (1) that the command actually executed (e.g.,\n  `echo success` above didn't) and (2) what stdout, stderr, non-zero\n  exit status, and output files are associated with the command, if\n  any.  Shell quoting in the command is now correct and minimal but is\n  not necessarily the original shell quoting from the RUN line.\n- The start and end of the contents of stdout, stderr, or an output\n  file is now delineated clearly in the trace.\n\nTo help produce some of the above output, this patch extends lit's\ninternal shell with a built-in `@echo` command.  It's like `echo`\nexcept lit suppresses the normal execution trace for `@echo` and just\nprints its stdout directly.  For now, `@echo` isn't documented for use\nin lit tests.\n\nWithout this patch, libcxx's custom lit test format tries to parse the\nstdout from `lit.TestRunner.executeScriptInternal` (which runs lit's\ninternal shell) to extract the stdout and stderr produced by shell\ncommands, and that parse no longer works after the above changes.\nThis patch makes a small adjustment to\n`lit.TestRunner.executeScriptInternal` so libcxx can just request\nstdout and stderr without an execution trace.\n\n(As a minor drive-by fix that came up in testing: lit's internal `not`\ncommand now always produces a numeric exit status and never `True`.)\n\nCaveat\n------\n\nThis patch only makes the above changes for lit's internal shell.  In\nmost cases, we do not know how to force external shells (e.g., bash,\nsh, window's `cmd`) to produce execution traces in the manner we want.\n\nTo configure a test suite to use lit's internal shell (which is\nusually better for test portability than external shells anyway), add\nthis to the test suite's `lit.cfg` or other configuration file:\n\n```\nconfig.test_format = lit.formats.ShTest(execute_external=False)\n```\n\nReviewed By: MaskRay, awarzynski\n\nDifferential Revision: https://reviews.llvm.org/D156954"}}, "https://github.com/linux4life798/llvm-project-ci-test": {"c981c533055e14302e7bff5d6898c9308065f665": {"url": "https://api.github.com/repos/linux4life798/llvm-project-ci-test/commits/c981c533055e14302e7bff5d6898c9308065f665", "html_url": "https://github.com/linux4life798/llvm-project-ci-test/commit/c981c533055e14302e7bff5d6898c9308065f665", "sha": "c981c533055e14302e7bff5d6898c9308065f665", "keyword": "execution after redirect correct", "diff": "diff --git a/libcxx/utils/libcxx/test/dsl.py b/libcxx/utils/libcxx/test/dsl.py\nindex 847cebf5962f..4c2217ec3142 100644\n--- a/libcxx/utils/libcxx/test/dsl.py\n+++ b/libcxx/utils/libcxx/test/dsl.py\n@@ -180,7 +180,7 @@ def programOutput(config, program, args=None):\n                 \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n             )\n \n-        return libcxx.test.format._parseLitOutput(out)\n+        return out\n \n \n @_memoizeExpensiveOperation(\ndiff --git a/libcxx/utils/libcxx/test/format.py b/libcxx/utils/libcxx/test/format.py\nindex ddd88f25646e..2be42d293280 100644\n--- a/libcxx/utils/libcxx/test/format.py\n+++ b/libcxx/utils/libcxx/test/format.py\n@@ -35,39 +35,6 @@ def _checkBaseSubstitutions(substitutions):\n     for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n         assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n \n-def _parseLitOutput(fullOutput):\n-    \"\"\"\n-    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n-\n-    This takes output of the form\n-\n-        $ \":\" \"RUN: at line 11\"\n-        $ \"echo\" \"OUTPUT1\"\n-        # command output:\n-        OUTPUT1\n-\n-        $ \":\" \"RUN: at line 12\"\n-        $ \"echo\" \"OUTPUT2\"\n-        # command output:\n-        OUTPUT2\n-\n-    and returns a string containing\n-\n-        OUTPUT1\n-        OUTPUT2\n-\n-    as-if the commands had been run directly. This is a workaround for the fact\n-    that Lit doesn't let us execute ShTest and retrieve the raw output without\n-    injecting additional Lit output around it.\n-    \"\"\"\n-    parsed = ''\n-    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n-        if output: # skip blank lines\n-            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n-            if commandOutput:\n-                parsed += commandOutput.group(1)\n-    return parsed\n-\n def _executeScriptInternal(test, litConfig, commands):\n     \"\"\"\n     Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n@@ -79,21 +46,12 @@ def _executeScriptInternal(test, litConfig, commands):\n     _, tmpBase = _getTempPaths(test)\n     execDir = os.path.dirname(test.getExecPath())\n     res = lit.TestRunner.executeScriptInternal(\n-        test, litConfig, tmpBase, parsedCommands, execDir\n+        test, litConfig, tmpBase, parsedCommands, execDir, debug=False\n     )\n     if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n         res = (\"\", res.output, 127, None)\n     (out, err, exitCode, timeoutInfo) = res\n \n-    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n-    #       split any stderr output that is included in stdout. It shouldn't be there, but\n-    #       the Lit internal shell conflates stderr and stdout.\n-    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n-    if conflatedErrorOutput:\n-        conflatedErrorOutput = conflatedErrorOutput.group(0)\n-        out = out[: -len(conflatedErrorOutput)]\n-        err += conflatedErrorOutput\n-\n     return (out, err, exitCode, timeoutInfo, parsedCommands)\n \n \n@@ -400,8 +358,7 @@ def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig):\n             raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n \n         # Split the generated output into multiple files and generate one test for each file\n-        parsed = _parseLitOutput(out)\n-        for (subfile, content) in self._splitFile(parsed):\n+        for (subfile, content) in self._splitFile(out):\n             generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n             os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n             with open(generatedFile, 'w') as f:\ndiff --git a/llvm/utils/lit/lit/TestRunner.py b/llvm/utils/lit/lit/TestRunner.py\nindex 0629eca42049..461cf63d6b96 100644\n--- a/llvm/utils/lit/lit/TestRunner.py\n+++ b/llvm/utils/lit/lit/TestRunner.py\n@@ -8,6 +8,7 @@\n import stat\n import pathlib\n import platform\n+import shlex\n import shutil\n import tempfile\n import threading\n@@ -57,6 +58,14 @@ def __init__(self, command, message):\n kPdbgRegex = \"%dbg\\\\(([^)'\\\"]*)\\\\)(.*)\"\n \n \n+def buildPdbgCommand(msg, cmd):\n+    res = f\"%dbg({msg}) {cmd}\"\n+    assert re.match(\n+        kPdbgRegex, res\n+    ), f\"kPdbgRegex expected to match actual %dbg usage: {res}\"\n+    return res\n+\n+\n class ShellEnvironment(object):\n \n     \"\"\"Mutable shell environment containing things like CWD and env vars.\n@@ -340,12 +349,12 @@ def executeBuiltinExport(cmd, shenv):\n \n \n def executeBuiltinEcho(cmd, shenv):\n-    \"\"\"Interpret a redirected echo command\"\"\"\n+    \"\"\"Interpret a redirected echo or @echo command\"\"\"\n     opened_files = []\n     stdin, stdout, stderr = processRedirects(cmd, subprocess.PIPE, shenv, opened_files)\n     if stdin != subprocess.PIPE or stderr != subprocess.PIPE:\n         raise InternalShellError(\n-            cmd, \"stdin and stderr redirects not supported for echo\"\n+            cmd, f\"stdin and stderr redirects not supported for {cmd.args[0]}\"\n         )\n \n     # Some tests have un-redirected echo commands to help debug test failures.\n@@ -692,6 +701,7 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n         \"cd\": executeBuiltinCd,\n         \"export\": executeBuiltinExport,\n         \"echo\": executeBuiltinEcho,\n+        \"@echo\": executeBuiltinEcho,\n         \"mkdir\": executeBuiltinMkdir,\n         \"popd\": executeBuiltinPopd,\n         \"pushd\": executeBuiltinPushd,\n@@ -919,7 +929,7 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n         if res == -signal.SIGINT:\n             raise KeyboardInterrupt\n         if proc_not_counts[i] % 2:\n-            res = not res\n+            res = 1 if res == 0 else 0\n         elif proc_not_counts[i] > 1:\n             res = 1 if res != 0 else 0\n \n@@ -982,19 +992,58 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n     return exitCode\n \n \n-def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n+def formatOutput(title, data, limit=None):\n+    if not data.strip():\n+        return \"\"\n+    if not limit is None and len(data) > limit:\n+        data = data[:limit] + \"\\n...\\n\"\n+        msg = \"data was truncated\"\n+    else:\n+        msg = \"\"\n+    ndashes = 30\n+    out =  f\"# .---{title}{'-' * (ndashes - 4 - len(title))}\\n\"\n+    out += f\"# | \" + \"\\n# | \".join(data.splitlines()) + \"\\n\"\n+    out += f\"# `---{msg}{'-' * (ndashes - 4 - len(msg))}\\n\"\n+    return out\n+\n+# Normally returns out, err, exitCode, timeoutInfo.\n+#\n+# If debug is True (the normal lit behavior), err is empty, and out contains an\n+# execution trace, including stdout and stderr shown per command executed.\n+#\n+# If debug is False (set by some custom lit test formats that call this\n+# function), out contains only stdout from the script, err contains only stderr\n+# from the script, and there is no execution trace.\n+def executeScriptInternal(test, litConfig, tmpBase, commands, cwd,\n+                          debug=True):\n     cmds = []\n     for i, ln in enumerate(commands):\n+        # Within lit, we try to always add '%dbg(...)' to command lines in order\n+        # to maximize debuggability.  However, custom lit test formats might not\n+        # always add it, so add a generic debug message in that case.\n         match = re.match(kPdbgRegex, ln)\n         if match:\n+            dbg = match.group(1)\n             command = match.group(2)\n-            ln = commands[i] = match.expand(\": '\\\\1'; \\\\2\" if command else \": '\\\\1'\")\n+        else:\n+            dbg = \"command line\"\n+            command = ln\n+        if debug:\n+            ln = f\"@echo '# {dbg}' \"\n+            if command:\n+                ln += f\"&& @echo {shlex.quote(command.lstrip())} && {command}\"\n+            else:\n+                ln += \"has no command after substitutions\"\n+        else:\n+            ln = command\n         try:\n             cmds.append(\n                 ShUtil.ShParser(ln, litConfig.isWindows, test.config.pipefail).parse()\n             )\n         except:\n-            return lit.Test.Result(Test.FAIL, \"shell parser error on: %r\" % ln)\n+            return lit.Test.Result(\n+                Test.FAIL, f\"shell parser error on {dbg}: {command.lstrip()}\\n\"\n+            )\n \n     cmd = cmds[0]\n     for c in cmds[1:]:\n@@ -1014,8 +1063,42 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n \n     out = err = \"\"\n     for i, result in enumerate(results):\n-        # Write the command line run.\n-        out += \"$ %s\\n\" % (\" \".join('\"%s\"' % s for s in result.command.args),)\n+        if not debug:\n+            out += result.stdout\n+            err += result.stderr\n+            continue\n+\n+        # The purpose of an \"@echo\" command is merely to add a debugging message\n+        # directly to lit's output.  It is used internally by lit's internal\n+        # shell and is not currently documented for use in lit tests.  However,\n+        # if someone misuses it (e.g., both \"echo\" and \"@echo\" complain about\n+        # stdin redirection), produce the normal execution trace to facilitate\n+        # debugging.\n+        if (\n+            result.command.args[0] == \"@echo\"\n+            and result.exitCode == 0\n+            and not result.stderr\n+            and not result.outputFiles\n+            and not result.timeoutReached\n+        ):\n+            out += result.stdout\n+            continue\n+\n+        # Write the command line that was run.  Properly quote it.  Leading\n+        # \"!\" commands should not be quoted as that would indicate they are not\n+        # the builtins.\n+        out += \"# executed command: \"\n+        nLeadingBangs = next(\n+            (i for i, cmd in enumerate(result.command.args) if cmd != \"!\"),\n+            len(result.command.args),\n+        )\n+        out += \"! \" * nLeadingBangs\n+        out += \" \".join(\n+            shlex.quote(str(s))\n+            for i, s in enumerate(result.command.args)\n+            if i >= nLeadingBangs\n+        )\n+        out += \"\\n\"\n \n         # If nothing interesting happened, move on.\n         if (\n@@ -1030,22 +1113,16 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n \n         # Add the command output, if redirected.\n         for (name, path, data) in result.outputFiles:\n-            if data.strip():\n-                out += \"# redirected output from %r:\\n\" % (name,)\n-                data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n-                if len(data) > 1024:\n-                    out += data[:1024] + \"\\n...\\n\"\n-                    out += \"note: data was truncated\\n\"\n-                else:\n-                    out += data\n-                out += \"\\n\"\n-\n+            data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n+            out += formatOutput(\n+                f\"redirected output from '{name}'\", data, limit=1024\n+            )\n         if result.stdout.strip():\n-            out += \"# command output:\\n%s\\n\" % (result.stdout,)\n+            out += formatOutput(\"command stdout\", result.stdout)\n         if result.stderr.strip():\n-            out += \"# command stderr:\\n%s\\n\" % (result.stderr,)\n+            out += formatOutput(\"command stderr\", result.stderr)\n         if not result.stdout.strip() and not result.stderr.strip():\n-            out += \"note: command had no output on stdout or stderr\\n\"\n+            out += \"# note: command had no output on stdout or stderr\\n\"\n \n         # Show the error conditions:\n         if result.exitCode != 0:\n@@ -1055,9 +1132,9 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n                 codeStr = hex(int(result.exitCode & 0xFFFFFFFF)).rstrip(\"L\")\n             else:\n                 codeStr = str(result.exitCode)\n-            out += \"error: command failed with exit status: %s\\n\" % (codeStr,)\n+            out += \"# error: command failed with exit status: %s\\n\" % (codeStr,)\n         if litConfig.maxIndividualTestTime > 0 and result.timeoutReached:\n-            out += \"error: command reached timeout: %s\\n\" % (\n+            out += \"# error: command reached timeout: %s\\n\" % (\n                 str(result.timeoutReached),\n             )\n \n@@ -1833,13 +1910,7 @@ def _handleCommand(cls, line_number, line, output, keyword):\n         if not output or not output[-1].add_continuation(line_number, keyword, line):\n             if output is None:\n                 output = []\n-            pdbg = \"%dbg({keyword} at line {line_number})\".format(\n-                keyword=keyword, line_number=line_number\n-            )\n-            assert re.match(\n-                kPdbgRegex + \"$\", pdbg\n-            ), \"kPdbgRegex expected to match actual %dbg usage\"\n-            line = \"{pdbg} {real_command}\".format(pdbg=pdbg, real_command=line)\n+            line = buildPdbgCommand(f\"{keyword} at line {line_number}\", line)\n             output.append(CommandDirective(line_number, line_number, keyword, line))\n         return output\n \n@@ -2104,6 +2175,8 @@ def executeShTest(\n         return lit.Test.Result(Test.UNSUPPORTED, \"Test is unsupported\")\n \n     script = list(preamble_commands)\n+    script = [buildPdbgCommand(f\"preamble command line\", ln) for ln in script]\n+\n     parsed = parseIntegratedTestScript(test, require_script=not script)\n     if isinstance(parsed, lit.Test.Result):\n         return parsed\ndiff --git a/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg b/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\nindex cf1a4f1ba1ec..301208c25bdc 100644\n--- a/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\n+++ b/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\n@@ -5,4 +5,4 @@ config.suffixes = [\".txt\"]\n config.test_format = lit.formats.ShTest()\n config.test_source_root = None\n config.test_exec_root = None\n-config.substitutions.append((\"%var\", lit_config.params.get(\"var\", \"\")))\n+config.substitutions.append((\"%var\", lit_config.params.get(\"var\", \"default\")))\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt b/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\nindex 6dd9b16304e0..1d94c1213723 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\n@@ -14,21 +14,21 @@\n ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0 -fopenmp-simd\n ; REDEFINE: %{fcflags} = -check-prefix=SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu -fopenmp-simd\n ; REDEFINE: %{fcflags} = -check-prefix=SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0\n ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu\n ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n \n ; CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt b/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\nindex 3bf057151afb..23c0a6d50753 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\n@@ -7,7 +7,7 @@\n #\n # REDEFINE: %{global:greeting}=Hello\n # RUN: %{global:echo}\n-# CHECK: GLOBAL: Hello World\n+# CHECK:# | GLOBAL: Hello World\n \n # We can redefine the test suite config's substitutions multiple times.  Again,\n # the expansion order remains the same (%{global:echo} before %{global:greeting}\n@@ -17,7 +17,7 @@\n # REDEFINE: %{global:greeting}=Goodbye %{global:what}\n # REDEFINE: %{global:what}=Sleep\n # RUN: %{global:echo}\n-# CHECK: GLOBAL: Goodbye Sleep Sleep\n+# CHECK:# | GLOBAL: Goodbye Sleep Sleep\n \n # A new local substitution is prepended to the substitution list so that it can\n # depend on all substitutions that were defined previously, including those from\n@@ -26,7 +26,7 @@\n # DEFINE: %{local:greeting}=Hey %{global:what}\n # DEFINE: %{local:echo}=echo \"LOCAL: %{local:greeting} %{global:what}\"\n # RUN: %{local:echo}\n-# CHECK: LOCAL: Hey Sleep Sleep\n+# CHECK:# | LOCAL: Hey Sleep Sleep\n \n # As for substitutions from the test suite config, redefining local\n # substitutions should not change the expansion order.  Again, the expansion\n@@ -36,6 +36,6 @@\n # REDEFINE: %{local:greeting}=So Long %{global:what}\n # REDEFINE: %{global:what}=World\n # RUN: %{local:echo}\n-# CHECK: LOCAL: So Long World World\n+# CHECK:# | LOCAL: So Long World World\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt b/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\nindex 65f90792ff7b..5a1d7f2e1987 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\n@@ -1,19 +1,19 @@\n # Does it work as expected directly in RUN lines?\n # RUN: echo %(line), %(line-1), %(line+2)\n-# CHECK: [[#@LINE-1]], [[#@LINE-2]], [[#@LINE+1]]\n+# CHECK:# | [[#@LINE-1]], [[#@LINE-2]], [[#@LINE+1]]\n \n # %(line) substitutions refer to the original DEFINE/REDEFINE line not the RUN\n # line they eventually appear within.\n #\n # DEFINE: %{lines} = %(line)\n # RUN: echo '%{lines}'\n-# CHECK: [[#@LINE-2]]\n+# CHECK:# | [[#@LINE-2]]\n #\n # REDEFINE: %{lines} = %(line),                                                \\\n # REDEFINE:            %(line),                                                \\\n # REDEFINE:            %(line)\n # RUN: echo '%{lines}'\n-# CHECK: [[#@LINE-4]], [[#@LINE-3]], [[#@LINE-2]]\n+# CHECK:# | [[#@LINE-4]], [[#@LINE-3]], [[#@LINE-2]]\n \n # %(line+N) and %{line-N) should work too.\n #\n@@ -21,12 +21,12 @@\n # DEFINE:                %(line),                                              \\\n # DEFINE:                %(line-1)\n # RUN: echo '%{lines-rel}'\n-# CHECK: [[#@LINE-3]], [[#@LINE-3]], [[#@LINE-3]]\n+# CHECK:# | [[#@LINE-3]], [[#@LINE-3]], [[#@LINE-3]]\n #\n # REDEFINE: %{lines-rel} = %(line+5),                                          \\\n # REDEFINE:                %(line+0),                                          \\\n # REDEFINE:                %(line-10)\n # RUN: echo '%{lines-rel}'\n-# CHECK: [[#@LINE+1]], [[#@LINE-3]], [[#@LINE-12]]\n+# CHECK:# | [[#@LINE+1]], [[#@LINE-3]], [[#@LINE-12]]\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt b/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\nindex 18a27cdd72fa..d27fda2e2fe6 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\n@@ -1,25 +1,25 @@\n # DEFINE: %{abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789} = ok\n # RUN: echo '%{abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789}'\n-# CHECK: ok\n+# CHECK:# | ok\n \n # DEFINE: %{FooBar} = ok at %(line)\n # RUN: echo '%{FooBar}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{fooBar} = ok at %(line)\n # RUN: echo '%{fooBar}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{foo-bar-} = ok at %(line)\n # RUN: echo '%{foo-bar-}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{foo:bar:} = ok at %(line)\n # RUN: echo '%{foo:bar:}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{_foo_bar_} = ok at %(line)\n # RUN: echo '%{_foo_bar_}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt b/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\nindex eb5f0b918fd1..e504b822ace8 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\n@@ -6,7 +6,7 @@\n \n # RUN: echo '%{outer}'\n \n-# CHECK-NON-RECUR:%{inner}\n-# CHECK-RECUR:expanded\n+# CHECK-NON-RECUR:# | %{inner}\n+# CHECK-RECUR:# | expanded\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt b/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\nindex 9d2e7197fb3a..c1bdfef30b1a 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\n@@ -2,21 +2,21 @@\n \n # DEFINE: %{equals} = FileCheck -check-prefixes=FOO,BAR\n # RUN: echo '%{equals}'\n-# CHECK: FileCheck -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -check-prefixes=FOO,BAR\n #\n # REDEFINE: %{equals} == == =\n # RUN: echo '%{equals}'\n-# CHECK: = == =\n+# CHECK:# | = == =\n \n # DEFINE: %{continue-equals} = FileCheck -strict-whitespace -match-full-lines \\\n # DEFINE:                      -check-prefixes=FOO,BAR\n # RUN: echo '%{continue-equals}'\n-# CHECK: FileCheck -strict-whitespace -match-full-lines -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -strict-whitespace -match-full-lines -check-prefixes=FOO,BAR\n #\n # REDEFINE: %{continue-equals} = FileCheck -input-file=test.txt                \\\n # REDEFINE:                      -implicit-check-not=foobar                    \\\n # REDEFINE:                      -check-prefixes=FOO,BAR\n # RUN: echo '%{continue-equals}'\n-# CHECK: FileCheck -input-file=test.txt -implicit-check-not=foobar -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -input-file=test.txt -implicit-check-not=foobar -check-prefixes=FOO,BAR\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt b/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\nindex 58d5c1a34ce8..9143796edd32 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\n@@ -6,11 +6,11 @@\n \n # DEFINE: %{escape} = \\g<0>\\n\n # RUN: echo '%{escape}'\n-# CHECK: {{\\\\?}}\\g<0>{{\\\\?}}\\n\n+# CHECK:# | {{\\\\?}}\\g<0>{{\\\\?}}\\n\n \n # REDEFINE: %{escape} = \\n                                                     \\\n # REDEFINE:             \\g<param>\n # RUN: echo '%{escape}'\n-# CHECK: {{\\\\?}}\\n {{\\\\?}}\\g<param>\n+# CHECK:# | {{\\\\?}}\\n {{\\\\?}}\\g<param>\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt b/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\nindex 1259e511ba70..3e4db1b15d92 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\n@@ -3,33 +3,33 @@\n #\n # DEFINE: %{empty}=\n # RUN: echo \"'%{empty}'\"\n-# CHECK:''\n+# CHECK:# | ''\n #\n # REDEFINE: %{empty}=\n # RUN: echo \"'%{empty}'\"\n-# CHECK:''\n+# CHECK:# | ''\n \n # A value consisting only of whitespace is trimmed to the empty string.\n #\n #               v~~ intentional whitespace\n # DEFINE: %{ws}=   \n # RUN: echo \"'%{ws}'\"\n-# CHECK:''\n+# CHECK:# | ''\n #\n #                 v intentional whitespace\n # REDEFINE: %{ws}= \n # RUN: echo \"'%{ws}'\"\n-# CHECK:''\n+# CHECK:# | ''\n \n # Whitespace is not required around the name or value.\n #\n # DEFINE:%{no-whitespace}=abc\n # RUN: echo \"'%{no-whitespace}'\"\n-# CHECK:'abc'\n+# CHECK:# | 'abc'\n #\n # REDEFINE:%{no-whitespace}=HelloWorld\n # RUN: echo \"'%{no-whitespace}'\"\n-# CHECK:'HelloWorld'\n+# CHECK:# | 'HelloWorld'\n \n # Whitespace is not required between substitutions in a value.\n #\n@@ -37,11 +37,11 @@\n # DEFINE: %{adjacent1} = bar\n # DEFINE: %{has-adjacent-substs} = %{adjacent0}%{adjacent1}\n # RUN: echo \"'%{has-adjacent-substs}'\"\n-# CHECK:'foobar'\n+# CHECK:# | 'foobar'\n #\n # REDEFINE: %{has-adjacent-substs} = %{adjacent0}%{adjacent1}%{adjacent0}\n # RUN: echo \"'%{has-adjacent-substs}'\"\n-# CHECK:'foobarfoo'\n+# CHECK:# | 'foobarfoo'\n \n # Exact whitespace is preserved within the value, but whitespace enclosing the\n # name or value is discarded.  ('%{' and '}' are part of the name, and\n@@ -50,11 +50,11 @@\n #                                       v~~ intentional whitespace\n # DEFINE:   %{whitespace}  =  abc    def   \n # RUN: echo \"'%{whitespace}'\"\n-# CHECK:'abc    def'\n+# CHECK:# | 'abc    def'\n #                                      v intentional whitespace\n # REDEFINE: %{whitespace} = Hello World \n # RUN: echo \"'%{whitespace}'\"\n-# CHECK:'Hello World'\n+# CHECK:# | 'Hello World'\n \n # Line continuations in the value are permitted and collapse whitespace.\n #\n@@ -66,12 +66,12 @@\n # DEFINE:  pqr \n #             ^ intentional whitespace\n # RUN: echo \"'%{continue}'\"\n-# CHECK:'abc def ghi jkl mno pqr'\n+# CHECK:# | 'abc def ghi jkl mno pqr'\n #\n # REDEFINE: %{continue} =  abc  \\\n # REDEFINE: def\n # RUN: echo \"'%{continue}'\"\n-# CHECK:'abc def'\n+# CHECK:# | 'abc def'\n \n # Whitespace at the end of the line after a '\\' is ignored, and it's treated as\n # a line continuation.  Otherwise, the behavior would be hard to understand\n@@ -83,7 +83,7 @@\n #                                   ^ intentional whitespace\n # DEFINE: baz\n # RUN: echo \"'%{ws-after-continue}'\"\n-# CHECK:'foo bar baz'\n+# CHECK:# | 'foo bar baz'\n #\n #                                     v intentional whitespace\n # REDEFINE: %{ws-after-continue}=foo \\ \n@@ -91,7 +91,7 @@\n #                                     ^~~~~~~~~~~~ intentional whitespace\n # REDEFINE: baz\n # RUN: echo \"'%{ws-after-continue}'\"\n-# CHECK:'foo bar baz'\n+# CHECK:# | 'foo bar baz'\n \n # A line continuation is recognized anywhere.  It should be used only where\n # whitespace is permitted because it reduces to a single space.\n@@ -107,7 +107,7 @@\n # DEFINE:\\\n # DEFINE:a\n # RUN: echo \"'%{blank-lines}'\"\n-# CHECK:'a'\n+# CHECK:# | 'a'\n #\n # REDEFINE:                  \\\n # REDEFINE: %{blank-lines}   \\\n@@ -120,7 +120,7 @@\n # REDEFINE:                  \\\n # REDEFINE:      c\n # RUN: echo \"'%{blank-lines}'\"\n-# CHECK:'a b c'\n+# CHECK:# | 'a b c'\n \n # The fourth DEFINE line is deceptive because it looks like a new substitution,\n # but it's actually a continuation of the previous value.\n@@ -130,6 +130,6 @@\n # DEFINE: %{deceptive-continue}=echo \\\n # DEFINE: %{name}=%{value}\n # RUN: %{deceptive-continue}\n-# CHECK:x=3\n+# CHECK:# | x=3\n \n # CHECK:{{ *}}Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt b/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\nindex b0a7cfd97941..b5fc1b49fcc5 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\n@@ -1,46 +1,34 @@\n-#       CHECK: -- Testing:{{.*}}\n-#  CHECK-NEXT: PASS: shtest-if-else :: test.txt (1 of 1)\n-#  CHECK-NEXT: Exit Code: 0\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: Command Output (stdout):\n-#  CHECK-NEXT: --\n+# CHECK: -- Testing:{{.*}}\n+# CHECK-NEXT: PASS: shtest-if-else :: test.txt (1 of 1)\n+#      CHECK: Command Output (stdout):\n+# CHECK-NEXT: --\n \n # RUN: %if feature %{ echo \"test-1\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-1\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-1\"\n \n # If %else is not present it is treated like %else %{%}. Empty commands\n # are ignored.\n #\n # RUN: %if nofeature %{ echo \"fail\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#   CHECK-NOT: fail\n+#     CHECK: # {{RUN}}: at line [[#@LINE-1]] has no command after substitutions\n+# CHECK-NOT: fail\n \n # RUN: %if nofeature %{ echo \"fail\" %} %else %{ echo \"test-2\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-2\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-2\"\n \n # Spaces inside curly braces are not ignored\n #\n # RUN: echo test-%if feature %{ 3 %} %else %{ fail %}-test\n # RUN: echo test-%if feature %{ 4 4 %} %else %{ fail %}-test\n # RUN: echo test-%if nofeature %{ fail %} %else %{ 5 5 %}-test\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 3 -test\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 4 4 -test\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 5 5 -test\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo test- 3 -test\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo test- 4 4 -test\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo test- 5 5 -test\n \n # Escape line breaks for multi-line expressions\n #\n@@ -48,42 +36,32 @@\n # RUN:   %{ echo     \\\n # RUN:     \"test-5\" \\\n # RUN:   %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-4]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-5\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-5\"\n \n # RUN: %if nofeature       \\\n # RUN:   %{ echo \"fail\" %}   \\\n # RUN: %else               \\\n # RUN:   %{ echo \"test-6\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-4]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-6\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-6\"\n \n # RUN: echo \"test%if feature %{%} %else %{%}-7\"\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-7\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-7\"\n \n # Escape %if. Without %if..%else context '%{' and '%}' are treated\n # literally.\n #\n # RUN: echo %%if feature %{ echo \"test-8\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: %if feature %{ echo test-8 %}\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo %if feature %{ echo \"test-8\" %}\n \n # Nested expressions are supported:\n #\n # RUN: echo %if feature %{ %if feature %{ %if nofeature %{\"fail\"%} %else %{\"test-9\"%} %} %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-9\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-9\"\n \n # Binary expression evaluation and regex match can be used as\n # conditions.\n@@ -91,18 +69,12 @@\n # RUN: echo %if feature && !nofeature %{ \"test-10\" %}\n # RUN: echo %if feature && nofeature %{ \"fail\" %} %else %{ \"test-11\" %}\n # RUN: echo %if {{fea.+}} %{ \"test-12\" %} %else %{ \"fail\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-10\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-11\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-12\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo \"test-10\"\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-11\"\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo \"test-12\"\n \n # Spaces between %if and %else are ignored. If there is no %else -\n # space after %if %{...%} is not ignored.\n@@ -110,39 +82,27 @@\n # RUN: echo XX %if feature %{YY%} ZZ\n # RUN: echo AA %if feature %{BB%} %else %{CC%} DD\n # RUN: echo AA %if nofeature %{BB%} %else %{CC%} DD\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: XX YY ZZ\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: AA BB DD\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: AA CC DD\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo XX YY ZZ\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo AA BB DD\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo AA CC DD\n \n # '{' and '}' can be used without escaping\n #\n # RUN: %if feature %{echo {}%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: {}\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo {}\n \n # Spaces are not required\n #\n # RUN: echo %if feature%{\"ok\"%}%else%{\"fail\"%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: ok\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"ok\"\n \n # Substitutions with braces are handled correctly\n #\n # RUN: echo %{sub} %if feature%{test-%{sub}%}%else%{\"fail\"%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: ok test-ok\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo ok test-ok\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt b/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\nindex fb3a3e000789..5ff0c891450b 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\n@@ -1,3 +1,4 @@\n # RUN: true\n # RUN: echo hi\n-# RUN: not not wc missing-file &> %t.out\n+# RUN: not not wc missing-file &> %t.out || true\n+# RUN: not %{python} %S/write-a-lot.py &> %t.out\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg b/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\nindex b872854d21e6..c53fd157b6ae 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\n@@ -2,4 +2,5 @@ import lit.formats\n \n config.name = \"shtest-output-printing\"\n config.suffixes = [\".txt\"]\n+config.substitutions.append((\"%{python}\", sys.executable))\n config.test_format = lit.formats.ShTest(execute_external=False)\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py b/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py\nnew file mode 100644\nindex 000000000000..ffcba7d517cd\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py\n@@ -0,0 +1,6 @@\n+#!/usr/bin/env python\n+\n+import sys\n+\n+sys.stdout.write(\"All work and no play makes Jack a dull boy.\\n\" * 1000);\n+sys.stdout.flush()\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt\nnew file mode 100644\nindex 000000000000..15a87aee46a3\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt\n@@ -0,0 +1 @@\n+RUN: @echo 2> %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt\nnew file mode 100644\nindex 000000000000..27fd0c4209fd\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt\n@@ -0,0 +1,2 @@\n+RUN: touch %t\n+RUN: @echo < %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt\nnew file mode 100644\nindex 000000000000..9611918f7e12\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt\n@@ -0,0 +1 @@\n+RUN: echo 2> %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt\nnew file mode 100644\nindex 000000000000..bc771be6b22a\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt\n@@ -0,0 +1,2 @@\n+RUN: touch %t\n+RUN: echo < %t\ndiff --git a/llvm/utils/lit/tests/allow-retries.py b/llvm/utils/lit/tests/allow-retries.py\nindex b8abe0ba4fee..ef548534f082 100644\n--- a/llvm/utils/lit/tests/allow-retries.py\n+++ b/llvm/utils/lit/tests/allow-retries.py\n@@ -15,9 +15,28 @@\n \n # This test does not succeed within the allowed retry limit\n #\n-# RUN: not %{lit} %{inputs}/allow-retries/does-not-succeed-within-limit.py | FileCheck --check-prefix=CHECK-TEST3 %s\n-# CHECK-TEST3: Failed Tests (1):\n-# CHECK-TEST3: allow-retries :: does-not-succeed-within-limit.py\n+# Check that the execution trace isn't corrupt due to reprocessing the script\n+# multiple times (e.g., '%dbg(...)' processing used to accumulate across\n+# retries).\n+#\n+# RUN: not %{lit} %{inputs}/allow-retries/does-not-succeed-within-limit.py -v |\\\n+# RUN:   FileCheck --check-prefix=CHECK-TEST3 -match-full-lines %s\n+#\n+#       CHECK-TEST3: FAIL: allow-retries :: does-not-succeed-within-limit.py (1 of 1)\n+#  CHECK-TEST3-NEXT: {{\\**}} TEST 'allow-retries :: does-not-succeed-within-limit.py' FAILED {{\\**}}\n+#  CHECK-TEST3-NEXT: Exit Code: 1\n+# CHECK-TEST3-EMPTY:\n+#  CHECK-TEST3-NEXT: Command Output (stdout):\n+#  CHECK-TEST3-NEXT: --\n+#  CHECK-TEST3-NEXT: # {{RUN}}: at line 3\n+#  CHECK-TEST3-NEXT: false\n+#  CHECK-TEST3-NEXT: # executed command: false\n+#  CHECK-TEST3-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-TEST3-NEXT: # error: command failed with exit status: 1\n+# CHECK-TEST3-EMPTY:\n+#  CHECK-TEST3-NEXT: --\n+#       CHECK-TEST3: Failed Tests (1):\n+#       CHECK-TEST3: allow-retries :: does-not-succeed-within-limit.py\n \n # This test should be UNRESOLVED since it has more than one ALLOW_RETRIES\n # lines, and that is not allowed.\ndiff --git a/llvm/utils/lit/tests/lit-opts.py b/llvm/utils/lit/tests/lit-opts.py\nindex d292ca74f3b9..a533a59d9d12 100644\n--- a/llvm/utils/lit/tests/lit-opts.py\n+++ b/llvm/utils/lit/tests/lit-opts.py\n@@ -8,7 +8,7 @@\n #\n # RUN: env LIT_OPTS=-a \\\n # RUN: %{lit} -s %{inputs}/lit-opts \\\n-# RUN: | FileCheck -check-prefix=SHOW-ALL -DVAR= %s\n+# RUN: | FileCheck -check-prefix=SHOW-ALL -DVAR=default %s\n \n # Check that LIT_OPTS understands multiple options with arbitrary spacing.\n #\n@@ -28,6 +28,6 @@\n \n # SHOW-ALL:     Testing: 1 tests\n # SHOW-ALL:     PASS: lit-opts :: test.txt (1 of 1)\n-# SHOW-ALL:     {{^}}[[VAR]]\n+# SHOW-ALL:     echo [[VAR]]\n # SHOW-ALL-NOT: PASS\n # SHOW-ALL:     Passed: 1\ndiff --git a/llvm/utils/lit/tests/shtest-define.py b/llvm/utils/lit/tests/shtest-define.py\nindex 1d0997bbbaf8..8c9309804cce 100644\n--- a/llvm/utils/lit/tests/shtest-define.py\n+++ b/llvm/utils/lit/tests/shtest-define.py\n@@ -136,15 +136,15 @@\n # RUN: %{lit} -va %{my-inputs}/shared-substs-*.txt 2>&1 |                      \\\n # RUN:   FileCheck -check-prefix=SHARED-SUBSTS -match-full-lines %s\n #\n-# SHARED-SUBSTS: shared-substs-0.txt\n-# SHARED-SUBSTS: GLOBAL: World\n-# SHARED-SUBSTS: LOCAL0: LOCAL0:Hello LOCAL0:World\n-# SHARED-SUBSTS: LOCAL0: subst\n+# SHARED-SUBSTS:# | shared-substs-0.txt\n+# SHARED-SUBSTS:# | GLOBAL: World\n+# SHARED-SUBSTS:# | LOCAL0: LOCAL0:Hello LOCAL0:World\n+# SHARED-SUBSTS:# | LOCAL0: subst\n #\n-# SHARED-SUBSTS: shared-substs-1.txt\n-# SHARED-SUBSTS: GLOBAL: World\n-# SHARED-SUBSTS: LOCAL1: LOCAL1:Hello LOCAL1:World\n-# SHARED-SUBSTS: LOCAL1: subst\n+# SHARED-SUBSTS:# | shared-substs-1.txt\n+# SHARED-SUBSTS:# | GLOBAL: World\n+# SHARED-SUBSTS:# | LOCAL1: LOCAL1:Hello LOCAL1:World\n+# SHARED-SUBSTS:# | LOCAL1: subst\n #\n # REDEFINE: %{test} = shared-substs-0.txt\n # RUN: %{record-test}\ndiff --git a/llvm/utils/lit/tests/shtest-env.py b/llvm/utils/lit/tests/shtest-env.py\nindex f2e8216f7f4a..a4775ac6688d 100644\n--- a/llvm/utils/lit/tests/shtest-env.py\n+++ b/llvm/utils/lit/tests/shtest-env.py\n@@ -10,88 +10,115 @@\n # CHECK: -- Testing: 16 tests{{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-assign.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"FOO=1\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env FOO=1\n+# CHECK: # executed command: env FOO=1\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-u-arg.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO\n+# CHECK: # executed command: env -u FOO\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-u.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u\n+# CHECK: # executed command: env -u\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-nested-none.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"env\" \"env\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env env env\n+# CHECK: # executed command: env env env\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-none.txt ({{[^)]*}})\n-# CHECK: $ \"env\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env\n+# CHECK: # executed command: env\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-cd.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"cd\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'cd'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 cd foobar\n+# CHECK: # executed command: env -u FOO BAR=3 cd foobar\n+# CHECK: # | Error: 'env' cannot call 'cd'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-colon.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \":\"\n-# CHECK: Error: 'env' cannot call ':'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 :\n+# CHECK: # executed command: env -u FOO BAR=3 :\n+# CHECK: # | Error: 'env' cannot call ':'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-echo.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"echo\" \"hello\" \"world\"\n-# CHECK: Error: 'env' cannot call 'echo'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 echo hello world\n+# CHECK: # executed command: env -u FOO BAR=3 echo hello world\n+# CHECK: # | Error: 'env' cannot call 'echo'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: PASS: shtest-env :: env-calls-env.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"env\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"FOO=2\" \"env\" \"BAR=1\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"env\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=1\" \"env\" \"-u\" \"BAR\" \"FOO=2\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=1\" \"env\" \"-u\" \"BAR\" \"FOO=2\" \"env\" \"BAZ=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env env [[PYTHON:.+]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env env [[PYTHON_BARE:.+]] print_environment.py\n+# CHECK: env FOO=2 env BAR=1 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env FOO=2 env BAR=1 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO env -u BAR [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO env -u BAR [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO BAR=1 env -u BAR FOO=2 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO BAR=1 env -u BAR FOO=2 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO BAR=1 env -u BAR FOO=2 env BAZ=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO BAR=1 env -u BAR FOO=2 env BAZ=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: FAIL: shtest-env :: env-calls-export.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"export\" \"BAZ=3\"\n-# CHECK: Error: 'env' cannot call 'export'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 export BAZ=3\n+# CHECK: # executed command: env -u FOO BAR=3 export BAZ=3\n+# CHECK: # | Error: 'env' cannot call 'export'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-mkdir.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"mkdir\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'mkdir'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 mkdir foobar\n+# CHECK: # executed command: env -u FOO BAR=3 mkdir foobar\n+# CHECK: # | Error: 'env' cannot call 'mkdir'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-not-builtin.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"not\" \"rm\" \"{{.*}}.no-such-file\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 not rm {{.+}}.no-such-file\n+# CHECK: # executed command: env -u FOO BAR=3 not rm {{.+}}.no-such-file\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-rm.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"rm\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 rm foobar\n+# CHECK: # executed command: env -u FOO BAR=3 rm foobar\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: PASS: shtest-env :: env-u.txt ({{[^)]*}})\n-# CHECK: $ \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: env -u FOO [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO -u BAR [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO -u BAR [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: PASS: shtest-env :: env.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"A_FOO=999\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"A_FOO=1\" \"B_BAR=2\" \"C_OOF=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env A_FOO=999 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=999 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env A_FOO=1 B_BAR=2 C_OOF=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=1 B_BAR=2 C_OOF=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: PASS: shtest-env :: mixed.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"A_FOO=999\" \"-u\" \"FOO\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"A_FOO=1\" \"-u\" \"FOO\" \"B_BAR=2\" \"-u\" \"BAR\" \"C_OOF=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env A_FOO=999 -u FOO [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=999 -u FOO [[PYTHON_BARE]] print_environment.py\n+# CHECK: env A_FOO=1 -u FOO B_BAR=2 -u BAR C_OOF=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=1 -u FOO B_BAR=2 -u BAR C_OOF=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: Passed:  4\n # CHECK: Failed: 12\ndiff --git a/llvm/utils/lit/tests/shtest-format.py b/llvm/utils/lit/tests/shtest-format.py\nindex 621776ab7bc2..4a3d65b7bce4 100644\n--- a/llvm/utils/lit/tests/shtest-format.py\n+++ b/llvm/utils/lit/tests/shtest-format.py\n@@ -43,13 +43,21 @@\n # CHECK-EMPTY:\n #  CHECK-NEXT: Command Output (stdout):\n #  CHECK-NEXT: --\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-#  CHECK-NEXT: $ \"printf\"\n-#  CHECK-NEXT: # command output:\n-#  CHECK-NEXT: line 1: failed test output on stdout\n-#  CHECK-NEXT: line 2: failed test output on stdout\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-#  CHECK-NEXT: $ \"false\"\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: printf \"line 1: failed test output on stdout\\nline 2: failed test output on stdout\"\n+#  CHECK-NEXT: executed command: printf 'line 1: failed test output on stdout\\nline 2: failed test output on stdout'\n+#  CHECK-NEXT: # .---command stdout------------\n+#  CHECK-NEXT: # | line 1: failed test output on stdout\n+#  CHECK-NEXT: # | line 2: failed test output on stdout\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # RUN: at line 2\n+#  CHECK-NEXT: false\n+#  CHECK-NEXT: # executed command: false\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: --\n+\n \n # CHECK: UNRESOLVED: shtest-format :: no-test-line.txt\n # CHECK: PASS: shtest-format :: pass.txt\n@@ -73,8 +81,11 @@\n # CHECK-EMPTY:\n #  CHECK-NEXT: Command Output (stdout):\n #  CHECK-NEXT: --\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-#  CHECK-NEXT: $ \"true\"\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: true\n+#  CHECK-NEXT: # executed command: true\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: --\n \n # CHECK: Failed Tests (4)\n # CHECK: shtest-format :: external_shell/fail.txt\ndiff --git a/llvm/utils/lit/tests/shtest-if-else.py b/llvm/utils/lit/tests/shtest-if-else.py\nindex aaf94a6e2437..c18da4abbcca 100644\n--- a/llvm/utils/lit/tests/shtest-if-else.py\n+++ b/llvm/utils/lit/tests/shtest-if-else.py\n@@ -1,5 +1,6 @@\n # RUN: %{lit} -v --show-all %{inputs}/shtest-if-else/test.txt \\\n-# RUN:    | FileCheck %{inputs}/shtest-if-else/test.txt --match-full-lines\n+# RUN:    | FileCheck %{inputs}/shtest-if-else/test.txt --match-full-lines \\\n+# RUN:                --implicit-check-not='RUN:'\n \n # RUN: not %{lit} -v --show-all %{inputs}/shtest-if-else/test-neg1.txt 2>&1 \\\n # RUN:    | FileCheck %{inputs}/shtest-if-else/test-neg1.txt\ndiff --git a/llvm/utils/lit/tests/shtest-inject.py b/llvm/utils/lit/tests/shtest-inject.py\nindex 17e293ea1a12..3d34eb7161d4 100644\n--- a/llvm/utils/lit/tests/shtest-inject.py\n+++ b/llvm/utils/lit/tests/shtest-inject.py\n@@ -1,9 +1,26 @@\n-# Check that we can inject commands at the beginning of a ShTest.\n+# Check that we can inject preamble commands at the beginning of a ShTest.\n+#\n+# For one case, check the execution trace as these preamble commands have\n+# \"preamble command\" instead of the usual \"{{RUN}}: at line N\".\n \n # RUN: %{lit} %{inputs}/shtest-inject/test-empty.txt --show-all | FileCheck --check-prefix=CHECK-TEST1 %s\n #\n-# CHECK-TEST1: THIS WAS\n-# CHECK-TEST1: INJECTED\n+#       CHECK-TEST1: Command Output (stdout):\n+#  CHECK-TEST1-NEXT: --\n+#  CHECK-TEST1-NEXT: # preamble command line\n+#  CHECK-TEST1-NEXT: echo \"THIS WAS\"\n+#  CHECK-TEST1-NEXT: # executed command: echo 'THIS WAS'\n+#  CHECK-TEST1-NEXT: # .---command stdout{{-*}}\n+#  CHECK-TEST1-NEXT: # | THIS WAS\n+#  CHECK-TEST1-NEXT: # `---{{-*}}\n+#  CHECK-TEST1-NEXT: # preamble command line\n+#  CHECK-TEST1-NEXT: echo \"INJECTED\"\n+#  CHECK-TEST1-NEXT: # executed command: echo INJECTED\n+#  CHECK-TEST1-NEXT: # .---command stdout{{-*}}\n+#  CHECK-TEST1-NEXT: # | INJECTED\n+#  CHECK-TEST1-NEXT: # `---{{-*}}\n+# CHECK-TEST1-EMPTY:\n+#  CHECK-TEST1-NEXT: --\n #\n # CHECK-TEST1: Passed: 1\n \ndiff --git a/llvm/utils/lit/tests/shtest-not.py b/llvm/utils/lit/tests/shtest-not.py\nindex d23c9d0cffaf..4590b9664b84 100644\n--- a/llvm/utils/lit/tests/shtest-not.py\n+++ b/llvm/utils/lit/tests/shtest-not.py\n@@ -10,112 +10,158 @@\n # CHECK: -- Testing: 17 tests{{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-args-nested-none.txt {{.*}}\n-# CHECK: $ \"!\" \"!\" \"!\"\n-# CHECK: Error: '!' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: ! ! !\n+# CHECK: # executed command: ! ! !\n+# CHECK: # | Error: '!' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-args-none.txt {{.*}}\n-# CHECK: $ \"!\"\n-# CHECK: Error: '!' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: !\n+# CHECK: # executed command: !\n+# CHECK: # | Error: '!' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-calls-external.txt {{.*}}\n \n-# CHECK: $ \"!\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"!\" \"!\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"!\" \"!\" \"!\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"!\" \"!\" \"!\" \"!\" \"{{[^\"]*}}\" \"pass.py\"\n+# CHECK: ! [[PYTHON:.*]] fail.py\n+# CHECK: # executed command: ! [[PYTHON_BARE:.*]] fail.py\n+# CHECK: ! ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! ! [[PYTHON_BARE]] pass.py\n+# CHECK: ! ! ! [[PYTHON]] fail.py\n+# CHECK: # executed command: ! ! ! [[PYTHON_BARE]] fail.py\n+# CHECK: ! ! ! ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! ! ! ! [[PYTHON_BARE]] pass.py\n \n-# CHECK: $ \"!\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! [[PYTHON_BARE]] pass.py\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-last-is-crash.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not --crash\n+# CHECK: # executed command: not --crash\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-nested-none.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not not\n+# CHECK: # executed command: not not not\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-none.txt {{.*}}\n-# CHECK: $ \"not\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not\n+# CHECK: # executed command: not\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-cd.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"cd\" \"foobar\"\n-# CHECK: $ \"not\" \"--crash\" \"cd\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'cd'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not cd foobar\n+# CHECK: # executed command: not not cd foobar\n+# CHECK: not --crash cd foobar\n+# CHECK: # executed command: not --crash cd foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'cd'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-colon.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \":\" \"foobar\"\n-# CHECK: $ \"not\" \"--crash\" \":\"\n-# CHECK: Error: 'not --crash' cannot call ':'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not : foobar\n+# CHECK: # executed command: not not : foobar\n+# CHECK: not --crash :\n+# CHECK: # executed command: not --crash :\n+# CHECK: # | Error: 'not --crash' cannot call ':'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-diff-with-crash.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"diff\" \"-u\" {{.*}}\n-# CHECK-NOT: \"$\"\n+# CHECK: not --crash diff -u {{.*}}\n+# CHECK: # executed command: not --crash diff -u {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n # CHECK-NOT: {{[Ee]rror}}\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: # error: command failed with exit status: {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n # CHECK-NOT: {{[Ee]rror}}\n-# CHECK-NOT: \"$\"\n \n # CHECK: FAIL: shtest-not :: not-calls-diff.txt {{.*}}\n-# CHECK: $ \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"diff\" {{.*}}\n-# CHECK-NOT: \"$\"\n+# CHECK: not diff {{.*}}\n+# CHECK: # executed command: not diff {{.*}}\n+# CHECK: not not not diff {{.*}}\n+# CHECK: # executed command: not not not diff {{.*}}\n+# CHECK: not not not not not diff {{.*}}\n+# CHECK: # executed command: not not not not not diff {{.*}}\n+# CHECK: diff {{.*}}\n+# CHECK: # executed command: diff {{.*}}\n+# CHECK: not not diff {{.*}}\n+# CHECK: # executed command: not not diff {{.*}}\n+# CHECK: not not not not diff {{.*}}\n+# CHECK: # executed command: not not not not diff {{.*}}\n+# CHECK: not diff {{.*}}\n+# CHECK: # executed command: not diff {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-echo.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"echo\" \"hello\" \"world\"\n-# CHECK: $ \"not\" \"--crash\" \"echo\" \"hello\" \"world\"\n-# CHECK: Error: 'not --crash' cannot call 'echo'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not echo hello world\n+# CHECK: # executed command: not not echo hello world\n+# CHECK: not --crash echo hello world\n+# CHECK: # executed command: not --crash echo hello world\n+# CHECK: # | Error: 'not --crash' cannot call 'echo'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-env-builtin.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"env\" \"-u\" \"FOO\" \"BAR=3\" \"rm\" \"{{.*}}.no-such-file\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not --crash env -u FOO BAR=3 rm {{.*}}.no-such-file\n+# CHECK: # executed command: not --crash env -u FOO BAR=3 rm {{.*}}.no-such-file\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-export.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"export\" \"FOO=1\"\n-# CHECK: $ \"not\" \"--crash\" \"export\" \"BAZ=3\"\n-# CHECK: Error: 'not --crash' cannot call 'export'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not export FOO=1\n+# CHECK: # executed command: not not export FOO=1\n+# CHECK: not --crash export BAZ=3\n+# CHECK: # executed command: not --crash export BAZ=3\n+# CHECK: # | Error: 'not --crash' cannot call 'export'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n \n # CHECK: PASS: shtest-not :: not-calls-external.txt {{.*}}\n \n-# CHECK: $ \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-\n-# CHECK: $ \"env\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"env\" \"-u\" \"FOO\" \"BAR=2\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"env\" \"-u\" \"FOO\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"env\" \"FOO=1\" \"env\" \"FOO=2\" \"BAR=1\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"-u\" \"BAR\" \"env\" \"-u\" \"FOO\" \"BAR=1\" \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"env\" \"FOO=2\" \"BAR=2\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"env\" \"-u\" \"BAR\" \"not\" \"env\" \"-u\" \"FOO\" \"BAR=1\" \"{{[^\"]*}}\" \"pass.py\"\n+# CHECK: not [[PYTHON]] fail.py\n+# CHECK: # executed command: not [[PYTHON_BARE]] fail.py\n+# CHECK: not not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not [[PYTHON_BARE]] pass.py\n+# CHECK: not not not [[PYTHON]] fail.py\n+# CHECK: # executed command: not not not [[PYTHON_BARE]] fail.py\n+# CHECK: not not not not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not not not [[PYTHON_BARE]] pass.py\n+\n+# CHECK: not not --crash [[PYTHON]] pass.py\n+# CHECK: # executed command: not not --crash [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash [[PYTHON]] fail.py\n+# CHECK: # executed command: not not --crash [[PYTHON_BARE]] fail.py\n+# CHECK: not not --crash not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not --crash not [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash not [[PYTHON]] fail.py\n+# CHECK: # executed command: not not --crash not [[PYTHON_BARE]] fail.py\n+\n+# CHECK: env not [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env not [[PYTHON_BARE]] fail.py\n+# CHECK: not env [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: not env [[PYTHON_BARE]] fail.py\n+# CHECK: env FOO=1 not [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 not [[PYTHON_BARE]] fail.py\n+# CHECK: not env FOO=1 BAR=1 [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 [[PYTHON_BARE]] fail.py\n+# CHECK: env FOO=1 BAR=1 not env -u FOO BAR=2 [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 BAR=1 not env -u FOO BAR=2 [[PYTHON_BARE]] fail.py\n+# CHECK: not env FOO=1 BAR=1 not env -u FOO -u BAR [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 not env -u FOO -u BAR [[PYTHON_BARE]] pass.py\n+# CHECK: not not env FOO=1 env FOO=2 BAR=1 [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not not env FOO=1 env FOO=2 BAR=1 [[PYTHON_BARE]] pass.py\n+# CHECK: env FOO=1 -u BAR env -u FOO BAR=1 not not [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 -u BAR env -u FOO BAR=1 not not [[PYTHON_BARE]] pass.py\n+\n+# CHECK: not env FOO=1 BAR=1 env FOO=2 BAR=2 not --crash [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 env FOO=2 BAR=2 not --crash [[PYTHON_BARE]] pass.py\n+# CHECK: not env FOO=1 BAR=1 not --crash not [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 not --crash not [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash env -u BAR not env -u FOO BAR=1 [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not not --crash env -u BAR not env -u FOO BAR=1 [[PYTHON_BARE]] pass.py\n \n \n # CHECK: FAIL: shtest-not :: not-calls-fail2.txt {{.*}}\n@@ -123,16 +169,20 @@\n # CHECK-NEXT: Exit Code: 1\n \n # CHECK: FAIL: shtest-not :: not-calls-mkdir.txt {{.*}}\n-# CHECK: $ \"not\" \"mkdir\" {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"mkdir\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'mkdir'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not mkdir {{.*}}\n+# CHECK: # executed command: not mkdir {{.*}}\n+# CHECK: not --crash mkdir foobar\n+# CHECK: # executed command: not --crash mkdir foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'mkdir'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-rm.txt {{.*}}\n-# CHECK: $ \"not\" \"rm\" {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"rm\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not rm {{.*}}\n+# CHECK: # executed command: not rm {{.*}}\n+# CHECK: not --crash rm foobar\n+# CHECK: # executed command: not --crash rm foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: Passed:  1\n # CHECK: Failed: 16\ndiff --git a/llvm/utils/lit/tests/shtest-output-printing.py b/llvm/utils/lit/tests/shtest-output-printing.py\nindex 7cd975ba8d3c..3e49197520a9 100644\n--- a/llvm/utils/lit/tests/shtest-output-printing.py\n+++ b/llvm/utils/lit/tests/shtest-output-printing.py\n@@ -1,28 +1,45 @@\n # Check the various features of the ShTest format.\n #\n # RUN: not %{lit} -v %{inputs}/shtest-output-printing > %t.out\n-# RUN: FileCheck --input-file %t.out %s\n+# RUN: FileCheck --input-file %t.out --match-full-lines %s\n #\n # END.\n \n-# CHECK: -- Testing:\n-\n-# CHECK: FAIL: shtest-output-printing :: basic.txt\n-# CHECK-NEXT: *** TEST 'shtest-output-printing :: basic.txt' FAILED ***\n-# CHECK-NEXT: Exit Code: 1\n-#\n-# CHECK:      Command Output\n-# CHECK-NEXT: --\n-# CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \"true\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-# CHECK-NEXT: $ \"echo\" \"hi\"\n-# CHECK-NEXT: # command output:\n-# CHECK-NEXT: hi\n-#\n-# CHECK:      $ \":\" \"RUN: at line 3\"\n-# CHECK-NEXT: $ \"not\" \"not\" \"wc\" \"missing-file\"\n-# CHECK-NEXT: # redirected output from '{{.*(/|\\\\\\\\)}}basic.txt.tmp.out':\n-# CHECK-NEXT: {{cannot open missing-file|missing-file.* No such file or directory}}\n-# CHECK:      note: command had no output on stdout or stderr\n-# CHECK-NEXT: error: command failed with exit status: 1\n+#       CHECK: -- Testing: {{.*}}\n+#       CHECK: FAIL: shtest-output-printing :: basic.txt {{.*}}\n+#  CHECK-NEXT: ***{{\\**}} TEST 'shtest-output-printing :: basic.txt' FAILED ***{{\\**}}\n+#  CHECK-NEXT: Exit Code: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: Command Output (stdout):\n+#  CHECK-NEXT: --\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: true\n+#  CHECK-NEXT: # executed command: true\n+#  CHECK-NEXT: # RUN: at line 2\n+#  CHECK-NEXT: echo hi\n+#  CHECK-NEXT: # executed command: echo hi\n+#  CHECK-NEXT: # .---command stdout------------\n+#  CHECK-NEXT: # | hi\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # RUN: at line 3\n+#  CHECK-NEXT: not not wc missing-file &> [[FILE:.*]] || true\n+#  CHECK-NEXT: # executed command: not not wc missing-file\n+#  CHECK-NEXT: # .---redirected output from '[[FILE]]'\n+#  CHECK-NEXT: # | wc: {{cannot open missing-file|missing-file.* No such file or directory}}\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+#  CHECK-NEXT: # executed command: true\n+#  CHECK-NEXT: # RUN: at line 4\n+#  CHECK-NEXT: not {{.*}}/python{{.*}} {{.*}}/write-a-lot.py &> [[FILE:.*]]\n+#  CHECK-NEXT: # executed command: not {{.*}}/python{{.*}} {{.*}}/write-a-lot.py\n+#  CHECK-NEXT: # .---redirected output from '[[FILE]]'\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#       CHECK: # | ...\n+#  CHECK-NEXT: # `---data was truncated--------\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT:--\ndiff --git a/llvm/utils/lit/tests/shtest-pushd-popd.py b/llvm/utils/lit/tests/shtest-pushd-popd.py\nindex 26296a7ffcf5..6d7e93c74a05 100644\n--- a/llvm/utils/lit/tests/shtest-pushd-popd.py\n+++ b/llvm/utils/lit/tests/shtest-pushd-popd.py\n@@ -8,16 +8,16 @@\n # CHECK: -- Testing: 4 tests{{.*}}\n \n # CHECK: FAIL: shtest-pushd-popd :: popd-args.txt ({{[^)]*}})\n-# CHECK: $ \"popd\" \"invalid\"\n-# CHECK: 'popd' does not support arguments\n+# CHECK: popd invalid\n+# CHECK: # | 'popd' does not support arguments\n \n # CHECK: FAIL: shtest-pushd-popd :: popd-no-stack.txt ({{[^)]*}})\n-# CHECK: $ \"popd\"\n-# CHECK: popd: directory stack empty\n+# CHECK: popd\n+# CHECK: # | popd: directory stack empty\n \n # CHECK: FAIL: shtest-pushd-popd :: pushd-too-many-args.txt ({{[^)]*}})\n-# CHECK: $ \"pushd\" \"a\" \"b\"\n-# CHECK: 'pushd' supports only one argument\n+# CHECK: pushd a b\n+# CHECK: # | 'pushd' supports only one argument\n \n # CHECK: Passed:  1\n # CHECK: Failed:  3\ndiff --git a/llvm/utils/lit/tests/shtest-recursive-substitution.py b/llvm/utils/lit/tests/shtest-recursive-substitution.py\nindex 48f4b5b12491..65c177e65a3c 100644\n--- a/llvm/utils/lit/tests/shtest-recursive-substitution.py\n+++ b/llvm/utils/lit/tests/shtest-recursive-substitution.py\n@@ -3,7 +3,7 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/substitutes-within-limit --show-all | FileCheck --check-prefix=CHECK-TEST1 %s\n # CHECK-TEST1: PASS: substitutes-within-limit :: test.py\n-# CHECK-TEST1: $ \"echo\" \"STOP\"\n+# CHECK-TEST1: echo STOP\n \n # RUN: not %{lit} %{inputs}/shtest-recursive-substitution/does-not-substitute-within-limit --show-all | FileCheck --check-prefix=CHECK-TEST2 %s\n # CHECK-TEST2: UNRESOLVED: does-not-substitute-within-limit :: test.py\n@@ -11,7 +11,7 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/does-not-substitute-no-limit --show-all | FileCheck --check-prefix=CHECK-TEST3 %s\n # CHECK-TEST3: PASS: does-not-substitute-no-limit :: test.py\n-# CHECK-TEST3: $ \"echo\" \"%rec4\"\n+# CHECK-TEST3: echo %rec4\n \n # RUN: not %{lit} %{inputs}/shtest-recursive-substitution/not-an-integer --show-all 2>&1 | FileCheck --check-prefix=CHECK-TEST4 %s\n # CHECK-TEST4: recursiveExpansionLimit must be either None or an integer\n@@ -24,4 +24,4 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/escaping --show-all | FileCheck --check-prefix=CHECK-TEST7 %s\n # CHECK-TEST7: PASS: escaping :: test.py\n-# CHECK-TEST7: $ \"echo\" \"%s\" \"%s\" \"%%s\"\n+# CHECK-TEST7: echo %s %s %%s\ndiff --git a/llvm/utils/lit/tests/shtest-run-at-line.py b/llvm/utils/lit/tests/shtest-run-at-line.py\nindex 879cd64ebf6e..a0626f872c4c 100644\n--- a/llvm/utils/lit/tests/shtest-run-at-line.py\n+++ b/llvm/utils/lit/tests/shtest-run-at-line.py\n@@ -28,21 +28,28 @@\n # CHECK-LABEL: FAIL: shtest-run-at-line :: internal-shell/basic.txt\n \n # CHECK:      Command Output (stdout)\n-# CHECK:      $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \"true\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-# CHECK-NEXT: $ \"false\"\n+# CHECK-NEXT: --\n+# CHECK-NEXT: # RUN: at line 1\n+# CHECK-NEXT: true\n+# CHECK-NEXT: # executed command: true\n+# CHECK-NEXT: # RUN: at line 2\n+# CHECK-NEXT: false\n+# CHECK-NEXT: # executed command: false\n # CHECK-NOT:  RUN\n \n # CHECK-LABEL: FAIL: shtest-run-at-line :: internal-shell/line-continuation.txt\n \n # CHECK:      Command Output (stdout)\n-# CHECK:      $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \":\" \"first\" \"line\" \"continued\" \"to\" \"second\" \"line\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 3\"\n-# CHECK-NEXT: $ \"echo\" \"foo bar\"\n-# CHECK-NEXT: $ \"FileCheck\" \"{{.*}}\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 5\"\n-# CHECK-NEXT: $ \"echo\" \"foo baz\"\n-# CHECK-NEXT: $ \"FileCheck\" \"{{.*}}\"\n+# CHECK-NEXT: --\n+# CHECK-NEXT: # RUN: at line 1\n+# CHECK-NEXT: : first line continued to second line\n+# CHECK-NEXT: # executed command: : first line continued to second line\n+# CHECK-NEXT: # RUN: at line 3\n+# CHECK-NEXT: echo 'foo bar' | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: echo 'foo bar'\n+# CHECK-NEXT: # executed command: FileCheck {{.*}}\n+# CHECK-NEXT: # RUN: at line 5\n+# CHECK-NEXT: echo 'foo baz' | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: echo 'foo baz'\n+# CHECK-NEXT: # executed command: FileCheck {{.*}}\n # CHECK-NOT:  RUN\ndiff --git a/llvm/utils/lit/tests/shtest-shell.py b/llvm/utils/lit/tests/shtest-shell.py\nindex 93f05dbd35d0..8ce71296c144 100644\n--- a/llvm/utils/lit/tests/shtest-shell.py\n+++ b/llvm/utils/lit/tests/shtest-shell.py\n@@ -20,202 +20,212 @@\n \n # CHECK: FAIL: shtest-shell :: cat-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: cat-error-0.txt' FAILED ***\n-# CHECK: $ \"cat\" \"-b\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'cat':  option -b not recognized\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: cat -b temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'cat':  option -b not recognized\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: cat-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: cat-error-1.txt' FAILED ***\n-# CHECK: $ \"cat\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: [Errno 2] No such file or directory: 'temp1.txt'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: cat temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | [Errno 2] No such file or directory: 'temp1.txt'\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: colon-error.txt\n # CHECK: *** TEST 'shtest-shell :: colon-error.txt' FAILED ***\n-# CHECK: $ \":\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: ':' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: :\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: ':' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: PASS: shtest-shell :: continuations.txt\n \n # CHECK: PASS: shtest-shell :: dev-null.txt\n \n-# CHECK: FAIL: shtest-shell :: diff-b.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-b.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-b\" \"{{[^\"]*}}.0\" \"{{[^\"]*}}.1\"\n-# CHECK: # command output:\n-# CHECK: 1,2\n-# CHECK-NEXT: {{^  }}f o o\n-# CHECK-NEXT: ! b a r\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: {{^  }}f o o\n-# CHECK-NEXT: ! bar\n-# CHECK-EMPTY:\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-b.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-b.txt' FAILED ***\n+#      CHECK: diff -b {{[^\"]*}}.0 {{[^\"]*}}.1\n+#      CHECK: # .---command stdout{{-*}}\n+#      CHECK: # | {{.*}}1,2\n+# CHECK-NEXT: # |   f o o\n+# CHECK-NEXT: # | ! b a r\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # |   f o o\n+# CHECK-NEXT: # | ! bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+#      CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-encodings.txt\n # CHECK: *** TEST 'shtest-shell :: diff-encodings.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"diff-in.bin\"\n+#      CHECK: diff -u diff-in.bin diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.bin diff-in.bin\n+#  CHECK-NOT: error\n+\n+#      CHECK: diff -u diff-in.utf16 diff-in.bin && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf16 diff-in.bin\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.utf8 diff-in.bin && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf8 diff-in.bin\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | -baz\n+# CHECK-NEXT: # | {{\\+.f.o.o.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{\\+.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.bin diff-in.utf8 && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.bin diff-in.utf8\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{-.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.}}\n+# CHECK-NEXT: # | {{-.b.a.z.$}}\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # | +baz\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#     CHECK: cat diff-in.bin | diff -u - diff-in.bin\n # CHECK-NOT: error\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf16\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^ .f.o.o.$}}\n-# CHECK-NEXT: {{^-.b.a.r.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^ .b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf8\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: -baz\n-# CHECK-NEXT: {{^\\+.f.o.o.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^\\+.b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"diff-in.utf8\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^\\-.f.o.o.$}}\n-# CHECK-NEXT: {{^\\-.b.a.r.}}\n-# CHECK-NEXT: {{^\\-.b.a.z.$}}\n-# CHECK-NEXT: +foo\n-# CHECK-NEXT: +bar\n-# CHECK-NEXT: +baz\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"-\"\n-# CHECK-NOT: error\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf16\" \"-\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^ .f.o.o.$}}\n-# CHECK-NEXT: {{^-.b.a.r.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^ .b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n+#     CHECK: cat diff-in.bin | diff -u diff-in.bin -\n # CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf8\" \"-\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: -baz\n-# CHECK-NEXT: {{^\\+.f.o.o.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^\\+.b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"diff-in.utf8\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^\\-.f.o.o.$}}\n-# CHECK-NEXT: {{^\\-.b.a.r.}}\n-# CHECK-NEXT: {{^\\-.b.a.z.$}}\n-# CHECK-NEXT: +foo\n-# CHECK-NEXT: +bar\n-# CHECK-NEXT: +baz\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n \n-# CHECK: $ \"false\"\n+#      CHECK: cat diff-in.bin | diff -u diff-in.utf16 - && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf16 -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat diff-in.bin | diff -u diff-in.utf8 - && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf8 -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | -baz\n+# CHECK-NEXT: # | {{\\+.f.o.o.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{\\+.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat diff-in.bin | diff -u - diff-in.utf8 && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u - diff-in.utf8\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{-.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.}}\n+# CHECK-NEXT: # | {{-.b.a.z.$}}\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # | +baz\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-1.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-B\" \"temp1.txt\" \"temp2.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'diff': option -B not recognized\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -B temp1.txt temp2.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'diff': option -B not recognized\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-2.txt' FAILED ***\n-# CHECK: $ \"diff\" \"temp.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff temp.txt \n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-3.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-3.txt' FAILED ***\n-# CHECK: $ \"diff\" \"temp.txt\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'diff' command failed\n+# CHECK: diff temp.txt temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'diff' command failed\n # CHECK: error: command failed with exit status: 1\n # CHECK: ***\n \n-# CHECK: FAIL: shtest-shell :: diff-error-4.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-error-4.txt' FAILED ***\n-# CHECK: Exit Code: 1\n-# CHECK: # command output:\n-# CHECK: diff-error-4.txt.tmp\n-# CHECK: diff-error-4.txt.tmp1\n-# CHECK: *** 1 ****\n-# CHECK: ! hello-first\n-# CHECK: --- 1 ----\n-# CHECK: ! hello-second\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-error-4.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-error-4.txt' FAILED ***\n+#      CHECK: Exit Code: 1\n+#      CHECK: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | {{.*}}diff-error-4.txt.tmp\n+# CHECK-NEXT: # | {{.*}}diff-error-4.txt.tmp1\n+# CHECK-NEXT: # | {{\\*+}}\n+# CHECK-NEXT: # | *** 1 ****\n+# CHECK-NEXT: # | ! hello-first\n+# CHECK-NEXT: # | --- 1 ----\n+# CHECK-NEXT: # | ! hello-second\n+# CHECK-NEXT: # `---{{-*}}\n+#      CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-5.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-5.txt' FAILED ***\n-# CHECK: $ \"diff\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-6.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-6.txt' FAILED ***\n-# CHECK: $ \"diff\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n \n@@ -223,137 +233,130 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-pipes.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.foo\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"FileCheck\"\n+# CHECK: diff {{[^ ]*}}.foo {{.*}}.foo | FileCheck {{.*}}\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: note: command had no output on stdout or stderr\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"FileCheck\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"true\"\n+#      CHECK: diff -u {{.*}}.foo {{.*}}.bar | FileCheck {{.*}} && false || true\n+# CHECK-NEXT: # executed command: diff -u {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # note: command had no output on stdout or stderr\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: FileCheck\n+# CHECK-NEXT: # executed command: true\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"{{[^\"]*}}.foo\"\n+#     CHECK: cat {{.*}}.foo | diff -u - {{.*}}.foo\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n+#     CHECK: cat {{.*}}.foo | diff -u {{.*}}.foo -\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: +bar\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"{{[^\"]*}}.foo\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: +foo\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-\" \"{{[^\"]*}}.foo\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"FileCheck\"\n+#      CHECK: cat {{.*}}.bar | diff -u {{.*}}.foo - && false || true\n+# CHECK-NEXT: # executed command: cat {{.*}}.bar\n+# CHECK-NEXT: # executed command: diff -u {{.*}}.foo -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat {{.*}}.bar | diff -u - {{.*}}.foo && false || true\n+# CHECK-NEXT: # executed command: cat {{.*}}.bar\n+# CHECK-NEXT: # executed command: diff -u - {{.*}}.foo\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#     CHECK: cat {{.*}}.foo | diff - {{.*}}.foo | FileCheck {{.*}}\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n-# CHECK: note: command had no output on stdout or stderr\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"FileCheck\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"true\"\n+#      CHECK: cat {{.*}}.bar | diff -u {{.*}}.foo - | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: cat {{.*}}.bar\n+# CHECK-NEXT: # executed command: diff -u {{.*}}.foo -\n+# CHECK-NEXT: note: command had no output on stdout or stderr\n+# CHECK-NEXT: error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: FileCheck\n+# CHECK-NEXT: # executed command: true\n \n-# CHECK: $ \"false\"\n+# CHECK: false\n \n # CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-r-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-0.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: dir1unique\n-# CHECK: Only in {{.*}}dir2: dir2unique\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: dir1unique\n+# CHECK: # | Only in {{.*}}dir2: dir2unique\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-1.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: *** {{.*}}dir1{{.*}}subdir{{.*}}f01\n-# CHECK: --- {{.*}}dir2{{.*}}subdir{{.*}}f01\n-# CHECK: 12345\n-# CHECK: 00000\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | *** {{.*}}dir1{{.*}}subdir{{.*}}f01\n+# CHECK: # | --- {{.*}}dir2{{.*}}subdir{{.*}}f01\n+# CHECK: # | ! 12345\n+# CHECK: # | ! 00000\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-2.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir2: extrafile\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir2: extrafile\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-3.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-3.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: extra_subdir\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: extra_subdir\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-4.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-4.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: File {{.*}}dir1{{.*}}extra_subdir is a directory while file {{.*}}dir2{{.*}}extra_subdir is a regular file\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | File {{.*}}dir1{{.*}}extra_subdir is a directory while file {{.*}}dir2{{.*}}extra_subdir is a regular file\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-5.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-5.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: extra_subdir\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: extra_subdir\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-6.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-6.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: File {{.*}}dir1{{.*}}extra_file is a regular empty file while file {{.*}}dir2{{.*}}extra_file is a directory\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | File {{.*}}dir1{{.*}}extra_file is a regular empty file while file {{.*}}dir2{{.*}}extra_file is a directory\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-7.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-7.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\" \"-\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: cannot recursively compare '-'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r - {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: cannot recursively compare '-'\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-8.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-8.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\" \"{{[^\"]*}}\" \"-\"\n-# CHECK: # command stderr:\n-# CHECK: Error: cannot recursively compare '-'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r {{.*}} -\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: cannot recursively compare '-'\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: PASS: shtest-shell :: diff-r.txt\n \n@@ -362,51 +365,59 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-strip-trailing-cr.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.dos\" \"diff-in.unix\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -In this file, the\n-# CHECK-NEXT: -sequence \"\\r\\n\"\n-# CHECK-NEXT: -terminates lines.\n-# CHECK-NEXT: +In this file, the\n-# CHECK-NEXT: +sequence \"\\n\"\n-# CHECK-NEXT: +terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.unix\" \"diff-in.dos\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -In this file, the\n-# CHECK-NEXT: -sequence \"\\n\"\n-# CHECK-NEXT: -terminates lines.\n-# CHECK-NEXT: +In this file, the\n-# CHECK-NEXT: +sequence \"\\r\\n\"\n-# CHECK-NEXT: +terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"--strip-trailing-cr\" \"diff-in.dos\" \"diff-in.unix\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT:  In this file, the\n-# CHECK-NEXT: -sequence \"\\r\\n\"\n-# CHECK-NEXT: +sequence \"\\n\"\n-# CHECK-NEXT:  terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"--strip-trailing-cr\" \"diff-in.unix\" \"diff-in.dos\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT:  In this file, the\n-# CHECK-NEXT: -sequence \"\\n\"\n-# CHECK-NEXT: +sequence \"\\r\\n\"\n-# CHECK-NEXT:  terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"false\"\n+#      CHECK: diff -u diff-in.dos diff-in.unix && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.dos diff-in.unix\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -In this file, the\n+# CHECK-NEXT: # | -sequence \"\\r\\n\"\n+# CHECK-NEXT: # | -terminates lines.\n+# CHECK-NEXT: # | +In this file, the\n+# CHECK-NEXT: # | +sequence \"\\n\"\n+# CHECK-NEXT: # | +terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.unix diff-in.dos && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.unix diff-in.dos\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -In this file, the\n+# CHECK-NEXT: # | -sequence \"\\n\"\n+# CHECK-NEXT: # | -terminates lines.\n+# CHECK-NEXT: # | +In this file, the\n+# CHECK-NEXT: # | +sequence \"\\r\\n\"\n+# CHECK-NEXT: # | +terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u --strip-trailing-cr diff-in.dos diff-in.unix && false || true\n+# CHECK-NEXT: executed command: diff -u --strip-trailing-cr diff-in.dos diff-in.unix\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # |  In this file, the\n+# CHECK-NEXT: # | -sequence \"\\r\\n\"\n+# CHECK-NEXT: # | +sequence \"\\n\"\n+# CHECK-NEXT: # |  terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u --strip-trailing-cr diff-in.unix diff-in.dos && false || true\n+# CHECK-NEXT: # executed command: diff -u --strip-trailing-cr diff-in.unix diff-in.dos\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # |  In this file, the\n+# CHECK-NEXT: # | -sequence \"\\n\"\n+# CHECK-NEXT: # | +sequence \"\\r\\n\"\n+# CHECK-NEXT: # |  terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n@@ -415,106 +426,144 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-unified.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 3\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-NEXT: 9\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U\" \"2\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U4\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 2\n-# CHECK-NEXT: 3\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-NEXT: 9\n-# CHECK-NEXT: 10\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U0\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U\" \"30.1\" \"{{[^\"]*}}\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: invalid '-U' argument: 30.1\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U-1\" \"{{[^\"]*}}\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: invalid '-U' argument: -1\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"false\"\n+#      CHECK: diff -u {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -u {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 3\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # | 9\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U 2 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U 2 {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U4 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U4 {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 2\n+# CHECK-NEXT: # | 3\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # | 9\n+# CHECK-NEXT: # | 10\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U0 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: diff -U0 {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: diff -U 30.1 {{.*}} {{.*}} && false || true\n+# CHECK: # executed command: diff -U 30.1 {{.*}} {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: invalid '-U' argument: 30.1\n+# CHECK: # error: command failed with exit status: 1\n+# CHECK: # executed command: true\n+\n+# CHECK: diff -U-1 {{.*}} {{.*}} && false || true\n+# CHECK: # executed command: diff -U-1 {{.*}} {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: invalid '-U' argument: -1\n+# CHECK: # error: command failed with exit status: 1\n+# CHECK: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n \n-# CHECK: FAIL: shtest-shell :: diff-w.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-w.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-w\" \"{{[^\"]*}}.0\" \"{{[^\"]*}}.1\"\n-# CHECK: # command output:\n-# CHECK: 1,3\n-# CHECK-NEXT: {{^  }}foo\n-# CHECK-NEXT: {{^  }}bar\n-# CHECK-NEXT: ! baz\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: {{^  }}foo\n-# CHECK-NEXT: {{^  }}bar\n-# CHECK-NEXT: ! bat\n-# CHECK-EMPTY:\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-w.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-w.txt' FAILED ***\n+#      CHECK: diff -w {{.*}}.0 {{.*}}.1\n+#      CHECK: # .---command stdout{{-*}}\n+#      CHECK: # | {{\\*+}} 1,3\n+# CHECK-NEXT: # |   foo\n+# CHECK-NEXT: # |   bar\n+# CHECK-NEXT: # | ! baz\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # |   foo\n+# CHECK-NEXT: # |   bar\n+# CHECK-NEXT: # | ! bat\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+#      CHECK: ***\n+\n+# CHECK: FAIL: shtest-shell :: echo-at-redirect-stderr.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-at-redirect-stderr.txt' FAILED ***\n+# CHECK: @echo 2> {{.*}}\n+# CHECK: # executed command: @echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for @echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-at-redirect-stdin.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-at-redirect-stdin.txt' FAILED ***\n+# CHECK: @echo < {{.*}}\n+# CHECK: # executed command: @echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for @echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-redirect-stderr.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-redirect-stderr.txt' FAILED ***\n+# CHECK: echo 2> {{.*}}\n+# CHECK: # executed command: echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-redirect-stdin.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-redirect-stdin.txt' FAILED ***\n+# CHECK: echo < {{.*}}\n+# CHECK: # executed command: echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for echo\n+# CHECK: error: command failed with exit status:\n \n # CHECK: FAIL: shtest-shell :: error-0.txt\n # CHECK: *** TEST 'shtest-shell :: error-0.txt' FAILED ***\n-# CHECK: $ \"not-a-real-command\"\n-# CHECK: # command stderr:\n-# CHECK: 'not-a-real-command': command not found\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: not-a-real-command\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | 'not-a-real-command': command not found\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # FIXME: The output here sucks.\n #\n # CHECK: FAIL: shtest-shell :: error-1.txt\n # CHECK: *** TEST 'shtest-shell :: error-1.txt' FAILED ***\n-# CHECK: shell parser error on: ': \\'RUN: at line 3\\'; echo \"missing quote'\n+# CHECK: shell parser error on RUN: at line 3: echo \"missing quote\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: error-2.txt\n@@ -524,52 +573,52 @@\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-0.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'mkdir' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p temp | rm -rf temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'mkdir' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-1.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\" \"-m\" \"777\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'mkdir': option -m not recognized\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p -m 777 temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'mkdir': option -m not recognized\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-2.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'mkdir' is missing an operand\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'mkdir' is missing an operand\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: PASS: shtest-shell :: redirects.txt\n \n # CHECK: FAIL: shtest-shell :: rm-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-0.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-rf\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'rm' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: rm -rf temp | echo \"hello\"\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'rm' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-1.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-f\" \"-v\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'rm': option -v not recognized\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: rm -f -v temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'rm': option -v not recognized\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-2.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-r\" \"hello\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'rm' command failed\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: rm -r hello\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'rm' command failed\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-3.txt\n@@ -581,16 +630,17 @@\n # CHECK: PASS: shtest-shell :: sequencing-0.txt\n # CHECK: XFAIL: shtest-shell :: sequencing-1.txt\n \n-# CHECK: FAIL: shtest-shell :: stdout-encoding.txt\n-# CHECK: *** TEST 'shtest-shell :: stdout-encoding.txt' FAILED ***\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: {{^.f.o.o.$}}\n-# CHECK-NEXT: {{^.b.a.r.}}\n-# CHECK-NEXT: {{^.b.a.z.$}}\n-# CHECK-NOT: error\n-# CHECK: $ \"false\"\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: stdout-encoding.txt\n+#      CHECK: *** TEST 'shtest-shell :: stdout-encoding.txt' FAILED ***\n+#      CHECK: cat diff-in.bin\n+#      CHECK: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+#  CHECK-NOT: error\n+#      CHECK: false\n+#      CHECK: ***\n \n # CHECK: PASS: shtest-shell :: valid-shell.txt\n-# CHECK: Failed Tests (35)\n+# CHECK: Failed Tests (39)\n", "message": "", "files": {"/libcxx/utils/libcxx/test/dsl.py": {"changes": [{"diff": "\n                 \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n             )\n \n-        return libcxx.test.format._parseLitOutput(out)\n+        return out\n \n \n @_memoizeExpensiveOperation(", "add": 1, "remove": 1, "filename": "/libcxx/utils/libcxx/test/dsl.py", "badparts": ["        return libcxx.test.format._parseLitOutput(out)"], "goodparts": ["        return out"]}], "source": "\n import os import pickle import pipes import platform import re import shutil import subprocess import tempfile import libcxx.test.format import lit import lit.LitConfig import lit.Test import lit.TestRunner import lit.util class ConfigurationError(Exception): pass class ConfigurationCompilationError(ConfigurationError): pass class ConfigurationRuntimeError(ConfigurationError): pass def _memoizeExpensiveOperation(extractCacheKey): \"\"\" Allows memoizing a very expensive operation. We pickle the cache key to make sure we store an immutable representation of it. If we stored an object and the object was referenced elsewhere, it could be changed from under our feet, which would break the cache. We also store the cache for a given function persistently across invocations of Lit. This dramatically speeds up the configuration of the test suite when invoking Lit repeatedly, which is important for developer workflow. However, with the current implementation that does not synchronize updates to the persistent cache, this also means that one should not call a memoized operation from multiple threads. This should normally not be a problem since Lit configuration is single-threaded. \"\"\" def decorator(function): def f(config, *args, **kwargs): cacheRoot=os.path.join(config.test_exec_root, \"__config_cache__\") persistentCache=os.path.join(cacheRoot, function.__name__) if not os.path.exists(cacheRoot): os.makedirs(cacheRoot) cache={} if os.path.exists(persistentCache): with open(persistentCache, \"rb\") as cacheFile: cache=pickle.load(cacheFile) cacheKey=pickle.dumps(extractCacheKey(config, *args, **kwargs)) if cacheKey not in cache: cache[cacheKey]=function(config, *args, **kwargs) with open(persistentCache, \"wb\") as cacheFile: pickle.dump(cache, cacheFile) return cache[cacheKey] return f return decorator def _executeWithFakeConfig(test, commands): \"\"\" Returns(stdout, stderr, exitCode, timeoutInfo, parsedCommands) \"\"\" litConfig=lit.LitConfig.LitConfig( progname=\"lit\", path=[], quiet=False, useValgrind=False, valgrindLeakCheck=False, valgrindArgs=[], noExecute=False, debug=False, isWindows=platform.system()==\"Windows\", order=\"smart\", params={}, ) return libcxx.test.format._executeScriptInternal(test, litConfig, commands) def _makeConfigTest(config): sourceRoot=os.path.join(config.test_exec_root, \"__config_src__\") execRoot=os.path.join(config.test_exec_root, \"__config_exec__\") for supportDir in(sourceRoot, execRoot): if not os.path.exists(supportDir): os.makedirs(supportDir) suite=lit.Test.TestSuite(\"__config__\", sourceRoot, execRoot, config) tmp=tempfile.NamedTemporaryFile(dir=sourceRoot, delete=False, suffix=\".cpp\") tmp.close() pathInSuite=[os.path.relpath(tmp.name, sourceRoot)] class TestWrapper(lit.Test.Test): def __enter__(self): testDir, _=libcxx.test.format._getTempPaths(self) os.makedirs(testDir) return self def __exit__(self, *args): testDir, _=libcxx.test.format._getTempPaths(self) shutil.rmtree(testDir) os.remove(tmp.name) return TestWrapper(suite, pathInSuite, config) @_memoizeExpensiveOperation(lambda c, s, f=[]:(c.substitutions, c.environment, s, f)) def sourceBuilds(config, source, additionalFlags=[]): \"\"\" Return whether the program in the given string builds successfully. This is done by compiling and linking a program that consists of the given source with the %{cxx} substitution, and seeing whether that succeeds. If any additional flags are passed, they are appended to the compiler invocation. \"\"\" with _makeConfigTest(config) as test: with open(test.getSourcePath(), \"w\") as sourceFile: sourceFile.write(source) _, _, exitCode, _, _=_executeWithFakeConfig( test,[\"%{{build}}{}\".format(\" \".join(additionalFlags))] ) return exitCode==0 @_memoizeExpensiveOperation( lambda c, p, args=None:(c.substitutions, c.environment, p, args) ) def programOutput(config, program, args=None): \"\"\" Compiles a program for the test target, run it on the test target and return the output. Note that execution of the program is done through the %{exec} substitution, which means that the program may be run on a remote host depending on what %{exec} does. \"\"\" if args is None: args=[] with _makeConfigTest(config) as test: with open(test.getSourcePath(), \"w\") as source: source.write(program) _, err, exitCode, _, buildcmd=_executeWithFakeConfig(test,[\"%{build}\"]) if exitCode !=0: raise ConfigurationCompilationError( \"Failed to build program, cmd:\\n{}\\nstderr is:\\n{}\".format( buildcmd, err ) ) out, err, exitCode, _, runcmd=_executeWithFakeConfig( test,[\"%{{run}}{}\".format(\" \".join(args))] ) if exitCode !=0: raise ConfigurationRuntimeError( \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err) ) return libcxx.test.format._parseLitOutput(out) @_memoizeExpensiveOperation( lambda c, p, args=None:(c.substitutions, c.environment, p, args) ) def programSucceeds(config, program, args=None): \"\"\" Compiles a program for the test target, run it on the test target and return whether it completed successfully. Note that execution of the program is done through the %{exec} substitution, which means that the program may be run on a remote host depending on what %{exec} does. \"\"\" try: programOutput(config, program, args) except ConfigurationRuntimeError: return False return True @_memoizeExpensiveOperation(lambda c, f:(c.substitutions, c.environment, f)) def hasCompileFlag(config, flag): \"\"\" Return whether the compiler in the configuration supports a given compiler flag. This is done by executing the %{cxx} substitution with the given flag and checking whether that succeeds. \"\"\" with _makeConfigTest(config) as test: out, err, exitCode, timeoutInfo, _=_executeWithFakeConfig( test, [ \"%{{cxx}} -xc++{} -Werror -fsyntax-only %{{flags}} %{{compile_flags}}{}\".format( os.devnull, flag ) ], ) return exitCode==0 @_memoizeExpensiveOperation(lambda c, s:(c.substitutions, c.environment, s)) def runScriptExitCode(config, script): \"\"\" Runs the given script as a Lit test, and returns the exit code of the execution. The script must be a list of commands, each of which being something that could appear on the right-hand-side of a `RUN:` keyword. \"\"\" with _makeConfigTest(config) as test: _, _, exitCode, _, _=_executeWithFakeConfig(test, script) return exitCode @_memoizeExpensiveOperation(lambda c, s:(c.substitutions, c.environment, s)) def commandOutput(config, command): \"\"\" Runs the given script as a Lit test, and returns the output. If the exit code isn't 0 an exception is raised. The script must be a list of commands, each of which being something that could appear on the right-hand-side of a `RUN:` keyword. \"\"\" with _makeConfigTest(config) as test: out, err, exitCode, _, cmd=_executeWithFakeConfig(test, command) if exitCode !=0: raise ConfigurationRuntimeError( \"Failed to run command:{}\\nstderr is:\\n{}\".format(cmd, err) ) return out @_memoizeExpensiveOperation(lambda c, l:(c.substitutions, c.environment, l)) def hasAnyLocale(config, locales): \"\"\" Return whether the runtime execution environment supports a given locale. Different systems may use different names for a locale, so this function checks whether any of the passed locale names is supported by setlocale() and returns true if one of them works. This is done by executing a program that tries to set the given locale using %{exec} --this means that the command may be executed on a remote host depending on the %{exec} substitution. \"\"\" program=\"\"\" int main(int, char**){ return 1;} int main(int argc, char** argv){ for(int i=1; i < argc; i++){ if(::setlocale(LC_ALL, argv[i]) !=NULL){ return 0; } } return 1; } \"\"\" return programSucceeds(config, program, args=[pipes.quote(l) for l in locales]) @_memoizeExpensiveOperation(lambda c, flags=\"\":(c.substitutions, c.environment, flags)) def compilerMacros(config, flags=\"\"): \"\"\" Return a dictionary of predefined compiler macros. The keys are strings representing macros, and the values are strings representing what each macro is defined to. If the optional `flags` argument(a string) is provided, these flags will be added to the compiler invocation when generating the macros. \"\"\" with _makeConfigTest(config) as test: with open(test.getSourcePath(), \"w\") as sourceFile: sourceFile.write( \"\"\" \"\"\" ) unparsedOutput, err, exitCode, _, cmd=_executeWithFakeConfig( test,[\"%{{cxx}} %s -dM -E %{{flags}} %{{compile_flags}}{}\".format(flags)] ) if exitCode !=0: raise ConfigurationCompilationError( \"Failed to retrieve compiler macros, compiler invocation is:\\n{}\\nstderr is:\\n{}\".format( cmd, err ) ) parsedMacros=dict() defines=( l.strip() for l in unparsedOutput.split(\"\\n\") if l.startswith(\" ) for line in defines: line=line[len(\" macro, _, value=line.partition(\" \") parsedMacros[macro]=value return parsedMacros def featureTestMacros(config, flags=\"\"): \"\"\" Return a dictionary of feature test macros. The keys are strings representing feature test macros, and the values are integers representing the value of the macro. \"\"\" allMacros=compilerMacros(config, flags) return{ m: int(v.rstrip(\"LlUu\")) for(m, v) in allMacros.items() if m.startswith(\"__cpp_\") } def _getSubstitution(substitution, config): for(orig, replacement) in config.substitutions: if orig==substitution: return replacement raise ValueError('Substitution{} is not in the config.'.format(substitution)) def _appendToSubstitution(substitutions, key, value): return[(k, v +\" \" +value) if k==key else(k, v) for(k, v) in substitutions] def _prependToSubstitution(substitutions, key, value): return[(k, value +\" \" +v) if k==key else(k, v) for(k, v) in substitutions] class ConfigAction(object): \"\"\" This class represents an action that can be performed on a Lit TestingConfig object. Examples of such actions are adding or modifying substitutions, Lit features, etc. This class only provides the interface of such actions, and it is meant to be subclassed appropriately to create new actions. \"\"\" def applyTo(self, config): \"\"\" Applies the action to the given configuration. This should modify the configuration object in place, and return nothing. If applying the action to the configuration would yield an invalid configuration, and it is possible to diagnose it here, this method should produce an error. For example, it should be an error to modify a substitution in a way that we know for sure is invalid(e.g. adding a compiler flag when we know the compiler doesn't support it). Failure to do so early may lead to difficult-to-diagnose issues down the road. \"\"\" pass def pretty(self, config, litParams): \"\"\" Returns a short and human-readable string describing what this action does. This is used for logging purposes when running the test suite, so it should be kept concise. \"\"\" pass class AddFeature(ConfigAction): \"\"\" This action defines the given Lit feature when running the test suite. The name of the feature can be a string or a callable, in which case it is called with the configuration to produce the feature name(as a string). \"\"\" def __init__(self, name): self._name=name def _getName(self, config): name=self._name(config) if callable(self._name) else self._name if not isinstance(name, str): raise ValueError( \"Lit feature did not resolve to a string(got{})\".format(name) ) return name def applyTo(self, config): config.available_features.add(self._getName(config)) def pretty(self, config, litParams): return \"add Lit feature{}\".format(self._getName(config)) class AddFlag(ConfigAction): \"\"\" This action adds the given flag to the %{flags} substitution. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) assert hasCompileFlag( config, flag ), \"Trying to enable flag{}, which is not supported\".format(flag) config.substitutions=_appendToSubstitution( config.substitutions, \"%{flags}\", flag ) def pretty(self, config, litParams): return \"add{} to %{{flags}}\".format(self._getFlag(config)) class AddFlagIfSupported(ConfigAction): \"\"\" This action adds the given flag to the %{flags} substitution, only if the compiler supports the flag. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) if hasCompileFlag(config, flag): config.substitutions=_appendToSubstitution( config.substitutions, \"%{flags}\", flag ) def pretty(self, config, litParams): return \"add{} to %{{flags}}\".format(self._getFlag(config)) class AddCompileFlag(ConfigAction): \"\"\" This action adds the given flag to the %{compile_flags} substitution. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) assert hasCompileFlag( config, flag ), \"Trying to enable compile flag{}, which is not supported\".format(flag) config.substitutions=_appendToSubstitution( config.substitutions, \"%{compile_flags}\", flag ) def pretty(self, config, litParams): return \"add{} to %{{compile_flags}}\".format(self._getFlag(config)) class AddLinkFlag(ConfigAction): \"\"\" This action appends the given flag to the %{link_flags} substitution. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) assert hasCompileFlag( config, flag ), \"Trying to enable link flag{}, which is not supported\".format(flag) config.substitutions=_appendToSubstitution( config.substitutions, \"%{link_flags}\", flag ) def pretty(self, config, litParams): return \"append{} to %{{link_flags}}\".format(self._getFlag(config)) class PrependLinkFlag(ConfigAction): \"\"\" This action prepends the given flag to the %{link_flags} substitution. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) assert hasCompileFlag( config, flag ), \"Trying to enable link flag{}, which is not supported\".format(flag) config.substitutions=_prependToSubstitution( config.substitutions, \"%{link_flags}\", flag ) def pretty(self, config, litParams): return \"prepend{} to %{{link_flags}}\".format(self._getFlag(config)) class AddOptionalWarningFlag(ConfigAction): \"\"\" This action adds the given warning flag to the %{compile_flags} substitution, if it is supported by the compiler. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) if hasCompileFlag(config, \"-Werror \" +flag): config.substitutions=_appendToSubstitution( config.substitutions, \"%{compile_flags}\", flag ) def pretty(self, config, litParams): return \"add{} to %{{compile_flags}}\".format(self._getFlag(config)) class AddSubstitution(ConfigAction): \"\"\" This action adds the given substitution to the Lit configuration. The substitution can be a string or a callable, in which case it is called with the configuration to produce the actual substitution(as a string). \"\"\" def __init__(self, key, substitution): self._key=key self._getSub=( lambda config: substitution(config) if callable(substitution) else substitution ) def applyTo(self, config): key=self._key sub=self._getSub(config) config.substitutions.append((key, sub)) def pretty(self, config, litParams): return \"add substitution{}={}\".format(self._key, self._getSub(config)) class Feature(object): \"\"\" Represents a Lit available feature that is enabled whenever it is supported. A feature like this informs the test suite about a capability of the compiler, platform, etc. Unlike Parameters, it does not make sense to explicitly control whether a Feature is enabled --it should be enabled whenever it is supported. \"\"\" def __init__(self, name, actions=None, when=lambda _: True): \"\"\" Create a Lit feature for consumption by a test suite. -name The name of the feature. This is what will end up in Lit's available features if the feature is enabled. This can be either a string or a callable, in which case it is passed the TestingConfig and should generate a string representing the name of the feature. -actions An optional list of ConfigActions to apply when the feature is supported. An AddFeature action is always created regardless of any actions supplied here --these actions are meant to perform more than setting a corresponding Lit feature(e.g. adding compiler flags). If 'actions' is a callable, it is called with the current configuration object to generate the actual list of actions. -when A callable that gets passed a TestingConfig and should return a boolean representing whether the feature is supported in that configuration. For example, this can use `hasCompileFlag` to check whether the compiler supports the flag that the feature represents. If omitted, the feature will always be considered supported. \"\"\" self._name=name self._actions=[] if actions is None else actions self._isSupported=when def _getName(self, config): name=self._name(config) if callable(self._name) else self._name if not isinstance(name, str): raise ValueError( \"Feature did not resolve to a name that's a string, got{}\".format(name) ) return name def getActions(self, config): \"\"\" Return the list of actions associated to this feature. If the feature is not supported, an empty list is returned. If the feature is supported, an `AddFeature` action is automatically added to the returned list of actions, in addition to any actions provided on construction. \"\"\" if not self._isSupported(config): return[] else: actions=( self._actions(config) if callable(self._actions) else self._actions ) return[AddFeature(self._getName(config))] +actions def pretty(self, config): \"\"\" Returns the Feature's name. \"\"\" return self._getName(config) def _str_to_bool(s): \"\"\" Convert a string value to a boolean. True values are \"y\", \"yes\", \"t\", \"true\", \"on\" and \"1\", regardless of capitalization. False values are \"n\", \"no\", \"f\", \"false\", \"off\" and \"0\", regardless of capitalization. \"\"\" trueVals=[\"y\", \"yes\", \"t\", \"true\", \"on\", \"1\"] falseVals=[\"n\", \"no\", \"f\", \"false\", \"off\", \"0\"] lower=s.lower() if lower in trueVals: return True elif lower in falseVals: return False else: raise ValueError(\"Got string '{}', which isn't a valid boolean\".format(s)) def _parse_parameter(s, type): if type is bool and isinstance(s, str): return _str_to_bool(s) elif type is list and isinstance(s, str): return[x.strip() for x in s.split(\",\") if x.strip()] return type(s) class Parameter(object): \"\"\" Represents a parameter of a Lit test suite. Parameters are used to customize the behavior of test suites in a user controllable way. There are two ways of setting the value of a Parameter. The first one is to pass `--param <KEY>=<VALUE>` when running Lit(or equivalently to set `litConfig.params[KEY]=VALUE` somewhere in the Lit configuration files. This method will set the parameter globally for all test suites being run. The second method is to set `config.KEY=VALUE` somewhere in the Lit configuration files, which sets the parameter only for the test suite(s) that use that `config` object. Parameters can have multiple possible values, and they can have a default value when left unspecified. They can also have any number of ConfigActions associated to them, in which case the actions will be performed on the TestingConfig if the parameter is enabled. Depending on the actions associated to a Parameter, it may be an error to enable the Parameter if some actions are not supported in the given configuration. For example, trying to set the compilation standard to C++23 when `-std=c++23` is not supported by the compiler would be an error. \"\"\" def __init__(self, name, type, help, actions, choices=None, default=None): \"\"\" Create a Lit parameter to customize the behavior of a test suite. -name The name of the parameter that can be used to set it on the command-line. On the command-line, the parameter can be set using `--param <name>=<value>` when running Lit. This must be non-empty. -choices An optional non-empty set of possible values for this parameter. If provided, this must be anything that can be iterated. It is an error if the parameter is given a value that is not in that set, whether explicitly or through a default value. -type A callable that can be used to parse the value of the parameter given on the command-line. As a special case, using the type `bool` also allows parsing strings with boolean-like contents, and the type `list` will parse a string delimited by commas into a list of the substrings. -help A string explaining the parameter, for documentation purposes. TODO: We should be able to surface those from the Lit command-line. -actions A callable that gets passed the parsed value of the parameter(either the one passed on the command-line or the default one), and that returns a list of ConfigAction to perform given the value of the parameter. All the ConfigAction must be supported in the given configuration. -default An optional default value to use for the parameter when no value is provided on the command-line. If the default value is a callable, it is called with the TestingConfig and should return the default value for the parameter. Whether the default value is computed or specified directly, it must be in the 'choices' provided for that Parameter. \"\"\" self._name=name if len(self._name)==0: raise ValueError(\"Parameter name must not be the empty string\") if choices is not None: self._choices=list(choices) if len(self._choices)==0: raise ValueError( \"Parameter '{}' must be given at least one possible value\".format( self._name ) ) else: self._choices=None self._parse=lambda x: _parse_parameter(x, type) self._help=help self._actions=actions self._default=default def _getValue(self, config, litParams): \"\"\" Return the value of the parameter given the configuration objects. \"\"\" param=getattr(config, self.name, None) param=litParams.get(self.name, param) if param is None and self._default is None: raise ValueError( \"Parameter{} doesn't have a default value, but it was not specified in the Lit parameters or in the Lit config\".format( self.name ) ) getDefault=( lambda: self._default(config) if callable(self._default) else self._default ) if param is not None: (pretty, value)=(param, self._parse(param)) else: value=getDefault() pretty=\"{}(default)\".format(value) if self._choices and value not in self._choices: raise ValueError( \"Got value '{}' for parameter '{}', which is not in the provided set of possible choices:{}\".format( value, self.name, self._choices ) ) return(pretty, value) @property def name(self): \"\"\" Return the name of the parameter. This is the name that can be used to set the parameter on the command-line when running Lit. \"\"\" return self._name def getActions(self, config, litParams): \"\"\" Return the list of actions associated to this value of the parameter. \"\"\" (_, parameterValue)=self._getValue(config, litParams) return self._actions(parameterValue) def pretty(self, config, litParams): \"\"\" Return a pretty representation of the parameter's name and value. \"\"\" (prettyParameterValue, _)=self._getValue(config, litParams) return \"{}={}\".format(self.name, prettyParameterValue) ", "sourceWithComments": "# ===----------------------------------------------------------------------===##\n#\n# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n# See https://llvm.org/LICENSE.txt for license information.\n# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n#\n# ===----------------------------------------------------------------------===##\n\nimport os\nimport pickle\nimport pipes\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport tempfile\n\nimport libcxx.test.format\nimport lit\nimport lit.LitConfig\nimport lit.Test\nimport lit.TestRunner\nimport lit.util\n\n\nclass ConfigurationError(Exception):\n    pass\n\n\nclass ConfigurationCompilationError(ConfigurationError):\n    pass\n\n\nclass ConfigurationRuntimeError(ConfigurationError):\n    pass\n\n\ndef _memoizeExpensiveOperation(extractCacheKey):\n    \"\"\"\n    Allows memoizing a very expensive operation.\n\n    We pickle the cache key to make sure we store an immutable representation\n    of it. If we stored an object and the object was referenced elsewhere, it\n    could be changed from under our feet, which would break the cache.\n\n    We also store the cache for a given function persistently across invocations\n    of Lit. This dramatically speeds up the configuration of the test suite when\n    invoking Lit repeatedly, which is important for developer workflow. However,\n    with the current implementation that does not synchronize updates to the\n    persistent cache, this also means that one should not call a memoized\n    operation from multiple threads. This should normally not be a problem\n    since Lit configuration is single-threaded.\n    \"\"\"\n\n    def decorator(function):\n        def f(config, *args, **kwargs):\n            cacheRoot = os.path.join(config.test_exec_root, \"__config_cache__\")\n            persistentCache = os.path.join(cacheRoot, function.__name__)\n            if not os.path.exists(cacheRoot):\n                os.makedirs(cacheRoot)\n\n            cache = {}\n            # Load a cache from a previous Lit invocation if there is one.\n            if os.path.exists(persistentCache):\n                with open(persistentCache, \"rb\") as cacheFile:\n                    cache = pickle.load(cacheFile)\n\n            cacheKey = pickle.dumps(extractCacheKey(config, *args, **kwargs))\n            if cacheKey not in cache:\n                cache[cacheKey] = function(config, *args, **kwargs)\n                # Update the persistent cache so it knows about the new key\n                with open(persistentCache, \"wb\") as cacheFile:\n                    pickle.dump(cache, cacheFile)\n            return cache[cacheKey]\n\n        return f\n\n    return decorator\n\n\ndef _executeWithFakeConfig(test, commands):\n    \"\"\"\n    Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n    \"\"\"\n    litConfig = lit.LitConfig.LitConfig(\n        progname=\"lit\",\n        path=[],\n        quiet=False,\n        useValgrind=False,\n        valgrindLeakCheck=False,\n        valgrindArgs=[],\n        noExecute=False,\n        debug=False,\n        isWindows=platform.system() == \"Windows\",\n        order=\"smart\",\n        params={},\n    )\n    return libcxx.test.format._executeScriptInternal(test, litConfig, commands)\n\n\ndef _makeConfigTest(config):\n    # Make sure the support directories exist, which is needed to create\n    # the temporary file %t below.\n    sourceRoot = os.path.join(config.test_exec_root, \"__config_src__\")\n    execRoot = os.path.join(config.test_exec_root, \"__config_exec__\")\n    for supportDir in (sourceRoot, execRoot):\n        if not os.path.exists(supportDir):\n            os.makedirs(supportDir)\n\n    # Create a dummy test suite and single dummy test inside it. As part of\n    # the Lit configuration, automatically do the equivalent of 'mkdir %T'\n    # and 'rm -r %T' to avoid cluttering the build directory.\n    suite = lit.Test.TestSuite(\"__config__\", sourceRoot, execRoot, config)\n    tmp = tempfile.NamedTemporaryFile(dir=sourceRoot, delete=False, suffix=\".cpp\")\n    tmp.close()\n    pathInSuite = [os.path.relpath(tmp.name, sourceRoot)]\n\n    class TestWrapper(lit.Test.Test):\n        def __enter__(self):\n            testDir, _ = libcxx.test.format._getTempPaths(self)\n            os.makedirs(testDir)\n            return self\n\n        def __exit__(self, *args):\n            testDir, _ = libcxx.test.format._getTempPaths(self)\n            shutil.rmtree(testDir)\n            os.remove(tmp.name)\n\n    return TestWrapper(suite, pathInSuite, config)\n\n\n@_memoizeExpensiveOperation(lambda c, s, f=[]: (c.substitutions, c.environment, s, f))\ndef sourceBuilds(config, source, additionalFlags=[]):\n    \"\"\"\n    Return whether the program in the given string builds successfully.\n\n    This is done by compiling and linking a program that consists of the given\n    source with the %{cxx} substitution, and seeing whether that succeeds. If\n    any additional flags are passed, they are appended to the compiler invocation.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        with open(test.getSourcePath(), \"w\") as sourceFile:\n            sourceFile.write(source)\n        _, _, exitCode, _, _ = _executeWithFakeConfig(\n            test, [\"%{{build}} {}\".format(\" \".join(additionalFlags))]\n        )\n        return exitCode == 0\n\n\n@_memoizeExpensiveOperation(\n    lambda c, p, args=None: (c.substitutions, c.environment, p, args)\n)\ndef programOutput(config, program, args=None):\n    \"\"\"\n    Compiles a program for the test target, run it on the test target and return\n    the output.\n\n    Note that execution of the program is done through the %{exec} substitution,\n    which means that the program may be run on a remote host depending on what\n    %{exec} does.\n    \"\"\"\n    if args is None:\n        args = []\n    with _makeConfigTest(config) as test:\n        with open(test.getSourcePath(), \"w\") as source:\n            source.write(program)\n        _, err, exitCode, _, buildcmd = _executeWithFakeConfig(test, [\"%{build}\"])\n        if exitCode != 0:\n            raise ConfigurationCompilationError(\n                \"Failed to build program, cmd:\\n{}\\nstderr is:\\n{}\".format(\n                    buildcmd, err\n                )\n            )\n\n        out, err, exitCode, _, runcmd = _executeWithFakeConfig(\n            test, [\"%{{run}} {}\".format(\" \".join(args))]\n        )\n        if exitCode != 0:\n            raise ConfigurationRuntimeError(\n                \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n            )\n\n        return libcxx.test.format._parseLitOutput(out)\n\n\n@_memoizeExpensiveOperation(\n    lambda c, p, args=None: (c.substitutions, c.environment, p, args)\n)\ndef programSucceeds(config, program, args=None):\n    \"\"\"\n    Compiles a program for the test target, run it on the test target and return\n    whether it completed successfully.\n\n    Note that execution of the program is done through the %{exec} substitution,\n    which means that the program may be run on a remote host depending on what\n    %{exec} does.\n    \"\"\"\n    try:\n        programOutput(config, program, args)\n    except ConfigurationRuntimeError:\n        return False\n    return True\n\n\n@_memoizeExpensiveOperation(lambda c, f: (c.substitutions, c.environment, f))\ndef hasCompileFlag(config, flag):\n    \"\"\"\n    Return whether the compiler in the configuration supports a given compiler flag.\n\n    This is done by executing the %{cxx} substitution with the given flag and\n    checking whether that succeeds.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        out, err, exitCode, timeoutInfo, _ = _executeWithFakeConfig(\n            test,\n            [\n                \"%{{cxx}} -xc++ {} -Werror -fsyntax-only %{{flags}} %{{compile_flags}} {}\".format(\n                    os.devnull, flag\n                )\n            ],\n        )\n        return exitCode == 0\n\n\n@_memoizeExpensiveOperation(lambda c, s: (c.substitutions, c.environment, s))\ndef runScriptExitCode(config, script):\n    \"\"\"\n    Runs the given script as a Lit test, and returns the exit code of the execution.\n\n    The script must be a list of commands, each of which being something that\n    could appear on the right-hand-side of a `RUN:` keyword.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        _, _, exitCode, _, _ = _executeWithFakeConfig(test, script)\n        return exitCode\n\n\n@_memoizeExpensiveOperation(lambda c, s: (c.substitutions, c.environment, s))\ndef commandOutput(config, command):\n    \"\"\"\n    Runs the given script as a Lit test, and returns the output.\n    If the exit code isn't 0 an exception is raised.\n\n    The script must be a list of commands, each of which being something that\n    could appear on the right-hand-side of a `RUN:` keyword.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        out, err, exitCode, _, cmd = _executeWithFakeConfig(test, command)\n        if exitCode != 0:\n            raise ConfigurationRuntimeError(\n                \"Failed to run command: {}\\nstderr is:\\n{}\".format(cmd, err)\n            )\n        return out\n\n\n@_memoizeExpensiveOperation(lambda c, l: (c.substitutions, c.environment, l))\ndef hasAnyLocale(config, locales):\n    \"\"\"\n    Return whether the runtime execution environment supports a given locale.\n    Different systems may use different names for a locale, so this function checks\n    whether any of the passed locale names is supported by setlocale() and returns\n    true if one of them works.\n\n    This is done by executing a program that tries to set the given locale using\n    %{exec} -- this means that the command may be executed on a remote host\n    depending on the %{exec} substitution.\n    \"\"\"\n    program = \"\"\"\n    #include <stddef.h>\n    #if defined(_LIBCPP_HAS_NO_LOCALIZATION)\n      int main(int, char**) { return 1; }\n    #else\n      #include <locale.h>\n      int main(int argc, char** argv) {\n        for (int i = 1; i < argc; i++) {\n          if (::setlocale(LC_ALL, argv[i]) != NULL) {\n            return 0;\n          }\n        }\n        return 1;\n      }\n    #endif\n  \"\"\"\n    return programSucceeds(config, program, args=[pipes.quote(l) for l in locales])\n\n\n@_memoizeExpensiveOperation(lambda c, flags=\"\": (c.substitutions, c.environment, flags))\ndef compilerMacros(config, flags=\"\"):\n    \"\"\"\n    Return a dictionary of predefined compiler macros.\n\n    The keys are strings representing macros, and the values are strings\n    representing what each macro is defined to.\n\n    If the optional `flags` argument (a string) is provided, these flags will\n    be added to the compiler invocation when generating the macros.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        with open(test.getSourcePath(), \"w\") as sourceFile:\n            sourceFile.write(\n                \"\"\"\n      #if __has_include(<__config_site>)\n      #  include <__config_site>\n      #endif\n      \"\"\"\n            )\n        unparsedOutput, err, exitCode, _, cmd = _executeWithFakeConfig(\n            test, [\"%{{cxx}} %s -dM -E %{{flags}} %{{compile_flags}} {}\".format(flags)]\n        )\n        if exitCode != 0:\n            raise ConfigurationCompilationError(\n                \"Failed to retrieve compiler macros, compiler invocation is:\\n{}\\nstderr is:\\n{}\".format(\n                    cmd, err\n                )\n            )\n        parsedMacros = dict()\n        defines = (\n            l.strip() for l in unparsedOutput.split(\"\\n\") if l.startswith(\"#define \")\n        )\n        for line in defines:\n            line = line[len(\"#define \") :]\n            macro, _, value = line.partition(\" \")\n            parsedMacros[macro] = value\n        return parsedMacros\n\n\ndef featureTestMacros(config, flags=\"\"):\n    \"\"\"\n    Return a dictionary of feature test macros.\n\n    The keys are strings representing feature test macros, and the values are\n    integers representing the value of the macro.\n    \"\"\"\n    allMacros = compilerMacros(config, flags)\n    return {\n        m: int(v.rstrip(\"LlUu\"))\n        for (m, v) in allMacros.items()\n        if m.startswith(\"__cpp_\")\n    }\n\n\ndef _getSubstitution(substitution, config):\n  for (orig, replacement) in config.substitutions:\n    if orig == substitution:\n      return replacement\n  raise ValueError('Substitution {} is not in the config.'.format(substitution))\n\ndef _appendToSubstitution(substitutions, key, value):\n    return [(k, v + \" \" + value) if k == key else (k, v) for (k, v) in substitutions]\n\n\ndef _prependToSubstitution(substitutions, key, value):\n    return [(k, value + \" \" + v) if k == key else (k, v) for (k, v) in substitutions]\n\n\nclass ConfigAction(object):\n    \"\"\"\n    This class represents an action that can be performed on a Lit TestingConfig\n    object.\n\n    Examples of such actions are adding or modifying substitutions, Lit features,\n    etc. This class only provides the interface of such actions, and it is meant\n    to be subclassed appropriately to create new actions.\n    \"\"\"\n\n    def applyTo(self, config):\n        \"\"\"\n        Applies the action to the given configuration.\n\n        This should modify the configuration object in place, and return nothing.\n\n        If applying the action to the configuration would yield an invalid\n        configuration, and it is possible to diagnose it here, this method\n        should produce an error. For example, it should be an error to modify\n        a substitution in a way that we know for sure is invalid (e.g. adding\n        a compiler flag when we know the compiler doesn't support it). Failure\n        to do so early may lead to difficult-to-diagnose issues down the road.\n        \"\"\"\n        pass\n\n    def pretty(self, config, litParams):\n        \"\"\"\n        Returns a short and human-readable string describing what this action does.\n\n        This is used for logging purposes when running the test suite, so it should\n        be kept concise.\n        \"\"\"\n        pass\n\n\nclass AddFeature(ConfigAction):\n    \"\"\"\n    This action defines the given Lit feature when running the test suite.\n\n    The name of the feature can be a string or a callable, in which case it is\n    called with the configuration to produce the feature name (as a string).\n    \"\"\"\n\n    def __init__(self, name):\n        self._name = name\n\n    def _getName(self, config):\n        name = self._name(config) if callable(self._name) else self._name\n        if not isinstance(name, str):\n            raise ValueError(\n                \"Lit feature did not resolve to a string (got {})\".format(name)\n            )\n        return name\n\n    def applyTo(self, config):\n        config.available_features.add(self._getName(config))\n\n    def pretty(self, config, litParams):\n        return \"add Lit feature {}\".format(self._getName(config))\n\n\nclass AddFlag(ConfigAction):\n    \"\"\"\n    This action adds the given flag to the %{flags} substitution.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        assert hasCompileFlag(\n            config, flag\n        ), \"Trying to enable flag {}, which is not supported\".format(flag)\n        config.substitutions = _appendToSubstitution(\n            config.substitutions, \"%{flags}\", flag\n        )\n\n    def pretty(self, config, litParams):\n        return \"add {} to %{{flags}}\".format(self._getFlag(config))\n\nclass AddFlagIfSupported(ConfigAction):\n    \"\"\"\n    This action adds the given flag to the %{flags} substitution, only if\n    the compiler supports the flag.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        if hasCompileFlag(config, flag):\n            config.substitutions = _appendToSubstitution(\n                config.substitutions, \"%{flags}\", flag\n            )\n\n    def pretty(self, config, litParams):\n        return \"add {} to %{{flags}}\".format(self._getFlag(config))\n\n\nclass AddCompileFlag(ConfigAction):\n    \"\"\"\n    This action adds the given flag to the %{compile_flags} substitution.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        assert hasCompileFlag(\n            config, flag\n        ), \"Trying to enable compile flag {}, which is not supported\".format(flag)\n        config.substitutions = _appendToSubstitution(\n            config.substitutions, \"%{compile_flags}\", flag\n        )\n\n    def pretty(self, config, litParams):\n        return \"add {} to %{{compile_flags}}\".format(self._getFlag(config))\n\n\nclass AddLinkFlag(ConfigAction):\n    \"\"\"\n    This action appends the given flag to the %{link_flags} substitution.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        assert hasCompileFlag(\n            config, flag\n        ), \"Trying to enable link flag {}, which is not supported\".format(flag)\n        config.substitutions = _appendToSubstitution(\n            config.substitutions, \"%{link_flags}\", flag\n        )\n\n    def pretty(self, config, litParams):\n        return \"append {} to %{{link_flags}}\".format(self._getFlag(config))\n\n\nclass PrependLinkFlag(ConfigAction):\n    \"\"\"\n    This action prepends the given flag to the %{link_flags} substitution.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        assert hasCompileFlag(\n            config, flag\n        ), \"Trying to enable link flag {}, which is not supported\".format(flag)\n        config.substitutions = _prependToSubstitution(\n            config.substitutions, \"%{link_flags}\", flag\n        )\n\n    def pretty(self, config, litParams):\n        return \"prepend {} to %{{link_flags}}\".format(self._getFlag(config))\n\n\nclass AddOptionalWarningFlag(ConfigAction):\n    \"\"\"\n    This action adds the given warning flag to the %{compile_flags} substitution,\n    if it is supported by the compiler.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        # Use -Werror to make sure we see an error about the flag being unsupported.\n        if hasCompileFlag(config, \"-Werror \" + flag):\n            config.substitutions = _appendToSubstitution(\n                config.substitutions, \"%{compile_flags}\", flag\n            )\n\n    def pretty(self, config, litParams):\n        return \"add {} to %{{compile_flags}}\".format(self._getFlag(config))\n\n\nclass AddSubstitution(ConfigAction):\n    \"\"\"\n    This action adds the given substitution to the Lit configuration.\n\n    The substitution can be a string or a callable, in which case it is called\n    with the configuration to produce the actual substitution (as a string).\n    \"\"\"\n\n    def __init__(self, key, substitution):\n        self._key = key\n        self._getSub = (\n            lambda config: substitution(config)\n            if callable(substitution)\n            else substitution\n        )\n\n    def applyTo(self, config):\n        key = self._key\n        sub = self._getSub(config)\n        config.substitutions.append((key, sub))\n\n    def pretty(self, config, litParams):\n        return \"add substitution {} = {}\".format(self._key, self._getSub(config))\n\n\nclass Feature(object):\n    \"\"\"\n    Represents a Lit available feature that is enabled whenever it is supported.\n\n    A feature like this informs the test suite about a capability of the compiler,\n    platform, etc. Unlike Parameters, it does not make sense to explicitly\n    control whether a Feature is enabled -- it should be enabled whenever it\n    is supported.\n    \"\"\"\n\n    def __init__(self, name, actions=None, when=lambda _: True):\n        \"\"\"\n        Create a Lit feature for consumption by a test suite.\n\n        - name\n            The name of the feature. This is what will end up in Lit's available\n            features if the feature is enabled. This can be either a string or a\n            callable, in which case it is passed the TestingConfig and should\n            generate a string representing the name of the feature.\n\n        - actions\n            An optional list of ConfigActions to apply when the feature is supported.\n            An AddFeature action is always created regardless of any actions supplied\n            here -- these actions are meant to perform more than setting a corresponding\n            Lit feature (e.g. adding compiler flags). If 'actions' is a callable, it\n            is called with the current configuration object to generate the actual\n            list of actions.\n\n        - when\n            A callable that gets passed a TestingConfig and should return a\n            boolean representing whether the feature is supported in that\n            configuration. For example, this can use `hasCompileFlag` to\n            check whether the compiler supports the flag that the feature\n            represents. If omitted, the feature will always be considered\n            supported.\n        \"\"\"\n        self._name = name\n        self._actions = [] if actions is None else actions\n        self._isSupported = when\n\n    def _getName(self, config):\n        name = self._name(config) if callable(self._name) else self._name\n        if not isinstance(name, str):\n            raise ValueError(\n                \"Feature did not resolve to a name that's a string, got {}\".format(name)\n            )\n        return name\n\n    def getActions(self, config):\n        \"\"\"\n        Return the list of actions associated to this feature.\n\n        If the feature is not supported, an empty list is returned.\n        If the feature is supported, an `AddFeature` action is automatically added\n        to the returned list of actions, in addition to any actions provided on\n        construction.\n        \"\"\"\n        if not self._isSupported(config):\n            return []\n        else:\n            actions = (\n                self._actions(config) if callable(self._actions) else self._actions\n            )\n            return [AddFeature(self._getName(config))] + actions\n\n    def pretty(self, config):\n        \"\"\"\n        Returns the Feature's name.\n        \"\"\"\n        return self._getName(config)\n\n\ndef _str_to_bool(s):\n    \"\"\"\n    Convert a string value to a boolean.\n\n    True values are \"y\", \"yes\", \"t\", \"true\", \"on\" and \"1\", regardless of capitalization.\n    False values are \"n\", \"no\", \"f\", \"false\", \"off\" and \"0\", regardless of capitalization.\n    \"\"\"\n    trueVals = [\"y\", \"yes\", \"t\", \"true\", \"on\", \"1\"]\n    falseVals = [\"n\", \"no\", \"f\", \"false\", \"off\", \"0\"]\n    lower = s.lower()\n    if lower in trueVals:\n        return True\n    elif lower in falseVals:\n        return False\n    else:\n        raise ValueError(\"Got string '{}', which isn't a valid boolean\".format(s))\n\n\ndef _parse_parameter(s, type):\n    if type is bool and isinstance(s, str):\n        return _str_to_bool(s)\n    elif type is list and isinstance(s, str):\n        return [x.strip() for x in s.split(\",\") if x.strip()]\n    return type(s)\n\n\nclass Parameter(object):\n    \"\"\"\n    Represents a parameter of a Lit test suite.\n\n    Parameters are used to customize the behavior of test suites in a user\n    controllable way. There are two ways of setting the value of a Parameter.\n    The first one is to pass `--param <KEY>=<VALUE>` when running Lit (or\n    equivalently to set `litConfig.params[KEY] = VALUE` somewhere in the\n    Lit configuration files. This method will set the parameter globally for\n    all test suites being run.\n\n    The second method is to set `config.KEY = VALUE` somewhere in the Lit\n    configuration files, which sets the parameter only for the test suite(s)\n    that use that `config` object.\n\n    Parameters can have multiple possible values, and they can have a default\n    value when left unspecified. They can also have any number of ConfigActions\n    associated to them, in which case the actions will be performed on the\n    TestingConfig if the parameter is enabled. Depending on the actions\n    associated to a Parameter, it may be an error to enable the Parameter\n    if some actions are not supported in the given configuration. For example,\n    trying to set the compilation standard to C++23 when `-std=c++23` is not\n    supported by the compiler would be an error.\n    \"\"\"\n\n    def __init__(self, name, type, help, actions, choices=None, default=None):\n        \"\"\"\n        Create a Lit parameter to customize the behavior of a test suite.\n\n        - name\n            The name of the parameter that can be used to set it on the command-line.\n            On the command-line, the parameter can be set using `--param <name>=<value>`\n            when running Lit. This must be non-empty.\n\n        - choices\n            An optional non-empty set of possible values for this parameter. If provided,\n            this must be anything that can be iterated. It is an error if the parameter\n            is given a value that is not in that set, whether explicitly or through a\n            default value.\n\n        - type\n            A callable that can be used to parse the value of the parameter given\n            on the command-line. As a special case, using the type `bool` also\n            allows parsing strings with boolean-like contents, and the type `list`\n            will parse a string delimited by commas into a list of the substrings.\n\n        - help\n            A string explaining the parameter, for documentation purposes.\n            TODO: We should be able to surface those from the Lit command-line.\n\n        - actions\n            A callable that gets passed the parsed value of the parameter (either\n            the one passed on the command-line or the default one), and that returns\n            a list of ConfigAction to perform given the value of the parameter.\n            All the ConfigAction must be supported in the given configuration.\n\n        - default\n            An optional default value to use for the parameter when no value is\n            provided on the command-line. If the default value is a callable, it\n            is called with the TestingConfig and should return the default value\n            for the parameter. Whether the default value is computed or specified\n            directly, it must be in the 'choices' provided for that Parameter.\n        \"\"\"\n        self._name = name\n        if len(self._name) == 0:\n            raise ValueError(\"Parameter name must not be the empty string\")\n\n        if choices is not None:\n            self._choices = list(choices)  # should be finite\n            if len(self._choices) == 0:\n                raise ValueError(\n                    \"Parameter '{}' must be given at least one possible value\".format(\n                        self._name\n                    )\n                )\n        else:\n            self._choices = None\n\n        self._parse = lambda x: _parse_parameter(x, type)\n        self._help = help\n        self._actions = actions\n        self._default = default\n\n    def _getValue(self, config, litParams):\n        \"\"\"\n        Return the value of the parameter given the configuration objects.\n        \"\"\"\n        param = getattr(config, self.name, None)\n        param = litParams.get(self.name, param)\n        if param is None and self._default is None:\n            raise ValueError(\n                \"Parameter {} doesn't have a default value, but it was not specified in the Lit parameters or in the Lit config\".format(\n                    self.name\n                )\n            )\n        getDefault = (\n            lambda: self._default(config) if callable(self._default) else self._default\n        )\n\n        if param is not None:\n            (pretty, value) = (param, self._parse(param))\n        else:\n            value = getDefault()\n            pretty = \"{} (default)\".format(value)\n\n        if self._choices and value not in self._choices:\n            raise ValueError(\n                \"Got value '{}' for parameter '{}', which is not in the provided set of possible choices: {}\".format(\n                    value, self.name, self._choices\n                )\n            )\n        return (pretty, value)\n\n    @property\n    def name(self):\n        \"\"\"\n        Return the name of the parameter.\n\n        This is the name that can be used to set the parameter on the command-line\n        when running Lit.\n        \"\"\"\n        return self._name\n\n    def getActions(self, config, litParams):\n        \"\"\"\n        Return the list of actions associated to this value of the parameter.\n        \"\"\"\n        (_, parameterValue) = self._getValue(config, litParams)\n        return self._actions(parameterValue)\n\n    def pretty(self, config, litParams):\n        \"\"\"\n        Return a pretty representation of the parameter's name and value.\n        \"\"\"\n        (prettyParameterValue, _) = self._getValue(config, litParams)\n        return \"{}={}\".format(self.name, prettyParameterValue)\n"}, "/libcxx/utils/libcxx/test/format.py": {"changes": [{"diff": "\n     for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n         assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n \n-def _parseLitOutput(fullOutput):\n-    \"\"\"\n-    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n-\n-    This takes output of the form\n-\n-        $ \":\" \"RUN: at line 11\"\n-        $ \"echo\" \"OUTPUT1\"\n-        # command output:\n-        OUTPUT1\n-\n-        $ \":\" \"RUN: at line 12\"\n-        $ \"echo\" \"OUTPUT2\"\n-        # command output:\n-        OUTPUT2\n-\n-    and returns a string containing\n-\n-        OUTPUT1\n-        OUTPUT2\n-\n-    as-if the commands had been run directly. This is a workaround for the fact\n-    that Lit doesn't let us execute ShTest and retrieve the raw output without\n-    injecting additional Lit output around it.\n-    \"\"\"\n-    parsed = ''\n-    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n-        if output: # skip blank lines\n-            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n-            if commandOutput:\n-                parsed += commandOutput.group(1)\n-    return parsed\n-\n def _executeScriptInternal(test, litConfig, commands):\n     \"\"\"\n     Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n", "add": 0, "remove": 33, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["def _parseLitOutput(fullOutput):", "    \"\"\"", "    Parse output of a Lit ShTest to extract the actual output of the contained commands.", "    This takes output of the form", "        $ \":\" \"RUN: at line 11\"", "        $ \"echo\" \"OUTPUT1\"", "        OUTPUT1", "        $ \":\" \"RUN: at line 12\"", "        $ \"echo\" \"OUTPUT2\"", "        OUTPUT2", "    and returns a string containing", "        OUTPUT1", "        OUTPUT2", "    as-if the commands had been run directly. This is a workaround for the fact", "    that Lit doesn't let us execute ShTest and retrieve the raw output without", "    injecting additional Lit output around it.", "    \"\"\"", "    parsed = ''", "    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):", "        if output: # skip blank lines", "            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)", "            if commandOutput:", "                parsed += commandOutput.group(1)", "    return parsed"], "goodparts": []}, {"diff": "\n     _, tmpBase = _getTempPaths(test)\n     execDir = os.path.dirname(test.getExecPath())\n     res = lit.TestRunner.executeScriptInternal(\n-        test, litConfig, tmpBase, parsedCommands, execDir\n+        test, litConfig, tmpBase, parsedCommands, execDir, debug=False\n     )\n     if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n         res = (\"\", res.output, 127, None)\n     (out, err, exitCode, timeoutInfo) = res\n \n-    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n-    #       split any stderr output that is included in stdout. It shouldn't be there, but\n-    #       the Lit internal shell conflates stderr and stdout.\n-    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n-    if conflatedErrorOutput:\n-        conflatedErrorOutput = conflatedErrorOutput.group(0)\n-        out = out[: -len(conflatedErrorOutput)]\n-        err += conflatedErrorOutput\n-\n     return (out, err, exitCode, timeoutInfo, parsedCommands)\n \n \n", "add": 1, "remove": 10, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["        test, litConfig, tmpBase, parsedCommands, execDir", "    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)", "    if conflatedErrorOutput:", "        conflatedErrorOutput = conflatedErrorOutput.group(0)", "        out = out[: -len(conflatedErrorOutput)]", "        err += conflatedErrorOutput"], "goodparts": ["        test, litConfig, tmpBase, parsedCommands, execDir, debug=False"]}, {"diff": "\n             raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n \n         # Split the generated output into multiple files and generate one test for each file\n-        parsed = _parseLitOutput(out)\n-        for (subfile, content) in self._splitFile(parsed):\n+        for (subfile, content) in self._splitFile(out):\n             generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n             os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n             with open(generatedFile, 'w') as f", "add": 1, "remove": 2, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["        parsed = _parseLitOutput(out)", "        for (subfile, content) in self._splitFile(parsed):"], "goodparts": ["        for (subfile, content) in self._splitFile(out):"]}], "source": "\n import contextlib import io import lit import lit.formats import os import pipes import re import shutil def _getTempPaths(test): \"\"\" Return the values to use for the %T and %t substitutions, respectively. The difference between this and Lit's default behavior is that we guarantee that %T is a path unique to the test being run. \"\"\" tmpDir, _=lit.TestRunner.getTempPaths(test) _, testName=os.path.split(test.getExecPath()) tmpDir=os.path.join(tmpDir, testName +\".dir\") tmpBase=os.path.join(tmpDir, \"t\") return tmpDir, tmpBase def _checkBaseSubstitutions(substitutions): substitutions=[s for(s, _) in substitutions] for s in[\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]: assert s in substitutions, \"Required substitution{} was not provided\".format(s) def _parseLitOutput(fullOutput): \"\"\" Parse output of a Lit ShTest to extract the actual output of the contained commands. This takes output of the form $ \":\" \"RUN: at line 11\" $ \"echo\" \"OUTPUT1\" OUTPUT1 $ \":\" \"RUN: at line 12\" $ \"echo\" \"OUTPUT2\" OUTPUT2 and returns a string containing OUTPUT1 OUTPUT2 as-if the commands had been run directly. This is a workaround for the fact that Lit doesn't let us execute ShTest and retrieve the raw output without injecting additional Lit output around it. \"\"\" parsed='' for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput): if output: commandOutput=re.search(\" if commandOutput: parsed +=commandOutput.group(1) return parsed def _executeScriptInternal(test, litConfig, commands): \"\"\" Returns(stdout, stderr, exitCode, timeoutInfo, parsedCommands) TODO: This really should be easier to access from Lit itself \"\"\" parsedCommands=parseScript(test, preamble=commands) _, tmpBase=_getTempPaths(test) execDir=os.path.dirname(test.getExecPath()) res=lit.TestRunner.executeScriptInternal( test, litConfig, tmpBase, parsedCommands, execDir ) if isinstance(res, lit.Test.Result): res=(\"\", res.output, 127, None) (out, err, exitCode, timeoutInfo)=res conflatedErrorOutput=re.search(\"( if conflatedErrorOutput: conflatedErrorOutput=conflatedErrorOutput.group(0) out=out[: -len(conflatedErrorOutput)] err +=conflatedErrorOutput return(out, err, exitCode, timeoutInfo, parsedCommands) def parseScript(test, preamble): \"\"\" Extract the script from a test, with substitutions applied. Returns a list of commands ready to be executed. -test The lit.Test to parse. -preamble A list of commands to perform before any command in the test. These commands can contain unexpanded substitutions, but they must not be of the form 'RUN:' --they must be proper commands once substituted. \"\"\" tmpDir, tmpBase=_getTempPaths(test) substitutions=lit.TestRunner.getDefaultSubstitutions(test, tmpDir, tmpBase) _checkBaseSubstitutions(substitutions) substitutions.append( (\"%{build}\", \"%{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\") ) substitutions.append((\"%{run}\", \"%{exec} %t.exe\")) additionalCompileFlags=[] fileDependencies=[] parsers=[ lit.TestRunner.IntegratedTestKeywordParser( \"FILE_DEPENDENCIES:\", lit.TestRunner.ParserKind.LIST, initial_value=fileDependencies, ), lit.TestRunner.IntegratedTestKeywordParser( \"ADDITIONAL_COMPILE_FLAGS:\", lit.TestRunner.ParserKind.LIST, initial_value=additionalCompileFlags, ), ] for feature in test.config.available_features: parser=lit.TestRunner.IntegratedTestKeywordParser( \"ADDITIONAL_COMPILE_FLAGS({}):\".format(feature), lit.TestRunner.ParserKind.LIST, initial_value=additionalCompileFlags, ) parsers.append(parser) scriptInTest=lit.TestRunner.parseIntegratedTestScript( test, additional_parsers=parsers, require_script=not preamble ) if isinstance(scriptInTest, lit.Test.Result): return scriptInTest script=[] for dep in fileDependencies: script +=[\"%dbg(SETUP) cd %S && cp{} %T\".format(dep)] script +=preamble script +=scriptInTest substitutions=[ (s, x +\" \" +\" \".join(additionalCompileFlags)) if s==\"%{compile_flags}\" else(s, x) for(s, x) in substitutions ] script=lit.TestRunner.applySubstitutions( script, substitutions, recursion_limit=test.config.recursiveExpansionLimit ) return script class CxxStandardLibraryTest(lit.formats.FileBasedTest): \"\"\" Lit test format for the C++Standard Library conformance test suite. This test format is based on top of the ShTest format --it basically creates a shell script performing the right operations(compile/link/run) based on the extension of the test file it encounters. It supports files with the following extensions: FOO.pass.cpp -Compiles, links and runs successfully FOO.pass.mm -Same as.pass.cpp, but for Objective-C++ FOO.compile.pass.cpp -Compiles successfully, link and run not attempted FOO.compile.pass.mm -Same as.compile.pass.cpp, but for Objective-C++ FOO.compile.fail.cpp -Does not compile successfully FOO.link.pass.cpp -Compiles and links successfully, run not attempted FOO.link.pass.mm -Same as.link.pass.cpp, but for Objective-C++ FOO.link.fail.cpp -Compiles successfully, but fails to link FOO.sh.<anything> -A builtin Lit Shell test FOO.gen.<anything> -A.sh test that generates one or more Lit tests on the fly. Executing this test must generate one or more files as expected by LLVM split-file, and each generated file leads to a separate Lit test that runs that file as defined by the test format. This can be used to generate multiple Lit tests from a single source file, which is useful for testing repetitive properties in the library. Be careful not to abuse this since this is not a replacement for usual code reuse techniques. FOO.verify.cpp -Compiles with clang-verify. This type of test is automatically marked as UNSUPPORTED if the compiler does not support Clang-verify. Substitution requirements =============================== The test format operates by assuming that each test's configuration provides the following substitutions, which it will reuse in the shell scripts it constructs: %{cxx} -A command that can be used to invoke the compiler %{compile_flags} -Flags to use when compiling a test case %{link_flags} -Flags to use when linking a test case %{flags} -Flags to use either when compiling or linking a test case %{exec} -A command to prefix the execution of executables Note that when building an executable(as opposed to only compiling a source file), all three of %{flags}, %{compile_flags} and %{link_flags} will be used in the same command line. In other words, the test format doesn't perform separate compilation and linking steps in this case. Additional supported directives =============================== In addition to everything that's supported in Lit ShTests, this test format also understands the following directives inside test files: // FILE_DEPENDENCIES: file, directory, /path/to/file This directive expresses that the test requires the provided files or directories in order to run. An example is a test that requires some test input stored in a data file. When a test file contains such a directive, this test format will collect them and copy them to the directory represented by %T. The intent is that %T contains all the inputs necessary to run the test, such that e.g. execution on a remote host can be done by simply copying %T to the host. // ADDITIONAL_COMPILE_FLAGS: flag1, flag2, flag3 This directive will cause the provided flags to be added to the %{compile_flags} substitution for the test that contains it. This allows adding special compilation flags without having to use a .sh.cpp test, which would be more powerful but perhaps overkill. Additional provided substitutions and features ============================================== The test format will define the following substitutions for use inside tests: %{build} Expands to a command-line that builds the current source file with the %{flags}, %{compile_flags} and %{link_flags} substitutions, and that produces an executable named %t.exe. %{run} Equivalent to `%{exec} %t.exe`. This is intended to be used in conjunction with the %{build} substitution. \"\"\" def getTestsForPath(self, testSuite, pathInSuite, litConfig, localConfig): SUPPORTED_SUFFIXES=[ \"[.]pass[.]cpp$\", \"[.]pass[.]mm$\", \"[.]compile[.]pass[.]cpp$\", \"[.]compile[.]pass[.]mm$\", \"[.]compile[.]fail[.]cpp$\", \"[.]link[.]pass[.]cpp$\", \"[.]link[.]pass[.]mm$\", \"[.]link[.]fail[.]cpp$\", \"[.]sh[.][^.]+$\", \"[.]gen[.][^.]+$\", \"[.]verify[.]cpp$\", \"[.]fail[.]cpp$\", ] sourcePath=testSuite.getSourcePath(pathInSuite) filename=os.path.basename(sourcePath) hasSupportedSuffix=lambda f: any([re.search(ext, f) for ext in SUPPORTED_SUFFIXES]) if filename.startswith(\".\") or filename in localConfig.excludes or not hasSupportedSuffix(filename): return if re.search('[.]gen[.][^.]+$', filename): for test in self._generateGenTest(testSuite, pathInSuite, litConfig, localConfig): yield test else: yield lit.Test.Test(testSuite, pathInSuite, localConfig) def execute(self, test, litConfig): VERIFY_FLAGS=( \"-Xclang -verify -Xclang -verify-ignore-unexpected=note -ferror-limit=0\" ) supportsVerify=\"verify-support\" in test.config.available_features filename=test.path_in_suite[-1] if re.search(\"[.]sh[.][^.]+$\", filename): steps=[] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".compile.pass.cpp\") or filename.endswith( \".compile.pass.mm\" ): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".compile.fail.cpp\"): steps=[ \"%dbg(COMPILED WITH) ! %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".link.pass.cpp\") or filename.endswith(\".link.pass.mm\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".link.fail.cpp\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -c -o %t.o\", \"%dbg(LINKED WITH) ! %{cxx} %t.o %{flags} %{link_flags} -o %t.exe\", ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".verify.cpp\"): if not supportsVerify: return lit.Test.Result( lit.Test.UNSUPPORTED, \"Test{} requires support for Clang-verify, which isn't supported by the compiler\".format( test.getFullName() ), ) steps=[ \"%dbg(COMPILED WITH) %{{cxx}} %s %{{flags}} %{{compile_flags}} -fsyntax-only -Wno-error{}\".format( VERIFY_FLAGS ) ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".pass.cpp\") or filename.endswith(\".pass.mm\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\", \"%dbg(EXECUTED AS) %{exec} %t.exe\", ] return self._executeShTest(test, litConfig, steps) else: return lit.Test.Result( lit.Test.UNRESOLVED, \"Unknown test suffix for '{}'\".format(filename) ) def _executeShTest(self, test, litConfig, steps): if test.config.unsupported: return lit.Test.Result(lit.Test.UNSUPPORTED, \"Test is unsupported\") script=parseScript(test, steps) if isinstance(script, lit.Test.Result): return script if litConfig.noExecute: return lit.Test.Result( lit.Test.XFAIL if test.isExpectedToFail() else lit.Test.PASS ) else: _, tmpBase=_getTempPaths(test) useExternalSh=False return lit.TestRunner._runShTest( test, litConfig, useExternalSh, script, tmpBase ) def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig): generator=lit.Test.Test(testSuite, pathInSuite, localConfig) generatorExecDir=os.path.dirname(testSuite.getExecPath(pathInSuite)) os.makedirs(generatorExecDir, exist_ok=True) steps=[] (out, err, exitCode, _, _)=_executeScriptInternal(generator, litConfig, steps) if exitCode !=0: raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\") parsed=_parseLitOutput(out) for(subfile, content) in self._splitFile(parsed): generatedFile=testSuite.getExecPath(pathInSuite +(subfile,)) os.makedirs(os.path.dirname(generatedFile), exist_ok=True) with open(generatedFile, 'w') as f: f.write(content) yield lit.Test.Test(testSuite,(generatedFile,), localConfig) def _splitFile(self, input): DELIM=r'^(//| lines=input.splitlines() currentFile=None thisFileContent=[] for line in lines: match=re.match(DELIM, line) if match: if currentFile is not None: yield(currentFile, '\\n'.join(thisFileContent)) currentFile=match.group(2).strip() thisFileContent=[] assert currentFile is not None, f\"Some input to split-file doesn't belong to any file, input was:\\n{input}\" thisFileContent.append(line) if currentFile is not None: yield(currentFile, '\\n'.join(thisFileContent)) ", "sourceWithComments": "# ===----------------------------------------------------------------------===##\n#\n# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n# See https://llvm.org/LICENSE.txt for license information.\n# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n#\n# ===----------------------------------------------------------------------===##\n\nimport contextlib\nimport io\nimport lit\nimport lit.formats\nimport os\nimport pipes\nimport re\nimport shutil\n\n\ndef _getTempPaths(test):\n    \"\"\"\n    Return the values to use for the %T and %t substitutions, respectively.\n\n    The difference between this and Lit's default behavior is that we guarantee\n    that %T is a path unique to the test being run.\n    \"\"\"\n    tmpDir, _ = lit.TestRunner.getTempPaths(test)\n    _, testName = os.path.split(test.getExecPath())\n    tmpDir = os.path.join(tmpDir, testName + \".dir\")\n    tmpBase = os.path.join(tmpDir, \"t\")\n    return tmpDir, tmpBase\n\n\ndef _checkBaseSubstitutions(substitutions):\n    substitutions = [s for (s, _) in substitutions]\n    for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n        assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n\ndef _parseLitOutput(fullOutput):\n    \"\"\"\n    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n\n    This takes output of the form\n\n        $ \":\" \"RUN: at line 11\"\n        $ \"echo\" \"OUTPUT1\"\n        # command output:\n        OUTPUT1\n\n        $ \":\" \"RUN: at line 12\"\n        $ \"echo\" \"OUTPUT2\"\n        # command output:\n        OUTPUT2\n\n    and returns a string containing\n\n        OUTPUT1\n        OUTPUT2\n\n    as-if the commands had been run directly. This is a workaround for the fact\n    that Lit doesn't let us execute ShTest and retrieve the raw output without\n    injecting additional Lit output around it.\n    \"\"\"\n    parsed = ''\n    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n        if output: # skip blank lines\n            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n            if commandOutput:\n                parsed += commandOutput.group(1)\n    return parsed\n\ndef _executeScriptInternal(test, litConfig, commands):\n    \"\"\"\n    Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n\n    TODO: This really should be easier to access from Lit itself\n    \"\"\"\n    parsedCommands = parseScript(test, preamble=commands)\n\n    _, tmpBase = _getTempPaths(test)\n    execDir = os.path.dirname(test.getExecPath())\n    res = lit.TestRunner.executeScriptInternal(\n        test, litConfig, tmpBase, parsedCommands, execDir\n    )\n    if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n        res = (\"\", res.output, 127, None)\n    (out, err, exitCode, timeoutInfo) = res\n\n    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n    #       split any stderr output that is included in stdout. It shouldn't be there, but\n    #       the Lit internal shell conflates stderr and stdout.\n    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n    if conflatedErrorOutput:\n        conflatedErrorOutput = conflatedErrorOutput.group(0)\n        out = out[: -len(conflatedErrorOutput)]\n        err += conflatedErrorOutput\n\n    return (out, err, exitCode, timeoutInfo, parsedCommands)\n\n\ndef parseScript(test, preamble):\n    \"\"\"\n    Extract the script from a test, with substitutions applied.\n\n    Returns a list of commands ready to be executed.\n\n    - test\n        The lit.Test to parse.\n\n    - preamble\n        A list of commands to perform before any command in the test.\n        These commands can contain unexpanded substitutions, but they\n        must not be of the form 'RUN:' -- they must be proper commands\n        once substituted.\n    \"\"\"\n    # Get the default substitutions\n    tmpDir, tmpBase = _getTempPaths(test)\n    substitutions = lit.TestRunner.getDefaultSubstitutions(test, tmpDir, tmpBase)\n\n    # Check base substitutions and add the %{build} and %{run} convenience substitutions\n    _checkBaseSubstitutions(substitutions)\n    substitutions.append(\n        (\"%{build}\", \"%{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\")\n    )\n    substitutions.append((\"%{run}\", \"%{exec} %t.exe\"))\n\n    # Parse the test file, including custom directives\n    additionalCompileFlags = []\n    fileDependencies = []\n    parsers = [\n        lit.TestRunner.IntegratedTestKeywordParser(\n            \"FILE_DEPENDENCIES:\",\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=fileDependencies,\n        ),\n        lit.TestRunner.IntegratedTestKeywordParser(\n            \"ADDITIONAL_COMPILE_FLAGS:\",\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=additionalCompileFlags,\n        ),\n    ]\n\n    # Add conditional parsers for ADDITIONAL_COMPILE_FLAGS. This should be replaced by first\n    # class support for conditional keywords in Lit, which would allow evaluating arbitrary\n    # Lit boolean expressions instead.\n    for feature in test.config.available_features:\n        parser = lit.TestRunner.IntegratedTestKeywordParser(\n            \"ADDITIONAL_COMPILE_FLAGS({}):\".format(feature),\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=additionalCompileFlags,\n        )\n        parsers.append(parser)\n\n    scriptInTest = lit.TestRunner.parseIntegratedTestScript(\n        test, additional_parsers=parsers, require_script=not preamble\n    )\n    if isinstance(scriptInTest, lit.Test.Result):\n        return scriptInTest\n\n    script = []\n\n    # For each file dependency in FILE_DEPENDENCIES, inject a command to copy\n    # that file to the execution directory. Execute the copy from %S to allow\n    # relative paths from the test directory.\n    for dep in fileDependencies:\n        script += [\"%dbg(SETUP) cd %S && cp {} %T\".format(dep)]\n    script += preamble\n    script += scriptInTest\n\n    # Add compile flags specified with ADDITIONAL_COMPILE_FLAGS.\n    substitutions = [\n        (s, x + \" \" + \" \".join(additionalCompileFlags))\n        if s == \"%{compile_flags}\"\n        else (s, x)\n        for (s, x) in substitutions\n    ]\n\n    # Perform substitutions in the script itself.\n    script = lit.TestRunner.applySubstitutions(\n        script, substitutions, recursion_limit=test.config.recursiveExpansionLimit\n    )\n\n    return script\n\n\nclass CxxStandardLibraryTest(lit.formats.FileBasedTest):\n    \"\"\"\n    Lit test format for the C++ Standard Library conformance test suite.\n\n    This test format is based on top of the ShTest format -- it basically\n    creates a shell script performing the right operations (compile/link/run)\n    based on the extension of the test file it encounters. It supports files\n    with the following extensions:\n\n    FOO.pass.cpp            - Compiles, links and runs successfully\n    FOO.pass.mm             - Same as .pass.cpp, but for Objective-C++\n\n    FOO.compile.pass.cpp    - Compiles successfully, link and run not attempted\n    FOO.compile.pass.mm     - Same as .compile.pass.cpp, but for Objective-C++\n    FOO.compile.fail.cpp    - Does not compile successfully\n\n    FOO.link.pass.cpp       - Compiles and links successfully, run not attempted\n    FOO.link.pass.mm        - Same as .link.pass.cpp, but for Objective-C++\n    FOO.link.fail.cpp       - Compiles successfully, but fails to link\n\n    FOO.sh.<anything>       - A builtin Lit Shell test\n\n    FOO.gen.<anything>      - A .sh test that generates one or more Lit tests on the\n                              fly. Executing this test must generate one or more files\n                              as expected by LLVM split-file, and each generated file\n                              leads to a separate Lit test that runs that file as\n                              defined by the test format. This can be used to generate\n                              multiple Lit tests from a single source file, which is\n                              useful for testing repetitive properties in the library.\n                              Be careful not to abuse this since this is not a replacement\n                              for usual code reuse techniques.\n\n    FOO.verify.cpp          - Compiles with clang-verify. This type of test is\n                              automatically marked as UNSUPPORTED if the compiler\n                              does not support Clang-verify.\n\n\n    Substitution requirements\n    ===============================\n    The test format operates by assuming that each test's configuration provides\n    the following substitutions, which it will reuse in the shell scripts it\n    constructs:\n        %{cxx}           - A command that can be used to invoke the compiler\n        %{compile_flags} - Flags to use when compiling a test case\n        %{link_flags}    - Flags to use when linking a test case\n        %{flags}         - Flags to use either when compiling or linking a test case\n        %{exec}          - A command to prefix the execution of executables\n\n    Note that when building an executable (as opposed to only compiling a source\n    file), all three of %{flags}, %{compile_flags} and %{link_flags} will be used\n    in the same command line. In other words, the test format doesn't perform\n    separate compilation and linking steps in this case.\n\n\n    Additional supported directives\n    ===============================\n    In addition to everything that's supported in Lit ShTests, this test format\n    also understands the following directives inside test files:\n\n        // FILE_DEPENDENCIES: file, directory, /path/to/file\n\n            This directive expresses that the test requires the provided files\n            or directories in order to run. An example is a test that requires\n            some test input stored in a data file. When a test file contains\n            such a directive, this test format will collect them and copy them\n            to the directory represented by %T. The intent is that %T contains\n            all the inputs necessary to run the test, such that e.g. execution\n            on a remote host can be done by simply copying %T to the host.\n\n        // ADDITIONAL_COMPILE_FLAGS: flag1, flag2, flag3\n\n            This directive will cause the provided flags to be added to the\n            %{compile_flags} substitution for the test that contains it. This\n            allows adding special compilation flags without having to use a\n            .sh.cpp test, which would be more powerful but perhaps overkill.\n\n\n    Additional provided substitutions and features\n    ==============================================\n    The test format will define the following substitutions for use inside tests:\n\n        %{build}\n            Expands to a command-line that builds the current source\n            file with the %{flags}, %{compile_flags} and %{link_flags}\n            substitutions, and that produces an executable named %t.exe.\n\n        %{run}\n            Equivalent to `%{exec} %t.exe`. This is intended to be used\n            in conjunction with the %{build} substitution.\n    \"\"\"\n\n    def getTestsForPath(self, testSuite, pathInSuite, litConfig, localConfig):\n        SUPPORTED_SUFFIXES = [\n            \"[.]pass[.]cpp$\",\n            \"[.]pass[.]mm$\",\n            \"[.]compile[.]pass[.]cpp$\",\n            \"[.]compile[.]pass[.]mm$\",\n            \"[.]compile[.]fail[.]cpp$\",\n            \"[.]link[.]pass[.]cpp$\",\n            \"[.]link[.]pass[.]mm$\",\n            \"[.]link[.]fail[.]cpp$\",\n            \"[.]sh[.][^.]+$\",\n            \"[.]gen[.][^.]+$\",\n            \"[.]verify[.]cpp$\",\n            \"[.]fail[.]cpp$\",\n        ]\n\n        sourcePath = testSuite.getSourcePath(pathInSuite)\n        filename = os.path.basename(sourcePath)\n\n        # Ignore dot files, excluded tests and tests with an unsupported suffix\n        hasSupportedSuffix = lambda f: any([re.search(ext, f) for ext in SUPPORTED_SUFFIXES])\n        if filename.startswith(\".\") or filename in localConfig.excludes or not hasSupportedSuffix(filename):\n            return\n\n        # If this is a generated test, run the generation step and add\n        # as many Lit tests as necessary.\n        if re.search('[.]gen[.][^.]+$', filename):\n            for test in self._generateGenTest(testSuite, pathInSuite, litConfig, localConfig):\n                yield test\n        else:\n            yield lit.Test.Test(testSuite, pathInSuite, localConfig)\n\n    def execute(self, test, litConfig):\n        VERIFY_FLAGS = (\n            \"-Xclang -verify -Xclang -verify-ignore-unexpected=note -ferror-limit=0\"\n        )\n        supportsVerify = \"verify-support\" in test.config.available_features\n        filename = test.path_in_suite[-1]\n\n        if re.search(\"[.]sh[.][^.]+$\", filename):\n            steps = []  # The steps are already in the script\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".compile.pass.cpp\") or filename.endswith(\n            \".compile.pass.mm\"\n        ):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".compile.fail.cpp\"):\n            steps = [\n                \"%dbg(COMPILED WITH) ! %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".link.pass.cpp\") or filename.endswith(\".link.pass.mm\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".link.fail.cpp\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -c -o %t.o\",\n                \"%dbg(LINKED WITH) ! %{cxx} %t.o %{flags} %{link_flags} -o %t.exe\",\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".verify.cpp\"):\n            if not supportsVerify:\n                return lit.Test.Result(\n                    lit.Test.UNSUPPORTED,\n                    \"Test {} requires support for Clang-verify, which isn't supported by the compiler\".format(\n                        test.getFullName()\n                    ),\n                )\n            steps = [\n                # Note: Use -Wno-error to make sure all diagnostics are not treated as errors,\n                #       which doesn't make sense for clang-verify tests.\n                \"%dbg(COMPILED WITH) %{{cxx}} %s %{{flags}} %{{compile_flags}} -fsyntax-only -Wno-error {}\".format(\n                    VERIFY_FLAGS\n                )\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        # Make sure to check these ones last, since they will match other\n        # suffixes above too.\n        elif filename.endswith(\".pass.cpp\") or filename.endswith(\".pass.mm\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\",\n                \"%dbg(EXECUTED AS) %{exec} %t.exe\",\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        else:\n            return lit.Test.Result(\n                lit.Test.UNRESOLVED, \"Unknown test suffix for '{}'\".format(filename)\n            )\n\n    def _executeShTest(self, test, litConfig, steps):\n        if test.config.unsupported:\n            return lit.Test.Result(lit.Test.UNSUPPORTED, \"Test is unsupported\")\n\n        script = parseScript(test, steps)\n        if isinstance(script, lit.Test.Result):\n            return script\n\n        if litConfig.noExecute:\n            return lit.Test.Result(\n                lit.Test.XFAIL if test.isExpectedToFail() else lit.Test.PASS\n            )\n        else:\n            _, tmpBase = _getTempPaths(test)\n            useExternalSh = False\n            return lit.TestRunner._runShTest(\n                test, litConfig, useExternalSh, script, tmpBase\n            )\n\n    def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig):\n        generator = lit.Test.Test(testSuite, pathInSuite, localConfig)\n\n        # Make sure we have a directory to execute the generator test in\n        generatorExecDir = os.path.dirname(testSuite.getExecPath(pathInSuite))\n        os.makedirs(generatorExecDir, exist_ok=True)\n\n        # Run the generator test\n        steps = [] # Steps must already be in the script\n        (out, err, exitCode, _, _) = _executeScriptInternal(generator, litConfig, steps)\n        if exitCode != 0:\n            raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n\n        # Split the generated output into multiple files and generate one test for each file\n        parsed = _parseLitOutput(out)\n        for (subfile, content) in self._splitFile(parsed):\n            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n            os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n            with open(generatedFile, 'w') as f:\n                f.write(content)\n            yield lit.Test.Test(testSuite, (generatedFile,), localConfig)\n\n    def _splitFile(self, input):\n        DELIM = r'^(//|#)---(.+)'\n        lines = input.splitlines()\n        currentFile = None\n        thisFileContent = []\n        for line in lines:\n            match = re.match(DELIM, line)\n            if match:\n                if currentFile is not None:\n                    yield (currentFile, '\\n'.join(thisFileContent))\n                currentFile = match.group(2).strip()\n                thisFileContent = []\n            assert currentFile is not None, f\"Some input to split-file doesn't belong to any file, input was:\\n{input}\"\n            thisFileContent.append(line)\n        if currentFile is not None:\n            yield (currentFile, '\\n'.join(thisFileContent))\n"}, "/llvm/utils/lit/lit/TestRunner.py": {"changes": [{"diff": "\n \n \n def executeBuiltinEcho(cmd, shenv):\n-    \"\"\"Interpret a redirected echo command\"\"\"\n+    \"\"\"Interpret a redirected echo or @echo command\"\"\"\n     opened_files = []\n     stdin, stdout, stderr = processRedirects(cmd, subprocess.PIPE, shenv, opened_files)\n     if stdin != subprocess.PIPE or stderr != subprocess.PIPE:\n         raise InternalShellError(\n-            cmd, \"stdin and stderr redirects not supported for echo\"\n+            cmd, f\"stdin and stderr redirects not supported for {cmd.args[0]}\"\n         )\n \n     # Some tests have un-redirected echo commands to help debug test failures.\n", "add": 2, "remove": 2, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["    \"\"\"Interpret a redirected echo command\"\"\"", "            cmd, \"stdin and stderr redirects not supported for echo\""], "goodparts": ["    \"\"\"Interpret a redirected echo or @echo command\"\"\"", "            cmd, f\"stdin and stderr redirects not supported for {cmd.args[0]}\""]}, {"diff": "\n         if res == -signal.SIGINT:\n             raise KeyboardInterrupt\n         if proc_not_counts[i] % 2:\n-            res = not res\n+            res = 1 if res == 0 else 0\n         elif proc_not_counts[i] > 1:\n             res = 1 if res != 0 else 0\n \n", "add": 1, "remove": 1, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["            res = not res"], "goodparts": ["            res = 1 if res == 0 else 0"]}, {"diff": "\n     return exitCode\n \n \n-def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n+def formatOutput(title, data, limit=None):\n+    if not data.strip():\n+        return \"\"\n+    if not limit is None and len(data) > limit:\n+        data = data[:limit] + \"\\n...\\n\"\n+        msg = \"data was truncated\"\n+    else:\n+        msg = \"\"\n+    ndashes = 30\n+    out =  f\"# .---{title}{'-' * (ndashes - 4 - len(title))}\\n\"\n+    out += f\"# | \" + \"\\n# | \".join(data.splitlines()) + \"\\n\"\n+    out += f\"# `---{msg}{'-' * (ndashes - 4 - len(msg))}\\n\"\n+    return out\n+\n+# Normally returns out, err, exitCode, timeoutInfo.\n+#\n+# If debug is True (the normal lit behavior), err is empty, and out contains an\n+# execution trace, including stdout and stderr shown per command executed.\n+#\n+# If debug is False (set by some custom lit test formats that call this\n+# function), out contains only stdout from the script, err contains only stderr\n+# from the script, and there is no execution trace.\n+def executeScriptInternal(test, litConfig, tmpBase, commands, cwd,\n+                          debug=True):\n     cmds = []\n     for i, ln in enumerate(commands):\n+        # Within lit, we try to always add '%dbg(...)' to command lines in order\n+        # to maximize debuggability.  However, custom lit test formats might not\n+        # always add it, so add a generic debug message in that case.\n         match = re.match(kPdbgRegex, ln)\n         if match:\n+            dbg = match.group(1)\n             command = match.group(2)\n-            ln = commands[i] = match.expand(\": '\\\\1'; \\\\2\" if command else \": '\\\\1'\")\n+        else:\n+            dbg = \"command line\"\n+            command = ln\n+        if debug:\n+            ln = f\"@echo '# {dbg}' \"\n+            if command:\n+                ln += f\"&& @echo {shlex.quote(command.lstrip())} && {command}\"\n+            else:\n+                ln += \"has no command after substitutions\"\n+        else:\n+            ln = command\n         try:\n             cmds.append(\n                 ShUtil.ShParser(ln, litConfig.isWindows, test.config.pipefail).parse()\n             )\n         except:\n-            return lit.Test.Result(Test.FAIL, \"shell parser error on: %r\" % ln)\n+            return lit.Test.Result(\n+                Test.FAIL, f\"shell parser error on {dbg}: {command.lstrip()}\\n\"\n+            )\n \n     cmd = cmds[0]\n     for c in cmds[1:]:\n", "add": 42, "remove": 3, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):", "            ln = commands[i] = match.expand(\": '\\\\1'; \\\\2\" if command else \": '\\\\1'\")", "            return lit.Test.Result(Test.FAIL, \"shell parser error on: %r\" % ln)"], "goodparts": ["def formatOutput(title, data, limit=None):", "    if not data.strip():", "        return \"\"", "    if not limit is None and len(data) > limit:", "        data = data[:limit] + \"\\n...\\n\"", "        msg = \"data was truncated\"", "    else:", "        msg = \"\"", "    ndashes = 30", "    out =  f\"# .---{title}{'-' * (ndashes - 4 - len(title))}\\n\"", "    out += f\"# | \" + \"\\n# | \".join(data.splitlines()) + \"\\n\"", "    out += f\"# `---{msg}{'-' * (ndashes - 4 - len(msg))}\\n\"", "    return out", "def executeScriptInternal(test, litConfig, tmpBase, commands, cwd,", "                          debug=True):", "            dbg = match.group(1)", "        else:", "            dbg = \"command line\"", "            command = ln", "        if debug:", "            ln = f\"@echo '# {dbg}' \"", "            if command:", "                ln += f\"&& @echo {shlex.quote(command.lstrip())} && {command}\"", "            else:", "                ln += \"has no command after substitutions\"", "        else:", "            ln = command", "            return lit.Test.Result(", "                Test.FAIL, f\"shell parser error on {dbg}: {command.lstrip()}\\n\"", "            )"]}, {"diff": "\n \n     out = err = \"\"\n     for i, result in enumerate(results):\n-        # Write the command line run.\n-        out += \"$ %s\\n\" % (\" \".join('\"%s\"' % s for s in result.command.args),)\n+        if not debug:\n+            out += result.stdout\n+            err += result.stderr\n+            continue\n+\n+        # The purpose of an \"@echo\" command is merely to add a debugging message\n+        # directly to lit's output.  It is used internally by lit's internal\n+        # shell and is not currently documented for use in lit tests.  However,\n+        # if someone misuses it (e.g., both \"echo\" and \"@echo\" complain about\n+        # stdin redirection), produce the normal execution trace to facilitate\n+        # debugging.\n+        if (\n+            result.command.args[0] == \"@echo\"\n+            and result.exitCode == 0\n+            and not result.stderr\n+            and not result.outputFiles\n+            and not result.timeoutReached\n+        ):\n+            out += result.stdout\n+            continue\n+\n+        # Write the command line that was run.  Properly quote it.  Leading\n+        # \"!\" commands should not be quoted as that would indicate they are not\n+        # the builtins.\n+        out += \"# executed command: \"\n+        nLeadingBangs = next(\n+            (i for i, cmd in enumerate(result.command.args) if cmd != \"!\"),\n+            len(result.command.args),\n+        )\n+        out += \"! \" * nLeadingBangs\n+        out += \" \".join(\n+            shlex.quote(str(s))\n+            for i, s in enumerate(result.command.args)\n+            if i >= nLeadingBangs\n+        )\n+        out += \"\\n\"\n \n         # If nothing interesting happened, move on.\n         if (\n", "add": 36, "remove": 2, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["        out += \"$ %s\\n\" % (\" \".join('\"%s\"' % s for s in result.command.args),)"], "goodparts": ["        if not debug:", "            out += result.stdout", "            err += result.stderr", "            continue", "        if (", "            result.command.args[0] == \"@echo\"", "            and result.exitCode == 0", "            and not result.stderr", "            and not result.outputFiles", "            and not result.timeoutReached", "        ):", "            out += result.stdout", "            continue", "        out += \"# executed command: \"", "        nLeadingBangs = next(", "            (i for i, cmd in enumerate(result.command.args) if cmd != \"!\"),", "            len(result.command.args),", "        )", "        out += \"! \" * nLeadingBangs", "        out += \" \".join(", "            shlex.quote(str(s))", "            for i, s in enumerate(result.command.args)", "            if i >= nLeadingBangs", "        )", "        out += \"\\n\""]}, {"diff": "\n \n         # Add the command output, if redirected.\n         for (name, path, data) in result.outputFiles:\n-            if data.strip():\n-                out += \"# redirected output from %r:\\n\" % (name,)\n-                data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n-                if len(data) > 1024:\n-                    out += data[:1024] + \"\\n...\\n\"\n-                    out += \"note: data was truncated\\n\"\n-                else:\n-                    out += data\n-                out += \"\\n\"\n-\n+            data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n+            out += formatOutput(\n+                f\"redirected output from '{name}'\", data, limit=1024\n+            )\n         if result.stdout.strip():\n-            out += \"# command output:\\n%s\\n\" % (result.stdout,)\n+            out += formatOutput(\"command stdout\", result.stdout)\n         if result.stderr.strip():\n-            out += \"# command stderr:\\n%s\\n\" % (result.stderr,)\n+            out += formatOutput(\"command stderr\", result.stderr)\n         if not result.stdout.strip() and not result.stderr.strip():\n-            out += \"note: command had no output on stdout or stderr\\n\"\n+            out += \"# note: command had no output on stdout or stderr\\n\"\n \n         # Show the error conditions:\n         if result.exitCode != 0:\n", "add": 7, "remove": 13, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["            if data.strip():", "                out += \"# redirected output from %r:\\n\" % (name,)", "                data = to_string(data.decode(\"utf-8\", errors=\"replace\"))", "                if len(data) > 1024:", "                    out += data[:1024] + \"\\n...\\n\"", "                    out += \"note: data was truncated\\n\"", "                else:", "                    out += data", "                out += \"\\n\"", "            out += \"# command output:\\n%s\\n\" % (result.stdout,)", "            out += \"# command stderr:\\n%s\\n\" % (result.stderr,)", "            out += \"note: command had no output on stdout or stderr\\n\""], "goodparts": ["            data = to_string(data.decode(\"utf-8\", errors=\"replace\"))", "            out += formatOutput(", "                f\"redirected output from '{name}'\", data, limit=1024", "            )", "            out += formatOutput(\"command stdout\", result.stdout)", "            out += formatOutput(\"command stderr\", result.stderr)", "            out += \"# note: command had no output on stdout or stderr\\n\""]}, {"diff": "\n                 codeStr = hex(int(result.exitCode & 0xFFFFFFFF)).rstrip(\"L\")\n             else:\n                 codeStr = str(result.exitCode)\n-            out += \"error: command failed with exit status: %s\\n\" % (codeStr,)\n+            out += \"# error: command failed with exit status: %s\\n\" % (codeStr,)\n         if litConfig.maxIndividualTestTime > 0 and result.timeoutReached:\n-            out += \"error: command reached timeout: %s\\n\" % (\n+            out += \"# error: command reached timeout: %s\\n\" % (\n                 str(result.timeoutReached),\n             )\n \n", "add": 2, "remove": 2, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["            out += \"error: command failed with exit status: %s\\n\" % (codeStr,)", "            out += \"error: command reached timeout: %s\\n\" % ("], "goodparts": ["            out += \"# error: command failed with exit status: %s\\n\" % (codeStr,)", "            out += \"# error: command reached timeout: %s\\n\" % ("]}, {"diff": "\n         if not output or not output[-1].add_continuation(line_number, keyword, line):\n             if output is None:\n                 output = []\n-            pdbg = \"%dbg({keyword} at line {line_number})\".format(\n-                keyword=keyword, line_number=line_number\n-            )\n-            assert re.match(\n-                kPdbgRegex + \"$\", pdbg\n-            ), \"kPdbgRegex expected to match actual %dbg usage\"\n-            line = \"{pdbg} {real_command}\".format(pdbg=pdbg, real_command=line)\n+            line = buildPdbgCommand(f\"{keyword} at line {line_number}\", line)\n             output.append(CommandDirective(line_number, line_number, keyword, line))\n         return output\n \n", "add": 1, "remove": 7, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["            pdbg = \"%dbg({keyword} at line {line_number})\".format(", "                keyword=keyword, line_number=line_number", "            )", "            assert re.match(", "                kPdbgRegex + \"$\", pdbg", "            ), \"kPdbgRegex expected to match actual %dbg usage\"", "            line = \"{pdbg} {real_command}\".format(pdbg=pdbg, real_command=line)"], "goodparts": ["            line = buildPdbgCommand(f\"{keyword} at line {line_number}\", line)"]}]}}, "msg": "[lit] Improve test output from lit's internal shell\n\nThis patch and D154984 were discussed in\n<https://discourse.llvm.org/t/rfc-improving-lits-debug-output/72839>.\n\nMotivation\n----------\n\nD154984 removes the \"Script:\" section that lit prints along with a\ntest's output, and it makes -v and -a imply -vv.  For example, after\nD154984, the \"Script:\" section below is never shown, but -v is enough\nto produce the execution trace following it:\n\n```\n Script:\n --\n : 'RUN: at line 1'; echo hello | FileCheck bogus.txt && echo success\n --\n Exit Code: 2\n\n Command Output (stdout):\n --\n $ \":\" \"RUN: at line 1\"\n $ \"echo\" \"hello\"\n # command output:\n hello\n\n $ \"FileCheck\" \"bogus.txt\"\n # command stderr:\n Could not open check file 'bogus.txt': No such file or directory\n\n error: command failed with exit status: 2\n\n --\n```\n\nIn the D154984 review, some reviewers point out that they have been\nusing the \"Script:\" section for copying and pasting a test's shell\ncommands to a terminal window.  The shell commands as printed in the\nexecution trace can be harder to copy and paste for the following\nreasons:\n\n- They drop redirections and break apart RUN lines at `&&`, `|`, etc.\n- They add `$` at the start of every command, which makes it hard to\n  copy and paste multiple commands in bulk.\n- Command stdout, stderr, etc. are interleaved with the commands and\n  are not clearly delineated.\n- They don't always use proper shell quoting.  Instead, they blindly\n  enclose all command-line arguments in double quotes.\n\nChanges\n-------\n\nD154984 plus this patch converts the above example into:\n\n```\n Exit Code: 2\n\n Command Output (stdout):\n --\n # RUN: at line 1\n echo hello | FileCheck bogus-file.txt && echo success\n # executed command: echo hello\n # .---command stdout------------\n # | hello\n # `-----------------------------\n # executed command: FileCheck bogus-file.txt\n # .---command stderr------------\n # | Could not open check file 'bogus-file.txt': No such file or directory\n # `-----------------------------\n # error: command failed with exit status: 2\n\n --\n```\n\nThus, this patch addresses the above issues as follows:\n\n- The entire execution trace can be copied and pasted in bulk to a\n  terminal for correct execution of the RUN lines, which are printed\n  intact as they appeared in the original RUN lines except lit\n  substitutions are expanded.  Everything else in the execution trace\n  appears in shell comments so it has no effect in a terminal.\n- Each of the RUN line's commands is repeated (in shell comments) as\n  it executes to show (1) that the command actually executed (e.g.,\n  `echo success` above didn't) and (2) what stdout, stderr, non-zero\n  exit status, and output files are associated with the command, if\n  any.  Shell quoting in the command is now correct and minimal but is\n  not necessarily the original shell quoting from the RUN line.\n- The start and end of the contents of stdout, stderr, or an output\n  file is now delineated clearly in the trace.\n\nTo help produce some of the above output, this patch extends lit's\ninternal shell with a built-in `@echo` command.  It's like `echo`\nexcept lit suppresses the normal execution trace for `@echo` and just\nprints its stdout directly.  For now, `@echo` isn't documented for use\nin lit tests.\n\nWithout this patch, libcxx's custom lit test format tries to parse the\nstdout from `lit.TestRunner.executeScriptInternal` (which runs lit's\ninternal shell) to extract the stdout and stderr produced by shell\ncommands, and that parse no longer works after the above changes.\nThis patch makes a small adjustment to\n`lit.TestRunner.executeScriptInternal` so libcxx can just request\nstdout and stderr without an execution trace.\n\n(As a minor drive-by fix that came up in testing: lit's internal `not`\ncommand now always produces a numeric exit status and never `True`.)\n\nCaveat\n------\n\nThis patch only makes the above changes for lit's internal shell.  In\nmost cases, we do not know how to force external shells (e.g., bash,\nsh, window's `cmd`) to produce execution traces in the manner we want.\n\nTo configure a test suite to use lit's internal shell (which is\nusually better for test portability than external shells anyway), add\nthis to the test suite's `lit.cfg` or other configuration file:\n\n```\nconfig.test_format = lit.formats.ShTest(execute_external=False)\n```\n\nReviewed By: MaskRay, awarzynski\n\nDifferential Revision: https://reviews.llvm.org/D156954"}, "f223022a4c521296a6d058862d66443ab9e355bf": {"url": "https://api.github.com/repos/linux4life798/llvm-project-ci-test/commits/f223022a4c521296a6d058862d66443ab9e355bf", "html_url": "https://github.com/linux4life798/llvm-project-ci-test/commit/f223022a4c521296a6d058862d66443ab9e355bf", "sha": "f223022a4c521296a6d058862d66443ab9e355bf", "keyword": "execution after redirect correct", "diff": "diff --git a/libcxx/utils/libcxx/test/dsl.py b/libcxx/utils/libcxx/test/dsl.py\nindex d2e0c6036dd3..5d4ca83be130 100644\n--- a/libcxx/utils/libcxx/test/dsl.py\n+++ b/libcxx/utils/libcxx/test/dsl.py\n@@ -186,7 +186,7 @@ def programOutput(config, program, args=None):\n                 \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n             )\n \n-        return libcxx.test.format._parseLitOutput(out)\n+        return out\n \n \n @_memoizeExpensiveOperation(\ndiff --git a/libcxx/utils/libcxx/test/format.py b/libcxx/utils/libcxx/test/format.py\nindex ddd88f25646e..c7c0bad681dd 100644\n--- a/libcxx/utils/libcxx/test/format.py\n+++ b/libcxx/utils/libcxx/test/format.py\n@@ -35,39 +35,6 @@ def _checkBaseSubstitutions(substitutions):\n     for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n         assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n \n-def _parseLitOutput(fullOutput):\n-    \"\"\"\n-    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n-\n-    This takes output of the form\n-\n-        $ \":\" \"RUN: at line 11\"\n-        $ \"echo\" \"OUTPUT1\"\n-        # command output:\n-        OUTPUT1\n-\n-        $ \":\" \"RUN: at line 12\"\n-        $ \"echo\" \"OUTPUT2\"\n-        # command output:\n-        OUTPUT2\n-\n-    and returns a string containing\n-\n-        OUTPUT1\n-        OUTPUT2\n-\n-    as-if the commands had been run directly. This is a workaround for the fact\n-    that Lit doesn't let us execute ShTest and retrieve the raw output without\n-    injecting additional Lit output around it.\n-    \"\"\"\n-    parsed = ''\n-    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n-        if output: # skip blank lines\n-            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n-            if commandOutput:\n-                parsed += commandOutput.group(1)\n-    return parsed\n-\n def _executeScriptInternal(test, litConfig, commands):\n     \"\"\"\n     Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n@@ -79,21 +46,12 @@ def _executeScriptInternal(test, litConfig, commands):\n     _, tmpBase = _getTempPaths(test)\n     execDir = os.path.dirname(test.getExecPath())\n     res = lit.TestRunner.executeScriptInternal(\n-        test, litConfig, tmpBase, parsedCommands, execDir\n+        test, litConfig, tmpBase, parsedCommands, execDir, debug=False\n     )\n     if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n         res = (\"\", res.output, 127, None)\n     (out, err, exitCode, timeoutInfo) = res\n \n-    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n-    #       split any stderr output that is included in stdout. It shouldn't be there, but\n-    #       the Lit internal shell conflates stderr and stdout.\n-    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n-    if conflatedErrorOutput:\n-        conflatedErrorOutput = conflatedErrorOutput.group(0)\n-        out = out[: -len(conflatedErrorOutput)]\n-        err += conflatedErrorOutput\n-\n     return (out, err, exitCode, timeoutInfo, parsedCommands)\n \n \n@@ -400,9 +358,8 @@ def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig):\n             raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n \n         # Split the generated output into multiple files and generate one test for each file\n-        parsed = _parseLitOutput(out)\n-        for (subfile, content) in self._splitFile(parsed):\n-            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n+        for subfile, content in self._splitFile(out):\n+            generatedFile = testSuite.getExecPath(pathInSuite + (subfile,))\n             os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n             with open(generatedFile, 'w') as f:\n                 f.write(content)\ndiff --git a/llvm/docs/CommandGuide/lit.rst b/llvm/docs/CommandGuide/lit.rst\nindex b494c74889aa..5e2443cb612a 100644\n--- a/llvm/docs/CommandGuide/lit.rst\n+++ b/llvm/docs/CommandGuide/lit.rst\n@@ -96,10 +96,9 @@ OUTPUT OPTIONS\n \n  Each command is printed before it is executed. This can be valuable for\n  debugging test failures, as the last printed command is the one that failed.\n- Moreover, :program:`lit` inserts a no-op command (``:`` in the case of bash)\n- with argument ``'RUN: at line N'`` before each command pipeline, and those\n- no-op commands are also printed to help you locate the source line of the\n- failed command.\n+ Moreover, :program:`lit` inserts ``'RUN: at line N'`` before each\n+ command pipeline in the output to help you locate the source line of\n+ the failed command.\n \n .. option:: -vv, --echo-all-commands\n \ndiff --git a/llvm/utils/lit/lit/TestRunner.py b/llvm/utils/lit/lit/TestRunner.py\nindex 0539b280a176..f85627eaf3de 100644\n--- a/llvm/utils/lit/lit/TestRunner.py\n+++ b/llvm/utils/lit/lit/TestRunner.py\n@@ -8,6 +8,7 @@\n import stat\n import pathlib\n import platform\n+import shlex\n import shutil\n import tempfile\n import threading\n@@ -348,12 +349,12 @@ def executeBuiltinExport(cmd, shenv):\n \n \n def executeBuiltinEcho(cmd, shenv):\n-    \"\"\"Interpret a redirected echo command\"\"\"\n+    \"\"\"Interpret a redirected echo or @echo command\"\"\"\n     opened_files = []\n     stdin, stdout, stderr = processRedirects(cmd, subprocess.PIPE, shenv, opened_files)\n     if stdin != subprocess.PIPE or stderr != subprocess.PIPE:\n         raise InternalShellError(\n-            cmd, \"stdin and stderr redirects not supported for echo\"\n+            cmd, f\"stdin and stderr redirects not supported for {cmd.args[0]}\"\n         )\n \n     # Some tests have un-redirected echo commands to help debug test failures.\n@@ -700,6 +701,7 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n         \"cd\": executeBuiltinCd,\n         \"export\": executeBuiltinExport,\n         \"echo\": executeBuiltinEcho,\n+        \"@echo\": executeBuiltinEcho,\n         \"mkdir\": executeBuiltinMkdir,\n         \"popd\": executeBuiltinPopd,\n         \"pushd\": executeBuiltinPushd,\n@@ -927,7 +929,7 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n         if res == -signal.SIGINT:\n             raise KeyboardInterrupt\n         if proc_not_counts[i] % 2:\n-            res = not res\n+            res = 1 if res == 0 else 0\n         elif proc_not_counts[i] > 1:\n             res = 1 if res != 0 else 0\n \n@@ -990,19 +992,60 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n     return exitCode\n \n \n-def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n+def formatOutput(title, data, limit=None):\n+    if not data.strip():\n+        return \"\"\n+    if not limit is None and len(data) > limit:\n+        data = data[:limit] + \"\\n...\\n\"\n+        msg = \"data was truncated\"\n+    else:\n+        msg = \"\"\n+    ndashes = 30\n+    # fmt: off\n+    out =  f\"# .---{title}{'-' * (ndashes - 4 - len(title))}\\n\"\n+    out += f\"# | \" + \"\\n# | \".join(data.splitlines()) + \"\\n\"\n+    out += f\"# `---{msg}{'-' * (ndashes - 4 - len(msg))}\\n\"\n+    # fmt: on\n+    return out\n+\n+\n+# Normally returns out, err, exitCode, timeoutInfo.\n+#\n+# If debug is True (the normal lit behavior), err is empty, and out contains an\n+# execution trace, including stdout and stderr shown per command executed.\n+#\n+# If debug is False (set by some custom lit test formats that call this\n+# function), out contains only stdout from the script, err contains only stderr\n+# from the script, and there is no execution trace.\n+def executeScriptInternal(test, litConfig, tmpBase, commands, cwd, debug=True):\n     cmds = []\n     for i, ln in enumerate(commands):\n+        # Within lit, we try to always add '%dbg(...)' to command lines in order\n+        # to maximize debuggability.  However, custom lit test formats might not\n+        # always add it, so add a generic debug message in that case.\n         match = re.fullmatch(kPdbgRegex, ln)\n         if match:\n+            dbg = match.group(1)\n             command = match.group(2)\n-            ln = commands[i] = match.expand(\": '\\\\1'; \\\\2\" if command else \": '\\\\1'\")\n+        else:\n+            dbg = \"command line\"\n+            command = ln\n+        if debug:\n+            ln = f\"@echo '# {dbg}' \"\n+            if command:\n+                ln += f\"&& @echo {shlex.quote(command.lstrip())} && {command}\"\n+            else:\n+                ln += \"has no command after substitutions\"\n+        else:\n+            ln = command\n         try:\n             cmds.append(\n                 ShUtil.ShParser(ln, litConfig.isWindows, test.config.pipefail).parse()\n             )\n         except:\n-            return lit.Test.Result(Test.FAIL, \"shell parser error on: %r\" % ln)\n+            return lit.Test.Result(\n+                Test.FAIL, f\"shell parser error on {dbg}: {command.lstrip()}\\n\"\n+            )\n \n     cmd = cmds[0]\n     for c in cmds[1:]:\n@@ -1022,8 +1065,42 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n \n     out = err = \"\"\n     for i, result in enumerate(results):\n-        # Write the command line run.\n-        out += \"$ %s\\n\" % (\" \".join('\"%s\"' % s for s in result.command.args),)\n+        if not debug:\n+            out += result.stdout\n+            err += result.stderr\n+            continue\n+\n+        # The purpose of an \"@echo\" command is merely to add a debugging message\n+        # directly to lit's output.  It is used internally by lit's internal\n+        # shell and is not currently documented for use in lit tests.  However,\n+        # if someone misuses it (e.g., both \"echo\" and \"@echo\" complain about\n+        # stdin redirection), produce the normal execution trace to facilitate\n+        # debugging.\n+        if (\n+            result.command.args[0] == \"@echo\"\n+            and result.exitCode == 0\n+            and not result.stderr\n+            and not result.outputFiles\n+            and not result.timeoutReached\n+        ):\n+            out += result.stdout\n+            continue\n+\n+        # Write the command line that was run.  Properly quote it.  Leading\n+        # \"!\" commands should not be quoted as that would indicate they are not\n+        # the builtins.\n+        out += \"# executed command: \"\n+        nLeadingBangs = next(\n+            (i for i, cmd in enumerate(result.command.args) if cmd != \"!\"),\n+            len(result.command.args),\n+        )\n+        out += \"! \" * nLeadingBangs\n+        out += \" \".join(\n+            shlex.quote(str(s))\n+            for i, s in enumerate(result.command.args)\n+            if i >= nLeadingBangs\n+        )\n+        out += \"\\n\"\n \n         # If nothing interesting happened, move on.\n         if (\n@@ -1038,22 +1115,14 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n \n         # Add the command output, if redirected.\n         for (name, path, data) in result.outputFiles:\n-            if data.strip():\n-                out += \"# redirected output from %r:\\n\" % (name,)\n-                data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n-                if len(data) > 1024:\n-                    out += data[:1024] + \"\\n...\\n\"\n-                    out += \"note: data was truncated\\n\"\n-                else:\n-                    out += data\n-                out += \"\\n\"\n-\n+            data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n+            out += formatOutput(f\"redirected output from '{name}'\", data, limit=1024)\n         if result.stdout.strip():\n-            out += \"# command output:\\n%s\\n\" % (result.stdout,)\n+            out += formatOutput(\"command stdout\", result.stdout)\n         if result.stderr.strip():\n-            out += \"# command stderr:\\n%s\\n\" % (result.stderr,)\n+            out += formatOutput(\"command stderr\", result.stderr)\n         if not result.stdout.strip() and not result.stderr.strip():\n-            out += \"note: command had no output on stdout or stderr\\n\"\n+            out += \"# note: command had no output on stdout or stderr\\n\"\n \n         # Show the error conditions:\n         if result.exitCode != 0:\n@@ -1063,9 +1132,9 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n                 codeStr = hex(int(result.exitCode & 0xFFFFFFFF)).rstrip(\"L\")\n             else:\n                 codeStr = str(result.exitCode)\n-            out += \"error: command failed with exit status: %s\\n\" % (codeStr,)\n+            out += \"# error: command failed with exit status: %s\\n\" % (codeStr,)\n         if litConfig.maxIndividualTestTime > 0 and result.timeoutReached:\n-            out += \"error: command reached timeout: %s\\n\" % (\n+            out += \"# error: command reached timeout: %s\\n\" % (\n                 str(result.timeoutReached),\n             )\n \n@@ -2117,6 +2186,8 @@ def executeShTest(\n         return lit.Test.Result(Test.UNSUPPORTED, \"Test is unsupported\")\n \n     script = list(preamble_commands)\n+    script = [buildPdbgCommand(f\"preamble command line\", ln) for ln in script]\n+\n     parsed = parseIntegratedTestScript(test, require_script=not script)\n     if isinstance(parsed, lit.Test.Result):\n         return parsed\ndiff --git a/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg b/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\nindex cf1a4f1ba1ec..301208c25bdc 100644\n--- a/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\n+++ b/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\n@@ -5,4 +5,4 @@ config.suffixes = [\".txt\"]\n config.test_format = lit.formats.ShTest()\n config.test_source_root = None\n config.test_exec_root = None\n-config.substitutions.append((\"%var\", lit_config.params.get(\"var\", \"\")))\n+config.substitutions.append((\"%var\", lit_config.params.get(\"var\", \"default\")))\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt b/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\nindex 6dd9b16304e0..1d94c1213723 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\n@@ -14,21 +14,21 @@\n ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0 -fopenmp-simd\n ; REDEFINE: %{fcflags} = -check-prefix=SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu -fopenmp-simd\n ; REDEFINE: %{fcflags} = -check-prefix=SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0\n ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu\n ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n \n ; CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt b/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\nindex 3bf057151afb..23c0a6d50753 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\n@@ -7,7 +7,7 @@\n #\n # REDEFINE: %{global:greeting}=Hello\n # RUN: %{global:echo}\n-# CHECK: GLOBAL: Hello World\n+# CHECK:# | GLOBAL: Hello World\n \n # We can redefine the test suite config's substitutions multiple times.  Again,\n # the expansion order remains the same (%{global:echo} before %{global:greeting}\n@@ -17,7 +17,7 @@\n # REDEFINE: %{global:greeting}=Goodbye %{global:what}\n # REDEFINE: %{global:what}=Sleep\n # RUN: %{global:echo}\n-# CHECK: GLOBAL: Goodbye Sleep Sleep\n+# CHECK:# | GLOBAL: Goodbye Sleep Sleep\n \n # A new local substitution is prepended to the substitution list so that it can\n # depend on all substitutions that were defined previously, including those from\n@@ -26,7 +26,7 @@\n # DEFINE: %{local:greeting}=Hey %{global:what}\n # DEFINE: %{local:echo}=echo \"LOCAL: %{local:greeting} %{global:what}\"\n # RUN: %{local:echo}\n-# CHECK: LOCAL: Hey Sleep Sleep\n+# CHECK:# | LOCAL: Hey Sleep Sleep\n \n # As for substitutions from the test suite config, redefining local\n # substitutions should not change the expansion order.  Again, the expansion\n@@ -36,6 +36,6 @@\n # REDEFINE: %{local:greeting}=So Long %{global:what}\n # REDEFINE: %{global:what}=World\n # RUN: %{local:echo}\n-# CHECK: LOCAL: So Long World World\n+# CHECK:# | LOCAL: So Long World World\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt b/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\nindex 65f90792ff7b..5a1d7f2e1987 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\n@@ -1,19 +1,19 @@\n # Does it work as expected directly in RUN lines?\n # RUN: echo %(line), %(line-1), %(line+2)\n-# CHECK: [[#@LINE-1]], [[#@LINE-2]], [[#@LINE+1]]\n+# CHECK:# | [[#@LINE-1]], [[#@LINE-2]], [[#@LINE+1]]\n \n # %(line) substitutions refer to the original DEFINE/REDEFINE line not the RUN\n # line they eventually appear within.\n #\n # DEFINE: %{lines} = %(line)\n # RUN: echo '%{lines}'\n-# CHECK: [[#@LINE-2]]\n+# CHECK:# | [[#@LINE-2]]\n #\n # REDEFINE: %{lines} = %(line),                                                \\\n # REDEFINE:            %(line),                                                \\\n # REDEFINE:            %(line)\n # RUN: echo '%{lines}'\n-# CHECK: [[#@LINE-4]], [[#@LINE-3]], [[#@LINE-2]]\n+# CHECK:# | [[#@LINE-4]], [[#@LINE-3]], [[#@LINE-2]]\n \n # %(line+N) and %{line-N) should work too.\n #\n@@ -21,12 +21,12 @@\n # DEFINE:                %(line),                                              \\\n # DEFINE:                %(line-1)\n # RUN: echo '%{lines-rel}'\n-# CHECK: [[#@LINE-3]], [[#@LINE-3]], [[#@LINE-3]]\n+# CHECK:# | [[#@LINE-3]], [[#@LINE-3]], [[#@LINE-3]]\n #\n # REDEFINE: %{lines-rel} = %(line+5),                                          \\\n # REDEFINE:                %(line+0),                                          \\\n # REDEFINE:                %(line-10)\n # RUN: echo '%{lines-rel}'\n-# CHECK: [[#@LINE+1]], [[#@LINE-3]], [[#@LINE-12]]\n+# CHECK:# | [[#@LINE+1]], [[#@LINE-3]], [[#@LINE-12]]\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt b/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\nindex 18a27cdd72fa..d27fda2e2fe6 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\n@@ -1,25 +1,25 @@\n # DEFINE: %{abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789} = ok\n # RUN: echo '%{abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789}'\n-# CHECK: ok\n+# CHECK:# | ok\n \n # DEFINE: %{FooBar} = ok at %(line)\n # RUN: echo '%{FooBar}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{fooBar} = ok at %(line)\n # RUN: echo '%{fooBar}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{foo-bar-} = ok at %(line)\n # RUN: echo '%{foo-bar-}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{foo:bar:} = ok at %(line)\n # RUN: echo '%{foo:bar:}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{_foo_bar_} = ok at %(line)\n # RUN: echo '%{_foo_bar_}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt b/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\nindex eb5f0b918fd1..e504b822ace8 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\n@@ -6,7 +6,7 @@\n \n # RUN: echo '%{outer}'\n \n-# CHECK-NON-RECUR:%{inner}\n-# CHECK-RECUR:expanded\n+# CHECK-NON-RECUR:# | %{inner}\n+# CHECK-RECUR:# | expanded\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt b/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\nindex 9d2e7197fb3a..c1bdfef30b1a 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\n@@ -2,21 +2,21 @@\n \n # DEFINE: %{equals} = FileCheck -check-prefixes=FOO,BAR\n # RUN: echo '%{equals}'\n-# CHECK: FileCheck -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -check-prefixes=FOO,BAR\n #\n # REDEFINE: %{equals} == == =\n # RUN: echo '%{equals}'\n-# CHECK: = == =\n+# CHECK:# | = == =\n \n # DEFINE: %{continue-equals} = FileCheck -strict-whitespace -match-full-lines \\\n # DEFINE:                      -check-prefixes=FOO,BAR\n # RUN: echo '%{continue-equals}'\n-# CHECK: FileCheck -strict-whitespace -match-full-lines -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -strict-whitespace -match-full-lines -check-prefixes=FOO,BAR\n #\n # REDEFINE: %{continue-equals} = FileCheck -input-file=test.txt                \\\n # REDEFINE:                      -implicit-check-not=foobar                    \\\n # REDEFINE:                      -check-prefixes=FOO,BAR\n # RUN: echo '%{continue-equals}'\n-# CHECK: FileCheck -input-file=test.txt -implicit-check-not=foobar -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -input-file=test.txt -implicit-check-not=foobar -check-prefixes=FOO,BAR\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt b/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\nindex 58d5c1a34ce8..9143796edd32 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\n@@ -6,11 +6,11 @@\n \n # DEFINE: %{escape} = \\g<0>\\n\n # RUN: echo '%{escape}'\n-# CHECK: {{\\\\?}}\\g<0>{{\\\\?}}\\n\n+# CHECK:# | {{\\\\?}}\\g<0>{{\\\\?}}\\n\n \n # REDEFINE: %{escape} = \\n                                                     \\\n # REDEFINE:             \\g<param>\n # RUN: echo '%{escape}'\n-# CHECK: {{\\\\?}}\\n {{\\\\?}}\\g<param>\n+# CHECK:# | {{\\\\?}}\\n {{\\\\?}}\\g<param>\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt b/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\nindex 1259e511ba70..3e4db1b15d92 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\n@@ -3,33 +3,33 @@\n #\n # DEFINE: %{empty}=\n # RUN: echo \"'%{empty}'\"\n-# CHECK:''\n+# CHECK:# | ''\n #\n # REDEFINE: %{empty}=\n # RUN: echo \"'%{empty}'\"\n-# CHECK:''\n+# CHECK:# | ''\n \n # A value consisting only of whitespace is trimmed to the empty string.\n #\n #               v~~ intentional whitespace\n # DEFINE: %{ws}=   \n # RUN: echo \"'%{ws}'\"\n-# CHECK:''\n+# CHECK:# | ''\n #\n #                 v intentional whitespace\n # REDEFINE: %{ws}= \n # RUN: echo \"'%{ws}'\"\n-# CHECK:''\n+# CHECK:# | ''\n \n # Whitespace is not required around the name or value.\n #\n # DEFINE:%{no-whitespace}=abc\n # RUN: echo \"'%{no-whitespace}'\"\n-# CHECK:'abc'\n+# CHECK:# | 'abc'\n #\n # REDEFINE:%{no-whitespace}=HelloWorld\n # RUN: echo \"'%{no-whitespace}'\"\n-# CHECK:'HelloWorld'\n+# CHECK:# | 'HelloWorld'\n \n # Whitespace is not required between substitutions in a value.\n #\n@@ -37,11 +37,11 @@\n # DEFINE: %{adjacent1} = bar\n # DEFINE: %{has-adjacent-substs} = %{adjacent0}%{adjacent1}\n # RUN: echo \"'%{has-adjacent-substs}'\"\n-# CHECK:'foobar'\n+# CHECK:# | 'foobar'\n #\n # REDEFINE: %{has-adjacent-substs} = %{adjacent0}%{adjacent1}%{adjacent0}\n # RUN: echo \"'%{has-adjacent-substs}'\"\n-# CHECK:'foobarfoo'\n+# CHECK:# | 'foobarfoo'\n \n # Exact whitespace is preserved within the value, but whitespace enclosing the\n # name or value is discarded.  ('%{' and '}' are part of the name, and\n@@ -50,11 +50,11 @@\n #                                       v~~ intentional whitespace\n # DEFINE:   %{whitespace}  =  abc    def   \n # RUN: echo \"'%{whitespace}'\"\n-# CHECK:'abc    def'\n+# CHECK:# | 'abc    def'\n #                                      v intentional whitespace\n # REDEFINE: %{whitespace} = Hello World \n # RUN: echo \"'%{whitespace}'\"\n-# CHECK:'Hello World'\n+# CHECK:# | 'Hello World'\n \n # Line continuations in the value are permitted and collapse whitespace.\n #\n@@ -66,12 +66,12 @@\n # DEFINE:  pqr \n #             ^ intentional whitespace\n # RUN: echo \"'%{continue}'\"\n-# CHECK:'abc def ghi jkl mno pqr'\n+# CHECK:# | 'abc def ghi jkl mno pqr'\n #\n # REDEFINE: %{continue} =  abc  \\\n # REDEFINE: def\n # RUN: echo \"'%{continue}'\"\n-# CHECK:'abc def'\n+# CHECK:# | 'abc def'\n \n # Whitespace at the end of the line after a '\\' is ignored, and it's treated as\n # a line continuation.  Otherwise, the behavior would be hard to understand\n@@ -83,7 +83,7 @@\n #                                   ^ intentional whitespace\n # DEFINE: baz\n # RUN: echo \"'%{ws-after-continue}'\"\n-# CHECK:'foo bar baz'\n+# CHECK:# | 'foo bar baz'\n #\n #                                     v intentional whitespace\n # REDEFINE: %{ws-after-continue}=foo \\ \n@@ -91,7 +91,7 @@\n #                                     ^~~~~~~~~~~~ intentional whitespace\n # REDEFINE: baz\n # RUN: echo \"'%{ws-after-continue}'\"\n-# CHECK:'foo bar baz'\n+# CHECK:# | 'foo bar baz'\n \n # A line continuation is recognized anywhere.  It should be used only where\n # whitespace is permitted because it reduces to a single space.\n@@ -107,7 +107,7 @@\n # DEFINE:\\\n # DEFINE:a\n # RUN: echo \"'%{blank-lines}'\"\n-# CHECK:'a'\n+# CHECK:# | 'a'\n #\n # REDEFINE:                  \\\n # REDEFINE: %{blank-lines}   \\\n@@ -120,7 +120,7 @@\n # REDEFINE:                  \\\n # REDEFINE:      c\n # RUN: echo \"'%{blank-lines}'\"\n-# CHECK:'a b c'\n+# CHECK:# | 'a b c'\n \n # The fourth DEFINE line is deceptive because it looks like a new substitution,\n # but it's actually a continuation of the previous value.\n@@ -130,6 +130,6 @@\n # DEFINE: %{deceptive-continue}=echo \\\n # DEFINE: %{name}=%{value}\n # RUN: %{deceptive-continue}\n-# CHECK:x=3\n+# CHECK:# | x=3\n \n # CHECK:{{ *}}Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt b/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\nindex b0a7cfd97941..b5fc1b49fcc5 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\n@@ -1,46 +1,34 @@\n-#       CHECK: -- Testing:{{.*}}\n-#  CHECK-NEXT: PASS: shtest-if-else :: test.txt (1 of 1)\n-#  CHECK-NEXT: Exit Code: 0\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: Command Output (stdout):\n-#  CHECK-NEXT: --\n+# CHECK: -- Testing:{{.*}}\n+# CHECK-NEXT: PASS: shtest-if-else :: test.txt (1 of 1)\n+#      CHECK: Command Output (stdout):\n+# CHECK-NEXT: --\n \n # RUN: %if feature %{ echo \"test-1\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-1\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-1\"\n \n # If %else is not present it is treated like %else %{%}. Empty commands\n # are ignored.\n #\n # RUN: %if nofeature %{ echo \"fail\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#   CHECK-NOT: fail\n+#     CHECK: # {{RUN}}: at line [[#@LINE-1]] has no command after substitutions\n+# CHECK-NOT: fail\n \n # RUN: %if nofeature %{ echo \"fail\" %} %else %{ echo \"test-2\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-2\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-2\"\n \n # Spaces inside curly braces are not ignored\n #\n # RUN: echo test-%if feature %{ 3 %} %else %{ fail %}-test\n # RUN: echo test-%if feature %{ 4 4 %} %else %{ fail %}-test\n # RUN: echo test-%if nofeature %{ fail %} %else %{ 5 5 %}-test\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 3 -test\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 4 4 -test\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 5 5 -test\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo test- 3 -test\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo test- 4 4 -test\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo test- 5 5 -test\n \n # Escape line breaks for multi-line expressions\n #\n@@ -48,42 +36,32 @@\n # RUN:   %{ echo     \\\n # RUN:     \"test-5\" \\\n # RUN:   %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-4]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-5\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-5\"\n \n # RUN: %if nofeature       \\\n # RUN:   %{ echo \"fail\" %}   \\\n # RUN: %else               \\\n # RUN:   %{ echo \"test-6\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-4]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-6\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-6\"\n \n # RUN: echo \"test%if feature %{%} %else %{%}-7\"\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-7\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-7\"\n \n # Escape %if. Without %if..%else context '%{' and '%}' are treated\n # literally.\n #\n # RUN: echo %%if feature %{ echo \"test-8\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: %if feature %{ echo test-8 %}\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo %if feature %{ echo \"test-8\" %}\n \n # Nested expressions are supported:\n #\n # RUN: echo %if feature %{ %if feature %{ %if nofeature %{\"fail\"%} %else %{\"test-9\"%} %} %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-9\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-9\"\n \n # Binary expression evaluation and regex match can be used as\n # conditions.\n@@ -91,18 +69,12 @@\n # RUN: echo %if feature && !nofeature %{ \"test-10\" %}\n # RUN: echo %if feature && nofeature %{ \"fail\" %} %else %{ \"test-11\" %}\n # RUN: echo %if {{fea.+}} %{ \"test-12\" %} %else %{ \"fail\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-10\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-11\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-12\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo \"test-10\"\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-11\"\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo \"test-12\"\n \n # Spaces between %if and %else are ignored. If there is no %else -\n # space after %if %{...%} is not ignored.\n@@ -110,39 +82,27 @@\n # RUN: echo XX %if feature %{YY%} ZZ\n # RUN: echo AA %if feature %{BB%} %else %{CC%} DD\n # RUN: echo AA %if nofeature %{BB%} %else %{CC%} DD\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: XX YY ZZ\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: AA BB DD\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: AA CC DD\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo XX YY ZZ\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo AA BB DD\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo AA CC DD\n \n # '{' and '}' can be used without escaping\n #\n # RUN: %if feature %{echo {}%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: {}\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo {}\n \n # Spaces are not required\n #\n # RUN: echo %if feature%{\"ok\"%}%else%{\"fail\"%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: ok\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"ok\"\n \n # Substitutions with braces are handled correctly\n #\n # RUN: echo %{sub} %if feature%{test-%{sub}%}%else%{\"fail\"%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: ok test-ok\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo ok test-ok\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt b/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\nindex fb3a3e000789..5ff0c891450b 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\n@@ -1,3 +1,4 @@\n # RUN: true\n # RUN: echo hi\n-# RUN: not not wc missing-file &> %t.out\n+# RUN: not not wc missing-file &> %t.out || true\n+# RUN: not %{python} %S/write-a-lot.py &> %t.out\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg b/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\nindex b872854d21e6..141fc3a596e7 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\n@@ -2,4 +2,5 @@ import lit.formats\n \n config.name = \"shtest-output-printing\"\n config.suffixes = [\".txt\"]\n+config.substitutions.append((\"%{python}\", f'\"{sys.executable}\"'))\n config.test_format = lit.formats.ShTest(execute_external=False)\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py b/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py\nnew file mode 100644\nindex 000000000000..5dbb94a41cbf\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py\n@@ -0,0 +1,6 @@\n+#!/usr/bin/env python\n+\n+import sys\n+\n+sys.stdout.write(\"All work and no play makes Jack a dull boy.\\n\" * 1000)\n+sys.stdout.flush()\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt\nnew file mode 100644\nindex 000000000000..15a87aee46a3\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt\n@@ -0,0 +1 @@\n+RUN: @echo 2> %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt\nnew file mode 100644\nindex 000000000000..27fd0c4209fd\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt\n@@ -0,0 +1,2 @@\n+RUN: touch %t\n+RUN: @echo < %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt\nnew file mode 100644\nindex 000000000000..9611918f7e12\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt\n@@ -0,0 +1 @@\n+RUN: echo 2> %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt\nnew file mode 100644\nindex 000000000000..bc771be6b22a\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt\n@@ -0,0 +1,2 @@\n+RUN: touch %t\n+RUN: echo < %t\ndiff --git a/llvm/utils/lit/tests/allow-retries.py b/llvm/utils/lit/tests/allow-retries.py\nindex bf6c04193388..45610fb70d34 100644\n--- a/llvm/utils/lit/tests/allow-retries.py\n+++ b/llvm/utils/lit/tests/allow-retries.py\n@@ -15,9 +15,28 @@\n \n # This test does not succeed within the allowed retry limit\n #\n-# RUN: not %{lit} %{inputs}/allow-retries/does-not-succeed-within-limit.py | FileCheck --check-prefix=CHECK-TEST3 %s\n-# CHECK-TEST3: Failed Tests (1):\n-# CHECK-TEST3: allow-retries :: does-not-succeed-within-limit.py\n+# Check that the execution trace isn't corrupt due to reprocessing the script\n+# multiple times (e.g., '%dbg(...)' processing used to accumulate across\n+# retries).\n+#\n+# RUN: not %{lit} %{inputs}/allow-retries/does-not-succeed-within-limit.py -v |\\\n+# RUN:   FileCheck --check-prefix=CHECK-TEST3 -match-full-lines %s\n+#\n+#       CHECK-TEST3: FAIL: allow-retries :: does-not-succeed-within-limit.py (1 of 1)\n+#  CHECK-TEST3-NEXT: {{\\**}} TEST 'allow-retries :: does-not-succeed-within-limit.py' FAILED {{\\**}}\n+#  CHECK-TEST3-NEXT: Exit Code: 1\n+# CHECK-TEST3-EMPTY:\n+#  CHECK-TEST3-NEXT: Command Output (stdout):\n+#  CHECK-TEST3-NEXT: --\n+#  CHECK-TEST3-NEXT: # {{RUN}}: at line 3\n+#  CHECK-TEST3-NEXT: false\n+#  CHECK-TEST3-NEXT: # executed command: false\n+#  CHECK-TEST3-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-TEST3-NEXT: # error: command failed with exit status: 1\n+# CHECK-TEST3-EMPTY:\n+#  CHECK-TEST3-NEXT: --\n+#       CHECK-TEST3: Failed Tests (1):\n+#       CHECK-TEST3: allow-retries :: does-not-succeed-within-limit.py\n \n # This test should be UNRESOLVED since it has more than one ALLOW_RETRIES\n # lines, and that is not allowed.\n@@ -48,6 +67,6 @@\n # RUN:     -Dcounter=%t.counter -Dpython=%{python} | \\\n # RUN:   FileCheck --check-prefix=CHECK-TEST7 %s\n #     CHECK-TEST7: Command Output (stdout):\n-#     CHECK-TEST7: LLVM_PROFILE_FILE=\n-# CHECK-TEST7-NOT: LLVM_PROFILE_FILE=\n+#     CHECK-TEST7: # executed command: export LLVM_PROFILE_FILE=\n+# CHECK-TEST7-NOT: # executed command: export LLVM_PROFILE_FILE=\n #     CHECK-TEST7: Passed With Retry: 1\ndiff --git a/llvm/utils/lit/tests/lit-opts.py b/llvm/utils/lit/tests/lit-opts.py\nindex d292ca74f3b9..a533a59d9d12 100644\n--- a/llvm/utils/lit/tests/lit-opts.py\n+++ b/llvm/utils/lit/tests/lit-opts.py\n@@ -8,7 +8,7 @@\n #\n # RUN: env LIT_OPTS=-a \\\n # RUN: %{lit} -s %{inputs}/lit-opts \\\n-# RUN: | FileCheck -check-prefix=SHOW-ALL -DVAR= %s\n+# RUN: | FileCheck -check-prefix=SHOW-ALL -DVAR=default %s\n \n # Check that LIT_OPTS understands multiple options with arbitrary spacing.\n #\n@@ -28,6 +28,6 @@\n \n # SHOW-ALL:     Testing: 1 tests\n # SHOW-ALL:     PASS: lit-opts :: test.txt (1 of 1)\n-# SHOW-ALL:     {{^}}[[VAR]]\n+# SHOW-ALL:     echo [[VAR]]\n # SHOW-ALL-NOT: PASS\n # SHOW-ALL:     Passed: 1\ndiff --git a/llvm/utils/lit/tests/shtest-define.py b/llvm/utils/lit/tests/shtest-define.py\nindex 1d0997bbbaf8..8c9309804cce 100644\n--- a/llvm/utils/lit/tests/shtest-define.py\n+++ b/llvm/utils/lit/tests/shtest-define.py\n@@ -136,15 +136,15 @@\n # RUN: %{lit} -va %{my-inputs}/shared-substs-*.txt 2>&1 |                      \\\n # RUN:   FileCheck -check-prefix=SHARED-SUBSTS -match-full-lines %s\n #\n-# SHARED-SUBSTS: shared-substs-0.txt\n-# SHARED-SUBSTS: GLOBAL: World\n-# SHARED-SUBSTS: LOCAL0: LOCAL0:Hello LOCAL0:World\n-# SHARED-SUBSTS: LOCAL0: subst\n+# SHARED-SUBSTS:# | shared-substs-0.txt\n+# SHARED-SUBSTS:# | GLOBAL: World\n+# SHARED-SUBSTS:# | LOCAL0: LOCAL0:Hello LOCAL0:World\n+# SHARED-SUBSTS:# | LOCAL0: subst\n #\n-# SHARED-SUBSTS: shared-substs-1.txt\n-# SHARED-SUBSTS: GLOBAL: World\n-# SHARED-SUBSTS: LOCAL1: LOCAL1:Hello LOCAL1:World\n-# SHARED-SUBSTS: LOCAL1: subst\n+# SHARED-SUBSTS:# | shared-substs-1.txt\n+# SHARED-SUBSTS:# | GLOBAL: World\n+# SHARED-SUBSTS:# | LOCAL1: LOCAL1:Hello LOCAL1:World\n+# SHARED-SUBSTS:# | LOCAL1: subst\n #\n # REDEFINE: %{test} = shared-substs-0.txt\n # RUN: %{record-test}\ndiff --git a/llvm/utils/lit/tests/shtest-env.py b/llvm/utils/lit/tests/shtest-env.py\nindex f2e8216f7f4a..c093b62e5420 100644\n--- a/llvm/utils/lit/tests/shtest-env.py\n+++ b/llvm/utils/lit/tests/shtest-env.py\n@@ -10,88 +10,115 @@\n # CHECK: -- Testing: 16 tests{{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-assign.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"FOO=1\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env FOO=1\n+# CHECK: # executed command: env FOO=1\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-u-arg.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO\n+# CHECK: # executed command: env -u FOO\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-u.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u\n+# CHECK: # executed command: env -u\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-nested-none.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"env\" \"env\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env env env\n+# CHECK: # executed command: env env env\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-none.txt ({{[^)]*}})\n-# CHECK: $ \"env\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env\n+# CHECK: # executed command: env\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-cd.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"cd\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'cd'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 cd foobar\n+# CHECK: # executed command: env -u FOO BAR=3 cd foobar\n+# CHECK: # | Error: 'env' cannot call 'cd'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-colon.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \":\"\n-# CHECK: Error: 'env' cannot call ':'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 :\n+# CHECK: # executed command: env -u FOO BAR=3 :\n+# CHECK: # | Error: 'env' cannot call ':'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-echo.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"echo\" \"hello\" \"world\"\n-# CHECK: Error: 'env' cannot call 'echo'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 echo hello world\n+# CHECK: # executed command: env -u FOO BAR=3 echo hello world\n+# CHECK: # | Error: 'env' cannot call 'echo'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: PASS: shtest-env :: env-calls-env.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"env\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"FOO=2\" \"env\" \"BAR=1\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"env\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=1\" \"env\" \"-u\" \"BAR\" \"FOO=2\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=1\" \"env\" \"-u\" \"BAR\" \"FOO=2\" \"env\" \"BAZ=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env env [[PYTHON:.+]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env env [[PYTHON_BARE:.+]] print_environment.py\n+# CHECK: env FOO=2 env BAR=1 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env FOO=2 env BAR=1 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO env -u BAR [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO env -u BAR [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO BAR=1 env -u BAR FOO=2 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO BAR=1 env -u BAR FOO=2 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO BAR=1 env -u BAR FOO=2 env BAZ=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO BAR=1 env -u BAR FOO=2 env BAZ=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: FAIL: shtest-env :: env-calls-export.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"export\" \"BAZ=3\"\n-# CHECK: Error: 'env' cannot call 'export'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 export BAZ=3\n+# CHECK: # executed command: env -u FOO BAR=3 export BAZ=3\n+# CHECK: # | Error: 'env' cannot call 'export'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-mkdir.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"mkdir\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'mkdir'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 mkdir foobar\n+# CHECK: # executed command: env -u FOO BAR=3 mkdir foobar\n+# CHECK: # | Error: 'env' cannot call 'mkdir'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-not-builtin.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"not\" \"rm\" \"{{.*}}.no-such-file\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 not rm {{.+}}.no-such-file\n+# CHECK: # executed command: env -u FOO BAR=3 not rm {{.+}}.no-such-file{{.*}}\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-rm.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"rm\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 rm foobar\n+# CHECK: # executed command: env -u FOO BAR=3 rm foobar\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: PASS: shtest-env :: env-u.txt ({{[^)]*}})\n-# CHECK: $ \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: env -u FOO [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO -u BAR [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO -u BAR [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: PASS: shtest-env :: env.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"A_FOO=999\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"A_FOO=1\" \"B_BAR=2\" \"C_OOF=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env A_FOO=999 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=999 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env A_FOO=1 B_BAR=2 C_OOF=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=1 B_BAR=2 C_OOF=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: PASS: shtest-env :: mixed.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"A_FOO=999\" \"-u\" \"FOO\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"A_FOO=1\" \"-u\" \"FOO\" \"B_BAR=2\" \"-u\" \"BAR\" \"C_OOF=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env A_FOO=999 -u FOO [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=999 -u FOO [[PYTHON_BARE]] print_environment.py\n+# CHECK: env A_FOO=1 -u FOO B_BAR=2 -u BAR C_OOF=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=1 -u FOO B_BAR=2 -u BAR C_OOF=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: Passed:  4\n # CHECK: Failed: 12\ndiff --git a/llvm/utils/lit/tests/shtest-format.py b/llvm/utils/lit/tests/shtest-format.py\nindex 621776ab7bc2..4a3d65b7bce4 100644\n--- a/llvm/utils/lit/tests/shtest-format.py\n+++ b/llvm/utils/lit/tests/shtest-format.py\n@@ -43,13 +43,21 @@\n # CHECK-EMPTY:\n #  CHECK-NEXT: Command Output (stdout):\n #  CHECK-NEXT: --\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-#  CHECK-NEXT: $ \"printf\"\n-#  CHECK-NEXT: # command output:\n-#  CHECK-NEXT: line 1: failed test output on stdout\n-#  CHECK-NEXT: line 2: failed test output on stdout\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-#  CHECK-NEXT: $ \"false\"\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: printf \"line 1: failed test output on stdout\\nline 2: failed test output on stdout\"\n+#  CHECK-NEXT: executed command: printf 'line 1: failed test output on stdout\\nline 2: failed test output on stdout'\n+#  CHECK-NEXT: # .---command stdout------------\n+#  CHECK-NEXT: # | line 1: failed test output on stdout\n+#  CHECK-NEXT: # | line 2: failed test output on stdout\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # RUN: at line 2\n+#  CHECK-NEXT: false\n+#  CHECK-NEXT: # executed command: false\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: --\n+\n \n # CHECK: UNRESOLVED: shtest-format :: no-test-line.txt\n # CHECK: PASS: shtest-format :: pass.txt\n@@ -73,8 +81,11 @@\n # CHECK-EMPTY:\n #  CHECK-NEXT: Command Output (stdout):\n #  CHECK-NEXT: --\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-#  CHECK-NEXT: $ \"true\"\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: true\n+#  CHECK-NEXT: # executed command: true\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: --\n \n # CHECK: Failed Tests (4)\n # CHECK: shtest-format :: external_shell/fail.txt\ndiff --git a/llvm/utils/lit/tests/shtest-if-else.py b/llvm/utils/lit/tests/shtest-if-else.py\nindex aaf94a6e2437..c18da4abbcca 100644\n--- a/llvm/utils/lit/tests/shtest-if-else.py\n+++ b/llvm/utils/lit/tests/shtest-if-else.py\n@@ -1,5 +1,6 @@\n # RUN: %{lit} -v --show-all %{inputs}/shtest-if-else/test.txt \\\n-# RUN:    | FileCheck %{inputs}/shtest-if-else/test.txt --match-full-lines\n+# RUN:    | FileCheck %{inputs}/shtest-if-else/test.txt --match-full-lines \\\n+# RUN:                --implicit-check-not='RUN:'\n \n # RUN: not %{lit} -v --show-all %{inputs}/shtest-if-else/test-neg1.txt 2>&1 \\\n # RUN:    | FileCheck %{inputs}/shtest-if-else/test-neg1.txt\ndiff --git a/llvm/utils/lit/tests/shtest-inject.py b/llvm/utils/lit/tests/shtest-inject.py\nindex 17e293ea1a12..3d34eb7161d4 100644\n--- a/llvm/utils/lit/tests/shtest-inject.py\n+++ b/llvm/utils/lit/tests/shtest-inject.py\n@@ -1,9 +1,26 @@\n-# Check that we can inject commands at the beginning of a ShTest.\n+# Check that we can inject preamble commands at the beginning of a ShTest.\n+#\n+# For one case, check the execution trace as these preamble commands have\n+# \"preamble command\" instead of the usual \"{{RUN}}: at line N\".\n \n # RUN: %{lit} %{inputs}/shtest-inject/test-empty.txt --show-all | FileCheck --check-prefix=CHECK-TEST1 %s\n #\n-# CHECK-TEST1: THIS WAS\n-# CHECK-TEST1: INJECTED\n+#       CHECK-TEST1: Command Output (stdout):\n+#  CHECK-TEST1-NEXT: --\n+#  CHECK-TEST1-NEXT: # preamble command line\n+#  CHECK-TEST1-NEXT: echo \"THIS WAS\"\n+#  CHECK-TEST1-NEXT: # executed command: echo 'THIS WAS'\n+#  CHECK-TEST1-NEXT: # .---command stdout{{-*}}\n+#  CHECK-TEST1-NEXT: # | THIS WAS\n+#  CHECK-TEST1-NEXT: # `---{{-*}}\n+#  CHECK-TEST1-NEXT: # preamble command line\n+#  CHECK-TEST1-NEXT: echo \"INJECTED\"\n+#  CHECK-TEST1-NEXT: # executed command: echo INJECTED\n+#  CHECK-TEST1-NEXT: # .---command stdout{{-*}}\n+#  CHECK-TEST1-NEXT: # | INJECTED\n+#  CHECK-TEST1-NEXT: # `---{{-*}}\n+# CHECK-TEST1-EMPTY:\n+#  CHECK-TEST1-NEXT: --\n #\n # CHECK-TEST1: Passed: 1\n \ndiff --git a/llvm/utils/lit/tests/shtest-not.py b/llvm/utils/lit/tests/shtest-not.py\nindex d23c9d0cffaf..f514cddf1def 100644\n--- a/llvm/utils/lit/tests/shtest-not.py\n+++ b/llvm/utils/lit/tests/shtest-not.py\n@@ -10,112 +10,158 @@\n # CHECK: -- Testing: 17 tests{{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-args-nested-none.txt {{.*}}\n-# CHECK: $ \"!\" \"!\" \"!\"\n-# CHECK: Error: '!' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: ! ! !\n+# CHECK: # executed command: ! ! !\n+# CHECK: # | Error: '!' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-args-none.txt {{.*}}\n-# CHECK: $ \"!\"\n-# CHECK: Error: '!' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: !\n+# CHECK: # executed command: !\n+# CHECK: # | Error: '!' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-calls-external.txt {{.*}}\n \n-# CHECK: $ \"!\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"!\" \"!\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"!\" \"!\" \"!\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"!\" \"!\" \"!\" \"!\" \"{{[^\"]*}}\" \"pass.py\"\n+# CHECK: ! [[PYTHON:.*]] fail.py\n+# CHECK: # executed command: ! [[PYTHON_BARE:.*]] fail.py\n+# CHECK: ! ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! ! [[PYTHON_BARE]] pass.py\n+# CHECK: ! ! ! [[PYTHON]] fail.py\n+# CHECK: # executed command: ! ! ! [[PYTHON_BARE]] fail.py\n+# CHECK: ! ! ! ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! ! ! ! [[PYTHON_BARE]] pass.py\n \n-# CHECK: $ \"!\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! [[PYTHON_BARE]] pass.py\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-last-is-crash.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not --crash\n+# CHECK: # executed command: not --crash\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-nested-none.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not not\n+# CHECK: # executed command: not not not\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-none.txt {{.*}}\n-# CHECK: $ \"not\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not\n+# CHECK: # executed command: not\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-cd.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"cd\" \"foobar\"\n-# CHECK: $ \"not\" \"--crash\" \"cd\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'cd'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not cd foobar\n+# CHECK: # executed command: not not cd foobar\n+# CHECK: not --crash cd foobar\n+# CHECK: # executed command: not --crash cd foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'cd'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-colon.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \":\" \"foobar\"\n-# CHECK: $ \"not\" \"--crash\" \":\"\n-# CHECK: Error: 'not --crash' cannot call ':'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not : foobar\n+# CHECK: # executed command: not not : foobar\n+# CHECK: not --crash :\n+# CHECK: # executed command: not --crash :\n+# CHECK: # | Error: 'not --crash' cannot call ':'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-diff-with-crash.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"diff\" \"-u\" {{.*}}\n-# CHECK-NOT: \"$\"\n+# CHECK: not --crash diff -u {{.*}}\n+# CHECK: # executed command: not --crash diff -u {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n # CHECK-NOT: {{[Ee]rror}}\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: # error: command failed with exit status: {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n # CHECK-NOT: {{[Ee]rror}}\n-# CHECK-NOT: \"$\"\n \n # CHECK: FAIL: shtest-not :: not-calls-diff.txt {{.*}}\n-# CHECK: $ \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"diff\" {{.*}}\n-# CHECK-NOT: \"$\"\n+# CHECK: not diff {{.*}}\n+# CHECK: # executed command: not diff {{.*}}\n+# CHECK: not not not diff {{.*}}\n+# CHECK: # executed command: not not not diff {{.*}}\n+# CHECK: not not not not not diff {{.*}}\n+# CHECK: # executed command: not not not not not diff {{.*}}\n+# CHECK: diff {{.*}}\n+# CHECK: # executed command: diff {{.*}}\n+# CHECK: not not diff {{.*}}\n+# CHECK: # executed command: not not diff {{.*}}\n+# CHECK: not not not not diff {{.*}}\n+# CHECK: # executed command: not not not not diff {{.*}}\n+# CHECK: not diff {{.*}}\n+# CHECK: # executed command: not diff {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-echo.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"echo\" \"hello\" \"world\"\n-# CHECK: $ \"not\" \"--crash\" \"echo\" \"hello\" \"world\"\n-# CHECK: Error: 'not --crash' cannot call 'echo'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not echo hello world\n+# CHECK: # executed command: not not echo hello world\n+# CHECK: not --crash echo hello world\n+# CHECK: # executed command: not --crash echo hello world\n+# CHECK: # | Error: 'not --crash' cannot call 'echo'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-env-builtin.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"env\" \"-u\" \"FOO\" \"BAR=3\" \"rm\" \"{{.*}}.no-such-file\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not --crash env -u FOO BAR=3 rm {{.*}}.no-such-file\n+# CHECK: # executed command: not --crash env -u FOO BAR=3 rm {{.+}}.no-such-file{{.*}}\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-export.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"export\" \"FOO=1\"\n-# CHECK: $ \"not\" \"--crash\" \"export\" \"BAZ=3\"\n-# CHECK: Error: 'not --crash' cannot call 'export'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not export FOO=1\n+# CHECK: # executed command: not not export FOO=1\n+# CHECK: not --crash export BAZ=3\n+# CHECK: # executed command: not --crash export BAZ=3\n+# CHECK: # | Error: 'not --crash' cannot call 'export'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n \n # CHECK: PASS: shtest-not :: not-calls-external.txt {{.*}}\n \n-# CHECK: $ \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-\n-# CHECK: $ \"env\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"env\" \"-u\" \"FOO\" \"BAR=2\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"env\" \"-u\" \"FOO\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"env\" \"FOO=1\" \"env\" \"FOO=2\" \"BAR=1\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"-u\" \"BAR\" \"env\" \"-u\" \"FOO\" \"BAR=1\" \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"env\" \"FOO=2\" \"BAR=2\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"env\" \"-u\" \"BAR\" \"not\" \"env\" \"-u\" \"FOO\" \"BAR=1\" \"{{[^\"]*}}\" \"pass.py\"\n+# CHECK: not [[PYTHON]] fail.py\n+# CHECK: # executed command: not [[PYTHON_BARE]] fail.py\n+# CHECK: not not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not [[PYTHON_BARE]] pass.py\n+# CHECK: not not not [[PYTHON]] fail.py\n+# CHECK: # executed command: not not not [[PYTHON_BARE]] fail.py\n+# CHECK: not not not not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not not not [[PYTHON_BARE]] pass.py\n+\n+# CHECK: not not --crash [[PYTHON]] pass.py\n+# CHECK: # executed command: not not --crash [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash [[PYTHON]] fail.py\n+# CHECK: # executed command: not not --crash [[PYTHON_BARE]] fail.py\n+# CHECK: not not --crash not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not --crash not [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash not [[PYTHON]] fail.py\n+# CHECK: # executed command: not not --crash not [[PYTHON_BARE]] fail.py\n+\n+# CHECK: env not [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env not [[PYTHON_BARE]] fail.py\n+# CHECK: not env [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: not env [[PYTHON_BARE]] fail.py\n+# CHECK: env FOO=1 not [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 not [[PYTHON_BARE]] fail.py\n+# CHECK: not env FOO=1 BAR=1 [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 [[PYTHON_BARE]] fail.py\n+# CHECK: env FOO=1 BAR=1 not env -u FOO BAR=2 [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 BAR=1 not env -u FOO BAR=2 [[PYTHON_BARE]] fail.py\n+# CHECK: not env FOO=1 BAR=1 not env -u FOO -u BAR [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 not env -u FOO -u BAR [[PYTHON_BARE]] pass.py\n+# CHECK: not not env FOO=1 env FOO=2 BAR=1 [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not not env FOO=1 env FOO=2 BAR=1 [[PYTHON_BARE]] pass.py\n+# CHECK: env FOO=1 -u BAR env -u FOO BAR=1 not not [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 -u BAR env -u FOO BAR=1 not not [[PYTHON_BARE]] pass.py\n+\n+# CHECK: not env FOO=1 BAR=1 env FOO=2 BAR=2 not --crash [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 env FOO=2 BAR=2 not --crash [[PYTHON_BARE]] pass.py\n+# CHECK: not env FOO=1 BAR=1 not --crash not [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 not --crash not [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash env -u BAR not env -u FOO BAR=1 [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not not --crash env -u BAR not env -u FOO BAR=1 [[PYTHON_BARE]] pass.py\n \n \n # CHECK: FAIL: shtest-not :: not-calls-fail2.txt {{.*}}\n@@ -123,16 +169,20 @@\n # CHECK-NEXT: Exit Code: 1\n \n # CHECK: FAIL: shtest-not :: not-calls-mkdir.txt {{.*}}\n-# CHECK: $ \"not\" \"mkdir\" {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"mkdir\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'mkdir'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not mkdir {{.*}}\n+# CHECK: # executed command: not mkdir {{.*}}\n+# CHECK: not --crash mkdir foobar\n+# CHECK: # executed command: not --crash mkdir foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'mkdir'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-rm.txt {{.*}}\n-# CHECK: $ \"not\" \"rm\" {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"rm\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not rm {{.*}}\n+# CHECK: # executed command: not rm {{.*}}\n+# CHECK: not --crash rm foobar\n+# CHECK: # executed command: not --crash rm foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: Passed:  1\n # CHECK: Failed: 16\ndiff --git a/llvm/utils/lit/tests/shtest-output-printing.py b/llvm/utils/lit/tests/shtest-output-printing.py\nindex 7cd975ba8d3c..129cff981eb5 100644\n--- a/llvm/utils/lit/tests/shtest-output-printing.py\n+++ b/llvm/utils/lit/tests/shtest-output-printing.py\n@@ -1,28 +1,45 @@\n # Check the various features of the ShTest format.\n #\n # RUN: not %{lit} -v %{inputs}/shtest-output-printing > %t.out\n-# RUN: FileCheck --input-file %t.out %s\n+# RUN: FileCheck --input-file %t.out --match-full-lines %s\n #\n # END.\n \n-# CHECK: -- Testing:\n-\n-# CHECK: FAIL: shtest-output-printing :: basic.txt\n-# CHECK-NEXT: *** TEST 'shtest-output-printing :: basic.txt' FAILED ***\n-# CHECK-NEXT: Exit Code: 1\n-#\n-# CHECK:      Command Output\n-# CHECK-NEXT: --\n-# CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \"true\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-# CHECK-NEXT: $ \"echo\" \"hi\"\n-# CHECK-NEXT: # command output:\n-# CHECK-NEXT: hi\n-#\n-# CHECK:      $ \":\" \"RUN: at line 3\"\n-# CHECK-NEXT: $ \"not\" \"not\" \"wc\" \"missing-file\"\n-# CHECK-NEXT: # redirected output from '{{.*(/|\\\\\\\\)}}basic.txt.tmp.out':\n-# CHECK-NEXT: {{cannot open missing-file|missing-file.* No such file or directory}}\n-# CHECK:      note: command had no output on stdout or stderr\n-# CHECK-NEXT: error: command failed with exit status: 1\n+#       CHECK: -- Testing: {{.*}}\n+#       CHECK: FAIL: shtest-output-printing :: basic.txt {{.*}}\n+#  CHECK-NEXT: ***{{\\**}} TEST 'shtest-output-printing :: basic.txt' FAILED ***{{\\**}}\n+#  CHECK-NEXT: Exit Code: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: Command Output (stdout):\n+#  CHECK-NEXT: --\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: true\n+#  CHECK-NEXT: # executed command: true\n+#  CHECK-NEXT: # RUN: at line 2\n+#  CHECK-NEXT: echo hi\n+#  CHECK-NEXT: # executed command: echo hi\n+#  CHECK-NEXT: # .---command stdout------------\n+#  CHECK-NEXT: # | hi\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # RUN: at line 3\n+#  CHECK-NEXT: not not wc missing-file &> [[FILE:.*]] || true\n+#  CHECK-NEXT: # executed command: not not wc missing-file\n+#  CHECK-NEXT: # .---redirected output from '[[FILE]]'\n+#  CHECK-NEXT: # | wc: {{cannot open missing-file|missing-file.* No such file or directory}}\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+#  CHECK-NEXT: # executed command: true\n+#  CHECK-NEXT: # RUN: at line 4\n+#  CHECK-NEXT: not {{.*}}python{{.*}} {{.*}}write-a-lot.py &> [[FILE:.*]]\n+#  CHECK-NEXT: # executed command: not {{.*}}python{{.*}} {{.*}}write-a-lot.py{{.*}}\n+#  CHECK-NEXT: # .---redirected output from '[[FILE]]'\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#       CHECK: # | ...\n+#  CHECK-NEXT: # `---data was truncated--------\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT:--\ndiff --git a/llvm/utils/lit/tests/shtest-pushd-popd.py b/llvm/utils/lit/tests/shtest-pushd-popd.py\nindex 26296a7ffcf5..6d7e93c74a05 100644\n--- a/llvm/utils/lit/tests/shtest-pushd-popd.py\n+++ b/llvm/utils/lit/tests/shtest-pushd-popd.py\n@@ -8,16 +8,16 @@\n # CHECK: -- Testing: 4 tests{{.*}}\n \n # CHECK: FAIL: shtest-pushd-popd :: popd-args.txt ({{[^)]*}})\n-# CHECK: $ \"popd\" \"invalid\"\n-# CHECK: 'popd' does not support arguments\n+# CHECK: popd invalid\n+# CHECK: # | 'popd' does not support arguments\n \n # CHECK: FAIL: shtest-pushd-popd :: popd-no-stack.txt ({{[^)]*}})\n-# CHECK: $ \"popd\"\n-# CHECK: popd: directory stack empty\n+# CHECK: popd\n+# CHECK: # | popd: directory stack empty\n \n # CHECK: FAIL: shtest-pushd-popd :: pushd-too-many-args.txt ({{[^)]*}})\n-# CHECK: $ \"pushd\" \"a\" \"b\"\n-# CHECK: 'pushd' supports only one argument\n+# CHECK: pushd a b\n+# CHECK: # | 'pushd' supports only one argument\n \n # CHECK: Passed:  1\n # CHECK: Failed:  3\ndiff --git a/llvm/utils/lit/tests/shtest-recursive-substitution.py b/llvm/utils/lit/tests/shtest-recursive-substitution.py\nindex 48f4b5b12491..65c177e65a3c 100644\n--- a/llvm/utils/lit/tests/shtest-recursive-substitution.py\n+++ b/llvm/utils/lit/tests/shtest-recursive-substitution.py\n@@ -3,7 +3,7 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/substitutes-within-limit --show-all | FileCheck --check-prefix=CHECK-TEST1 %s\n # CHECK-TEST1: PASS: substitutes-within-limit :: test.py\n-# CHECK-TEST1: $ \"echo\" \"STOP\"\n+# CHECK-TEST1: echo STOP\n \n # RUN: not %{lit} %{inputs}/shtest-recursive-substitution/does-not-substitute-within-limit --show-all | FileCheck --check-prefix=CHECK-TEST2 %s\n # CHECK-TEST2: UNRESOLVED: does-not-substitute-within-limit :: test.py\n@@ -11,7 +11,7 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/does-not-substitute-no-limit --show-all | FileCheck --check-prefix=CHECK-TEST3 %s\n # CHECK-TEST3: PASS: does-not-substitute-no-limit :: test.py\n-# CHECK-TEST3: $ \"echo\" \"%rec4\"\n+# CHECK-TEST3: echo %rec4\n \n # RUN: not %{lit} %{inputs}/shtest-recursive-substitution/not-an-integer --show-all 2>&1 | FileCheck --check-prefix=CHECK-TEST4 %s\n # CHECK-TEST4: recursiveExpansionLimit must be either None or an integer\n@@ -24,4 +24,4 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/escaping --show-all | FileCheck --check-prefix=CHECK-TEST7 %s\n # CHECK-TEST7: PASS: escaping :: test.py\n-# CHECK-TEST7: $ \"echo\" \"%s\" \"%s\" \"%%s\"\n+# CHECK-TEST7: echo %s %s %%s\ndiff --git a/llvm/utils/lit/tests/shtest-run-at-line.py b/llvm/utils/lit/tests/shtest-run-at-line.py\nindex 879cd64ebf6e..a0626f872c4c 100644\n--- a/llvm/utils/lit/tests/shtest-run-at-line.py\n+++ b/llvm/utils/lit/tests/shtest-run-at-line.py\n@@ -28,21 +28,28 @@\n # CHECK-LABEL: FAIL: shtest-run-at-line :: internal-shell/basic.txt\n \n # CHECK:      Command Output (stdout)\n-# CHECK:      $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \"true\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-# CHECK-NEXT: $ \"false\"\n+# CHECK-NEXT: --\n+# CHECK-NEXT: # RUN: at line 1\n+# CHECK-NEXT: true\n+# CHECK-NEXT: # executed command: true\n+# CHECK-NEXT: # RUN: at line 2\n+# CHECK-NEXT: false\n+# CHECK-NEXT: # executed command: false\n # CHECK-NOT:  RUN\n \n # CHECK-LABEL: FAIL: shtest-run-at-line :: internal-shell/line-continuation.txt\n \n # CHECK:      Command Output (stdout)\n-# CHECK:      $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \":\" \"first\" \"line\" \"continued\" \"to\" \"second\" \"line\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 3\"\n-# CHECK-NEXT: $ \"echo\" \"foo bar\"\n-# CHECK-NEXT: $ \"FileCheck\" \"{{.*}}\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 5\"\n-# CHECK-NEXT: $ \"echo\" \"foo baz\"\n-# CHECK-NEXT: $ \"FileCheck\" \"{{.*}}\"\n+# CHECK-NEXT: --\n+# CHECK-NEXT: # RUN: at line 1\n+# CHECK-NEXT: : first line continued to second line\n+# CHECK-NEXT: # executed command: : first line continued to second line\n+# CHECK-NEXT: # RUN: at line 3\n+# CHECK-NEXT: echo 'foo bar' | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: echo 'foo bar'\n+# CHECK-NEXT: # executed command: FileCheck {{.*}}\n+# CHECK-NEXT: # RUN: at line 5\n+# CHECK-NEXT: echo 'foo baz' | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: echo 'foo baz'\n+# CHECK-NEXT: # executed command: FileCheck {{.*}}\n # CHECK-NOT:  RUN\ndiff --git a/llvm/utils/lit/tests/shtest-shell.py b/llvm/utils/lit/tests/shtest-shell.py\nindex 93f05dbd35d0..a043582d6ae2 100644\n--- a/llvm/utils/lit/tests/shtest-shell.py\n+++ b/llvm/utils/lit/tests/shtest-shell.py\n@@ -20,202 +20,212 @@\n \n # CHECK: FAIL: shtest-shell :: cat-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: cat-error-0.txt' FAILED ***\n-# CHECK: $ \"cat\" \"-b\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'cat':  option -b not recognized\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: cat -b temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'cat':  option -b not recognized\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: cat-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: cat-error-1.txt' FAILED ***\n-# CHECK: $ \"cat\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: [Errno 2] No such file or directory: 'temp1.txt'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: cat temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | [Errno 2] No such file or directory: 'temp1.txt'\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: colon-error.txt\n # CHECK: *** TEST 'shtest-shell :: colon-error.txt' FAILED ***\n-# CHECK: $ \":\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: ':' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: :\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: ':' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: PASS: shtest-shell :: continuations.txt\n \n # CHECK: PASS: shtest-shell :: dev-null.txt\n \n-# CHECK: FAIL: shtest-shell :: diff-b.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-b.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-b\" \"{{[^\"]*}}.0\" \"{{[^\"]*}}.1\"\n-# CHECK: # command output:\n-# CHECK: 1,2\n-# CHECK-NEXT: {{^  }}f o o\n-# CHECK-NEXT: ! b a r\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: {{^  }}f o o\n-# CHECK-NEXT: ! bar\n-# CHECK-EMPTY:\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-b.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-b.txt' FAILED ***\n+#      CHECK: diff -b {{[^\"]*}}.0 {{[^\"]*}}.1\n+#      CHECK: # .---command stdout{{-*}}\n+#      CHECK: # | {{.*}}1,2\n+# CHECK-NEXT: # |   f o o\n+# CHECK-NEXT: # | ! b a r\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # |   f o o\n+# CHECK-NEXT: # | ! bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+#      CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-encodings.txt\n # CHECK: *** TEST 'shtest-shell :: diff-encodings.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"diff-in.bin\"\n+#      CHECK: diff -u diff-in.bin diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.bin diff-in.bin\n+#  CHECK-NOT: error\n+\n+#      CHECK: diff -u diff-in.utf16 diff-in.bin && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf16 diff-in.bin\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.utf8 diff-in.bin && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf8 diff-in.bin\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | -baz\n+# CHECK-NEXT: # | {{\\+.f.o.o.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{\\+.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.bin diff-in.utf8 && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.bin diff-in.utf8\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{-.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.}}\n+# CHECK-NEXT: # | {{-.b.a.z.$}}\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # | +baz\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#     CHECK: cat diff-in.bin | diff -u - diff-in.bin\n # CHECK-NOT: error\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf16\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^ .f.o.o.$}}\n-# CHECK-NEXT: {{^-.b.a.r.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^ .b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf8\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: -baz\n-# CHECK-NEXT: {{^\\+.f.o.o.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^\\+.b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"diff-in.utf8\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^\\-.f.o.o.$}}\n-# CHECK-NEXT: {{^\\-.b.a.r.}}\n-# CHECK-NEXT: {{^\\-.b.a.z.$}}\n-# CHECK-NEXT: +foo\n-# CHECK-NEXT: +bar\n-# CHECK-NEXT: +baz\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"-\"\n-# CHECK-NOT: error\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf16\" \"-\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^ .f.o.o.$}}\n-# CHECK-NEXT: {{^-.b.a.r.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^ .b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n+#     CHECK: cat diff-in.bin | diff -u diff-in.bin -\n # CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf8\" \"-\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: -baz\n-# CHECK-NEXT: {{^\\+.f.o.o.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^\\+.b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"diff-in.utf8\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^\\-.f.o.o.$}}\n-# CHECK-NEXT: {{^\\-.b.a.r.}}\n-# CHECK-NEXT: {{^\\-.b.a.z.$}}\n-# CHECK-NEXT: +foo\n-# CHECK-NEXT: +bar\n-# CHECK-NEXT: +baz\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n \n-# CHECK: $ \"false\"\n+#      CHECK: cat diff-in.bin | diff -u diff-in.utf16 - && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf16 -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat diff-in.bin | diff -u diff-in.utf8 - && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf8 -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | -baz\n+# CHECK-NEXT: # | {{\\+.f.o.o.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{\\+.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat diff-in.bin | diff -u - diff-in.utf8 && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u - diff-in.utf8\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{-.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.}}\n+# CHECK-NEXT: # | {{-.b.a.z.$}}\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # | +baz\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-1.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-B\" \"temp1.txt\" \"temp2.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'diff': option -B not recognized\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -B temp1.txt temp2.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'diff': option -B not recognized\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-2.txt' FAILED ***\n-# CHECK: $ \"diff\" \"temp.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff temp.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-3.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-3.txt' FAILED ***\n-# CHECK: $ \"diff\" \"temp.txt\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'diff' command failed\n+# CHECK: diff temp.txt temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'diff' command failed\n # CHECK: error: command failed with exit status: 1\n # CHECK: ***\n \n-# CHECK: FAIL: shtest-shell :: diff-error-4.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-error-4.txt' FAILED ***\n-# CHECK: Exit Code: 1\n-# CHECK: # command output:\n-# CHECK: diff-error-4.txt.tmp\n-# CHECK: diff-error-4.txt.tmp1\n-# CHECK: *** 1 ****\n-# CHECK: ! hello-first\n-# CHECK: --- 1 ----\n-# CHECK: ! hello-second\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-error-4.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-error-4.txt' FAILED ***\n+#      CHECK: Exit Code: 1\n+#      CHECK: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | {{.*}}diff-error-4.txt.tmp\n+# CHECK-NEXT: # | {{.*}}diff-error-4.txt.tmp1\n+# CHECK-NEXT: # | {{\\*+}}\n+# CHECK-NEXT: # | *** 1 ****\n+# CHECK-NEXT: # | ! hello-first\n+# CHECK-NEXT: # | --- 1 ----\n+# CHECK-NEXT: # | ! hello-second\n+# CHECK-NEXT: # `---{{-*}}\n+#      CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-5.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-5.txt' FAILED ***\n-# CHECK: $ \"diff\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-6.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-6.txt' FAILED ***\n-# CHECK: $ \"diff\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n \n@@ -223,137 +233,130 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-pipes.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.foo\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"FileCheck\"\n+# CHECK: diff {{[^ ]*}}.foo {{.*}}.foo | FileCheck {{.*}}\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: note: command had no output on stdout or stderr\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"FileCheck\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"true\"\n+#      CHECK: diff -u {{.*}}.foo {{.*}}.bar | FileCheck {{.*}} && false || true\n+# CHECK-NEXT: # executed command: diff -u {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # note: command had no output on stdout or stderr\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: FileCheck\n+# CHECK-NEXT: # executed command: true\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"{{[^\"]*}}.foo\"\n+#     CHECK: cat {{.*}}.foo | diff -u - {{.*}}.foo\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n+#     CHECK: cat {{.*}}.foo | diff -u {{.*}}.foo -\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: +bar\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"{{[^\"]*}}.foo\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: +foo\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-\" \"{{[^\"]*}}.foo\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"FileCheck\"\n+#      CHECK: cat {{.*}}.bar | diff -u {{.*}}.foo - && false || true\n+# CHECK-NEXT: # executed command: cat {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # executed command: diff -u {{.+}}.foo{{.*}} -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat {{.*}}.bar | diff -u - {{.*}}.foo && false || true\n+# CHECK-NEXT: # executed command: cat {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # executed command: diff -u - {{.+}}.foo{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#     CHECK: cat {{.*}}.foo | diff - {{.*}}.foo | FileCheck {{.*}}\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n-# CHECK: note: command had no output on stdout or stderr\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"FileCheck\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"true\"\n+#      CHECK: cat {{.*}}.bar | diff -u {{.*}}.foo - | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: cat {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # executed command: diff -u {{.+}}.foo{{.*}} -\n+# CHECK-NEXT: note: command had no output on stdout or stderr\n+# CHECK-NEXT: error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: FileCheck\n+# CHECK-NEXT: # executed command: true\n \n-# CHECK: $ \"false\"\n+# CHECK: false\n \n # CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-r-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-0.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: dir1unique\n-# CHECK: Only in {{.*}}dir2: dir2unique\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: dir1unique\n+# CHECK: # | Only in {{.*}}dir2: dir2unique\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-1.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: *** {{.*}}dir1{{.*}}subdir{{.*}}f01\n-# CHECK: --- {{.*}}dir2{{.*}}subdir{{.*}}f01\n-# CHECK: 12345\n-# CHECK: 00000\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | *** {{.*}}dir1{{.*}}subdir{{.*}}f01\n+# CHECK: # | --- {{.*}}dir2{{.*}}subdir{{.*}}f01\n+# CHECK: # | ! 12345\n+# CHECK: # | ! 00000\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-2.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir2: extrafile\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir2: extrafile\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-3.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-3.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: extra_subdir\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: extra_subdir\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-4.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-4.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: File {{.*}}dir1{{.*}}extra_subdir is a directory while file {{.*}}dir2{{.*}}extra_subdir is a regular file\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | File {{.*}}dir1{{.*}}extra_subdir is a directory while file {{.*}}dir2{{.*}}extra_subdir is a regular file\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-5.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-5.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: extra_subdir\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: extra_subdir\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-6.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-6.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: File {{.*}}dir1{{.*}}extra_file is a regular empty file while file {{.*}}dir2{{.*}}extra_file is a directory\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | File {{.*}}dir1{{.*}}extra_file is a regular empty file while file {{.*}}dir2{{.*}}extra_file is a directory\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-7.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-7.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\" \"-\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: cannot recursively compare '-'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r - {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: cannot recursively compare '-'\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-8.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-8.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\" \"{{[^\"]*}}\" \"-\"\n-# CHECK: # command stderr:\n-# CHECK: Error: cannot recursively compare '-'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r {{.*}} -\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: cannot recursively compare '-'\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: PASS: shtest-shell :: diff-r.txt\n \n@@ -362,51 +365,59 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-strip-trailing-cr.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.dos\" \"diff-in.unix\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -In this file, the\n-# CHECK-NEXT: -sequence \"\\r\\n\"\n-# CHECK-NEXT: -terminates lines.\n-# CHECK-NEXT: +In this file, the\n-# CHECK-NEXT: +sequence \"\\n\"\n-# CHECK-NEXT: +terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.unix\" \"diff-in.dos\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -In this file, the\n-# CHECK-NEXT: -sequence \"\\n\"\n-# CHECK-NEXT: -terminates lines.\n-# CHECK-NEXT: +In this file, the\n-# CHECK-NEXT: +sequence \"\\r\\n\"\n-# CHECK-NEXT: +terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"--strip-trailing-cr\" \"diff-in.dos\" \"diff-in.unix\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT:  In this file, the\n-# CHECK-NEXT: -sequence \"\\r\\n\"\n-# CHECK-NEXT: +sequence \"\\n\"\n-# CHECK-NEXT:  terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"--strip-trailing-cr\" \"diff-in.unix\" \"diff-in.dos\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT:  In this file, the\n-# CHECK-NEXT: -sequence \"\\n\"\n-# CHECK-NEXT: +sequence \"\\r\\n\"\n-# CHECK-NEXT:  terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"false\"\n+#      CHECK: diff -u diff-in.dos diff-in.unix && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.dos diff-in.unix\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -In this file, the\n+# CHECK-NEXT: # | -sequence \"\\r\\n\"\n+# CHECK-NEXT: # | -terminates lines.\n+# CHECK-NEXT: # | +In this file, the\n+# CHECK-NEXT: # | +sequence \"\\n\"\n+# CHECK-NEXT: # | +terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.unix diff-in.dos && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.unix diff-in.dos\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -In this file, the\n+# CHECK-NEXT: # | -sequence \"\\n\"\n+# CHECK-NEXT: # | -terminates lines.\n+# CHECK-NEXT: # | +In this file, the\n+# CHECK-NEXT: # | +sequence \"\\r\\n\"\n+# CHECK-NEXT: # | +terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u --strip-trailing-cr diff-in.dos diff-in.unix && false || true\n+# CHECK-NEXT: executed command: diff -u --strip-trailing-cr diff-in.dos diff-in.unix\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # |  In this file, the\n+# CHECK-NEXT: # | -sequence \"\\r\\n\"\n+# CHECK-NEXT: # | +sequence \"\\n\"\n+# CHECK-NEXT: # |  terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u --strip-trailing-cr diff-in.unix diff-in.dos && false || true\n+# CHECK-NEXT: # executed command: diff -u --strip-trailing-cr diff-in.unix diff-in.dos\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # |  In this file, the\n+# CHECK-NEXT: # | -sequence \"\\n\"\n+# CHECK-NEXT: # | +sequence \"\\r\\n\"\n+# CHECK-NEXT: # |  terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n@@ -415,106 +426,144 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-unified.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 3\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-NEXT: 9\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U\" \"2\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U4\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 2\n-# CHECK-NEXT: 3\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-NEXT: 9\n-# CHECK-NEXT: 10\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U0\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U\" \"30.1\" \"{{[^\"]*}}\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: invalid '-U' argument: 30.1\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U-1\" \"{{[^\"]*}}\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: invalid '-U' argument: -1\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"false\"\n+#      CHECK: diff -u {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -u {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 3\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # | 9\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U 2 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U 2 {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U4 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U4 {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 2\n+# CHECK-NEXT: # | 3\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # | 9\n+# CHECK-NEXT: # | 10\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U0 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U0 {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: diff -U 30.1 {{.*}} {{.*}} && false || true\n+# CHECK: # executed command: diff -U 30.1 {{.*}} {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: invalid '-U' argument: 30.1\n+# CHECK: # error: command failed with exit status: 1\n+# CHECK: # executed command: true\n+\n+# CHECK: diff -U-1 {{.*}} {{.*}} && false || true\n+# CHECK: # executed command: diff -U-1 {{.*}} {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: invalid '-U' argument: -1\n+# CHECK: # error: command failed with exit status: 1\n+# CHECK: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n \n-# CHECK: FAIL: shtest-shell :: diff-w.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-w.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-w\" \"{{[^\"]*}}.0\" \"{{[^\"]*}}.1\"\n-# CHECK: # command output:\n-# CHECK: 1,3\n-# CHECK-NEXT: {{^  }}foo\n-# CHECK-NEXT: {{^  }}bar\n-# CHECK-NEXT: ! baz\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: {{^  }}foo\n-# CHECK-NEXT: {{^  }}bar\n-# CHECK-NEXT: ! bat\n-# CHECK-EMPTY:\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-w.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-w.txt' FAILED ***\n+#      CHECK: diff -w {{.*}}.0 {{.*}}.1\n+#      CHECK: # .---command stdout{{-*}}\n+#      CHECK: # | {{\\*+}} 1,3\n+# CHECK-NEXT: # |   foo\n+# CHECK-NEXT: # |   bar\n+# CHECK-NEXT: # | ! baz\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # |   foo\n+# CHECK-NEXT: # |   bar\n+# CHECK-NEXT: # | ! bat\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+#      CHECK: ***\n+\n+# CHECK: FAIL: shtest-shell :: echo-at-redirect-stderr.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-at-redirect-stderr.txt' FAILED ***\n+# CHECK: @echo 2> {{.*}}\n+# CHECK: # executed command: @echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for @echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-at-redirect-stdin.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-at-redirect-stdin.txt' FAILED ***\n+# CHECK: @echo < {{.*}}\n+# CHECK: # executed command: @echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for @echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-redirect-stderr.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-redirect-stderr.txt' FAILED ***\n+# CHECK: echo 2> {{.*}}\n+# CHECK: # executed command: echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-redirect-stdin.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-redirect-stdin.txt' FAILED ***\n+# CHECK: echo < {{.*}}\n+# CHECK: # executed command: echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for echo\n+# CHECK: error: command failed with exit status:\n \n # CHECK: FAIL: shtest-shell :: error-0.txt\n # CHECK: *** TEST 'shtest-shell :: error-0.txt' FAILED ***\n-# CHECK: $ \"not-a-real-command\"\n-# CHECK: # command stderr:\n-# CHECK: 'not-a-real-command': command not found\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: not-a-real-command\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | 'not-a-real-command': command not found\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # FIXME: The output here sucks.\n #\n # CHECK: FAIL: shtest-shell :: error-1.txt\n # CHECK: *** TEST 'shtest-shell :: error-1.txt' FAILED ***\n-# CHECK: shell parser error on: ': \\'RUN: at line 3\\'; echo \"missing quote'\n+# CHECK: shell parser error on RUN: at line 3: echo \"missing quote\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: error-2.txt\n@@ -524,52 +573,52 @@\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-0.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'mkdir' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p temp | rm -rf temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'mkdir' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-1.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\" \"-m\" \"777\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'mkdir': option -m not recognized\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p -m 777 temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'mkdir': option -m not recognized\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-2.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'mkdir' is missing an operand\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'mkdir' is missing an operand\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: PASS: shtest-shell :: redirects.txt\n \n # CHECK: FAIL: shtest-shell :: rm-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-0.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-rf\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'rm' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: rm -rf temp | echo \"hello\"\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'rm' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-1.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-f\" \"-v\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'rm': option -v not recognized\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: rm -f -v temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'rm': option -v not recognized\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-2.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-r\" \"hello\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'rm' command failed\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: rm -r hello\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'rm' command failed\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-3.txt\n@@ -581,16 +630,17 @@\n # CHECK: PASS: shtest-shell :: sequencing-0.txt\n # CHECK: XFAIL: shtest-shell :: sequencing-1.txt\n \n-# CHECK: FAIL: shtest-shell :: stdout-encoding.txt\n-# CHECK: *** TEST 'shtest-shell :: stdout-encoding.txt' FAILED ***\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: {{^.f.o.o.$}}\n-# CHECK-NEXT: {{^.b.a.r.}}\n-# CHECK-NEXT: {{^.b.a.z.$}}\n-# CHECK-NOT: error\n-# CHECK: $ \"false\"\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: stdout-encoding.txt\n+#      CHECK: *** TEST 'shtest-shell :: stdout-encoding.txt' FAILED ***\n+#      CHECK: cat diff-in.bin\n+#      CHECK: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+#  CHECK-NOT: error\n+#      CHECK: false\n+#      CHECK: ***\n \n # CHECK: PASS: shtest-shell :: valid-shell.txt\n-# CHECK: Failed Tests (35)\n+# CHECK: Failed Tests (39)\n", "message": "", "files": {"/libcxx/utils/libcxx/test/dsl.py": {"changes": [{"diff": "\n                 \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n             )\n \n-        return libcxx.test.format._parseLitOutput(out)\n+        return out\n \n \n @_memoizeExpensiveOperation(", "add": 1, "remove": 1, "filename": "/libcxx/utils/libcxx/test/dsl.py", "badparts": ["        return libcxx.test.format._parseLitOutput(out)"], "goodparts": ["        return out"]}]}, "/libcxx/utils/libcxx/test/format.py": {"changes": [{"diff": "\n     for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n         assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n \n-def _parseLitOutput(fullOutput):\n-    \"\"\"\n-    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n-\n-    This takes output of the form\n-\n-        $ \":\" \"RUN: at line 11\"\n-        $ \"echo\" \"OUTPUT1\"\n-        # command output:\n-        OUTPUT1\n-\n-        $ \":\" \"RUN: at line 12\"\n-        $ \"echo\" \"OUTPUT2\"\n-        # command output:\n-        OUTPUT2\n-\n-    and returns a string containing\n-\n-        OUTPUT1\n-        OUTPUT2\n-\n-    as-if the commands had been run directly. This is a workaround for the fact\n-    that Lit doesn't let us execute ShTest and retrieve the raw output without\n-    injecting additional Lit output around it.\n-    \"\"\"\n-    parsed = ''\n-    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n-        if output: # skip blank lines\n-            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n-            if commandOutput:\n-                parsed += commandOutput.group(1)\n-    return parsed\n-\n def _executeScriptInternal(test, litConfig, commands):\n     \"\"\"\n     Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n", "add": 0, "remove": 33, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["def _parseLitOutput(fullOutput):", "    \"\"\"", "    Parse output of a Lit ShTest to extract the actual output of the contained commands.", "    This takes output of the form", "        $ \":\" \"RUN: at line 11\"", "        $ \"echo\" \"OUTPUT1\"", "        OUTPUT1", "        $ \":\" \"RUN: at line 12\"", "        $ \"echo\" \"OUTPUT2\"", "        OUTPUT2", "    and returns a string containing", "        OUTPUT1", "        OUTPUT2", "    as-if the commands had been run directly. This is a workaround for the fact", "    that Lit doesn't let us execute ShTest and retrieve the raw output without", "    injecting additional Lit output around it.", "    \"\"\"", "    parsed = ''", "    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):", "        if output: # skip blank lines", "            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)", "            if commandOutput:", "                parsed += commandOutput.group(1)", "    return parsed"], "goodparts": []}, {"diff": "\n     _, tmpBase = _getTempPaths(test)\n     execDir = os.path.dirname(test.getExecPath())\n     res = lit.TestRunner.executeScriptInternal(\n-        test, litConfig, tmpBase, parsedCommands, execDir\n+        test, litConfig, tmpBase, parsedCommands, execDir, debug=False\n     )\n     if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n         res = (\"\", res.output, 127, None)\n     (out, err, exitCode, timeoutInfo) = res\n \n-    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n-    #       split any stderr output that is included in stdout. It shouldn't be there, but\n-    #       the Lit internal shell conflates stderr and stdout.\n-    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n-    if conflatedErrorOutput:\n-        conflatedErrorOutput = conflatedErrorOutput.group(0)\n-        out = out[: -len(conflatedErrorOutput)]\n-        err += conflatedErrorOutput\n-\n     return (out, err, exitCode, timeoutInfo, parsedCommands)\n \n \n", "add": 1, "remove": 10, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["        test, litConfig, tmpBase, parsedCommands, execDir", "    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)", "    if conflatedErrorOutput:", "        conflatedErrorOutput = conflatedErrorOutput.group(0)", "        out = out[: -len(conflatedErrorOutput)]", "        err += conflatedErrorOutput"], "goodparts": ["        test, litConfig, tmpBase, parsedCommands, execDir, debug=False"]}, {"diff": "\n             raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n \n         # Split the generated output into multiple files and generate one test for each file\n-        parsed = _parseLitOutput(out)\n-        for (subfile, content) in self._splitFile(parsed):\n-            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n+        for subfile, content in self._splitFile(out):\n+            generatedFile = testSuite.getExecPath(pathInSuite + (subfile,))\n             os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n             with open(generatedFile, 'w') as f:\n                 f.write(content", "add": 2, "remove": 3, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["        parsed = _parseLitOutput(out)", "        for (subfile, content) in self._splitFile(parsed):", "            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))"], "goodparts": ["        for subfile, content in self._splitFile(out):", "            generatedFile = testSuite.getExecPath(pathInSuite + (subfile,))"]}], "source": "\n import contextlib import io import lit import lit.formats import os import pipes import re import shutil def _getTempPaths(test): \"\"\" Return the values to use for the %T and %t substitutions, respectively. The difference between this and Lit's default behavior is that we guarantee that %T is a path unique to the test being run. \"\"\" tmpDir, _=lit.TestRunner.getTempPaths(test) _, testName=os.path.split(test.getExecPath()) tmpDir=os.path.join(tmpDir, testName +\".dir\") tmpBase=os.path.join(tmpDir, \"t\") return tmpDir, tmpBase def _checkBaseSubstitutions(substitutions): substitutions=[s for(s, _) in substitutions] for s in[\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]: assert s in substitutions, \"Required substitution{} was not provided\".format(s) def _parseLitOutput(fullOutput): \"\"\" Parse output of a Lit ShTest to extract the actual output of the contained commands. This takes output of the form $ \":\" \"RUN: at line 11\" $ \"echo\" \"OUTPUT1\" OUTPUT1 $ \":\" \"RUN: at line 12\" $ \"echo\" \"OUTPUT2\" OUTPUT2 and returns a string containing OUTPUT1 OUTPUT2 as-if the commands had been run directly. This is a workaround for the fact that Lit doesn't let us execute ShTest and retrieve the raw output without injecting additional Lit output around it. \"\"\" parsed='' for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput): if output: commandOutput=re.search(\" if commandOutput: parsed +=commandOutput.group(1) return parsed def _executeScriptInternal(test, litConfig, commands): \"\"\" Returns(stdout, stderr, exitCode, timeoutInfo, parsedCommands) TODO: This really should be easier to access from Lit itself \"\"\" parsedCommands=parseScript(test, preamble=commands) _, tmpBase=_getTempPaths(test) execDir=os.path.dirname(test.getExecPath()) res=lit.TestRunner.executeScriptInternal( test, litConfig, tmpBase, parsedCommands, execDir ) if isinstance(res, lit.Test.Result): res=(\"\", res.output, 127, None) (out, err, exitCode, timeoutInfo)=res conflatedErrorOutput=re.search(\"( if conflatedErrorOutput: conflatedErrorOutput=conflatedErrorOutput.group(0) out=out[: -len(conflatedErrorOutput)] err +=conflatedErrorOutput return(out, err, exitCode, timeoutInfo, parsedCommands) def parseScript(test, preamble): \"\"\" Extract the script from a test, with substitutions applied. Returns a list of commands ready to be executed. -test The lit.Test to parse. -preamble A list of commands to perform before any command in the test. These commands can contain unexpanded substitutions, but they must not be of the form 'RUN:' --they must be proper commands once substituted. \"\"\" tmpDir, tmpBase=_getTempPaths(test) substitutions=lit.TestRunner.getDefaultSubstitutions(test, tmpDir, tmpBase) _checkBaseSubstitutions(substitutions) substitutions.append( (\"%{build}\", \"%{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\") ) substitutions.append((\"%{run}\", \"%{exec} %t.exe\")) additionalCompileFlags=[] fileDependencies=[] parsers=[ lit.TestRunner.IntegratedTestKeywordParser( \"FILE_DEPENDENCIES:\", lit.TestRunner.ParserKind.LIST, initial_value=fileDependencies, ), lit.TestRunner.IntegratedTestKeywordParser( \"ADDITIONAL_COMPILE_FLAGS:\", lit.TestRunner.ParserKind.LIST, initial_value=additionalCompileFlags, ), ] for feature in test.config.available_features: parser=lit.TestRunner.IntegratedTestKeywordParser( \"ADDITIONAL_COMPILE_FLAGS({}):\".format(feature), lit.TestRunner.ParserKind.LIST, initial_value=additionalCompileFlags, ) parsers.append(parser) scriptInTest=lit.TestRunner.parseIntegratedTestScript( test, additional_parsers=parsers, require_script=not preamble ) if isinstance(scriptInTest, lit.Test.Result): return scriptInTest script=[] for dep in fileDependencies: script +=[\"%dbg(SETUP) cd %S && cp{} %T\".format(dep)] script +=preamble script +=scriptInTest substitutions=[ (s, x +\" \" +\" \".join(additionalCompileFlags)) if s==\"%{compile_flags}\" else(s, x) for(s, x) in substitutions ] script=lit.TestRunner.applySubstitutions( script, substitutions, recursion_limit=test.config.recursiveExpansionLimit ) return script class CxxStandardLibraryTest(lit.formats.FileBasedTest): \"\"\" Lit test format for the C++Standard Library conformance test suite. This test format is based on top of the ShTest format --it basically creates a shell script performing the right operations(compile/link/run) based on the extension of the test file it encounters. It supports files with the following extensions: FOO.pass.cpp -Compiles, links and runs successfully FOO.pass.mm -Same as.pass.cpp, but for Objective-C++ FOO.compile.pass.cpp -Compiles successfully, link and run not attempted FOO.compile.pass.mm -Same as.compile.pass.cpp, but for Objective-C++ FOO.compile.fail.cpp -Does not compile successfully FOO.link.pass.cpp -Compiles and links successfully, run not attempted FOO.link.pass.mm -Same as.link.pass.cpp, but for Objective-C++ FOO.link.fail.cpp -Compiles successfully, but fails to link FOO.sh.<anything> -A builtin Lit Shell test FOO.gen.<anything> -A.sh test that generates one or more Lit tests on the fly. Executing this test must generate one or more files as expected by LLVM split-file, and each generated file leads to a separate Lit test that runs that file as defined by the test format. This can be used to generate multiple Lit tests from a single source file, which is useful for testing repetitive properties in the library. Be careful not to abuse this since this is not a replacement for usual code reuse techniques. FOO.verify.cpp -Compiles with clang-verify. This type of test is automatically marked as UNSUPPORTED if the compiler does not support Clang-verify. Substitution requirements =============================== The test format operates by assuming that each test's configuration provides the following substitutions, which it will reuse in the shell scripts it constructs: %{cxx} -A command that can be used to invoke the compiler %{compile_flags} -Flags to use when compiling a test case %{link_flags} -Flags to use when linking a test case %{flags} -Flags to use either when compiling or linking a test case %{exec} -A command to prefix the execution of executables Note that when building an executable(as opposed to only compiling a source file), all three of %{flags}, %{compile_flags} and %{link_flags} will be used in the same command line. In other words, the test format doesn't perform separate compilation and linking steps in this case. Additional supported directives =============================== In addition to everything that's supported in Lit ShTests, this test format also understands the following directives inside test files: // FILE_DEPENDENCIES: file, directory, /path/to/file This directive expresses that the test requires the provided files or directories in order to run. An example is a test that requires some test input stored in a data file. When a test file contains such a directive, this test format will collect them and copy them to the directory represented by %T. The intent is that %T contains all the inputs necessary to run the test, such that e.g. execution on a remote host can be done by simply copying %T to the host. // ADDITIONAL_COMPILE_FLAGS: flag1, flag2, flag3 This directive will cause the provided flags to be added to the %{compile_flags} substitution for the test that contains it. This allows adding special compilation flags without having to use a .sh.cpp test, which would be more powerful but perhaps overkill. Additional provided substitutions and features ============================================== The test format will define the following substitutions for use inside tests: %{build} Expands to a command-line that builds the current source file with the %{flags}, %{compile_flags} and %{link_flags} substitutions, and that produces an executable named %t.exe. %{run} Equivalent to `%{exec} %t.exe`. This is intended to be used in conjunction with the %{build} substitution. \"\"\" def getTestsForPath(self, testSuite, pathInSuite, litConfig, localConfig): SUPPORTED_SUFFIXES=[ \"[.]pass[.]cpp$\", \"[.]pass[.]mm$\", \"[.]compile[.]pass[.]cpp$\", \"[.]compile[.]pass[.]mm$\", \"[.]compile[.]fail[.]cpp$\", \"[.]link[.]pass[.]cpp$\", \"[.]link[.]pass[.]mm$\", \"[.]link[.]fail[.]cpp$\", \"[.]sh[.][^.]+$\", \"[.]gen[.][^.]+$\", \"[.]verify[.]cpp$\", \"[.]fail[.]cpp$\", ] sourcePath=testSuite.getSourcePath(pathInSuite) filename=os.path.basename(sourcePath) hasSupportedSuffix=lambda f: any([re.search(ext, f) for ext in SUPPORTED_SUFFIXES]) if filename.startswith(\".\") or filename in localConfig.excludes or not hasSupportedSuffix(filename): return if re.search('[.]gen[.][^.]+$', filename): for test in self._generateGenTest(testSuite, pathInSuite, litConfig, localConfig): yield test else: yield lit.Test.Test(testSuite, pathInSuite, localConfig) def execute(self, test, litConfig): VERIFY_FLAGS=( \"-Xclang -verify -Xclang -verify-ignore-unexpected=note -ferror-limit=0\" ) supportsVerify=\"verify-support\" in test.config.available_features filename=test.path_in_suite[-1] if re.search(\"[.]sh[.][^.]+$\", filename): steps=[] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".compile.pass.cpp\") or filename.endswith( \".compile.pass.mm\" ): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".compile.fail.cpp\"): steps=[ \"%dbg(COMPILED WITH) ! %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".link.pass.cpp\") or filename.endswith(\".link.pass.mm\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".link.fail.cpp\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -c -o %t.o\", \"%dbg(LINKED WITH) ! %{cxx} %t.o %{flags} %{link_flags} -o %t.exe\", ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".verify.cpp\"): if not supportsVerify: return lit.Test.Result( lit.Test.UNSUPPORTED, \"Test{} requires support for Clang-verify, which isn't supported by the compiler\".format( test.getFullName() ), ) steps=[ \"%dbg(COMPILED WITH) %{{cxx}} %s %{{flags}} %{{compile_flags}} -fsyntax-only -Wno-error{}\".format( VERIFY_FLAGS ) ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".pass.cpp\") or filename.endswith(\".pass.mm\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\", \"%dbg(EXECUTED AS) %{exec} %t.exe\", ] return self._executeShTest(test, litConfig, steps) else: return lit.Test.Result( lit.Test.UNRESOLVED, \"Unknown test suffix for '{}'\".format(filename) ) def _executeShTest(self, test, litConfig, steps): if test.config.unsupported: return lit.Test.Result(lit.Test.UNSUPPORTED, \"Test is unsupported\") script=parseScript(test, steps) if isinstance(script, lit.Test.Result): return script if litConfig.noExecute: return lit.Test.Result( lit.Test.XFAIL if test.isExpectedToFail() else lit.Test.PASS ) else: _, tmpBase=_getTempPaths(test) useExternalSh=False return lit.TestRunner._runShTest( test, litConfig, useExternalSh, script, tmpBase ) def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig): generator=lit.Test.Test(testSuite, pathInSuite, localConfig) generatorExecDir=os.path.dirname(testSuite.getExecPath(pathInSuite)) os.makedirs(generatorExecDir, exist_ok=True) steps=[] (out, err, exitCode, _, _)=_executeScriptInternal(generator, litConfig, steps) if exitCode !=0: raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\") parsed=_parseLitOutput(out) for(subfile, content) in self._splitFile(parsed): generatedFile=testSuite.getExecPath(pathInSuite +(subfile,)) os.makedirs(os.path.dirname(generatedFile), exist_ok=True) with open(generatedFile, 'w') as f: f.write(content) yield lit.Test.Test(testSuite,(generatedFile,), localConfig) def _splitFile(self, input): DELIM=r'^(//| lines=input.splitlines() currentFile=None thisFileContent=[] for line in lines: match=re.match(DELIM, line) if match: if currentFile is not None: yield(currentFile, '\\n'.join(thisFileContent)) currentFile=match.group(2).strip() thisFileContent=[] assert currentFile is not None, f\"Some input to split-file doesn't belong to any file, input was:\\n{input}\" thisFileContent.append(line) if currentFile is not None: yield(currentFile, '\\n'.join(thisFileContent)) ", "sourceWithComments": "# ===----------------------------------------------------------------------===##\n#\n# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n# See https://llvm.org/LICENSE.txt for license information.\n# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n#\n# ===----------------------------------------------------------------------===##\n\nimport contextlib\nimport io\nimport lit\nimport lit.formats\nimport os\nimport pipes\nimport re\nimport shutil\n\n\ndef _getTempPaths(test):\n    \"\"\"\n    Return the values to use for the %T and %t substitutions, respectively.\n\n    The difference between this and Lit's default behavior is that we guarantee\n    that %T is a path unique to the test being run.\n    \"\"\"\n    tmpDir, _ = lit.TestRunner.getTempPaths(test)\n    _, testName = os.path.split(test.getExecPath())\n    tmpDir = os.path.join(tmpDir, testName + \".dir\")\n    tmpBase = os.path.join(tmpDir, \"t\")\n    return tmpDir, tmpBase\n\n\ndef _checkBaseSubstitutions(substitutions):\n    substitutions = [s for (s, _) in substitutions]\n    for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n        assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n\ndef _parseLitOutput(fullOutput):\n    \"\"\"\n    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n\n    This takes output of the form\n\n        $ \":\" \"RUN: at line 11\"\n        $ \"echo\" \"OUTPUT1\"\n        # command output:\n        OUTPUT1\n\n        $ \":\" \"RUN: at line 12\"\n        $ \"echo\" \"OUTPUT2\"\n        # command output:\n        OUTPUT2\n\n    and returns a string containing\n\n        OUTPUT1\n        OUTPUT2\n\n    as-if the commands had been run directly. This is a workaround for the fact\n    that Lit doesn't let us execute ShTest and retrieve the raw output without\n    injecting additional Lit output around it.\n    \"\"\"\n    parsed = ''\n    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n        if output: # skip blank lines\n            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n            if commandOutput:\n                parsed += commandOutput.group(1)\n    return parsed\n\ndef _executeScriptInternal(test, litConfig, commands):\n    \"\"\"\n    Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n\n    TODO: This really should be easier to access from Lit itself\n    \"\"\"\n    parsedCommands = parseScript(test, preamble=commands)\n\n    _, tmpBase = _getTempPaths(test)\n    execDir = os.path.dirname(test.getExecPath())\n    res = lit.TestRunner.executeScriptInternal(\n        test, litConfig, tmpBase, parsedCommands, execDir\n    )\n    if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n        res = (\"\", res.output, 127, None)\n    (out, err, exitCode, timeoutInfo) = res\n\n    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n    #       split any stderr output that is included in stdout. It shouldn't be there, but\n    #       the Lit internal shell conflates stderr and stdout.\n    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n    if conflatedErrorOutput:\n        conflatedErrorOutput = conflatedErrorOutput.group(0)\n        out = out[: -len(conflatedErrorOutput)]\n        err += conflatedErrorOutput\n\n    return (out, err, exitCode, timeoutInfo, parsedCommands)\n\n\ndef parseScript(test, preamble):\n    \"\"\"\n    Extract the script from a test, with substitutions applied.\n\n    Returns a list of commands ready to be executed.\n\n    - test\n        The lit.Test to parse.\n\n    - preamble\n        A list of commands to perform before any command in the test.\n        These commands can contain unexpanded substitutions, but they\n        must not be of the form 'RUN:' -- they must be proper commands\n        once substituted.\n    \"\"\"\n    # Get the default substitutions\n    tmpDir, tmpBase = _getTempPaths(test)\n    substitutions = lit.TestRunner.getDefaultSubstitutions(test, tmpDir, tmpBase)\n\n    # Check base substitutions and add the %{build} and %{run} convenience substitutions\n    _checkBaseSubstitutions(substitutions)\n    substitutions.append(\n        (\"%{build}\", \"%{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\")\n    )\n    substitutions.append((\"%{run}\", \"%{exec} %t.exe\"))\n\n    # Parse the test file, including custom directives\n    additionalCompileFlags = []\n    fileDependencies = []\n    parsers = [\n        lit.TestRunner.IntegratedTestKeywordParser(\n            \"FILE_DEPENDENCIES:\",\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=fileDependencies,\n        ),\n        lit.TestRunner.IntegratedTestKeywordParser(\n            \"ADDITIONAL_COMPILE_FLAGS:\",\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=additionalCompileFlags,\n        ),\n    ]\n\n    # Add conditional parsers for ADDITIONAL_COMPILE_FLAGS. This should be replaced by first\n    # class support for conditional keywords in Lit, which would allow evaluating arbitrary\n    # Lit boolean expressions instead.\n    for feature in test.config.available_features:\n        parser = lit.TestRunner.IntegratedTestKeywordParser(\n            \"ADDITIONAL_COMPILE_FLAGS({}):\".format(feature),\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=additionalCompileFlags,\n        )\n        parsers.append(parser)\n\n    scriptInTest = lit.TestRunner.parseIntegratedTestScript(\n        test, additional_parsers=parsers, require_script=not preamble\n    )\n    if isinstance(scriptInTest, lit.Test.Result):\n        return scriptInTest\n\n    script = []\n\n    # For each file dependency in FILE_DEPENDENCIES, inject a command to copy\n    # that file to the execution directory. Execute the copy from %S to allow\n    # relative paths from the test directory.\n    for dep in fileDependencies:\n        script += [\"%dbg(SETUP) cd %S && cp {} %T\".format(dep)]\n    script += preamble\n    script += scriptInTest\n\n    # Add compile flags specified with ADDITIONAL_COMPILE_FLAGS.\n    substitutions = [\n        (s, x + \" \" + \" \".join(additionalCompileFlags))\n        if s == \"%{compile_flags}\"\n        else (s, x)\n        for (s, x) in substitutions\n    ]\n\n    # Perform substitutions in the script itself.\n    script = lit.TestRunner.applySubstitutions(\n        script, substitutions, recursion_limit=test.config.recursiveExpansionLimit\n    )\n\n    return script\n\n\nclass CxxStandardLibraryTest(lit.formats.FileBasedTest):\n    \"\"\"\n    Lit test format for the C++ Standard Library conformance test suite.\n\n    This test format is based on top of the ShTest format -- it basically\n    creates a shell script performing the right operations (compile/link/run)\n    based on the extension of the test file it encounters. It supports files\n    with the following extensions:\n\n    FOO.pass.cpp            - Compiles, links and runs successfully\n    FOO.pass.mm             - Same as .pass.cpp, but for Objective-C++\n\n    FOO.compile.pass.cpp    - Compiles successfully, link and run not attempted\n    FOO.compile.pass.mm     - Same as .compile.pass.cpp, but for Objective-C++\n    FOO.compile.fail.cpp    - Does not compile successfully\n\n    FOO.link.pass.cpp       - Compiles and links successfully, run not attempted\n    FOO.link.pass.mm        - Same as .link.pass.cpp, but for Objective-C++\n    FOO.link.fail.cpp       - Compiles successfully, but fails to link\n\n    FOO.sh.<anything>       - A builtin Lit Shell test\n\n    FOO.gen.<anything>      - A .sh test that generates one or more Lit tests on the\n                              fly. Executing this test must generate one or more files\n                              as expected by LLVM split-file, and each generated file\n                              leads to a separate Lit test that runs that file as\n                              defined by the test format. This can be used to generate\n                              multiple Lit tests from a single source file, which is\n                              useful for testing repetitive properties in the library.\n                              Be careful not to abuse this since this is not a replacement\n                              for usual code reuse techniques.\n\n    FOO.verify.cpp          - Compiles with clang-verify. This type of test is\n                              automatically marked as UNSUPPORTED if the compiler\n                              does not support Clang-verify.\n\n\n    Substitution requirements\n    ===============================\n    The test format operates by assuming that each test's configuration provides\n    the following substitutions, which it will reuse in the shell scripts it\n    constructs:\n        %{cxx}           - A command that can be used to invoke the compiler\n        %{compile_flags} - Flags to use when compiling a test case\n        %{link_flags}    - Flags to use when linking a test case\n        %{flags}         - Flags to use either when compiling or linking a test case\n        %{exec}          - A command to prefix the execution of executables\n\n    Note that when building an executable (as opposed to only compiling a source\n    file), all three of %{flags}, %{compile_flags} and %{link_flags} will be used\n    in the same command line. In other words, the test format doesn't perform\n    separate compilation and linking steps in this case.\n\n\n    Additional supported directives\n    ===============================\n    In addition to everything that's supported in Lit ShTests, this test format\n    also understands the following directives inside test files:\n\n        // FILE_DEPENDENCIES: file, directory, /path/to/file\n\n            This directive expresses that the test requires the provided files\n            or directories in order to run. An example is a test that requires\n            some test input stored in a data file. When a test file contains\n            such a directive, this test format will collect them and copy them\n            to the directory represented by %T. The intent is that %T contains\n            all the inputs necessary to run the test, such that e.g. execution\n            on a remote host can be done by simply copying %T to the host.\n\n        // ADDITIONAL_COMPILE_FLAGS: flag1, flag2, flag3\n\n            This directive will cause the provided flags to be added to the\n            %{compile_flags} substitution for the test that contains it. This\n            allows adding special compilation flags without having to use a\n            .sh.cpp test, which would be more powerful but perhaps overkill.\n\n\n    Additional provided substitutions and features\n    ==============================================\n    The test format will define the following substitutions for use inside tests:\n\n        %{build}\n            Expands to a command-line that builds the current source\n            file with the %{flags}, %{compile_flags} and %{link_flags}\n            substitutions, and that produces an executable named %t.exe.\n\n        %{run}\n            Equivalent to `%{exec} %t.exe`. This is intended to be used\n            in conjunction with the %{build} substitution.\n    \"\"\"\n\n    def getTestsForPath(self, testSuite, pathInSuite, litConfig, localConfig):\n        SUPPORTED_SUFFIXES = [\n            \"[.]pass[.]cpp$\",\n            \"[.]pass[.]mm$\",\n            \"[.]compile[.]pass[.]cpp$\",\n            \"[.]compile[.]pass[.]mm$\",\n            \"[.]compile[.]fail[.]cpp$\",\n            \"[.]link[.]pass[.]cpp$\",\n            \"[.]link[.]pass[.]mm$\",\n            \"[.]link[.]fail[.]cpp$\",\n            \"[.]sh[.][^.]+$\",\n            \"[.]gen[.][^.]+$\",\n            \"[.]verify[.]cpp$\",\n            \"[.]fail[.]cpp$\",\n        ]\n\n        sourcePath = testSuite.getSourcePath(pathInSuite)\n        filename = os.path.basename(sourcePath)\n\n        # Ignore dot files, excluded tests and tests with an unsupported suffix\n        hasSupportedSuffix = lambda f: any([re.search(ext, f) for ext in SUPPORTED_SUFFIXES])\n        if filename.startswith(\".\") or filename in localConfig.excludes or not hasSupportedSuffix(filename):\n            return\n\n        # If this is a generated test, run the generation step and add\n        # as many Lit tests as necessary.\n        if re.search('[.]gen[.][^.]+$', filename):\n            for test in self._generateGenTest(testSuite, pathInSuite, litConfig, localConfig):\n                yield test\n        else:\n            yield lit.Test.Test(testSuite, pathInSuite, localConfig)\n\n    def execute(self, test, litConfig):\n        VERIFY_FLAGS = (\n            \"-Xclang -verify -Xclang -verify-ignore-unexpected=note -ferror-limit=0\"\n        )\n        supportsVerify = \"verify-support\" in test.config.available_features\n        filename = test.path_in_suite[-1]\n\n        if re.search(\"[.]sh[.][^.]+$\", filename):\n            steps = []  # The steps are already in the script\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".compile.pass.cpp\") or filename.endswith(\n            \".compile.pass.mm\"\n        ):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".compile.fail.cpp\"):\n            steps = [\n                \"%dbg(COMPILED WITH) ! %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".link.pass.cpp\") or filename.endswith(\".link.pass.mm\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".link.fail.cpp\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -c -o %t.o\",\n                \"%dbg(LINKED WITH) ! %{cxx} %t.o %{flags} %{link_flags} -o %t.exe\",\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".verify.cpp\"):\n            if not supportsVerify:\n                return lit.Test.Result(\n                    lit.Test.UNSUPPORTED,\n                    \"Test {} requires support for Clang-verify, which isn't supported by the compiler\".format(\n                        test.getFullName()\n                    ),\n                )\n            steps = [\n                # Note: Use -Wno-error to make sure all diagnostics are not treated as errors,\n                #       which doesn't make sense for clang-verify tests.\n                \"%dbg(COMPILED WITH) %{{cxx}} %s %{{flags}} %{{compile_flags}} -fsyntax-only -Wno-error {}\".format(\n                    VERIFY_FLAGS\n                )\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        # Make sure to check these ones last, since they will match other\n        # suffixes above too.\n        elif filename.endswith(\".pass.cpp\") or filename.endswith(\".pass.mm\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\",\n                \"%dbg(EXECUTED AS) %{exec} %t.exe\",\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        else:\n            return lit.Test.Result(\n                lit.Test.UNRESOLVED, \"Unknown test suffix for '{}'\".format(filename)\n            )\n\n    def _executeShTest(self, test, litConfig, steps):\n        if test.config.unsupported:\n            return lit.Test.Result(lit.Test.UNSUPPORTED, \"Test is unsupported\")\n\n        script = parseScript(test, steps)\n        if isinstance(script, lit.Test.Result):\n            return script\n\n        if litConfig.noExecute:\n            return lit.Test.Result(\n                lit.Test.XFAIL if test.isExpectedToFail() else lit.Test.PASS\n            )\n        else:\n            _, tmpBase = _getTempPaths(test)\n            useExternalSh = False\n            return lit.TestRunner._runShTest(\n                test, litConfig, useExternalSh, script, tmpBase\n            )\n\n    def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig):\n        generator = lit.Test.Test(testSuite, pathInSuite, localConfig)\n\n        # Make sure we have a directory to execute the generator test in\n        generatorExecDir = os.path.dirname(testSuite.getExecPath(pathInSuite))\n        os.makedirs(generatorExecDir, exist_ok=True)\n\n        # Run the generator test\n        steps = [] # Steps must already be in the script\n        (out, err, exitCode, _, _) = _executeScriptInternal(generator, litConfig, steps)\n        if exitCode != 0:\n            raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n\n        # Split the generated output into multiple files and generate one test for each file\n        parsed = _parseLitOutput(out)\n        for (subfile, content) in self._splitFile(parsed):\n            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n            os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n            with open(generatedFile, 'w') as f:\n                f.write(content)\n            yield lit.Test.Test(testSuite, (generatedFile,), localConfig)\n\n    def _splitFile(self, input):\n        DELIM = r'^(//|#)---(.+)'\n        lines = input.splitlines()\n        currentFile = None\n        thisFileContent = []\n        for line in lines:\n            match = re.match(DELIM, line)\n            if match:\n                if currentFile is not None:\n                    yield (currentFile, '\\n'.join(thisFileContent))\n                currentFile = match.group(2).strip()\n                thisFileContent = []\n            assert currentFile is not None, f\"Some input to split-file doesn't belong to any file, input was:\\n{input}\"\n            thisFileContent.append(line)\n        if currentFile is not None:\n            yield (currentFile, '\\n'.join(thisFileContent))\n"}}, "msg": "[lit] Improve test output from lit's internal shell\n\nThis patch and D154984 were discussed in\n<https://discourse.llvm.org/t/rfc-improving-lits-debug-output/72839>.\n\nMotivation\n----------\n\nD154984 removes the \"Script:\" section that lit prints along with a\ntest's output, and it makes -v and -a imply -vv.  For example, after\nD154984, the \"Script:\" section below is never shown, but -v is enough\nto produce the execution trace following it:\n\n```\n Script:\n --\n : 'RUN: at line 1'; echo hello | FileCheck bogus.txt && echo success\n --\n Exit Code: 2\n\n Command Output (stdout):\n --\n $ \":\" \"RUN: at line 1\"\n $ \"echo\" \"hello\"\n # command output:\n hello\n\n $ \"FileCheck\" \"bogus.txt\"\n # command stderr:\n Could not open check file 'bogus.txt': No such file or directory\n\n error: command failed with exit status: 2\n\n --\n```\n\nIn the D154984 review, some reviewers point out that they have been\nusing the \"Script:\" section for copying and pasting a test's shell\ncommands to a terminal window.  The shell commands as printed in the\nexecution trace can be harder to copy and paste for the following\nreasons:\n\n- They drop redirections and break apart RUN lines at `&&`, `|`, etc.\n- They add `$` at the start of every command, which makes it hard to\n  copy and paste multiple commands in bulk.\n- Command stdout, stderr, etc. are interleaved with the commands and\n  are not clearly delineated.\n- They don't always use proper shell quoting.  Instead, they blindly\n  enclose all command-line arguments in double quotes.\n\nChanges\n-------\n\nD154984 plus this patch converts the above example into:\n\n```\n Exit Code: 2\n\n Command Output (stdout):\n --\n # RUN: at line 1\n echo hello | FileCheck bogus-file.txt && echo success\n # executed command: echo hello\n # .---command stdout------------\n # | hello\n # `-----------------------------\n # executed command: FileCheck bogus-file.txt\n # .---command stderr------------\n # | Could not open check file 'bogus-file.txt': No such file or directory\n # `-----------------------------\n # error: command failed with exit status: 2\n\n --\n```\n\nThus, this patch addresses the above issues as follows:\n\n- The entire execution trace can be copied and pasted in bulk to a\n  terminal for correct execution of the RUN lines, which are printed\n  intact as they appeared in the original RUN lines except lit\n  substitutions are expanded.  Everything else in the execution trace\n  appears in shell comments so it has no effect in a terminal.\n- Each of the RUN line's commands is repeated (in shell comments) as\n  it executes to show (1) that the command actually executed (e.g.,\n  `echo success` above didn't) and (2) what stdout, stderr, non-zero\n  exit status, and output files are associated with the command, if\n  any.  Shell quoting in the command is now correct and minimal but is\n  not necessarily the original shell quoting from the RUN line.\n- The start and end of the contents of stdout, stderr, or an output\n  file is now delineated clearly in the trace.\n\nTo help produce some of the above output, this patch extends lit's\ninternal shell with a built-in `@echo` command.  It's like `echo`\nexcept lit suppresses the normal execution trace for `@echo` and just\nprints its stdout directly.  For now, `@echo` isn't documented for use\nin lit tests.\n\nWithout this patch, libcxx's custom lit test format tries to parse the\nstdout from `lit.TestRunner.executeScriptInternal` (which runs lit's\ninternal shell) to extract the stdout and stderr produced by shell\ncommands, and that parse no longer works after the above changes.\nThis patch makes a small adjustment to\n`lit.TestRunner.executeScriptInternal` so libcxx can just request\nstdout and stderr without an execution trace.\n\n(As a minor drive-by fix that came up in testing: lit's internal `not`\ncommand now always produces a numeric exit status and never `True`.)\n\nCaveat\n------\n\nThis patch only makes the above changes for lit's internal shell.  In\nmost cases, we do not know how to force external shells (e.g., bash,\nsh, window's `cmd`) to produce execution traces in the manner we want.\n\nTo configure a test suite to use lit's internal shell (which is\nusually better for test portability than external shells anyway), add\nthis to the test suite's `lit.cfg` or other configuration file:\n\n```\nconfig.test_format = lit.formats.ShTest(execute_external=False)\n```\n\nReviewed By: MaskRay, awarzynski\n\nDifferential Revision: https://reviews.llvm.org/D156954"}}, "https://github.com/llvm-mos/llvm-mos": {"c981c533055e14302e7bff5d6898c9308065f665": {"url": "https://api.github.com/repos/llvm-mos/llvm-mos/commits/c981c533055e14302e7bff5d6898c9308065f665", "html_url": "https://github.com/llvm-mos/llvm-mos/commit/c981c533055e14302e7bff5d6898c9308065f665", "sha": "c981c533055e14302e7bff5d6898c9308065f665", "keyword": "execution after redirect correct", "diff": "diff --git a/libcxx/utils/libcxx/test/dsl.py b/libcxx/utils/libcxx/test/dsl.py\nindex 847cebf5962f..4c2217ec3142 100644\n--- a/libcxx/utils/libcxx/test/dsl.py\n+++ b/libcxx/utils/libcxx/test/dsl.py\n@@ -180,7 +180,7 @@ def programOutput(config, program, args=None):\n                 \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n             )\n \n-        return libcxx.test.format._parseLitOutput(out)\n+        return out\n \n \n @_memoizeExpensiveOperation(\ndiff --git a/libcxx/utils/libcxx/test/format.py b/libcxx/utils/libcxx/test/format.py\nindex ddd88f25646e..2be42d293280 100644\n--- a/libcxx/utils/libcxx/test/format.py\n+++ b/libcxx/utils/libcxx/test/format.py\n@@ -35,39 +35,6 @@ def _checkBaseSubstitutions(substitutions):\n     for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n         assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n \n-def _parseLitOutput(fullOutput):\n-    \"\"\"\n-    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n-\n-    This takes output of the form\n-\n-        $ \":\" \"RUN: at line 11\"\n-        $ \"echo\" \"OUTPUT1\"\n-        # command output:\n-        OUTPUT1\n-\n-        $ \":\" \"RUN: at line 12\"\n-        $ \"echo\" \"OUTPUT2\"\n-        # command output:\n-        OUTPUT2\n-\n-    and returns a string containing\n-\n-        OUTPUT1\n-        OUTPUT2\n-\n-    as-if the commands had been run directly. This is a workaround for the fact\n-    that Lit doesn't let us execute ShTest and retrieve the raw output without\n-    injecting additional Lit output around it.\n-    \"\"\"\n-    parsed = ''\n-    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n-        if output: # skip blank lines\n-            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n-            if commandOutput:\n-                parsed += commandOutput.group(1)\n-    return parsed\n-\n def _executeScriptInternal(test, litConfig, commands):\n     \"\"\"\n     Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n@@ -79,21 +46,12 @@ def _executeScriptInternal(test, litConfig, commands):\n     _, tmpBase = _getTempPaths(test)\n     execDir = os.path.dirname(test.getExecPath())\n     res = lit.TestRunner.executeScriptInternal(\n-        test, litConfig, tmpBase, parsedCommands, execDir\n+        test, litConfig, tmpBase, parsedCommands, execDir, debug=False\n     )\n     if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n         res = (\"\", res.output, 127, None)\n     (out, err, exitCode, timeoutInfo) = res\n \n-    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n-    #       split any stderr output that is included in stdout. It shouldn't be there, but\n-    #       the Lit internal shell conflates stderr and stdout.\n-    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n-    if conflatedErrorOutput:\n-        conflatedErrorOutput = conflatedErrorOutput.group(0)\n-        out = out[: -len(conflatedErrorOutput)]\n-        err += conflatedErrorOutput\n-\n     return (out, err, exitCode, timeoutInfo, parsedCommands)\n \n \n@@ -400,8 +358,7 @@ def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig):\n             raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n \n         # Split the generated output into multiple files and generate one test for each file\n-        parsed = _parseLitOutput(out)\n-        for (subfile, content) in self._splitFile(parsed):\n+        for (subfile, content) in self._splitFile(out):\n             generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n             os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n             with open(generatedFile, 'w') as f:\ndiff --git a/llvm/utils/lit/lit/TestRunner.py b/llvm/utils/lit/lit/TestRunner.py\nindex 0629eca42049..461cf63d6b96 100644\n--- a/llvm/utils/lit/lit/TestRunner.py\n+++ b/llvm/utils/lit/lit/TestRunner.py\n@@ -8,6 +8,7 @@\n import stat\n import pathlib\n import platform\n+import shlex\n import shutil\n import tempfile\n import threading\n@@ -57,6 +58,14 @@ def __init__(self, command, message):\n kPdbgRegex = \"%dbg\\\\(([^)'\\\"]*)\\\\)(.*)\"\n \n \n+def buildPdbgCommand(msg, cmd):\n+    res = f\"%dbg({msg}) {cmd}\"\n+    assert re.match(\n+        kPdbgRegex, res\n+    ), f\"kPdbgRegex expected to match actual %dbg usage: {res}\"\n+    return res\n+\n+\n class ShellEnvironment(object):\n \n     \"\"\"Mutable shell environment containing things like CWD and env vars.\n@@ -340,12 +349,12 @@ def executeBuiltinExport(cmd, shenv):\n \n \n def executeBuiltinEcho(cmd, shenv):\n-    \"\"\"Interpret a redirected echo command\"\"\"\n+    \"\"\"Interpret a redirected echo or @echo command\"\"\"\n     opened_files = []\n     stdin, stdout, stderr = processRedirects(cmd, subprocess.PIPE, shenv, opened_files)\n     if stdin != subprocess.PIPE or stderr != subprocess.PIPE:\n         raise InternalShellError(\n-            cmd, \"stdin and stderr redirects not supported for echo\"\n+            cmd, f\"stdin and stderr redirects not supported for {cmd.args[0]}\"\n         )\n \n     # Some tests have un-redirected echo commands to help debug test failures.\n@@ -692,6 +701,7 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n         \"cd\": executeBuiltinCd,\n         \"export\": executeBuiltinExport,\n         \"echo\": executeBuiltinEcho,\n+        \"@echo\": executeBuiltinEcho,\n         \"mkdir\": executeBuiltinMkdir,\n         \"popd\": executeBuiltinPopd,\n         \"pushd\": executeBuiltinPushd,\n@@ -919,7 +929,7 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n         if res == -signal.SIGINT:\n             raise KeyboardInterrupt\n         if proc_not_counts[i] % 2:\n-            res = not res\n+            res = 1 if res == 0 else 0\n         elif proc_not_counts[i] > 1:\n             res = 1 if res != 0 else 0\n \n@@ -982,19 +992,58 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n     return exitCode\n \n \n-def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n+def formatOutput(title, data, limit=None):\n+    if not data.strip():\n+        return \"\"\n+    if not limit is None and len(data) > limit:\n+        data = data[:limit] + \"\\n...\\n\"\n+        msg = \"data was truncated\"\n+    else:\n+        msg = \"\"\n+    ndashes = 30\n+    out =  f\"# .---{title}{'-' * (ndashes - 4 - len(title))}\\n\"\n+    out += f\"# | \" + \"\\n# | \".join(data.splitlines()) + \"\\n\"\n+    out += f\"# `---{msg}{'-' * (ndashes - 4 - len(msg))}\\n\"\n+    return out\n+\n+# Normally returns out, err, exitCode, timeoutInfo.\n+#\n+# If debug is True (the normal lit behavior), err is empty, and out contains an\n+# execution trace, including stdout and stderr shown per command executed.\n+#\n+# If debug is False (set by some custom lit test formats that call this\n+# function), out contains only stdout from the script, err contains only stderr\n+# from the script, and there is no execution trace.\n+def executeScriptInternal(test, litConfig, tmpBase, commands, cwd,\n+                          debug=True):\n     cmds = []\n     for i, ln in enumerate(commands):\n+        # Within lit, we try to always add '%dbg(...)' to command lines in order\n+        # to maximize debuggability.  However, custom lit test formats might not\n+        # always add it, so add a generic debug message in that case.\n         match = re.match(kPdbgRegex, ln)\n         if match:\n+            dbg = match.group(1)\n             command = match.group(2)\n-            ln = commands[i] = match.expand(\": '\\\\1'; \\\\2\" if command else \": '\\\\1'\")\n+        else:\n+            dbg = \"command line\"\n+            command = ln\n+        if debug:\n+            ln = f\"@echo '# {dbg}' \"\n+            if command:\n+                ln += f\"&& @echo {shlex.quote(command.lstrip())} && {command}\"\n+            else:\n+                ln += \"has no command after substitutions\"\n+        else:\n+            ln = command\n         try:\n             cmds.append(\n                 ShUtil.ShParser(ln, litConfig.isWindows, test.config.pipefail).parse()\n             )\n         except:\n-            return lit.Test.Result(Test.FAIL, \"shell parser error on: %r\" % ln)\n+            return lit.Test.Result(\n+                Test.FAIL, f\"shell parser error on {dbg}: {command.lstrip()}\\n\"\n+            )\n \n     cmd = cmds[0]\n     for c in cmds[1:]:\n@@ -1014,8 +1063,42 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n \n     out = err = \"\"\n     for i, result in enumerate(results):\n-        # Write the command line run.\n-        out += \"$ %s\\n\" % (\" \".join('\"%s\"' % s for s in result.command.args),)\n+        if not debug:\n+            out += result.stdout\n+            err += result.stderr\n+            continue\n+\n+        # The purpose of an \"@echo\" command is merely to add a debugging message\n+        # directly to lit's output.  It is used internally by lit's internal\n+        # shell and is not currently documented for use in lit tests.  However,\n+        # if someone misuses it (e.g., both \"echo\" and \"@echo\" complain about\n+        # stdin redirection), produce the normal execution trace to facilitate\n+        # debugging.\n+        if (\n+            result.command.args[0] == \"@echo\"\n+            and result.exitCode == 0\n+            and not result.stderr\n+            and not result.outputFiles\n+            and not result.timeoutReached\n+        ):\n+            out += result.stdout\n+            continue\n+\n+        # Write the command line that was run.  Properly quote it.  Leading\n+        # \"!\" commands should not be quoted as that would indicate they are not\n+        # the builtins.\n+        out += \"# executed command: \"\n+        nLeadingBangs = next(\n+            (i for i, cmd in enumerate(result.command.args) if cmd != \"!\"),\n+            len(result.command.args),\n+        )\n+        out += \"! \" * nLeadingBangs\n+        out += \" \".join(\n+            shlex.quote(str(s))\n+            for i, s in enumerate(result.command.args)\n+            if i >= nLeadingBangs\n+        )\n+        out += \"\\n\"\n \n         # If nothing interesting happened, move on.\n         if (\n@@ -1030,22 +1113,16 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n \n         # Add the command output, if redirected.\n         for (name, path, data) in result.outputFiles:\n-            if data.strip():\n-                out += \"# redirected output from %r:\\n\" % (name,)\n-                data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n-                if len(data) > 1024:\n-                    out += data[:1024] + \"\\n...\\n\"\n-                    out += \"note: data was truncated\\n\"\n-                else:\n-                    out += data\n-                out += \"\\n\"\n-\n+            data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n+            out += formatOutput(\n+                f\"redirected output from '{name}'\", data, limit=1024\n+            )\n         if result.stdout.strip():\n-            out += \"# command output:\\n%s\\n\" % (result.stdout,)\n+            out += formatOutput(\"command stdout\", result.stdout)\n         if result.stderr.strip():\n-            out += \"# command stderr:\\n%s\\n\" % (result.stderr,)\n+            out += formatOutput(\"command stderr\", result.stderr)\n         if not result.stdout.strip() and not result.stderr.strip():\n-            out += \"note: command had no output on stdout or stderr\\n\"\n+            out += \"# note: command had no output on stdout or stderr\\n\"\n \n         # Show the error conditions:\n         if result.exitCode != 0:\n@@ -1055,9 +1132,9 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n                 codeStr = hex(int(result.exitCode & 0xFFFFFFFF)).rstrip(\"L\")\n             else:\n                 codeStr = str(result.exitCode)\n-            out += \"error: command failed with exit status: %s\\n\" % (codeStr,)\n+            out += \"# error: command failed with exit status: %s\\n\" % (codeStr,)\n         if litConfig.maxIndividualTestTime > 0 and result.timeoutReached:\n-            out += \"error: command reached timeout: %s\\n\" % (\n+            out += \"# error: command reached timeout: %s\\n\" % (\n                 str(result.timeoutReached),\n             )\n \n@@ -1833,13 +1910,7 @@ def _handleCommand(cls, line_number, line, output, keyword):\n         if not output or not output[-1].add_continuation(line_number, keyword, line):\n             if output is None:\n                 output = []\n-            pdbg = \"%dbg({keyword} at line {line_number})\".format(\n-                keyword=keyword, line_number=line_number\n-            )\n-            assert re.match(\n-                kPdbgRegex + \"$\", pdbg\n-            ), \"kPdbgRegex expected to match actual %dbg usage\"\n-            line = \"{pdbg} {real_command}\".format(pdbg=pdbg, real_command=line)\n+            line = buildPdbgCommand(f\"{keyword} at line {line_number}\", line)\n             output.append(CommandDirective(line_number, line_number, keyword, line))\n         return output\n \n@@ -2104,6 +2175,8 @@ def executeShTest(\n         return lit.Test.Result(Test.UNSUPPORTED, \"Test is unsupported\")\n \n     script = list(preamble_commands)\n+    script = [buildPdbgCommand(f\"preamble command line\", ln) for ln in script]\n+\n     parsed = parseIntegratedTestScript(test, require_script=not script)\n     if isinstance(parsed, lit.Test.Result):\n         return parsed\ndiff --git a/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg b/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\nindex cf1a4f1ba1ec..301208c25bdc 100644\n--- a/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\n+++ b/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\n@@ -5,4 +5,4 @@ config.suffixes = [\".txt\"]\n config.test_format = lit.formats.ShTest()\n config.test_source_root = None\n config.test_exec_root = None\n-config.substitutions.append((\"%var\", lit_config.params.get(\"var\", \"\")))\n+config.substitutions.append((\"%var\", lit_config.params.get(\"var\", \"default\")))\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt b/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\nindex 6dd9b16304e0..1d94c1213723 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\n@@ -14,21 +14,21 @@\n ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0 -fopenmp-simd\n ; REDEFINE: %{fcflags} = -check-prefix=SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu -fopenmp-simd\n ; REDEFINE: %{fcflags} = -check-prefix=SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0\n ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu\n ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n \n ; CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt b/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\nindex 3bf057151afb..23c0a6d50753 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\n@@ -7,7 +7,7 @@\n #\n # REDEFINE: %{global:greeting}=Hello\n # RUN: %{global:echo}\n-# CHECK: GLOBAL: Hello World\n+# CHECK:# | GLOBAL: Hello World\n \n # We can redefine the test suite config's substitutions multiple times.  Again,\n # the expansion order remains the same (%{global:echo} before %{global:greeting}\n@@ -17,7 +17,7 @@\n # REDEFINE: %{global:greeting}=Goodbye %{global:what}\n # REDEFINE: %{global:what}=Sleep\n # RUN: %{global:echo}\n-# CHECK: GLOBAL: Goodbye Sleep Sleep\n+# CHECK:# | GLOBAL: Goodbye Sleep Sleep\n \n # A new local substitution is prepended to the substitution list so that it can\n # depend on all substitutions that were defined previously, including those from\n@@ -26,7 +26,7 @@\n # DEFINE: %{local:greeting}=Hey %{global:what}\n # DEFINE: %{local:echo}=echo \"LOCAL: %{local:greeting} %{global:what}\"\n # RUN: %{local:echo}\n-# CHECK: LOCAL: Hey Sleep Sleep\n+# CHECK:# | LOCAL: Hey Sleep Sleep\n \n # As for substitutions from the test suite config, redefining local\n # substitutions should not change the expansion order.  Again, the expansion\n@@ -36,6 +36,6 @@\n # REDEFINE: %{local:greeting}=So Long %{global:what}\n # REDEFINE: %{global:what}=World\n # RUN: %{local:echo}\n-# CHECK: LOCAL: So Long World World\n+# CHECK:# | LOCAL: So Long World World\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt b/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\nindex 65f90792ff7b..5a1d7f2e1987 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\n@@ -1,19 +1,19 @@\n # Does it work as expected directly in RUN lines?\n # RUN: echo %(line), %(line-1), %(line+2)\n-# CHECK: [[#@LINE-1]], [[#@LINE-2]], [[#@LINE+1]]\n+# CHECK:# | [[#@LINE-1]], [[#@LINE-2]], [[#@LINE+1]]\n \n # %(line) substitutions refer to the original DEFINE/REDEFINE line not the RUN\n # line they eventually appear within.\n #\n # DEFINE: %{lines} = %(line)\n # RUN: echo '%{lines}'\n-# CHECK: [[#@LINE-2]]\n+# CHECK:# | [[#@LINE-2]]\n #\n # REDEFINE: %{lines} = %(line),                                                \\\n # REDEFINE:            %(line),                                                \\\n # REDEFINE:            %(line)\n # RUN: echo '%{lines}'\n-# CHECK: [[#@LINE-4]], [[#@LINE-3]], [[#@LINE-2]]\n+# CHECK:# | [[#@LINE-4]], [[#@LINE-3]], [[#@LINE-2]]\n \n # %(line+N) and %{line-N) should work too.\n #\n@@ -21,12 +21,12 @@\n # DEFINE:                %(line),                                              \\\n # DEFINE:                %(line-1)\n # RUN: echo '%{lines-rel}'\n-# CHECK: [[#@LINE-3]], [[#@LINE-3]], [[#@LINE-3]]\n+# CHECK:# | [[#@LINE-3]], [[#@LINE-3]], [[#@LINE-3]]\n #\n # REDEFINE: %{lines-rel} = %(line+5),                                          \\\n # REDEFINE:                %(line+0),                                          \\\n # REDEFINE:                %(line-10)\n # RUN: echo '%{lines-rel}'\n-# CHECK: [[#@LINE+1]], [[#@LINE-3]], [[#@LINE-12]]\n+# CHECK:# | [[#@LINE+1]], [[#@LINE-3]], [[#@LINE-12]]\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt b/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\nindex 18a27cdd72fa..d27fda2e2fe6 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\n@@ -1,25 +1,25 @@\n # DEFINE: %{abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789} = ok\n # RUN: echo '%{abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789}'\n-# CHECK: ok\n+# CHECK:# | ok\n \n # DEFINE: %{FooBar} = ok at %(line)\n # RUN: echo '%{FooBar}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{fooBar} = ok at %(line)\n # RUN: echo '%{fooBar}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{foo-bar-} = ok at %(line)\n # RUN: echo '%{foo-bar-}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{foo:bar:} = ok at %(line)\n # RUN: echo '%{foo:bar:}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{_foo_bar_} = ok at %(line)\n # RUN: echo '%{_foo_bar_}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt b/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\nindex eb5f0b918fd1..e504b822ace8 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\n@@ -6,7 +6,7 @@\n \n # RUN: echo '%{outer}'\n \n-# CHECK-NON-RECUR:%{inner}\n-# CHECK-RECUR:expanded\n+# CHECK-NON-RECUR:# | %{inner}\n+# CHECK-RECUR:# | expanded\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt b/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\nindex 9d2e7197fb3a..c1bdfef30b1a 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\n@@ -2,21 +2,21 @@\n \n # DEFINE: %{equals} = FileCheck -check-prefixes=FOO,BAR\n # RUN: echo '%{equals}'\n-# CHECK: FileCheck -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -check-prefixes=FOO,BAR\n #\n # REDEFINE: %{equals} == == =\n # RUN: echo '%{equals}'\n-# CHECK: = == =\n+# CHECK:# | = == =\n \n # DEFINE: %{continue-equals} = FileCheck -strict-whitespace -match-full-lines \\\n # DEFINE:                      -check-prefixes=FOO,BAR\n # RUN: echo '%{continue-equals}'\n-# CHECK: FileCheck -strict-whitespace -match-full-lines -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -strict-whitespace -match-full-lines -check-prefixes=FOO,BAR\n #\n # REDEFINE: %{continue-equals} = FileCheck -input-file=test.txt                \\\n # REDEFINE:                      -implicit-check-not=foobar                    \\\n # REDEFINE:                      -check-prefixes=FOO,BAR\n # RUN: echo '%{continue-equals}'\n-# CHECK: FileCheck -input-file=test.txt -implicit-check-not=foobar -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -input-file=test.txt -implicit-check-not=foobar -check-prefixes=FOO,BAR\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt b/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\nindex 58d5c1a34ce8..9143796edd32 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\n@@ -6,11 +6,11 @@\n \n # DEFINE: %{escape} = \\g<0>\\n\n # RUN: echo '%{escape}'\n-# CHECK: {{\\\\?}}\\g<0>{{\\\\?}}\\n\n+# CHECK:# | {{\\\\?}}\\g<0>{{\\\\?}}\\n\n \n # REDEFINE: %{escape} = \\n                                                     \\\n # REDEFINE:             \\g<param>\n # RUN: echo '%{escape}'\n-# CHECK: {{\\\\?}}\\n {{\\\\?}}\\g<param>\n+# CHECK:# | {{\\\\?}}\\n {{\\\\?}}\\g<param>\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt b/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\nindex 1259e511ba70..3e4db1b15d92 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\n@@ -3,33 +3,33 @@\n #\n # DEFINE: %{empty}=\n # RUN: echo \"'%{empty}'\"\n-# CHECK:''\n+# CHECK:# | ''\n #\n # REDEFINE: %{empty}=\n # RUN: echo \"'%{empty}'\"\n-# CHECK:''\n+# CHECK:# | ''\n \n # A value consisting only of whitespace is trimmed to the empty string.\n #\n #               v~~ intentional whitespace\n # DEFINE: %{ws}=   \n # RUN: echo \"'%{ws}'\"\n-# CHECK:''\n+# CHECK:# | ''\n #\n #                 v intentional whitespace\n # REDEFINE: %{ws}= \n # RUN: echo \"'%{ws}'\"\n-# CHECK:''\n+# CHECK:# | ''\n \n # Whitespace is not required around the name or value.\n #\n # DEFINE:%{no-whitespace}=abc\n # RUN: echo \"'%{no-whitespace}'\"\n-# CHECK:'abc'\n+# CHECK:# | 'abc'\n #\n # REDEFINE:%{no-whitespace}=HelloWorld\n # RUN: echo \"'%{no-whitespace}'\"\n-# CHECK:'HelloWorld'\n+# CHECK:# | 'HelloWorld'\n \n # Whitespace is not required between substitutions in a value.\n #\n@@ -37,11 +37,11 @@\n # DEFINE: %{adjacent1} = bar\n # DEFINE: %{has-adjacent-substs} = %{adjacent0}%{adjacent1}\n # RUN: echo \"'%{has-adjacent-substs}'\"\n-# CHECK:'foobar'\n+# CHECK:# | 'foobar'\n #\n # REDEFINE: %{has-adjacent-substs} = %{adjacent0}%{adjacent1}%{adjacent0}\n # RUN: echo \"'%{has-adjacent-substs}'\"\n-# CHECK:'foobarfoo'\n+# CHECK:# | 'foobarfoo'\n \n # Exact whitespace is preserved within the value, but whitespace enclosing the\n # name or value is discarded.  ('%{' and '}' are part of the name, and\n@@ -50,11 +50,11 @@\n #                                       v~~ intentional whitespace\n # DEFINE:   %{whitespace}  =  abc    def   \n # RUN: echo \"'%{whitespace}'\"\n-# CHECK:'abc    def'\n+# CHECK:# | 'abc    def'\n #                                      v intentional whitespace\n # REDEFINE: %{whitespace} = Hello World \n # RUN: echo \"'%{whitespace}'\"\n-# CHECK:'Hello World'\n+# CHECK:# | 'Hello World'\n \n # Line continuations in the value are permitted and collapse whitespace.\n #\n@@ -66,12 +66,12 @@\n # DEFINE:  pqr \n #             ^ intentional whitespace\n # RUN: echo \"'%{continue}'\"\n-# CHECK:'abc def ghi jkl mno pqr'\n+# CHECK:# | 'abc def ghi jkl mno pqr'\n #\n # REDEFINE: %{continue} =  abc  \\\n # REDEFINE: def\n # RUN: echo \"'%{continue}'\"\n-# CHECK:'abc def'\n+# CHECK:# | 'abc def'\n \n # Whitespace at the end of the line after a '\\' is ignored, and it's treated as\n # a line continuation.  Otherwise, the behavior would be hard to understand\n@@ -83,7 +83,7 @@\n #                                   ^ intentional whitespace\n # DEFINE: baz\n # RUN: echo \"'%{ws-after-continue}'\"\n-# CHECK:'foo bar baz'\n+# CHECK:# | 'foo bar baz'\n #\n #                                     v intentional whitespace\n # REDEFINE: %{ws-after-continue}=foo \\ \n@@ -91,7 +91,7 @@\n #                                     ^~~~~~~~~~~~ intentional whitespace\n # REDEFINE: baz\n # RUN: echo \"'%{ws-after-continue}'\"\n-# CHECK:'foo bar baz'\n+# CHECK:# | 'foo bar baz'\n \n # A line continuation is recognized anywhere.  It should be used only where\n # whitespace is permitted because it reduces to a single space.\n@@ -107,7 +107,7 @@\n # DEFINE:\\\n # DEFINE:a\n # RUN: echo \"'%{blank-lines}'\"\n-# CHECK:'a'\n+# CHECK:# | 'a'\n #\n # REDEFINE:                  \\\n # REDEFINE: %{blank-lines}   \\\n@@ -120,7 +120,7 @@\n # REDEFINE:                  \\\n # REDEFINE:      c\n # RUN: echo \"'%{blank-lines}'\"\n-# CHECK:'a b c'\n+# CHECK:# | 'a b c'\n \n # The fourth DEFINE line is deceptive because it looks like a new substitution,\n # but it's actually a continuation of the previous value.\n@@ -130,6 +130,6 @@\n # DEFINE: %{deceptive-continue}=echo \\\n # DEFINE: %{name}=%{value}\n # RUN: %{deceptive-continue}\n-# CHECK:x=3\n+# CHECK:# | x=3\n \n # CHECK:{{ *}}Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt b/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\nindex b0a7cfd97941..b5fc1b49fcc5 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\n@@ -1,46 +1,34 @@\n-#       CHECK: -- Testing:{{.*}}\n-#  CHECK-NEXT: PASS: shtest-if-else :: test.txt (1 of 1)\n-#  CHECK-NEXT: Exit Code: 0\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: Command Output (stdout):\n-#  CHECK-NEXT: --\n+# CHECK: -- Testing:{{.*}}\n+# CHECK-NEXT: PASS: shtest-if-else :: test.txt (1 of 1)\n+#      CHECK: Command Output (stdout):\n+# CHECK-NEXT: --\n \n # RUN: %if feature %{ echo \"test-1\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-1\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-1\"\n \n # If %else is not present it is treated like %else %{%}. Empty commands\n # are ignored.\n #\n # RUN: %if nofeature %{ echo \"fail\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#   CHECK-NOT: fail\n+#     CHECK: # {{RUN}}: at line [[#@LINE-1]] has no command after substitutions\n+# CHECK-NOT: fail\n \n # RUN: %if nofeature %{ echo \"fail\" %} %else %{ echo \"test-2\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-2\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-2\"\n \n # Spaces inside curly braces are not ignored\n #\n # RUN: echo test-%if feature %{ 3 %} %else %{ fail %}-test\n # RUN: echo test-%if feature %{ 4 4 %} %else %{ fail %}-test\n # RUN: echo test-%if nofeature %{ fail %} %else %{ 5 5 %}-test\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 3 -test\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 4 4 -test\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 5 5 -test\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo test- 3 -test\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo test- 4 4 -test\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo test- 5 5 -test\n \n # Escape line breaks for multi-line expressions\n #\n@@ -48,42 +36,32 @@\n # RUN:   %{ echo     \\\n # RUN:     \"test-5\" \\\n # RUN:   %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-4]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-5\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-5\"\n \n # RUN: %if nofeature       \\\n # RUN:   %{ echo \"fail\" %}   \\\n # RUN: %else               \\\n # RUN:   %{ echo \"test-6\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-4]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-6\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-6\"\n \n # RUN: echo \"test%if feature %{%} %else %{%}-7\"\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-7\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-7\"\n \n # Escape %if. Without %if..%else context '%{' and '%}' are treated\n # literally.\n #\n # RUN: echo %%if feature %{ echo \"test-8\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: %if feature %{ echo test-8 %}\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo %if feature %{ echo \"test-8\" %}\n \n # Nested expressions are supported:\n #\n # RUN: echo %if feature %{ %if feature %{ %if nofeature %{\"fail\"%} %else %{\"test-9\"%} %} %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-9\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-9\"\n \n # Binary expression evaluation and regex match can be used as\n # conditions.\n@@ -91,18 +69,12 @@\n # RUN: echo %if feature && !nofeature %{ \"test-10\" %}\n # RUN: echo %if feature && nofeature %{ \"fail\" %} %else %{ \"test-11\" %}\n # RUN: echo %if {{fea.+}} %{ \"test-12\" %} %else %{ \"fail\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-10\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-11\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-12\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo \"test-10\"\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-11\"\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo \"test-12\"\n \n # Spaces between %if and %else are ignored. If there is no %else -\n # space after %if %{...%} is not ignored.\n@@ -110,39 +82,27 @@\n # RUN: echo XX %if feature %{YY%} ZZ\n # RUN: echo AA %if feature %{BB%} %else %{CC%} DD\n # RUN: echo AA %if nofeature %{BB%} %else %{CC%} DD\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: XX YY ZZ\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: AA BB DD\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: AA CC DD\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo XX YY ZZ\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo AA BB DD\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo AA CC DD\n \n # '{' and '}' can be used without escaping\n #\n # RUN: %if feature %{echo {}%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: {}\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo {}\n \n # Spaces are not required\n #\n # RUN: echo %if feature%{\"ok\"%}%else%{\"fail\"%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: ok\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"ok\"\n \n # Substitutions with braces are handled correctly\n #\n # RUN: echo %{sub} %if feature%{test-%{sub}%}%else%{\"fail\"%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: ok test-ok\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo ok test-ok\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt b/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\nindex fb3a3e000789..5ff0c891450b 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\n@@ -1,3 +1,4 @@\n # RUN: true\n # RUN: echo hi\n-# RUN: not not wc missing-file &> %t.out\n+# RUN: not not wc missing-file &> %t.out || true\n+# RUN: not %{python} %S/write-a-lot.py &> %t.out\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg b/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\nindex b872854d21e6..c53fd157b6ae 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\n@@ -2,4 +2,5 @@ import lit.formats\n \n config.name = \"shtest-output-printing\"\n config.suffixes = [\".txt\"]\n+config.substitutions.append((\"%{python}\", sys.executable))\n config.test_format = lit.formats.ShTest(execute_external=False)\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py b/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py\nnew file mode 100644\nindex 000000000000..ffcba7d517cd\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py\n@@ -0,0 +1,6 @@\n+#!/usr/bin/env python\n+\n+import sys\n+\n+sys.stdout.write(\"All work and no play makes Jack a dull boy.\\n\" * 1000);\n+sys.stdout.flush()\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt\nnew file mode 100644\nindex 000000000000..15a87aee46a3\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt\n@@ -0,0 +1 @@\n+RUN: @echo 2> %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt\nnew file mode 100644\nindex 000000000000..27fd0c4209fd\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt\n@@ -0,0 +1,2 @@\n+RUN: touch %t\n+RUN: @echo < %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt\nnew file mode 100644\nindex 000000000000..9611918f7e12\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt\n@@ -0,0 +1 @@\n+RUN: echo 2> %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt\nnew file mode 100644\nindex 000000000000..bc771be6b22a\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt\n@@ -0,0 +1,2 @@\n+RUN: touch %t\n+RUN: echo < %t\ndiff --git a/llvm/utils/lit/tests/allow-retries.py b/llvm/utils/lit/tests/allow-retries.py\nindex b8abe0ba4fee..ef548534f082 100644\n--- a/llvm/utils/lit/tests/allow-retries.py\n+++ b/llvm/utils/lit/tests/allow-retries.py\n@@ -15,9 +15,28 @@\n \n # This test does not succeed within the allowed retry limit\n #\n-# RUN: not %{lit} %{inputs}/allow-retries/does-not-succeed-within-limit.py | FileCheck --check-prefix=CHECK-TEST3 %s\n-# CHECK-TEST3: Failed Tests (1):\n-# CHECK-TEST3: allow-retries :: does-not-succeed-within-limit.py\n+# Check that the execution trace isn't corrupt due to reprocessing the script\n+# multiple times (e.g., '%dbg(...)' processing used to accumulate across\n+# retries).\n+#\n+# RUN: not %{lit} %{inputs}/allow-retries/does-not-succeed-within-limit.py -v |\\\n+# RUN:   FileCheck --check-prefix=CHECK-TEST3 -match-full-lines %s\n+#\n+#       CHECK-TEST3: FAIL: allow-retries :: does-not-succeed-within-limit.py (1 of 1)\n+#  CHECK-TEST3-NEXT: {{\\**}} TEST 'allow-retries :: does-not-succeed-within-limit.py' FAILED {{\\**}}\n+#  CHECK-TEST3-NEXT: Exit Code: 1\n+# CHECK-TEST3-EMPTY:\n+#  CHECK-TEST3-NEXT: Command Output (stdout):\n+#  CHECK-TEST3-NEXT: --\n+#  CHECK-TEST3-NEXT: # {{RUN}}: at line 3\n+#  CHECK-TEST3-NEXT: false\n+#  CHECK-TEST3-NEXT: # executed command: false\n+#  CHECK-TEST3-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-TEST3-NEXT: # error: command failed with exit status: 1\n+# CHECK-TEST3-EMPTY:\n+#  CHECK-TEST3-NEXT: --\n+#       CHECK-TEST3: Failed Tests (1):\n+#       CHECK-TEST3: allow-retries :: does-not-succeed-within-limit.py\n \n # This test should be UNRESOLVED since it has more than one ALLOW_RETRIES\n # lines, and that is not allowed.\ndiff --git a/llvm/utils/lit/tests/lit-opts.py b/llvm/utils/lit/tests/lit-opts.py\nindex d292ca74f3b9..a533a59d9d12 100644\n--- a/llvm/utils/lit/tests/lit-opts.py\n+++ b/llvm/utils/lit/tests/lit-opts.py\n@@ -8,7 +8,7 @@\n #\n # RUN: env LIT_OPTS=-a \\\n # RUN: %{lit} -s %{inputs}/lit-opts \\\n-# RUN: | FileCheck -check-prefix=SHOW-ALL -DVAR= %s\n+# RUN: | FileCheck -check-prefix=SHOW-ALL -DVAR=default %s\n \n # Check that LIT_OPTS understands multiple options with arbitrary spacing.\n #\n@@ -28,6 +28,6 @@\n \n # SHOW-ALL:     Testing: 1 tests\n # SHOW-ALL:     PASS: lit-opts :: test.txt (1 of 1)\n-# SHOW-ALL:     {{^}}[[VAR]]\n+# SHOW-ALL:     echo [[VAR]]\n # SHOW-ALL-NOT: PASS\n # SHOW-ALL:     Passed: 1\ndiff --git a/llvm/utils/lit/tests/shtest-define.py b/llvm/utils/lit/tests/shtest-define.py\nindex 1d0997bbbaf8..8c9309804cce 100644\n--- a/llvm/utils/lit/tests/shtest-define.py\n+++ b/llvm/utils/lit/tests/shtest-define.py\n@@ -136,15 +136,15 @@\n # RUN: %{lit} -va %{my-inputs}/shared-substs-*.txt 2>&1 |                      \\\n # RUN:   FileCheck -check-prefix=SHARED-SUBSTS -match-full-lines %s\n #\n-# SHARED-SUBSTS: shared-substs-0.txt\n-# SHARED-SUBSTS: GLOBAL: World\n-# SHARED-SUBSTS: LOCAL0: LOCAL0:Hello LOCAL0:World\n-# SHARED-SUBSTS: LOCAL0: subst\n+# SHARED-SUBSTS:# | shared-substs-0.txt\n+# SHARED-SUBSTS:# | GLOBAL: World\n+# SHARED-SUBSTS:# | LOCAL0: LOCAL0:Hello LOCAL0:World\n+# SHARED-SUBSTS:# | LOCAL0: subst\n #\n-# SHARED-SUBSTS: shared-substs-1.txt\n-# SHARED-SUBSTS: GLOBAL: World\n-# SHARED-SUBSTS: LOCAL1: LOCAL1:Hello LOCAL1:World\n-# SHARED-SUBSTS: LOCAL1: subst\n+# SHARED-SUBSTS:# | shared-substs-1.txt\n+# SHARED-SUBSTS:# | GLOBAL: World\n+# SHARED-SUBSTS:# | LOCAL1: LOCAL1:Hello LOCAL1:World\n+# SHARED-SUBSTS:# | LOCAL1: subst\n #\n # REDEFINE: %{test} = shared-substs-0.txt\n # RUN: %{record-test}\ndiff --git a/llvm/utils/lit/tests/shtest-env.py b/llvm/utils/lit/tests/shtest-env.py\nindex f2e8216f7f4a..a4775ac6688d 100644\n--- a/llvm/utils/lit/tests/shtest-env.py\n+++ b/llvm/utils/lit/tests/shtest-env.py\n@@ -10,88 +10,115 @@\n # CHECK: -- Testing: 16 tests{{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-assign.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"FOO=1\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env FOO=1\n+# CHECK: # executed command: env FOO=1\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-u-arg.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO\n+# CHECK: # executed command: env -u FOO\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-u.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u\n+# CHECK: # executed command: env -u\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-nested-none.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"env\" \"env\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env env env\n+# CHECK: # executed command: env env env\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-none.txt ({{[^)]*}})\n-# CHECK: $ \"env\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env\n+# CHECK: # executed command: env\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-cd.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"cd\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'cd'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 cd foobar\n+# CHECK: # executed command: env -u FOO BAR=3 cd foobar\n+# CHECK: # | Error: 'env' cannot call 'cd'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-colon.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \":\"\n-# CHECK: Error: 'env' cannot call ':'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 :\n+# CHECK: # executed command: env -u FOO BAR=3 :\n+# CHECK: # | Error: 'env' cannot call ':'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-echo.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"echo\" \"hello\" \"world\"\n-# CHECK: Error: 'env' cannot call 'echo'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 echo hello world\n+# CHECK: # executed command: env -u FOO BAR=3 echo hello world\n+# CHECK: # | Error: 'env' cannot call 'echo'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: PASS: shtest-env :: env-calls-env.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"env\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"FOO=2\" \"env\" \"BAR=1\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"env\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=1\" \"env\" \"-u\" \"BAR\" \"FOO=2\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=1\" \"env\" \"-u\" \"BAR\" \"FOO=2\" \"env\" \"BAZ=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env env [[PYTHON:.+]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env env [[PYTHON_BARE:.+]] print_environment.py\n+# CHECK: env FOO=2 env BAR=1 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env FOO=2 env BAR=1 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO env -u BAR [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO env -u BAR [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO BAR=1 env -u BAR FOO=2 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO BAR=1 env -u BAR FOO=2 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO BAR=1 env -u BAR FOO=2 env BAZ=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO BAR=1 env -u BAR FOO=2 env BAZ=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: FAIL: shtest-env :: env-calls-export.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"export\" \"BAZ=3\"\n-# CHECK: Error: 'env' cannot call 'export'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 export BAZ=3\n+# CHECK: # executed command: env -u FOO BAR=3 export BAZ=3\n+# CHECK: # | Error: 'env' cannot call 'export'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-mkdir.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"mkdir\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'mkdir'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 mkdir foobar\n+# CHECK: # executed command: env -u FOO BAR=3 mkdir foobar\n+# CHECK: # | Error: 'env' cannot call 'mkdir'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-not-builtin.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"not\" \"rm\" \"{{.*}}.no-such-file\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 not rm {{.+}}.no-such-file\n+# CHECK: # executed command: env -u FOO BAR=3 not rm {{.+}}.no-such-file\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-rm.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"rm\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 rm foobar\n+# CHECK: # executed command: env -u FOO BAR=3 rm foobar\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: PASS: shtest-env :: env-u.txt ({{[^)]*}})\n-# CHECK: $ \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: env -u FOO [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO -u BAR [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO -u BAR [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: PASS: shtest-env :: env.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"A_FOO=999\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"A_FOO=1\" \"B_BAR=2\" \"C_OOF=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env A_FOO=999 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=999 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env A_FOO=1 B_BAR=2 C_OOF=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=1 B_BAR=2 C_OOF=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: PASS: shtest-env :: mixed.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"A_FOO=999\" \"-u\" \"FOO\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"A_FOO=1\" \"-u\" \"FOO\" \"B_BAR=2\" \"-u\" \"BAR\" \"C_OOF=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env A_FOO=999 -u FOO [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=999 -u FOO [[PYTHON_BARE]] print_environment.py\n+# CHECK: env A_FOO=1 -u FOO B_BAR=2 -u BAR C_OOF=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=1 -u FOO B_BAR=2 -u BAR C_OOF=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: Passed:  4\n # CHECK: Failed: 12\ndiff --git a/llvm/utils/lit/tests/shtest-format.py b/llvm/utils/lit/tests/shtest-format.py\nindex 621776ab7bc2..4a3d65b7bce4 100644\n--- a/llvm/utils/lit/tests/shtest-format.py\n+++ b/llvm/utils/lit/tests/shtest-format.py\n@@ -43,13 +43,21 @@\n # CHECK-EMPTY:\n #  CHECK-NEXT: Command Output (stdout):\n #  CHECK-NEXT: --\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-#  CHECK-NEXT: $ \"printf\"\n-#  CHECK-NEXT: # command output:\n-#  CHECK-NEXT: line 1: failed test output on stdout\n-#  CHECK-NEXT: line 2: failed test output on stdout\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-#  CHECK-NEXT: $ \"false\"\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: printf \"line 1: failed test output on stdout\\nline 2: failed test output on stdout\"\n+#  CHECK-NEXT: executed command: printf 'line 1: failed test output on stdout\\nline 2: failed test output on stdout'\n+#  CHECK-NEXT: # .---command stdout------------\n+#  CHECK-NEXT: # | line 1: failed test output on stdout\n+#  CHECK-NEXT: # | line 2: failed test output on stdout\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # RUN: at line 2\n+#  CHECK-NEXT: false\n+#  CHECK-NEXT: # executed command: false\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: --\n+\n \n # CHECK: UNRESOLVED: shtest-format :: no-test-line.txt\n # CHECK: PASS: shtest-format :: pass.txt\n@@ -73,8 +81,11 @@\n # CHECK-EMPTY:\n #  CHECK-NEXT: Command Output (stdout):\n #  CHECK-NEXT: --\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-#  CHECK-NEXT: $ \"true\"\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: true\n+#  CHECK-NEXT: # executed command: true\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: --\n \n # CHECK: Failed Tests (4)\n # CHECK: shtest-format :: external_shell/fail.txt\ndiff --git a/llvm/utils/lit/tests/shtest-if-else.py b/llvm/utils/lit/tests/shtest-if-else.py\nindex aaf94a6e2437..c18da4abbcca 100644\n--- a/llvm/utils/lit/tests/shtest-if-else.py\n+++ b/llvm/utils/lit/tests/shtest-if-else.py\n@@ -1,5 +1,6 @@\n # RUN: %{lit} -v --show-all %{inputs}/shtest-if-else/test.txt \\\n-# RUN:    | FileCheck %{inputs}/shtest-if-else/test.txt --match-full-lines\n+# RUN:    | FileCheck %{inputs}/shtest-if-else/test.txt --match-full-lines \\\n+# RUN:                --implicit-check-not='RUN:'\n \n # RUN: not %{lit} -v --show-all %{inputs}/shtest-if-else/test-neg1.txt 2>&1 \\\n # RUN:    | FileCheck %{inputs}/shtest-if-else/test-neg1.txt\ndiff --git a/llvm/utils/lit/tests/shtest-inject.py b/llvm/utils/lit/tests/shtest-inject.py\nindex 17e293ea1a12..3d34eb7161d4 100644\n--- a/llvm/utils/lit/tests/shtest-inject.py\n+++ b/llvm/utils/lit/tests/shtest-inject.py\n@@ -1,9 +1,26 @@\n-# Check that we can inject commands at the beginning of a ShTest.\n+# Check that we can inject preamble commands at the beginning of a ShTest.\n+#\n+# For one case, check the execution trace as these preamble commands have\n+# \"preamble command\" instead of the usual \"{{RUN}}: at line N\".\n \n # RUN: %{lit} %{inputs}/shtest-inject/test-empty.txt --show-all | FileCheck --check-prefix=CHECK-TEST1 %s\n #\n-# CHECK-TEST1: THIS WAS\n-# CHECK-TEST1: INJECTED\n+#       CHECK-TEST1: Command Output (stdout):\n+#  CHECK-TEST1-NEXT: --\n+#  CHECK-TEST1-NEXT: # preamble command line\n+#  CHECK-TEST1-NEXT: echo \"THIS WAS\"\n+#  CHECK-TEST1-NEXT: # executed command: echo 'THIS WAS'\n+#  CHECK-TEST1-NEXT: # .---command stdout{{-*}}\n+#  CHECK-TEST1-NEXT: # | THIS WAS\n+#  CHECK-TEST1-NEXT: # `---{{-*}}\n+#  CHECK-TEST1-NEXT: # preamble command line\n+#  CHECK-TEST1-NEXT: echo \"INJECTED\"\n+#  CHECK-TEST1-NEXT: # executed command: echo INJECTED\n+#  CHECK-TEST1-NEXT: # .---command stdout{{-*}}\n+#  CHECK-TEST1-NEXT: # | INJECTED\n+#  CHECK-TEST1-NEXT: # `---{{-*}}\n+# CHECK-TEST1-EMPTY:\n+#  CHECK-TEST1-NEXT: --\n #\n # CHECK-TEST1: Passed: 1\n \ndiff --git a/llvm/utils/lit/tests/shtest-not.py b/llvm/utils/lit/tests/shtest-not.py\nindex d23c9d0cffaf..4590b9664b84 100644\n--- a/llvm/utils/lit/tests/shtest-not.py\n+++ b/llvm/utils/lit/tests/shtest-not.py\n@@ -10,112 +10,158 @@\n # CHECK: -- Testing: 17 tests{{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-args-nested-none.txt {{.*}}\n-# CHECK: $ \"!\" \"!\" \"!\"\n-# CHECK: Error: '!' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: ! ! !\n+# CHECK: # executed command: ! ! !\n+# CHECK: # | Error: '!' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-args-none.txt {{.*}}\n-# CHECK: $ \"!\"\n-# CHECK: Error: '!' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: !\n+# CHECK: # executed command: !\n+# CHECK: # | Error: '!' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-calls-external.txt {{.*}}\n \n-# CHECK: $ \"!\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"!\" \"!\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"!\" \"!\" \"!\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"!\" \"!\" \"!\" \"!\" \"{{[^\"]*}}\" \"pass.py\"\n+# CHECK: ! [[PYTHON:.*]] fail.py\n+# CHECK: # executed command: ! [[PYTHON_BARE:.*]] fail.py\n+# CHECK: ! ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! ! [[PYTHON_BARE]] pass.py\n+# CHECK: ! ! ! [[PYTHON]] fail.py\n+# CHECK: # executed command: ! ! ! [[PYTHON_BARE]] fail.py\n+# CHECK: ! ! ! ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! ! ! ! [[PYTHON_BARE]] pass.py\n \n-# CHECK: $ \"!\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! [[PYTHON_BARE]] pass.py\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-last-is-crash.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not --crash\n+# CHECK: # executed command: not --crash\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-nested-none.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not not\n+# CHECK: # executed command: not not not\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-none.txt {{.*}}\n-# CHECK: $ \"not\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not\n+# CHECK: # executed command: not\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-cd.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"cd\" \"foobar\"\n-# CHECK: $ \"not\" \"--crash\" \"cd\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'cd'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not cd foobar\n+# CHECK: # executed command: not not cd foobar\n+# CHECK: not --crash cd foobar\n+# CHECK: # executed command: not --crash cd foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'cd'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-colon.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \":\" \"foobar\"\n-# CHECK: $ \"not\" \"--crash\" \":\"\n-# CHECK: Error: 'not --crash' cannot call ':'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not : foobar\n+# CHECK: # executed command: not not : foobar\n+# CHECK: not --crash :\n+# CHECK: # executed command: not --crash :\n+# CHECK: # | Error: 'not --crash' cannot call ':'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-diff-with-crash.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"diff\" \"-u\" {{.*}}\n-# CHECK-NOT: \"$\"\n+# CHECK: not --crash diff -u {{.*}}\n+# CHECK: # executed command: not --crash diff -u {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n # CHECK-NOT: {{[Ee]rror}}\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: # error: command failed with exit status: {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n # CHECK-NOT: {{[Ee]rror}}\n-# CHECK-NOT: \"$\"\n \n # CHECK: FAIL: shtest-not :: not-calls-diff.txt {{.*}}\n-# CHECK: $ \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"diff\" {{.*}}\n-# CHECK-NOT: \"$\"\n+# CHECK: not diff {{.*}}\n+# CHECK: # executed command: not diff {{.*}}\n+# CHECK: not not not diff {{.*}}\n+# CHECK: # executed command: not not not diff {{.*}}\n+# CHECK: not not not not not diff {{.*}}\n+# CHECK: # executed command: not not not not not diff {{.*}}\n+# CHECK: diff {{.*}}\n+# CHECK: # executed command: diff {{.*}}\n+# CHECK: not not diff {{.*}}\n+# CHECK: # executed command: not not diff {{.*}}\n+# CHECK: not not not not diff {{.*}}\n+# CHECK: # executed command: not not not not diff {{.*}}\n+# CHECK: not diff {{.*}}\n+# CHECK: # executed command: not diff {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-echo.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"echo\" \"hello\" \"world\"\n-# CHECK: $ \"not\" \"--crash\" \"echo\" \"hello\" \"world\"\n-# CHECK: Error: 'not --crash' cannot call 'echo'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not echo hello world\n+# CHECK: # executed command: not not echo hello world\n+# CHECK: not --crash echo hello world\n+# CHECK: # executed command: not --crash echo hello world\n+# CHECK: # | Error: 'not --crash' cannot call 'echo'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-env-builtin.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"env\" \"-u\" \"FOO\" \"BAR=3\" \"rm\" \"{{.*}}.no-such-file\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not --crash env -u FOO BAR=3 rm {{.*}}.no-such-file\n+# CHECK: # executed command: not --crash env -u FOO BAR=3 rm {{.*}}.no-such-file\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-export.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"export\" \"FOO=1\"\n-# CHECK: $ \"not\" \"--crash\" \"export\" \"BAZ=3\"\n-# CHECK: Error: 'not --crash' cannot call 'export'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not export FOO=1\n+# CHECK: # executed command: not not export FOO=1\n+# CHECK: not --crash export BAZ=3\n+# CHECK: # executed command: not --crash export BAZ=3\n+# CHECK: # | Error: 'not --crash' cannot call 'export'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n \n # CHECK: PASS: shtest-not :: not-calls-external.txt {{.*}}\n \n-# CHECK: $ \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-\n-# CHECK: $ \"env\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"env\" \"-u\" \"FOO\" \"BAR=2\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"env\" \"-u\" \"FOO\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"env\" \"FOO=1\" \"env\" \"FOO=2\" \"BAR=1\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"-u\" \"BAR\" \"env\" \"-u\" \"FOO\" \"BAR=1\" \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"env\" \"FOO=2\" \"BAR=2\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"env\" \"-u\" \"BAR\" \"not\" \"env\" \"-u\" \"FOO\" \"BAR=1\" \"{{[^\"]*}}\" \"pass.py\"\n+# CHECK: not [[PYTHON]] fail.py\n+# CHECK: # executed command: not [[PYTHON_BARE]] fail.py\n+# CHECK: not not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not [[PYTHON_BARE]] pass.py\n+# CHECK: not not not [[PYTHON]] fail.py\n+# CHECK: # executed command: not not not [[PYTHON_BARE]] fail.py\n+# CHECK: not not not not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not not not [[PYTHON_BARE]] pass.py\n+\n+# CHECK: not not --crash [[PYTHON]] pass.py\n+# CHECK: # executed command: not not --crash [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash [[PYTHON]] fail.py\n+# CHECK: # executed command: not not --crash [[PYTHON_BARE]] fail.py\n+# CHECK: not not --crash not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not --crash not [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash not [[PYTHON]] fail.py\n+# CHECK: # executed command: not not --crash not [[PYTHON_BARE]] fail.py\n+\n+# CHECK: env not [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env not [[PYTHON_BARE]] fail.py\n+# CHECK: not env [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: not env [[PYTHON_BARE]] fail.py\n+# CHECK: env FOO=1 not [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 not [[PYTHON_BARE]] fail.py\n+# CHECK: not env FOO=1 BAR=1 [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 [[PYTHON_BARE]] fail.py\n+# CHECK: env FOO=1 BAR=1 not env -u FOO BAR=2 [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 BAR=1 not env -u FOO BAR=2 [[PYTHON_BARE]] fail.py\n+# CHECK: not env FOO=1 BAR=1 not env -u FOO -u BAR [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 not env -u FOO -u BAR [[PYTHON_BARE]] pass.py\n+# CHECK: not not env FOO=1 env FOO=2 BAR=1 [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not not env FOO=1 env FOO=2 BAR=1 [[PYTHON_BARE]] pass.py\n+# CHECK: env FOO=1 -u BAR env -u FOO BAR=1 not not [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 -u BAR env -u FOO BAR=1 not not [[PYTHON_BARE]] pass.py\n+\n+# CHECK: not env FOO=1 BAR=1 env FOO=2 BAR=2 not --crash [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 env FOO=2 BAR=2 not --crash [[PYTHON_BARE]] pass.py\n+# CHECK: not env FOO=1 BAR=1 not --crash not [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 not --crash not [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash env -u BAR not env -u FOO BAR=1 [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not not --crash env -u BAR not env -u FOO BAR=1 [[PYTHON_BARE]] pass.py\n \n \n # CHECK: FAIL: shtest-not :: not-calls-fail2.txt {{.*}}\n@@ -123,16 +169,20 @@\n # CHECK-NEXT: Exit Code: 1\n \n # CHECK: FAIL: shtest-not :: not-calls-mkdir.txt {{.*}}\n-# CHECK: $ \"not\" \"mkdir\" {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"mkdir\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'mkdir'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not mkdir {{.*}}\n+# CHECK: # executed command: not mkdir {{.*}}\n+# CHECK: not --crash mkdir foobar\n+# CHECK: # executed command: not --crash mkdir foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'mkdir'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-rm.txt {{.*}}\n-# CHECK: $ \"not\" \"rm\" {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"rm\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not rm {{.*}}\n+# CHECK: # executed command: not rm {{.*}}\n+# CHECK: not --crash rm foobar\n+# CHECK: # executed command: not --crash rm foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: Passed:  1\n # CHECK: Failed: 16\ndiff --git a/llvm/utils/lit/tests/shtest-output-printing.py b/llvm/utils/lit/tests/shtest-output-printing.py\nindex 7cd975ba8d3c..3e49197520a9 100644\n--- a/llvm/utils/lit/tests/shtest-output-printing.py\n+++ b/llvm/utils/lit/tests/shtest-output-printing.py\n@@ -1,28 +1,45 @@\n # Check the various features of the ShTest format.\n #\n # RUN: not %{lit} -v %{inputs}/shtest-output-printing > %t.out\n-# RUN: FileCheck --input-file %t.out %s\n+# RUN: FileCheck --input-file %t.out --match-full-lines %s\n #\n # END.\n \n-# CHECK: -- Testing:\n-\n-# CHECK: FAIL: shtest-output-printing :: basic.txt\n-# CHECK-NEXT: *** TEST 'shtest-output-printing :: basic.txt' FAILED ***\n-# CHECK-NEXT: Exit Code: 1\n-#\n-# CHECK:      Command Output\n-# CHECK-NEXT: --\n-# CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \"true\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-# CHECK-NEXT: $ \"echo\" \"hi\"\n-# CHECK-NEXT: # command output:\n-# CHECK-NEXT: hi\n-#\n-# CHECK:      $ \":\" \"RUN: at line 3\"\n-# CHECK-NEXT: $ \"not\" \"not\" \"wc\" \"missing-file\"\n-# CHECK-NEXT: # redirected output from '{{.*(/|\\\\\\\\)}}basic.txt.tmp.out':\n-# CHECK-NEXT: {{cannot open missing-file|missing-file.* No such file or directory}}\n-# CHECK:      note: command had no output on stdout or stderr\n-# CHECK-NEXT: error: command failed with exit status: 1\n+#       CHECK: -- Testing: {{.*}}\n+#       CHECK: FAIL: shtest-output-printing :: basic.txt {{.*}}\n+#  CHECK-NEXT: ***{{\\**}} TEST 'shtest-output-printing :: basic.txt' FAILED ***{{\\**}}\n+#  CHECK-NEXT: Exit Code: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: Command Output (stdout):\n+#  CHECK-NEXT: --\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: true\n+#  CHECK-NEXT: # executed command: true\n+#  CHECK-NEXT: # RUN: at line 2\n+#  CHECK-NEXT: echo hi\n+#  CHECK-NEXT: # executed command: echo hi\n+#  CHECK-NEXT: # .---command stdout------------\n+#  CHECK-NEXT: # | hi\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # RUN: at line 3\n+#  CHECK-NEXT: not not wc missing-file &> [[FILE:.*]] || true\n+#  CHECK-NEXT: # executed command: not not wc missing-file\n+#  CHECK-NEXT: # .---redirected output from '[[FILE]]'\n+#  CHECK-NEXT: # | wc: {{cannot open missing-file|missing-file.* No such file or directory}}\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+#  CHECK-NEXT: # executed command: true\n+#  CHECK-NEXT: # RUN: at line 4\n+#  CHECK-NEXT: not {{.*}}/python{{.*}} {{.*}}/write-a-lot.py &> [[FILE:.*]]\n+#  CHECK-NEXT: # executed command: not {{.*}}/python{{.*}} {{.*}}/write-a-lot.py\n+#  CHECK-NEXT: # .---redirected output from '[[FILE]]'\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#       CHECK: # | ...\n+#  CHECK-NEXT: # `---data was truncated--------\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT:--\ndiff --git a/llvm/utils/lit/tests/shtest-pushd-popd.py b/llvm/utils/lit/tests/shtest-pushd-popd.py\nindex 26296a7ffcf5..6d7e93c74a05 100644\n--- a/llvm/utils/lit/tests/shtest-pushd-popd.py\n+++ b/llvm/utils/lit/tests/shtest-pushd-popd.py\n@@ -8,16 +8,16 @@\n # CHECK: -- Testing: 4 tests{{.*}}\n \n # CHECK: FAIL: shtest-pushd-popd :: popd-args.txt ({{[^)]*}})\n-# CHECK: $ \"popd\" \"invalid\"\n-# CHECK: 'popd' does not support arguments\n+# CHECK: popd invalid\n+# CHECK: # | 'popd' does not support arguments\n \n # CHECK: FAIL: shtest-pushd-popd :: popd-no-stack.txt ({{[^)]*}})\n-# CHECK: $ \"popd\"\n-# CHECK: popd: directory stack empty\n+# CHECK: popd\n+# CHECK: # | popd: directory stack empty\n \n # CHECK: FAIL: shtest-pushd-popd :: pushd-too-many-args.txt ({{[^)]*}})\n-# CHECK: $ \"pushd\" \"a\" \"b\"\n-# CHECK: 'pushd' supports only one argument\n+# CHECK: pushd a b\n+# CHECK: # | 'pushd' supports only one argument\n \n # CHECK: Passed:  1\n # CHECK: Failed:  3\ndiff --git a/llvm/utils/lit/tests/shtest-recursive-substitution.py b/llvm/utils/lit/tests/shtest-recursive-substitution.py\nindex 48f4b5b12491..65c177e65a3c 100644\n--- a/llvm/utils/lit/tests/shtest-recursive-substitution.py\n+++ b/llvm/utils/lit/tests/shtest-recursive-substitution.py\n@@ -3,7 +3,7 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/substitutes-within-limit --show-all | FileCheck --check-prefix=CHECK-TEST1 %s\n # CHECK-TEST1: PASS: substitutes-within-limit :: test.py\n-# CHECK-TEST1: $ \"echo\" \"STOP\"\n+# CHECK-TEST1: echo STOP\n \n # RUN: not %{lit} %{inputs}/shtest-recursive-substitution/does-not-substitute-within-limit --show-all | FileCheck --check-prefix=CHECK-TEST2 %s\n # CHECK-TEST2: UNRESOLVED: does-not-substitute-within-limit :: test.py\n@@ -11,7 +11,7 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/does-not-substitute-no-limit --show-all | FileCheck --check-prefix=CHECK-TEST3 %s\n # CHECK-TEST3: PASS: does-not-substitute-no-limit :: test.py\n-# CHECK-TEST3: $ \"echo\" \"%rec4\"\n+# CHECK-TEST3: echo %rec4\n \n # RUN: not %{lit} %{inputs}/shtest-recursive-substitution/not-an-integer --show-all 2>&1 | FileCheck --check-prefix=CHECK-TEST4 %s\n # CHECK-TEST4: recursiveExpansionLimit must be either None or an integer\n@@ -24,4 +24,4 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/escaping --show-all | FileCheck --check-prefix=CHECK-TEST7 %s\n # CHECK-TEST7: PASS: escaping :: test.py\n-# CHECK-TEST7: $ \"echo\" \"%s\" \"%s\" \"%%s\"\n+# CHECK-TEST7: echo %s %s %%s\ndiff --git a/llvm/utils/lit/tests/shtest-run-at-line.py b/llvm/utils/lit/tests/shtest-run-at-line.py\nindex 879cd64ebf6e..a0626f872c4c 100644\n--- a/llvm/utils/lit/tests/shtest-run-at-line.py\n+++ b/llvm/utils/lit/tests/shtest-run-at-line.py\n@@ -28,21 +28,28 @@\n # CHECK-LABEL: FAIL: shtest-run-at-line :: internal-shell/basic.txt\n \n # CHECK:      Command Output (stdout)\n-# CHECK:      $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \"true\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-# CHECK-NEXT: $ \"false\"\n+# CHECK-NEXT: --\n+# CHECK-NEXT: # RUN: at line 1\n+# CHECK-NEXT: true\n+# CHECK-NEXT: # executed command: true\n+# CHECK-NEXT: # RUN: at line 2\n+# CHECK-NEXT: false\n+# CHECK-NEXT: # executed command: false\n # CHECK-NOT:  RUN\n \n # CHECK-LABEL: FAIL: shtest-run-at-line :: internal-shell/line-continuation.txt\n \n # CHECK:      Command Output (stdout)\n-# CHECK:      $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \":\" \"first\" \"line\" \"continued\" \"to\" \"second\" \"line\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 3\"\n-# CHECK-NEXT: $ \"echo\" \"foo bar\"\n-# CHECK-NEXT: $ \"FileCheck\" \"{{.*}}\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 5\"\n-# CHECK-NEXT: $ \"echo\" \"foo baz\"\n-# CHECK-NEXT: $ \"FileCheck\" \"{{.*}}\"\n+# CHECK-NEXT: --\n+# CHECK-NEXT: # RUN: at line 1\n+# CHECK-NEXT: : first line continued to second line\n+# CHECK-NEXT: # executed command: : first line continued to second line\n+# CHECK-NEXT: # RUN: at line 3\n+# CHECK-NEXT: echo 'foo bar' | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: echo 'foo bar'\n+# CHECK-NEXT: # executed command: FileCheck {{.*}}\n+# CHECK-NEXT: # RUN: at line 5\n+# CHECK-NEXT: echo 'foo baz' | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: echo 'foo baz'\n+# CHECK-NEXT: # executed command: FileCheck {{.*}}\n # CHECK-NOT:  RUN\ndiff --git a/llvm/utils/lit/tests/shtest-shell.py b/llvm/utils/lit/tests/shtest-shell.py\nindex 93f05dbd35d0..8ce71296c144 100644\n--- a/llvm/utils/lit/tests/shtest-shell.py\n+++ b/llvm/utils/lit/tests/shtest-shell.py\n@@ -20,202 +20,212 @@\n \n # CHECK: FAIL: shtest-shell :: cat-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: cat-error-0.txt' FAILED ***\n-# CHECK: $ \"cat\" \"-b\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'cat':  option -b not recognized\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: cat -b temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'cat':  option -b not recognized\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: cat-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: cat-error-1.txt' FAILED ***\n-# CHECK: $ \"cat\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: [Errno 2] No such file or directory: 'temp1.txt'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: cat temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | [Errno 2] No such file or directory: 'temp1.txt'\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: colon-error.txt\n # CHECK: *** TEST 'shtest-shell :: colon-error.txt' FAILED ***\n-# CHECK: $ \":\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: ':' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: :\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: ':' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: PASS: shtest-shell :: continuations.txt\n \n # CHECK: PASS: shtest-shell :: dev-null.txt\n \n-# CHECK: FAIL: shtest-shell :: diff-b.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-b.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-b\" \"{{[^\"]*}}.0\" \"{{[^\"]*}}.1\"\n-# CHECK: # command output:\n-# CHECK: 1,2\n-# CHECK-NEXT: {{^  }}f o o\n-# CHECK-NEXT: ! b a r\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: {{^  }}f o o\n-# CHECK-NEXT: ! bar\n-# CHECK-EMPTY:\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-b.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-b.txt' FAILED ***\n+#      CHECK: diff -b {{[^\"]*}}.0 {{[^\"]*}}.1\n+#      CHECK: # .---command stdout{{-*}}\n+#      CHECK: # | {{.*}}1,2\n+# CHECK-NEXT: # |   f o o\n+# CHECK-NEXT: # | ! b a r\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # |   f o o\n+# CHECK-NEXT: # | ! bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+#      CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-encodings.txt\n # CHECK: *** TEST 'shtest-shell :: diff-encodings.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"diff-in.bin\"\n+#      CHECK: diff -u diff-in.bin diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.bin diff-in.bin\n+#  CHECK-NOT: error\n+\n+#      CHECK: diff -u diff-in.utf16 diff-in.bin && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf16 diff-in.bin\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.utf8 diff-in.bin && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf8 diff-in.bin\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | -baz\n+# CHECK-NEXT: # | {{\\+.f.o.o.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{\\+.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.bin diff-in.utf8 && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.bin diff-in.utf8\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{-.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.}}\n+# CHECK-NEXT: # | {{-.b.a.z.$}}\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # | +baz\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#     CHECK: cat diff-in.bin | diff -u - diff-in.bin\n # CHECK-NOT: error\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf16\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^ .f.o.o.$}}\n-# CHECK-NEXT: {{^-.b.a.r.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^ .b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf8\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: -baz\n-# CHECK-NEXT: {{^\\+.f.o.o.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^\\+.b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"diff-in.utf8\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^\\-.f.o.o.$}}\n-# CHECK-NEXT: {{^\\-.b.a.r.}}\n-# CHECK-NEXT: {{^\\-.b.a.z.$}}\n-# CHECK-NEXT: +foo\n-# CHECK-NEXT: +bar\n-# CHECK-NEXT: +baz\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"-\"\n-# CHECK-NOT: error\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf16\" \"-\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^ .f.o.o.$}}\n-# CHECK-NEXT: {{^-.b.a.r.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^ .b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n+#     CHECK: cat diff-in.bin | diff -u diff-in.bin -\n # CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf8\" \"-\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: -baz\n-# CHECK-NEXT: {{^\\+.f.o.o.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^\\+.b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"diff-in.utf8\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^\\-.f.o.o.$}}\n-# CHECK-NEXT: {{^\\-.b.a.r.}}\n-# CHECK-NEXT: {{^\\-.b.a.z.$}}\n-# CHECK-NEXT: +foo\n-# CHECK-NEXT: +bar\n-# CHECK-NEXT: +baz\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n \n-# CHECK: $ \"false\"\n+#      CHECK: cat diff-in.bin | diff -u diff-in.utf16 - && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf16 -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat diff-in.bin | diff -u diff-in.utf8 - && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf8 -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | -baz\n+# CHECK-NEXT: # | {{\\+.f.o.o.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{\\+.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat diff-in.bin | diff -u - diff-in.utf8 && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u - diff-in.utf8\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{-.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.}}\n+# CHECK-NEXT: # | {{-.b.a.z.$}}\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # | +baz\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-1.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-B\" \"temp1.txt\" \"temp2.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'diff': option -B not recognized\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -B temp1.txt temp2.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'diff': option -B not recognized\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-2.txt' FAILED ***\n-# CHECK: $ \"diff\" \"temp.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff temp.txt \n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-3.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-3.txt' FAILED ***\n-# CHECK: $ \"diff\" \"temp.txt\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'diff' command failed\n+# CHECK: diff temp.txt temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'diff' command failed\n # CHECK: error: command failed with exit status: 1\n # CHECK: ***\n \n-# CHECK: FAIL: shtest-shell :: diff-error-4.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-error-4.txt' FAILED ***\n-# CHECK: Exit Code: 1\n-# CHECK: # command output:\n-# CHECK: diff-error-4.txt.tmp\n-# CHECK: diff-error-4.txt.tmp1\n-# CHECK: *** 1 ****\n-# CHECK: ! hello-first\n-# CHECK: --- 1 ----\n-# CHECK: ! hello-second\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-error-4.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-error-4.txt' FAILED ***\n+#      CHECK: Exit Code: 1\n+#      CHECK: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | {{.*}}diff-error-4.txt.tmp\n+# CHECK-NEXT: # | {{.*}}diff-error-4.txt.tmp1\n+# CHECK-NEXT: # | {{\\*+}}\n+# CHECK-NEXT: # | *** 1 ****\n+# CHECK-NEXT: # | ! hello-first\n+# CHECK-NEXT: # | --- 1 ----\n+# CHECK-NEXT: # | ! hello-second\n+# CHECK-NEXT: # `---{{-*}}\n+#      CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-5.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-5.txt' FAILED ***\n-# CHECK: $ \"diff\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-6.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-6.txt' FAILED ***\n-# CHECK: $ \"diff\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n \n@@ -223,137 +233,130 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-pipes.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.foo\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"FileCheck\"\n+# CHECK: diff {{[^ ]*}}.foo {{.*}}.foo | FileCheck {{.*}}\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: note: command had no output on stdout or stderr\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"FileCheck\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"true\"\n+#      CHECK: diff -u {{.*}}.foo {{.*}}.bar | FileCheck {{.*}} && false || true\n+# CHECK-NEXT: # executed command: diff -u {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # note: command had no output on stdout or stderr\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: FileCheck\n+# CHECK-NEXT: # executed command: true\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"{{[^\"]*}}.foo\"\n+#     CHECK: cat {{.*}}.foo | diff -u - {{.*}}.foo\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n+#     CHECK: cat {{.*}}.foo | diff -u {{.*}}.foo -\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: +bar\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"{{[^\"]*}}.foo\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: +foo\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-\" \"{{[^\"]*}}.foo\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"FileCheck\"\n+#      CHECK: cat {{.*}}.bar | diff -u {{.*}}.foo - && false || true\n+# CHECK-NEXT: # executed command: cat {{.*}}.bar\n+# CHECK-NEXT: # executed command: diff -u {{.*}}.foo -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat {{.*}}.bar | diff -u - {{.*}}.foo && false || true\n+# CHECK-NEXT: # executed command: cat {{.*}}.bar\n+# CHECK-NEXT: # executed command: diff -u - {{.*}}.foo\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#     CHECK: cat {{.*}}.foo | diff - {{.*}}.foo | FileCheck {{.*}}\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n-# CHECK: note: command had no output on stdout or stderr\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"FileCheck\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"true\"\n+#      CHECK: cat {{.*}}.bar | diff -u {{.*}}.foo - | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: cat {{.*}}.bar\n+# CHECK-NEXT: # executed command: diff -u {{.*}}.foo -\n+# CHECK-NEXT: note: command had no output on stdout or stderr\n+# CHECK-NEXT: error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: FileCheck\n+# CHECK-NEXT: # executed command: true\n \n-# CHECK: $ \"false\"\n+# CHECK: false\n \n # CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-r-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-0.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: dir1unique\n-# CHECK: Only in {{.*}}dir2: dir2unique\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: dir1unique\n+# CHECK: # | Only in {{.*}}dir2: dir2unique\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-1.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: *** {{.*}}dir1{{.*}}subdir{{.*}}f01\n-# CHECK: --- {{.*}}dir2{{.*}}subdir{{.*}}f01\n-# CHECK: 12345\n-# CHECK: 00000\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | *** {{.*}}dir1{{.*}}subdir{{.*}}f01\n+# CHECK: # | --- {{.*}}dir2{{.*}}subdir{{.*}}f01\n+# CHECK: # | ! 12345\n+# CHECK: # | ! 00000\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-2.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir2: extrafile\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir2: extrafile\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-3.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-3.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: extra_subdir\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: extra_subdir\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-4.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-4.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: File {{.*}}dir1{{.*}}extra_subdir is a directory while file {{.*}}dir2{{.*}}extra_subdir is a regular file\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | File {{.*}}dir1{{.*}}extra_subdir is a directory while file {{.*}}dir2{{.*}}extra_subdir is a regular file\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-5.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-5.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: extra_subdir\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: extra_subdir\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-6.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-6.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: File {{.*}}dir1{{.*}}extra_file is a regular empty file while file {{.*}}dir2{{.*}}extra_file is a directory\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | File {{.*}}dir1{{.*}}extra_file is a regular empty file while file {{.*}}dir2{{.*}}extra_file is a directory\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-7.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-7.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\" \"-\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: cannot recursively compare '-'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r - {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: cannot recursively compare '-'\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-8.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-8.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\" \"{{[^\"]*}}\" \"-\"\n-# CHECK: # command stderr:\n-# CHECK: Error: cannot recursively compare '-'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r {{.*}} -\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: cannot recursively compare '-'\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: PASS: shtest-shell :: diff-r.txt\n \n@@ -362,51 +365,59 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-strip-trailing-cr.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.dos\" \"diff-in.unix\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -In this file, the\n-# CHECK-NEXT: -sequence \"\\r\\n\"\n-# CHECK-NEXT: -terminates lines.\n-# CHECK-NEXT: +In this file, the\n-# CHECK-NEXT: +sequence \"\\n\"\n-# CHECK-NEXT: +terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.unix\" \"diff-in.dos\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -In this file, the\n-# CHECK-NEXT: -sequence \"\\n\"\n-# CHECK-NEXT: -terminates lines.\n-# CHECK-NEXT: +In this file, the\n-# CHECK-NEXT: +sequence \"\\r\\n\"\n-# CHECK-NEXT: +terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"--strip-trailing-cr\" \"diff-in.dos\" \"diff-in.unix\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT:  In this file, the\n-# CHECK-NEXT: -sequence \"\\r\\n\"\n-# CHECK-NEXT: +sequence \"\\n\"\n-# CHECK-NEXT:  terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"--strip-trailing-cr\" \"diff-in.unix\" \"diff-in.dos\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT:  In this file, the\n-# CHECK-NEXT: -sequence \"\\n\"\n-# CHECK-NEXT: +sequence \"\\r\\n\"\n-# CHECK-NEXT:  terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"false\"\n+#      CHECK: diff -u diff-in.dos diff-in.unix && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.dos diff-in.unix\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -In this file, the\n+# CHECK-NEXT: # | -sequence \"\\r\\n\"\n+# CHECK-NEXT: # | -terminates lines.\n+# CHECK-NEXT: # | +In this file, the\n+# CHECK-NEXT: # | +sequence \"\\n\"\n+# CHECK-NEXT: # | +terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.unix diff-in.dos && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.unix diff-in.dos\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -In this file, the\n+# CHECK-NEXT: # | -sequence \"\\n\"\n+# CHECK-NEXT: # | -terminates lines.\n+# CHECK-NEXT: # | +In this file, the\n+# CHECK-NEXT: # | +sequence \"\\r\\n\"\n+# CHECK-NEXT: # | +terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u --strip-trailing-cr diff-in.dos diff-in.unix && false || true\n+# CHECK-NEXT: executed command: diff -u --strip-trailing-cr diff-in.dos diff-in.unix\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # |  In this file, the\n+# CHECK-NEXT: # | -sequence \"\\r\\n\"\n+# CHECK-NEXT: # | +sequence \"\\n\"\n+# CHECK-NEXT: # |  terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u --strip-trailing-cr diff-in.unix diff-in.dos && false || true\n+# CHECK-NEXT: # executed command: diff -u --strip-trailing-cr diff-in.unix diff-in.dos\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # |  In this file, the\n+# CHECK-NEXT: # | -sequence \"\\n\"\n+# CHECK-NEXT: # | +sequence \"\\r\\n\"\n+# CHECK-NEXT: # |  terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n@@ -415,106 +426,144 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-unified.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 3\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-NEXT: 9\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U\" \"2\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U4\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 2\n-# CHECK-NEXT: 3\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-NEXT: 9\n-# CHECK-NEXT: 10\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U0\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U\" \"30.1\" \"{{[^\"]*}}\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: invalid '-U' argument: 30.1\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U-1\" \"{{[^\"]*}}\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: invalid '-U' argument: -1\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"false\"\n+#      CHECK: diff -u {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -u {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 3\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # | 9\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U 2 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U 2 {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U4 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U4 {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 2\n+# CHECK-NEXT: # | 3\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # | 9\n+# CHECK-NEXT: # | 10\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U0 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: diff -U0 {{.*}}.foo {{.*}}.bar\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: diff -U 30.1 {{.*}} {{.*}} && false || true\n+# CHECK: # executed command: diff -U 30.1 {{.*}} {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: invalid '-U' argument: 30.1\n+# CHECK: # error: command failed with exit status: 1\n+# CHECK: # executed command: true\n+\n+# CHECK: diff -U-1 {{.*}} {{.*}} && false || true\n+# CHECK: # executed command: diff -U-1 {{.*}} {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: invalid '-U' argument: -1\n+# CHECK: # error: command failed with exit status: 1\n+# CHECK: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n \n-# CHECK: FAIL: shtest-shell :: diff-w.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-w.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-w\" \"{{[^\"]*}}.0\" \"{{[^\"]*}}.1\"\n-# CHECK: # command output:\n-# CHECK: 1,3\n-# CHECK-NEXT: {{^  }}foo\n-# CHECK-NEXT: {{^  }}bar\n-# CHECK-NEXT: ! baz\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: {{^  }}foo\n-# CHECK-NEXT: {{^  }}bar\n-# CHECK-NEXT: ! bat\n-# CHECK-EMPTY:\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-w.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-w.txt' FAILED ***\n+#      CHECK: diff -w {{.*}}.0 {{.*}}.1\n+#      CHECK: # .---command stdout{{-*}}\n+#      CHECK: # | {{\\*+}} 1,3\n+# CHECK-NEXT: # |   foo\n+# CHECK-NEXT: # |   bar\n+# CHECK-NEXT: # | ! baz\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # |   foo\n+# CHECK-NEXT: # |   bar\n+# CHECK-NEXT: # | ! bat\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+#      CHECK: ***\n+\n+# CHECK: FAIL: shtest-shell :: echo-at-redirect-stderr.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-at-redirect-stderr.txt' FAILED ***\n+# CHECK: @echo 2> {{.*}}\n+# CHECK: # executed command: @echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for @echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-at-redirect-stdin.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-at-redirect-stdin.txt' FAILED ***\n+# CHECK: @echo < {{.*}}\n+# CHECK: # executed command: @echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for @echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-redirect-stderr.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-redirect-stderr.txt' FAILED ***\n+# CHECK: echo 2> {{.*}}\n+# CHECK: # executed command: echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-redirect-stdin.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-redirect-stdin.txt' FAILED ***\n+# CHECK: echo < {{.*}}\n+# CHECK: # executed command: echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for echo\n+# CHECK: error: command failed with exit status:\n \n # CHECK: FAIL: shtest-shell :: error-0.txt\n # CHECK: *** TEST 'shtest-shell :: error-0.txt' FAILED ***\n-# CHECK: $ \"not-a-real-command\"\n-# CHECK: # command stderr:\n-# CHECK: 'not-a-real-command': command not found\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: not-a-real-command\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | 'not-a-real-command': command not found\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # FIXME: The output here sucks.\n #\n # CHECK: FAIL: shtest-shell :: error-1.txt\n # CHECK: *** TEST 'shtest-shell :: error-1.txt' FAILED ***\n-# CHECK: shell parser error on: ': \\'RUN: at line 3\\'; echo \"missing quote'\n+# CHECK: shell parser error on RUN: at line 3: echo \"missing quote\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: error-2.txt\n@@ -524,52 +573,52 @@\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-0.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'mkdir' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p temp | rm -rf temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'mkdir' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-1.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\" \"-m\" \"777\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'mkdir': option -m not recognized\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p -m 777 temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'mkdir': option -m not recognized\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-2.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'mkdir' is missing an operand\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'mkdir' is missing an operand\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: PASS: shtest-shell :: redirects.txt\n \n # CHECK: FAIL: shtest-shell :: rm-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-0.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-rf\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'rm' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: rm -rf temp | echo \"hello\"\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'rm' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-1.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-f\" \"-v\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'rm': option -v not recognized\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: rm -f -v temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'rm': option -v not recognized\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-2.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-r\" \"hello\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'rm' command failed\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: rm -r hello\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'rm' command failed\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-3.txt\n@@ -581,16 +630,17 @@\n # CHECK: PASS: shtest-shell :: sequencing-0.txt\n # CHECK: XFAIL: shtest-shell :: sequencing-1.txt\n \n-# CHECK: FAIL: shtest-shell :: stdout-encoding.txt\n-# CHECK: *** TEST 'shtest-shell :: stdout-encoding.txt' FAILED ***\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: {{^.f.o.o.$}}\n-# CHECK-NEXT: {{^.b.a.r.}}\n-# CHECK-NEXT: {{^.b.a.z.$}}\n-# CHECK-NOT: error\n-# CHECK: $ \"false\"\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: stdout-encoding.txt\n+#      CHECK: *** TEST 'shtest-shell :: stdout-encoding.txt' FAILED ***\n+#      CHECK: cat diff-in.bin\n+#      CHECK: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+#  CHECK-NOT: error\n+#      CHECK: false\n+#      CHECK: ***\n \n # CHECK: PASS: shtest-shell :: valid-shell.txt\n-# CHECK: Failed Tests (35)\n+# CHECK: Failed Tests (39)\n", "message": "", "files": {"/libcxx/utils/libcxx/test/dsl.py": {"changes": [{"diff": "\n                 \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n             )\n \n-        return libcxx.test.format._parseLitOutput(out)\n+        return out\n \n \n @_memoizeExpensiveOperation(", "add": 1, "remove": 1, "filename": "/libcxx/utils/libcxx/test/dsl.py", "badparts": ["        return libcxx.test.format._parseLitOutput(out)"], "goodparts": ["        return out"]}], "source": "\n import os import pickle import pipes import platform import re import shutil import subprocess import tempfile import libcxx.test.format import lit import lit.LitConfig import lit.Test import lit.TestRunner import lit.util class ConfigurationError(Exception): pass class ConfigurationCompilationError(ConfigurationError): pass class ConfigurationRuntimeError(ConfigurationError): pass def _memoizeExpensiveOperation(extractCacheKey): \"\"\" Allows memoizing a very expensive operation. We pickle the cache key to make sure we store an immutable representation of it. If we stored an object and the object was referenced elsewhere, it could be changed from under our feet, which would break the cache. We also store the cache for a given function persistently across invocations of Lit. This dramatically speeds up the configuration of the test suite when invoking Lit repeatedly, which is important for developer workflow. However, with the current implementation that does not synchronize updates to the persistent cache, this also means that one should not call a memoized operation from multiple threads. This should normally not be a problem since Lit configuration is single-threaded. \"\"\" def decorator(function): def f(config, *args, **kwargs): cacheRoot=os.path.join(config.test_exec_root, \"__config_cache__\") persistentCache=os.path.join(cacheRoot, function.__name__) if not os.path.exists(cacheRoot): os.makedirs(cacheRoot) cache={} if os.path.exists(persistentCache): with open(persistentCache, \"rb\") as cacheFile: cache=pickle.load(cacheFile) cacheKey=pickle.dumps(extractCacheKey(config, *args, **kwargs)) if cacheKey not in cache: cache[cacheKey]=function(config, *args, **kwargs) with open(persistentCache, \"wb\") as cacheFile: pickle.dump(cache, cacheFile) return cache[cacheKey] return f return decorator def _executeWithFakeConfig(test, commands): \"\"\" Returns(stdout, stderr, exitCode, timeoutInfo, parsedCommands) \"\"\" litConfig=lit.LitConfig.LitConfig( progname=\"lit\", path=[], quiet=False, useValgrind=False, valgrindLeakCheck=False, valgrindArgs=[], noExecute=False, debug=False, isWindows=platform.system()==\"Windows\", order=\"smart\", params={}, ) return libcxx.test.format._executeScriptInternal(test, litConfig, commands) def _makeConfigTest(config): sourceRoot=os.path.join(config.test_exec_root, \"__config_src__\") execRoot=os.path.join(config.test_exec_root, \"__config_exec__\") for supportDir in(sourceRoot, execRoot): if not os.path.exists(supportDir): os.makedirs(supportDir) suite=lit.Test.TestSuite(\"__config__\", sourceRoot, execRoot, config) tmp=tempfile.NamedTemporaryFile(dir=sourceRoot, delete=False, suffix=\".cpp\") tmp.close() pathInSuite=[os.path.relpath(tmp.name, sourceRoot)] class TestWrapper(lit.Test.Test): def __enter__(self): testDir, _=libcxx.test.format._getTempPaths(self) os.makedirs(testDir) return self def __exit__(self, *args): testDir, _=libcxx.test.format._getTempPaths(self) shutil.rmtree(testDir) os.remove(tmp.name) return TestWrapper(suite, pathInSuite, config) @_memoizeExpensiveOperation(lambda c, s, f=[]:(c.substitutions, c.environment, s, f)) def sourceBuilds(config, source, additionalFlags=[]): \"\"\" Return whether the program in the given string builds successfully. This is done by compiling and linking a program that consists of the given source with the %{cxx} substitution, and seeing whether that succeeds. If any additional flags are passed, they are appended to the compiler invocation. \"\"\" with _makeConfigTest(config) as test: with open(test.getSourcePath(), \"w\") as sourceFile: sourceFile.write(source) _, _, exitCode, _, _=_executeWithFakeConfig( test,[\"%{{build}}{}\".format(\" \".join(additionalFlags))] ) return exitCode==0 @_memoizeExpensiveOperation( lambda c, p, args=None:(c.substitutions, c.environment, p, args) ) def programOutput(config, program, args=None): \"\"\" Compiles a program for the test target, run it on the test target and return the output. Note that execution of the program is done through the %{exec} substitution, which means that the program may be run on a remote host depending on what %{exec} does. \"\"\" if args is None: args=[] with _makeConfigTest(config) as test: with open(test.getSourcePath(), \"w\") as source: source.write(program) _, err, exitCode, _, buildcmd=_executeWithFakeConfig(test,[\"%{build}\"]) if exitCode !=0: raise ConfigurationCompilationError( \"Failed to build program, cmd:\\n{}\\nstderr is:\\n{}\".format( buildcmd, err ) ) out, err, exitCode, _, runcmd=_executeWithFakeConfig( test,[\"%{{run}}{}\".format(\" \".join(args))] ) if exitCode !=0: raise ConfigurationRuntimeError( \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err) ) return libcxx.test.format._parseLitOutput(out) @_memoizeExpensiveOperation( lambda c, p, args=None:(c.substitutions, c.environment, p, args) ) def programSucceeds(config, program, args=None): \"\"\" Compiles a program for the test target, run it on the test target and return whether it completed successfully. Note that execution of the program is done through the %{exec} substitution, which means that the program may be run on a remote host depending on what %{exec} does. \"\"\" try: programOutput(config, program, args) except ConfigurationRuntimeError: return False return True @_memoizeExpensiveOperation(lambda c, f:(c.substitutions, c.environment, f)) def hasCompileFlag(config, flag): \"\"\" Return whether the compiler in the configuration supports a given compiler flag. This is done by executing the %{cxx} substitution with the given flag and checking whether that succeeds. \"\"\" with _makeConfigTest(config) as test: out, err, exitCode, timeoutInfo, _=_executeWithFakeConfig( test, [ \"%{{cxx}} -xc++{} -Werror -fsyntax-only %{{flags}} %{{compile_flags}}{}\".format( os.devnull, flag ) ], ) return exitCode==0 @_memoizeExpensiveOperation(lambda c, s:(c.substitutions, c.environment, s)) def runScriptExitCode(config, script): \"\"\" Runs the given script as a Lit test, and returns the exit code of the execution. The script must be a list of commands, each of which being something that could appear on the right-hand-side of a `RUN:` keyword. \"\"\" with _makeConfigTest(config) as test: _, _, exitCode, _, _=_executeWithFakeConfig(test, script) return exitCode @_memoizeExpensiveOperation(lambda c, s:(c.substitutions, c.environment, s)) def commandOutput(config, command): \"\"\" Runs the given script as a Lit test, and returns the output. If the exit code isn't 0 an exception is raised. The script must be a list of commands, each of which being something that could appear on the right-hand-side of a `RUN:` keyword. \"\"\" with _makeConfigTest(config) as test: out, err, exitCode, _, cmd=_executeWithFakeConfig(test, command) if exitCode !=0: raise ConfigurationRuntimeError( \"Failed to run command:{}\\nstderr is:\\n{}\".format(cmd, err) ) return out @_memoizeExpensiveOperation(lambda c, l:(c.substitutions, c.environment, l)) def hasAnyLocale(config, locales): \"\"\" Return whether the runtime execution environment supports a given locale. Different systems may use different names for a locale, so this function checks whether any of the passed locale names is supported by setlocale() and returns true if one of them works. This is done by executing a program that tries to set the given locale using %{exec} --this means that the command may be executed on a remote host depending on the %{exec} substitution. \"\"\" program=\"\"\" int main(int, char**){ return 1;} int main(int argc, char** argv){ for(int i=1; i < argc; i++){ if(::setlocale(LC_ALL, argv[i]) !=NULL){ return 0; } } return 1; } \"\"\" return programSucceeds(config, program, args=[pipes.quote(l) for l in locales]) @_memoizeExpensiveOperation(lambda c, flags=\"\":(c.substitutions, c.environment, flags)) def compilerMacros(config, flags=\"\"): \"\"\" Return a dictionary of predefined compiler macros. The keys are strings representing macros, and the values are strings representing what each macro is defined to. If the optional `flags` argument(a string) is provided, these flags will be added to the compiler invocation when generating the macros. \"\"\" with _makeConfigTest(config) as test: with open(test.getSourcePath(), \"w\") as sourceFile: sourceFile.write( \"\"\" \"\"\" ) unparsedOutput, err, exitCode, _, cmd=_executeWithFakeConfig( test,[\"%{{cxx}} %s -dM -E %{{flags}} %{{compile_flags}}{}\".format(flags)] ) if exitCode !=0: raise ConfigurationCompilationError( \"Failed to retrieve compiler macros, compiler invocation is:\\n{}\\nstderr is:\\n{}\".format( cmd, err ) ) parsedMacros=dict() defines=( l.strip() for l in unparsedOutput.split(\"\\n\") if l.startswith(\" ) for line in defines: line=line[len(\" macro, _, value=line.partition(\" \") parsedMacros[macro]=value return parsedMacros def featureTestMacros(config, flags=\"\"): \"\"\" Return a dictionary of feature test macros. The keys are strings representing feature test macros, and the values are integers representing the value of the macro. \"\"\" allMacros=compilerMacros(config, flags) return{ m: int(v.rstrip(\"LlUu\")) for(m, v) in allMacros.items() if m.startswith(\"__cpp_\") } def _getSubstitution(substitution, config): for(orig, replacement) in config.substitutions: if orig==substitution: return replacement raise ValueError('Substitution{} is not in the config.'.format(substitution)) def _appendToSubstitution(substitutions, key, value): return[(k, v +\" \" +value) if k==key else(k, v) for(k, v) in substitutions] def _prependToSubstitution(substitutions, key, value): return[(k, value +\" \" +v) if k==key else(k, v) for(k, v) in substitutions] class ConfigAction(object): \"\"\" This class represents an action that can be performed on a Lit TestingConfig object. Examples of such actions are adding or modifying substitutions, Lit features, etc. This class only provides the interface of such actions, and it is meant to be subclassed appropriately to create new actions. \"\"\" def applyTo(self, config): \"\"\" Applies the action to the given configuration. This should modify the configuration object in place, and return nothing. If applying the action to the configuration would yield an invalid configuration, and it is possible to diagnose it here, this method should produce an error. For example, it should be an error to modify a substitution in a way that we know for sure is invalid(e.g. adding a compiler flag when we know the compiler doesn't support it). Failure to do so early may lead to difficult-to-diagnose issues down the road. \"\"\" pass def pretty(self, config, litParams): \"\"\" Returns a short and human-readable string describing what this action does. This is used for logging purposes when running the test suite, so it should be kept concise. \"\"\" pass class AddFeature(ConfigAction): \"\"\" This action defines the given Lit feature when running the test suite. The name of the feature can be a string or a callable, in which case it is called with the configuration to produce the feature name(as a string). \"\"\" def __init__(self, name): self._name=name def _getName(self, config): name=self._name(config) if callable(self._name) else self._name if not isinstance(name, str): raise ValueError( \"Lit feature did not resolve to a string(got{})\".format(name) ) return name def applyTo(self, config): config.available_features.add(self._getName(config)) def pretty(self, config, litParams): return \"add Lit feature{}\".format(self._getName(config)) class AddFlag(ConfigAction): \"\"\" This action adds the given flag to the %{flags} substitution. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) assert hasCompileFlag( config, flag ), \"Trying to enable flag{}, which is not supported\".format(flag) config.substitutions=_appendToSubstitution( config.substitutions, \"%{flags}\", flag ) def pretty(self, config, litParams): return \"add{} to %{{flags}}\".format(self._getFlag(config)) class AddFlagIfSupported(ConfigAction): \"\"\" This action adds the given flag to the %{flags} substitution, only if the compiler supports the flag. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) if hasCompileFlag(config, flag): config.substitutions=_appendToSubstitution( config.substitutions, \"%{flags}\", flag ) def pretty(self, config, litParams): return \"add{} to %{{flags}}\".format(self._getFlag(config)) class AddCompileFlag(ConfigAction): \"\"\" This action adds the given flag to the %{compile_flags} substitution. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) assert hasCompileFlag( config, flag ), \"Trying to enable compile flag{}, which is not supported\".format(flag) config.substitutions=_appendToSubstitution( config.substitutions, \"%{compile_flags}\", flag ) def pretty(self, config, litParams): return \"add{} to %{{compile_flags}}\".format(self._getFlag(config)) class AddLinkFlag(ConfigAction): \"\"\" This action appends the given flag to the %{link_flags} substitution. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) assert hasCompileFlag( config, flag ), \"Trying to enable link flag{}, which is not supported\".format(flag) config.substitutions=_appendToSubstitution( config.substitutions, \"%{link_flags}\", flag ) def pretty(self, config, litParams): return \"append{} to %{{link_flags}}\".format(self._getFlag(config)) class PrependLinkFlag(ConfigAction): \"\"\" This action prepends the given flag to the %{link_flags} substitution. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) assert hasCompileFlag( config, flag ), \"Trying to enable link flag{}, which is not supported\".format(flag) config.substitutions=_prependToSubstitution( config.substitutions, \"%{link_flags}\", flag ) def pretty(self, config, litParams): return \"prepend{} to %{{link_flags}}\".format(self._getFlag(config)) class AddOptionalWarningFlag(ConfigAction): \"\"\" This action adds the given warning flag to the %{compile_flags} substitution, if it is supported by the compiler. The flag can be a string or a callable, in which case it is called with the configuration to produce the actual flag(as a string). \"\"\" def __init__(self, flag): self._getFlag=lambda config: flag(config) if callable(flag) else flag def applyTo(self, config): flag=self._getFlag(config) if hasCompileFlag(config, \"-Werror \" +flag): config.substitutions=_appendToSubstitution( config.substitutions, \"%{compile_flags}\", flag ) def pretty(self, config, litParams): return \"add{} to %{{compile_flags}}\".format(self._getFlag(config)) class AddSubstitution(ConfigAction): \"\"\" This action adds the given substitution to the Lit configuration. The substitution can be a string or a callable, in which case it is called with the configuration to produce the actual substitution(as a string). \"\"\" def __init__(self, key, substitution): self._key=key self._getSub=( lambda config: substitution(config) if callable(substitution) else substitution ) def applyTo(self, config): key=self._key sub=self._getSub(config) config.substitutions.append((key, sub)) def pretty(self, config, litParams): return \"add substitution{}={}\".format(self._key, self._getSub(config)) class Feature(object): \"\"\" Represents a Lit available feature that is enabled whenever it is supported. A feature like this informs the test suite about a capability of the compiler, platform, etc. Unlike Parameters, it does not make sense to explicitly control whether a Feature is enabled --it should be enabled whenever it is supported. \"\"\" def __init__(self, name, actions=None, when=lambda _: True): \"\"\" Create a Lit feature for consumption by a test suite. -name The name of the feature. This is what will end up in Lit's available features if the feature is enabled. This can be either a string or a callable, in which case it is passed the TestingConfig and should generate a string representing the name of the feature. -actions An optional list of ConfigActions to apply when the feature is supported. An AddFeature action is always created regardless of any actions supplied here --these actions are meant to perform more than setting a corresponding Lit feature(e.g. adding compiler flags). If 'actions' is a callable, it is called with the current configuration object to generate the actual list of actions. -when A callable that gets passed a TestingConfig and should return a boolean representing whether the feature is supported in that configuration. For example, this can use `hasCompileFlag` to check whether the compiler supports the flag that the feature represents. If omitted, the feature will always be considered supported. \"\"\" self._name=name self._actions=[] if actions is None else actions self._isSupported=when def _getName(self, config): name=self._name(config) if callable(self._name) else self._name if not isinstance(name, str): raise ValueError( \"Feature did not resolve to a name that's a string, got{}\".format(name) ) return name def getActions(self, config): \"\"\" Return the list of actions associated to this feature. If the feature is not supported, an empty list is returned. If the feature is supported, an `AddFeature` action is automatically added to the returned list of actions, in addition to any actions provided on construction. \"\"\" if not self._isSupported(config): return[] else: actions=( self._actions(config) if callable(self._actions) else self._actions ) return[AddFeature(self._getName(config))] +actions def pretty(self, config): \"\"\" Returns the Feature's name. \"\"\" return self._getName(config) def _str_to_bool(s): \"\"\" Convert a string value to a boolean. True values are \"y\", \"yes\", \"t\", \"true\", \"on\" and \"1\", regardless of capitalization. False values are \"n\", \"no\", \"f\", \"false\", \"off\" and \"0\", regardless of capitalization. \"\"\" trueVals=[\"y\", \"yes\", \"t\", \"true\", \"on\", \"1\"] falseVals=[\"n\", \"no\", \"f\", \"false\", \"off\", \"0\"] lower=s.lower() if lower in trueVals: return True elif lower in falseVals: return False else: raise ValueError(\"Got string '{}', which isn't a valid boolean\".format(s)) def _parse_parameter(s, type): if type is bool and isinstance(s, str): return _str_to_bool(s) elif type is list and isinstance(s, str): return[x.strip() for x in s.split(\",\") if x.strip()] return type(s) class Parameter(object): \"\"\" Represents a parameter of a Lit test suite. Parameters are used to customize the behavior of test suites in a user controllable way. There are two ways of setting the value of a Parameter. The first one is to pass `--param <KEY>=<VALUE>` when running Lit(or equivalently to set `litConfig.params[KEY]=VALUE` somewhere in the Lit configuration files. This method will set the parameter globally for all test suites being run. The second method is to set `config.KEY=VALUE` somewhere in the Lit configuration files, which sets the parameter only for the test suite(s) that use that `config` object. Parameters can have multiple possible values, and they can have a default value when left unspecified. They can also have any number of ConfigActions associated to them, in which case the actions will be performed on the TestingConfig if the parameter is enabled. Depending on the actions associated to a Parameter, it may be an error to enable the Parameter if some actions are not supported in the given configuration. For example, trying to set the compilation standard to C++23 when `-std=c++23` is not supported by the compiler would be an error. \"\"\" def __init__(self, name, type, help, actions, choices=None, default=None): \"\"\" Create a Lit parameter to customize the behavior of a test suite. -name The name of the parameter that can be used to set it on the command-line. On the command-line, the parameter can be set using `--param <name>=<value>` when running Lit. This must be non-empty. -choices An optional non-empty set of possible values for this parameter. If provided, this must be anything that can be iterated. It is an error if the parameter is given a value that is not in that set, whether explicitly or through a default value. -type A callable that can be used to parse the value of the parameter given on the command-line. As a special case, using the type `bool` also allows parsing strings with boolean-like contents, and the type `list` will parse a string delimited by commas into a list of the substrings. -help A string explaining the parameter, for documentation purposes. TODO: We should be able to surface those from the Lit command-line. -actions A callable that gets passed the parsed value of the parameter(either the one passed on the command-line or the default one), and that returns a list of ConfigAction to perform given the value of the parameter. All the ConfigAction must be supported in the given configuration. -default An optional default value to use for the parameter when no value is provided on the command-line. If the default value is a callable, it is called with the TestingConfig and should return the default value for the parameter. Whether the default value is computed or specified directly, it must be in the 'choices' provided for that Parameter. \"\"\" self._name=name if len(self._name)==0: raise ValueError(\"Parameter name must not be the empty string\") if choices is not None: self._choices=list(choices) if len(self._choices)==0: raise ValueError( \"Parameter '{}' must be given at least one possible value\".format( self._name ) ) else: self._choices=None self._parse=lambda x: _parse_parameter(x, type) self._help=help self._actions=actions self._default=default def _getValue(self, config, litParams): \"\"\" Return the value of the parameter given the configuration objects. \"\"\" param=getattr(config, self.name, None) param=litParams.get(self.name, param) if param is None and self._default is None: raise ValueError( \"Parameter{} doesn't have a default value, but it was not specified in the Lit parameters or in the Lit config\".format( self.name ) ) getDefault=( lambda: self._default(config) if callable(self._default) else self._default ) if param is not None: (pretty, value)=(param, self._parse(param)) else: value=getDefault() pretty=\"{}(default)\".format(value) if self._choices and value not in self._choices: raise ValueError( \"Got value '{}' for parameter '{}', which is not in the provided set of possible choices:{}\".format( value, self.name, self._choices ) ) return(pretty, value) @property def name(self): \"\"\" Return the name of the parameter. This is the name that can be used to set the parameter on the command-line when running Lit. \"\"\" return self._name def getActions(self, config, litParams): \"\"\" Return the list of actions associated to this value of the parameter. \"\"\" (_, parameterValue)=self._getValue(config, litParams) return self._actions(parameterValue) def pretty(self, config, litParams): \"\"\" Return a pretty representation of the parameter's name and value. \"\"\" (prettyParameterValue, _)=self._getValue(config, litParams) return \"{}={}\".format(self.name, prettyParameterValue) ", "sourceWithComments": "# ===----------------------------------------------------------------------===##\n#\n# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n# See https://llvm.org/LICENSE.txt for license information.\n# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n#\n# ===----------------------------------------------------------------------===##\n\nimport os\nimport pickle\nimport pipes\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport tempfile\n\nimport libcxx.test.format\nimport lit\nimport lit.LitConfig\nimport lit.Test\nimport lit.TestRunner\nimport lit.util\n\n\nclass ConfigurationError(Exception):\n    pass\n\n\nclass ConfigurationCompilationError(ConfigurationError):\n    pass\n\n\nclass ConfigurationRuntimeError(ConfigurationError):\n    pass\n\n\ndef _memoizeExpensiveOperation(extractCacheKey):\n    \"\"\"\n    Allows memoizing a very expensive operation.\n\n    We pickle the cache key to make sure we store an immutable representation\n    of it. If we stored an object and the object was referenced elsewhere, it\n    could be changed from under our feet, which would break the cache.\n\n    We also store the cache for a given function persistently across invocations\n    of Lit. This dramatically speeds up the configuration of the test suite when\n    invoking Lit repeatedly, which is important for developer workflow. However,\n    with the current implementation that does not synchronize updates to the\n    persistent cache, this also means that one should not call a memoized\n    operation from multiple threads. This should normally not be a problem\n    since Lit configuration is single-threaded.\n    \"\"\"\n\n    def decorator(function):\n        def f(config, *args, **kwargs):\n            cacheRoot = os.path.join(config.test_exec_root, \"__config_cache__\")\n            persistentCache = os.path.join(cacheRoot, function.__name__)\n            if not os.path.exists(cacheRoot):\n                os.makedirs(cacheRoot)\n\n            cache = {}\n            # Load a cache from a previous Lit invocation if there is one.\n            if os.path.exists(persistentCache):\n                with open(persistentCache, \"rb\") as cacheFile:\n                    cache = pickle.load(cacheFile)\n\n            cacheKey = pickle.dumps(extractCacheKey(config, *args, **kwargs))\n            if cacheKey not in cache:\n                cache[cacheKey] = function(config, *args, **kwargs)\n                # Update the persistent cache so it knows about the new key\n                with open(persistentCache, \"wb\") as cacheFile:\n                    pickle.dump(cache, cacheFile)\n            return cache[cacheKey]\n\n        return f\n\n    return decorator\n\n\ndef _executeWithFakeConfig(test, commands):\n    \"\"\"\n    Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n    \"\"\"\n    litConfig = lit.LitConfig.LitConfig(\n        progname=\"lit\",\n        path=[],\n        quiet=False,\n        useValgrind=False,\n        valgrindLeakCheck=False,\n        valgrindArgs=[],\n        noExecute=False,\n        debug=False,\n        isWindows=platform.system() == \"Windows\",\n        order=\"smart\",\n        params={},\n    )\n    return libcxx.test.format._executeScriptInternal(test, litConfig, commands)\n\n\ndef _makeConfigTest(config):\n    # Make sure the support directories exist, which is needed to create\n    # the temporary file %t below.\n    sourceRoot = os.path.join(config.test_exec_root, \"__config_src__\")\n    execRoot = os.path.join(config.test_exec_root, \"__config_exec__\")\n    for supportDir in (sourceRoot, execRoot):\n        if not os.path.exists(supportDir):\n            os.makedirs(supportDir)\n\n    # Create a dummy test suite and single dummy test inside it. As part of\n    # the Lit configuration, automatically do the equivalent of 'mkdir %T'\n    # and 'rm -r %T' to avoid cluttering the build directory.\n    suite = lit.Test.TestSuite(\"__config__\", sourceRoot, execRoot, config)\n    tmp = tempfile.NamedTemporaryFile(dir=sourceRoot, delete=False, suffix=\".cpp\")\n    tmp.close()\n    pathInSuite = [os.path.relpath(tmp.name, sourceRoot)]\n\n    class TestWrapper(lit.Test.Test):\n        def __enter__(self):\n            testDir, _ = libcxx.test.format._getTempPaths(self)\n            os.makedirs(testDir)\n            return self\n\n        def __exit__(self, *args):\n            testDir, _ = libcxx.test.format._getTempPaths(self)\n            shutil.rmtree(testDir)\n            os.remove(tmp.name)\n\n    return TestWrapper(suite, pathInSuite, config)\n\n\n@_memoizeExpensiveOperation(lambda c, s, f=[]: (c.substitutions, c.environment, s, f))\ndef sourceBuilds(config, source, additionalFlags=[]):\n    \"\"\"\n    Return whether the program in the given string builds successfully.\n\n    This is done by compiling and linking a program that consists of the given\n    source with the %{cxx} substitution, and seeing whether that succeeds. If\n    any additional flags are passed, they are appended to the compiler invocation.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        with open(test.getSourcePath(), \"w\") as sourceFile:\n            sourceFile.write(source)\n        _, _, exitCode, _, _ = _executeWithFakeConfig(\n            test, [\"%{{build}} {}\".format(\" \".join(additionalFlags))]\n        )\n        return exitCode == 0\n\n\n@_memoizeExpensiveOperation(\n    lambda c, p, args=None: (c.substitutions, c.environment, p, args)\n)\ndef programOutput(config, program, args=None):\n    \"\"\"\n    Compiles a program for the test target, run it on the test target and return\n    the output.\n\n    Note that execution of the program is done through the %{exec} substitution,\n    which means that the program may be run on a remote host depending on what\n    %{exec} does.\n    \"\"\"\n    if args is None:\n        args = []\n    with _makeConfigTest(config) as test:\n        with open(test.getSourcePath(), \"w\") as source:\n            source.write(program)\n        _, err, exitCode, _, buildcmd = _executeWithFakeConfig(test, [\"%{build}\"])\n        if exitCode != 0:\n            raise ConfigurationCompilationError(\n                \"Failed to build program, cmd:\\n{}\\nstderr is:\\n{}\".format(\n                    buildcmd, err\n                )\n            )\n\n        out, err, exitCode, _, runcmd = _executeWithFakeConfig(\n            test, [\"%{{run}} {}\".format(\" \".join(args))]\n        )\n        if exitCode != 0:\n            raise ConfigurationRuntimeError(\n                \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n            )\n\n        return libcxx.test.format._parseLitOutput(out)\n\n\n@_memoizeExpensiveOperation(\n    lambda c, p, args=None: (c.substitutions, c.environment, p, args)\n)\ndef programSucceeds(config, program, args=None):\n    \"\"\"\n    Compiles a program for the test target, run it on the test target and return\n    whether it completed successfully.\n\n    Note that execution of the program is done through the %{exec} substitution,\n    which means that the program may be run on a remote host depending on what\n    %{exec} does.\n    \"\"\"\n    try:\n        programOutput(config, program, args)\n    except ConfigurationRuntimeError:\n        return False\n    return True\n\n\n@_memoizeExpensiveOperation(lambda c, f: (c.substitutions, c.environment, f))\ndef hasCompileFlag(config, flag):\n    \"\"\"\n    Return whether the compiler in the configuration supports a given compiler flag.\n\n    This is done by executing the %{cxx} substitution with the given flag and\n    checking whether that succeeds.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        out, err, exitCode, timeoutInfo, _ = _executeWithFakeConfig(\n            test,\n            [\n                \"%{{cxx}} -xc++ {} -Werror -fsyntax-only %{{flags}} %{{compile_flags}} {}\".format(\n                    os.devnull, flag\n                )\n            ],\n        )\n        return exitCode == 0\n\n\n@_memoizeExpensiveOperation(lambda c, s: (c.substitutions, c.environment, s))\ndef runScriptExitCode(config, script):\n    \"\"\"\n    Runs the given script as a Lit test, and returns the exit code of the execution.\n\n    The script must be a list of commands, each of which being something that\n    could appear on the right-hand-side of a `RUN:` keyword.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        _, _, exitCode, _, _ = _executeWithFakeConfig(test, script)\n        return exitCode\n\n\n@_memoizeExpensiveOperation(lambda c, s: (c.substitutions, c.environment, s))\ndef commandOutput(config, command):\n    \"\"\"\n    Runs the given script as a Lit test, and returns the output.\n    If the exit code isn't 0 an exception is raised.\n\n    The script must be a list of commands, each of which being something that\n    could appear on the right-hand-side of a `RUN:` keyword.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        out, err, exitCode, _, cmd = _executeWithFakeConfig(test, command)\n        if exitCode != 0:\n            raise ConfigurationRuntimeError(\n                \"Failed to run command: {}\\nstderr is:\\n{}\".format(cmd, err)\n            )\n        return out\n\n\n@_memoizeExpensiveOperation(lambda c, l: (c.substitutions, c.environment, l))\ndef hasAnyLocale(config, locales):\n    \"\"\"\n    Return whether the runtime execution environment supports a given locale.\n    Different systems may use different names for a locale, so this function checks\n    whether any of the passed locale names is supported by setlocale() and returns\n    true if one of them works.\n\n    This is done by executing a program that tries to set the given locale using\n    %{exec} -- this means that the command may be executed on a remote host\n    depending on the %{exec} substitution.\n    \"\"\"\n    program = \"\"\"\n    #include <stddef.h>\n    #if defined(_LIBCPP_HAS_NO_LOCALIZATION)\n      int main(int, char**) { return 1; }\n    #else\n      #include <locale.h>\n      int main(int argc, char** argv) {\n        for (int i = 1; i < argc; i++) {\n          if (::setlocale(LC_ALL, argv[i]) != NULL) {\n            return 0;\n          }\n        }\n        return 1;\n      }\n    #endif\n  \"\"\"\n    return programSucceeds(config, program, args=[pipes.quote(l) for l in locales])\n\n\n@_memoizeExpensiveOperation(lambda c, flags=\"\": (c.substitutions, c.environment, flags))\ndef compilerMacros(config, flags=\"\"):\n    \"\"\"\n    Return a dictionary of predefined compiler macros.\n\n    The keys are strings representing macros, and the values are strings\n    representing what each macro is defined to.\n\n    If the optional `flags` argument (a string) is provided, these flags will\n    be added to the compiler invocation when generating the macros.\n    \"\"\"\n    with _makeConfigTest(config) as test:\n        with open(test.getSourcePath(), \"w\") as sourceFile:\n            sourceFile.write(\n                \"\"\"\n      #if __has_include(<__config_site>)\n      #  include <__config_site>\n      #endif\n      \"\"\"\n            )\n        unparsedOutput, err, exitCode, _, cmd = _executeWithFakeConfig(\n            test, [\"%{{cxx}} %s -dM -E %{{flags}} %{{compile_flags}} {}\".format(flags)]\n        )\n        if exitCode != 0:\n            raise ConfigurationCompilationError(\n                \"Failed to retrieve compiler macros, compiler invocation is:\\n{}\\nstderr is:\\n{}\".format(\n                    cmd, err\n                )\n            )\n        parsedMacros = dict()\n        defines = (\n            l.strip() for l in unparsedOutput.split(\"\\n\") if l.startswith(\"#define \")\n        )\n        for line in defines:\n            line = line[len(\"#define \") :]\n            macro, _, value = line.partition(\" \")\n            parsedMacros[macro] = value\n        return parsedMacros\n\n\ndef featureTestMacros(config, flags=\"\"):\n    \"\"\"\n    Return a dictionary of feature test macros.\n\n    The keys are strings representing feature test macros, and the values are\n    integers representing the value of the macro.\n    \"\"\"\n    allMacros = compilerMacros(config, flags)\n    return {\n        m: int(v.rstrip(\"LlUu\"))\n        for (m, v) in allMacros.items()\n        if m.startswith(\"__cpp_\")\n    }\n\n\ndef _getSubstitution(substitution, config):\n  for (orig, replacement) in config.substitutions:\n    if orig == substitution:\n      return replacement\n  raise ValueError('Substitution {} is not in the config.'.format(substitution))\n\ndef _appendToSubstitution(substitutions, key, value):\n    return [(k, v + \" \" + value) if k == key else (k, v) for (k, v) in substitutions]\n\n\ndef _prependToSubstitution(substitutions, key, value):\n    return [(k, value + \" \" + v) if k == key else (k, v) for (k, v) in substitutions]\n\n\nclass ConfigAction(object):\n    \"\"\"\n    This class represents an action that can be performed on a Lit TestingConfig\n    object.\n\n    Examples of such actions are adding or modifying substitutions, Lit features,\n    etc. This class only provides the interface of such actions, and it is meant\n    to be subclassed appropriately to create new actions.\n    \"\"\"\n\n    def applyTo(self, config):\n        \"\"\"\n        Applies the action to the given configuration.\n\n        This should modify the configuration object in place, and return nothing.\n\n        If applying the action to the configuration would yield an invalid\n        configuration, and it is possible to diagnose it here, this method\n        should produce an error. For example, it should be an error to modify\n        a substitution in a way that we know for sure is invalid (e.g. adding\n        a compiler flag when we know the compiler doesn't support it). Failure\n        to do so early may lead to difficult-to-diagnose issues down the road.\n        \"\"\"\n        pass\n\n    def pretty(self, config, litParams):\n        \"\"\"\n        Returns a short and human-readable string describing what this action does.\n\n        This is used for logging purposes when running the test suite, so it should\n        be kept concise.\n        \"\"\"\n        pass\n\n\nclass AddFeature(ConfigAction):\n    \"\"\"\n    This action defines the given Lit feature when running the test suite.\n\n    The name of the feature can be a string or a callable, in which case it is\n    called with the configuration to produce the feature name (as a string).\n    \"\"\"\n\n    def __init__(self, name):\n        self._name = name\n\n    def _getName(self, config):\n        name = self._name(config) if callable(self._name) else self._name\n        if not isinstance(name, str):\n            raise ValueError(\n                \"Lit feature did not resolve to a string (got {})\".format(name)\n            )\n        return name\n\n    def applyTo(self, config):\n        config.available_features.add(self._getName(config))\n\n    def pretty(self, config, litParams):\n        return \"add Lit feature {}\".format(self._getName(config))\n\n\nclass AddFlag(ConfigAction):\n    \"\"\"\n    This action adds the given flag to the %{flags} substitution.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        assert hasCompileFlag(\n            config, flag\n        ), \"Trying to enable flag {}, which is not supported\".format(flag)\n        config.substitutions = _appendToSubstitution(\n            config.substitutions, \"%{flags}\", flag\n        )\n\n    def pretty(self, config, litParams):\n        return \"add {} to %{{flags}}\".format(self._getFlag(config))\n\nclass AddFlagIfSupported(ConfigAction):\n    \"\"\"\n    This action adds the given flag to the %{flags} substitution, only if\n    the compiler supports the flag.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        if hasCompileFlag(config, flag):\n            config.substitutions = _appendToSubstitution(\n                config.substitutions, \"%{flags}\", flag\n            )\n\n    def pretty(self, config, litParams):\n        return \"add {} to %{{flags}}\".format(self._getFlag(config))\n\n\nclass AddCompileFlag(ConfigAction):\n    \"\"\"\n    This action adds the given flag to the %{compile_flags} substitution.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        assert hasCompileFlag(\n            config, flag\n        ), \"Trying to enable compile flag {}, which is not supported\".format(flag)\n        config.substitutions = _appendToSubstitution(\n            config.substitutions, \"%{compile_flags}\", flag\n        )\n\n    def pretty(self, config, litParams):\n        return \"add {} to %{{compile_flags}}\".format(self._getFlag(config))\n\n\nclass AddLinkFlag(ConfigAction):\n    \"\"\"\n    This action appends the given flag to the %{link_flags} substitution.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        assert hasCompileFlag(\n            config, flag\n        ), \"Trying to enable link flag {}, which is not supported\".format(flag)\n        config.substitutions = _appendToSubstitution(\n            config.substitutions, \"%{link_flags}\", flag\n        )\n\n    def pretty(self, config, litParams):\n        return \"append {} to %{{link_flags}}\".format(self._getFlag(config))\n\n\nclass PrependLinkFlag(ConfigAction):\n    \"\"\"\n    This action prepends the given flag to the %{link_flags} substitution.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        assert hasCompileFlag(\n            config, flag\n        ), \"Trying to enable link flag {}, which is not supported\".format(flag)\n        config.substitutions = _prependToSubstitution(\n            config.substitutions, \"%{link_flags}\", flag\n        )\n\n    def pretty(self, config, litParams):\n        return \"prepend {} to %{{link_flags}}\".format(self._getFlag(config))\n\n\nclass AddOptionalWarningFlag(ConfigAction):\n    \"\"\"\n    This action adds the given warning flag to the %{compile_flags} substitution,\n    if it is supported by the compiler.\n\n    The flag can be a string or a callable, in which case it is called with the\n    configuration to produce the actual flag (as a string).\n    \"\"\"\n\n    def __init__(self, flag):\n        self._getFlag = lambda config: flag(config) if callable(flag) else flag\n\n    def applyTo(self, config):\n        flag = self._getFlag(config)\n        # Use -Werror to make sure we see an error about the flag being unsupported.\n        if hasCompileFlag(config, \"-Werror \" + flag):\n            config.substitutions = _appendToSubstitution(\n                config.substitutions, \"%{compile_flags}\", flag\n            )\n\n    def pretty(self, config, litParams):\n        return \"add {} to %{{compile_flags}}\".format(self._getFlag(config))\n\n\nclass AddSubstitution(ConfigAction):\n    \"\"\"\n    This action adds the given substitution to the Lit configuration.\n\n    The substitution can be a string or a callable, in which case it is called\n    with the configuration to produce the actual substitution (as a string).\n    \"\"\"\n\n    def __init__(self, key, substitution):\n        self._key = key\n        self._getSub = (\n            lambda config: substitution(config)\n            if callable(substitution)\n            else substitution\n        )\n\n    def applyTo(self, config):\n        key = self._key\n        sub = self._getSub(config)\n        config.substitutions.append((key, sub))\n\n    def pretty(self, config, litParams):\n        return \"add substitution {} = {}\".format(self._key, self._getSub(config))\n\n\nclass Feature(object):\n    \"\"\"\n    Represents a Lit available feature that is enabled whenever it is supported.\n\n    A feature like this informs the test suite about a capability of the compiler,\n    platform, etc. Unlike Parameters, it does not make sense to explicitly\n    control whether a Feature is enabled -- it should be enabled whenever it\n    is supported.\n    \"\"\"\n\n    def __init__(self, name, actions=None, when=lambda _: True):\n        \"\"\"\n        Create a Lit feature for consumption by a test suite.\n\n        - name\n            The name of the feature. This is what will end up in Lit's available\n            features if the feature is enabled. This can be either a string or a\n            callable, in which case it is passed the TestingConfig and should\n            generate a string representing the name of the feature.\n\n        - actions\n            An optional list of ConfigActions to apply when the feature is supported.\n            An AddFeature action is always created regardless of any actions supplied\n            here -- these actions are meant to perform more than setting a corresponding\n            Lit feature (e.g. adding compiler flags). If 'actions' is a callable, it\n            is called with the current configuration object to generate the actual\n            list of actions.\n\n        - when\n            A callable that gets passed a TestingConfig and should return a\n            boolean representing whether the feature is supported in that\n            configuration. For example, this can use `hasCompileFlag` to\n            check whether the compiler supports the flag that the feature\n            represents. If omitted, the feature will always be considered\n            supported.\n        \"\"\"\n        self._name = name\n        self._actions = [] if actions is None else actions\n        self._isSupported = when\n\n    def _getName(self, config):\n        name = self._name(config) if callable(self._name) else self._name\n        if not isinstance(name, str):\n            raise ValueError(\n                \"Feature did not resolve to a name that's a string, got {}\".format(name)\n            )\n        return name\n\n    def getActions(self, config):\n        \"\"\"\n        Return the list of actions associated to this feature.\n\n        If the feature is not supported, an empty list is returned.\n        If the feature is supported, an `AddFeature` action is automatically added\n        to the returned list of actions, in addition to any actions provided on\n        construction.\n        \"\"\"\n        if not self._isSupported(config):\n            return []\n        else:\n            actions = (\n                self._actions(config) if callable(self._actions) else self._actions\n            )\n            return [AddFeature(self._getName(config))] + actions\n\n    def pretty(self, config):\n        \"\"\"\n        Returns the Feature's name.\n        \"\"\"\n        return self._getName(config)\n\n\ndef _str_to_bool(s):\n    \"\"\"\n    Convert a string value to a boolean.\n\n    True values are \"y\", \"yes\", \"t\", \"true\", \"on\" and \"1\", regardless of capitalization.\n    False values are \"n\", \"no\", \"f\", \"false\", \"off\" and \"0\", regardless of capitalization.\n    \"\"\"\n    trueVals = [\"y\", \"yes\", \"t\", \"true\", \"on\", \"1\"]\n    falseVals = [\"n\", \"no\", \"f\", \"false\", \"off\", \"0\"]\n    lower = s.lower()\n    if lower in trueVals:\n        return True\n    elif lower in falseVals:\n        return False\n    else:\n        raise ValueError(\"Got string '{}', which isn't a valid boolean\".format(s))\n\n\ndef _parse_parameter(s, type):\n    if type is bool and isinstance(s, str):\n        return _str_to_bool(s)\n    elif type is list and isinstance(s, str):\n        return [x.strip() for x in s.split(\",\") if x.strip()]\n    return type(s)\n\n\nclass Parameter(object):\n    \"\"\"\n    Represents a parameter of a Lit test suite.\n\n    Parameters are used to customize the behavior of test suites in a user\n    controllable way. There are two ways of setting the value of a Parameter.\n    The first one is to pass `--param <KEY>=<VALUE>` when running Lit (or\n    equivalently to set `litConfig.params[KEY] = VALUE` somewhere in the\n    Lit configuration files. This method will set the parameter globally for\n    all test suites being run.\n\n    The second method is to set `config.KEY = VALUE` somewhere in the Lit\n    configuration files, which sets the parameter only for the test suite(s)\n    that use that `config` object.\n\n    Parameters can have multiple possible values, and they can have a default\n    value when left unspecified. They can also have any number of ConfigActions\n    associated to them, in which case the actions will be performed on the\n    TestingConfig if the parameter is enabled. Depending on the actions\n    associated to a Parameter, it may be an error to enable the Parameter\n    if some actions are not supported in the given configuration. For example,\n    trying to set the compilation standard to C++23 when `-std=c++23` is not\n    supported by the compiler would be an error.\n    \"\"\"\n\n    def __init__(self, name, type, help, actions, choices=None, default=None):\n        \"\"\"\n        Create a Lit parameter to customize the behavior of a test suite.\n\n        - name\n            The name of the parameter that can be used to set it on the command-line.\n            On the command-line, the parameter can be set using `--param <name>=<value>`\n            when running Lit. This must be non-empty.\n\n        - choices\n            An optional non-empty set of possible values for this parameter. If provided,\n            this must be anything that can be iterated. It is an error if the parameter\n            is given a value that is not in that set, whether explicitly or through a\n            default value.\n\n        - type\n            A callable that can be used to parse the value of the parameter given\n            on the command-line. As a special case, using the type `bool` also\n            allows parsing strings with boolean-like contents, and the type `list`\n            will parse a string delimited by commas into a list of the substrings.\n\n        - help\n            A string explaining the parameter, for documentation purposes.\n            TODO: We should be able to surface those from the Lit command-line.\n\n        - actions\n            A callable that gets passed the parsed value of the parameter (either\n            the one passed on the command-line or the default one), and that returns\n            a list of ConfigAction to perform given the value of the parameter.\n            All the ConfigAction must be supported in the given configuration.\n\n        - default\n            An optional default value to use for the parameter when no value is\n            provided on the command-line. If the default value is a callable, it\n            is called with the TestingConfig and should return the default value\n            for the parameter. Whether the default value is computed or specified\n            directly, it must be in the 'choices' provided for that Parameter.\n        \"\"\"\n        self._name = name\n        if len(self._name) == 0:\n            raise ValueError(\"Parameter name must not be the empty string\")\n\n        if choices is not None:\n            self._choices = list(choices)  # should be finite\n            if len(self._choices) == 0:\n                raise ValueError(\n                    \"Parameter '{}' must be given at least one possible value\".format(\n                        self._name\n                    )\n                )\n        else:\n            self._choices = None\n\n        self._parse = lambda x: _parse_parameter(x, type)\n        self._help = help\n        self._actions = actions\n        self._default = default\n\n    def _getValue(self, config, litParams):\n        \"\"\"\n        Return the value of the parameter given the configuration objects.\n        \"\"\"\n        param = getattr(config, self.name, None)\n        param = litParams.get(self.name, param)\n        if param is None and self._default is None:\n            raise ValueError(\n                \"Parameter {} doesn't have a default value, but it was not specified in the Lit parameters or in the Lit config\".format(\n                    self.name\n                )\n            )\n        getDefault = (\n            lambda: self._default(config) if callable(self._default) else self._default\n        )\n\n        if param is not None:\n            (pretty, value) = (param, self._parse(param))\n        else:\n            value = getDefault()\n            pretty = \"{} (default)\".format(value)\n\n        if self._choices and value not in self._choices:\n            raise ValueError(\n                \"Got value '{}' for parameter '{}', which is not in the provided set of possible choices: {}\".format(\n                    value, self.name, self._choices\n                )\n            )\n        return (pretty, value)\n\n    @property\n    def name(self):\n        \"\"\"\n        Return the name of the parameter.\n\n        This is the name that can be used to set the parameter on the command-line\n        when running Lit.\n        \"\"\"\n        return self._name\n\n    def getActions(self, config, litParams):\n        \"\"\"\n        Return the list of actions associated to this value of the parameter.\n        \"\"\"\n        (_, parameterValue) = self._getValue(config, litParams)\n        return self._actions(parameterValue)\n\n    def pretty(self, config, litParams):\n        \"\"\"\n        Return a pretty representation of the parameter's name and value.\n        \"\"\"\n        (prettyParameterValue, _) = self._getValue(config, litParams)\n        return \"{}={}\".format(self.name, prettyParameterValue)\n"}, "/libcxx/utils/libcxx/test/format.py": {"changes": [{"diff": "\n     for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n         assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n \n-def _parseLitOutput(fullOutput):\n-    \"\"\"\n-    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n-\n-    This takes output of the form\n-\n-        $ \":\" \"RUN: at line 11\"\n-        $ \"echo\" \"OUTPUT1\"\n-        # command output:\n-        OUTPUT1\n-\n-        $ \":\" \"RUN: at line 12\"\n-        $ \"echo\" \"OUTPUT2\"\n-        # command output:\n-        OUTPUT2\n-\n-    and returns a string containing\n-\n-        OUTPUT1\n-        OUTPUT2\n-\n-    as-if the commands had been run directly. This is a workaround for the fact\n-    that Lit doesn't let us execute ShTest and retrieve the raw output without\n-    injecting additional Lit output around it.\n-    \"\"\"\n-    parsed = ''\n-    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n-        if output: # skip blank lines\n-            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n-            if commandOutput:\n-                parsed += commandOutput.group(1)\n-    return parsed\n-\n def _executeScriptInternal(test, litConfig, commands):\n     \"\"\"\n     Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n", "add": 0, "remove": 33, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["def _parseLitOutput(fullOutput):", "    \"\"\"", "    Parse output of a Lit ShTest to extract the actual output of the contained commands.", "    This takes output of the form", "        $ \":\" \"RUN: at line 11\"", "        $ \"echo\" \"OUTPUT1\"", "        OUTPUT1", "        $ \":\" \"RUN: at line 12\"", "        $ \"echo\" \"OUTPUT2\"", "        OUTPUT2", "    and returns a string containing", "        OUTPUT1", "        OUTPUT2", "    as-if the commands had been run directly. This is a workaround for the fact", "    that Lit doesn't let us execute ShTest and retrieve the raw output without", "    injecting additional Lit output around it.", "    \"\"\"", "    parsed = ''", "    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):", "        if output: # skip blank lines", "            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)", "            if commandOutput:", "                parsed += commandOutput.group(1)", "    return parsed"], "goodparts": []}, {"diff": "\n     _, tmpBase = _getTempPaths(test)\n     execDir = os.path.dirname(test.getExecPath())\n     res = lit.TestRunner.executeScriptInternal(\n-        test, litConfig, tmpBase, parsedCommands, execDir\n+        test, litConfig, tmpBase, parsedCommands, execDir, debug=False\n     )\n     if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n         res = (\"\", res.output, 127, None)\n     (out, err, exitCode, timeoutInfo) = res\n \n-    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n-    #       split any stderr output that is included in stdout. It shouldn't be there, but\n-    #       the Lit internal shell conflates stderr and stdout.\n-    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n-    if conflatedErrorOutput:\n-        conflatedErrorOutput = conflatedErrorOutput.group(0)\n-        out = out[: -len(conflatedErrorOutput)]\n-        err += conflatedErrorOutput\n-\n     return (out, err, exitCode, timeoutInfo, parsedCommands)\n \n \n", "add": 1, "remove": 10, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["        test, litConfig, tmpBase, parsedCommands, execDir", "    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)", "    if conflatedErrorOutput:", "        conflatedErrorOutput = conflatedErrorOutput.group(0)", "        out = out[: -len(conflatedErrorOutput)]", "        err += conflatedErrorOutput"], "goodparts": ["        test, litConfig, tmpBase, parsedCommands, execDir, debug=False"]}, {"diff": "\n             raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n \n         # Split the generated output into multiple files and generate one test for each file\n-        parsed = _parseLitOutput(out)\n-        for (subfile, content) in self._splitFile(parsed):\n+        for (subfile, content) in self._splitFile(out):\n             generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n             os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n             with open(generatedFile, 'w') as f", "add": 1, "remove": 2, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["        parsed = _parseLitOutput(out)", "        for (subfile, content) in self._splitFile(parsed):"], "goodparts": ["        for (subfile, content) in self._splitFile(out):"]}], "source": "\n import contextlib import io import lit import lit.formats import os import pipes import re import shutil def _getTempPaths(test): \"\"\" Return the values to use for the %T and %t substitutions, respectively. The difference between this and Lit's default behavior is that we guarantee that %T is a path unique to the test being run. \"\"\" tmpDir, _=lit.TestRunner.getTempPaths(test) _, testName=os.path.split(test.getExecPath()) tmpDir=os.path.join(tmpDir, testName +\".dir\") tmpBase=os.path.join(tmpDir, \"t\") return tmpDir, tmpBase def _checkBaseSubstitutions(substitutions): substitutions=[s for(s, _) in substitutions] for s in[\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]: assert s in substitutions, \"Required substitution{} was not provided\".format(s) def _parseLitOutput(fullOutput): \"\"\" Parse output of a Lit ShTest to extract the actual output of the contained commands. This takes output of the form $ \":\" \"RUN: at line 11\" $ \"echo\" \"OUTPUT1\" OUTPUT1 $ \":\" \"RUN: at line 12\" $ \"echo\" \"OUTPUT2\" OUTPUT2 and returns a string containing OUTPUT1 OUTPUT2 as-if the commands had been run directly. This is a workaround for the fact that Lit doesn't let us execute ShTest and retrieve the raw output without injecting additional Lit output around it. \"\"\" parsed='' for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput): if output: commandOutput=re.search(\" if commandOutput: parsed +=commandOutput.group(1) return parsed def _executeScriptInternal(test, litConfig, commands): \"\"\" Returns(stdout, stderr, exitCode, timeoutInfo, parsedCommands) TODO: This really should be easier to access from Lit itself \"\"\" parsedCommands=parseScript(test, preamble=commands) _, tmpBase=_getTempPaths(test) execDir=os.path.dirname(test.getExecPath()) res=lit.TestRunner.executeScriptInternal( test, litConfig, tmpBase, parsedCommands, execDir ) if isinstance(res, lit.Test.Result): res=(\"\", res.output, 127, None) (out, err, exitCode, timeoutInfo)=res conflatedErrorOutput=re.search(\"( if conflatedErrorOutput: conflatedErrorOutput=conflatedErrorOutput.group(0) out=out[: -len(conflatedErrorOutput)] err +=conflatedErrorOutput return(out, err, exitCode, timeoutInfo, parsedCommands) def parseScript(test, preamble): \"\"\" Extract the script from a test, with substitutions applied. Returns a list of commands ready to be executed. -test The lit.Test to parse. -preamble A list of commands to perform before any command in the test. These commands can contain unexpanded substitutions, but they must not be of the form 'RUN:' --they must be proper commands once substituted. \"\"\" tmpDir, tmpBase=_getTempPaths(test) substitutions=lit.TestRunner.getDefaultSubstitutions(test, tmpDir, tmpBase) _checkBaseSubstitutions(substitutions) substitutions.append( (\"%{build}\", \"%{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\") ) substitutions.append((\"%{run}\", \"%{exec} %t.exe\")) additionalCompileFlags=[] fileDependencies=[] parsers=[ lit.TestRunner.IntegratedTestKeywordParser( \"FILE_DEPENDENCIES:\", lit.TestRunner.ParserKind.LIST, initial_value=fileDependencies, ), lit.TestRunner.IntegratedTestKeywordParser( \"ADDITIONAL_COMPILE_FLAGS:\", lit.TestRunner.ParserKind.LIST, initial_value=additionalCompileFlags, ), ] for feature in test.config.available_features: parser=lit.TestRunner.IntegratedTestKeywordParser( \"ADDITIONAL_COMPILE_FLAGS({}):\".format(feature), lit.TestRunner.ParserKind.LIST, initial_value=additionalCompileFlags, ) parsers.append(parser) scriptInTest=lit.TestRunner.parseIntegratedTestScript( test, additional_parsers=parsers, require_script=not preamble ) if isinstance(scriptInTest, lit.Test.Result): return scriptInTest script=[] for dep in fileDependencies: script +=[\"%dbg(SETUP) cd %S && cp{} %T\".format(dep)] script +=preamble script +=scriptInTest substitutions=[ (s, x +\" \" +\" \".join(additionalCompileFlags)) if s==\"%{compile_flags}\" else(s, x) for(s, x) in substitutions ] script=lit.TestRunner.applySubstitutions( script, substitutions, recursion_limit=test.config.recursiveExpansionLimit ) return script class CxxStandardLibraryTest(lit.formats.FileBasedTest): \"\"\" Lit test format for the C++Standard Library conformance test suite. This test format is based on top of the ShTest format --it basically creates a shell script performing the right operations(compile/link/run) based on the extension of the test file it encounters. It supports files with the following extensions: FOO.pass.cpp -Compiles, links and runs successfully FOO.pass.mm -Same as.pass.cpp, but for Objective-C++ FOO.compile.pass.cpp -Compiles successfully, link and run not attempted FOO.compile.pass.mm -Same as.compile.pass.cpp, but for Objective-C++ FOO.compile.fail.cpp -Does not compile successfully FOO.link.pass.cpp -Compiles and links successfully, run not attempted FOO.link.pass.mm -Same as.link.pass.cpp, but for Objective-C++ FOO.link.fail.cpp -Compiles successfully, but fails to link FOO.sh.<anything> -A builtin Lit Shell test FOO.gen.<anything> -A.sh test that generates one or more Lit tests on the fly. Executing this test must generate one or more files as expected by LLVM split-file, and each generated file leads to a separate Lit test that runs that file as defined by the test format. This can be used to generate multiple Lit tests from a single source file, which is useful for testing repetitive properties in the library. Be careful not to abuse this since this is not a replacement for usual code reuse techniques. FOO.verify.cpp -Compiles with clang-verify. This type of test is automatically marked as UNSUPPORTED if the compiler does not support Clang-verify. Substitution requirements =============================== The test format operates by assuming that each test's configuration provides the following substitutions, which it will reuse in the shell scripts it constructs: %{cxx} -A command that can be used to invoke the compiler %{compile_flags} -Flags to use when compiling a test case %{link_flags} -Flags to use when linking a test case %{flags} -Flags to use either when compiling or linking a test case %{exec} -A command to prefix the execution of executables Note that when building an executable(as opposed to only compiling a source file), all three of %{flags}, %{compile_flags} and %{link_flags} will be used in the same command line. In other words, the test format doesn't perform separate compilation and linking steps in this case. Additional supported directives =============================== In addition to everything that's supported in Lit ShTests, this test format also understands the following directives inside test files: // FILE_DEPENDENCIES: file, directory, /path/to/file This directive expresses that the test requires the provided files or directories in order to run. An example is a test that requires some test input stored in a data file. When a test file contains such a directive, this test format will collect them and copy them to the directory represented by %T. The intent is that %T contains all the inputs necessary to run the test, such that e.g. execution on a remote host can be done by simply copying %T to the host. // ADDITIONAL_COMPILE_FLAGS: flag1, flag2, flag3 This directive will cause the provided flags to be added to the %{compile_flags} substitution for the test that contains it. This allows adding special compilation flags without having to use a .sh.cpp test, which would be more powerful but perhaps overkill. Additional provided substitutions and features ============================================== The test format will define the following substitutions for use inside tests: %{build} Expands to a command-line that builds the current source file with the %{flags}, %{compile_flags} and %{link_flags} substitutions, and that produces an executable named %t.exe. %{run} Equivalent to `%{exec} %t.exe`. This is intended to be used in conjunction with the %{build} substitution. \"\"\" def getTestsForPath(self, testSuite, pathInSuite, litConfig, localConfig): SUPPORTED_SUFFIXES=[ \"[.]pass[.]cpp$\", \"[.]pass[.]mm$\", \"[.]compile[.]pass[.]cpp$\", \"[.]compile[.]pass[.]mm$\", \"[.]compile[.]fail[.]cpp$\", \"[.]link[.]pass[.]cpp$\", \"[.]link[.]pass[.]mm$\", \"[.]link[.]fail[.]cpp$\", \"[.]sh[.][^.]+$\", \"[.]gen[.][^.]+$\", \"[.]verify[.]cpp$\", \"[.]fail[.]cpp$\", ] sourcePath=testSuite.getSourcePath(pathInSuite) filename=os.path.basename(sourcePath) hasSupportedSuffix=lambda f: any([re.search(ext, f) for ext in SUPPORTED_SUFFIXES]) if filename.startswith(\".\") or filename in localConfig.excludes or not hasSupportedSuffix(filename): return if re.search('[.]gen[.][^.]+$', filename): for test in self._generateGenTest(testSuite, pathInSuite, litConfig, localConfig): yield test else: yield lit.Test.Test(testSuite, pathInSuite, localConfig) def execute(self, test, litConfig): VERIFY_FLAGS=( \"-Xclang -verify -Xclang -verify-ignore-unexpected=note -ferror-limit=0\" ) supportsVerify=\"verify-support\" in test.config.available_features filename=test.path_in_suite[-1] if re.search(\"[.]sh[.][^.]+$\", filename): steps=[] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".compile.pass.cpp\") or filename.endswith( \".compile.pass.mm\" ): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".compile.fail.cpp\"): steps=[ \"%dbg(COMPILED WITH) ! %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".link.pass.cpp\") or filename.endswith(\".link.pass.mm\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".link.fail.cpp\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -c -o %t.o\", \"%dbg(LINKED WITH) ! %{cxx} %t.o %{flags} %{link_flags} -o %t.exe\", ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".verify.cpp\"): if not supportsVerify: return lit.Test.Result( lit.Test.UNSUPPORTED, \"Test{} requires support for Clang-verify, which isn't supported by the compiler\".format( test.getFullName() ), ) steps=[ \"%dbg(COMPILED WITH) %{{cxx}} %s %{{flags}} %{{compile_flags}} -fsyntax-only -Wno-error{}\".format( VERIFY_FLAGS ) ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".pass.cpp\") or filename.endswith(\".pass.mm\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\", \"%dbg(EXECUTED AS) %{exec} %t.exe\", ] return self._executeShTest(test, litConfig, steps) else: return lit.Test.Result( lit.Test.UNRESOLVED, \"Unknown test suffix for '{}'\".format(filename) ) def _executeShTest(self, test, litConfig, steps): if test.config.unsupported: return lit.Test.Result(lit.Test.UNSUPPORTED, \"Test is unsupported\") script=parseScript(test, steps) if isinstance(script, lit.Test.Result): return script if litConfig.noExecute: return lit.Test.Result( lit.Test.XFAIL if test.isExpectedToFail() else lit.Test.PASS ) else: _, tmpBase=_getTempPaths(test) useExternalSh=False return lit.TestRunner._runShTest( test, litConfig, useExternalSh, script, tmpBase ) def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig): generator=lit.Test.Test(testSuite, pathInSuite, localConfig) generatorExecDir=os.path.dirname(testSuite.getExecPath(pathInSuite)) os.makedirs(generatorExecDir, exist_ok=True) steps=[] (out, err, exitCode, _, _)=_executeScriptInternal(generator, litConfig, steps) if exitCode !=0: raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\") parsed=_parseLitOutput(out) for(subfile, content) in self._splitFile(parsed): generatedFile=testSuite.getExecPath(pathInSuite +(subfile,)) os.makedirs(os.path.dirname(generatedFile), exist_ok=True) with open(generatedFile, 'w') as f: f.write(content) yield lit.Test.Test(testSuite,(generatedFile,), localConfig) def _splitFile(self, input): DELIM=r'^(//| lines=input.splitlines() currentFile=None thisFileContent=[] for line in lines: match=re.match(DELIM, line) if match: if currentFile is not None: yield(currentFile, '\\n'.join(thisFileContent)) currentFile=match.group(2).strip() thisFileContent=[] assert currentFile is not None, f\"Some input to split-file doesn't belong to any file, input was:\\n{input}\" thisFileContent.append(line) if currentFile is not None: yield(currentFile, '\\n'.join(thisFileContent)) ", "sourceWithComments": "# ===----------------------------------------------------------------------===##\n#\n# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n# See https://llvm.org/LICENSE.txt for license information.\n# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n#\n# ===----------------------------------------------------------------------===##\n\nimport contextlib\nimport io\nimport lit\nimport lit.formats\nimport os\nimport pipes\nimport re\nimport shutil\n\n\ndef _getTempPaths(test):\n    \"\"\"\n    Return the values to use for the %T and %t substitutions, respectively.\n\n    The difference between this and Lit's default behavior is that we guarantee\n    that %T is a path unique to the test being run.\n    \"\"\"\n    tmpDir, _ = lit.TestRunner.getTempPaths(test)\n    _, testName = os.path.split(test.getExecPath())\n    tmpDir = os.path.join(tmpDir, testName + \".dir\")\n    tmpBase = os.path.join(tmpDir, \"t\")\n    return tmpDir, tmpBase\n\n\ndef _checkBaseSubstitutions(substitutions):\n    substitutions = [s for (s, _) in substitutions]\n    for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n        assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n\ndef _parseLitOutput(fullOutput):\n    \"\"\"\n    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n\n    This takes output of the form\n\n        $ \":\" \"RUN: at line 11\"\n        $ \"echo\" \"OUTPUT1\"\n        # command output:\n        OUTPUT1\n\n        $ \":\" \"RUN: at line 12\"\n        $ \"echo\" \"OUTPUT2\"\n        # command output:\n        OUTPUT2\n\n    and returns a string containing\n\n        OUTPUT1\n        OUTPUT2\n\n    as-if the commands had been run directly. This is a workaround for the fact\n    that Lit doesn't let us execute ShTest and retrieve the raw output without\n    injecting additional Lit output around it.\n    \"\"\"\n    parsed = ''\n    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n        if output: # skip blank lines\n            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n            if commandOutput:\n                parsed += commandOutput.group(1)\n    return parsed\n\ndef _executeScriptInternal(test, litConfig, commands):\n    \"\"\"\n    Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n\n    TODO: This really should be easier to access from Lit itself\n    \"\"\"\n    parsedCommands = parseScript(test, preamble=commands)\n\n    _, tmpBase = _getTempPaths(test)\n    execDir = os.path.dirname(test.getExecPath())\n    res = lit.TestRunner.executeScriptInternal(\n        test, litConfig, tmpBase, parsedCommands, execDir\n    )\n    if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n        res = (\"\", res.output, 127, None)\n    (out, err, exitCode, timeoutInfo) = res\n\n    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n    #       split any stderr output that is included in stdout. It shouldn't be there, but\n    #       the Lit internal shell conflates stderr and stdout.\n    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n    if conflatedErrorOutput:\n        conflatedErrorOutput = conflatedErrorOutput.group(0)\n        out = out[: -len(conflatedErrorOutput)]\n        err += conflatedErrorOutput\n\n    return (out, err, exitCode, timeoutInfo, parsedCommands)\n\n\ndef parseScript(test, preamble):\n    \"\"\"\n    Extract the script from a test, with substitutions applied.\n\n    Returns a list of commands ready to be executed.\n\n    - test\n        The lit.Test to parse.\n\n    - preamble\n        A list of commands to perform before any command in the test.\n        These commands can contain unexpanded substitutions, but they\n        must not be of the form 'RUN:' -- they must be proper commands\n        once substituted.\n    \"\"\"\n    # Get the default substitutions\n    tmpDir, tmpBase = _getTempPaths(test)\n    substitutions = lit.TestRunner.getDefaultSubstitutions(test, tmpDir, tmpBase)\n\n    # Check base substitutions and add the %{build} and %{run} convenience substitutions\n    _checkBaseSubstitutions(substitutions)\n    substitutions.append(\n        (\"%{build}\", \"%{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\")\n    )\n    substitutions.append((\"%{run}\", \"%{exec} %t.exe\"))\n\n    # Parse the test file, including custom directives\n    additionalCompileFlags = []\n    fileDependencies = []\n    parsers = [\n        lit.TestRunner.IntegratedTestKeywordParser(\n            \"FILE_DEPENDENCIES:\",\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=fileDependencies,\n        ),\n        lit.TestRunner.IntegratedTestKeywordParser(\n            \"ADDITIONAL_COMPILE_FLAGS:\",\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=additionalCompileFlags,\n        ),\n    ]\n\n    # Add conditional parsers for ADDITIONAL_COMPILE_FLAGS. This should be replaced by first\n    # class support for conditional keywords in Lit, which would allow evaluating arbitrary\n    # Lit boolean expressions instead.\n    for feature in test.config.available_features:\n        parser = lit.TestRunner.IntegratedTestKeywordParser(\n            \"ADDITIONAL_COMPILE_FLAGS({}):\".format(feature),\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=additionalCompileFlags,\n        )\n        parsers.append(parser)\n\n    scriptInTest = lit.TestRunner.parseIntegratedTestScript(\n        test, additional_parsers=parsers, require_script=not preamble\n    )\n    if isinstance(scriptInTest, lit.Test.Result):\n        return scriptInTest\n\n    script = []\n\n    # For each file dependency in FILE_DEPENDENCIES, inject a command to copy\n    # that file to the execution directory. Execute the copy from %S to allow\n    # relative paths from the test directory.\n    for dep in fileDependencies:\n        script += [\"%dbg(SETUP) cd %S && cp {} %T\".format(dep)]\n    script += preamble\n    script += scriptInTest\n\n    # Add compile flags specified with ADDITIONAL_COMPILE_FLAGS.\n    substitutions = [\n        (s, x + \" \" + \" \".join(additionalCompileFlags))\n        if s == \"%{compile_flags}\"\n        else (s, x)\n        for (s, x) in substitutions\n    ]\n\n    # Perform substitutions in the script itself.\n    script = lit.TestRunner.applySubstitutions(\n        script, substitutions, recursion_limit=test.config.recursiveExpansionLimit\n    )\n\n    return script\n\n\nclass CxxStandardLibraryTest(lit.formats.FileBasedTest):\n    \"\"\"\n    Lit test format for the C++ Standard Library conformance test suite.\n\n    This test format is based on top of the ShTest format -- it basically\n    creates a shell script performing the right operations (compile/link/run)\n    based on the extension of the test file it encounters. It supports files\n    with the following extensions:\n\n    FOO.pass.cpp            - Compiles, links and runs successfully\n    FOO.pass.mm             - Same as .pass.cpp, but for Objective-C++\n\n    FOO.compile.pass.cpp    - Compiles successfully, link and run not attempted\n    FOO.compile.pass.mm     - Same as .compile.pass.cpp, but for Objective-C++\n    FOO.compile.fail.cpp    - Does not compile successfully\n\n    FOO.link.pass.cpp       - Compiles and links successfully, run not attempted\n    FOO.link.pass.mm        - Same as .link.pass.cpp, but for Objective-C++\n    FOO.link.fail.cpp       - Compiles successfully, but fails to link\n\n    FOO.sh.<anything>       - A builtin Lit Shell test\n\n    FOO.gen.<anything>      - A .sh test that generates one or more Lit tests on the\n                              fly. Executing this test must generate one or more files\n                              as expected by LLVM split-file, and each generated file\n                              leads to a separate Lit test that runs that file as\n                              defined by the test format. This can be used to generate\n                              multiple Lit tests from a single source file, which is\n                              useful for testing repetitive properties in the library.\n                              Be careful not to abuse this since this is not a replacement\n                              for usual code reuse techniques.\n\n    FOO.verify.cpp          - Compiles with clang-verify. This type of test is\n                              automatically marked as UNSUPPORTED if the compiler\n                              does not support Clang-verify.\n\n\n    Substitution requirements\n    ===============================\n    The test format operates by assuming that each test's configuration provides\n    the following substitutions, which it will reuse in the shell scripts it\n    constructs:\n        %{cxx}           - A command that can be used to invoke the compiler\n        %{compile_flags} - Flags to use when compiling a test case\n        %{link_flags}    - Flags to use when linking a test case\n        %{flags}         - Flags to use either when compiling or linking a test case\n        %{exec}          - A command to prefix the execution of executables\n\n    Note that when building an executable (as opposed to only compiling a source\n    file), all three of %{flags}, %{compile_flags} and %{link_flags} will be used\n    in the same command line. In other words, the test format doesn't perform\n    separate compilation and linking steps in this case.\n\n\n    Additional supported directives\n    ===============================\n    In addition to everything that's supported in Lit ShTests, this test format\n    also understands the following directives inside test files:\n\n        // FILE_DEPENDENCIES: file, directory, /path/to/file\n\n            This directive expresses that the test requires the provided files\n            or directories in order to run. An example is a test that requires\n            some test input stored in a data file. When a test file contains\n            such a directive, this test format will collect them and copy them\n            to the directory represented by %T. The intent is that %T contains\n            all the inputs necessary to run the test, such that e.g. execution\n            on a remote host can be done by simply copying %T to the host.\n\n        // ADDITIONAL_COMPILE_FLAGS: flag1, flag2, flag3\n\n            This directive will cause the provided flags to be added to the\n            %{compile_flags} substitution for the test that contains it. This\n            allows adding special compilation flags without having to use a\n            .sh.cpp test, which would be more powerful but perhaps overkill.\n\n\n    Additional provided substitutions and features\n    ==============================================\n    The test format will define the following substitutions for use inside tests:\n\n        %{build}\n            Expands to a command-line that builds the current source\n            file with the %{flags}, %{compile_flags} and %{link_flags}\n            substitutions, and that produces an executable named %t.exe.\n\n        %{run}\n            Equivalent to `%{exec} %t.exe`. This is intended to be used\n            in conjunction with the %{build} substitution.\n    \"\"\"\n\n    def getTestsForPath(self, testSuite, pathInSuite, litConfig, localConfig):\n        SUPPORTED_SUFFIXES = [\n            \"[.]pass[.]cpp$\",\n            \"[.]pass[.]mm$\",\n            \"[.]compile[.]pass[.]cpp$\",\n            \"[.]compile[.]pass[.]mm$\",\n            \"[.]compile[.]fail[.]cpp$\",\n            \"[.]link[.]pass[.]cpp$\",\n            \"[.]link[.]pass[.]mm$\",\n            \"[.]link[.]fail[.]cpp$\",\n            \"[.]sh[.][^.]+$\",\n            \"[.]gen[.][^.]+$\",\n            \"[.]verify[.]cpp$\",\n            \"[.]fail[.]cpp$\",\n        ]\n\n        sourcePath = testSuite.getSourcePath(pathInSuite)\n        filename = os.path.basename(sourcePath)\n\n        # Ignore dot files, excluded tests and tests with an unsupported suffix\n        hasSupportedSuffix = lambda f: any([re.search(ext, f) for ext in SUPPORTED_SUFFIXES])\n        if filename.startswith(\".\") or filename in localConfig.excludes or not hasSupportedSuffix(filename):\n            return\n\n        # If this is a generated test, run the generation step and add\n        # as many Lit tests as necessary.\n        if re.search('[.]gen[.][^.]+$', filename):\n            for test in self._generateGenTest(testSuite, pathInSuite, litConfig, localConfig):\n                yield test\n        else:\n            yield lit.Test.Test(testSuite, pathInSuite, localConfig)\n\n    def execute(self, test, litConfig):\n        VERIFY_FLAGS = (\n            \"-Xclang -verify -Xclang -verify-ignore-unexpected=note -ferror-limit=0\"\n        )\n        supportsVerify = \"verify-support\" in test.config.available_features\n        filename = test.path_in_suite[-1]\n\n        if re.search(\"[.]sh[.][^.]+$\", filename):\n            steps = []  # The steps are already in the script\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".compile.pass.cpp\") or filename.endswith(\n            \".compile.pass.mm\"\n        ):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".compile.fail.cpp\"):\n            steps = [\n                \"%dbg(COMPILED WITH) ! %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".link.pass.cpp\") or filename.endswith(\".link.pass.mm\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".link.fail.cpp\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -c -o %t.o\",\n                \"%dbg(LINKED WITH) ! %{cxx} %t.o %{flags} %{link_flags} -o %t.exe\",\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".verify.cpp\"):\n            if not supportsVerify:\n                return lit.Test.Result(\n                    lit.Test.UNSUPPORTED,\n                    \"Test {} requires support for Clang-verify, which isn't supported by the compiler\".format(\n                        test.getFullName()\n                    ),\n                )\n            steps = [\n                # Note: Use -Wno-error to make sure all diagnostics are not treated as errors,\n                #       which doesn't make sense for clang-verify tests.\n                \"%dbg(COMPILED WITH) %{{cxx}} %s %{{flags}} %{{compile_flags}} -fsyntax-only -Wno-error {}\".format(\n                    VERIFY_FLAGS\n                )\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        # Make sure to check these ones last, since they will match other\n        # suffixes above too.\n        elif filename.endswith(\".pass.cpp\") or filename.endswith(\".pass.mm\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\",\n                \"%dbg(EXECUTED AS) %{exec} %t.exe\",\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        else:\n            return lit.Test.Result(\n                lit.Test.UNRESOLVED, \"Unknown test suffix for '{}'\".format(filename)\n            )\n\n    def _executeShTest(self, test, litConfig, steps):\n        if test.config.unsupported:\n            return lit.Test.Result(lit.Test.UNSUPPORTED, \"Test is unsupported\")\n\n        script = parseScript(test, steps)\n        if isinstance(script, lit.Test.Result):\n            return script\n\n        if litConfig.noExecute:\n            return lit.Test.Result(\n                lit.Test.XFAIL if test.isExpectedToFail() else lit.Test.PASS\n            )\n        else:\n            _, tmpBase = _getTempPaths(test)\n            useExternalSh = False\n            return lit.TestRunner._runShTest(\n                test, litConfig, useExternalSh, script, tmpBase\n            )\n\n    def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig):\n        generator = lit.Test.Test(testSuite, pathInSuite, localConfig)\n\n        # Make sure we have a directory to execute the generator test in\n        generatorExecDir = os.path.dirname(testSuite.getExecPath(pathInSuite))\n        os.makedirs(generatorExecDir, exist_ok=True)\n\n        # Run the generator test\n        steps = [] # Steps must already be in the script\n        (out, err, exitCode, _, _) = _executeScriptInternal(generator, litConfig, steps)\n        if exitCode != 0:\n            raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n\n        # Split the generated output into multiple files and generate one test for each file\n        parsed = _parseLitOutput(out)\n        for (subfile, content) in self._splitFile(parsed):\n            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n            os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n            with open(generatedFile, 'w') as f:\n                f.write(content)\n            yield lit.Test.Test(testSuite, (generatedFile,), localConfig)\n\n    def _splitFile(self, input):\n        DELIM = r'^(//|#)---(.+)'\n        lines = input.splitlines()\n        currentFile = None\n        thisFileContent = []\n        for line in lines:\n            match = re.match(DELIM, line)\n            if match:\n                if currentFile is not None:\n                    yield (currentFile, '\\n'.join(thisFileContent))\n                currentFile = match.group(2).strip()\n                thisFileContent = []\n            assert currentFile is not None, f\"Some input to split-file doesn't belong to any file, input was:\\n{input}\"\n            thisFileContent.append(line)\n        if currentFile is not None:\n            yield (currentFile, '\\n'.join(thisFileContent))\n"}, "/llvm/utils/lit/lit/TestRunner.py": {"changes": [{"diff": "\n \n \n def executeBuiltinEcho(cmd, shenv):\n-    \"\"\"Interpret a redirected echo command\"\"\"\n+    \"\"\"Interpret a redirected echo or @echo command\"\"\"\n     opened_files = []\n     stdin, stdout, stderr = processRedirects(cmd, subprocess.PIPE, shenv, opened_files)\n     if stdin != subprocess.PIPE or stderr != subprocess.PIPE:\n         raise InternalShellError(\n-            cmd, \"stdin and stderr redirects not supported for echo\"\n+            cmd, f\"stdin and stderr redirects not supported for {cmd.args[0]}\"\n         )\n \n     # Some tests have un-redirected echo commands to help debug test failures.\n", "add": 2, "remove": 2, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["    \"\"\"Interpret a redirected echo command\"\"\"", "            cmd, \"stdin and stderr redirects not supported for echo\""], "goodparts": ["    \"\"\"Interpret a redirected echo or @echo command\"\"\"", "            cmd, f\"stdin and stderr redirects not supported for {cmd.args[0]}\""]}, {"diff": "\n         if res == -signal.SIGINT:\n             raise KeyboardInterrupt\n         if proc_not_counts[i] % 2:\n-            res = not res\n+            res = 1 if res == 0 else 0\n         elif proc_not_counts[i] > 1:\n             res = 1 if res != 0 else 0\n \n", "add": 1, "remove": 1, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["            res = not res"], "goodparts": ["            res = 1 if res == 0 else 0"]}, {"diff": "\n     return exitCode\n \n \n-def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n+def formatOutput(title, data, limit=None):\n+    if not data.strip():\n+        return \"\"\n+    if not limit is None and len(data) > limit:\n+        data = data[:limit] + \"\\n...\\n\"\n+        msg = \"data was truncated\"\n+    else:\n+        msg = \"\"\n+    ndashes = 30\n+    out =  f\"# .---{title}{'-' * (ndashes - 4 - len(title))}\\n\"\n+    out += f\"# | \" + \"\\n# | \".join(data.splitlines()) + \"\\n\"\n+    out += f\"# `---{msg}{'-' * (ndashes - 4 - len(msg))}\\n\"\n+    return out\n+\n+# Normally returns out, err, exitCode, timeoutInfo.\n+#\n+# If debug is True (the normal lit behavior), err is empty, and out contains an\n+# execution trace, including stdout and stderr shown per command executed.\n+#\n+# If debug is False (set by some custom lit test formats that call this\n+# function), out contains only stdout from the script, err contains only stderr\n+# from the script, and there is no execution trace.\n+def executeScriptInternal(test, litConfig, tmpBase, commands, cwd,\n+                          debug=True):\n     cmds = []\n     for i, ln in enumerate(commands):\n+        # Within lit, we try to always add '%dbg(...)' to command lines in order\n+        # to maximize debuggability.  However, custom lit test formats might not\n+        # always add it, so add a generic debug message in that case.\n         match = re.match(kPdbgRegex, ln)\n         if match:\n+            dbg = match.group(1)\n             command = match.group(2)\n-            ln = commands[i] = match.expand(\": '\\\\1'; \\\\2\" if command else \": '\\\\1'\")\n+        else:\n+            dbg = \"command line\"\n+            command = ln\n+        if debug:\n+            ln = f\"@echo '# {dbg}' \"\n+            if command:\n+                ln += f\"&& @echo {shlex.quote(command.lstrip())} && {command}\"\n+            else:\n+                ln += \"has no command after substitutions\"\n+        else:\n+            ln = command\n         try:\n             cmds.append(\n                 ShUtil.ShParser(ln, litConfig.isWindows, test.config.pipefail).parse()\n             )\n         except:\n-            return lit.Test.Result(Test.FAIL, \"shell parser error on: %r\" % ln)\n+            return lit.Test.Result(\n+                Test.FAIL, f\"shell parser error on {dbg}: {command.lstrip()}\\n\"\n+            )\n \n     cmd = cmds[0]\n     for c in cmds[1:]:\n", "add": 42, "remove": 3, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):", "            ln = commands[i] = match.expand(\": '\\\\1'; \\\\2\" if command else \": '\\\\1'\")", "            return lit.Test.Result(Test.FAIL, \"shell parser error on: %r\" % ln)"], "goodparts": ["def formatOutput(title, data, limit=None):", "    if not data.strip():", "        return \"\"", "    if not limit is None and len(data) > limit:", "        data = data[:limit] + \"\\n...\\n\"", "        msg = \"data was truncated\"", "    else:", "        msg = \"\"", "    ndashes = 30", "    out =  f\"# .---{title}{'-' * (ndashes - 4 - len(title))}\\n\"", "    out += f\"# | \" + \"\\n# | \".join(data.splitlines()) + \"\\n\"", "    out += f\"# `---{msg}{'-' * (ndashes - 4 - len(msg))}\\n\"", "    return out", "def executeScriptInternal(test, litConfig, tmpBase, commands, cwd,", "                          debug=True):", "            dbg = match.group(1)", "        else:", "            dbg = \"command line\"", "            command = ln", "        if debug:", "            ln = f\"@echo '# {dbg}' \"", "            if command:", "                ln += f\"&& @echo {shlex.quote(command.lstrip())} && {command}\"", "            else:", "                ln += \"has no command after substitutions\"", "        else:", "            ln = command", "            return lit.Test.Result(", "                Test.FAIL, f\"shell parser error on {dbg}: {command.lstrip()}\\n\"", "            )"]}, {"diff": "\n \n     out = err = \"\"\n     for i, result in enumerate(results):\n-        # Write the command line run.\n-        out += \"$ %s\\n\" % (\" \".join('\"%s\"' % s for s in result.command.args),)\n+        if not debug:\n+            out += result.stdout\n+            err += result.stderr\n+            continue\n+\n+        # The purpose of an \"@echo\" command is merely to add a debugging message\n+        # directly to lit's output.  It is used internally by lit's internal\n+        # shell and is not currently documented for use in lit tests.  However,\n+        # if someone misuses it (e.g., both \"echo\" and \"@echo\" complain about\n+        # stdin redirection), produce the normal execution trace to facilitate\n+        # debugging.\n+        if (\n+            result.command.args[0] == \"@echo\"\n+            and result.exitCode == 0\n+            and not result.stderr\n+            and not result.outputFiles\n+            and not result.timeoutReached\n+        ):\n+            out += result.stdout\n+            continue\n+\n+        # Write the command line that was run.  Properly quote it.  Leading\n+        # \"!\" commands should not be quoted as that would indicate they are not\n+        # the builtins.\n+        out += \"# executed command: \"\n+        nLeadingBangs = next(\n+            (i for i, cmd in enumerate(result.command.args) if cmd != \"!\"),\n+            len(result.command.args),\n+        )\n+        out += \"! \" * nLeadingBangs\n+        out += \" \".join(\n+            shlex.quote(str(s))\n+            for i, s in enumerate(result.command.args)\n+            if i >= nLeadingBangs\n+        )\n+        out += \"\\n\"\n \n         # If nothing interesting happened, move on.\n         if (\n", "add": 36, "remove": 2, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["        out += \"$ %s\\n\" % (\" \".join('\"%s\"' % s for s in result.command.args),)"], "goodparts": ["        if not debug:", "            out += result.stdout", "            err += result.stderr", "            continue", "        if (", "            result.command.args[0] == \"@echo\"", "            and result.exitCode == 0", "            and not result.stderr", "            and not result.outputFiles", "            and not result.timeoutReached", "        ):", "            out += result.stdout", "            continue", "        out += \"# executed command: \"", "        nLeadingBangs = next(", "            (i for i, cmd in enumerate(result.command.args) if cmd != \"!\"),", "            len(result.command.args),", "        )", "        out += \"! \" * nLeadingBangs", "        out += \" \".join(", "            shlex.quote(str(s))", "            for i, s in enumerate(result.command.args)", "            if i >= nLeadingBangs", "        )", "        out += \"\\n\""]}, {"diff": "\n \n         # Add the command output, if redirected.\n         for (name, path, data) in result.outputFiles:\n-            if data.strip():\n-                out += \"# redirected output from %r:\\n\" % (name,)\n-                data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n-                if len(data) > 1024:\n-                    out += data[:1024] + \"\\n...\\n\"\n-                    out += \"note: data was truncated\\n\"\n-                else:\n-                    out += data\n-                out += \"\\n\"\n-\n+            data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n+            out += formatOutput(\n+                f\"redirected output from '{name}'\", data, limit=1024\n+            )\n         if result.stdout.strip():\n-            out += \"# command output:\\n%s\\n\" % (result.stdout,)\n+            out += formatOutput(\"command stdout\", result.stdout)\n         if result.stderr.strip():\n-            out += \"# command stderr:\\n%s\\n\" % (result.stderr,)\n+            out += formatOutput(\"command stderr\", result.stderr)\n         if not result.stdout.strip() and not result.stderr.strip():\n-            out += \"note: command had no output on stdout or stderr\\n\"\n+            out += \"# note: command had no output on stdout or stderr\\n\"\n \n         # Show the error conditions:\n         if result.exitCode != 0:\n", "add": 7, "remove": 13, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["            if data.strip():", "                out += \"# redirected output from %r:\\n\" % (name,)", "                data = to_string(data.decode(\"utf-8\", errors=\"replace\"))", "                if len(data) > 1024:", "                    out += data[:1024] + \"\\n...\\n\"", "                    out += \"note: data was truncated\\n\"", "                else:", "                    out += data", "                out += \"\\n\"", "            out += \"# command output:\\n%s\\n\" % (result.stdout,)", "            out += \"# command stderr:\\n%s\\n\" % (result.stderr,)", "            out += \"note: command had no output on stdout or stderr\\n\""], "goodparts": ["            data = to_string(data.decode(\"utf-8\", errors=\"replace\"))", "            out += formatOutput(", "                f\"redirected output from '{name}'\", data, limit=1024", "            )", "            out += formatOutput(\"command stdout\", result.stdout)", "            out += formatOutput(\"command stderr\", result.stderr)", "            out += \"# note: command had no output on stdout or stderr\\n\""]}, {"diff": "\n                 codeStr = hex(int(result.exitCode & 0xFFFFFFFF)).rstrip(\"L\")\n             else:\n                 codeStr = str(result.exitCode)\n-            out += \"error: command failed with exit status: %s\\n\" % (codeStr,)\n+            out += \"# error: command failed with exit status: %s\\n\" % (codeStr,)\n         if litConfig.maxIndividualTestTime > 0 and result.timeoutReached:\n-            out += \"error: command reached timeout: %s\\n\" % (\n+            out += \"# error: command reached timeout: %s\\n\" % (\n                 str(result.timeoutReached),\n             )\n \n", "add": 2, "remove": 2, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["            out += \"error: command failed with exit status: %s\\n\" % (codeStr,)", "            out += \"error: command reached timeout: %s\\n\" % ("], "goodparts": ["            out += \"# error: command failed with exit status: %s\\n\" % (codeStr,)", "            out += \"# error: command reached timeout: %s\\n\" % ("]}, {"diff": "\n         if not output or not output[-1].add_continuation(line_number, keyword, line):\n             if output is None:\n                 output = []\n-            pdbg = \"%dbg({keyword} at line {line_number})\".format(\n-                keyword=keyword, line_number=line_number\n-            )\n-            assert re.match(\n-                kPdbgRegex + \"$\", pdbg\n-            ), \"kPdbgRegex expected to match actual %dbg usage\"\n-            line = \"{pdbg} {real_command}\".format(pdbg=pdbg, real_command=line)\n+            line = buildPdbgCommand(f\"{keyword} at line {line_number}\", line)\n             output.append(CommandDirective(line_number, line_number, keyword, line))\n         return output\n \n", "add": 1, "remove": 7, "filename": "/llvm/utils/lit/lit/TestRunner.py", "badparts": ["            pdbg = \"%dbg({keyword} at line {line_number})\".format(", "                keyword=keyword, line_number=line_number", "            )", "            assert re.match(", "                kPdbgRegex + \"$\", pdbg", "            ), \"kPdbgRegex expected to match actual %dbg usage\"", "            line = \"{pdbg} {real_command}\".format(pdbg=pdbg, real_command=line)"], "goodparts": ["            line = buildPdbgCommand(f\"{keyword} at line {line_number}\", line)"]}]}}, "msg": "[lit] Improve test output from lit's internal shell\n\nThis patch and D154984 were discussed in\n<https://discourse.llvm.org/t/rfc-improving-lits-debug-output/72839>.\n\nMotivation\n----------\n\nD154984 removes the \"Script:\" section that lit prints along with a\ntest's output, and it makes -v and -a imply -vv.  For example, after\nD154984, the \"Script:\" section below is never shown, but -v is enough\nto produce the execution trace following it:\n\n```\n Script:\n --\n : 'RUN: at line 1'; echo hello | FileCheck bogus.txt && echo success\n --\n Exit Code: 2\n\n Command Output (stdout):\n --\n $ \":\" \"RUN: at line 1\"\n $ \"echo\" \"hello\"\n # command output:\n hello\n\n $ \"FileCheck\" \"bogus.txt\"\n # command stderr:\n Could not open check file 'bogus.txt': No such file or directory\n\n error: command failed with exit status: 2\n\n --\n```\n\nIn the D154984 review, some reviewers point out that they have been\nusing the \"Script:\" section for copying and pasting a test's shell\ncommands to a terminal window.  The shell commands as printed in the\nexecution trace can be harder to copy and paste for the following\nreasons:\n\n- They drop redirections and break apart RUN lines at `&&`, `|`, etc.\n- They add `$` at the start of every command, which makes it hard to\n  copy and paste multiple commands in bulk.\n- Command stdout, stderr, etc. are interleaved with the commands and\n  are not clearly delineated.\n- They don't always use proper shell quoting.  Instead, they blindly\n  enclose all command-line arguments in double quotes.\n\nChanges\n-------\n\nD154984 plus this patch converts the above example into:\n\n```\n Exit Code: 2\n\n Command Output (stdout):\n --\n # RUN: at line 1\n echo hello | FileCheck bogus-file.txt && echo success\n # executed command: echo hello\n # .---command stdout------------\n # | hello\n # `-----------------------------\n # executed command: FileCheck bogus-file.txt\n # .---command stderr------------\n # | Could not open check file 'bogus-file.txt': No such file or directory\n # `-----------------------------\n # error: command failed with exit status: 2\n\n --\n```\n\nThus, this patch addresses the above issues as follows:\n\n- The entire execution trace can be copied and pasted in bulk to a\n  terminal for correct execution of the RUN lines, which are printed\n  intact as they appeared in the original RUN lines except lit\n  substitutions are expanded.  Everything else in the execution trace\n  appears in shell comments so it has no effect in a terminal.\n- Each of the RUN line's commands is repeated (in shell comments) as\n  it executes to show (1) that the command actually executed (e.g.,\n  `echo success` above didn't) and (2) what stdout, stderr, non-zero\n  exit status, and output files are associated with the command, if\n  any.  Shell quoting in the command is now correct and minimal but is\n  not necessarily the original shell quoting from the RUN line.\n- The start and end of the contents of stdout, stderr, or an output\n  file is now delineated clearly in the trace.\n\nTo help produce some of the above output, this patch extends lit's\ninternal shell with a built-in `@echo` command.  It's like `echo`\nexcept lit suppresses the normal execution trace for `@echo` and just\nprints its stdout directly.  For now, `@echo` isn't documented for use\nin lit tests.\n\nWithout this patch, libcxx's custom lit test format tries to parse the\nstdout from `lit.TestRunner.executeScriptInternal` (which runs lit's\ninternal shell) to extract the stdout and stderr produced by shell\ncommands, and that parse no longer works after the above changes.\nThis patch makes a small adjustment to\n`lit.TestRunner.executeScriptInternal` so libcxx can just request\nstdout and stderr without an execution trace.\n\n(As a minor drive-by fix that came up in testing: lit's internal `not`\ncommand now always produces a numeric exit status and never `True`.)\n\nCaveat\n------\n\nThis patch only makes the above changes for lit's internal shell.  In\nmost cases, we do not know how to force external shells (e.g., bash,\nsh, window's `cmd`) to produce execution traces in the manner we want.\n\nTo configure a test suite to use lit's internal shell (which is\nusually better for test portability than external shells anyway), add\nthis to the test suite's `lit.cfg` or other configuration file:\n\n```\nconfig.test_format = lit.formats.ShTest(execute_external=False)\n```\n\nReviewed By: MaskRay, awarzynski\n\nDifferential Revision: https://reviews.llvm.org/D156954"}, "f223022a4c521296a6d058862d66443ab9e355bf": {"url": "https://api.github.com/repos/llvm-mos/llvm-mos/commits/f223022a4c521296a6d058862d66443ab9e355bf", "html_url": "https://github.com/llvm-mos/llvm-mos/commit/f223022a4c521296a6d058862d66443ab9e355bf", "sha": "f223022a4c521296a6d058862d66443ab9e355bf", "keyword": "execution after redirect correct", "diff": "diff --git a/libcxx/utils/libcxx/test/dsl.py b/libcxx/utils/libcxx/test/dsl.py\nindex d2e0c6036dd3..5d4ca83be130 100644\n--- a/libcxx/utils/libcxx/test/dsl.py\n+++ b/libcxx/utils/libcxx/test/dsl.py\n@@ -186,7 +186,7 @@ def programOutput(config, program, args=None):\n                 \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n             )\n \n-        return libcxx.test.format._parseLitOutput(out)\n+        return out\n \n \n @_memoizeExpensiveOperation(\ndiff --git a/libcxx/utils/libcxx/test/format.py b/libcxx/utils/libcxx/test/format.py\nindex ddd88f25646e..c7c0bad681dd 100644\n--- a/libcxx/utils/libcxx/test/format.py\n+++ b/libcxx/utils/libcxx/test/format.py\n@@ -35,39 +35,6 @@ def _checkBaseSubstitutions(substitutions):\n     for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n         assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n \n-def _parseLitOutput(fullOutput):\n-    \"\"\"\n-    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n-\n-    This takes output of the form\n-\n-        $ \":\" \"RUN: at line 11\"\n-        $ \"echo\" \"OUTPUT1\"\n-        # command output:\n-        OUTPUT1\n-\n-        $ \":\" \"RUN: at line 12\"\n-        $ \"echo\" \"OUTPUT2\"\n-        # command output:\n-        OUTPUT2\n-\n-    and returns a string containing\n-\n-        OUTPUT1\n-        OUTPUT2\n-\n-    as-if the commands had been run directly. This is a workaround for the fact\n-    that Lit doesn't let us execute ShTest and retrieve the raw output without\n-    injecting additional Lit output around it.\n-    \"\"\"\n-    parsed = ''\n-    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n-        if output: # skip blank lines\n-            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n-            if commandOutput:\n-                parsed += commandOutput.group(1)\n-    return parsed\n-\n def _executeScriptInternal(test, litConfig, commands):\n     \"\"\"\n     Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n@@ -79,21 +46,12 @@ def _executeScriptInternal(test, litConfig, commands):\n     _, tmpBase = _getTempPaths(test)\n     execDir = os.path.dirname(test.getExecPath())\n     res = lit.TestRunner.executeScriptInternal(\n-        test, litConfig, tmpBase, parsedCommands, execDir\n+        test, litConfig, tmpBase, parsedCommands, execDir, debug=False\n     )\n     if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n         res = (\"\", res.output, 127, None)\n     (out, err, exitCode, timeoutInfo) = res\n \n-    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n-    #       split any stderr output that is included in stdout. It shouldn't be there, but\n-    #       the Lit internal shell conflates stderr and stdout.\n-    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n-    if conflatedErrorOutput:\n-        conflatedErrorOutput = conflatedErrorOutput.group(0)\n-        out = out[: -len(conflatedErrorOutput)]\n-        err += conflatedErrorOutput\n-\n     return (out, err, exitCode, timeoutInfo, parsedCommands)\n \n \n@@ -400,9 +358,8 @@ def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig):\n             raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n \n         # Split the generated output into multiple files and generate one test for each file\n-        parsed = _parseLitOutput(out)\n-        for (subfile, content) in self._splitFile(parsed):\n-            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n+        for subfile, content in self._splitFile(out):\n+            generatedFile = testSuite.getExecPath(pathInSuite + (subfile,))\n             os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n             with open(generatedFile, 'w') as f:\n                 f.write(content)\ndiff --git a/llvm/docs/CommandGuide/lit.rst b/llvm/docs/CommandGuide/lit.rst\nindex b494c74889aa..5e2443cb612a 100644\n--- a/llvm/docs/CommandGuide/lit.rst\n+++ b/llvm/docs/CommandGuide/lit.rst\n@@ -96,10 +96,9 @@ OUTPUT OPTIONS\n \n  Each command is printed before it is executed. This can be valuable for\n  debugging test failures, as the last printed command is the one that failed.\n- Moreover, :program:`lit` inserts a no-op command (``:`` in the case of bash)\n- with argument ``'RUN: at line N'`` before each command pipeline, and those\n- no-op commands are also printed to help you locate the source line of the\n- failed command.\n+ Moreover, :program:`lit` inserts ``'RUN: at line N'`` before each\n+ command pipeline in the output to help you locate the source line of\n+ the failed command.\n \n .. option:: -vv, --echo-all-commands\n \ndiff --git a/llvm/utils/lit/lit/TestRunner.py b/llvm/utils/lit/lit/TestRunner.py\nindex 0539b280a176..f85627eaf3de 100644\n--- a/llvm/utils/lit/lit/TestRunner.py\n+++ b/llvm/utils/lit/lit/TestRunner.py\n@@ -8,6 +8,7 @@\n import stat\n import pathlib\n import platform\n+import shlex\n import shutil\n import tempfile\n import threading\n@@ -348,12 +349,12 @@ def executeBuiltinExport(cmd, shenv):\n \n \n def executeBuiltinEcho(cmd, shenv):\n-    \"\"\"Interpret a redirected echo command\"\"\"\n+    \"\"\"Interpret a redirected echo or @echo command\"\"\"\n     opened_files = []\n     stdin, stdout, stderr = processRedirects(cmd, subprocess.PIPE, shenv, opened_files)\n     if stdin != subprocess.PIPE or stderr != subprocess.PIPE:\n         raise InternalShellError(\n-            cmd, \"stdin and stderr redirects not supported for echo\"\n+            cmd, f\"stdin and stderr redirects not supported for {cmd.args[0]}\"\n         )\n \n     # Some tests have un-redirected echo commands to help debug test failures.\n@@ -700,6 +701,7 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n         \"cd\": executeBuiltinCd,\n         \"export\": executeBuiltinExport,\n         \"echo\": executeBuiltinEcho,\n+        \"@echo\": executeBuiltinEcho,\n         \"mkdir\": executeBuiltinMkdir,\n         \"popd\": executeBuiltinPopd,\n         \"pushd\": executeBuiltinPushd,\n@@ -927,7 +929,7 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n         if res == -signal.SIGINT:\n             raise KeyboardInterrupt\n         if proc_not_counts[i] % 2:\n-            res = not res\n+            res = 1 if res == 0 else 0\n         elif proc_not_counts[i] > 1:\n             res = 1 if res != 0 else 0\n \n@@ -990,19 +992,60 @@ def _executeShCmd(cmd, shenv, results, timeoutHelper):\n     return exitCode\n \n \n-def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n+def formatOutput(title, data, limit=None):\n+    if not data.strip():\n+        return \"\"\n+    if not limit is None and len(data) > limit:\n+        data = data[:limit] + \"\\n...\\n\"\n+        msg = \"data was truncated\"\n+    else:\n+        msg = \"\"\n+    ndashes = 30\n+    # fmt: off\n+    out =  f\"# .---{title}{'-' * (ndashes - 4 - len(title))}\\n\"\n+    out += f\"# | \" + \"\\n# | \".join(data.splitlines()) + \"\\n\"\n+    out += f\"# `---{msg}{'-' * (ndashes - 4 - len(msg))}\\n\"\n+    # fmt: on\n+    return out\n+\n+\n+# Normally returns out, err, exitCode, timeoutInfo.\n+#\n+# If debug is True (the normal lit behavior), err is empty, and out contains an\n+# execution trace, including stdout and stderr shown per command executed.\n+#\n+# If debug is False (set by some custom lit test formats that call this\n+# function), out contains only stdout from the script, err contains only stderr\n+# from the script, and there is no execution trace.\n+def executeScriptInternal(test, litConfig, tmpBase, commands, cwd, debug=True):\n     cmds = []\n     for i, ln in enumerate(commands):\n+        # Within lit, we try to always add '%dbg(...)' to command lines in order\n+        # to maximize debuggability.  However, custom lit test formats might not\n+        # always add it, so add a generic debug message in that case.\n         match = re.fullmatch(kPdbgRegex, ln)\n         if match:\n+            dbg = match.group(1)\n             command = match.group(2)\n-            ln = commands[i] = match.expand(\": '\\\\1'; \\\\2\" if command else \": '\\\\1'\")\n+        else:\n+            dbg = \"command line\"\n+            command = ln\n+        if debug:\n+            ln = f\"@echo '# {dbg}' \"\n+            if command:\n+                ln += f\"&& @echo {shlex.quote(command.lstrip())} && {command}\"\n+            else:\n+                ln += \"has no command after substitutions\"\n+        else:\n+            ln = command\n         try:\n             cmds.append(\n                 ShUtil.ShParser(ln, litConfig.isWindows, test.config.pipefail).parse()\n             )\n         except:\n-            return lit.Test.Result(Test.FAIL, \"shell parser error on: %r\" % ln)\n+            return lit.Test.Result(\n+                Test.FAIL, f\"shell parser error on {dbg}: {command.lstrip()}\\n\"\n+            )\n \n     cmd = cmds[0]\n     for c in cmds[1:]:\n@@ -1022,8 +1065,42 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n \n     out = err = \"\"\n     for i, result in enumerate(results):\n-        # Write the command line run.\n-        out += \"$ %s\\n\" % (\" \".join('\"%s\"' % s for s in result.command.args),)\n+        if not debug:\n+            out += result.stdout\n+            err += result.stderr\n+            continue\n+\n+        # The purpose of an \"@echo\" command is merely to add a debugging message\n+        # directly to lit's output.  It is used internally by lit's internal\n+        # shell and is not currently documented for use in lit tests.  However,\n+        # if someone misuses it (e.g., both \"echo\" and \"@echo\" complain about\n+        # stdin redirection), produce the normal execution trace to facilitate\n+        # debugging.\n+        if (\n+            result.command.args[0] == \"@echo\"\n+            and result.exitCode == 0\n+            and not result.stderr\n+            and not result.outputFiles\n+            and not result.timeoutReached\n+        ):\n+            out += result.stdout\n+            continue\n+\n+        # Write the command line that was run.  Properly quote it.  Leading\n+        # \"!\" commands should not be quoted as that would indicate they are not\n+        # the builtins.\n+        out += \"# executed command: \"\n+        nLeadingBangs = next(\n+            (i for i, cmd in enumerate(result.command.args) if cmd != \"!\"),\n+            len(result.command.args),\n+        )\n+        out += \"! \" * nLeadingBangs\n+        out += \" \".join(\n+            shlex.quote(str(s))\n+            for i, s in enumerate(result.command.args)\n+            if i >= nLeadingBangs\n+        )\n+        out += \"\\n\"\n \n         # If nothing interesting happened, move on.\n         if (\n@@ -1038,22 +1115,14 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n \n         # Add the command output, if redirected.\n         for (name, path, data) in result.outputFiles:\n-            if data.strip():\n-                out += \"# redirected output from %r:\\n\" % (name,)\n-                data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n-                if len(data) > 1024:\n-                    out += data[:1024] + \"\\n...\\n\"\n-                    out += \"note: data was truncated\\n\"\n-                else:\n-                    out += data\n-                out += \"\\n\"\n-\n+            data = to_string(data.decode(\"utf-8\", errors=\"replace\"))\n+            out += formatOutput(f\"redirected output from '{name}'\", data, limit=1024)\n         if result.stdout.strip():\n-            out += \"# command output:\\n%s\\n\" % (result.stdout,)\n+            out += formatOutput(\"command stdout\", result.stdout)\n         if result.stderr.strip():\n-            out += \"# command stderr:\\n%s\\n\" % (result.stderr,)\n+            out += formatOutput(\"command stderr\", result.stderr)\n         if not result.stdout.strip() and not result.stderr.strip():\n-            out += \"note: command had no output on stdout or stderr\\n\"\n+            out += \"# note: command had no output on stdout or stderr\\n\"\n \n         # Show the error conditions:\n         if result.exitCode != 0:\n@@ -1063,9 +1132,9 @@ def executeScriptInternal(test, litConfig, tmpBase, commands, cwd):\n                 codeStr = hex(int(result.exitCode & 0xFFFFFFFF)).rstrip(\"L\")\n             else:\n                 codeStr = str(result.exitCode)\n-            out += \"error: command failed with exit status: %s\\n\" % (codeStr,)\n+            out += \"# error: command failed with exit status: %s\\n\" % (codeStr,)\n         if litConfig.maxIndividualTestTime > 0 and result.timeoutReached:\n-            out += \"error: command reached timeout: %s\\n\" % (\n+            out += \"# error: command reached timeout: %s\\n\" % (\n                 str(result.timeoutReached),\n             )\n \n@@ -2117,6 +2186,8 @@ def executeShTest(\n         return lit.Test.Result(Test.UNSUPPORTED, \"Test is unsupported\")\n \n     script = list(preamble_commands)\n+    script = [buildPdbgCommand(f\"preamble command line\", ln) for ln in script]\n+\n     parsed = parseIntegratedTestScript(test, require_script=not script)\n     if isinstance(parsed, lit.Test.Result):\n         return parsed\ndiff --git a/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg b/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\nindex cf1a4f1ba1ec..301208c25bdc 100644\n--- a/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\n+++ b/llvm/utils/lit/tests/Inputs/lit-opts/lit.cfg\n@@ -5,4 +5,4 @@ config.suffixes = [\".txt\"]\n config.test_format = lit.formats.ShTest()\n config.test_source_root = None\n config.test_exec_root = None\n-config.substitutions.append((\"%var\", lit_config.params.get(\"var\", \"\")))\n+config.substitutions.append((\"%var\", lit_config.params.get(\"var\", \"default\")))\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt b/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\nindex 6dd9b16304e0..1d94c1213723 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/examples/param-subst.txt\n@@ -14,21 +14,21 @@\n ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0 -fopenmp-simd\n ; REDEFINE: %{fcflags} = -check-prefix=SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu -fopenmp-simd\n ; REDEFINE: %{fcflags} = -check-prefix=SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -fopenmp-simd -emit-llvm -o - {{.*}} | FileCheck -check-prefix=SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0\n ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-apple-darwin10.6.0 -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n \n ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu\n ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD\n ; RUN: %{check}\n-; CHECK: %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n+; CHECK:# | %clang_cc1 -verify -fopenmp -fopenmp-version=51 -triple x86_64-unknown-linux-gnu -emit-llvm -o - {{.*}} | FileCheck -check-prefix=NO-SIMD {{.*}}\n \n ; CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt b/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\nindex 3bf057151afb..23c0a6d50753 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/expansion-order.txt\n@@ -7,7 +7,7 @@\n #\n # REDEFINE: %{global:greeting}=Hello\n # RUN: %{global:echo}\n-# CHECK: GLOBAL: Hello World\n+# CHECK:# | GLOBAL: Hello World\n \n # We can redefine the test suite config's substitutions multiple times.  Again,\n # the expansion order remains the same (%{global:echo} before %{global:greeting}\n@@ -17,7 +17,7 @@\n # REDEFINE: %{global:greeting}=Goodbye %{global:what}\n # REDEFINE: %{global:what}=Sleep\n # RUN: %{global:echo}\n-# CHECK: GLOBAL: Goodbye Sleep Sleep\n+# CHECK:# | GLOBAL: Goodbye Sleep Sleep\n \n # A new local substitution is prepended to the substitution list so that it can\n # depend on all substitutions that were defined previously, including those from\n@@ -26,7 +26,7 @@\n # DEFINE: %{local:greeting}=Hey %{global:what}\n # DEFINE: %{local:echo}=echo \"LOCAL: %{local:greeting} %{global:what}\"\n # RUN: %{local:echo}\n-# CHECK: LOCAL: Hey Sleep Sleep\n+# CHECK:# | LOCAL: Hey Sleep Sleep\n \n # As for substitutions from the test suite config, redefining local\n # substitutions should not change the expansion order.  Again, the expansion\n@@ -36,6 +36,6 @@\n # REDEFINE: %{local:greeting}=So Long %{global:what}\n # REDEFINE: %{global:what}=World\n # RUN: %{local:echo}\n-# CHECK: LOCAL: So Long World World\n+# CHECK:# | LOCAL: So Long World World\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt b/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\nindex 65f90792ff7b..5a1d7f2e1987 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/line-number-substitutions.txt\n@@ -1,19 +1,19 @@\n # Does it work as expected directly in RUN lines?\n # RUN: echo %(line), %(line-1), %(line+2)\n-# CHECK: [[#@LINE-1]], [[#@LINE-2]], [[#@LINE+1]]\n+# CHECK:# | [[#@LINE-1]], [[#@LINE-2]], [[#@LINE+1]]\n \n # %(line) substitutions refer to the original DEFINE/REDEFINE line not the RUN\n # line they eventually appear within.\n #\n # DEFINE: %{lines} = %(line)\n # RUN: echo '%{lines}'\n-# CHECK: [[#@LINE-2]]\n+# CHECK:# | [[#@LINE-2]]\n #\n # REDEFINE: %{lines} = %(line),                                                \\\n # REDEFINE:            %(line),                                                \\\n # REDEFINE:            %(line)\n # RUN: echo '%{lines}'\n-# CHECK: [[#@LINE-4]], [[#@LINE-3]], [[#@LINE-2]]\n+# CHECK:# | [[#@LINE-4]], [[#@LINE-3]], [[#@LINE-2]]\n \n # %(line+N) and %{line-N) should work too.\n #\n@@ -21,12 +21,12 @@\n # DEFINE:                %(line),                                              \\\n # DEFINE:                %(line-1)\n # RUN: echo '%{lines-rel}'\n-# CHECK: [[#@LINE-3]], [[#@LINE-3]], [[#@LINE-3]]\n+# CHECK:# | [[#@LINE-3]], [[#@LINE-3]], [[#@LINE-3]]\n #\n # REDEFINE: %{lines-rel} = %(line+5),                                          \\\n # REDEFINE:                %(line+0),                                          \\\n # REDEFINE:                %(line-10)\n # RUN: echo '%{lines-rel}'\n-# CHECK: [[#@LINE+1]], [[#@LINE-3]], [[#@LINE-12]]\n+# CHECK:# | [[#@LINE+1]], [[#@LINE-3]], [[#@LINE-12]]\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt b/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\nindex 18a27cdd72fa..d27fda2e2fe6 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/name-chars.txt\n@@ -1,25 +1,25 @@\n # DEFINE: %{abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789} = ok\n # RUN: echo '%{abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789}'\n-# CHECK: ok\n+# CHECK:# | ok\n \n # DEFINE: %{FooBar} = ok at %(line)\n # RUN: echo '%{FooBar}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{fooBar} = ok at %(line)\n # RUN: echo '%{fooBar}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{foo-bar-} = ok at %(line)\n # RUN: echo '%{foo-bar-}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{foo:bar:} = ok at %(line)\n # RUN: echo '%{foo:bar:}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # DEFINE: %{_foo_bar_} = ok at %(line)\n # RUN: echo '%{_foo_bar_}'\n-# CHECK: ok at [[#@LINE - 2]]\n+# CHECK:# | ok at [[#@LINE - 2]]\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt b/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\nindex eb5f0b918fd1..e504b822ace8 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/recursiveExpansionLimit.txt\n@@ -6,7 +6,7 @@\n \n # RUN: echo '%{outer}'\n \n-# CHECK-NON-RECUR:%{inner}\n-# CHECK-RECUR:expanded\n+# CHECK-NON-RECUR:# | %{inner}\n+# CHECK-RECUR:# | expanded\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt b/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\nindex 9d2e7197fb3a..c1bdfef30b1a 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/value-equals.txt\n@@ -2,21 +2,21 @@\n \n # DEFINE: %{equals} = FileCheck -check-prefixes=FOO,BAR\n # RUN: echo '%{equals}'\n-# CHECK: FileCheck -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -check-prefixes=FOO,BAR\n #\n # REDEFINE: %{equals} == == =\n # RUN: echo '%{equals}'\n-# CHECK: = == =\n+# CHECK:# | = == =\n \n # DEFINE: %{continue-equals} = FileCheck -strict-whitespace -match-full-lines \\\n # DEFINE:                      -check-prefixes=FOO,BAR\n # RUN: echo '%{continue-equals}'\n-# CHECK: FileCheck -strict-whitespace -match-full-lines -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -strict-whitespace -match-full-lines -check-prefixes=FOO,BAR\n #\n # REDEFINE: %{continue-equals} = FileCheck -input-file=test.txt                \\\n # REDEFINE:                      -implicit-check-not=foobar                    \\\n # REDEFINE:                      -check-prefixes=FOO,BAR\n # RUN: echo '%{continue-equals}'\n-# CHECK: FileCheck -input-file=test.txt -implicit-check-not=foobar -check-prefixes=FOO,BAR\n+# CHECK:# | FileCheck -input-file=test.txt -implicit-check-not=foobar -check-prefixes=FOO,BAR\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt b/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\nindex 58d5c1a34ce8..9143796edd32 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/value-escaped.txt\n@@ -6,11 +6,11 @@\n \n # DEFINE: %{escape} = \\g<0>\\n\n # RUN: echo '%{escape}'\n-# CHECK: {{\\\\?}}\\g<0>{{\\\\?}}\\n\n+# CHECK:# | {{\\\\?}}\\g<0>{{\\\\?}}\\n\n \n # REDEFINE: %{escape} = \\n                                                     \\\n # REDEFINE:             \\g<param>\n # RUN: echo '%{escape}'\n-# CHECK: {{\\\\?}}\\n {{\\\\?}}\\g<param>\n+# CHECK:# | {{\\\\?}}\\n {{\\\\?}}\\g<param>\n \n # CHECK: Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt b/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\nindex 1259e511ba70..3e4db1b15d92 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-define/ws-and-continuations.txt\n@@ -3,33 +3,33 @@\n #\n # DEFINE: %{empty}=\n # RUN: echo \"'%{empty}'\"\n-# CHECK:''\n+# CHECK:# | ''\n #\n # REDEFINE: %{empty}=\n # RUN: echo \"'%{empty}'\"\n-# CHECK:''\n+# CHECK:# | ''\n \n # A value consisting only of whitespace is trimmed to the empty string.\n #\n #               v~~ intentional whitespace\n # DEFINE: %{ws}=   \n # RUN: echo \"'%{ws}'\"\n-# CHECK:''\n+# CHECK:# | ''\n #\n #                 v intentional whitespace\n # REDEFINE: %{ws}= \n # RUN: echo \"'%{ws}'\"\n-# CHECK:''\n+# CHECK:# | ''\n \n # Whitespace is not required around the name or value.\n #\n # DEFINE:%{no-whitespace}=abc\n # RUN: echo \"'%{no-whitespace}'\"\n-# CHECK:'abc'\n+# CHECK:# | 'abc'\n #\n # REDEFINE:%{no-whitespace}=HelloWorld\n # RUN: echo \"'%{no-whitespace}'\"\n-# CHECK:'HelloWorld'\n+# CHECK:# | 'HelloWorld'\n \n # Whitespace is not required between substitutions in a value.\n #\n@@ -37,11 +37,11 @@\n # DEFINE: %{adjacent1} = bar\n # DEFINE: %{has-adjacent-substs} = %{adjacent0}%{adjacent1}\n # RUN: echo \"'%{has-adjacent-substs}'\"\n-# CHECK:'foobar'\n+# CHECK:# | 'foobar'\n #\n # REDEFINE: %{has-adjacent-substs} = %{adjacent0}%{adjacent1}%{adjacent0}\n # RUN: echo \"'%{has-adjacent-substs}'\"\n-# CHECK:'foobarfoo'\n+# CHECK:# | 'foobarfoo'\n \n # Exact whitespace is preserved within the value, but whitespace enclosing the\n # name or value is discarded.  ('%{' and '}' are part of the name, and\n@@ -50,11 +50,11 @@\n #                                       v~~ intentional whitespace\n # DEFINE:   %{whitespace}  =  abc    def   \n # RUN: echo \"'%{whitespace}'\"\n-# CHECK:'abc    def'\n+# CHECK:# | 'abc    def'\n #                                      v intentional whitespace\n # REDEFINE: %{whitespace} = Hello World \n # RUN: echo \"'%{whitespace}'\"\n-# CHECK:'Hello World'\n+# CHECK:# | 'Hello World'\n \n # Line continuations in the value are permitted and collapse whitespace.\n #\n@@ -66,12 +66,12 @@\n # DEFINE:  pqr \n #             ^ intentional whitespace\n # RUN: echo \"'%{continue}'\"\n-# CHECK:'abc def ghi jkl mno pqr'\n+# CHECK:# | 'abc def ghi jkl mno pqr'\n #\n # REDEFINE: %{continue} =  abc  \\\n # REDEFINE: def\n # RUN: echo \"'%{continue}'\"\n-# CHECK:'abc def'\n+# CHECK:# | 'abc def'\n \n # Whitespace at the end of the line after a '\\' is ignored, and it's treated as\n # a line continuation.  Otherwise, the behavior would be hard to understand\n@@ -83,7 +83,7 @@\n #                                   ^ intentional whitespace\n # DEFINE: baz\n # RUN: echo \"'%{ws-after-continue}'\"\n-# CHECK:'foo bar baz'\n+# CHECK:# | 'foo bar baz'\n #\n #                                     v intentional whitespace\n # REDEFINE: %{ws-after-continue}=foo \\ \n@@ -91,7 +91,7 @@\n #                                     ^~~~~~~~~~~~ intentional whitespace\n # REDEFINE: baz\n # RUN: echo \"'%{ws-after-continue}'\"\n-# CHECK:'foo bar baz'\n+# CHECK:# | 'foo bar baz'\n \n # A line continuation is recognized anywhere.  It should be used only where\n # whitespace is permitted because it reduces to a single space.\n@@ -107,7 +107,7 @@\n # DEFINE:\\\n # DEFINE:a\n # RUN: echo \"'%{blank-lines}'\"\n-# CHECK:'a'\n+# CHECK:# | 'a'\n #\n # REDEFINE:                  \\\n # REDEFINE: %{blank-lines}   \\\n@@ -120,7 +120,7 @@\n # REDEFINE:                  \\\n # REDEFINE:      c\n # RUN: echo \"'%{blank-lines}'\"\n-# CHECK:'a b c'\n+# CHECK:# | 'a b c'\n \n # The fourth DEFINE line is deceptive because it looks like a new substitution,\n # but it's actually a continuation of the previous value.\n@@ -130,6 +130,6 @@\n # DEFINE: %{deceptive-continue}=echo \\\n # DEFINE: %{name}=%{value}\n # RUN: %{deceptive-continue}\n-# CHECK:x=3\n+# CHECK:# | x=3\n \n # CHECK:{{ *}}Passed: 1\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt b/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\nindex b0a7cfd97941..b5fc1b49fcc5 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-if-else/test.txt\n@@ -1,46 +1,34 @@\n-#       CHECK: -- Testing:{{.*}}\n-#  CHECK-NEXT: PASS: shtest-if-else :: test.txt (1 of 1)\n-#  CHECK-NEXT: Exit Code: 0\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: Command Output (stdout):\n-#  CHECK-NEXT: --\n+# CHECK: -- Testing:{{.*}}\n+# CHECK-NEXT: PASS: shtest-if-else :: test.txt (1 of 1)\n+#      CHECK: Command Output (stdout):\n+# CHECK-NEXT: --\n \n # RUN: %if feature %{ echo \"test-1\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-1\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-1\"\n \n # If %else is not present it is treated like %else %{%}. Empty commands\n # are ignored.\n #\n # RUN: %if nofeature %{ echo \"fail\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#   CHECK-NOT: fail\n+#     CHECK: # {{RUN}}: at line [[#@LINE-1]] has no command after substitutions\n+# CHECK-NOT: fail\n \n # RUN: %if nofeature %{ echo \"fail\" %} %else %{ echo \"test-2\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-2\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-2\"\n \n # Spaces inside curly braces are not ignored\n #\n # RUN: echo test-%if feature %{ 3 %} %else %{ fail %}-test\n # RUN: echo test-%if feature %{ 4 4 %} %else %{ fail %}-test\n # RUN: echo test-%if nofeature %{ fail %} %else %{ 5 5 %}-test\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 3 -test\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 4 4 -test\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test- 5 5 -test\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo test- 3 -test\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo test- 4 4 -test\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo test- 5 5 -test\n \n # Escape line breaks for multi-line expressions\n #\n@@ -48,42 +36,32 @@\n # RUN:   %{ echo     \\\n # RUN:     \"test-5\" \\\n # RUN:   %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-4]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-5\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-5\"\n \n # RUN: %if nofeature       \\\n # RUN:   %{ echo \"fail\" %}   \\\n # RUN: %else               \\\n # RUN:   %{ echo \"test-6\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-4]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-6\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-6\"\n \n # RUN: echo \"test%if feature %{%} %else %{%}-7\"\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-7\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-7\"\n \n # Escape %if. Without %if..%else context '%{' and '%}' are treated\n # literally.\n #\n # RUN: echo %%if feature %{ echo \"test-8\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: %if feature %{ echo test-8 %}\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo %if feature %{ echo \"test-8\" %}\n \n # Nested expressions are supported:\n #\n # RUN: echo %if feature %{ %if feature %{ %if nofeature %{\"fail\"%} %else %{\"test-9\"%} %} %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-9\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"test-9\"\n \n # Binary expression evaluation and regex match can be used as\n # conditions.\n@@ -91,18 +69,12 @@\n # RUN: echo %if feature && !nofeature %{ \"test-10\" %}\n # RUN: echo %if feature && nofeature %{ \"fail\" %} %else %{ \"test-11\" %}\n # RUN: echo %if {{fea.+}} %{ \"test-12\" %} %else %{ \"fail\" %}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-10\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-11\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: test-12\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo \"test-10\"\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo \"test-11\"\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo \"test-12\"\n \n # Spaces between %if and %else are ignored. If there is no %else -\n # space after %if %{...%} is not ignored.\n@@ -110,39 +82,27 @@\n # RUN: echo XX %if feature %{YY%} ZZ\n # RUN: echo AA %if feature %{BB%} %else %{CC%} DD\n # RUN: echo AA %if nofeature %{BB%} %else %{CC%} DD\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-3]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: XX YY ZZ\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-6]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: AA BB DD\n-# CHECK-EMPTY:\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-9]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: AA CC DD\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-3]]\n+# CHECK-NEXT: echo XX YY ZZ\n+#      CHECK: # {{RUN}}: at line [[#@LINE-4]]\n+# CHECK-NEXT: echo AA BB DD\n+#      CHECK: # {{RUN}}: at line [[#@LINE-5]]\n+# CHECK-NEXT: echo AA CC DD\n \n # '{' and '}' can be used without escaping\n #\n # RUN: %if feature %{echo {}%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: {}\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo {}\n \n # Spaces are not required\n #\n # RUN: echo %if feature%{\"ok\"%}%else%{\"fail\"%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: ok\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo \"ok\"\n \n # Substitutions with braces are handled correctly\n #\n # RUN: echo %{sub} %if feature%{test-%{sub}%}%else%{\"fail\"%}\n-#  CHECK-NEXT: {{^.*\"RUN}}: at line [[#@LINE-1]]\"\n-#       CHECK: # command output:\n-#  CHECK-NEXT: ok test-ok\n-# CHECK-EMPTY:\n+#      CHECK: # {{RUN}}: at line [[#@LINE-1]]\n+# CHECK-NEXT: echo ok test-ok\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt b/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\nindex fb3a3e000789..5ff0c891450b 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/basic.txt\n@@ -1,3 +1,4 @@\n # RUN: true\n # RUN: echo hi\n-# RUN: not not wc missing-file &> %t.out\n+# RUN: not not wc missing-file &> %t.out || true\n+# RUN: not %{python} %S/write-a-lot.py &> %t.out\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg b/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\nindex b872854d21e6..141fc3a596e7 100644\n--- a/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/lit.cfg\n@@ -2,4 +2,5 @@ import lit.formats\n \n config.name = \"shtest-output-printing\"\n config.suffixes = [\".txt\"]\n+config.substitutions.append((\"%{python}\", f'\"{sys.executable}\"'))\n config.test_format = lit.formats.ShTest(execute_external=False)\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py b/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py\nnew file mode 100644\nindex 000000000000..5dbb94a41cbf\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-output-printing/write-a-lot.py\n@@ -0,0 +1,6 @@\n+#!/usr/bin/env python\n+\n+import sys\n+\n+sys.stdout.write(\"All work and no play makes Jack a dull boy.\\n\" * 1000)\n+sys.stdout.flush()\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt\nnew file mode 100644\nindex 000000000000..15a87aee46a3\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stderr.txt\n@@ -0,0 +1 @@\n+RUN: @echo 2> %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt\nnew file mode 100644\nindex 000000000000..27fd0c4209fd\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-at-redirect-stdin.txt\n@@ -0,0 +1,2 @@\n+RUN: touch %t\n+RUN: @echo < %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt\nnew file mode 100644\nindex 000000000000..9611918f7e12\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stderr.txt\n@@ -0,0 +1 @@\n+RUN: echo 2> %t\ndiff --git a/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt\nnew file mode 100644\nindex 000000000000..bc771be6b22a\n--- /dev/null\n+++ b/llvm/utils/lit/tests/Inputs/shtest-shell/echo-redirect-stdin.txt\n@@ -0,0 +1,2 @@\n+RUN: touch %t\n+RUN: echo < %t\ndiff --git a/llvm/utils/lit/tests/allow-retries.py b/llvm/utils/lit/tests/allow-retries.py\nindex bf6c04193388..45610fb70d34 100644\n--- a/llvm/utils/lit/tests/allow-retries.py\n+++ b/llvm/utils/lit/tests/allow-retries.py\n@@ -15,9 +15,28 @@\n \n # This test does not succeed within the allowed retry limit\n #\n-# RUN: not %{lit} %{inputs}/allow-retries/does-not-succeed-within-limit.py | FileCheck --check-prefix=CHECK-TEST3 %s\n-# CHECK-TEST3: Failed Tests (1):\n-# CHECK-TEST3: allow-retries :: does-not-succeed-within-limit.py\n+# Check that the execution trace isn't corrupt due to reprocessing the script\n+# multiple times (e.g., '%dbg(...)' processing used to accumulate across\n+# retries).\n+#\n+# RUN: not %{lit} %{inputs}/allow-retries/does-not-succeed-within-limit.py -v |\\\n+# RUN:   FileCheck --check-prefix=CHECK-TEST3 -match-full-lines %s\n+#\n+#       CHECK-TEST3: FAIL: allow-retries :: does-not-succeed-within-limit.py (1 of 1)\n+#  CHECK-TEST3-NEXT: {{\\**}} TEST 'allow-retries :: does-not-succeed-within-limit.py' FAILED {{\\**}}\n+#  CHECK-TEST3-NEXT: Exit Code: 1\n+# CHECK-TEST3-EMPTY:\n+#  CHECK-TEST3-NEXT: Command Output (stdout):\n+#  CHECK-TEST3-NEXT: --\n+#  CHECK-TEST3-NEXT: # {{RUN}}: at line 3\n+#  CHECK-TEST3-NEXT: false\n+#  CHECK-TEST3-NEXT: # executed command: false\n+#  CHECK-TEST3-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-TEST3-NEXT: # error: command failed with exit status: 1\n+# CHECK-TEST3-EMPTY:\n+#  CHECK-TEST3-NEXT: --\n+#       CHECK-TEST3: Failed Tests (1):\n+#       CHECK-TEST3: allow-retries :: does-not-succeed-within-limit.py\n \n # This test should be UNRESOLVED since it has more than one ALLOW_RETRIES\n # lines, and that is not allowed.\n@@ -48,6 +67,6 @@\n # RUN:     -Dcounter=%t.counter -Dpython=%{python} | \\\n # RUN:   FileCheck --check-prefix=CHECK-TEST7 %s\n #     CHECK-TEST7: Command Output (stdout):\n-#     CHECK-TEST7: LLVM_PROFILE_FILE=\n-# CHECK-TEST7-NOT: LLVM_PROFILE_FILE=\n+#     CHECK-TEST7: # executed command: export LLVM_PROFILE_FILE=\n+# CHECK-TEST7-NOT: # executed command: export LLVM_PROFILE_FILE=\n #     CHECK-TEST7: Passed With Retry: 1\ndiff --git a/llvm/utils/lit/tests/lit-opts.py b/llvm/utils/lit/tests/lit-opts.py\nindex d292ca74f3b9..a533a59d9d12 100644\n--- a/llvm/utils/lit/tests/lit-opts.py\n+++ b/llvm/utils/lit/tests/lit-opts.py\n@@ -8,7 +8,7 @@\n #\n # RUN: env LIT_OPTS=-a \\\n # RUN: %{lit} -s %{inputs}/lit-opts \\\n-# RUN: | FileCheck -check-prefix=SHOW-ALL -DVAR= %s\n+# RUN: | FileCheck -check-prefix=SHOW-ALL -DVAR=default %s\n \n # Check that LIT_OPTS understands multiple options with arbitrary spacing.\n #\n@@ -28,6 +28,6 @@\n \n # SHOW-ALL:     Testing: 1 tests\n # SHOW-ALL:     PASS: lit-opts :: test.txt (1 of 1)\n-# SHOW-ALL:     {{^}}[[VAR]]\n+# SHOW-ALL:     echo [[VAR]]\n # SHOW-ALL-NOT: PASS\n # SHOW-ALL:     Passed: 1\ndiff --git a/llvm/utils/lit/tests/shtest-define.py b/llvm/utils/lit/tests/shtest-define.py\nindex 1d0997bbbaf8..8c9309804cce 100644\n--- a/llvm/utils/lit/tests/shtest-define.py\n+++ b/llvm/utils/lit/tests/shtest-define.py\n@@ -136,15 +136,15 @@\n # RUN: %{lit} -va %{my-inputs}/shared-substs-*.txt 2>&1 |                      \\\n # RUN:   FileCheck -check-prefix=SHARED-SUBSTS -match-full-lines %s\n #\n-# SHARED-SUBSTS: shared-substs-0.txt\n-# SHARED-SUBSTS: GLOBAL: World\n-# SHARED-SUBSTS: LOCAL0: LOCAL0:Hello LOCAL0:World\n-# SHARED-SUBSTS: LOCAL0: subst\n+# SHARED-SUBSTS:# | shared-substs-0.txt\n+# SHARED-SUBSTS:# | GLOBAL: World\n+# SHARED-SUBSTS:# | LOCAL0: LOCAL0:Hello LOCAL0:World\n+# SHARED-SUBSTS:# | LOCAL0: subst\n #\n-# SHARED-SUBSTS: shared-substs-1.txt\n-# SHARED-SUBSTS: GLOBAL: World\n-# SHARED-SUBSTS: LOCAL1: LOCAL1:Hello LOCAL1:World\n-# SHARED-SUBSTS: LOCAL1: subst\n+# SHARED-SUBSTS:# | shared-substs-1.txt\n+# SHARED-SUBSTS:# | GLOBAL: World\n+# SHARED-SUBSTS:# | LOCAL1: LOCAL1:Hello LOCAL1:World\n+# SHARED-SUBSTS:# | LOCAL1: subst\n #\n # REDEFINE: %{test} = shared-substs-0.txt\n # RUN: %{record-test}\ndiff --git a/llvm/utils/lit/tests/shtest-env.py b/llvm/utils/lit/tests/shtest-env.py\nindex f2e8216f7f4a..c093b62e5420 100644\n--- a/llvm/utils/lit/tests/shtest-env.py\n+++ b/llvm/utils/lit/tests/shtest-env.py\n@@ -10,88 +10,115 @@\n # CHECK: -- Testing: 16 tests{{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-assign.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"FOO=1\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env FOO=1\n+# CHECK: # executed command: env FOO=1\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-u-arg.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO\n+# CHECK: # executed command: env -u FOO\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-last-is-u.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u\n+# CHECK: # executed command: env -u\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-nested-none.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"env\" \"env\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env env env\n+# CHECK: # executed command: env env env\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-args-none.txt ({{[^)]*}})\n-# CHECK: $ \"env\"\n-# CHECK: Error: 'env' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env\n+# CHECK: # executed command: env\n+# CHECK: # | Error: 'env' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-cd.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"cd\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'cd'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 cd foobar\n+# CHECK: # executed command: env -u FOO BAR=3 cd foobar\n+# CHECK: # | Error: 'env' cannot call 'cd'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-colon.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \":\"\n-# CHECK: Error: 'env' cannot call ':'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 :\n+# CHECK: # executed command: env -u FOO BAR=3 :\n+# CHECK: # | Error: 'env' cannot call ':'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-echo.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"echo\" \"hello\" \"world\"\n-# CHECK: Error: 'env' cannot call 'echo'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 echo hello world\n+# CHECK: # executed command: env -u FOO BAR=3 echo hello world\n+# CHECK: # | Error: 'env' cannot call 'echo'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: PASS: shtest-env :: env-calls-env.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"env\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"FOO=2\" \"env\" \"BAR=1\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"env\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=1\" \"env\" \"-u\" \"BAR\" \"FOO=2\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=1\" \"env\" \"-u\" \"BAR\" \"FOO=2\" \"env\" \"BAZ=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env env [[PYTHON:.+]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env env [[PYTHON_BARE:.+]] print_environment.py\n+# CHECK: env FOO=2 env BAR=1 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env FOO=2 env BAR=1 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO env -u BAR [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO env -u BAR [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO BAR=1 env -u BAR FOO=2 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO BAR=1 env -u BAR FOO=2 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO BAR=1 env -u BAR FOO=2 env BAZ=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO BAR=1 env -u BAR FOO=2 env BAZ=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: FAIL: shtest-env :: env-calls-export.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"export\" \"BAZ=3\"\n-# CHECK: Error: 'env' cannot call 'export'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 export BAZ=3\n+# CHECK: # executed command: env -u FOO BAR=3 export BAZ=3\n+# CHECK: # | Error: 'env' cannot call 'export'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-mkdir.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"mkdir\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'mkdir'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 mkdir foobar\n+# CHECK: # executed command: env -u FOO BAR=3 mkdir foobar\n+# CHECK: # | Error: 'env' cannot call 'mkdir'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-not-builtin.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"not\" \"rm\" \"{{.*}}.no-such-file\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 not rm {{.+}}.no-such-file\n+# CHECK: # executed command: env -u FOO BAR=3 not rm {{.+}}.no-such-file{{.*}}\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-env :: env-calls-rm.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"BAR=3\" \"rm\" \"foobar\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: env -u FOO BAR=3 rm foobar\n+# CHECK: # executed command: env -u FOO BAR=3 rm foobar\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: PASS: shtest-env :: env-u.txt ({{[^)]*}})\n-# CHECK: $ \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"-u\" \"FOO\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: env -u FOO [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO [[PYTHON_BARE]] print_environment.py\n+# CHECK: env -u FOO -u BAR [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env -u FOO -u BAR [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: PASS: shtest-env :: env.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"A_FOO=999\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"A_FOO=1\" \"B_BAR=2\" \"C_OOF=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env A_FOO=999 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=999 [[PYTHON_BARE]] print_environment.py\n+# CHECK: env A_FOO=1 B_BAR=2 C_OOF=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=1 B_BAR=2 C_OOF=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: PASS: shtest-env :: mixed.txt ({{[^)]*}})\n-# CHECK: $ \"env\" \"A_FOO=999\" \"-u\" \"FOO\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK: $ \"env\" \"A_FOO=1\" \"-u\" \"FOO\" \"B_BAR=2\" \"-u\" \"BAR\" \"C_OOF=3\" \"{{[^\"]*}}\" \"print_environment.py\"\n-# CHECK-NOT: ${{.*}}print_environment.py\n+# CHECK: env A_FOO=999 -u FOO [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=999 -u FOO [[PYTHON_BARE]] print_environment.py\n+# CHECK: env A_FOO=1 -u FOO B_BAR=2 -u BAR C_OOF=3 [[PYTHON]] print_environment.py | {{.*}}\n+# CHECK: # executed command: env A_FOO=1 -u FOO B_BAR=2 -u BAR C_OOF=3 [[PYTHON_BARE]] print_environment.py\n+# CHECK-NOT: {{^[^#]}}\n+# CHECK: --\n \n # CHECK: Passed:  4\n # CHECK: Failed: 12\ndiff --git a/llvm/utils/lit/tests/shtest-format.py b/llvm/utils/lit/tests/shtest-format.py\nindex 621776ab7bc2..4a3d65b7bce4 100644\n--- a/llvm/utils/lit/tests/shtest-format.py\n+++ b/llvm/utils/lit/tests/shtest-format.py\n@@ -43,13 +43,21 @@\n # CHECK-EMPTY:\n #  CHECK-NEXT: Command Output (stdout):\n #  CHECK-NEXT: --\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-#  CHECK-NEXT: $ \"printf\"\n-#  CHECK-NEXT: # command output:\n-#  CHECK-NEXT: line 1: failed test output on stdout\n-#  CHECK-NEXT: line 2: failed test output on stdout\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-#  CHECK-NEXT: $ \"false\"\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: printf \"line 1: failed test output on stdout\\nline 2: failed test output on stdout\"\n+#  CHECK-NEXT: executed command: printf 'line 1: failed test output on stdout\\nline 2: failed test output on stdout'\n+#  CHECK-NEXT: # .---command stdout------------\n+#  CHECK-NEXT: # | line 1: failed test output on stdout\n+#  CHECK-NEXT: # | line 2: failed test output on stdout\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # RUN: at line 2\n+#  CHECK-NEXT: false\n+#  CHECK-NEXT: # executed command: false\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: --\n+\n \n # CHECK: UNRESOLVED: shtest-format :: no-test-line.txt\n # CHECK: PASS: shtest-format :: pass.txt\n@@ -73,8 +81,11 @@\n # CHECK-EMPTY:\n #  CHECK-NEXT: Command Output (stdout):\n #  CHECK-NEXT: --\n-#  CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-#  CHECK-NEXT: $ \"true\"\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: true\n+#  CHECK-NEXT: # executed command: true\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: --\n \n # CHECK: Failed Tests (4)\n # CHECK: shtest-format :: external_shell/fail.txt\ndiff --git a/llvm/utils/lit/tests/shtest-if-else.py b/llvm/utils/lit/tests/shtest-if-else.py\nindex aaf94a6e2437..c18da4abbcca 100644\n--- a/llvm/utils/lit/tests/shtest-if-else.py\n+++ b/llvm/utils/lit/tests/shtest-if-else.py\n@@ -1,5 +1,6 @@\n # RUN: %{lit} -v --show-all %{inputs}/shtest-if-else/test.txt \\\n-# RUN:    | FileCheck %{inputs}/shtest-if-else/test.txt --match-full-lines\n+# RUN:    | FileCheck %{inputs}/shtest-if-else/test.txt --match-full-lines \\\n+# RUN:                --implicit-check-not='RUN:'\n \n # RUN: not %{lit} -v --show-all %{inputs}/shtest-if-else/test-neg1.txt 2>&1 \\\n # RUN:    | FileCheck %{inputs}/shtest-if-else/test-neg1.txt\ndiff --git a/llvm/utils/lit/tests/shtest-inject.py b/llvm/utils/lit/tests/shtest-inject.py\nindex 17e293ea1a12..3d34eb7161d4 100644\n--- a/llvm/utils/lit/tests/shtest-inject.py\n+++ b/llvm/utils/lit/tests/shtest-inject.py\n@@ -1,9 +1,26 @@\n-# Check that we can inject commands at the beginning of a ShTest.\n+# Check that we can inject preamble commands at the beginning of a ShTest.\n+#\n+# For one case, check the execution trace as these preamble commands have\n+# \"preamble command\" instead of the usual \"{{RUN}}: at line N\".\n \n # RUN: %{lit} %{inputs}/shtest-inject/test-empty.txt --show-all | FileCheck --check-prefix=CHECK-TEST1 %s\n #\n-# CHECK-TEST1: THIS WAS\n-# CHECK-TEST1: INJECTED\n+#       CHECK-TEST1: Command Output (stdout):\n+#  CHECK-TEST1-NEXT: --\n+#  CHECK-TEST1-NEXT: # preamble command line\n+#  CHECK-TEST1-NEXT: echo \"THIS WAS\"\n+#  CHECK-TEST1-NEXT: # executed command: echo 'THIS WAS'\n+#  CHECK-TEST1-NEXT: # .---command stdout{{-*}}\n+#  CHECK-TEST1-NEXT: # | THIS WAS\n+#  CHECK-TEST1-NEXT: # `---{{-*}}\n+#  CHECK-TEST1-NEXT: # preamble command line\n+#  CHECK-TEST1-NEXT: echo \"INJECTED\"\n+#  CHECK-TEST1-NEXT: # executed command: echo INJECTED\n+#  CHECK-TEST1-NEXT: # .---command stdout{{-*}}\n+#  CHECK-TEST1-NEXT: # | INJECTED\n+#  CHECK-TEST1-NEXT: # `---{{-*}}\n+# CHECK-TEST1-EMPTY:\n+#  CHECK-TEST1-NEXT: --\n #\n # CHECK-TEST1: Passed: 1\n \ndiff --git a/llvm/utils/lit/tests/shtest-not.py b/llvm/utils/lit/tests/shtest-not.py\nindex d23c9d0cffaf..f514cddf1def 100644\n--- a/llvm/utils/lit/tests/shtest-not.py\n+++ b/llvm/utils/lit/tests/shtest-not.py\n@@ -10,112 +10,158 @@\n # CHECK: -- Testing: 17 tests{{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-args-nested-none.txt {{.*}}\n-# CHECK: $ \"!\" \"!\" \"!\"\n-# CHECK: Error: '!' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: ! ! !\n+# CHECK: # executed command: ! ! !\n+# CHECK: # | Error: '!' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-args-none.txt {{.*}}\n-# CHECK: $ \"!\"\n-# CHECK: Error: '!' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: !\n+# CHECK: # executed command: !\n+# CHECK: # | Error: '!' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: exclamation-calls-external.txt {{.*}}\n \n-# CHECK: $ \"!\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"!\" \"!\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"!\" \"!\" \"!\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"!\" \"!\" \"!\" \"!\" \"{{[^\"]*}}\" \"pass.py\"\n+# CHECK: ! [[PYTHON:.*]] fail.py\n+# CHECK: # executed command: ! [[PYTHON_BARE:.*]] fail.py\n+# CHECK: ! ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! ! [[PYTHON_BARE]] pass.py\n+# CHECK: ! ! ! [[PYTHON]] fail.py\n+# CHECK: # executed command: ! ! ! [[PYTHON_BARE]] fail.py\n+# CHECK: ! ! ! ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! ! ! ! [[PYTHON_BARE]] pass.py\n \n-# CHECK: $ \"!\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: ! [[PYTHON]] pass.py\n+# CHECK: # executed command: ! [[PYTHON_BARE]] pass.py\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-last-is-crash.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not --crash\n+# CHECK: # executed command: not --crash\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-nested-none.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not not\n+# CHECK: # executed command: not not not\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-args-none.txt {{.*}}\n-# CHECK: $ \"not\"\n-# CHECK: Error: 'not' requires a subcommand\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not\n+# CHECK: # executed command: not\n+# CHECK: # | Error: 'not' requires a subcommand\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-cd.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"cd\" \"foobar\"\n-# CHECK: $ \"not\" \"--crash\" \"cd\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'cd'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not cd foobar\n+# CHECK: # executed command: not not cd foobar\n+# CHECK: not --crash cd foobar\n+# CHECK: # executed command: not --crash cd foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'cd'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-colon.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \":\" \"foobar\"\n-# CHECK: $ \"not\" \"--crash\" \":\"\n-# CHECK: Error: 'not --crash' cannot call ':'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not : foobar\n+# CHECK: # executed command: not not : foobar\n+# CHECK: not --crash :\n+# CHECK: # executed command: not --crash :\n+# CHECK: # | Error: 'not --crash' cannot call ':'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-diff-with-crash.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"diff\" \"-u\" {{.*}}\n-# CHECK-NOT: \"$\"\n+# CHECK: not --crash diff -u {{.*}}\n+# CHECK: # executed command: not --crash diff -u {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n # CHECK-NOT: {{[Ee]rror}}\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: # error: command failed with exit status: {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n # CHECK-NOT: {{[Ee]rror}}\n-# CHECK-NOT: \"$\"\n \n # CHECK: FAIL: shtest-not :: not-calls-diff.txt {{.*}}\n-# CHECK: $ \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"diff\" {{.*}}\n-# CHECK: $ \"not\" \"diff\" {{.*}}\n-# CHECK-NOT: \"$\"\n+# CHECK: not diff {{.*}}\n+# CHECK: # executed command: not diff {{.*}}\n+# CHECK: not not not diff {{.*}}\n+# CHECK: # executed command: not not not diff {{.*}}\n+# CHECK: not not not not not diff {{.*}}\n+# CHECK: # executed command: not not not not not diff {{.*}}\n+# CHECK: diff {{.*}}\n+# CHECK: # executed command: diff {{.*}}\n+# CHECK: not not diff {{.*}}\n+# CHECK: # executed command: not not diff {{.*}}\n+# CHECK: not not not not diff {{.*}}\n+# CHECK: # executed command: not not not not diff {{.*}}\n+# CHECK: not diff {{.*}}\n+# CHECK: # executed command: not diff {{.*}}\n+# CHECK-NOT: # executed command: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-echo.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"echo\" \"hello\" \"world\"\n-# CHECK: $ \"not\" \"--crash\" \"echo\" \"hello\" \"world\"\n-# CHECK: Error: 'not --crash' cannot call 'echo'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not echo hello world\n+# CHECK: # executed command: not not echo hello world\n+# CHECK: not --crash echo hello world\n+# CHECK: # executed command: not --crash echo hello world\n+# CHECK: # | Error: 'not --crash' cannot call 'echo'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-env-builtin.txt {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"env\" \"-u\" \"FOO\" \"BAR=3\" \"rm\" \"{{.*}}.no-such-file\"\n-# CHECK: Error: 'env' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not --crash env -u FOO BAR=3 rm {{.*}}.no-such-file\n+# CHECK: # executed command: not --crash env -u FOO BAR=3 rm {{.+}}.no-such-file{{.*}}\n+# CHECK: # | Error: 'env' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-export.txt {{.*}}\n-# CHECK: $ \"not\" \"not\" \"export\" \"FOO=1\"\n-# CHECK: $ \"not\" \"--crash\" \"export\" \"BAZ=3\"\n-# CHECK: Error: 'not --crash' cannot call 'export'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not not export FOO=1\n+# CHECK: # executed command: not not export FOO=1\n+# CHECK: not --crash export BAZ=3\n+# CHECK: # executed command: not --crash export BAZ=3\n+# CHECK: # | Error: 'not --crash' cannot call 'export'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n \n # CHECK: PASS: shtest-not :: not-calls-external.txt {{.*}}\n \n-# CHECK: $ \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-\n-# CHECK: $ \"env\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"not\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"env\" \"-u\" \"FOO\" \"BAR=2\" \"{{[^\"]*}}\" \"fail.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"env\" \"-u\" \"FOO\" \"-u\" \"BAR\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"env\" \"FOO=1\" \"env\" \"FOO=2\" \"BAR=1\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"env\" \"FOO=1\" \"-u\" \"BAR\" \"env\" \"-u\" \"FOO\" \"BAR=1\" \"not\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"env\" \"FOO=2\" \"BAR=2\" \"not\" \"--crash\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"env\" \"FOO=1\" \"BAR=1\" \"not\" \"--crash\" \"not\" \"{{[^\"]*}}\" \"pass.py\"\n-# CHECK: $ \"not\" \"not\" \"--crash\" \"env\" \"-u\" \"BAR\" \"not\" \"env\" \"-u\" \"FOO\" \"BAR=1\" \"{{[^\"]*}}\" \"pass.py\"\n+# CHECK: not [[PYTHON]] fail.py\n+# CHECK: # executed command: not [[PYTHON_BARE]] fail.py\n+# CHECK: not not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not [[PYTHON_BARE]] pass.py\n+# CHECK: not not not [[PYTHON]] fail.py\n+# CHECK: # executed command: not not not [[PYTHON_BARE]] fail.py\n+# CHECK: not not not not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not not not [[PYTHON_BARE]] pass.py\n+\n+# CHECK: not not --crash [[PYTHON]] pass.py\n+# CHECK: # executed command: not not --crash [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash [[PYTHON]] fail.py\n+# CHECK: # executed command: not not --crash [[PYTHON_BARE]] fail.py\n+# CHECK: not not --crash not [[PYTHON]] pass.py\n+# CHECK: # executed command: not not --crash not [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash not [[PYTHON]] fail.py\n+# CHECK: # executed command: not not --crash not [[PYTHON_BARE]] fail.py\n+\n+# CHECK: env not [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env not [[PYTHON_BARE]] fail.py\n+# CHECK: not env [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: not env [[PYTHON_BARE]] fail.py\n+# CHECK: env FOO=1 not [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 not [[PYTHON_BARE]] fail.py\n+# CHECK: not env FOO=1 BAR=1 [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 [[PYTHON_BARE]] fail.py\n+# CHECK: env FOO=1 BAR=1 not env -u FOO BAR=2 [[PYTHON]] fail.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 BAR=1 not env -u FOO BAR=2 [[PYTHON_BARE]] fail.py\n+# CHECK: not env FOO=1 BAR=1 not env -u FOO -u BAR [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 not env -u FOO -u BAR [[PYTHON_BARE]] pass.py\n+# CHECK: not not env FOO=1 env FOO=2 BAR=1 [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not not env FOO=1 env FOO=2 BAR=1 [[PYTHON_BARE]] pass.py\n+# CHECK: env FOO=1 -u BAR env -u FOO BAR=1 not not [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: env FOO=1 -u BAR env -u FOO BAR=1 not not [[PYTHON_BARE]] pass.py\n+\n+# CHECK: not env FOO=1 BAR=1 env FOO=2 BAR=2 not --crash [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 env FOO=2 BAR=2 not --crash [[PYTHON_BARE]] pass.py\n+# CHECK: not env FOO=1 BAR=1 not --crash not [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not env FOO=1 BAR=1 not --crash not [[PYTHON_BARE]] pass.py\n+# CHECK: not not --crash env -u BAR not env -u FOO BAR=1 [[PYTHON]] pass.py | {{.*}}\n+# CHECK: # executed command: not not --crash env -u BAR not env -u FOO BAR=1 [[PYTHON_BARE]] pass.py\n \n \n # CHECK: FAIL: shtest-not :: not-calls-fail2.txt {{.*}}\n@@ -123,16 +169,20 @@\n # CHECK-NEXT: Exit Code: 1\n \n # CHECK: FAIL: shtest-not :: not-calls-mkdir.txt {{.*}}\n-# CHECK: $ \"not\" \"mkdir\" {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"mkdir\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'mkdir'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not mkdir {{.*}}\n+# CHECK: # executed command: not mkdir {{.*}}\n+# CHECK: not --crash mkdir foobar\n+# CHECK: # executed command: not --crash mkdir foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'mkdir'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: FAIL: shtest-not :: not-calls-rm.txt {{.*}}\n-# CHECK: $ \"not\" \"rm\" {{.*}}\n-# CHECK: $ \"not\" \"--crash\" \"rm\" \"foobar\"\n-# CHECK: Error: 'not --crash' cannot call 'rm'\n-# CHECK: error: command failed with exit status: {{.*}}\n+# CHECK: not rm {{.*}}\n+# CHECK: # executed command: not rm {{.*}}\n+# CHECK: not --crash rm foobar\n+# CHECK: # executed command: not --crash rm foobar\n+# CHECK: # | Error: 'not --crash' cannot call 'rm'\n+# CHECK: # error: command failed with exit status: {{.*}}\n \n # CHECK: Passed:  1\n # CHECK: Failed: 16\ndiff --git a/llvm/utils/lit/tests/shtest-output-printing.py b/llvm/utils/lit/tests/shtest-output-printing.py\nindex 7cd975ba8d3c..129cff981eb5 100644\n--- a/llvm/utils/lit/tests/shtest-output-printing.py\n+++ b/llvm/utils/lit/tests/shtest-output-printing.py\n@@ -1,28 +1,45 @@\n # Check the various features of the ShTest format.\n #\n # RUN: not %{lit} -v %{inputs}/shtest-output-printing > %t.out\n-# RUN: FileCheck --input-file %t.out %s\n+# RUN: FileCheck --input-file %t.out --match-full-lines %s\n #\n # END.\n \n-# CHECK: -- Testing:\n-\n-# CHECK: FAIL: shtest-output-printing :: basic.txt\n-# CHECK-NEXT: *** TEST 'shtest-output-printing :: basic.txt' FAILED ***\n-# CHECK-NEXT: Exit Code: 1\n-#\n-# CHECK:      Command Output\n-# CHECK-NEXT: --\n-# CHECK-NEXT: $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \"true\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-# CHECK-NEXT: $ \"echo\" \"hi\"\n-# CHECK-NEXT: # command output:\n-# CHECK-NEXT: hi\n-#\n-# CHECK:      $ \":\" \"RUN: at line 3\"\n-# CHECK-NEXT: $ \"not\" \"not\" \"wc\" \"missing-file\"\n-# CHECK-NEXT: # redirected output from '{{.*(/|\\\\\\\\)}}basic.txt.tmp.out':\n-# CHECK-NEXT: {{cannot open missing-file|missing-file.* No such file or directory}}\n-# CHECK:      note: command had no output on stdout or stderr\n-# CHECK-NEXT: error: command failed with exit status: 1\n+#       CHECK: -- Testing: {{.*}}\n+#       CHECK: FAIL: shtest-output-printing :: basic.txt {{.*}}\n+#  CHECK-NEXT: ***{{\\**}} TEST 'shtest-output-printing :: basic.txt' FAILED ***{{\\**}}\n+#  CHECK-NEXT: Exit Code: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT: Command Output (stdout):\n+#  CHECK-NEXT: --\n+#  CHECK-NEXT: # RUN: at line 1\n+#  CHECK-NEXT: true\n+#  CHECK-NEXT: # executed command: true\n+#  CHECK-NEXT: # RUN: at line 2\n+#  CHECK-NEXT: echo hi\n+#  CHECK-NEXT: # executed command: echo hi\n+#  CHECK-NEXT: # .---command stdout------------\n+#  CHECK-NEXT: # | hi\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # RUN: at line 3\n+#  CHECK-NEXT: not not wc missing-file &> [[FILE:.*]] || true\n+#  CHECK-NEXT: # executed command: not not wc missing-file\n+#  CHECK-NEXT: # .---redirected output from '[[FILE]]'\n+#  CHECK-NEXT: # | wc: {{cannot open missing-file|missing-file.* No such file or directory}}\n+#  CHECK-NEXT: # `-----------------------------\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+#  CHECK-NEXT: # executed command: true\n+#  CHECK-NEXT: # RUN: at line 4\n+#  CHECK-NEXT: not {{.*}}python{{.*}} {{.*}}write-a-lot.py &> [[FILE:.*]]\n+#  CHECK-NEXT: # executed command: not {{.*}}python{{.*}} {{.*}}write-a-lot.py{{.*}}\n+#  CHECK-NEXT: # .---redirected output from '[[FILE]]'\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#  CHECK-NEXT: # | All work and no play makes Jack a dull boy.\n+#       CHECK: # | ...\n+#  CHECK-NEXT: # `---data was truncated--------\n+#  CHECK-NEXT: # note: command had no output on stdout or stderr\n+#  CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-EMPTY:\n+#  CHECK-NEXT:--\ndiff --git a/llvm/utils/lit/tests/shtest-pushd-popd.py b/llvm/utils/lit/tests/shtest-pushd-popd.py\nindex 26296a7ffcf5..6d7e93c74a05 100644\n--- a/llvm/utils/lit/tests/shtest-pushd-popd.py\n+++ b/llvm/utils/lit/tests/shtest-pushd-popd.py\n@@ -8,16 +8,16 @@\n # CHECK: -- Testing: 4 tests{{.*}}\n \n # CHECK: FAIL: shtest-pushd-popd :: popd-args.txt ({{[^)]*}})\n-# CHECK: $ \"popd\" \"invalid\"\n-# CHECK: 'popd' does not support arguments\n+# CHECK: popd invalid\n+# CHECK: # | 'popd' does not support arguments\n \n # CHECK: FAIL: shtest-pushd-popd :: popd-no-stack.txt ({{[^)]*}})\n-# CHECK: $ \"popd\"\n-# CHECK: popd: directory stack empty\n+# CHECK: popd\n+# CHECK: # | popd: directory stack empty\n \n # CHECK: FAIL: shtest-pushd-popd :: pushd-too-many-args.txt ({{[^)]*}})\n-# CHECK: $ \"pushd\" \"a\" \"b\"\n-# CHECK: 'pushd' supports only one argument\n+# CHECK: pushd a b\n+# CHECK: # | 'pushd' supports only one argument\n \n # CHECK: Passed:  1\n # CHECK: Failed:  3\ndiff --git a/llvm/utils/lit/tests/shtest-recursive-substitution.py b/llvm/utils/lit/tests/shtest-recursive-substitution.py\nindex 48f4b5b12491..65c177e65a3c 100644\n--- a/llvm/utils/lit/tests/shtest-recursive-substitution.py\n+++ b/llvm/utils/lit/tests/shtest-recursive-substitution.py\n@@ -3,7 +3,7 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/substitutes-within-limit --show-all | FileCheck --check-prefix=CHECK-TEST1 %s\n # CHECK-TEST1: PASS: substitutes-within-limit :: test.py\n-# CHECK-TEST1: $ \"echo\" \"STOP\"\n+# CHECK-TEST1: echo STOP\n \n # RUN: not %{lit} %{inputs}/shtest-recursive-substitution/does-not-substitute-within-limit --show-all | FileCheck --check-prefix=CHECK-TEST2 %s\n # CHECK-TEST2: UNRESOLVED: does-not-substitute-within-limit :: test.py\n@@ -11,7 +11,7 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/does-not-substitute-no-limit --show-all | FileCheck --check-prefix=CHECK-TEST3 %s\n # CHECK-TEST3: PASS: does-not-substitute-no-limit :: test.py\n-# CHECK-TEST3: $ \"echo\" \"%rec4\"\n+# CHECK-TEST3: echo %rec4\n \n # RUN: not %{lit} %{inputs}/shtest-recursive-substitution/not-an-integer --show-all 2>&1 | FileCheck --check-prefix=CHECK-TEST4 %s\n # CHECK-TEST4: recursiveExpansionLimit must be either None or an integer\n@@ -24,4 +24,4 @@\n \n # RUN: %{lit} %{inputs}/shtest-recursive-substitution/escaping --show-all | FileCheck --check-prefix=CHECK-TEST7 %s\n # CHECK-TEST7: PASS: escaping :: test.py\n-# CHECK-TEST7: $ \"echo\" \"%s\" \"%s\" \"%%s\"\n+# CHECK-TEST7: echo %s %s %%s\ndiff --git a/llvm/utils/lit/tests/shtest-run-at-line.py b/llvm/utils/lit/tests/shtest-run-at-line.py\nindex 879cd64ebf6e..a0626f872c4c 100644\n--- a/llvm/utils/lit/tests/shtest-run-at-line.py\n+++ b/llvm/utils/lit/tests/shtest-run-at-line.py\n@@ -28,21 +28,28 @@\n # CHECK-LABEL: FAIL: shtest-run-at-line :: internal-shell/basic.txt\n \n # CHECK:      Command Output (stdout)\n-# CHECK:      $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \"true\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 2\"\n-# CHECK-NEXT: $ \"false\"\n+# CHECK-NEXT: --\n+# CHECK-NEXT: # RUN: at line 1\n+# CHECK-NEXT: true\n+# CHECK-NEXT: # executed command: true\n+# CHECK-NEXT: # RUN: at line 2\n+# CHECK-NEXT: false\n+# CHECK-NEXT: # executed command: false\n # CHECK-NOT:  RUN\n \n # CHECK-LABEL: FAIL: shtest-run-at-line :: internal-shell/line-continuation.txt\n \n # CHECK:      Command Output (stdout)\n-# CHECK:      $ \":\" \"RUN: at line 1\"\n-# CHECK-NEXT: $ \":\" \"first\" \"line\" \"continued\" \"to\" \"second\" \"line\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 3\"\n-# CHECK-NEXT: $ \"echo\" \"foo bar\"\n-# CHECK-NEXT: $ \"FileCheck\" \"{{.*}}\"\n-# CHECK-NEXT: $ \":\" \"RUN: at line 5\"\n-# CHECK-NEXT: $ \"echo\" \"foo baz\"\n-# CHECK-NEXT: $ \"FileCheck\" \"{{.*}}\"\n+# CHECK-NEXT: --\n+# CHECK-NEXT: # RUN: at line 1\n+# CHECK-NEXT: : first line continued to second line\n+# CHECK-NEXT: # executed command: : first line continued to second line\n+# CHECK-NEXT: # RUN: at line 3\n+# CHECK-NEXT: echo 'foo bar' | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: echo 'foo bar'\n+# CHECK-NEXT: # executed command: FileCheck {{.*}}\n+# CHECK-NEXT: # RUN: at line 5\n+# CHECK-NEXT: echo 'foo baz' | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: echo 'foo baz'\n+# CHECK-NEXT: # executed command: FileCheck {{.*}}\n # CHECK-NOT:  RUN\ndiff --git a/llvm/utils/lit/tests/shtest-shell.py b/llvm/utils/lit/tests/shtest-shell.py\nindex 93f05dbd35d0..a043582d6ae2 100644\n--- a/llvm/utils/lit/tests/shtest-shell.py\n+++ b/llvm/utils/lit/tests/shtest-shell.py\n@@ -20,202 +20,212 @@\n \n # CHECK: FAIL: shtest-shell :: cat-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: cat-error-0.txt' FAILED ***\n-# CHECK: $ \"cat\" \"-b\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'cat':  option -b not recognized\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: cat -b temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'cat':  option -b not recognized\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: cat-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: cat-error-1.txt' FAILED ***\n-# CHECK: $ \"cat\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: [Errno 2] No such file or directory: 'temp1.txt'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: cat temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | [Errno 2] No such file or directory: 'temp1.txt'\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: colon-error.txt\n # CHECK: *** TEST 'shtest-shell :: colon-error.txt' FAILED ***\n-# CHECK: $ \":\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: ':' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: :\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: ':' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: PASS: shtest-shell :: continuations.txt\n \n # CHECK: PASS: shtest-shell :: dev-null.txt\n \n-# CHECK: FAIL: shtest-shell :: diff-b.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-b.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-b\" \"{{[^\"]*}}.0\" \"{{[^\"]*}}.1\"\n-# CHECK: # command output:\n-# CHECK: 1,2\n-# CHECK-NEXT: {{^  }}f o o\n-# CHECK-NEXT: ! b a r\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: {{^  }}f o o\n-# CHECK-NEXT: ! bar\n-# CHECK-EMPTY:\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-b.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-b.txt' FAILED ***\n+#      CHECK: diff -b {{[^\"]*}}.0 {{[^\"]*}}.1\n+#      CHECK: # .---command stdout{{-*}}\n+#      CHECK: # | {{.*}}1,2\n+# CHECK-NEXT: # |   f o o\n+# CHECK-NEXT: # | ! b a r\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # |   f o o\n+# CHECK-NEXT: # | ! bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+#      CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-encodings.txt\n # CHECK: *** TEST 'shtest-shell :: diff-encodings.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"diff-in.bin\"\n+#      CHECK: diff -u diff-in.bin diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.bin diff-in.bin\n+#  CHECK-NOT: error\n+\n+#      CHECK: diff -u diff-in.utf16 diff-in.bin && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf16 diff-in.bin\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.utf8 diff-in.bin && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf8 diff-in.bin\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | -baz\n+# CHECK-NEXT: # | {{\\+.f.o.o.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{\\+.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.bin diff-in.utf8 && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.bin diff-in.utf8\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{-.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.}}\n+# CHECK-NEXT: # | {{-.b.a.z.$}}\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # | +baz\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#     CHECK: cat diff-in.bin | diff -u - diff-in.bin\n # CHECK-NOT: error\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf16\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^ .f.o.o.$}}\n-# CHECK-NEXT: {{^-.b.a.r.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^ .b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf8\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: -baz\n-# CHECK-NEXT: {{^\\+.f.o.o.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^\\+.b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"diff-in.utf8\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^\\-.f.o.o.$}}\n-# CHECK-NEXT: {{^\\-.b.a.r.}}\n-# CHECK-NEXT: {{^\\-.b.a.z.$}}\n-# CHECK-NEXT: +foo\n-# CHECK-NEXT: +bar\n-# CHECK-NEXT: +baz\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.bin\" \"-\"\n-# CHECK-NOT: error\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf16\" \"-\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^ .f.o.o.$}}\n-# CHECK-NEXT: {{^-.b.a.r.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^ .b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n+#     CHECK: cat diff-in.bin | diff -u diff-in.bin -\n # CHECK-NOT: error\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.utf8\" \"-\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: -baz\n-# CHECK-NEXT: {{^\\+.f.o.o.$}}\n-# CHECK-NEXT: {{^\\+.b.a.r.}}\n-# CHECK-NEXT: {{^\\+.b.a.z.$}}\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"diff-in.utf8\"\n-# CHECK: # command output:\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: +++\n-# CHECK-NEXT: @@\n-# CHECK-NEXT: {{^\\-.f.o.o.$}}\n-# CHECK-NEXT: {{^\\-.b.a.r.}}\n-# CHECK-NEXT: {{^\\-.b.a.z.$}}\n-# CHECK-NEXT: +foo\n-# CHECK-NEXT: +bar\n-# CHECK-NEXT: +baz\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n \n-# CHECK: $ \"false\"\n+#      CHECK: cat diff-in.bin | diff -u diff-in.utf16 - && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf16 -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat diff-in.bin | diff -u diff-in.utf8 - && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u diff-in.utf8 -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | -baz\n+# CHECK-NEXT: # | {{\\+.f.o.o.$}}\n+# CHECK-NEXT: # | {{\\+.b.a.r.}}\n+# CHECK-NEXT: # | {{\\+.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat diff-in.bin | diff -u - diff-in.utf8 && false || true\n+# CHECK-NEXT: # executed command: cat diff-in.bin\n+# CHECK-NEXT: # executed command: diff -u - diff-in.utf8\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # | +++\n+# CHECK-NEXT: # | @@\n+# CHECK-NEXT: # | {{-.f.o.o.$}}\n+# CHECK-NEXT: # | {{-.b.a.r.}}\n+# CHECK-NEXT: # | {{-.b.a.z.$}}\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # | +baz\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-1.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-B\" \"temp1.txt\" \"temp2.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'diff': option -B not recognized\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -B temp1.txt temp2.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'diff': option -B not recognized\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-2.txt' FAILED ***\n-# CHECK: $ \"diff\" \"temp.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff temp.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-3.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-3.txt' FAILED ***\n-# CHECK: $ \"diff\" \"temp.txt\" \"temp1.txt\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'diff' command failed\n+# CHECK: diff temp.txt temp1.txt\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'diff' command failed\n # CHECK: error: command failed with exit status: 1\n # CHECK: ***\n \n-# CHECK: FAIL: shtest-shell :: diff-error-4.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-error-4.txt' FAILED ***\n-# CHECK: Exit Code: 1\n-# CHECK: # command output:\n-# CHECK: diff-error-4.txt.tmp\n-# CHECK: diff-error-4.txt.tmp1\n-# CHECK: *** 1 ****\n-# CHECK: ! hello-first\n-# CHECK: --- 1 ----\n-# CHECK: ! hello-second\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-error-4.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-error-4.txt' FAILED ***\n+#      CHECK: Exit Code: 1\n+#      CHECK: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | {{.*}}diff-error-4.txt.tmp\n+# CHECK-NEXT: # | {{.*}}diff-error-4.txt.tmp1\n+# CHECK-NEXT: # | {{\\*+}}\n+# CHECK-NEXT: # | *** 1 ****\n+# CHECK-NEXT: # | ! hello-first\n+# CHECK-NEXT: # | --- 1 ----\n+# CHECK-NEXT: # | ! hello-second\n+# CHECK-NEXT: # `---{{-*}}\n+#      CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-5.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-5.txt' FAILED ***\n-# CHECK: $ \"diff\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: diff-error-6.txt\n # CHECK: *** TEST 'shtest-shell :: diff-error-6.txt' FAILED ***\n-# CHECK: $ \"diff\"\n-# CHECK: # command stderr:\n-# CHECK: Error: missing or extra operand\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: missing or extra operand\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n \n@@ -223,137 +233,130 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-pipes.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.foo\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"FileCheck\"\n+# CHECK: diff {{[^ ]*}}.foo {{.*}}.foo | FileCheck {{.*}}\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: note: command had no output on stdout or stderr\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"FileCheck\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"true\"\n+#      CHECK: diff -u {{.*}}.foo {{.*}}.bar | FileCheck {{.*}} && false || true\n+# CHECK-NEXT: # executed command: diff -u {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # note: command had no output on stdout or stderr\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: FileCheck\n+# CHECK-NEXT: # executed command: true\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"{{[^\"]*}}.foo\"\n+#     CHECK: cat {{.*}}.foo | diff -u - {{.*}}.foo\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n+#     CHECK: cat {{.*}}.foo | diff -u {{.*}}.foo -\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -foo\n-# CHECK-NEXT: +bar\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"-\" \"{{[^\"]*}}.foo\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -bar\n-# CHECK-NEXT: +foo\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"cat\" \"{{[^\"]*}}.foo\"\n-# CHECK: $ \"diff\" \"-\" \"{{[^\"]*}}.foo\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"FileCheck\"\n+#      CHECK: cat {{.*}}.bar | diff -u {{.*}}.foo - && false || true\n+# CHECK-NEXT: # executed command: cat {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # executed command: diff -u {{.+}}.foo{{.*}} -\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -foo\n+# CHECK-NEXT: # | +bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: cat {{.*}}.bar | diff -u - {{.*}}.foo && false || true\n+# CHECK-NEXT: # executed command: cat {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # executed command: diff -u - {{.+}}.foo{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -bar\n+# CHECK-NEXT: # | +foo\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#     CHECK: cat {{.*}}.foo | diff - {{.*}}.foo | FileCheck {{.*}}\n # CHECK-NOT: note\n # CHECK-NOT: error\n \n-# CHECK: $ \"cat\" \"{{[^\"]*}}.bar\"\n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"-\"\n-# CHECK: note: command had no output on stdout or stderr\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"FileCheck\"\n-# CHECK-NOT: note\n-# CHECK-NOT: error\n-# CHECK: $ \"true\"\n+#      CHECK: cat {{.*}}.bar | diff -u {{.*}}.foo - | FileCheck {{.*}}\n+# CHECK-NEXT: # executed command: cat {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # executed command: diff -u {{.+}}.foo{{.*}} -\n+# CHECK-NEXT: note: command had no output on stdout or stderr\n+# CHECK-NEXT: error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: FileCheck\n+# CHECK-NEXT: # executed command: true\n \n-# CHECK: $ \"false\"\n+# CHECK: false\n \n # CHECK: ***\n \n \n # CHECK: FAIL: shtest-shell :: diff-r-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-0.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: dir1unique\n-# CHECK: Only in {{.*}}dir2: dir2unique\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: dir1unique\n+# CHECK: # | Only in {{.*}}dir2: dir2unique\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-1.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: *** {{.*}}dir1{{.*}}subdir{{.*}}f01\n-# CHECK: --- {{.*}}dir2{{.*}}subdir{{.*}}f01\n-# CHECK: 12345\n-# CHECK: 00000\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | *** {{.*}}dir1{{.*}}subdir{{.*}}f01\n+# CHECK: # | --- {{.*}}dir2{{.*}}subdir{{.*}}f01\n+# CHECK: # | ! 12345\n+# CHECK: # | ! 00000\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-2.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir2: extrafile\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir2: extrafile\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-3.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-3.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: extra_subdir\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: extra_subdir\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-4.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-4.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: File {{.*}}dir1{{.*}}extra_subdir is a directory while file {{.*}}dir2{{.*}}extra_subdir is a regular file\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | File {{.*}}dir1{{.*}}extra_subdir is a directory while file {{.*}}dir2{{.*}}extra_subdir is a regular file\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-5.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-5.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: Only in {{.*}}dir1: extra_subdir\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | Only in {{.*}}dir1: extra_subdir\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-6.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-6.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\"\n-# CHECK: # command output:\n-# CHECK: File {{.*}}dir1{{.*}}extra_file is a regular empty file while file {{.*}}dir2{{.*}}extra_file is a directory\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r\n+# CHECK: # .---command stdout{{-*}}\n+# CHECK: # | File {{.*}}dir1{{.*}}extra_file is a regular empty file while file {{.*}}dir2{{.*}}extra_file is a directory\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-7.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-7.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\" \"-\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: cannot recursively compare '-'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r - {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: cannot recursively compare '-'\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: FAIL: shtest-shell :: diff-r-error-8.txt\n # CHECK: *** TEST 'shtest-shell :: diff-r-error-8.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-r\" \"{{[^\"]*}}\" \"-\"\n-# CHECK: # command stderr:\n-# CHECK: Error: cannot recursively compare '-'\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: diff -r {{.*}} -\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: cannot recursively compare '-'\n+# CHECK: # error: command failed with exit status: 1\n \n # CHECK: PASS: shtest-shell :: diff-r.txt\n \n@@ -362,51 +365,59 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-strip-trailing-cr.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"diff-in.dos\" \"diff-in.unix\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -In this file, the\n-# CHECK-NEXT: -sequence \"\\r\\n\"\n-# CHECK-NEXT: -terminates lines.\n-# CHECK-NEXT: +In this file, the\n-# CHECK-NEXT: +sequence \"\\n\"\n-# CHECK-NEXT: +terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"diff-in.unix\" \"diff-in.dos\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT: -In this file, the\n-# CHECK-NEXT: -sequence \"\\n\"\n-# CHECK-NEXT: -terminates lines.\n-# CHECK-NEXT: +In this file, the\n-# CHECK-NEXT: +sequence \"\\r\\n\"\n-# CHECK-NEXT: +terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"--strip-trailing-cr\" \"diff-in.dos\" \"diff-in.unix\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT:  In this file, the\n-# CHECK-NEXT: -sequence \"\\r\\n\"\n-# CHECK-NEXT: +sequence \"\\n\"\n-# CHECK-NEXT:  terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-u\" \"--strip-trailing-cr\" \"diff-in.unix\" \"diff-in.dos\"\n-# CHECK: # command output:\n-# CHECK: @@\n-# CHECK-NEXT:  In this file, the\n-# CHECK-NEXT: -sequence \"\\n\"\n-# CHECK-NEXT: +sequence \"\\r\\n\"\n-# CHECK-NEXT:  terminates lines.\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"false\"\n+#      CHECK: diff -u diff-in.dos diff-in.unix && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.dos diff-in.unix\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -In this file, the\n+# CHECK-NEXT: # | -sequence \"\\r\\n\"\n+# CHECK-NEXT: # | -terminates lines.\n+# CHECK-NEXT: # | +In this file, the\n+# CHECK-NEXT: # | +sequence \"\\n\"\n+# CHECK-NEXT: # | +terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u diff-in.unix diff-in.dos && false || true\n+# CHECK-NEXT: # executed command: diff -u diff-in.unix diff-in.dos\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # | -In this file, the\n+# CHECK-NEXT: # | -sequence \"\\n\"\n+# CHECK-NEXT: # | -terminates lines.\n+# CHECK-NEXT: # | +In this file, the\n+# CHECK-NEXT: # | +sequence \"\\r\\n\"\n+# CHECK-NEXT: # | +terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u --strip-trailing-cr diff-in.dos diff-in.unix && false || true\n+# CHECK-NEXT: executed command: diff -u --strip-trailing-cr diff-in.dos diff-in.unix\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # |  In this file, the\n+# CHECK-NEXT: # | -sequence \"\\r\\n\"\n+# CHECK-NEXT: # | +sequence \"\\n\"\n+# CHECK-NEXT: # |  terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -u --strip-trailing-cr diff-in.unix diff-in.dos && false || true\n+# CHECK-NEXT: # executed command: diff -u --strip-trailing-cr diff-in.unix diff-in.dos\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@\n+# CHECK-NEXT: # |  In this file, the\n+# CHECK-NEXT: # | -sequence \"\\n\"\n+# CHECK-NEXT: # | +sequence \"\\r\\n\"\n+# CHECK-NEXT: # |  terminates lines.\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n@@ -415,106 +426,144 @@\n \n # CHECK: *** TEST 'shtest-shell :: diff-unified.txt' FAILED ***\n \n-# CHECK: $ \"diff\" \"-u\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 3\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-NEXT: 9\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U\" \"2\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U4\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: 2\n-# CHECK-NEXT: 3\n-# CHECK-NEXT: 4\n-# CHECK-NEXT: 5\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-NEXT: 7\n-# CHECK-NEXT: 8\n-# CHECK-NEXT: 9\n-# CHECK-NEXT: 10\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U0\" \"{{[^\"]*}}.foo\" \"{{[^\"]*}}.bar\"\n-# CHECK: # command output:\n-# CHECK: @@ {{.*}} @@\n-# CHECK-NEXT: -6 foo\n-# CHECK-NEXT: +6 bar\n-# CHECK-EMPTY:\n-# CHECK-NEXT: error: command failed with exit status: 1\n-# CHECK-NEXT: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U\" \"30.1\" \"{{[^\"]*}}\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: invalid '-U' argument: 30.1\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"diff\" \"-U-1\" \"{{[^\"]*}}\" \"{{[^\"]*}}\"\n-# CHECK: # command stderr:\n-# CHECK: Error: invalid '-U' argument: -1\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: $ \"true\"\n-\n-# CHECK: $ \"false\"\n+#      CHECK: diff -u {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -u {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 3\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # | 9\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U 2 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U 2 {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U4 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U4 {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | 2\n+# CHECK-NEXT: # | 3\n+# CHECK-NEXT: # | 4\n+# CHECK-NEXT: # | 5\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # | 7\n+# CHECK-NEXT: # | 8\n+# CHECK-NEXT: # | 9\n+# CHECK-NEXT: # | 10\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+#      CHECK: diff -U0 {{.*}}.foo {{.*}}.bar && false || true\n+# CHECK-NEXT: # executed command: diff -U0 {{.+}}.foo{{.*}} {{.+}}.bar{{.*}}\n+# CHECK-NEXT: # .---command stdout{{-*}}\n+#      CHECK: # | @@ {{.*}} @@\n+# CHECK-NEXT: # | -6 foo\n+# CHECK-NEXT: # | +6 bar\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+# CHECK-NEXT: # executed command: true\n+\n+# CHECK: diff -U 30.1 {{.*}} {{.*}} && false || true\n+# CHECK: # executed command: diff -U 30.1 {{.*}} {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: invalid '-U' argument: 30.1\n+# CHECK: # error: command failed with exit status: 1\n+# CHECK: # executed command: true\n+\n+# CHECK: diff -U-1 {{.*}} {{.*}} && false || true\n+# CHECK: # executed command: diff -U-1 {{.*}} {{.*}}\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: invalid '-U' argument: -1\n+# CHECK: # error: command failed with exit status: 1\n+# CHECK: # executed command: true\n+\n+# CHECK: false\n \n # CHECK: ***\n \n \n-# CHECK: FAIL: shtest-shell :: diff-w.txt\n-# CHECK: *** TEST 'shtest-shell :: diff-w.txt' FAILED ***\n-# CHECK: $ \"diff\" \"-w\" \"{{[^\"]*}}.0\" \"{{[^\"]*}}.1\"\n-# CHECK: # command output:\n-# CHECK: 1,3\n-# CHECK-NEXT: {{^  }}foo\n-# CHECK-NEXT: {{^  }}bar\n-# CHECK-NEXT: ! baz\n-# CHECK-NEXT: ---\n-# CHECK-NEXT: {{^  }}foo\n-# CHECK-NEXT: {{^  }}bar\n-# CHECK-NEXT: ! bat\n-# CHECK-EMPTY:\n-# CHECK: error: command failed with exit status: 1\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: diff-w.txt\n+#      CHECK: *** TEST 'shtest-shell :: diff-w.txt' FAILED ***\n+#      CHECK: diff -w {{.*}}.0 {{.*}}.1\n+#      CHECK: # .---command stdout{{-*}}\n+#      CHECK: # | {{\\*+}} 1,3\n+# CHECK-NEXT: # |   foo\n+# CHECK-NEXT: # |   bar\n+# CHECK-NEXT: # | ! baz\n+# CHECK-NEXT: # | ---\n+# CHECK-NEXT: # |   foo\n+# CHECK-NEXT: # |   bar\n+# CHECK-NEXT: # | ! bat\n+# CHECK-NEXT: # `---{{-*}}\n+# CHECK-NEXT: # error: command failed with exit status: 1\n+#      CHECK: ***\n+\n+# CHECK: FAIL: shtest-shell :: echo-at-redirect-stderr.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-at-redirect-stderr.txt' FAILED ***\n+# CHECK: @echo 2> {{.*}}\n+# CHECK: # executed command: @echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for @echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-at-redirect-stdin.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-at-redirect-stdin.txt' FAILED ***\n+# CHECK: @echo < {{.*}}\n+# CHECK: # executed command: @echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for @echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-redirect-stderr.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-redirect-stderr.txt' FAILED ***\n+# CHECK: echo 2> {{.*}}\n+# CHECK: # executed command: echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for echo\n+# CHECK: error: command failed with exit status:\n+\n+# CHECK: FAIL: shtest-shell :: echo-redirect-stdin.txt\n+# CHECK: *** TEST 'shtest-shell :: echo-redirect-stdin.txt' FAILED ***\n+# CHECK: echo < {{.*}}\n+# CHECK: # executed command: echo\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | stdin and stderr redirects not supported for echo\n+# CHECK: error: command failed with exit status:\n \n # CHECK: FAIL: shtest-shell :: error-0.txt\n # CHECK: *** TEST 'shtest-shell :: error-0.txt' FAILED ***\n-# CHECK: $ \"not-a-real-command\"\n-# CHECK: # command stderr:\n-# CHECK: 'not-a-real-command': command not found\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: not-a-real-command\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | 'not-a-real-command': command not found\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # FIXME: The output here sucks.\n #\n # CHECK: FAIL: shtest-shell :: error-1.txt\n # CHECK: *** TEST 'shtest-shell :: error-1.txt' FAILED ***\n-# CHECK: shell parser error on: ': \\'RUN: at line 3\\'; echo \"missing quote'\n+# CHECK: shell parser error on RUN: at line 3: echo \"missing quote\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: error-2.txt\n@@ -524,52 +573,52 @@\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-0.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'mkdir' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p temp | rm -rf temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'mkdir' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-1.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\" \"-m\" \"777\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'mkdir': option -m not recognized\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p -m 777 temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'mkdir': option -m not recognized\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: mkdir-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: mkdir-error-2.txt' FAILED ***\n-# CHECK: $ \"mkdir\" \"-p\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'mkdir' is missing an operand\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: mkdir -p\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'mkdir' is missing an operand\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: PASS: shtest-shell :: redirects.txt\n \n # CHECK: FAIL: shtest-shell :: rm-error-0.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-0.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-rf\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'rm' cannot be part of a pipeline\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: rm -rf temp | echo \"hello\"\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'rm' cannot be part of a pipeline\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-1.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-1.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-f\" \"-v\" \"temp\"\n-# CHECK: # command stderr:\n-# CHECK: Unsupported: 'rm': option -v not recognized\n-# CHECK: error: command failed with exit status: 127\n+# CHECK: rm -f -v temp\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Unsupported: 'rm': option -v not recognized\n+# CHECK: # error: command failed with exit status: 127\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-2.txt\n # CHECK: *** TEST 'shtest-shell :: rm-error-2.txt' FAILED ***\n-# CHECK: $ \"rm\" \"-r\" \"hello\"\n-# CHECK: # command stderr:\n-# CHECK: Error: 'rm' command failed\n-# CHECK: error: command failed with exit status: 1\n+# CHECK: rm -r hello\n+# CHECK: # .---command stderr{{-*}}\n+# CHECK: # | Error: 'rm' command failed\n+# CHECK: # error: command failed with exit status: 1\n # CHECK: ***\n \n # CHECK: FAIL: shtest-shell :: rm-error-3.txt\n@@ -581,16 +630,17 @@\n # CHECK: PASS: shtest-shell :: sequencing-0.txt\n # CHECK: XFAIL: shtest-shell :: sequencing-1.txt\n \n-# CHECK: FAIL: shtest-shell :: stdout-encoding.txt\n-# CHECK: *** TEST 'shtest-shell :: stdout-encoding.txt' FAILED ***\n-# CHECK: $ \"cat\" \"diff-in.bin\"\n-# CHECK: # command output:\n-# CHECK-NEXT: {{^.f.o.o.$}}\n-# CHECK-NEXT: {{^.b.a.r.}}\n-# CHECK-NEXT: {{^.b.a.z.$}}\n-# CHECK-NOT: error\n-# CHECK: $ \"false\"\n-# CHECK: ***\n+#      CHECK: FAIL: shtest-shell :: stdout-encoding.txt\n+#      CHECK: *** TEST 'shtest-shell :: stdout-encoding.txt' FAILED ***\n+#      CHECK: cat diff-in.bin\n+#      CHECK: # .---command stdout{{-*}}\n+# CHECK-NEXT: # | {{.f.o.o.$}}\n+# CHECK-NEXT: # | {{.b.a.r.}}\n+# CHECK-NEXT: # | {{.b.a.z.$}}\n+# CHECK-NEXT: # `---{{-*}}\n+#  CHECK-NOT: error\n+#      CHECK: false\n+#      CHECK: ***\n \n # CHECK: PASS: shtest-shell :: valid-shell.txt\n-# CHECK: Failed Tests (35)\n+# CHECK: Failed Tests (39)\n", "message": "", "files": {"/libcxx/utils/libcxx/test/dsl.py": {"changes": [{"diff": "\n                 \"Failed to run program, cmd:\\n{}\\nstderr is:\\n{}\".format(runcmd, err)\n             )\n \n-        return libcxx.test.format._parseLitOutput(out)\n+        return out\n \n \n @_memoizeExpensiveOperation(", "add": 1, "remove": 1, "filename": "/libcxx/utils/libcxx/test/dsl.py", "badparts": ["        return libcxx.test.format._parseLitOutput(out)"], "goodparts": ["        return out"]}]}, "/libcxx/utils/libcxx/test/format.py": {"changes": [{"diff": "\n     for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n         assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n \n-def _parseLitOutput(fullOutput):\n-    \"\"\"\n-    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n-\n-    This takes output of the form\n-\n-        $ \":\" \"RUN: at line 11\"\n-        $ \"echo\" \"OUTPUT1\"\n-        # command output:\n-        OUTPUT1\n-\n-        $ \":\" \"RUN: at line 12\"\n-        $ \"echo\" \"OUTPUT2\"\n-        # command output:\n-        OUTPUT2\n-\n-    and returns a string containing\n-\n-        OUTPUT1\n-        OUTPUT2\n-\n-    as-if the commands had been run directly. This is a workaround for the fact\n-    that Lit doesn't let us execute ShTest and retrieve the raw output without\n-    injecting additional Lit output around it.\n-    \"\"\"\n-    parsed = ''\n-    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n-        if output: # skip blank lines\n-            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n-            if commandOutput:\n-                parsed += commandOutput.group(1)\n-    return parsed\n-\n def _executeScriptInternal(test, litConfig, commands):\n     \"\"\"\n     Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n", "add": 0, "remove": 33, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["def _parseLitOutput(fullOutput):", "    \"\"\"", "    Parse output of a Lit ShTest to extract the actual output of the contained commands.", "    This takes output of the form", "        $ \":\" \"RUN: at line 11\"", "        $ \"echo\" \"OUTPUT1\"", "        OUTPUT1", "        $ \":\" \"RUN: at line 12\"", "        $ \"echo\" \"OUTPUT2\"", "        OUTPUT2", "    and returns a string containing", "        OUTPUT1", "        OUTPUT2", "    as-if the commands had been run directly. This is a workaround for the fact", "    that Lit doesn't let us execute ShTest and retrieve the raw output without", "    injecting additional Lit output around it.", "    \"\"\"", "    parsed = ''", "    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):", "        if output: # skip blank lines", "            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)", "            if commandOutput:", "                parsed += commandOutput.group(1)", "    return parsed"], "goodparts": []}, {"diff": "\n     _, tmpBase = _getTempPaths(test)\n     execDir = os.path.dirname(test.getExecPath())\n     res = lit.TestRunner.executeScriptInternal(\n-        test, litConfig, tmpBase, parsedCommands, execDir\n+        test, litConfig, tmpBase, parsedCommands, execDir, debug=False\n     )\n     if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n         res = (\"\", res.output, 127, None)\n     (out, err, exitCode, timeoutInfo) = res\n \n-    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n-    #       split any stderr output that is included in stdout. It shouldn't be there, but\n-    #       the Lit internal shell conflates stderr and stdout.\n-    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n-    if conflatedErrorOutput:\n-        conflatedErrorOutput = conflatedErrorOutput.group(0)\n-        out = out[: -len(conflatedErrorOutput)]\n-        err += conflatedErrorOutput\n-\n     return (out, err, exitCode, timeoutInfo, parsedCommands)\n \n \n", "add": 1, "remove": 10, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["        test, litConfig, tmpBase, parsedCommands, execDir", "    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)", "    if conflatedErrorOutput:", "        conflatedErrorOutput = conflatedErrorOutput.group(0)", "        out = out[: -len(conflatedErrorOutput)]", "        err += conflatedErrorOutput"], "goodparts": ["        test, litConfig, tmpBase, parsedCommands, execDir, debug=False"]}, {"diff": "\n             raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n \n         # Split the generated output into multiple files and generate one test for each file\n-        parsed = _parseLitOutput(out)\n-        for (subfile, content) in self._splitFile(parsed):\n-            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n+        for subfile, content in self._splitFile(out):\n+            generatedFile = testSuite.getExecPath(pathInSuite + (subfile,))\n             os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n             with open(generatedFile, 'w') as f:\n                 f.write(content", "add": 2, "remove": 3, "filename": "/libcxx/utils/libcxx/test/format.py", "badparts": ["        parsed = _parseLitOutput(out)", "        for (subfile, content) in self._splitFile(parsed):", "            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))"], "goodparts": ["        for subfile, content in self._splitFile(out):", "            generatedFile = testSuite.getExecPath(pathInSuite + (subfile,))"]}], "source": "\n import contextlib import io import lit import lit.formats import os import pipes import re import shutil def _getTempPaths(test): \"\"\" Return the values to use for the %T and %t substitutions, respectively. The difference between this and Lit's default behavior is that we guarantee that %T is a path unique to the test being run. \"\"\" tmpDir, _=lit.TestRunner.getTempPaths(test) _, testName=os.path.split(test.getExecPath()) tmpDir=os.path.join(tmpDir, testName +\".dir\") tmpBase=os.path.join(tmpDir, \"t\") return tmpDir, tmpBase def _checkBaseSubstitutions(substitutions): substitutions=[s for(s, _) in substitutions] for s in[\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]: assert s in substitutions, \"Required substitution{} was not provided\".format(s) def _parseLitOutput(fullOutput): \"\"\" Parse output of a Lit ShTest to extract the actual output of the contained commands. This takes output of the form $ \":\" \"RUN: at line 11\" $ \"echo\" \"OUTPUT1\" OUTPUT1 $ \":\" \"RUN: at line 12\" $ \"echo\" \"OUTPUT2\" OUTPUT2 and returns a string containing OUTPUT1 OUTPUT2 as-if the commands had been run directly. This is a workaround for the fact that Lit doesn't let us execute ShTest and retrieve the raw output without injecting additional Lit output around it. \"\"\" parsed='' for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput): if output: commandOutput=re.search(\" if commandOutput: parsed +=commandOutput.group(1) return parsed def _executeScriptInternal(test, litConfig, commands): \"\"\" Returns(stdout, stderr, exitCode, timeoutInfo, parsedCommands) TODO: This really should be easier to access from Lit itself \"\"\" parsedCommands=parseScript(test, preamble=commands) _, tmpBase=_getTempPaths(test) execDir=os.path.dirname(test.getExecPath()) res=lit.TestRunner.executeScriptInternal( test, litConfig, tmpBase, parsedCommands, execDir ) if isinstance(res, lit.Test.Result): res=(\"\", res.output, 127, None) (out, err, exitCode, timeoutInfo)=res conflatedErrorOutput=re.search(\"( if conflatedErrorOutput: conflatedErrorOutput=conflatedErrorOutput.group(0) out=out[: -len(conflatedErrorOutput)] err +=conflatedErrorOutput return(out, err, exitCode, timeoutInfo, parsedCommands) def parseScript(test, preamble): \"\"\" Extract the script from a test, with substitutions applied. Returns a list of commands ready to be executed. -test The lit.Test to parse. -preamble A list of commands to perform before any command in the test. These commands can contain unexpanded substitutions, but they must not be of the form 'RUN:' --they must be proper commands once substituted. \"\"\" tmpDir, tmpBase=_getTempPaths(test) substitutions=lit.TestRunner.getDefaultSubstitutions(test, tmpDir, tmpBase) _checkBaseSubstitutions(substitutions) substitutions.append( (\"%{build}\", \"%{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\") ) substitutions.append((\"%{run}\", \"%{exec} %t.exe\")) additionalCompileFlags=[] fileDependencies=[] parsers=[ lit.TestRunner.IntegratedTestKeywordParser( \"FILE_DEPENDENCIES:\", lit.TestRunner.ParserKind.LIST, initial_value=fileDependencies, ), lit.TestRunner.IntegratedTestKeywordParser( \"ADDITIONAL_COMPILE_FLAGS:\", lit.TestRunner.ParserKind.LIST, initial_value=additionalCompileFlags, ), ] for feature in test.config.available_features: parser=lit.TestRunner.IntegratedTestKeywordParser( \"ADDITIONAL_COMPILE_FLAGS({}):\".format(feature), lit.TestRunner.ParserKind.LIST, initial_value=additionalCompileFlags, ) parsers.append(parser) scriptInTest=lit.TestRunner.parseIntegratedTestScript( test, additional_parsers=parsers, require_script=not preamble ) if isinstance(scriptInTest, lit.Test.Result): return scriptInTest script=[] for dep in fileDependencies: script +=[\"%dbg(SETUP) cd %S && cp{} %T\".format(dep)] script +=preamble script +=scriptInTest substitutions=[ (s, x +\" \" +\" \".join(additionalCompileFlags)) if s==\"%{compile_flags}\" else(s, x) for(s, x) in substitutions ] script=lit.TestRunner.applySubstitutions( script, substitutions, recursion_limit=test.config.recursiveExpansionLimit ) return script class CxxStandardLibraryTest(lit.formats.FileBasedTest): \"\"\" Lit test format for the C++Standard Library conformance test suite. This test format is based on top of the ShTest format --it basically creates a shell script performing the right operations(compile/link/run) based on the extension of the test file it encounters. It supports files with the following extensions: FOO.pass.cpp -Compiles, links and runs successfully FOO.pass.mm -Same as.pass.cpp, but for Objective-C++ FOO.compile.pass.cpp -Compiles successfully, link and run not attempted FOO.compile.pass.mm -Same as.compile.pass.cpp, but for Objective-C++ FOO.compile.fail.cpp -Does not compile successfully FOO.link.pass.cpp -Compiles and links successfully, run not attempted FOO.link.pass.mm -Same as.link.pass.cpp, but for Objective-C++ FOO.link.fail.cpp -Compiles successfully, but fails to link FOO.sh.<anything> -A builtin Lit Shell test FOO.gen.<anything> -A.sh test that generates one or more Lit tests on the fly. Executing this test must generate one or more files as expected by LLVM split-file, and each generated file leads to a separate Lit test that runs that file as defined by the test format. This can be used to generate multiple Lit tests from a single source file, which is useful for testing repetitive properties in the library. Be careful not to abuse this since this is not a replacement for usual code reuse techniques. FOO.verify.cpp -Compiles with clang-verify. This type of test is automatically marked as UNSUPPORTED if the compiler does not support Clang-verify. Substitution requirements =============================== The test format operates by assuming that each test's configuration provides the following substitutions, which it will reuse in the shell scripts it constructs: %{cxx} -A command that can be used to invoke the compiler %{compile_flags} -Flags to use when compiling a test case %{link_flags} -Flags to use when linking a test case %{flags} -Flags to use either when compiling or linking a test case %{exec} -A command to prefix the execution of executables Note that when building an executable(as opposed to only compiling a source file), all three of %{flags}, %{compile_flags} and %{link_flags} will be used in the same command line. In other words, the test format doesn't perform separate compilation and linking steps in this case. Additional supported directives =============================== In addition to everything that's supported in Lit ShTests, this test format also understands the following directives inside test files: // FILE_DEPENDENCIES: file, directory, /path/to/file This directive expresses that the test requires the provided files or directories in order to run. An example is a test that requires some test input stored in a data file. When a test file contains such a directive, this test format will collect them and copy them to the directory represented by %T. The intent is that %T contains all the inputs necessary to run the test, such that e.g. execution on a remote host can be done by simply copying %T to the host. // ADDITIONAL_COMPILE_FLAGS: flag1, flag2, flag3 This directive will cause the provided flags to be added to the %{compile_flags} substitution for the test that contains it. This allows adding special compilation flags without having to use a .sh.cpp test, which would be more powerful but perhaps overkill. Additional provided substitutions and features ============================================== The test format will define the following substitutions for use inside tests: %{build} Expands to a command-line that builds the current source file with the %{flags}, %{compile_flags} and %{link_flags} substitutions, and that produces an executable named %t.exe. %{run} Equivalent to `%{exec} %t.exe`. This is intended to be used in conjunction with the %{build} substitution. \"\"\" def getTestsForPath(self, testSuite, pathInSuite, litConfig, localConfig): SUPPORTED_SUFFIXES=[ \"[.]pass[.]cpp$\", \"[.]pass[.]mm$\", \"[.]compile[.]pass[.]cpp$\", \"[.]compile[.]pass[.]mm$\", \"[.]compile[.]fail[.]cpp$\", \"[.]link[.]pass[.]cpp$\", \"[.]link[.]pass[.]mm$\", \"[.]link[.]fail[.]cpp$\", \"[.]sh[.][^.]+$\", \"[.]gen[.][^.]+$\", \"[.]verify[.]cpp$\", \"[.]fail[.]cpp$\", ] sourcePath=testSuite.getSourcePath(pathInSuite) filename=os.path.basename(sourcePath) hasSupportedSuffix=lambda f: any([re.search(ext, f) for ext in SUPPORTED_SUFFIXES]) if filename.startswith(\".\") or filename in localConfig.excludes or not hasSupportedSuffix(filename): return if re.search('[.]gen[.][^.]+$', filename): for test in self._generateGenTest(testSuite, pathInSuite, litConfig, localConfig): yield test else: yield lit.Test.Test(testSuite, pathInSuite, localConfig) def execute(self, test, litConfig): VERIFY_FLAGS=( \"-Xclang -verify -Xclang -verify-ignore-unexpected=note -ferror-limit=0\" ) supportsVerify=\"verify-support\" in test.config.available_features filename=test.path_in_suite[-1] if re.search(\"[.]sh[.][^.]+$\", filename): steps=[] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".compile.pass.cpp\") or filename.endswith( \".compile.pass.mm\" ): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".compile.fail.cpp\"): steps=[ \"%dbg(COMPILED WITH) ! %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".link.pass.cpp\") or filename.endswith(\".link.pass.mm\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\" ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".link.fail.cpp\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -c -o %t.o\", \"%dbg(LINKED WITH) ! %{cxx} %t.o %{flags} %{link_flags} -o %t.exe\", ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".verify.cpp\"): if not supportsVerify: return lit.Test.Result( lit.Test.UNSUPPORTED, \"Test{} requires support for Clang-verify, which isn't supported by the compiler\".format( test.getFullName() ), ) steps=[ \"%dbg(COMPILED WITH) %{{cxx}} %s %{{flags}} %{{compile_flags}} -fsyntax-only -Wno-error{}\".format( VERIFY_FLAGS ) ] return self._executeShTest(test, litConfig, steps) elif filename.endswith(\".pass.cpp\") or filename.endswith(\".pass.mm\"): steps=[ \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\", \"%dbg(EXECUTED AS) %{exec} %t.exe\", ] return self._executeShTest(test, litConfig, steps) else: return lit.Test.Result( lit.Test.UNRESOLVED, \"Unknown test suffix for '{}'\".format(filename) ) def _executeShTest(self, test, litConfig, steps): if test.config.unsupported: return lit.Test.Result(lit.Test.UNSUPPORTED, \"Test is unsupported\") script=parseScript(test, steps) if isinstance(script, lit.Test.Result): return script if litConfig.noExecute: return lit.Test.Result( lit.Test.XFAIL if test.isExpectedToFail() else lit.Test.PASS ) else: _, tmpBase=_getTempPaths(test) useExternalSh=False return lit.TestRunner._runShTest( test, litConfig, useExternalSh, script, tmpBase ) def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig): generator=lit.Test.Test(testSuite, pathInSuite, localConfig) generatorExecDir=os.path.dirname(testSuite.getExecPath(pathInSuite)) os.makedirs(generatorExecDir, exist_ok=True) steps=[] (out, err, exitCode, _, _)=_executeScriptInternal(generator, litConfig, steps) if exitCode !=0: raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\") parsed=_parseLitOutput(out) for(subfile, content) in self._splitFile(parsed): generatedFile=testSuite.getExecPath(pathInSuite +(subfile,)) os.makedirs(os.path.dirname(generatedFile), exist_ok=True) with open(generatedFile, 'w') as f: f.write(content) yield lit.Test.Test(testSuite,(generatedFile,), localConfig) def _splitFile(self, input): DELIM=r'^(//| lines=input.splitlines() currentFile=None thisFileContent=[] for line in lines: match=re.match(DELIM, line) if match: if currentFile is not None: yield(currentFile, '\\n'.join(thisFileContent)) currentFile=match.group(2).strip() thisFileContent=[] assert currentFile is not None, f\"Some input to split-file doesn't belong to any file, input was:\\n{input}\" thisFileContent.append(line) if currentFile is not None: yield(currentFile, '\\n'.join(thisFileContent)) ", "sourceWithComments": "# ===----------------------------------------------------------------------===##\n#\n# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n# See https://llvm.org/LICENSE.txt for license information.\n# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n#\n# ===----------------------------------------------------------------------===##\n\nimport contextlib\nimport io\nimport lit\nimport lit.formats\nimport os\nimport pipes\nimport re\nimport shutil\n\n\ndef _getTempPaths(test):\n    \"\"\"\n    Return the values to use for the %T and %t substitutions, respectively.\n\n    The difference between this and Lit's default behavior is that we guarantee\n    that %T is a path unique to the test being run.\n    \"\"\"\n    tmpDir, _ = lit.TestRunner.getTempPaths(test)\n    _, testName = os.path.split(test.getExecPath())\n    tmpDir = os.path.join(tmpDir, testName + \".dir\")\n    tmpBase = os.path.join(tmpDir, \"t\")\n    return tmpDir, tmpBase\n\n\ndef _checkBaseSubstitutions(substitutions):\n    substitutions = [s for (s, _) in substitutions]\n    for s in [\"%{cxx}\", \"%{compile_flags}\", \"%{link_flags}\", \"%{flags}\", \"%{exec}\"]:\n        assert s in substitutions, \"Required substitution {} was not provided\".format(s)\n\ndef _parseLitOutput(fullOutput):\n    \"\"\"\n    Parse output of a Lit ShTest to extract the actual output of the contained commands.\n\n    This takes output of the form\n\n        $ \":\" \"RUN: at line 11\"\n        $ \"echo\" \"OUTPUT1\"\n        # command output:\n        OUTPUT1\n\n        $ \":\" \"RUN: at line 12\"\n        $ \"echo\" \"OUTPUT2\"\n        # command output:\n        OUTPUT2\n\n    and returns a string containing\n\n        OUTPUT1\n        OUTPUT2\n\n    as-if the commands had been run directly. This is a workaround for the fact\n    that Lit doesn't let us execute ShTest and retrieve the raw output without\n    injecting additional Lit output around it.\n    \"\"\"\n    parsed = ''\n    for output in re.split('[$]\\s*\":\"\\s*\"RUN: at line \\d+\"', fullOutput):\n        if output: # skip blank lines\n            commandOutput = re.search(\"# command output:\\n(.+)\\n$\", output, flags=re.DOTALL)\n            if commandOutput:\n                parsed += commandOutput.group(1)\n    return parsed\n\ndef _executeScriptInternal(test, litConfig, commands):\n    \"\"\"\n    Returns (stdout, stderr, exitCode, timeoutInfo, parsedCommands)\n\n    TODO: This really should be easier to access from Lit itself\n    \"\"\"\n    parsedCommands = parseScript(test, preamble=commands)\n\n    _, tmpBase = _getTempPaths(test)\n    execDir = os.path.dirname(test.getExecPath())\n    res = lit.TestRunner.executeScriptInternal(\n        test, litConfig, tmpBase, parsedCommands, execDir\n    )\n    if isinstance(res, lit.Test.Result):  # Handle failure to parse the Lit test\n        res = (\"\", res.output, 127, None)\n    (out, err, exitCode, timeoutInfo) = res\n\n    # TODO: As a temporary workaround until https://reviews.llvm.org/D81892 lands, manually\n    #       split any stderr output that is included in stdout. It shouldn't be there, but\n    #       the Lit internal shell conflates stderr and stdout.\n    conflatedErrorOutput = re.search(\"(# command stderr:.+$)\", out, flags=re.DOTALL)\n    if conflatedErrorOutput:\n        conflatedErrorOutput = conflatedErrorOutput.group(0)\n        out = out[: -len(conflatedErrorOutput)]\n        err += conflatedErrorOutput\n\n    return (out, err, exitCode, timeoutInfo, parsedCommands)\n\n\ndef parseScript(test, preamble):\n    \"\"\"\n    Extract the script from a test, with substitutions applied.\n\n    Returns a list of commands ready to be executed.\n\n    - test\n        The lit.Test to parse.\n\n    - preamble\n        A list of commands to perform before any command in the test.\n        These commands can contain unexpanded substitutions, but they\n        must not be of the form 'RUN:' -- they must be proper commands\n        once substituted.\n    \"\"\"\n    # Get the default substitutions\n    tmpDir, tmpBase = _getTempPaths(test)\n    substitutions = lit.TestRunner.getDefaultSubstitutions(test, tmpDir, tmpBase)\n\n    # Check base substitutions and add the %{build} and %{run} convenience substitutions\n    _checkBaseSubstitutions(substitutions)\n    substitutions.append(\n        (\"%{build}\", \"%{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\")\n    )\n    substitutions.append((\"%{run}\", \"%{exec} %t.exe\"))\n\n    # Parse the test file, including custom directives\n    additionalCompileFlags = []\n    fileDependencies = []\n    parsers = [\n        lit.TestRunner.IntegratedTestKeywordParser(\n            \"FILE_DEPENDENCIES:\",\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=fileDependencies,\n        ),\n        lit.TestRunner.IntegratedTestKeywordParser(\n            \"ADDITIONAL_COMPILE_FLAGS:\",\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=additionalCompileFlags,\n        ),\n    ]\n\n    # Add conditional parsers for ADDITIONAL_COMPILE_FLAGS. This should be replaced by first\n    # class support for conditional keywords in Lit, which would allow evaluating arbitrary\n    # Lit boolean expressions instead.\n    for feature in test.config.available_features:\n        parser = lit.TestRunner.IntegratedTestKeywordParser(\n            \"ADDITIONAL_COMPILE_FLAGS({}):\".format(feature),\n            lit.TestRunner.ParserKind.LIST,\n            initial_value=additionalCompileFlags,\n        )\n        parsers.append(parser)\n\n    scriptInTest = lit.TestRunner.parseIntegratedTestScript(\n        test, additional_parsers=parsers, require_script=not preamble\n    )\n    if isinstance(scriptInTest, lit.Test.Result):\n        return scriptInTest\n\n    script = []\n\n    # For each file dependency in FILE_DEPENDENCIES, inject a command to copy\n    # that file to the execution directory. Execute the copy from %S to allow\n    # relative paths from the test directory.\n    for dep in fileDependencies:\n        script += [\"%dbg(SETUP) cd %S && cp {} %T\".format(dep)]\n    script += preamble\n    script += scriptInTest\n\n    # Add compile flags specified with ADDITIONAL_COMPILE_FLAGS.\n    substitutions = [\n        (s, x + \" \" + \" \".join(additionalCompileFlags))\n        if s == \"%{compile_flags}\"\n        else (s, x)\n        for (s, x) in substitutions\n    ]\n\n    # Perform substitutions in the script itself.\n    script = lit.TestRunner.applySubstitutions(\n        script, substitutions, recursion_limit=test.config.recursiveExpansionLimit\n    )\n\n    return script\n\n\nclass CxxStandardLibraryTest(lit.formats.FileBasedTest):\n    \"\"\"\n    Lit test format for the C++ Standard Library conformance test suite.\n\n    This test format is based on top of the ShTest format -- it basically\n    creates a shell script performing the right operations (compile/link/run)\n    based on the extension of the test file it encounters. It supports files\n    with the following extensions:\n\n    FOO.pass.cpp            - Compiles, links and runs successfully\n    FOO.pass.mm             - Same as .pass.cpp, but for Objective-C++\n\n    FOO.compile.pass.cpp    - Compiles successfully, link and run not attempted\n    FOO.compile.pass.mm     - Same as .compile.pass.cpp, but for Objective-C++\n    FOO.compile.fail.cpp    - Does not compile successfully\n\n    FOO.link.pass.cpp       - Compiles and links successfully, run not attempted\n    FOO.link.pass.mm        - Same as .link.pass.cpp, but for Objective-C++\n    FOO.link.fail.cpp       - Compiles successfully, but fails to link\n\n    FOO.sh.<anything>       - A builtin Lit Shell test\n\n    FOO.gen.<anything>      - A .sh test that generates one or more Lit tests on the\n                              fly. Executing this test must generate one or more files\n                              as expected by LLVM split-file, and each generated file\n                              leads to a separate Lit test that runs that file as\n                              defined by the test format. This can be used to generate\n                              multiple Lit tests from a single source file, which is\n                              useful for testing repetitive properties in the library.\n                              Be careful not to abuse this since this is not a replacement\n                              for usual code reuse techniques.\n\n    FOO.verify.cpp          - Compiles with clang-verify. This type of test is\n                              automatically marked as UNSUPPORTED if the compiler\n                              does not support Clang-verify.\n\n\n    Substitution requirements\n    ===============================\n    The test format operates by assuming that each test's configuration provides\n    the following substitutions, which it will reuse in the shell scripts it\n    constructs:\n        %{cxx}           - A command that can be used to invoke the compiler\n        %{compile_flags} - Flags to use when compiling a test case\n        %{link_flags}    - Flags to use when linking a test case\n        %{flags}         - Flags to use either when compiling or linking a test case\n        %{exec}          - A command to prefix the execution of executables\n\n    Note that when building an executable (as opposed to only compiling a source\n    file), all three of %{flags}, %{compile_flags} and %{link_flags} will be used\n    in the same command line. In other words, the test format doesn't perform\n    separate compilation and linking steps in this case.\n\n\n    Additional supported directives\n    ===============================\n    In addition to everything that's supported in Lit ShTests, this test format\n    also understands the following directives inside test files:\n\n        // FILE_DEPENDENCIES: file, directory, /path/to/file\n\n            This directive expresses that the test requires the provided files\n            or directories in order to run. An example is a test that requires\n            some test input stored in a data file. When a test file contains\n            such a directive, this test format will collect them and copy them\n            to the directory represented by %T. The intent is that %T contains\n            all the inputs necessary to run the test, such that e.g. execution\n            on a remote host can be done by simply copying %T to the host.\n\n        // ADDITIONAL_COMPILE_FLAGS: flag1, flag2, flag3\n\n            This directive will cause the provided flags to be added to the\n            %{compile_flags} substitution for the test that contains it. This\n            allows adding special compilation flags without having to use a\n            .sh.cpp test, which would be more powerful but perhaps overkill.\n\n\n    Additional provided substitutions and features\n    ==============================================\n    The test format will define the following substitutions for use inside tests:\n\n        %{build}\n            Expands to a command-line that builds the current source\n            file with the %{flags}, %{compile_flags} and %{link_flags}\n            substitutions, and that produces an executable named %t.exe.\n\n        %{run}\n            Equivalent to `%{exec} %t.exe`. This is intended to be used\n            in conjunction with the %{build} substitution.\n    \"\"\"\n\n    def getTestsForPath(self, testSuite, pathInSuite, litConfig, localConfig):\n        SUPPORTED_SUFFIXES = [\n            \"[.]pass[.]cpp$\",\n            \"[.]pass[.]mm$\",\n            \"[.]compile[.]pass[.]cpp$\",\n            \"[.]compile[.]pass[.]mm$\",\n            \"[.]compile[.]fail[.]cpp$\",\n            \"[.]link[.]pass[.]cpp$\",\n            \"[.]link[.]pass[.]mm$\",\n            \"[.]link[.]fail[.]cpp$\",\n            \"[.]sh[.][^.]+$\",\n            \"[.]gen[.][^.]+$\",\n            \"[.]verify[.]cpp$\",\n            \"[.]fail[.]cpp$\",\n        ]\n\n        sourcePath = testSuite.getSourcePath(pathInSuite)\n        filename = os.path.basename(sourcePath)\n\n        # Ignore dot files, excluded tests and tests with an unsupported suffix\n        hasSupportedSuffix = lambda f: any([re.search(ext, f) for ext in SUPPORTED_SUFFIXES])\n        if filename.startswith(\".\") or filename in localConfig.excludes or not hasSupportedSuffix(filename):\n            return\n\n        # If this is a generated test, run the generation step and add\n        # as many Lit tests as necessary.\n        if re.search('[.]gen[.][^.]+$', filename):\n            for test in self._generateGenTest(testSuite, pathInSuite, litConfig, localConfig):\n                yield test\n        else:\n            yield lit.Test.Test(testSuite, pathInSuite, localConfig)\n\n    def execute(self, test, litConfig):\n        VERIFY_FLAGS = (\n            \"-Xclang -verify -Xclang -verify-ignore-unexpected=note -ferror-limit=0\"\n        )\n        supportsVerify = \"verify-support\" in test.config.available_features\n        filename = test.path_in_suite[-1]\n\n        if re.search(\"[.]sh[.][^.]+$\", filename):\n            steps = []  # The steps are already in the script\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".compile.pass.cpp\") or filename.endswith(\n            \".compile.pass.mm\"\n        ):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".compile.fail.cpp\"):\n            steps = [\n                \"%dbg(COMPILED WITH) ! %{cxx} %s %{flags} %{compile_flags} -fsyntax-only\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".link.pass.cpp\") or filename.endswith(\".link.pass.mm\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\"\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".link.fail.cpp\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} -c -o %t.o\",\n                \"%dbg(LINKED WITH) ! %{cxx} %t.o %{flags} %{link_flags} -o %t.exe\",\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        elif filename.endswith(\".verify.cpp\"):\n            if not supportsVerify:\n                return lit.Test.Result(\n                    lit.Test.UNSUPPORTED,\n                    \"Test {} requires support for Clang-verify, which isn't supported by the compiler\".format(\n                        test.getFullName()\n                    ),\n                )\n            steps = [\n                # Note: Use -Wno-error to make sure all diagnostics are not treated as errors,\n                #       which doesn't make sense for clang-verify tests.\n                \"%dbg(COMPILED WITH) %{{cxx}} %s %{{flags}} %{{compile_flags}} -fsyntax-only -Wno-error {}\".format(\n                    VERIFY_FLAGS\n                )\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        # Make sure to check these ones last, since they will match other\n        # suffixes above too.\n        elif filename.endswith(\".pass.cpp\") or filename.endswith(\".pass.mm\"):\n            steps = [\n                \"%dbg(COMPILED WITH) %{cxx} %s %{flags} %{compile_flags} %{link_flags} -o %t.exe\",\n                \"%dbg(EXECUTED AS) %{exec} %t.exe\",\n            ]\n            return self._executeShTest(test, litConfig, steps)\n        else:\n            return lit.Test.Result(\n                lit.Test.UNRESOLVED, \"Unknown test suffix for '{}'\".format(filename)\n            )\n\n    def _executeShTest(self, test, litConfig, steps):\n        if test.config.unsupported:\n            return lit.Test.Result(lit.Test.UNSUPPORTED, \"Test is unsupported\")\n\n        script = parseScript(test, steps)\n        if isinstance(script, lit.Test.Result):\n            return script\n\n        if litConfig.noExecute:\n            return lit.Test.Result(\n                lit.Test.XFAIL if test.isExpectedToFail() else lit.Test.PASS\n            )\n        else:\n            _, tmpBase = _getTempPaths(test)\n            useExternalSh = False\n            return lit.TestRunner._runShTest(\n                test, litConfig, useExternalSh, script, tmpBase\n            )\n\n    def _generateGenTest(self, testSuite, pathInSuite, litConfig, localConfig):\n        generator = lit.Test.Test(testSuite, pathInSuite, localConfig)\n\n        # Make sure we have a directory to execute the generator test in\n        generatorExecDir = os.path.dirname(testSuite.getExecPath(pathInSuite))\n        os.makedirs(generatorExecDir, exist_ok=True)\n\n        # Run the generator test\n        steps = [] # Steps must already be in the script\n        (out, err, exitCode, _, _) = _executeScriptInternal(generator, litConfig, steps)\n        if exitCode != 0:\n            raise RuntimeError(f\"Error while trying to generate gen test\\nstdout:\\n{out}\\n\\nstderr:\\n{err}\")\n\n        # Split the generated output into multiple files and generate one test for each file\n        parsed = _parseLitOutput(out)\n        for (subfile, content) in self._splitFile(parsed):\n            generatedFile = testSuite.getExecPath(pathInSuite + (subfile, ))\n            os.makedirs(os.path.dirname(generatedFile), exist_ok=True)\n            with open(generatedFile, 'w') as f:\n                f.write(content)\n            yield lit.Test.Test(testSuite, (generatedFile,), localConfig)\n\n    def _splitFile(self, input):\n        DELIM = r'^(//|#)---(.+)'\n        lines = input.splitlines()\n        currentFile = None\n        thisFileContent = []\n        for line in lines:\n            match = re.match(DELIM, line)\n            if match:\n                if currentFile is not None:\n                    yield (currentFile, '\\n'.join(thisFileContent))\n                currentFile = match.group(2).strip()\n                thisFileContent = []\n            assert currentFile is not None, f\"Some input to split-file doesn't belong to any file, input was:\\n{input}\"\n            thisFileContent.append(line)\n        if currentFile is not None:\n            yield (currentFile, '\\n'.join(thisFileContent))\n"}}, "msg": "[lit] Improve test output from lit's internal shell\n\nThis patch and D154984 were discussed in\n<https://discourse.llvm.org/t/rfc-improving-lits-debug-output/72839>.\n\nMotivation\n----------\n\nD154984 removes the \"Script:\" section that lit prints along with a\ntest's output, and it makes -v and -a imply -vv.  For example, after\nD154984, the \"Script:\" section below is never shown, but -v is enough\nto produce the execution trace following it:\n\n```\n Script:\n --\n : 'RUN: at line 1'; echo hello | FileCheck bogus.txt && echo success\n --\n Exit Code: 2\n\n Command Output (stdout):\n --\n $ \":\" \"RUN: at line 1\"\n $ \"echo\" \"hello\"\n # command output:\n hello\n\n $ \"FileCheck\" \"bogus.txt\"\n # command stderr:\n Could not open check file 'bogus.txt': No such file or directory\n\n error: command failed with exit status: 2\n\n --\n```\n\nIn the D154984 review, some reviewers point out that they have been\nusing the \"Script:\" section for copying and pasting a test's shell\ncommands to a terminal window.  The shell commands as printed in the\nexecution trace can be harder to copy and paste for the following\nreasons:\n\n- They drop redirections and break apart RUN lines at `&&`, `|`, etc.\n- They add `$` at the start of every command, which makes it hard to\n  copy and paste multiple commands in bulk.\n- Command stdout, stderr, etc. are interleaved with the commands and\n  are not clearly delineated.\n- They don't always use proper shell quoting.  Instead, they blindly\n  enclose all command-line arguments in double quotes.\n\nChanges\n-------\n\nD154984 plus this patch converts the above example into:\n\n```\n Exit Code: 2\n\n Command Output (stdout):\n --\n # RUN: at line 1\n echo hello | FileCheck bogus-file.txt && echo success\n # executed command: echo hello\n # .---command stdout------------\n # | hello\n # `-----------------------------\n # executed command: FileCheck bogus-file.txt\n # .---command stderr------------\n # | Could not open check file 'bogus-file.txt': No such file or directory\n # `-----------------------------\n # error: command failed with exit status: 2\n\n --\n```\n\nThus, this patch addresses the above issues as follows:\n\n- The entire execution trace can be copied and pasted in bulk to a\n  terminal for correct execution of the RUN lines, which are printed\n  intact as they appeared in the original RUN lines except lit\n  substitutions are expanded.  Everything else in the execution trace\n  appears in shell comments so it has no effect in a terminal.\n- Each of the RUN line's commands is repeated (in shell comments) as\n  it executes to show (1) that the command actually executed (e.g.,\n  `echo success` above didn't) and (2) what stdout, stderr, non-zero\n  exit status, and output files are associated with the command, if\n  any.  Shell quoting in the command is now correct and minimal but is\n  not necessarily the original shell quoting from the RUN line.\n- The start and end of the contents of stdout, stderr, or an output\n  file is now delineated clearly in the trace.\n\nTo help produce some of the above output, this patch extends lit's\ninternal shell with a built-in `@echo` command.  It's like `echo`\nexcept lit suppresses the normal execution trace for `@echo` and just\nprints its stdout directly.  For now, `@echo` isn't documented for use\nin lit tests.\n\nWithout this patch, libcxx's custom lit test format tries to parse the\nstdout from `lit.TestRunner.executeScriptInternal` (which runs lit's\ninternal shell) to extract the stdout and stderr produced by shell\ncommands, and that parse no longer works after the above changes.\nThis patch makes a small adjustment to\n`lit.TestRunner.executeScriptInternal` so libcxx can just request\nstdout and stderr without an execution trace.\n\n(As a minor drive-by fix that came up in testing: lit's internal `not`\ncommand now always produces a numeric exit status and never `True`.)\n\nCaveat\n------\n\nThis patch only makes the above changes for lit's internal shell.  In\nmost cases, we do not know how to force external shells (e.g., bash,\nsh, window's `cmd`) to produce execution traces in the manner we want.\n\nTo configure a test suite to use lit's internal shell (which is\nusually better for test portability than external shells anyway), add\nthis to the test suite's `lit.cfg` or other configuration file:\n\n```\nconfig.test_format = lit.formats.ShTest(execute_external=False)\n```\n\nReviewed By: MaskRay, awarzynski\n\nDifferential Revision: https://reviews.llvm.org/D156954"}}}