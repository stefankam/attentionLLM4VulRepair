{"https://github.com/Special-K-s-Flightsim-Bots/DCSServerBot": {"86731e7b05e3c283f32291bcb72cebe83721f6e5": {"url": "https://api.github.com/repos/Special-K-s-Flightsim-Bots/DCSServerBot/commits/86731e7b05e3c283f32291bcb72cebe83721f6e5", "html_url": "https://github.com/Special-K-s-Flightsim-Bots/DCSServerBot/commit/86731e7b05e3c283f32291bcb72cebe83721f6e5", "sha": "86731e7b05e3c283f32291bcb72cebe83721f6e5", "keyword": "sql injection change", "diff": "diff --git a/core/services/base.py b/core/services/base.py\nindex 0103245db..04853a31d 100644\n--- a/core/services/base.py\n+++ b/core/services/base.py\n@@ -8,7 +8,6 @@\n from typing import TYPE_CHECKING, Optional, Callable, Any\n \n from ..const import DEFAULT_TAG\n-from ..utils.helper import YAMLError\n from ..data.dataobject import DataObject\n \n # ruamel YAML support\ndiff --git a/extensions/realweather.py b/extensions/realweather.py\nindex eff1ab31f..2dfb0bb87 100644\n--- a/extensions/realweather.py\n+++ b/extensions/realweather.py\n@@ -31,7 +31,8 @@ def get_config(self, filename: str) -> dict:\n         else:\n             return self.config\n \n-    def get_icao_code(self, filename: str) -> Optional[str]:\n+    @staticmethod\n+    def get_icao_code(filename: str) -> Optional[str]:\n         index = filename.find('ICAO_')\n         if index != -1:\n             return filename[index + 5:index + 9]\n@@ -62,7 +63,7 @@ async def beforeMissionLoad(self, filename: str) -> tuple[str, bool]:\n                     \"icao\": icao\n                 }\n             }\n-            self.config['metar'] = { \"icao\": icao }\n+            self.config['metar'] = {\"icao\": icao}\n         cwd = await self.server.get_missions_dir()\n         with open(os.path.join(cwd, 'config.json'), mode='w', encoding='utf-8') as outfile:\n             json.dump(cfg, outfile, indent=2)\ndiff --git a/plugins/admin/commands.py b/plugins/admin/commands.py\nindex 42faf541f..326b83f0d 100644\n--- a/plugins/admin/commands.py\n+++ b/plugins/admin/commands.py\n@@ -139,7 +139,7 @@ async def plugins_autocomplete(interaction: discord.Interaction, current: str) -\n     ]\n \n \n-async def get_branches(interaction: discord.Interaction, current: str) -> list[app_commands.Choice[str]]:\n+async def get_branches(interaction: discord.Interaction, _: str) -> list[app_commands.Choice[str]]:\n     current_branch, _ = await interaction.client.node.get_dcs_branch_and_version()\n     if 'dcs_server' not in current_branch:\n         branch = 'release'\n@@ -212,7 +212,7 @@ async def on_submit(derived, interaction: discord.Interaction):\n                         name = ucid\n                 else:\n                     # noinspection PyUnresolvedReferences\n-                    await interaction.response.send_message(_(\"{} is not a valid UCID!\", ephemeral=ephemeral))\n+                    await interaction.response.send_message(_(\"{} is not a valid UCID!\"), ephemeral=ephemeral)\n                     return\n                 await self.bus.ban(ucid, interaction.user.display_name, derived.reason.value, days)\n                 # noinspection PyUnresolvedReferences\n@@ -382,11 +382,11 @@ async def update(self, interaction: discord.Interaction,\n                 ephemeral=ephemeral)\n         elif new_version:\n             if not await utils.yn_question(interaction,\n-                                       _('Would you like to update from version {old_version}@{old_branch} to '\n-                                         '{new_version}@{new_branch}?\\nAll running DCS servers will be shut down!'\n-                                         ).format(old_version=old_version, old_branch=_branch, new_version=new_version,\n-                                                  new_branch=branch),\n-                                       ephemeral=ephemeral):\n+                                           _('Would you like to update from version {old_version}@{old_branch} to '\n+                                             '{new_version}@{new_branch}?\\nAll running DCS servers will be shut down!'\n+                                             ).format(old_version=old_version, old_branch=_branch,\n+                                                      new_version=new_version, new_branch=branch),\n+                                           ephemeral=ephemeral):\n                 await interaction.followup.send(_(\"Aborted.\"))\n                 return\n             await self.bot.audit(f\"started an update of all DCS servers on node {node.name}.\",\ndiff --git a/plugins/cloud/commands.py b/plugins/cloud/commands.py\nindex c1f0cf720..2f92db2f5 100644\n--- a/plugins/cloud/commands.py\n+++ b/plugins/cloud/commands.py\n@@ -130,7 +130,6 @@ async def status(self, interaction: discord.Interaction):\n         ephemeral = utils.get_ephemeral(interaction)\n         # noinspection PyUnresolvedReferences\n         await interaction.response.send_message(_('Checking cloud connection ...'), ephemeral=ephemeral)\n-        message = \"\"\n         try:\n             await self.get('discord-bans')\n             message = _('Cloud connection established.')\ndiff --git a/plugins/funkman/commands.py b/plugins/funkman/commands.py\nindex 12a0cabc6..311b166ac 100644\n--- a/plugins/funkman/commands.py\n+++ b/plugins/funkman/commands.py\n@@ -78,11 +78,11 @@ async def prune(self, conn: psycopg.AsyncConnection, *, days: int = -1, ucids: l\n                 await conn.execute('DELETE FROM strafe_runs WHERE player_ucid = %s', (ucid,))\n         elif days > -1:\n             await conn.execute(f\"\"\"\n-                DELETE FROM bomb_runs WHERE time < (DATE(now() AT TIME ZONE 'utc') - interval '{days} days')\n-            \"\"\")\n-            await conn.execute(f\"\"\"\n-                DELETE FROM strafe_runs WHERE time < (DATE(now() AT TIME ZONE 'utc') - interval '{days} days')\n-            \"\"\")\n+                DELETE FROM bomb_runs WHERE time < (DATE(now() AT TIME ZONE 'utc') - %s::interval)\n+            \"\"\", (f'{days} days', ))\n+            await conn.execute(\"\"\"\n+                DELETE FROM strafe_runs WHERE time < (DATE(now() AT TIME ZONE 'utc') - %s::interval)\n+            \"\"\", (f'{days} days', ))\n         self.log.debug('FunkMan pruned.')\n \n \ndiff --git a/plugins/gamemaster/commands.py b/plugins/gamemaster/commands.py\nindex e106ffb84..11008a99f 100644\n--- a/plugins/gamemaster/commands.py\n+++ b/plugins/gamemaster/commands.py\n@@ -57,8 +57,8 @@ async def prune(self, conn: psycopg.AsyncConnection, *, days: int = -1, ucids: l\n             for ucid in ucids:\n                 await conn.execute('DELETE FROM coalitions WHERE player_ucid = %s', (ucid, ))\n         if days > -1:\n-            await conn.execute(\n-                f\"DELETE FROM campaigns WHERE stop < (DATE(now() AT TIME ZONE 'utc') - interval '{days} days')\")\n+            await conn.execute(\"DELETE FROM campaigns WHERE stop < (DATE(now() AT TIME ZONE 'utc') - %s::interval)\",\n+                               (f'{days} days', ))\n         if server:\n             await conn.execute(\"DELETE FROM campaigns_servers WHERE server_name = %s\", (server, ))\n             await conn.execute(\"DELETE FROM coalitions WHERE server_name = %s\", (server, ))\ndiff --git a/plugins/greenieboard/commands.py b/plugins/greenieboard/commands.py\nindex 7da22f236..dc03b8672 100644\n--- a/plugins/greenieboard/commands.py\n+++ b/plugins/greenieboard/commands.py\n@@ -53,7 +53,7 @@ async def prune(self, conn: psycopg.AsyncConnection, *, days: int = -1, ucids: l\n             for ucid in ucids:\n                 await conn.execute('DELETE FROM greenieboard WHERE player_ucid = %s', (ucid,))\n         elif days > -1:\n-            await conn.execute(f\"DELETE FROM greenieboard WHERE time < (DATE(NOW()) - interval '{days} days')\")\n+            await conn.execute(\"DELETE FROM greenieboard WHERE time < (DATE(NOW()) - %s::interval)\", (f'{days} days', ))\n         self.log.debug('Greenieboard pruned.')\n \n     async def update_ucid(self, conn: psycopg.AsyncConnection, old_ucid: str, new_ucid: str) -> None:\ndiff --git a/plugins/missionstats/commands.py b/plugins/missionstats/commands.py\nindex e10df9233..2a1e14e67 100644\n--- a/plugins/missionstats/commands.py\n+++ b/plugins/missionstats/commands.py\n@@ -53,7 +53,7 @@ async def prune(self, conn: psycopg.AsyncConnection, *, days: int = -1, ucids: l\n             for ucid in ucids:\n                 await conn.execute('DELETE FROM missionstats WHERE init_id = %s', (ucid,))\n         elif days > -1:\n-            await conn.execute(f\"DELETE FROM missionstats WHERE time < (DATE(NOW()) - interval '{days} days')\")\n+            await conn.execute(\"DELETE FROM missionstats WHERE time < (DATE(NOW()) - %s::interval)\", (f'{days} days', ))\n         if server:\n             await conn.execute(\"\"\"\n                 DELETE FROM missionstats WHERE mission_id in (\ndiff --git a/plugins/punishment/db/tables.sql b/plugins/punishment/db/tables.sql\nindex ff9f9aa6a..11a391377 100644\n--- a/plugins/punishment/db/tables.sql\n+++ b/plugins/punishment/db/tables.sql\n@@ -1,4 +1,4 @@\n-CREATE TABLE IF NOT EXISTS pu_events (id SERIAL PRIMARY KEY, init_id TEXT NOT NULL, target_id TEXT, server_name TEXT NOT NULL, event TEXT NOT NULL, points DECIMAL NOT NULL, time TIMESTAMP NOT NULL DEFAULT timezone('utc', now()), decay_run INTEGER NOT NULL DEFAULT -1);\n+CREATE TABLE IF NOT EXISTS pu_events (id SERIAL PRIMARY KEY, init_id TEXT NOT NULL, target_id TEXT, server_name TEXT NOT NULL, event TEXT NOT NULL, points DECIMAL NOT NULL, time TIMESTAMP NOT NULL DEFAULT (now() AT TIME ZONE 'utc'), decay_run INTEGER NOT NULL DEFAULT -1);\n CREATE INDEX IF NOT EXISTS idx_pu_events_init_id ON pu_events(init_id);\n CREATE INDEX IF NOT EXISTS idx_pu_events_target_id ON pu_events(target_id);\n CREATE UNIQUE INDEX idx_pu_events_unique ON pu_events (init_id, COALESCE(target_id, '-1'), event, DATE_TRUNC('minute', time));\ndiff --git a/plugins/serverstats/commands.py b/plugins/serverstats/commands.py\nindex 5645b0201..37ecb5a1c 100644\n--- a/plugins/serverstats/commands.py\n+++ b/plugins/serverstats/commands.py\n@@ -59,7 +59,7 @@ async def serverload(self, interaction: discord.Interaction,\n                          period: Optional[Literal['Hour', 'Day', 'Week', 'Month']] = 'Hour'):\n         try:\n             if _server:\n-                await self.display_report(interaction, 'serverload.json', period, _server,\n+                await self.display_report(interaction, 'serverload.json', str(period), _server,\n                                           ephemeral=utils.get_ephemeral(interaction))\n             else:\n                 report = PaginationReport(self.bot, interaction, self.plugin_name, 'serverload.json')\ndiff --git a/plugins/userstats/commands.py b/plugins/userstats/commands.py\nindex fdf91cd77..4493320dc 100644\n--- a/plugins/userstats/commands.py\n+++ b/plugins/userstats/commands.py\n@@ -323,7 +323,7 @@ async def join(self, interaction: discord.Interaction, squadron_id: int):\n             async with interaction.client.apool.connection() as conn:\n                 async with conn.transaction():\n                     await conn.execute(\"INSERT INTO squadron_members (squadron_id, player_ucid) VALUES (%s, %s)\",\n-                                        (squadron_id, ucid))\n+                                       (squadron_id, ucid))\n                     cursor = await conn.execute(\"SELECT name, role FROM squadrons WHERE id = %s\", (squadron_id, ))\n                     row = await cursor.fetchone()\n                     if row:\ndiff --git a/services/backup/service.py b/services/backup/service.py\nindex 8516ef24b..adf93eb73 100644\n--- a/services/backup/service.py\n+++ b/services/backup/service.py\n@@ -47,7 +47,7 @@ def mkdir(self) -> str:\n         target = os.path.expandvars(self.locals.get('target'))\n         directory = os.path.join(target, utils.slugify(self.node.name) + '_' + datetime.now().strftime(\"%Y%m%d\"))\n         os.makedirs(directory, exist_ok=True)\n-        return directory\n+        return str(directory)\n \n     @staticmethod\n     def zip_path(zf: ZipFile, base: str, path: str):\ndiff --git a/services/scheduler/actions.py b/services/scheduler/actions.py\nindex 4153e519a..985eec760 100644\n--- a/services/scheduler/actions.py\n+++ b/services/scheduler/actions.py\n@@ -22,7 +22,7 @@ async def report(file: str, channel: int, node: Node, persistent: Optional[bool]\n         await bot.get_channel(channel).send(embed=env.embed)\n \n \n-async def restart(node: Node, server: Server, shutdown: Optional[bool] = False, rotate: Optional[bool] = False,\n+async def restart(_: Node, server: Server, shutdown: Optional[bool] = False, rotate: Optional[bool] = False,\n                   run_extensions: Optional[bool] = True):\n     if not server or server.status in [Status.SHUTDOWN, Status.UNREGISTERED]:\n         return\ndiff --git a/services/servicebus/service.py b/services/servicebus/service.py\nindex 9356c1ad3..1cc404db2 100644\n--- a/services/servicebus/service.py\n+++ b/services/servicebus/service.py\n@@ -316,7 +316,7 @@ def rename_server(self, server: Server, new_name: str):\n \n     async def ban(self, ucid: str, banned_by: str, reason: str = 'n/a', days: Optional[int] = None):\n         if days:\n-            until = datetime.utcnow() + timedelta(days=days)\n+            until = datetime.now(tz=timezone.utc) + timedelta(days=days)\n             until_str = until.strftime('%Y-%m-%d %H:%M') + ' (UTC)'\n         else:\n             until = datetime(year=9999, month=12, day=31)\n@@ -327,7 +327,7 @@ async def ban(self, ucid: str, banned_by: str, reason: str = 'n/a', days: Option\n                     INSERT INTO bans (ucid, banned_by, reason, banned_until) \n                     VALUES (%s, %s, %s, %s) \n                     ON CONFLICT DO NOTHING\n-                \"\"\", (ucid, banned_by, reason, until))\n+                \"\"\", (ucid, banned_by, reason, until.replace(tzinfo=None)))\n         for server in self.servers.values():\n             if server.status not in [Status.PAUSED, Status.RUNNING, Status.STOPPED]:\n                 continue\n", "message": "", "files": {"/core/services/base.py": {"changes": [{"diff": "\n from typing import TYPE_CHECKING, Optional, Callable, Any\n \n from ..const import DEFAULT_TAG\n-from ..utils.helper import YAMLError\n from ..data.dataobject import DataObject\n \n # ruamel YAML support", "add": 0, "remove": 1, "filename": "/core/services/base.py", "badparts": ["from ..utils.helper import YAMLError"], "goodparts": []}], "source": "\nfrom __future__ import annotations import os from abc import ABC from enum import Enum from functools import wraps from pathlib import Path from typing import TYPE_CHECKING, Optional, Callable, Any from..const import DEFAULT_TAG from..utils.helper import YAMLError from..data.dataobject import DataObject from ruamel.yaml import YAML from ruamel.yaml.error import MarkedYAMLError yaml=YAML() if TYPE_CHECKING: from core import Server, NodeImpl __all__=[ \"proxy\", \"Service\", \"ServiceInstallationError\" ] def proxy(original_function: Callable[..., Any]): \"\"\" Can be used as a decorator to any service method, that should act as a remote call, if the server provided is not on the same node. @proxy async def my_fancy_method(self, server: Server, *args, **kwargs) -> Any: ... This will call my_fancy_method on the remote node, if the server is remote, and on the local node, if it is not. \"\"\" @wraps(original_function) async def wrapper(self, server: Server, *args, **kwargs): arg_names=list(original_function.__annotations__.keys()) if hasattr(original_function, \"__annotations__\") else[] params={ k: v.name if isinstance(v, DataObject) else v.value if isinstance(v, Enum) else v for k, v in zip(arg_names[1:], args) if v is not None } if server.is_remote: data=await self.bus.send_to_node_sync({ \"command\": \"rpc\", \"service\": self.__class__.__name__, \"method\": original_function.__name__, \"params\":{\"server\": server.name} | params }, node=server.node.name) return data.get('return') return await original_function(self, server, *args, **kwargs) return wrapper class Service(ABC): def __init__(self, node: NodeImpl, name: Optional[str]=None): self.name=name or self.__class__.__name__ self.running: bool=False self.node: NodeImpl=node self.log=node.log self.pool=node.pool self.apool=node.apool self.config=node.config self.locals=self.read_locals() self._config=dict[str, dict]() async def start(self, *args, **kwargs): self.log.info(f' => Starting Service{self.name}...') self.running=True async def stop(self, *args, **kwargs): self.running=False self.log.info(f' => Service{self.name} stopped.') def is_running(self) -> bool: return self.running def read_locals(self) -> dict: filename=os.path.join(self.node.config_dir, 'services', f'{self.name.lower()}.yaml') if not os.path.exists(filename): return{} self.log.debug(f' -Reading service configuration from{filename}...') try: return yaml.load(Path(filename).read_text(encoding='utf-8')) except MarkedYAMLError as ex: raise ServiceInstallationError(self.name, ex.__str__()) def get_config(self, server: Optional[Server]=None) -> dict: if not server: return self.locals.get(DEFAULT_TAG,{}) if server.node.name not in self._config: self._config[server.node.name]={} if server.instance.name not in self._config[server.node.name]: self._config[server.node.name][server.instance.name]=( self.locals.get(DEFAULT_TAG,{}) | self.locals.get(server.node.name, self.locals).get(server.instance.name,{}) ) return self._config.get(server.node.name,{}).get(server.instance.name,{}) class ServiceInstallationError(Exception): def __init__(self, service: str, reason: str): super().__init__(f'Service \"{service.title()}\" could not be installed:{reason}') ", "sourceWithComments": "from __future__ import annotations\nimport os\n\nfrom abc import ABC\nfrom enum import Enum\nfrom functools import wraps\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Optional, Callable, Any\n\nfrom ..const import DEFAULT_TAG\nfrom ..utils.helper import YAMLError\nfrom ..data.dataobject import DataObject\n\n# ruamel YAML support\nfrom ruamel.yaml import YAML\nfrom ruamel.yaml.error import MarkedYAMLError\nyaml = YAML()\n\nif TYPE_CHECKING:\n    from core import Server, NodeImpl\n\n__all__ = [\n    \"proxy\",\n    \"Service\",\n    \"ServiceInstallationError\"\n]\n\n\ndef proxy(original_function: Callable[..., Any]):\n    \"\"\"\n    Can be used as a decorator to any service method, that should act as a remote call, if the server provided\n    is not on the same node.\n\n    @proxy\n    async def my_fancy_method(self, server: Server, *args, **kwargs) -> Any:\n        ...\n\n    This will call my_fancy_method on the remote node, if the server is remote, and on the local node, if it is not.\n    \"\"\"\n    @wraps(original_function)\n    async def wrapper(self, server: Server, *args, **kwargs):\n        # Get argument names from the original function\n        arg_names = list(original_function.__annotations__.keys()) if hasattr(original_function,\n                                                                              \"__annotations__\") else []\n\n        # Prepare params by dereferencing DataObject instances to their names,\n        # while matching argument names with values.\n        params = {\n            k: v.name if isinstance(v, DataObject)\n            else v.value if isinstance(v, Enum)\n            else v\n            for k, v in zip(arg_names[1:], args)\n            if v is not None\n        }\n\n        if server.is_remote:\n            data = await self.bus.send_to_node_sync({\n                \"command\": \"rpc\",\n                \"service\": self.__class__.__name__,\n                \"method\": original_function.__name__,\n                \"params\": {\"server\": server.name} | params\n            }, node=server.node.name)\n            return data.get('return')\n        return await original_function(self, server, *args, **kwargs)\n\n    return wrapper\n\n\nclass Service(ABC):\n    def __init__(self, node: NodeImpl, name: Optional[str] = None):\n        self.name = name or self.__class__.__name__\n        self.running: bool = False\n        self.node: NodeImpl = node\n        self.log = node.log\n        self.pool = node.pool\n        self.apool = node.apool\n        self.config = node.config\n        self.locals = self.read_locals()\n        self._config = dict[str, dict]()\n\n    async def start(self, *args, **kwargs):\n        self.log.info(f'  => Starting Service {self.name} ...')\n        self.running = True\n\n    async def stop(self, *args, **kwargs):\n        self.running = False\n        self.log.info(f'  => Service {self.name} stopped.')\n\n    def is_running(self) -> bool:\n        return self.running\n\n    def read_locals(self) -> dict:\n        filename = os.path.join(self.node.config_dir, 'services', f'{self.name.lower()}.yaml')\n        if not os.path.exists(filename):\n            return {}\n        self.log.debug(f'  - Reading service configuration from {filename} ...')\n        try:\n            return yaml.load(Path(filename).read_text(encoding='utf-8'))\n        except MarkedYAMLError as ex:\n            raise ServiceInstallationError(self.name, ex.__str__())\n\n    def get_config(self, server: Optional[Server] = None) -> dict:\n        if not server:\n            return self.locals.get(DEFAULT_TAG, {})\n        if server.node.name not in self._config:\n            self._config[server.node.name] = {}\n        if server.instance.name not in self._config[server.node.name]:\n            self._config[server.node.name][server.instance.name] = (\n                    self.locals.get(DEFAULT_TAG, {}) |\n                    self.locals.get(server.node.name, self.locals).get(server.instance.name, {})\n            )\n        return self._config.get(server.node.name, {}).get(server.instance.name, {})\n\n\nclass ServiceInstallationError(Exception):\n    def __init__(self, service: str, reason: str):\n        super().__init__(f'Service \"{service.title()}\" could not be installed: {reason}')\n"}, "/extensions/realweather.py": {"changes": [{"diff": "\n         else:\n             return self.config\n \n-    def get_icao_code(self, filename: str) -> Optional[str]:\n+    @staticmethod\n+    def get_icao_code(filename: str) -> Optional[str]:\n         index = filename.find('ICAO_')\n         if index != -1:\n             return filename[index + 5:index + 9]\n", "add": 2, "remove": 1, "filename": "/extensions/realweather.py", "badparts": ["    def get_icao_code(self, filename: str) -> Optional[str]:"], "goodparts": ["    @staticmethod", "    def get_icao_code(filename: str) -> Optional[str]:"]}, {"diff": "\n                     \"icao\": icao\n                 }\n             }\n-            self.config['metar'] = { \"icao\": icao }\n+            self.config['metar'] = {\"icao\": icao}\n         cwd = await self.server.get_missions_dir()\n         with open(os.path.join(cwd, 'config.json'), mode='w', encoding='utf-8') as outfile:\n             json.dump(cfg, outfile, indent=2", "add": 1, "remove": 1, "filename": "/extensions/realweather.py", "badparts": ["            self.config['metar'] = { \"icao\": icao }"], "goodparts": ["            self.config['metar'] = {\"icao\": icao}"]}], "source": "\nimport asyncio import json import os import shutil import subprocess import tempfile from core import Extension, MizFile, utils, DEFAULT_TAG, Server from typing import Optional class RealWeatherException(Exception): pass class RealWeather(Extension): def __init__(self, server: Server, config: dict): super().__init__(server, config) self.lock=asyncio.Lock() @property def version(self) -> Optional[str]: return utils.get_windows_version(os.path.join(os.path.expandvars(self.config['installation']), 'realweather.exe')) def get_config(self, filename: str) -> dict: if 'terrains' in self.config: miz=MizFile(self.node, filename) return self.config['terrains'].get(miz.theatre, self.config['terrains'].get(DEFAULT_TAG,{})) else: return self.config def get_icao_code(self, filename: str) -> Optional[str]: index=filename.find('ICAO_') if index !=-1: return filename[index +5:index +9] else: return None async def beforeMissionLoad(self, filename: str) -> tuple[str, bool]: rw_home=os.path.expandvars(self.config['installation']) tmpfd, tmpname=tempfile.mkstemp() os.close(tmpfd) with open(os.path.join(rw_home, 'config.json'), mode='r', encoding='utf-8') as infile: cfg=json.load(infile) config=self.get_config(filename) for name, element in cfg.items(): if name=='files': element['input-mission']=filename element['output-mission']=tmpname elif name in config: if isinstance(config[name], dict): element |=config[name] else: cfg[name]=config[name] icao=self.get_icao_code(filename) if icao and icao !=self.config.get('metar',{}).get('icao'): cfg |={ \"metar\":{ \"icao\": icao } } self.config['metar']={ \"icao\": icao} cwd=await self.server.get_missions_dir() with open(os.path.join(cwd, 'config.json'), mode='w', encoding='utf-8') as outfile: json.dump(cfg, outfile, indent=2) def run_subprocess(): out=subprocess.DEVNULL if not self.config.get('debug', False) else None subprocess.check_call([os.path.join(rw_home, 'realweather.exe')], stdout=out, stderr=out, cwd=cwd) try: async with self.lock: await asyncio.to_thread(run_subprocess) except subprocess.CalledProcessError: raise RealWeatherException(f\"Error in RealWeather. Enable debug in your extension to see more.\") await asyncio.to_thread(MizFile, self, tmpname) new_filename=utils.create_writable_mission(filename) shutil.copy2(tmpname, new_filename) os.remove(tmpname) return new_filename, True async def render(self, param: Optional[dict]=None) -> dict: icao=self.config.get('metar',{}).get('icao') if icao: value=f'Metar:{icao}' else: value='enabled' return{ \"name\": \"RealWeather\", \"version\": self.version, \"value\": value } def is_installed(self) -> bool: if not self.config.get('enabled', True): return False installation=self.config.get('installation') if not installation: self.log.error(\"No 'installation' specified for RealWeather in your nodes.yaml!\") return False rw_home=os.path.expandvars(installation) if not os.path.exists(os.path.join(rw_home, 'realweather.exe')): self.log.error(f'No realweather.exe found in{rw_home}') return False if self.version: ver=[int(x) for x in self.version.split('.')] if ver[0]==1 and ver[1] < 9: self.log.error(\"DCS Realweather < 1.9.x not supported, please upgrade!\") return False else: self.log.error(\"DCS Realweather < 1.9.x not supported, please upgrade!\") return False if not os.path.exists(os.path.join(rw_home, 'config.json')): self.log.error(f'No config.json found in{rw_home}') return False return True def shutdown(self) -> bool: return True def is_running(self) -> bool: return True ", "sourceWithComments": "import asyncio\nimport json\nimport os\nimport shutil\nimport subprocess\nimport tempfile\n\nfrom core import Extension, MizFile, utils, DEFAULT_TAG, Server\nfrom typing import Optional\n\n\nclass RealWeatherException(Exception):\n    pass\n\n\nclass RealWeather(Extension):\n\n    def __init__(self, server: Server, config: dict):\n        super().__init__(server, config)\n        self.lock = asyncio.Lock()\n\n    @property\n    def version(self) -> Optional[str]:\n        return utils.get_windows_version(os.path.join(os.path.expandvars(self.config['installation']),\n                                                      'realweather.exe'))\n\n    def get_config(self, filename: str) -> dict:\n        if 'terrains' in self.config:\n            miz = MizFile(self.node, filename)\n            return self.config['terrains'].get(miz.theatre, self.config['terrains'].get(DEFAULT_TAG, {}))\n        else:\n            return self.config\n\n    def get_icao_code(self, filename: str) -> Optional[str]:\n        index = filename.find('ICAO_')\n        if index != -1:\n            return filename[index + 5:index + 9]\n        else:\n            return None\n\n    async def beforeMissionLoad(self, filename: str) -> tuple[str, bool]:\n        rw_home = os.path.expandvars(self.config['installation'])\n        tmpfd, tmpname = tempfile.mkstemp()\n        os.close(tmpfd)\n        with open(os.path.join(rw_home, 'config.json'), mode='r', encoding='utf-8') as infile:\n            cfg = json.load(infile)\n        config = self.get_config(filename)\n        # create proper configuration\n        for name, element in cfg.items():\n            if name == 'files':\n                element['input-mission'] = filename\n                element['output-mission'] = tmpname\n            elif name in config:\n                if isinstance(config[name], dict):\n                    element |= config[name]\n                else:\n                    cfg[name] = config[name]\n        icao = self.get_icao_code(filename)\n        if icao and icao != self.config.get('metar', {}).get('icao'):\n            cfg |= {\n                \"metar\": {\n                    \"icao\": icao\n                }\n            }\n            self.config['metar'] = { \"icao\": icao }\n        cwd = await self.server.get_missions_dir()\n        with open(os.path.join(cwd, 'config.json'), mode='w', encoding='utf-8') as outfile:\n            json.dump(cfg, outfile, indent=2)\n\n        def run_subprocess():\n            out = subprocess.DEVNULL if not self.config.get('debug', False) else None\n            subprocess.check_call([os.path.join(rw_home, 'realweather.exe')], stdout=out, stderr=out, cwd=cwd)\n\n        try:\n            async with self.lock:\n                await asyncio.to_thread(run_subprocess)\n        except subprocess.CalledProcessError:\n            raise RealWeatherException(f\"Error in RealWeather. Enable debug in your extension to see more.\")\n\n        # check if DCS Real Weather corrupted the miz file\n        # (as the original author does not see any reason to do that on his own)\n        await asyncio.to_thread(MizFile, self, tmpname)\n        # mission is good, take it\n        new_filename = utils.create_writable_mission(filename)\n        shutil.copy2(tmpname, new_filename)\n        os.remove(tmpname)\n        return new_filename, True\n\n    async def render(self, param: Optional[dict] = None) -> dict:\n        icao = self.config.get('metar', {}).get('icao')\n        if icao:\n            value = f'Metar: {icao}'\n        else:\n            value = 'enabled'\n        return {\n            \"name\": \"RealWeather\",\n            \"version\": self.version,\n            \"value\": value\n        }\n\n    def is_installed(self) -> bool:\n        if not self.config.get('enabled', True):\n            return False\n        installation = self.config.get('installation')\n        if not installation:\n            self.log.error(\"No 'installation' specified for RealWeather in your nodes.yaml!\")\n            return False\n        rw_home = os.path.expandvars(installation)\n        if not os.path.exists(os.path.join(rw_home, 'realweather.exe')):\n            self.log.error(f'No realweather.exe found in {rw_home}')\n            return False\n        if self.version:\n            ver = [int(x) for x in self.version.split('.')]\n            if ver[0] == 1 and ver[1] < 9:\n                self.log.error(\"DCS Realweather < 1.9.x not supported, please upgrade!\")\n                return False\n        else:\n            self.log.error(\"DCS Realweather < 1.9.x not supported, please upgrade!\")\n            return False\n        if not os.path.exists(os.path.join(rw_home, 'config.json')):\n            self.log.error(f'No config.json found in {rw_home}')\n            return False\n        return True\n\n    def shutdown(self) -> bool:\n        return True\n\n    def is_running(self) -> bool:\n        return True\n"}, "/plugins/admin/commands.py": {"changes": [{"diff": "\n     ]\n \n \n-async def get_branches(interaction: discord.Interaction, current: str) -> list[app_commands.Choice[str]]:\n+async def get_branches(interaction: discord.Interaction, _: str) -> list[app_commands.Choice[str]]:\n     current_branch, _ = await interaction.client.node.get_dcs_branch_and_version()\n     if 'dcs_server' not in current_branch:\n         branch = 'release'\n", "add": 1, "remove": 1, "filename": "/plugins/admin/commands.py", "badparts": ["async def get_branches(interaction: discord.Interaction, current: str) -> list[app_commands.Choice[str]]:"], "goodparts": ["async def get_branches(interaction: discord.Interaction, _: str) -> list[app_commands.Choice[str]]:"]}, {"diff": "\n                         name = ucid\n                 else:\n                     # noinspection PyUnresolvedReferences\n-                    await interaction.response.send_message(_(\"{} is not a valid UCID!\", ephemeral=ephemeral))\n+                    await interaction.response.send_message(_(\"{} is not a valid UCID!\"), ephemeral=ephemeral)\n                     return\n                 await self.bus.ban(ucid, interaction.user.display_name, derived.reason.value, days)\n                 # noinspection PyUnresolvedReferences\n", "add": 1, "remove": 1, "filename": "/plugins/admin/commands.py", "badparts": ["                    await interaction.response.send_message(_(\"{} is not a valid UCID!\", ephemeral=ephemeral))"], "goodparts": ["                    await interaction.response.send_message(_(\"{} is not a valid UCID!\"), ephemeral=ephemeral)"]}, {"diff": "\n                 ephemeral=ephemeral)\n         elif new_version:\n             if not await utils.yn_question(interaction,\n-                                       _('Would you like to update from version {old_version}@{old_branch} to '\n-                                         '{new_version}@{new_branch}?\\nAll running DCS servers will be shut down!'\n-                                         ).format(old_version=old_version, old_branch=_branch, new_version=new_version,\n-                                                  new_branch=branch),\n-                                       ephemeral=ephemeral):\n+                                           _('Would you like to update from version {old_version}@{old_branch} to '\n+                                             '{new_version}@{new_branch}?\\nAll running DCS servers will be shut down!'\n+                                             ).format(old_version=old_version, old_branch=_branch,\n+                                                      new_version=new_version, new_branch=branch),\n+                                           ephemeral=ephemeral):\n                 await interaction.followup.send(_(\"Aborted.\"))\n                 return\n             await self.bot.audit(f\"started an update of all DCS servers on node {node.name}.", "add": 5, "remove": 5, "filename": "/plugins/admin/commands.py", "badparts": ["                                       _('Would you like to update from version {old_version}@{old_branch} to '", "                                         '{new_version}@{new_branch}?\\nAll running DCS servers will be shut down!'", "                                         ).format(old_version=old_version, old_branch=_branch, new_version=new_version,", "                                                  new_branch=branch),", "                                       ephemeral=ephemeral):"], "goodparts": ["                                           _('Would you like to update from version {old_version}@{old_branch} to '", "                                             '{new_version}@{new_branch}?\\nAll running DCS servers will be shut down!'", "                                             ).format(old_version=old_version, old_branch=_branch,", "                                                      new_version=new_version, new_branch=branch),", "                                           ephemeral=ephemeral):"]}]}, "/plugins/cloud/commands.py": {"changes": [{"diff": "\n         ephemeral = utils.get_ephemeral(interaction)\n         # noinspection PyUnresolvedReferences\n         await interaction.response.send_message(_('Checking cloud connection ...'), ephemeral=ephemeral)\n-        message = \"\"\n         try:\n             await self.get('discord-bans')\n             message = _('Cloud connection established", "add": 0, "remove": 1, "filename": "/plugins/cloud/commands.py", "badparts": ["        message = \"\""], "goodparts": []}], "source": "\nimport aiohttp import asyncio import certifi import discord import os import pandas as pd import platform import psycopg import shutil import ssl from contextlib import suppress from core import Plugin, utils, TEventListener, PaginationReport, Group, DEFAULT_TAG, PluginConfigurationError, \\ get_translation from discord import app_commands from discord.ext import commands, tasks from psycopg.rows import dict_row from typing import Type, Any, Optional, Union from services import DCSServerBot from.listener import CloudListener from.logger import CloudLoggingHandler _=get_translation(__name__.split('.')[1]) class CloudHandler(Plugin): def __init__(self, bot: DCSServerBot, eventlistener: Type[TEventListener]=None): super().__init__(bot, eventlistener) if not len(self.locals): raise commands.ExtensionFailed(self.plugin_name, FileNotFoundError(\"No cloud.yaml available.\")) self.config=self.get_config() if not self.config: raise PluginConfigurationError(plugin=self.plugin_name, option=DEFAULT_TAG) self.base_url=f\"{self.config['protocol']}://{self.config['host']}:{self.config['port']}\" self._session=None self.client=None if self.config.get('dcs-ban', False) or self.config.get('discord-ban', False): self.cloud_bans.add_exception_type(IndexError) self.cloud_bans.add_exception_type(aiohttp.ClientError) self.cloud_bans.add_exception_type(discord.Forbidden) self.cloud_bans.add_exception_type(psycopg.DatabaseError) self.cloud_bans.start() if 'token' in self.config: self.cloud_sync.add_exception_type(IndexError) self.cloud_sync.add_exception_type(aiohttp.ClientError) self.cloud_sync.add_exception_type(psycopg.DatabaseError) self.cloud_sync.start() if self.config.get('register', True): self.register.start() @property def session(self): if not self._session: headers={ \"Content-type\": \"application/json\" } if 'token' in self.config: headers['Authorization']=f\"Bearer{self.config['token']}\" self.client={ \"guild_id\": self.bot.guilds[0].id, \"guild_name\": self.bot.guilds[0].name, \"owner_id\": self.bot.owner_id } self._session=aiohttp.ClientSession( connector=aiohttp.TCPConnector(ssl=ssl.create_default_context(cafile=certifi.where())), raise_for_status=True, headers=headers ) return self._session async def cog_load(self): await super().cog_load() if self.config.get('upload_errors', True): cloud_logger=CloudLoggingHandler(node=self.node, url=self.base_url +'/errors/') self.log.addHandler(cloud_logger) async def cog_unload(self) -> None: if self.config.get('register', True): self.register.cancel() if self.config.get('upload_errors', True): for handler in self.log.handlers: if isinstance(handler, CloudLoggingHandler): self.log.removeHandler(handler) if 'token' in self.config: self.cloud_sync.cancel() if self.config.get('dcs-ban', False) or self.config.get('discord-ban', False): self.cloud_bans.cancel() asyncio.create_task(self.session.close()) await super().cog_unload() def read_locals(self) -> dict: config=super().read_locals() if not config: self.log.info('No cloud.yaml found, copying the sample.') shutil.copyfile('samples/plugins/cloud.yaml', os.path.join(self.node.config_dir, 'plugins', 'cloud.yaml')) config=super().read_locals() return config async def get(self, request: str) -> Any: url=f\"{self.base_url}/{request}\" async with self.session.get(url) as response: return await response.json() async def post(self, request: str, data: Any) -> Any: async def send(element: dict): url=f\"{self.base_url}/{request}/\" async with self.session.post(url, json=element) as response: return await response.json() if isinstance(data, list): for line in data: await send(line) else: await send(data) async def update_ucid(self, conn: psycopg.AsyncConnection, old_ucid: str, new_ucid: str) -> None: with suppress(Exception): await self.post('update_ucid',{\"old_ucid\": old_ucid, \"new_ucid\": new_ucid}) cloud=Group(name=\"cloud\", description=\"Commands to manage the DCSSB Cloud Service\") @cloud.command(description=_('Test the cloud-connection')) @app_commands.guild_only() @utils.app_has_role('Admin') async def status(self, interaction: discord.Interaction): ephemeral=utils.get_ephemeral(interaction) await interaction.response.send_message(_('Checking cloud connection...'), ephemeral=ephemeral) message=\"\" try: await self.get('discord-bans') message=_('Cloud connection established.') if 'token' in self.config: try: await self.get('verify') message +=_('\\nCloud TOKEN configured and valid.') except aiohttp.ClientError: message +=_('\\nCloud TOKEN configured, but invalid!') else: message +=_(\"\\nGet a cloud TOKEN, if you want to use cloud statistics!\") await interaction.followup.send(message, ephemeral=ephemeral) except aiohttp.ClientError: await interaction.followup.send(_('Cloud not connected!'), ephemeral=ephemeral) finally: await interaction.delete_original_response() @cloud.command(description=_('Resync statistics with the cloud')) @app_commands.guild_only() @utils.app_has_role('DCS Admin') @app_commands.rename(member=\"user\") async def resync(self, interaction: discord.Interaction, member: Optional[app_commands.Transform[ Union[discord.Member, str], utils.UserTransformer]]=None): ephemeral=utils.get_ephemeral(interaction) if 'token' not in self.config: await interaction.response.send_message(_('No cloud sync configured!'), ephemeral=ephemeral) return async with self.apool.connection() as conn: async with conn.transaction(): sql='UPDATE players SET synced=false' if member: if isinstance(member, str): sql +=' WHERE ucid=%s' else: sql +=' WHERE discord_id=%s' member=member.id await conn.execute(sql,(member,)) else: await conn.execute(sql) await interaction.response.send_message(_('Resync with cloud triggered.'), ephemeral=ephemeral) @cloud.command(description=_('Generate Cloud Statistics')) @app_commands.guild_only() @utils.app_has_role('DCS') async def statistics(self, interaction: discord.Interaction, user: Optional[app_commands.Transform[Union[discord.Member, str], utils.UserTransformer]]): if 'token' not in self.config: await interaction.response.send_message(_('Cloud statistics are not activated in this Discord!'), ephemeral=True) return if not user: user=interaction.user if isinstance(user, discord.Member): ucid=await self.bot.get_ucid_by_member(user) if not ucid: await interaction.response.send_message(_(\"Use{} to link your account.\").format( (await utils.get_command(self.bot, name='linkme')).mention ), ephemeral=True) return name=user.display_name else: ucid=user name=await self.bot.get_member_or_name_by_ucid(ucid) if isinstance(name, discord.Member): name=name.display_name await interaction.response.defer() try: response=await self.get(f'stats/{ucid}') if not len(response): await interaction.followup.send(_('No cloud-based statistics found for this user.'), ephemeral=True) return df=pd.DataFrame(response) report=PaginationReport(self.bot, interaction, self.plugin_name, 'cloudstats.json') await report.render(user=name, data=df, guild=None) except aiohttp.ClientError: await interaction.followup.send(_('Cloud not connected!'), ephemeral=True) @tasks.loop(minutes=15.0) async def cloud_bans(self): if self.config.get('dcs-ban', False): self_bans: set={x['ucid'] for x in await self.bus.bans() if x['banned_by']==self.plugin_name} external_bans: set={ban['ucid'] for ban in await self.get('bans')} for ucid in external_bans -self_bans: reason=next(ban['reason'] for ban in await self.get('bans') if ban['ucid']==ucid) await self.bus.ban(ucid=ucid, reason='DGSA: ' +reason, banned_by=self.plugin_name) for ucid in self_bans -external_bans: await self.bus.unban(ucid) if self.config.get('discord-ban', False): bans: dict=await self.get('discord-bans') users_to_ban={await self.bot.fetch_user(x['discord_id']) for x in bans} guild=self.bot.guilds[0] guild_bans=[entry async for entry in guild.bans()] banned_users={x.user for x in guild_bans if x.reason and x.reason.startswith('DGSA:')} for user in banned_users -users_to_ban: await guild.unban(user, reason='DGSA: ban revoked.') for user in users_to_ban -banned_users -{self.bot.owner_id}: reason=next(x['reason'] for x in bans if x['discord_id']==user.id) await guild.ban(user, reason='DGSA: ' +reason) @tasks.loop(seconds=10) async def cloud_sync(self): async with self.apool.connection() as conn: cursor=await conn.execute(\"\"\" SELECT ucid FROM players WHERE synced IS FALSE ORDER BY last_seen DESC LIMIT 10 \"\"\") rows=await cursor.fetchall() for row in rows: async with self.apool.connection() as conn: async with conn.transaction(): async with conn.cursor(row_factory=dict_row) as cursor: await cursor.execute(\"\"\" SELECT s.player_ucid, m.mission_theatre, s.slot, SUM(s.kills) as kills, SUM(s.pvp) as pvp, SUM(deaths) as deaths, SUM(ejections) as ejections, SUM(crashes) as crashes, SUM(teamkills) as teamkills, SUM(kills_planes) AS kills_planes, SUM(kills_helicopters) AS kills_helicopters, SUM(kills_ships) AS kills_ships, SUM(kills_sams) AS kills_sams, SUM(kills_ground) AS kills_ground, SUM(deaths_pvp) as deaths_pvp, SUM(deaths_planes) AS deaths_planes, SUM(deaths_helicopters) AS deaths_helicopters, SUM(deaths_ships) AS deaths_ships, SUM(deaths_sams) AS deaths_sams, SUM(deaths_ground) AS deaths_ground, SUM(takeoffs) as takeoffs, SUM(landings) as landings, ROUND(SUM(EXTRACT(EPOCH FROM(s.hop_off -s.hop_on))))::BIGINT AS playtime FROM statistics s, missions m WHERE s.player_ucid=%s AND s.hop_off IS NOT null AND s.mission_id=m.id GROUP BY 1, 2, 3 \"\"\",(row[0],)) async for line in cursor: try: line['client']=self.client await self.post('upload', line) except TypeError as ex: self.log.warning(f\"Could not replicate user{row[0]}:{ex}\") await cursor.execute('UPDATE players SET synced=TRUE WHERE ucid=%s',(row[0],)) @tasks.loop(hours=1) async def register(self): async with self.apool.connection() as conn: async with conn.cursor() as cursor: await cursor.execute(\"\"\" SELECT count(distinct node) as num_bots, count(distinct instance) as num_servers FROM instances WHERE last_seen >(DATE(now() AT TIME ZONE 'utc') -interval '1 week') \"\"\") if cursor.rowcount==0: num_bots=num_servers=0 else: row=await cursor.fetchone() num_bots=row[0] num_servers=row[1] try: _, dcs_version=await self.node.get_dcs_branch_and_version() bot={ \"guild_id\": self.bot.guilds[0].id, \"bot_version\": f\"{self.bot.version}.{self.bot.sub_version}\", \"variant\": \"DCSServerBot\", \"dcs_version\": dcs_version, \"python_version\": '.'.join(platform.python_version_tuple()), \"num_bots\": num_bots, \"num_servers\": num_servers, \"plugins\":[ { \"name\": p.plugin_name, \"version\": p.plugin_version } for p in self.bot.cogs.values() ] } self.log.debug(\"Updating registration with this data: \" +str(bot)) await self.post('register', bot) except aiohttp.ClientError: self.log.debug('Cloud: Bot could not register due to service unavailability. Ignored.') except Exception: self.log.debug(\"Error while registering: \", exc_info=True) @register.before_loop async def before_register(self): await self.bot.wait_until_ready() async def setup(bot: DCSServerBot): await bot.add_cog(CloudHandler(bot, CloudListener)) ", "sourceWithComments": "import aiohttp\nimport asyncio\nimport certifi\nimport discord\nimport os\nimport pandas as pd\nimport platform\nimport psycopg\nimport shutil\nimport ssl\n\nfrom contextlib import suppress\nfrom core import Plugin, utils, TEventListener, PaginationReport, Group, DEFAULT_TAG, PluginConfigurationError, \\\n    get_translation\nfrom discord import app_commands\nfrom discord.ext import commands, tasks\nfrom psycopg.rows import dict_row\nfrom typing import Type, Any, Optional, Union\n\nfrom services import DCSServerBot\nfrom .listener import CloudListener\nfrom .logger import CloudLoggingHandler\n\n_ = get_translation(__name__.split('.')[1])\n\n\nclass CloudHandler(Plugin):\n\n    def __init__(self, bot: DCSServerBot, eventlistener: Type[TEventListener] = None):\n        super().__init__(bot, eventlistener)\n        if not len(self.locals):\n            raise commands.ExtensionFailed(self.plugin_name, FileNotFoundError(\"No cloud.yaml available.\"))\n        self.config = self.get_config()\n        if not self.config:\n            raise PluginConfigurationError(plugin=self.plugin_name, option=DEFAULT_TAG)\n        self.base_url = f\"{self.config['protocol']}://{self.config['host']}:{self.config['port']}\"\n        self._session = None\n        self.client = None\n        if self.config.get('dcs-ban', False) or self.config.get('discord-ban', False):\n            self.cloud_bans.add_exception_type(IndexError)\n            self.cloud_bans.add_exception_type(aiohttp.ClientError)\n            self.cloud_bans.add_exception_type(discord.Forbidden)\n            self.cloud_bans.add_exception_type(psycopg.DatabaseError)\n            self.cloud_bans.start()\n        if 'token' in self.config:\n            self.cloud_sync.add_exception_type(IndexError)\n            self.cloud_sync.add_exception_type(aiohttp.ClientError)\n            self.cloud_sync.add_exception_type(psycopg.DatabaseError)\n            self.cloud_sync.start()\n        if self.config.get('register', True):\n            self.register.start()\n\n    @property\n    def session(self):\n        if not self._session:\n            headers = {\n                \"Content-type\": \"application/json\"\n            }\n            if 'token' in self.config:\n                headers['Authorization'] = f\"Bearer {self.config['token']}\"\n            self.client = {\n                \"guild_id\": self.bot.guilds[0].id,\n                \"guild_name\": self.bot.guilds[0].name,\n                \"owner_id\": self.bot.owner_id\n            }\n            self._session = aiohttp.ClientSession(\n                connector=aiohttp.TCPConnector(ssl=ssl.create_default_context(cafile=certifi.where())),\n                raise_for_status=True, headers=headers\n            )\n        return self._session\n\n    async def cog_load(self):\n        await super().cog_load()\n        if self.config.get('upload_errors', True):\n            cloud_logger = CloudLoggingHandler(node=self.node, url=self.base_url + '/errors/')\n            self.log.addHandler(cloud_logger)\n\n    async def cog_unload(self) -> None:\n        if self.config.get('register', True):\n            self.register.cancel()\n        if self.config.get('upload_errors', True):\n            for handler in self.log.handlers:\n                if isinstance(handler, CloudLoggingHandler):\n                    self.log.removeHandler(handler)\n        if 'token' in self.config:\n            self.cloud_sync.cancel()\n        if self.config.get('dcs-ban', False) or self.config.get('discord-ban', False):\n            self.cloud_bans.cancel()\n        # noinspection PyAsyncCall\n        asyncio.create_task(self.session.close())\n        await super().cog_unload()\n\n    def read_locals(self) -> dict:\n        config = super().read_locals()\n        if not config:\n            self.log.info('No cloud.yaml found, copying the sample.')\n            shutil.copyfile('samples/plugins/cloud.yaml', os.path.join(self.node.config_dir, 'plugins', 'cloud.yaml'))\n            config = super().read_locals()\n        return config\n\n    async def get(self, request: str) -> Any:\n        url = f\"{self.base_url}/{request}\"\n        async with self.session.get(url) as response:  # type: aiohttp.ClientResponse\n            return await response.json()\n\n    async def post(self, request: str, data: Any) -> Any:\n        async def send(element: dict):\n            url = f\"{self.base_url}/{request}/\"\n            async with self.session.post(url, json=element) as response:  # type: aiohttp.ClientResponse\n                return await response.json()\n\n        if isinstance(data, list):\n            for line in data:\n                await send(line)\n        else:\n            await send(data)\n\n    async def update_ucid(self, conn: psycopg.AsyncConnection, old_ucid: str, new_ucid: str) -> None:\n        # we must not fail due to a cloud unavailability\n        with suppress(Exception):\n            await self.post('update_ucid', {\"old_ucid\": old_ucid, \"new_ucid\": new_ucid})\n\n    # New command group \"/cloud\"\n    cloud = Group(name=\"cloud\", description=\"Commands to manage the DCSSB Cloud Service\")\n\n    @cloud.command(description=_('Test the cloud-connection'))\n    @app_commands.guild_only()\n    @utils.app_has_role('Admin')\n    async def status(self, interaction: discord.Interaction):\n        ephemeral = utils.get_ephemeral(interaction)\n        # noinspection PyUnresolvedReferences\n        await interaction.response.send_message(_('Checking cloud connection ...'), ephemeral=ephemeral)\n        message = \"\"\n        try:\n            await self.get('discord-bans')\n            message = _('Cloud connection established.')\n            if 'token' in self.config:\n                try:\n                    await self.get('verify')\n                    message += _('\\nCloud TOKEN configured and valid.')\n                except aiohttp.ClientError:\n                    message += _('\\nCloud TOKEN configured, but invalid!')\n            else:\n                message += _(\"\\nGet a cloud TOKEN, if you want to use cloud statistics!\")\n            await interaction.followup.send(message, ephemeral=ephemeral)\n        except aiohttp.ClientError:\n            await interaction.followup.send(_('Cloud not connected!'), ephemeral=ephemeral)\n        finally:\n            await interaction.delete_original_response()\n\n    @cloud.command(description=_('Resync statistics with the cloud'))\n    @app_commands.guild_only()\n    @utils.app_has_role('DCS Admin')\n    @app_commands.rename(member=\"user\")\n    async def resync(self, interaction: discord.Interaction,\n                     member: Optional[app_commands.Transform[\n                         Union[discord.Member, str], utils.UserTransformer]] = None):\n        ephemeral = utils.get_ephemeral(interaction)\n        if 'token' not in self.config:\n            # noinspection PyUnresolvedReferences\n            await interaction.response.send_message(_('No cloud sync configured!'), ephemeral=ephemeral)\n            return\n        async with self.apool.connection() as conn:\n            async with conn.transaction():\n                sql = 'UPDATE players SET synced = false'\n                if member:\n                    if isinstance(member, str):\n                        sql += ' WHERE ucid = %s'\n                    else:\n                        sql += ' WHERE discord_id = %s'\n                        member = member.id\n                    await conn.execute(sql, (member, ))\n                else:\n                    await conn.execute(sql)\n        # noinspection PyUnresolvedReferences\n        await interaction.response.send_message(_('Resync with cloud triggered.'), ephemeral=ephemeral)\n\n    @cloud.command(description=_('Generate Cloud Statistics'))\n    @app_commands.guild_only()\n    @utils.app_has_role('DCS')\n    async def statistics(self, interaction: discord.Interaction,\n                         user: Optional[app_commands.Transform[Union[discord.Member, str], utils.UserTransformer]]):\n        if 'token' not in self.config:\n            # noinspection PyUnresolvedReferences\n            await interaction.response.send_message(_('Cloud statistics are not activated in this Discord!'),\n                                                    ephemeral=True)\n            return\n        if not user:\n            user = interaction.user\n        if isinstance(user, discord.Member):\n            ucid = await self.bot.get_ucid_by_member(user)\n            if not ucid:\n                # noinspection PyUnresolvedReferences\n                await interaction.response.send_message(_(\"Use {} to link your account.\").format(\n                    (await utils.get_command(self.bot, name='linkme')).mention\n                ), ephemeral=True)\n                return\n            name = user.display_name\n        else:\n            ucid = user\n            name = await self.bot.get_member_or_name_by_ucid(ucid)\n            if isinstance(name, discord.Member):\n                name = name.display_name\n        # noinspection PyUnresolvedReferences\n        await interaction.response.defer()\n        try:\n            response = await self.get(f'stats/{ucid}')\n            if not len(response):\n                await interaction.followup.send(_('No cloud-based statistics found for this user.'), ephemeral=True)\n                return\n            # TODO: support period\n            df = pd.DataFrame(response)\n            report = PaginationReport(self.bot, interaction, self.plugin_name, 'cloudstats.json')\n            await report.render(user=name, data=df, guild=None)\n        except aiohttp.ClientError:\n            await interaction.followup.send(_('Cloud not connected!'), ephemeral=True)\n\n    @tasks.loop(minutes=15.0)\n    async def cloud_bans(self):\n        if self.config.get('dcs-ban', False):\n            self_bans: set = {x['ucid'] for x in await self.bus.bans() if x['banned_by'] == self.plugin_name}\n            external_bans: set = {ban['ucid'] for ban in await self.get('bans')}\n            # find UCIDs to ban (in external_bans but not in self_bans)\n            for ucid in external_bans - self_bans:\n                reason = next(ban['reason'] for ban in await self.get('bans') if ban['ucid'] == ucid)\n                await self.bus.ban(ucid=ucid, reason='DGSA: ' + reason, banned_by=self.plugin_name)\n            # find UCIDs to unban (in self_bans but not in external_bans)\n            for ucid in self_bans - external_bans:\n                await self.bus.unban(ucid)\n        if self.config.get('discord-ban', False):\n            bans: dict = await self.get('discord-bans')\n            users_to_ban = {await self.bot.fetch_user(x['discord_id']) for x in bans}\n            guild = self.bot.guilds[0]\n            guild_bans = [entry async for entry in guild.bans()]\n            banned_users = {x.user for x in guild_bans if x.reason and x.reason.startswith('DGSA:')}\n            # unban users that should not be banned anymore\n            for user in banned_users - users_to_ban:\n                await guild.unban(user, reason='DGSA: ban revoked.')\n            # ban users that were not banned yet (omit the owner)\n            for user in users_to_ban - banned_users - {self.bot.owner_id}:\n                reason = next(x['reason'] for x in bans if x['discord_id'] == user.id)\n                await guild.ban(user, reason='DGSA: ' + reason)\n\n    @tasks.loop(seconds=10)\n    async def cloud_sync(self):\n        async with self.apool.connection() as conn:\n            cursor = await conn.execute(\"\"\"\n                SELECT ucid FROM players \n                WHERE synced IS FALSE \n                ORDER BY last_seen DESC \n                LIMIT 10\n            \"\"\")\n            rows = await cursor.fetchall()\n        # We do not want to block the connection pool for an unnecessary amount of time\n        for row in rows:\n            async with self.apool.connection() as conn:\n                async with conn.transaction():\n                    async with conn.cursor(row_factory=dict_row) as cursor:\n                        await cursor.execute(\"\"\"\n                            SELECT s.player_ucid, m.mission_theatre, s.slot, \n                                   SUM(s.kills) as kills, SUM(s.pvp) as pvp, SUM(deaths) as deaths, \n                                   SUM(ejections) as ejections, SUM(crashes) as crashes, \n                                   SUM(teamkills) as teamkills, SUM(kills_planes) AS kills_planes, \n                                   SUM(kills_helicopters) AS kills_helicopters, SUM(kills_ships) AS kills_ships, \n                                   SUM(kills_sams) AS kills_sams, SUM(kills_ground) AS kills_ground, \n                                   SUM(deaths_pvp) as deaths_pvp, SUM(deaths_planes) AS deaths_planes, \n                                   SUM(deaths_helicopters) AS deaths_helicopters, SUM(deaths_ships) AS deaths_ships,\n                                   SUM(deaths_sams) AS deaths_sams, SUM(deaths_ground) AS deaths_ground, \n                                   SUM(takeoffs) as takeoffs, SUM(landings) as landings, \n                                   ROUND(SUM(EXTRACT(EPOCH FROM (s.hop_off - s.hop_on))))::BIGINT AS playtime \n                            FROM statistics s, missions m \n                            WHERE s.player_ucid = %s AND s.hop_off IS NOT null AND s.mission_id = m.id \n                            GROUP BY 1, 2, 3\n                        \"\"\", (row[0], ))\n                        async for line in cursor:\n                            try:\n                                line['client'] = self.client\n                                await self.post('upload', line)\n                            except TypeError as ex:\n                                self.log.warning(f\"Could not replicate user {row[0]}: {ex}\")\n                        await cursor.execute('UPDATE players SET synced = TRUE WHERE ucid = %s', (row[0], ))\n\n    @tasks.loop(hours=1)\n    async def register(self):\n        async with self.apool.connection() as conn:\n            async with conn.cursor() as cursor:\n                await cursor.execute(\"\"\"\n                    SELECT count(distinct node) as num_bots, count(distinct instance) as num_servers \n                    FROM instances WHERE last_seen > (DATE(now() AT TIME ZONE 'utc') - interval '1 week')\n                \"\"\")\n                if cursor.rowcount == 0:\n                    num_bots = num_servers = 0\n                else:\n                    row = await cursor.fetchone()\n                    num_bots = row[0]\n                    num_servers = row[1]\n        try:\n            _, dcs_version = await self.node.get_dcs_branch_and_version()\n            # noinspection PyUnresolvedReferences\n            bot = {\n                \"guild_id\": self.bot.guilds[0].id,\n                \"bot_version\": f\"{self.bot.version}.{self.bot.sub_version}\",\n                \"variant\": \"DCSServerBot\",\n                \"dcs_version\": dcs_version,\n                \"python_version\": '.'.join(platform.python_version_tuple()),\n                \"num_bots\": num_bots,\n                \"num_servers\": num_servers,\n                \"plugins\": [\n                    {\n                        \"name\": p.plugin_name,\n                        \"version\": p.plugin_version\n                    } for p in self.bot.cogs.values()\n                ]\n            }\n            self.log.debug(\"Updating registration with this data: \" + str(bot))\n            await self.post('register', bot)\n        except aiohttp.ClientError:\n            self.log.debug('Cloud: Bot could not register due to service unavailability. Ignored.')\n        except Exception:\n            self.log.debug(\"Error while registering: \", exc_info=True)\n\n    @register.before_loop\n    async def before_register(self):\n        await self.bot.wait_until_ready()\n\n\nasync def setup(bot: DCSServerBot):\n    await bot.add_cog(CloudHandler(bot, CloudListener))\n"}, "/plugins/funkman/commands.py": {"changes": [{"diff": "\n                 await conn.execute('DELETE FROM strafe_runs WHERE player_ucid = %s', (ucid,))\n         elif days > -1:\n             await conn.execute(f\"\"\"\n-                DELETE FROM bomb_runs WHERE time < (DATE(now() AT TIME ZONE 'utc') - interval '{days} days')\n-            \"\"\")\n-            await conn.execute(f\"\"\"\n-                DELETE FROM strafe_runs WHERE time < (DATE(now() AT TIME ZONE 'utc') - interval '{days} days')\n-            \"\"\")\n+                DELETE FROM bomb_runs WHERE time < (DATE(now() AT TIME ZONE 'utc') - %s::interval)\n+            \"\"\", (f'{days} days', ))\n+            await conn.execute(\"\"\"\n+                DELETE FROM strafe_runs WHERE time < (DATE(now() AT TIME ZONE 'utc') - %s::interval)\n+            \"\"\", (f'{days} days', ))\n         self.log.debug('FunkMan pruned.')", "add": 5, "remove": 5, "filename": "/plugins/funkman/commands.py", "badparts": ["                DELETE FROM bomb_runs WHERE time < (DATE(now() AT TIME ZONE 'utc') - interval '{days} days')", "            \"\"\")", "            await conn.execute(f\"\"\"", "                DELETE FROM strafe_runs WHERE time < (DATE(now() AT TIME ZONE 'utc') - interval '{days} days')", "            \"\"\")"], "goodparts": ["                DELETE FROM bomb_runs WHERE time < (DATE(now() AT TIME ZONE 'utc') - %s::interval)", "            \"\"\", (f'{days} days', ))", "            await conn.execute(\"\"\"", "                DELETE FROM strafe_runs WHERE time < (DATE(now() AT TIME ZONE 'utc') - %s::interval)", "            \"\"\", (f'{days} days', ))"]}], "source": "\nimport os import psycopg from configparser import ConfigParser from core import Plugin, PluginInstallationError, PluginConfigurationError, DEFAULT_TAG, Server from services import DCSServerBot from typing import Optional from.listener import FunkManEventListener from ruamel.yaml import YAML yaml=YAML() class FunkMan(Plugin): def read_locals(self) -> dict: config=super().read_locals() if not config: raise PluginInstallationError('funkman', f\"Can't find{self.node.config_dir}/plugins/funkman.yaml, please create one!\") return config async def install(self) -> bool: if await super().install(): config=self.get_config() if 'install' not in config: raise PluginConfigurationError(self.plugin_name, 'install') funkpath=os.path.expandvars(config['install']) if not os.path.exists(funkpath) or not os.path.exists(os.path.join(funkpath, 'FunkMan.ini')): self.log.error(f\"No FunkMan installation found at{funkpath}!\") raise PluginConfigurationError(self.plugin_name, 'install') if 'CHANNELID_MAIN' not in config: self.log.info(' => Migrating FunkMan.ini...') ini=ConfigParser() ini.read(os.path.join(config['install'], 'FunkMan.ini')) if 'CHANNELID_MAIN' in ini['FUNKBOT']: config['CHANNELID_MAIN']=ini['FUNKBOT']['CHANNELID_MAIN'] if 'CHANNELID_RANGE' in ini['FUNKBOT']: config['CHANNELID_RANGE']=ini['FUNKBOT']['CHANNELID_RANGE'] if 'CHANNELID_AIRBOSS' in ini['FUNKBOT']: config['CHANNELID_AIRBOSS']=ini['FUNKBOT']['CHANNELID_AIRBOSS'] if 'IMAGEPATH' in ini['FUNKPLOT']: if ini['FUNKPLOT']['IMAGEPATH'].startswith('.'): config['IMAGEPATH']=config['install'] +ini['FUNKPLOT']['IMAGEPATH'][1:] else: config['IMAGEPATH']=ini['FUNKPLOT']['IMAGEPATH'] with open(os.path.join(self.node.config_dir, 'plugins', 'funkman.yaml'), mode='w', encoding='utf-8') as outfile: yaml.dump({DEFAULT_TAG: config}, outfile) return True return False def get_config(self, server: Optional[Server]=None, *, plugin_name: Optional[str]=None, use_cache: Optional[bool]=True) -> dict: if plugin_name: return super().get_config(server, plugin_name=plugin_name, use_cache=use_cache) if not server: return self.locals.get(DEFAULT_TAG,{}) if server.node.name not in self._config: self._config[server.node.name]={} if server.instance.name not in self._config[server.node.name] or not use_cache: default, specific=self.get_base_config(server) for x in['strafe_board', 'strafe_channel', 'bomb_board', 'bomb_channel']: if x in default: del default[x] self._config[server.node.name][server.instance.name]=default | specific return self._config[server.node.name][server.instance.name] async def prune(self, conn: psycopg.AsyncConnection, *, days: int=-1, ucids: list[str]=None, server: Optional[str]=None) -> None: self.log.debug('Pruning FunkMan...') if ucids: for ucid in ucids: await conn.execute('DELETE FROM bomb_runs WHERE player_ucid=%s',(ucid,)) await conn.execute('DELETE FROM strafe_runs WHERE player_ucid=%s',(ucid,)) elif days > -1: await conn.execute(f\"\"\" DELETE FROM bomb_runs WHERE time <(DATE(now() AT TIME ZONE 'utc') -interval '{days} days') \"\"\") await conn.execute(f\"\"\" DELETE FROM strafe_runs WHERE time <(DATE(now() AT TIME ZONE 'utc') -interval '{days} days') \"\"\") self.log.debug('FunkMan pruned.') async def setup(bot: DCSServerBot): await bot.add_cog(FunkMan(bot, FunkManEventListener)) ", "sourceWithComments": "import os\nimport psycopg\n\nfrom configparser import ConfigParser\nfrom core import Plugin, PluginInstallationError, PluginConfigurationError, DEFAULT_TAG, Server\nfrom services import DCSServerBot\nfrom typing import Optional\n\nfrom .listener import FunkManEventListener\n\n# ruamel YAML support\nfrom ruamel.yaml import YAML\nyaml = YAML()\n\n\nclass FunkMan(Plugin):\n\n    def read_locals(self) -> dict:\n        config = super().read_locals()\n        if not config:\n            raise PluginInstallationError('funkman',\n                                          f\"Can't find {self.node.config_dir}/plugins/funkman.yaml, please create one!\")\n        return config\n\n    async def install(self) -> bool:\n        if await super().install():\n            config = self.get_config()\n            if 'install' not in config:\n                raise PluginConfigurationError(self.plugin_name, 'install')\n            funkpath = os.path.expandvars(config['install'])\n            if not os.path.exists(funkpath) or not os.path.exists(os.path.join(funkpath, 'FunkMan.ini')):\n                self.log.error(f\"No FunkMan installation found at {funkpath}!\")\n                raise PluginConfigurationError(self.plugin_name, 'install')\n            if 'CHANNELID_MAIN' not in config:\n                self.log.info('  => Migrating FunkMan.ini ...')\n                ini = ConfigParser()\n                ini.read(os.path.join(config['install'], 'FunkMan.ini'))\n                if 'CHANNELID_MAIN' in ini['FUNKBOT']:\n                    config['CHANNELID_MAIN'] = ini['FUNKBOT']['CHANNELID_MAIN']\n                if 'CHANNELID_RANGE' in ini['FUNKBOT']:\n                    config['CHANNELID_RANGE'] = ini['FUNKBOT']['CHANNELID_RANGE']\n                if 'CHANNELID_AIRBOSS' in ini['FUNKBOT']:\n                    config['CHANNELID_AIRBOSS'] = ini['FUNKBOT']['CHANNELID_AIRBOSS']\n                if 'IMAGEPATH' in ini['FUNKPLOT']:\n                    if ini['FUNKPLOT']['IMAGEPATH'].startswith('.'):\n                        config['IMAGEPATH'] = config['install'] + ini['FUNKPLOT']['IMAGEPATH'][1:]\n                    else:\n                        config['IMAGEPATH'] = ini['FUNKPLOT']['IMAGEPATH']\n                with open(os.path.join(self.node.config_dir, 'plugins', 'funkman.yaml'), mode='w',\n                          encoding='utf-8') as outfile:\n                    yaml.dump({DEFAULT_TAG: config}, outfile)\n            return True\n        return False\n\n    def get_config(self, server: Optional[Server] = None, *, plugin_name: Optional[str] = None,\n                   use_cache: Optional[bool] = True) -> dict:\n        # retrieve the config from another plugin\n        if plugin_name:\n            return super().get_config(server, plugin_name=plugin_name, use_cache=use_cache)\n        if not server:\n            return self.locals.get(DEFAULT_TAG, {})\n        if server.node.name not in self._config:\n            self._config[server.node.name] = {}\n        if server.instance.name not in self._config[server.node.name] or not use_cache:\n            default, specific = self.get_base_config(server)\n            for x in ['strafe_board', 'strafe_channel', 'bomb_board', 'bomb_channel']:\n                if x in default:\n                    del default[x]\n            self._config[server.node.name][server.instance.name] = default | specific\n        return self._config[server.node.name][server.instance.name]\n\n    async def prune(self, conn: psycopg.AsyncConnection, *, days: int = -1, ucids: list[str] = None,\n                    server: Optional[str] = None) -> None:\n        self.log.debug('Pruning FunkMan ...')\n        if ucids:\n            for ucid in ucids:\n                await conn.execute('DELETE FROM bomb_runs WHERE player_ucid = %s', (ucid,))\n                await conn.execute('DELETE FROM strafe_runs WHERE player_ucid = %s', (ucid,))\n        elif days > -1:\n            await conn.execute(f\"\"\"\n                DELETE FROM bomb_runs WHERE time < (DATE(now() AT TIME ZONE 'utc') - interval '{days} days')\n            \"\"\")\n            await conn.execute(f\"\"\"\n                DELETE FROM strafe_runs WHERE time < (DATE(now() AT TIME ZONE 'utc') - interval '{days} days')\n            \"\"\")\n        self.log.debug('FunkMan pruned.')\n\n\nasync def setup(bot: DCSServerBot):\n    await bot.add_cog(FunkMan(bot, FunkManEventListener))\n"}, "/plugins/gamemaster/commands.py": {"changes": [{"diff": "\n             for ucid in ucids:\n                 await conn.execute('DELETE FROM coalitions WHERE player_ucid = %s', (ucid, ))\n         if days > -1:\n-            await conn.execute(\n-                f\"DELETE FROM campaigns WHERE stop < (DATE(now() AT TIME ZONE 'utc') - interval '{days} days')\")\n+            await conn.execute(\"DELETE FROM campaigns WHERE stop < (DATE(now() AT TIME ZONE 'utc') - %s::interval)\",\n+                               (f'{days} days', ))\n         if server:\n             await conn.execute(\"DELETE FROM campaigns_servers WHERE server_name = %s\", (server, ))\n             await conn.execute(\"DELETE FROM coalitions WHERE server_name = %s\", (serve", "add": 2, "remove": 2, "filename": "/plugins/gamemaster/commands.py", "badparts": ["            await conn.execute(", "                f\"DELETE FROM campaigns WHERE stop < (DATE(now() AT TIME ZONE 'utc') - interval '{days} days')\")"], "goodparts": ["            await conn.execute(\"DELETE FROM campaigns WHERE stop < (DATE(now() AT TIME ZONE 'utc') - %s::interval)\",", "                               (f'{days} days', ))"]}], "source": "\nimport asyncio import aiohttp import discord import os import psycopg from core import Plugin, utils, Report, Status, Server, Coalition, Channel, command, Group, Player, UploadStatus, \\ get_translation from discord import app_commands from discord.app_commands import Range from discord.ext import commands from services import DCSServerBot from typing import Optional, Literal from.listener import GameMasterEventListener from.views import CampaignModal, ScriptModal _=get_translation(__name__.split('.')[1]) async def scriptfile_autocomplete(interaction: discord.Interaction, current: str) -> list[app_commands.Choice[str]]: if not await interaction.command._check_can_run(interaction): return[] try: server: Server=await utils.ServerTransformer().transform(interaction, utils.get_interaction_param(interaction, 'server')) if not server: return[] choices: list[app_commands.Choice[str]]=[ app_commands.Choice(name=os.path.basename(x), value=os.path.basename(x)) for x in await server.node.list_directory(os.path.join(await server.get_missions_dir(), 'Scripts'), pattern='*.lua') if not current or current.casefold() in x.casefold() ] return choices[:25] except Exception as ex: interaction.client.log.exception(ex) class GameMaster(Plugin): async def install(self) -> bool: init=await super().install() for server in self.bot.servers.values(): if 'coalitions' in server.locals: self.log.debug(f' -Updating \"{server.name}\":serverSettings.lua for coalitions') advanced=server.settings['advanced'] if advanced['allow_players_pool'] !=server.locals['coalitions'].get('allow_players_pool', False): advanced['allow_players_pool']=server.locals['coalitions'].get('allow_players_pool', False) server.settings['advanced']=advanced return init async def prune(self, conn: psycopg.AsyncConnection, *, days: int=-1, ucids: list[str]=None, server: Optional[str]=None) -> None: self.log.debug('Pruning Gamemaster...') if ucids: for ucid in ucids: await conn.execute('DELETE FROM coalitions WHERE player_ucid=%s',(ucid,)) if days > -1: await conn.execute( f\"DELETE FROM campaigns WHERE stop <(DATE(now() AT TIME ZONE 'utc') -interval '{days} days')\") if server: await conn.execute(\"DELETE FROM campaigns_servers WHERE server_name=%s\",(server,)) await conn.execute(\"DELETE FROM coalitions WHERE server_name=%s\",(server,)) self.log.debug('Gamemaster pruned.') async def rename(self, conn: psycopg.AsyncConnection, old_name: str, new_name: str): await conn.execute('UPDATE campaigns_servers SET server_name=%s WHERE server_name=%s',(new_name, old_name)) async def update_ucid(self, conn: psycopg.AsyncConnection, old_ucid: str, new_ucid: str) -> None: await conn.execute('UPDATE coalitions SET player_ucid=%s WHERE player_ucid=%s',(new_ucid, old_ucid)) @command(description=_('Send a chat message to DCS')) @app_commands.guild_only() @utils.app_has_roles(['DCS Admin', 'GameMaster']) async def chat(self, interaction: discord.Interaction, server: app_commands.Transform[Server, utils.ServerTransformer(status=[Status.RUNNING])], message: str): if server.status !=Status.RUNNING: await interaction.response.send_message(_(\"Server{} is not running.\").format(server.name), ephemeral=True) return server.send_to_dcs({ \"command\": \"sendChatMessage\", \"channel\": interaction.channel.id, \"message\": message, \"from\": interaction.user.display_name }) await interaction.response.send_message(_('Message sent.'), ephemeral=utils.get_ephemeral(interaction)) @command(description=_('Sends a popup to a coalition\\n')) @app_commands.guild_only() @utils.app_has_roles(['DCS Admin', 'GameMaster']) async def popup(self, interaction: discord.Interaction, server: app_commands.Transform[Server, utils.ServerTransformer(status=[Status.RUNNING])], to: Literal['all', 'red', 'blue'], message: str, time: Optional[Range[int, 1, 30]]=-1): if server.status !=Status.RUNNING: await interaction.response.send_message(_(\"Server{} is not running.\").format(server.name), ephemeral=True) return server.sendPopupMessage(Coalition(to), message, time, interaction.user.display_name) await interaction.response.send_message(_('Message sent.'), ephemeral=utils.get_ephemeral(interaction)) @command(description=_('Sends a popup to all servers')) @app_commands.guild_only() @utils.app_has_roles(['DCS Admin', 'GameMaster']) async def broadcast(self, interaction: discord.Interaction, to: Literal['all', 'red', 'blue'], message: str, time: Optional[Range[int, 1, 30]]=-1): ephemeral=utils.get_ephemeral(interaction) await interaction.response.defer(ephemeral=ephemeral) for server in self.bot.servers.values(): if server.status !=Status.RUNNING: await interaction.followup.send(_('Message NOT sent to server{server} because it is{status}.' ).format(server=server.display_name, status=server.status.name), ephemeral=ephemeral) continue server.sendPopupMessage(Coalition(to), message, time, interaction.user.display_name) await interaction.followup.send(_('Message sent to server{}.').format(server.display_name), ephemeral=ephemeral) @command(description=_('Set or get a flag inside the mission')) @app_commands.guild_only() @utils.app_has_roles(['DCS Admin', 'GameMaster']) async def flag(self, interaction: discord.Interaction, server: app_commands.Transform[Server, utils.ServerTransformer(status=[Status.RUNNING])], flag: str, value: Optional[int]=None): if server.status !=Status.RUNNING: await interaction.response.send_message(_(\"Server{} is not running.\").format(server.name), ephemeral=True) return ephemeral=utils.get_ephemeral(interaction) if value is not None: server.send_to_dcs({ \"command\": \"setFlag\", \"flag\": flag, \"value\": value }) await interaction.response.send_message(_(\"Flag{flag} set to{value}.\").format(flag=flag, value=value), ephemeral=ephemeral) else: data=await server.send_to_dcs_sync({\"command\": \"getFlag\", \"flag\": flag}) await interaction.response.send_message(_(\"Flag{flag} has value{value}.\").format( flag=flag, value=data['value']), ephemeral=ephemeral) @command(description=_('Set or get a mission variable')) @app_commands.guild_only() @utils.app_has_roles(['DCS Admin', 'GameMaster']) async def variable(self, interaction: discord.Interaction, server: app_commands.Transform[Server, utils.ServerTransformer(status=[Status.RUNNING])], name: str, value: Optional[str]=None): if server.status !=Status.RUNNING: await interaction.response.send_message(_(\"Server{} is not running.\").format(server.name), ephemeral=True) return ephemeral=utils.get_ephemeral(interaction) await interaction.response.defer(ephemeral=ephemeral) if value is not None: server.send_to_dcs({ \"command\": \"setVariable\", \"name\": name, \"value\": value }) await interaction.followup.send(_(\"Variable{name} set to{value}.\").format(name=name, value=value), ephemeral=ephemeral) else: try: data=await server.send_to_dcs_sync({\"command\": \"getVariable\", \"name\": name}) except(TimeoutError, asyncio.TimeoutError): await interaction.followup.send( _('Timeout while retrieving variable. Most likely a lua error occurred. Check your dcs.log.'), ephemeral=True) return if 'value' in data: await interaction.followup.send( _(\"Variable{name} has value{value}.\").format(name=name, value=data['value']), ephemeral=ephemeral) else: await interaction.followup.send(_(\"Variable{} is not set.\").format(name), ephemeral=ephemeral) @command(description=_('Calls any function inside the mission')) @utils.app_has_roles(['DCS Admin', 'GameMaster']) @app_commands.guild_only() async def do_script(self, interaction: discord.Interaction, server: app_commands.Transform[Server, utils.ServerTransformer(status=[ Status.RUNNING, Status.PAUSED ])]): if server.status not in[Status.RUNNING, Status.PAUSED]: await interaction.response.send_message(_(\"Server{} is not running.\").format(server.name), ephemeral=True) return modal=ScriptModal(server, utils.get_ephemeral(interaction)) await interaction.response.send_modal(modal) @command(description=_('Loads a lua file into the mission')) @app_commands.guild_only() @utils.app_has_roles(['DCS Admin', 'GameMaster']) @app_commands.autocomplete(filename=scriptfile_autocomplete) async def do_script_file(self, interaction: discord.Interaction, server: app_commands.Transform[Server, utils.ServerTransformer(status=[ Status.RUNNING, Status.PAUSED ])], filename: str): if server.status not in[Status.RUNNING, Status.PAUSED]: await interaction.response.send_message(_(\"Server{} is not running.\").format(server.name), ephemeral=True) return filename=os.path.join('Missions', 'Scripts', filename) server.send_to_dcs({ \"command\": \"do_script_file\", \"file\": filename.replace('\\\\', '/') }) await interaction.response.send_message(_('Script loaded.'), ephemeral=utils.get_ephemeral(interaction)) @command(description=_('Mass coalition leave for users')) @app_commands.guild_only() @utils.app_has_role('DCS Admin') async def reset_coalitions(self, interaction: discord.Interaction): ephemeral=utils.get_ephemeral(interaction) if not await utils.yn_question(interaction, _('Do you want to mass-reset all coalition-bindings from your players?'), ephemeral=ephemeral): await interaction.followup.send('Aborted.', ephemeral=ephemeral) return try: for server in self.bot.servers.values(): if not server.locals.get('coalitions'): continue await self.eventlistener.reset_coalitions(server, True) await interaction.followup.send(_('Coalition bindings reset for all players.'), ephemeral=ephemeral) except discord.Forbidden: await interaction.followup.send(_('The bot is missing the \"Manage Roles\" permission!'), ephemeral=ephemeral) await self.bot.audit(f'permission \"Manage Roles\" missing.', user=self.bot.member) campaign=Group(name=\"campaign\", description=_(\"Commands to manage DCS campaigns\")) @campaign.command(name='list', description=_(\"Lists all(active) campaigns\")) @app_commands.guild_only() @utils.app_has_role('DCS Admin') @app_commands.describe(active=_(\"Display only active campaigns\")) async def _list(self, interaction: discord.Interaction, active: Optional[bool]=True): report=Report(self.bot, self.plugin_name, 'active-campaigns.json' if active else 'all-campaigns.json') env=await report.render() await interaction.response.send_message(embed=env.embed, ephemeral=utils.get_ephemeral(interaction)) @campaign.command(description=_(\"Campaign info\")) @app_commands.guild_only() @utils.app_has_role('DCS Admin') @app_commands.autocomplete(campaign=utils.campaign_autocomplete) async def info(self, interaction: discord.Interaction, campaign: str): report=Report(self.bot, self.plugin_name, 'campaign.json') env=await report.render(campaign=await utils.get_campaign(self, campaign), title=_('Campaign Overview')) await interaction.response.send_message(embed=env.embed, ephemeral=utils.get_ephemeral(interaction)) @campaign.command(description=_(\"Add a campaign\")) @app_commands.guild_only() @utils.app_has_role('DCS Admin') async def add(self, interaction: discord.Interaction): ephemeral=utils.get_ephemeral(interaction) modal=CampaignModal(self.eventlistener) await interaction.response.send_modal(modal) if await modal.wait(): await interaction.response.send_message(_('Aborted.'), ephemeral=ephemeral) return try: servers=await utils.server_selection(self.bus, interaction, title=_(\"Select all servers for this campaign\"), multi_select=True, ephemeral=ephemeral) if not servers: await interaction.followup.send(_('Aborted.'), ephemeral=True) return if not isinstance(servers, list): servers=[servers] try: await self.eventlistener.campaign('add', servers=servers, name=modal.name.value, description=modal.description.value, start=modal.start, end=modal.end) await interaction.followup.send(_(\"Campaign{} added.\").format(modal.name.value), ephemeral=ephemeral) except psycopg.errors.ExclusionViolation: await interaction.followup.send(_(\"A campaign is already configured for this timeframe!\"), ephemeral=ephemeral) except psycopg.errors.UniqueViolation: await interaction.followup.send(_(\"A campaign with this name already exists!\"), ephemeral=ephemeral) except Exception as ex: self.log.exception(ex) @campaign.command(description=_(\"Add a server to an existing campaign\\n\")) @app_commands.guild_only() @utils.app_has_role('DCS Admin') @app_commands.autocomplete(campaign=utils.campaign_autocomplete) async def add_server(self, interaction: discord.Interaction, campaign: str, server: app_commands.Transform[Server, utils.ServerTransformer]): ephemeral=utils.get_ephemeral(interaction) try: async with self.apool.connection() as conn: async with conn.transaction(): await conn.execute(\"\"\" INSERT INTO campaigns_servers(campaign_id, server_name) SELECT id, %s FROM campaigns WHERE name=%s ON CONFLICT DO NOTHING \"\"\",(server.name, campaign)) await interaction.response.send_message( _(\"Server{server} added to campaign{campaign}.\").format(server=server.name, campaign=campaign), ephemeral=ephemeral) except psycopg.errors.UniqueViolation: await interaction.response.send_message( _(\"Server{server} is already part of the campaign{campaign}!\").format( server=server.name, campaign=campaign), ephemeral=ephemeral) @campaign.command(description=_(\"Delete a campaign\")) @app_commands.guild_only() @utils.app_has_role('DCS Admin') @app_commands.autocomplete(campaign=utils.campaign_autocomplete) async def delete(self, interaction: discord.Interaction, campaign: str): ephemeral=utils.get_ephemeral(interaction) if await utils.yn_question(interaction, _('Do you want to delete campaign \"{}\"?').format(campaign), ephemeral=ephemeral): await self.eventlistener.campaign('delete', name=campaign) await interaction.followup.send(_(\"Campaign deleted.\"), ephemeral=ephemeral) else: await interaction.followup.send(_('Aborted.'), ephemeral=ephemeral) @campaign.command(description=_(\"Start a campaign\")) @app_commands.guild_only() @utils.app_has_role('DCS Admin') async def start(self, interaction: discord.Interaction, campaign: str): ephemeral=utils.get_ephemeral(interaction) try: await interaction.response.defer(ephemeral=True) servers=await utils.server_selection(self.bus, interaction, title=_(\"Select all servers for this campaign\"), multi_select=True, ephemeral=ephemeral) if not isinstance(servers, list): servers=[servers] await self.eventlistener.campaign('start', servers=servers, name=campaign) await interaction.followup.send(_(\"Campaign{} started.\").format(campaign), ephemeral=ephemeral) except psycopg.errors.ExclusionViolation: await interaction.followup.send(_(\"A campaign is already configured for this timeframe!\"), ephemeral=ephemeral) except psycopg.errors.UniqueViolation: await interaction.followup.send(_(\"A campaign with this name already exists!\"), ephemeral=ephemeral) @campaign.command(description=_(\"Stop a campaign\")) @app_commands.guild_only() @utils.app_has_role('DCS Admin') @app_commands.autocomplete(campaign=utils.campaign_autocomplete) async def stop(self, interaction: discord.Interaction, campaign: str): ephemeral=utils.get_ephemeral(interaction) if await utils.yn_question(interaction, _('Do you want to stop campaign \"{}\"?').format(campaign), ephemeral=ephemeral): await self.eventlistener.campaign('stop', name=campaign) await interaction.followup.send(_(\"Campaign stopped.\"), ephemeral=ephemeral) else: await interaction.followup.send(_('Aborted.'), ephemeral=ephemeral) @commands.Cog.listener() async def on_member_update(self, before: discord.Member, after: discord.Member): if before.roles==after.roles: return for server in self.bot.servers.values(): player: Player=server.get_player(discord_id=after.id) if player: server.send_to_dcs({ 'command': 'uploadUserRoles', 'id': player.id, 'ucid': player.ucid, 'roles':[x.id for x in after.roles] }) async def _create_embed(self, message: discord.Message) -> None: async with aiohttp.ClientSession() as session: async with session.get(message.attachments[0].url) as response: if response.status==200: data=await response.json(encoding=\"utf-8\") embed=utils.format_embed(data, bot=self.bot, bus=self.bus, node=self.bus.node, user=message.author) msg=None if 'message_id' in data: try: msg=await message.channel.fetch_message(int(data['message_id'])) await msg.edit(embed=embed) except discord.errors.NotFound: msg=None except discord.errors.DiscordException as ex: self.log.exception(ex) await message.channel.send(_('Error while updating embed!')) return if not msg: await message.channel.send(embed=embed) await message.delete() else: await message.channel.send(_('Error{} while reading JSON file!').format(response.status)) async def _upload_lua(self, message: discord.Message) -> int: server: Server=self.bot.get_server(message, admin_only=True) ctx=await self.bot.get_context(message) if not server: if self.bot.locals.get('admin_channel', 0)==message.channel.id: try: server=await utils.server_selection( self.bus, ctx, title=_(\"To which server do you want to upload this LUA to?\")) if not server: await ctx.send(_('Aborted.')) return -1 except Exception as ex: self.log.exception(ex) return -1 else: return -1 num=0 for attachment in message.attachments: if not attachment.filename.endswith('.lua'): continue filename=os.path.normpath(os.path.join(await server.get_missions_dir(), 'Scripts', attachment.filename)) rc=await server.node.write_file(filename, attachment.url) if rc==UploadStatus.OK: num +=1 continue if not await utils.yn_question(ctx, _('File exists. Do you want to overwrite it?')): await message.channel.send(_('Aborted.')) continue rc=await server.node.write_file(filename, attachment.url, overwrite=True) if rc !=UploadStatus.OK: await message.channel.send(_(\"File{} could not be uploaded.\").format(attachment.filename)) else: num +=1 return num @commands.Cog.listener() async def on_message(self, message: discord.Message): if message.author.bot: return if message.attachments: if(message.attachments[0].filename.endswith('.json') and utils.check_roles(self.bot.roles['Admin'], message.author)): await self._create_embed(message) elif(message.attachments[0].filename.endswith('.lua') and utils.check_roles(self.bot.roles['DCS Admin'], message.author)): num=await self._upload_lua(message) if num > 0: await message.channel.send( _(\"{num} LUA files uploaded. You can load any of them with{command} now.\").format( num=num, command=(await utils.get_command(self.bot, name='do_script_file')).mention ) ) await message.delete() else: for server in self.bot.servers.values(): if server.status !=Status.RUNNING: continue if 'coalitions' in server.locals: sides=utils.get_sides(self.bot, message, server) if Coalition.BLUE in sides and server.channels[Channel.COALITION_BLUE_CHAT]==message.channel.id: pass elif Coalition.RED in sides and server.channels[Channel.COALITION_RED_CHAT]==message.channel.id: pass if server.channels[Channel.CHAT] and server.channels[Channel.CHAT]==message.channel.id: if message.content.startswith('/') is False: server.sendChatMessage(Coalition.ALL, message.content, message.author.display_name) async def setup(bot: DCSServerBot): await bot.add_cog(GameMaster(bot, GameMasterEventListener)) ", "sourceWithComments": "import asyncio\nimport aiohttp\nimport discord\nimport os\nimport psycopg\n\nfrom core import Plugin, utils, Report, Status, Server, Coalition, Channel, command, Group, Player, UploadStatus, \\\n    get_translation\nfrom discord import app_commands\nfrom discord.app_commands import Range\nfrom discord.ext import commands\nfrom services import DCSServerBot\nfrom typing import Optional, Literal\n\nfrom .listener import GameMasterEventListener\nfrom .views import CampaignModal, ScriptModal\n\n_ = get_translation(__name__.split('.')[1])\n\n\nasync def scriptfile_autocomplete(interaction: discord.Interaction, current: str) -> list[app_commands.Choice[str]]:\n    if not await interaction.command._check_can_run(interaction):\n        return []\n    try:\n        server: Server = await utils.ServerTransformer().transform(interaction,\n                                                                   utils.get_interaction_param(interaction, 'server'))\n        if not server:\n            return []\n        choices: list[app_commands.Choice[str]] = [\n            app_commands.Choice(name=os.path.basename(x), value=os.path.basename(x))\n            for x in await server.node.list_directory(os.path.join(await server.get_missions_dir(), 'Scripts'),\n                                                      pattern='*.lua')\n            if not current or current.casefold() in x.casefold()\n        ]\n        return choices[:25]\n    except Exception as ex:\n        interaction.client.log.exception(ex)\n\n\nclass GameMaster(Plugin):\n\n    async def install(self) -> bool:\n        init = await super().install()\n        for server in self.bot.servers.values():\n            if 'coalitions' in server.locals:\n                self.log.debug(f'  - Updating \"{server.name}\":serverSettings.lua for coalitions')\n                advanced = server.settings['advanced']\n                if advanced['allow_players_pool'] != server.locals['coalitions'].get('allow_players_pool', False):\n                    advanced['allow_players_pool'] = server.locals['coalitions'].get('allow_players_pool', False)\n                    server.settings['advanced'] = advanced\n        return init\n\n    async def prune(self, conn: psycopg.AsyncConnection, *, days: int = -1, ucids: list[str] = None,\n                    server: Optional[str] = None) -> None:\n        self.log.debug('Pruning Gamemaster ...')\n        if ucids:\n            for ucid in ucids:\n                await conn.execute('DELETE FROM coalitions WHERE player_ucid = %s', (ucid, ))\n        if days > -1:\n            await conn.execute(\n                f\"DELETE FROM campaigns WHERE stop < (DATE(now() AT TIME ZONE 'utc') - interval '{days} days')\")\n        if server:\n            await conn.execute(\"DELETE FROM campaigns_servers WHERE server_name = %s\", (server, ))\n            await conn.execute(\"DELETE FROM coalitions WHERE server_name = %s\", (server, ))\n        self.log.debug('Gamemaster pruned.')\n\n    async def rename(self, conn: psycopg.AsyncConnection, old_name: str, new_name: str):\n        await conn.execute('UPDATE campaigns_servers SET server_name = %s WHERE server_name = %s', (new_name, old_name))\n\n    async def update_ucid(self, conn: psycopg.AsyncConnection, old_ucid: str, new_ucid: str) -> None:\n        await conn.execute('UPDATE coalitions SET player_ucid = %s WHERE player_ucid = %s', (new_ucid, old_ucid))\n\n    @command(description=_('Send a chat message to DCS'))\n    @app_commands.guild_only()\n    @utils.app_has_roles(['DCS Admin', 'GameMaster'])\n    async def chat(self, interaction: discord.Interaction,\n                   server: app_commands.Transform[Server, utils.ServerTransformer(status=[Status.RUNNING])],\n                   message: str):\n        if server.status != Status.RUNNING:\n            # noinspection PyUnresolvedReferences\n            await interaction.response.send_message(_(\"Server {} is not running.\").format(server.name), ephemeral=True)\n            return\n        server.send_to_dcs({\n            \"command\": \"sendChatMessage\",\n            \"channel\": interaction.channel.id,\n            \"message\": message,\n            \"from\": interaction.user.display_name\n        })\n        # noinspection PyUnresolvedReferences\n        await interaction.response.send_message(_('Message sent.'), ephemeral=utils.get_ephemeral(interaction))\n\n    @command(description=_('Sends a popup to a coalition\\n'))\n    @app_commands.guild_only()\n    @utils.app_has_roles(['DCS Admin', 'GameMaster'])\n    async def popup(self, interaction: discord.Interaction,\n                    server: app_commands.Transform[Server, utils.ServerTransformer(status=[Status.RUNNING])],\n                    to: Literal['all', 'red', 'blue'], message: str, time: Optional[Range[int, 1, 30]] = -1):\n        if server.status != Status.RUNNING:\n            # noinspection PyUnresolvedReferences\n            await interaction.response.send_message(_(\"Server {} is not running.\").format(server.name), ephemeral=True)\n            return\n        server.sendPopupMessage(Coalition(to), message, time, interaction.user.display_name)\n        # noinspection PyUnresolvedReferences\n        await interaction.response.send_message(_('Message sent.'), ephemeral=utils.get_ephemeral(interaction))\n\n    @command(description=_('Sends a popup to all servers'))\n    @app_commands.guild_only()\n    @utils.app_has_roles(['DCS Admin', 'GameMaster'])\n    async def broadcast(self, interaction: discord.Interaction, to: Literal['all', 'red', 'blue'], message: str,\n                        time: Optional[Range[int, 1, 30]] = -1):\n        ephemeral = utils.get_ephemeral(interaction)\n        # noinspection PyUnresolvedReferences\n        await interaction.response.defer(ephemeral=ephemeral)\n        for server in self.bot.servers.values():\n            if server.status != Status.RUNNING:\n                await interaction.followup.send(_('Message NOT sent to server {server} because it is {status}.'\n                                                  ).format(server=server.display_name, status=server.status.name),\n                                                ephemeral=ephemeral)\n                continue\n            server.sendPopupMessage(Coalition(to), message, time, interaction.user.display_name)\n            await interaction.followup.send(_('Message sent to server {}.').format(server.display_name),\n                                            ephemeral=ephemeral)\n\n    @command(description=_('Set or get a flag inside the mission'))\n    @app_commands.guild_only()\n    @utils.app_has_roles(['DCS Admin', 'GameMaster'])\n    async def flag(self, interaction: discord.Interaction,\n                   server: app_commands.Transform[Server, utils.ServerTransformer(status=[Status.RUNNING])],\n                   flag: str, value: Optional[int] = None):\n        if server.status != Status.RUNNING:\n            # noinspection PyUnresolvedReferences\n            await interaction.response.send_message(_(\"Server {} is not running.\").format(server.name), ephemeral=True)\n            return\n        ephemeral = utils.get_ephemeral(interaction)\n        if value is not None:\n            server.send_to_dcs({\n                \"command\": \"setFlag\",\n                \"flag\": flag,\n                \"value\": value\n            })\n            # noinspection PyUnresolvedReferences\n            await interaction.response.send_message(_(\"Flag {flag} set to {value}.\").format(flag=flag, value=value),\n                                                    ephemeral=ephemeral)\n        else:\n            data = await server.send_to_dcs_sync({\"command\": \"getFlag\", \"flag\": flag})\n            # noinspection PyUnresolvedReferences\n            await interaction.response.send_message(_(\"Flag {flag} has value {value}.\").format(\n                flag=flag, value=data['value']), ephemeral=ephemeral)\n\n    @command(description=_('Set or get a mission variable'))\n    @app_commands.guild_only()\n    @utils.app_has_roles(['DCS Admin', 'GameMaster'])\n    async def variable(self, interaction: discord.Interaction,\n                       server: app_commands.Transform[Server, utils.ServerTransformer(status=[Status.RUNNING])],\n                       name: str, value: Optional[str] = None):\n        if server.status != Status.RUNNING:\n            # noinspection PyUnresolvedReferences\n            await interaction.response.send_message(_(\"Server {} is not running.\").format(server.name), ephemeral=True)\n            return\n        ephemeral = utils.get_ephemeral(interaction)\n        # noinspection PyUnresolvedReferences\n        await interaction.response.defer(ephemeral=ephemeral)\n        if value is not None:\n            server.send_to_dcs({\n                \"command\": \"setVariable\",\n                \"name\": name,\n                \"value\": value\n            })\n            await interaction.followup.send(_(\"Variable {name} set to {value}.\").format(name=name, value=value),\n                                            ephemeral=ephemeral)\n        else:\n            try:\n                data = await server.send_to_dcs_sync({\"command\": \"getVariable\", \"name\": name})\n            except (TimeoutError, asyncio.TimeoutError):\n                await interaction.followup.send(\n                    _('Timeout while retrieving variable. Most likely a lua error occurred. Check your dcs.log.'),\n                    ephemeral=True)\n                return\n            if 'value' in data:\n                await interaction.followup.send(\n                    _(\"Variable {name} has value {value}.\").format(name=name, value=data['value']), ephemeral=ephemeral)\n            else:\n                await interaction.followup.send(_(\"Variable {} is not set.\").format(name), ephemeral=ephemeral)\n\n    @command(description=_('Calls any function inside the mission'))\n    @utils.app_has_roles(['DCS Admin', 'GameMaster'])\n    @app_commands.guild_only()\n    async def do_script(self, interaction: discord.Interaction,\n                        server: app_commands.Transform[Server, utils.ServerTransformer(status=[\n                            Status.RUNNING, Status.PAUSED\n                        ])]):\n        if server.status not in [Status.RUNNING, Status.PAUSED]:\n            # noinspection PyUnresolvedReferences\n            await interaction.response.send_message(_(\"Server {} is not running.\").format(server.name), ephemeral=True)\n            return\n        modal = ScriptModal(server, utils.get_ephemeral(interaction))\n        # noinspection PyUnresolvedReferences\n        await interaction.response.send_modal(modal)\n\n    @command(description=_('Loads a lua file into the mission'))\n    @app_commands.guild_only()\n    @utils.app_has_roles(['DCS Admin', 'GameMaster'])\n    @app_commands.autocomplete(filename=scriptfile_autocomplete)\n    async def do_script_file(self, interaction: discord.Interaction,\n                             server: app_commands.Transform[Server, utils.ServerTransformer(status=[\n                                 Status.RUNNING, Status.PAUSED\n                             ])],\n                             filename: str):\n        if server.status not in [Status.RUNNING, Status.PAUSED]:\n            # noinspection PyUnresolvedReferences\n            await interaction.response.send_message(_(\"Server {} is not running.\").format(server.name), ephemeral=True)\n            return\n        filename = os.path.join('Missions', 'Scripts', filename)\n        server.send_to_dcs({\n            \"command\": \"do_script_file\",\n            \"file\": filename.replace('\\\\', '/')\n        })\n        # noinspection PyUnresolvedReferences\n        await interaction.response.send_message(_('Script loaded.'), ephemeral=utils.get_ephemeral(interaction))\n\n    @command(description=_('Mass coalition leave for users'))\n    @app_commands.guild_only()\n    @utils.app_has_role('DCS Admin')\n    async def reset_coalitions(self, interaction: discord.Interaction):\n        ephemeral = utils.get_ephemeral(interaction)\n        if not await utils.yn_question(interaction,\n                                       _('Do you want to mass-reset all coalition-bindings from your players?'),\n                                       ephemeral=ephemeral):\n            await interaction.followup.send('Aborted.', ephemeral=ephemeral)\n            return\n        try:\n            for server in self.bot.servers.values():\n                if not server.locals.get('coalitions'):\n                    continue\n                await self.eventlistener.reset_coalitions(server, True)\n                await interaction.followup.send(_('Coalition bindings reset for all players.'), ephemeral=ephemeral)\n        except discord.Forbidden:\n            await interaction.followup.send(_('The bot is missing the \"Manage Roles\" permission!'), ephemeral=ephemeral)\n            await self.bot.audit(f'permission \"Manage Roles\" missing.', user=self.bot.member)\n\n    # New command group \"/campaign\"\n    campaign = Group(name=\"campaign\", description=_(\"Commands to manage DCS campaigns\"))\n\n    @campaign.command(name='list', description=_(\"Lists all (active) campaigns\"))\n    @app_commands.guild_only()\n    @utils.app_has_role('DCS Admin')\n    @app_commands.describe(active=_(\"Display only active campaigns\"))\n    async def _list(self, interaction: discord.Interaction, active: Optional[bool] = True):\n        report = Report(self.bot, self.plugin_name, 'active-campaigns.json' if active else 'all-campaigns.json')\n        env = await report.render()\n        # noinspection PyUnresolvedReferences\n        await interaction.response.send_message(embed=env.embed, ephemeral=utils.get_ephemeral(interaction))\n\n    @campaign.command(description=_(\"Campaign info\"))\n    @app_commands.guild_only()\n    @utils.app_has_role('DCS Admin')\n    @app_commands.autocomplete(campaign=utils.campaign_autocomplete)\n    async def info(self, interaction: discord.Interaction, campaign: str):\n        report = Report(self.bot, self.plugin_name, 'campaign.json')\n        env = await report.render(campaign=await utils.get_campaign(self, campaign), title=_('Campaign Overview'))\n        # noinspection PyUnresolvedReferences\n        await interaction.response.send_message(embed=env.embed, ephemeral=utils.get_ephemeral(interaction))\n\n    @campaign.command(description=_(\"Add a campaign\"))\n    @app_commands.guild_only()\n    @utils.app_has_role('DCS Admin')\n    async def add(self, interaction: discord.Interaction):\n        ephemeral = utils.get_ephemeral(interaction)\n        modal = CampaignModal(self.eventlistener)\n        # noinspection PyUnresolvedReferences\n        await interaction.response.send_modal(modal)\n        if await modal.wait():\n            # noinspection PyUnresolvedReferences\n            await interaction.response.send_message(_('Aborted.'), ephemeral=ephemeral)\n            return\n        try:\n            servers = await utils.server_selection(self.bus, interaction,\n                                                   title=_(\"Select all servers for this campaign\"),\n                                                   multi_select=True, ephemeral=ephemeral)\n            if not servers:\n                await interaction.followup.send(_('Aborted.'), ephemeral=True)\n                return\n            if not isinstance(servers, list):\n                servers = [servers]\n            try:\n                await self.eventlistener.campaign('add', servers=servers, name=modal.name.value,\n                                                  description=modal.description.value, start=modal.start, end=modal.end)\n                await interaction.followup.send(_(\"Campaign {} added.\").format(modal.name.value), ephemeral=ephemeral)\n            except psycopg.errors.ExclusionViolation:\n                await interaction.followup.send(_(\"A campaign is already configured for this timeframe!\"),\n                                                ephemeral=ephemeral)\n            except psycopg.errors.UniqueViolation:\n                await interaction.followup.send(_(\"A campaign with this name already exists!\"), ephemeral=ephemeral)\n        except Exception as ex:\n            self.log.exception(ex)\n\n    @campaign.command(description=_(\"Add a server to an existing campaign\\n\"))\n    @app_commands.guild_only()\n    @utils.app_has_role('DCS Admin')\n    @app_commands.autocomplete(campaign=utils.campaign_autocomplete)\n    async def add_server(self, interaction: discord.Interaction, campaign: str,\n                         server: app_commands.Transform[Server, utils.ServerTransformer]):\n        ephemeral = utils.get_ephemeral(interaction)\n        try:\n            async with self.apool.connection() as conn:\n                async with conn.transaction():\n                    await conn.execute(\"\"\"\n                        INSERT INTO campaigns_servers (campaign_id, server_name) \n                        SELECT id, %s FROM campaigns WHERE name = %s \n                        ON CONFLICT DO NOTHING\n                        \"\"\", (server.name, campaign))\n            # noinspection PyUnresolvedReferences\n            await interaction.response.send_message(\n                _(\"Server {server} added to campaign {campaign}.\").format(server=server.name, campaign=campaign),\n                ephemeral=ephemeral)\n        except psycopg.errors.UniqueViolation:\n            # noinspection PyUnresolvedReferences\n            await interaction.response.send_message(\n                _(\"Server {server} is already part of the campaign {campaign}!\").format(\n                    server=server.name, campaign=campaign), ephemeral=ephemeral)\n\n    @campaign.command(description=_(\"Delete a campaign\"))\n    @app_commands.guild_only()\n    @utils.app_has_role('DCS Admin')\n    @app_commands.autocomplete(campaign=utils.campaign_autocomplete)\n    async def delete(self, interaction: discord.Interaction, campaign: str):\n        ephemeral = utils.get_ephemeral(interaction)\n        if await utils.yn_question(interaction, _('Do you want to delete campaign \"{}\"?').format(campaign),\n                                   ephemeral=ephemeral):\n            await self.eventlistener.campaign('delete', name=campaign)\n            await interaction.followup.send(_(\"Campaign deleted.\"), ephemeral=ephemeral)\n        else:\n            await interaction.followup.send(_('Aborted.'), ephemeral=ephemeral)\n\n    @campaign.command(description=_(\"Start a campaign\"))\n    @app_commands.guild_only()\n    @utils.app_has_role('DCS Admin')\n    async def start(self, interaction: discord.Interaction, campaign: str):\n        ephemeral = utils.get_ephemeral(interaction)\n        try:\n            # noinspection PyUnresolvedReferences\n            await interaction.response.defer(ephemeral=True)\n            servers = await utils.server_selection(self.bus, interaction,\n                                                   title=_(\"Select all servers for this campaign\"),\n                                                   multi_select=True, ephemeral=ephemeral)\n            if not isinstance(servers, list):\n                servers = [servers]\n            await self.eventlistener.campaign('start', servers=servers, name=campaign)\n            await interaction.followup.send(_(\"Campaign {} started.\").format(campaign), ephemeral=ephemeral)\n        except psycopg.errors.ExclusionViolation:\n            await interaction.followup.send(_(\"A campaign is already configured for this timeframe!\"),\n                                            ephemeral=ephemeral)\n        except psycopg.errors.UniqueViolation:\n            await interaction.followup.send(_(\"A campaign with this name already exists!\"), ephemeral=ephemeral)\n\n    @campaign.command(description=_(\"Stop a campaign\"))\n    @app_commands.guild_only()\n    @utils.app_has_role('DCS Admin')\n    @app_commands.autocomplete(campaign=utils.campaign_autocomplete)\n    async def stop(self, interaction: discord.Interaction, campaign: str):\n        ephemeral = utils.get_ephemeral(interaction)\n        if await utils.yn_question(interaction, _('Do you want to stop campaign \"{}\"?').format(campaign),\n                                   ephemeral=ephemeral):\n            await self.eventlistener.campaign('stop', name=campaign)\n            await interaction.followup.send(_(\"Campaign stopped.\"), ephemeral=ephemeral)\n        else:\n            await interaction.followup.send(_('Aborted.'), ephemeral=ephemeral)\n\n    @commands.Cog.listener()\n    async def on_member_update(self, before: discord.Member, after: discord.Member):\n        # did a member change their roles?\n        if before.roles == after.roles:\n            return\n        for server in self.bot.servers.values():\n            player: Player = server.get_player(discord_id=after.id)\n            if player:\n                server.send_to_dcs({\n                    'command': 'uploadUserRoles',\n                    'id': player.id,\n                    'ucid': player.ucid,\n                    'roles': [x.id for x in after.roles]\n                })\n\n    async def _create_embed(self, message: discord.Message) -> None:\n        async with aiohttp.ClientSession() as session:\n            async with session.get(message.attachments[0].url) as response:\n                if response.status == 200:\n                    data = await response.json(encoding=\"utf-8\")\n                    embed = utils.format_embed(data, bot=self.bot, bus=self.bus, node=self.bus.node,\n                                               user=message.author)\n                    msg = None\n                    if 'message_id' in data:\n                        try:\n                            msg = await message.channel.fetch_message(int(data['message_id']))\n                            await msg.edit(embed=embed)\n                        except discord.errors.NotFound:\n                            msg = None\n                        except discord.errors.DiscordException as ex:\n                            self.log.exception(ex)\n                            await message.channel.send(_('Error while updating embed!'))\n                            return\n                    if not msg:\n                        await message.channel.send(embed=embed)\n                    await message.delete()\n                else:\n                    await message.channel.send(_('Error {} while reading JSON file!').format(response.status))\n\n    async def _upload_lua(self, message: discord.Message) -> int:\n        # check if the upload happens in the servers admin channel (if provided)\n        server: Server = self.bot.get_server(message, admin_only=True)\n        ctx = await self.bot.get_context(message)\n        if not server:\n            # check if there is a central admin channel configured\n            if self.bot.locals.get('admin_channel', 0) == message.channel.id:\n                try:\n                    server = await utils.server_selection(\n                        self.bus, ctx, title=_(\"To which server do you want to upload this LUA to?\"))\n                    if not server:\n                        await ctx.send(_('Aborted.'))\n                        return -1\n                except Exception as ex:\n                    self.log.exception(ex)\n                    return -1\n            else:\n                return -1\n        num = 0\n        for attachment in message.attachments:\n            if not attachment.filename.endswith('.lua'):\n                continue\n            filename = os.path.normpath(os.path.join(await server.get_missions_dir(), 'Scripts', attachment.filename))\n            rc = await server.node.write_file(filename, attachment.url)\n            if rc == UploadStatus.OK:\n                num += 1\n                continue\n            if not await utils.yn_question(ctx, _('File exists. Do you want to overwrite it?')):\n                await message.channel.send(_('Aborted.'))\n                continue\n            rc = await server.node.write_file(filename, attachment.url, overwrite=True)\n            if rc != UploadStatus.OK:\n                await message.channel.send(_(\"File {} could not be uploaded.\").format(attachment.filename))\n            else:\n                num += 1\n        return num\n\n    @commands.Cog.listener()\n    async def on_message(self, message: discord.Message):\n        # ignore bot messages\n        if message.author.bot:\n            return\n        if message.attachments:\n            if (message.attachments[0].filename.endswith('.json') and\n                    utils.check_roles(self.bot.roles['Admin'], message.author)):\n                await self._create_embed(message)\n            elif (message.attachments[0].filename.endswith('.lua') and\n                  utils.check_roles(self.bot.roles['DCS Admin'], message.author)):\n                num = await self._upload_lua(message)\n                if num > 0:\n                    await message.channel.send(\n                        _(\"{num} LUA files uploaded. You can load any of them with {command} now.\").format(\n                            num=num, command=(await utils.get_command(self.bot, name='do_script_file')).mention\n                        )\n                    )\n                    await message.delete()\n        else:\n            for server in self.bot.servers.values():\n                if server.status != Status.RUNNING:\n                    continue\n                if 'coalitions' in server.locals:\n                    sides = utils.get_sides(self.bot, message, server)\n                    if Coalition.BLUE in sides and server.channels[Channel.COALITION_BLUE_CHAT] == message.channel.id:\n                        # TODO: ignore messages for now, as DCS does not understand the coalitions yet\n                        # server.sendChatMessage(Coalition.BLUE, message.content, message.author.display_name)\n                        pass\n                    elif Coalition.RED in sides and server.channels[Channel.COALITION_RED_CHAT] == message.channel.id:\n                        # TODO:  ignore messages for now, as DCS does not understand the coalitions yet\n                        # server.sendChatMessage(Coalition.RED, message.content, message.author.display_name)\n                        pass\n                if server.channels[Channel.CHAT] and server.channels[Channel.CHAT] == message.channel.id:\n                    if message.content.startswith('/') is False:\n                        server.sendChatMessage(Coalition.ALL, message.content, message.author.display_name)\n\n\nasync def setup(bot: DCSServerBot):\n    await bot.add_cog(GameMaster(bot, GameMasterEventListener))\n"}, "/plugins/greenieboard/commands.py": {"changes": [{"diff": "\n             for ucid in ucids:\n                 await conn.execute('DELETE FROM greenieboard WHERE player_ucid = %s', (ucid,))\n         elif days > -1:\n-            await conn.execute(f\"DELETE FROM greenieboard WHERE time < (DATE(NOW()) - interval '{days} days')\")\n+            await conn.execute(\"DELETE FROM greenieboard WHERE time < (DATE(NOW()) - %s::interval)\", (f'{days} days', ))\n         self.log.debug('Greenieboard pruned.')\n \n     async def update_ucid(self, conn: psycopg.AsyncConnection, old_ucid: str, new_ucid: str) ->", "add": 1, "remove": 1, "filename": "/plugins/greenieboard/commands.py", "badparts": ["            await conn.execute(f\"DELETE FROM greenieboard WHERE time < (DATE(NOW()) - interval '{days} days')\")"], "goodparts": ["            await conn.execute(\"DELETE FROM greenieboard WHERE time < (DATE(NOW()) - %s::interval)\", (f'{days} days', ))"]}], "source": "\nimport discord import os import psycopg import shutil from core import Plugin, PluginRequiredError, utils, PaginationReport, Report, Group, Server, DEFAULT_TAG, \\ get_translation from discord import SelectOption, app_commands from discord.app_commands import Range from psycopg.rows import dict_row from services import DCSServerBot from typing import Optional, Union from.listener import GreenieBoardEventListener from.views import TrapView _=get_translation(__name__.split('.')[1]) class GreenieBoard(Plugin): def read_locals(self) -> dict: config=super().read_locals() if not config: self.log.info('No greenieboard.yaml found, copying the sample.') shutil.copyfile('samples/plugins/greenieboard.yaml', os.path.join(self.node.config_dir, 'plugins', 'greenieboard.yaml')) config=super().read_locals() return config def get_config(self, server: Optional[Server]=None, *, plugin_name: Optional[str]=None, use_cache: Optional[bool]=True) -> dict: if plugin_name: return super().get_config(server, plugin_name=plugin_name, use_cache=use_cache) if not server: return self.locals.get(DEFAULT_TAG,{}) if server.node.name not in self._config: self._config[server.node.name]={} if server.instance.name not in self._config[server.node.name] or not use_cache: default, specific=self.get_base_config(server) if 'persistent_board' in default: del default['persistent_board'] if 'persistent_channel' in default: del default['persistent_channel'] self._config[server.node.name][server.instance.name]=default | specific return self._config[server.node.name][server.instance.name] async def prune(self, conn: psycopg.AsyncConnection, *, days: int=-1, ucids: list[str]=None, server: Optional[str]=None) -> None: self.log.debug('Pruning Greenieboard...') if ucids: for ucid in ucids: await conn.execute('DELETE FROM greenieboard WHERE player_ucid=%s',(ucid,)) elif days > -1: await conn.execute(f\"DELETE FROM greenieboard WHERE time <(DATE(NOW()) -interval '{days} days')\") self.log.debug('Greenieboard pruned.') async def update_ucid(self, conn: psycopg.AsyncConnection, old_ucid: str, new_ucid: str) -> None: await conn.execute('UPDATE greenieboard SET player_ucid=%s WHERE player_ucid=%s',(new_ucid, old_ucid)) traps=Group(name=\"traps\", description=_(\"Commands to display and manage carrier traps\")) @traps.command(description=_('Show carrier landing qualifications')) @app_commands.guild_only() @utils.app_has_role('DCS') async def info(self, interaction: discord.Interaction, user: Optional[app_commands.Transform[Union[str, discord.Member], utils.UserTransformer]]=None): def format_landing(landing: dict) -> str: return(f\"{landing['time']:%y-%m-%d %H:%M:%S} -\" f\"{landing['unit_type']}@{landing['place']}:{landing['grade']}\") ephemeral=utils.get_ephemeral(interaction) if not user: user=interaction.user if isinstance(user, str): ucid=user user=await self.bot.get_member_or_name_by_ucid(ucid) if isinstance(user, discord.Member): name=user.display_name else: name=user else: ucid=await self.bot.get_ucid_by_member(user) name=user.display_name num_landings=max(self.get_config().get('num_landings', 25), 25) async with self.apool.connection() as conn: async with conn.cursor(row_factory=dict_row) as cursor: await cursor.execute(\"\"\" SELECT id, p.name, g.grade, g.unit_type, g.comment, g.place, g.trapcase, g.wire, g.time, g.points, g.trapsheet FROM greenieboard g, players p WHERE p.ucid=%s AND g.player_ucid=p.ucid ORDER BY ID DESC LIMIT %s \"\"\",(ucid, num_landings)) if cursor.rowcount==0: await interaction.response.send_message(_('No carrier landings recorded for this user.'), ephemeral=True) return landings=[dict(row) async for row in cursor] report=Report(self.bot, self.plugin_name, 'traps.json') env=await report.render(ucid=ucid, name=utils.escape_string(name)) n=await utils.selection(interaction, embed=env.embed, placeholder=_(\"Select a trap for details\"), options=[ SelectOption(label=format_landing(x), value=str(idx), default=(idx==0)) for idx, x in enumerate(landings) ], ephemeral=ephemeral) if n: report=PaginationReport(self.bot, interaction, self.plugin_name, 'lsoRating.json', keep_image=True) await report.render(landings=landings, start_index=int(n), formatter=format_landing) @traps.command(description=_('Display the current Greenieboard')) @utils.app_has_role('DCS') @app_commands.guild_only() @app_commands.rename(num_rows='rows') @app_commands.autocomplete(squadron_id=utils.squadron_autocomplete) @app_commands.rename(squadron_id=\"squadron\") async def board(self, interaction: discord.Interaction, num_rows: Optional[Range[int, 5, 20]]=10, squadron_id: Optional[int]=None): report=PaginationReport(self.bot, interaction, self.plugin_name, 'greenieboard.json') squadron=(await utils.get_squadron(self.bot, squadron_id=squadron_id)) if squadron_id else None await report.render(server_name=None, num_rows=num_rows, squadron=squadron) @traps.command(description=_('Adds a trap to the Greenieboard')) @app_commands.guild_only() @utils.app_has_role('DCS Admin') async def add(self, interaction: discord.Interaction, user: app_commands.Transform[Union[str, discord.Member], utils.UserTransformer]): ephemeral=utils.get_ephemeral(interaction) config=self.get_config() if 'ratings' not in config: await interaction.response.send_message( _('You need to specify ratings in your greenieboard.yaml to use{}!').format( (await utils.get_command(self.bot, group='traps', name='add')).mention ), ephemeral=True) return view=TrapView(self.bot, config, user) await interaction.response.send_message(view=view) try: await view.wait() if view.success: await interaction.followup.send(_('Trap added.'), ephemeral=ephemeral) else: await interaction.followup.send(_('Aborted.'), ephemeral=ephemeral) finally: await interaction.delete_original_response() async def setup(bot: DCSServerBot): if 'missionstats' not in bot.plugins: raise PluginRequiredError('missionstats') await bot.add_cog(GreenieBoard(bot, GreenieBoardEventListener)) ", "sourceWithComments": "import discord\nimport os\nimport psycopg\nimport shutil\n\nfrom core import Plugin, PluginRequiredError, utils, PaginationReport, Report, Group, Server, DEFAULT_TAG, \\\n    get_translation\nfrom discord import SelectOption, app_commands\nfrom discord.app_commands import Range\nfrom psycopg.rows import dict_row\nfrom services import DCSServerBot\nfrom typing import Optional, Union\n\nfrom .listener import GreenieBoardEventListener\nfrom .views import TrapView\n\n_ = get_translation(__name__.split('.')[1])\n\n\nclass GreenieBoard(Plugin):\n\n    def read_locals(self) -> dict:\n        config = super().read_locals()\n        if not config:\n            self.log.info('No greenieboard.yaml found, copying the sample.')\n            shutil.copyfile('samples/plugins/greenieboard.yaml',\n                            os.path.join(self.node.config_dir, 'plugins', 'greenieboard.yaml'))\n            config = super().read_locals()\n        return config\n\n    def get_config(self, server: Optional[Server] = None, *, plugin_name: Optional[str] = None,\n                   use_cache: Optional[bool] = True) -> dict:\n        # retrieve the config from another plugin\n        if plugin_name:\n            return super().get_config(server, plugin_name=plugin_name, use_cache=use_cache)\n        if not server:\n            return self.locals.get(DEFAULT_TAG, {})\n        if server.node.name not in self._config:\n            self._config[server.node.name] = {}\n        if server.instance.name not in self._config[server.node.name] or not use_cache:\n            default, specific = self.get_base_config(server)\n            if 'persistent_board' in default:\n                del default['persistent_board']\n            if 'persistent_channel' in default:\n                del default['persistent_channel']\n            self._config[server.node.name][server.instance.name] = default | specific\n        return self._config[server.node.name][server.instance.name]\n\n    async def prune(self, conn: psycopg.AsyncConnection, *, days: int = -1, ucids: list[str] = None,\n                    server: Optional[str] = None) -> None:\n        self.log.debug('Pruning Greenieboard ...')\n        if ucids:\n            for ucid in ucids:\n                await conn.execute('DELETE FROM greenieboard WHERE player_ucid = %s', (ucid,))\n        elif days > -1:\n            await conn.execute(f\"DELETE FROM greenieboard WHERE time < (DATE(NOW()) - interval '{days} days')\")\n        self.log.debug('Greenieboard pruned.')\n\n    async def update_ucid(self, conn: psycopg.AsyncConnection, old_ucid: str, new_ucid: str) -> None:\n        await conn.execute('UPDATE greenieboard SET player_ucid = %s WHERE player_ucid = %s', (new_ucid, old_ucid))\n\n    # New command group \"/traps\"\n    traps = Group(name=\"traps\", description=_(\"Commands to display and manage carrier traps\"))\n\n    @traps.command(description=_('Show carrier landing qualifications'))\n    @app_commands.guild_only()\n    @utils.app_has_role('DCS')\n    async def info(self, interaction: discord.Interaction,\n                   user: Optional[app_commands.Transform[Union[str, discord.Member], utils.UserTransformer]] = None):\n        def format_landing(landing: dict) -> str:\n            return (f\"{landing['time']:%y-%m-%d %H:%M:%S} - \"\n                    f\"{landing['unit_type']}@{landing['place']}: {landing['grade']}\")\n\n        ephemeral = utils.get_ephemeral(interaction)\n        if not user:\n            user = interaction.user\n        if isinstance(user, str):\n            ucid = user\n            user = await self.bot.get_member_or_name_by_ucid(ucid)\n            if isinstance(user, discord.Member):\n                name = user.display_name\n            else:\n                name = user\n        else:\n            ucid = await self.bot.get_ucid_by_member(user)\n            name = user.display_name\n        num_landings = max(self.get_config().get('num_landings', 25), 25)\n        async with self.apool.connection() as conn:\n            async with conn.cursor(row_factory=dict_row) as cursor:\n                await cursor.execute(\"\"\"\n                    SELECT id, p.name, g.grade, g.unit_type, g.comment, g.place, g.trapcase, g.wire, \n                           g.time, g.points, g.trapsheet \n                    FROM greenieboard g, players p \n                    WHERE p.ucid = %s AND g.player_ucid = p.ucid ORDER BY ID DESC LIMIT %s\n                \"\"\", (ucid, num_landings))\n                if cursor.rowcount == 0:\n                    # noinspection PyUnresolvedReferences\n                    await interaction.response.send_message(_('No carrier landings recorded for this user.'),\n                                                            ephemeral=True)\n                    return\n                landings = [dict(row) async for row in cursor]\n        report = Report(self.bot, self.plugin_name, 'traps.json')\n        env = await report.render(ucid=ucid, name=utils.escape_string(name))\n        n = await utils.selection(interaction, embed=env.embed, placeholder=_(\"Select a trap for details\"),\n                                  options=[\n                                      SelectOption(label=format_landing(x), value=str(idx), default=(idx == 0))\n                                      for idx, x in enumerate(landings)\n                                  ], ephemeral=ephemeral)\n        if n:\n            report = PaginationReport(self.bot, interaction, self.plugin_name, 'lsoRating.json', keep_image=True)\n            await report.render(landings=landings, start_index=int(n), formatter=format_landing)\n\n    @traps.command(description=_('Display the current Greenieboard'))\n    @utils.app_has_role('DCS')\n    @app_commands.guild_only()\n    @app_commands.rename(num_rows='rows')\n    @app_commands.autocomplete(squadron_id=utils.squadron_autocomplete)\n    @app_commands.rename(squadron_id=\"squadron\")\n    async def board(self, interaction: discord.Interaction,\n                    num_rows: Optional[Range[int, 5, 20]] = 10,\n                    squadron_id: Optional[int] = None):\n        report = PaginationReport(self.bot, interaction, self.plugin_name, 'greenieboard.json')\n        squadron = (await utils.get_squadron(self.bot, squadron_id=squadron_id)) if squadron_id else None\n        await report.render(server_name=None, num_rows=num_rows, squadron=squadron)\n\n    @traps.command(description=_('Adds a trap to the Greenieboard'))\n    @app_commands.guild_only()\n    @utils.app_has_role('DCS Admin')\n    async def add(self, interaction: discord.Interaction,\n                  user: app_commands.Transform[Union[str, discord.Member], utils.UserTransformer]):\n        ephemeral = utils.get_ephemeral(interaction)\n        config = self.get_config()\n        if 'ratings' not in config:\n            # noinspection PyUnresolvedReferences\n            await interaction.response.send_message(\n                _('You need to specify ratings in your greenieboard.yaml to use {}!').format(\n                    (await utils.get_command(self.bot, group='traps', name='add')).mention\n                ), ephemeral=True)\n            return\n\n        view = TrapView(self.bot, config, user)\n        # noinspection PyUnresolvedReferences\n        await interaction.response.send_message(view=view)\n        try:\n            await view.wait()\n            if view.success:\n                await interaction.followup.send(_('Trap added.'), ephemeral=ephemeral)\n            else:\n                await interaction.followup.send(_('Aborted.'), ephemeral=ephemeral)\n        finally:\n            await interaction.delete_original_response()\n\n\nasync def setup(bot: DCSServerBot):\n    if 'missionstats' not in bot.plugins:\n        raise PluginRequiredError('missionstats')\n    await bot.add_cog(GreenieBoard(bot, GreenieBoardEventListener))\n"}, "/plugins/missionstats/commands.py": {"changes": [{"diff": "\n             for ucid in ucids:\n                 await conn.execute('DELETE FROM missionstats WHERE init_id = %s', (ucid,))\n         elif days > -1:\n-            await conn.execute(f\"DELETE FROM missionstats WHERE time < (DATE(NOW()) - interval '{days} days')\")\n+            await conn.execute(\"DELETE FROM missionstats WHERE time < (DATE(NOW()) - %s::interval)\", (f'{days} days', ))\n         if server:\n             await conn.execute(\"\"\"\n                 DELETE FROM missionstats WHERE mission_", "add": 1, "remove": 1, "filename": "/plugins/missionstats/commands.py", "badparts": ["            await conn.execute(f\"DELETE FROM missionstats WHERE time < (DATE(NOW()) - interval '{days} days')\")"], "goodparts": ["            await conn.execute(\"DELETE FROM missionstats WHERE time < (DATE(NOW()) - %s::interval)\", (f'{days} days', ))"]}], "source": "\nimport discord import psycopg from core import Plugin, PluginRequiredError, utils, Report, Status, Server, command, get_translation from discord import app_commands from plugins.userstats.filter import StatisticsFilter, MissionStatisticsFilter, PeriodTransformer, PeriodFilter, \\ CampaignFilter, MissionFilter from services import DCSServerBot from typing import Optional, Union from.listener import MissionStatisticsEventListener _=get_translation(__name__.split('.')[1]) async def player_modules_autocomplete(interaction: discord.Interaction, current: str) -> list[app_commands.Choice[str]]: async def get_modules(ucid: str) -> list[str]: async with interaction.client.apool.connection() as conn: return[row[0] async for row in await conn.execute(\"\"\" SELECT DISTINCT slot, COUNT(*) FROM statistics WHERE player_ucid= %s AND slot NOT IN('', '?', '''forward_observer', 'instructor', 'observer', 'artillery_commander') GROUP BY 1 ORDER BY 2 DESC \"\"\",(ucid,))] try: user=await utils.UserTransformer().transform(interaction, utils.get_interaction_param(interaction, \"user\")) if not user: return[] if isinstance(user, str): ucid=user else: ucid=await interaction.client.get_ucid_by_member(user) if not ucid: return[] ret=[ app_commands.Choice(name=x, value=x) for x in await get_modules(ucid) if not current or current.casefold() in x.casefold() ] return ret[:25] except Exception as ex: interaction.client.log.exception(ex) class MissionStatistics(Plugin): async def prune(self, conn: psycopg.AsyncConnection, *, days: int=-1, ucids: list[str]=None, server: Optional[str]=None) -> None: self.log.debug('Pruning Missionstats...') if ucids: for ucid in ucids: await conn.execute('DELETE FROM missionstats WHERE init_id=%s',(ucid,)) elif days > -1: await conn.execute(f\"DELETE FROM missionstats WHERE time <(DATE(NOW()) -interval '{days} days')\") if server: await conn.execute(\"\"\" DELETE FROM missionstats WHERE mission_id in( SELECT id FROM missions WHERE server_name=%s ) \"\"\",(server,)) await conn.execute(\"\"\" DELETE FROM missionstats WHERE mission_id NOT IN( SELECT id FROM missions ) \"\"\") self.log.debug('Missionstats pruned.') async def update_ucid(self, conn: psycopg.AsyncConnection, old_ucid: str, new_ucid: str) -> None: await conn.execute(\"UPDATE missionstats SET init_id=%s WHERE init_id=%s\",(new_ucid, old_ucid)) await conn.execute(\"UPDATE missionstats SET target_id=%s WHERE target_id=%s\",(new_ucid, old_ucid)) @command(description=_('Display Mission Statistics')) @app_commands.guild_only() @utils.app_has_role('DCS') async def missionstats(self, interaction: discord.Interaction, server: app_commands.Transform[Server, utils.ServerTransformer( status=[Status.RUNNING, Status.PAUSED])]): if server.name not in self.bot.mission_stats: await interaction.response.send_message( _(\"Mission statistics not initialized yet or not active for this server.\"), ephemeral=True) return await interaction.response.defer(ephemeral=True) stats=self.bot.mission_stats[server.name] report=Report(self.bot, self.plugin_name, 'missionstats.json') env=await report.render(stats=stats, mission_id=server.mission_id, sides=utils.get_sides(interaction.client, interaction, server)) await interaction.followup.send(embed=env.embed, ephemeral=utils.get_ephemeral(interaction)) @command(description=_('Display statistics about sorties')) @app_commands.guild_only() @utils.app_has_role('DCS') async def sorties(self, interaction: discord.Interaction, user: Optional[app_commands.Transform[Union[str, discord.Member], utils.UserTransformer]], period: Optional[app_commands.Transform[ StatisticsFilter, PeriodTransformer(flt=[MissionStatisticsFilter])] ]=MissionStatisticsFilter()): if not user: user=interaction.user if isinstance(user, str): ucid=user user=await self.bot.get_member_or_name_by_ucid(ucid) if isinstance(user, discord.Member): name=user.display_name else: name=user else: ucid=await self.bot.get_ucid_by_member(user) name=user.display_name await interaction.response.defer(ephemeral=True) report=Report(self.bot, self.plugin_name, 'sorties.json') env=await report.render(ucid=ucid, member_name=name, flt=period) await interaction.followup.send(embed=env.embed, ephemeral=True) @command(description=_('Module statistics')) @app_commands.guild_only() @utils.app_has_role('DCS') @app_commands.autocomplete(module=player_modules_autocomplete) async def modulestats(self, interaction: discord.Interaction, user: Optional[app_commands.Transform[Union[str, discord.Member], utils.UserTransformer]], module: Optional[str], period: Optional[app_commands.Transform[ StatisticsFilter, PeriodTransformer( flt=[PeriodFilter, CampaignFilter, MissionFilter] )]]=PeriodFilter()): if not user: user=interaction.user if not module: await interaction.response.send_message(_('You need to chose a module!'), ephemeral=True) return if isinstance(user, str): ucid=user user=await self.bot.get_member_or_name_by_ucid(ucid) if isinstance(user, discord.Member): name=user.display_name else: name=user else: ucid=await self.bot.get_ucid_by_member(user) name=user.display_name await interaction.response.defer(ephemeral=True) report=Report(self.bot, self.plugin_name, 'modulestats.json') env=await report.render(member_name=name, ucid=ucid, module=module, flt=period) await interaction.followup.send(embed=env.embed, ephemeral=True) @command(description=_('Refueling statistics')) @app_commands.guild_only() @utils.app_has_role('DCS') async def refuelings(self, interaction: discord.Interaction, user: Optional[app_commands.Transform[Union[str, discord.Member], utils.UserTransformer]], period: Optional[app_commands.Transform[ StatisticsFilter, PeriodTransformer(flt=[MissionStatisticsFilter])] ]=MissionStatisticsFilter()): if not user: user=interaction.user if isinstance(user, str): ucid=user user=await self.bot.get_member_or_name_by_ucid(ucid) if isinstance(user, discord.Member): name=user.display_name else: name=user else: ucid=await self.bot.get_ucid_by_member(user) name=user.display_name await interaction.response.defer(ephemeral=True) report=Report(self.bot, self.plugin_name, 'refuelings.json') env=await report.render(ucid=ucid, member_name=name, flt=period) await interaction.followup.send(embed=env.embed, ephemeral=True) @command(description=_('Find who killed you most')) @app_commands.guild_only() @utils.app_has_role('DCS') async def nemesis(self, interaction: discord.Interaction, user: Optional[app_commands.Transform[Union[str, discord.Member], utils.UserTransformer]]): if not user: user=interaction.user if isinstance(user, str): ucid=user user=await self.bot.get_member_or_name_by_ucid(ucid) if isinstance(user, discord.Member): name=user.display_name else: name=user else: ucid=await self.bot.get_ucid_by_member(user) name=user.display_name await interaction.response.defer(ephemeral=True) report=Report(self.bot, self.plugin_name, 'nemesis.json') env=await report.render(ucid=ucid, member_name=name) await interaction.followup.send(embed=env.embed, ephemeral=True) @command(description=_(\"Find who you've killed the most\")) @app_commands.guild_only() @utils.app_has_role('DCS') async def antagonist(self, interaction: discord.Interaction, user: Optional[app_commands.Transform[Union[str, discord.Member], utils.UserTransformer]]): if not user: user=interaction.user if isinstance(user, str): ucid=user user=await self.bot.get_member_or_name_by_ucid(ucid) if isinstance(user, discord.Member): name=user.display_name else: name=user else: ucid=await self.bot.get_ucid_by_member(user) name=user.display_name await interaction.response.defer(ephemeral=True) report=Report(self.bot, self.plugin_name, 'antagonist.json') env=await report.render(ucid=ucid, member_name=name) await interaction.followup.send(embed=env.embed, ephemeral=True) async def setup(bot: DCSServerBot): if 'userstats' not in bot.plugins: raise PluginRequiredError('userstats') await bot.add_cog(MissionStatistics(bot, MissionStatisticsEventListener)) ", "sourceWithComments": "import discord\nimport psycopg\n\nfrom core import Plugin, PluginRequiredError, utils, Report, Status, Server, command, get_translation\nfrom discord import app_commands\nfrom plugins.userstats.filter import StatisticsFilter, MissionStatisticsFilter, PeriodTransformer, PeriodFilter, \\\n    CampaignFilter, MissionFilter\nfrom services import DCSServerBot\nfrom typing import Optional, Union\n\nfrom .listener import MissionStatisticsEventListener\n\n_ = get_translation(__name__.split('.')[1])\n\n\nasync def player_modules_autocomplete(interaction: discord.Interaction, current: str) -> list[app_commands.Choice[str]]:\n\n    async def get_modules(ucid: str) -> list[str]:\n        async with interaction.client.apool.connection() as conn:\n            return [row[0] async for row in await conn.execute(\"\"\"\n                SELECT DISTINCT slot, COUNT(*) FROM statistics \n                WHERE player_ucid =  %s \n                AND slot NOT IN ('', '?', '''forward_observer', 'instructor', 'observer', 'artillery_commander') \n                GROUP BY 1 ORDER BY 2 DESC\n            \"\"\", (ucid, ))]\n\n    try:\n        user = await utils.UserTransformer().transform(interaction, utils.get_interaction_param(interaction, \"user\"))\n        if not user:\n            return []\n        if isinstance(user, str):\n            ucid = user\n        else:\n            ucid = await interaction.client.get_ucid_by_member(user)\n        if not ucid:\n            return []\n        ret = [\n            app_commands.Choice(name=x, value=x)\n            for x in await get_modules(ucid)\n            if not current or current.casefold() in x.casefold()\n        ]\n        return ret[:25]\n    except Exception as ex:\n        interaction.client.log.exception(ex)\n\n\nclass MissionStatistics(Plugin):\n\n    async def prune(self, conn: psycopg.AsyncConnection, *, days: int = -1, ucids: list[str] = None,\n                    server: Optional[str] = None) -> None:\n        self.log.debug('Pruning Missionstats ...')\n        if ucids:\n            for ucid in ucids:\n                await conn.execute('DELETE FROM missionstats WHERE init_id = %s', (ucid,))\n        elif days > -1:\n            await conn.execute(f\"DELETE FROM missionstats WHERE time < (DATE(NOW()) - interval '{days} days')\")\n        if server:\n            await conn.execute(\"\"\"\n                DELETE FROM missionstats WHERE mission_id in (\n                    SELECT id FROM missions WHERE server_name = %s\n                )\n            \"\"\", (server, ))\n            await conn.execute(\"\"\"\n                DELETE FROM missionstats WHERE mission_id NOT IN (\n                    SELECT id FROM missions\n                )\n            \"\"\")\n        self.log.debug('Missionstats pruned.')\n\n    async def update_ucid(self, conn: psycopg.AsyncConnection, old_ucid: str, new_ucid: str) -> None:\n        await conn.execute(\"UPDATE missionstats SET init_id = %s WHERE init_id = %s\", (new_ucid, old_ucid))\n        await conn.execute(\"UPDATE missionstats SET target_id = %s WHERE target_id = %s\", (new_ucid, old_ucid))\n\n    @command(description=_('Display Mission Statistics'))\n    @app_commands.guild_only()\n    @utils.app_has_role('DCS')\n    async def missionstats(self, interaction: discord.Interaction,\n                           server: app_commands.Transform[Server, utils.ServerTransformer(\n                               status=[Status.RUNNING, Status.PAUSED])]):\n        if server.name not in self.bot.mission_stats:\n            # noinspection PyUnresolvedReferences\n            await interaction.response.send_message(\n                _(\"Mission statistics not initialized yet or not active for this server.\"), ephemeral=True)\n            return\n        # noinspection PyUnresolvedReferences\n        await interaction.response.defer(ephemeral=True)\n        stats = self.bot.mission_stats[server.name]\n        report = Report(self.bot, self.plugin_name, 'missionstats.json')\n        env = await report.render(stats=stats, mission_id=server.mission_id,\n                                  sides=utils.get_sides(interaction.client, interaction, server))\n        await interaction.followup.send(embed=env.embed, ephemeral=utils.get_ephemeral(interaction))\n\n    @command(description=_('Display statistics about sorties'))\n    @app_commands.guild_only()\n    @utils.app_has_role('DCS')\n    async def sorties(self, interaction: discord.Interaction,\n                      user: Optional[app_commands.Transform[Union[str, discord.Member], utils.UserTransformer]],\n                      period: Optional[app_commands.Transform[\n                          StatisticsFilter, PeriodTransformer(flt=[MissionStatisticsFilter])]\n                      ] = MissionStatisticsFilter()):\n        if not user:\n            user = interaction.user\n        if isinstance(user, str):\n            ucid = user\n            user = await self.bot.get_member_or_name_by_ucid(ucid)\n            if isinstance(user, discord.Member):\n                name = user.display_name\n            else:\n                name = user\n        else:\n            ucid = await self.bot.get_ucid_by_member(user)\n            name = user.display_name\n        # noinspection PyUnresolvedReferences\n        await interaction.response.defer(ephemeral=True)\n        report = Report(self.bot, self.plugin_name, 'sorties.json')\n        env = await report.render(ucid=ucid, member_name=name, flt=period)\n        await interaction.followup.send(embed=env.embed, ephemeral=True)\n\n    @command(description=_('Module statistics'))\n    @app_commands.guild_only()\n    @utils.app_has_role('DCS')\n    @app_commands.autocomplete(module=player_modules_autocomplete)\n    async def modulestats(self, interaction: discord.Interaction,\n                          user: Optional[app_commands.Transform[Union[str, discord.Member], utils.UserTransformer]],\n                          module: Optional[str],\n                          period: Optional[app_commands.Transform[\n                              StatisticsFilter, PeriodTransformer(\n                                  flt=[PeriodFilter, CampaignFilter, MissionFilter]\n                              )]] = PeriodFilter()):\n        if not user:\n            user = interaction.user\n        if not module:\n            # noinspection PyUnresolvedReferences\n            await interaction.response.send_message(_('You need to chose a module!'), ephemeral=True)\n            return\n        if isinstance(user, str):\n            ucid = user\n            user = await self.bot.get_member_or_name_by_ucid(ucid)\n            if isinstance(user, discord.Member):\n                name = user.display_name\n            else:\n                name = user\n        else:\n            ucid = await self.bot.get_ucid_by_member(user)\n            name = user.display_name\n        # noinspection PyUnresolvedReferences\n        await interaction.response.defer(ephemeral=True)\n        report = Report(self.bot, self.plugin_name, 'modulestats.json')\n        env = await report.render(member_name=name, ucid=ucid, module=module, flt=period)\n        await interaction.followup.send(embed=env.embed, ephemeral=True)\n\n    @command(description=_('Refueling statistics'))\n    @app_commands.guild_only()\n    @utils.app_has_role('DCS')\n    async def refuelings(self, interaction: discord.Interaction,\n                         user: Optional[app_commands.Transform[Union[str, discord.Member], utils.UserTransformer]],\n                         period: Optional[app_commands.Transform[\n                             StatisticsFilter, PeriodTransformer(flt=[MissionStatisticsFilter])]\n                         ] = MissionStatisticsFilter()):\n        if not user:\n            user = interaction.user\n        if isinstance(user, str):\n            ucid = user\n            user = await self.bot.get_member_or_name_by_ucid(ucid)\n            if isinstance(user, discord.Member):\n                name = user.display_name\n            else:\n                name = user\n        else:\n            ucid = await self.bot.get_ucid_by_member(user)\n            name = user.display_name\n        # noinspection PyUnresolvedReferences\n        await interaction.response.defer(ephemeral=True)\n        report = Report(self.bot, self.plugin_name, 'refuelings.json')\n        env = await report.render(ucid=ucid, member_name=name, flt=period)\n        await interaction.followup.send(embed=env.embed, ephemeral=True)\n\n    @command(description=_('Find who killed you most'))\n    @app_commands.guild_only()\n    @utils.app_has_role('DCS')\n    async def nemesis(self, interaction: discord.Interaction,\n                      user: Optional[app_commands.Transform[Union[str, discord.Member], utils.UserTransformer]]):\n        if not user:\n            user = interaction.user\n        if isinstance(user, str):\n            ucid = user\n            user = await self.bot.get_member_or_name_by_ucid(ucid)\n            if isinstance(user, discord.Member):\n                name = user.display_name\n            else:\n                name = user\n        else:\n            ucid = await self.bot.get_ucid_by_member(user)\n            name = user.display_name\n        # noinspection PyUnresolvedReferences\n        await interaction.response.defer(ephemeral=True)\n        report = Report(self.bot, self.plugin_name, 'nemesis.json')\n        env = await report.render(ucid=ucid, member_name=name)\n        await interaction.followup.send(embed=env.embed, ephemeral=True)\n\n    @command(description=_(\"Find who you've killed the most\"))\n    @app_commands.guild_only()\n    @utils.app_has_role('DCS')\n    async def antagonist(self, interaction: discord.Interaction,\n                         user: Optional[app_commands.Transform[Union[str, discord.Member], utils.UserTransformer]]):\n        if not user:\n            user = interaction.user\n        if isinstance(user, str):\n            ucid = user\n            user = await self.bot.get_member_or_name_by_ucid(ucid)\n            if isinstance(user, discord.Member):\n                name = user.display_name\n            else:\n                name = user\n        else:\n            ucid = await self.bot.get_ucid_by_member(user)\n            name = user.display_name\n        # noinspection PyUnresolvedReferences\n        await interaction.response.defer(ephemeral=True)\n        report = Report(self.bot, self.plugin_name, 'antagonist.json')\n        env = await report.render(ucid=ucid, member_name=name)\n        await interaction.followup.send(embed=env.embed, ephemeral=True)\n\n\nasync def setup(bot: DCSServerBot):\n    if 'userstats' not in bot.plugins:\n        raise PluginRequiredError('userstats')\n    await bot.add_cog(MissionStatistics(bot, MissionStatisticsEventListener))\n"}}, "msg": "CHANGES:\n- Removed one deprecated Python call.\n- Some code cleanups\n- Fixed some places for possible SQL injections"}, "ef49bbfa7d492a81f300041a10d8abdd8abb8773": {"url": "https://api.github.com/repos/Special-K-s-Flightsim-Bots/DCSServerBot/commits/ef49bbfa7d492a81f300041a10d8abdd8abb8773", "html_url": "https://github.com/Special-K-s-Flightsim-Bots/DCSServerBot/commit/ef49bbfa7d492a81f300041a10d8abdd8abb8773", "sha": "ef49bbfa7d492a81f300041a10d8abdd8abb8773", "keyword": "sql injection change", "diff": "diff --git a/services/scheduler/actions.py b/services/scheduler/actions.py\nindex 985eec760..4153e519a 100644\n--- a/services/scheduler/actions.py\n+++ b/services/scheduler/actions.py\n@@ -22,7 +22,7 @@ async def report(file: str, channel: int, node: Node, persistent: Optional[bool]\n         await bot.get_channel(channel).send(embed=env.embed)\n \n \n-async def restart(_: Node, server: Server, shutdown: Optional[bool] = False, rotate: Optional[bool] = False,\n+async def restart(node: Node, server: Server, shutdown: Optional[bool] = False, rotate: Optional[bool] = False,\n                   run_extensions: Optional[bool] = True):\n     if not server or server.status in [Status.SHUTDOWN, Status.UNREGISTERED]:\n         return\n", "message": "", "files": {"/services/scheduler/actions.py": {"changes": [{"diff": "\n         await bot.get_channel(channel).send(embed=env.embed)\n \n \n-async def restart(_: Node, server: Server, shutdown: Optional[bool] = False, rotate: Optional[bool] = False,\n+async def restart(node: Node, server: Server, shutdown: Optional[bool] = False, rotate: Optional[bool] = False,\n                   run_extensions: Optional[bool] = True):\n     if not server or server.status in [Status.SHUTDOWN, Status.UNREGISTERED]:\n         return\n", "add": 1, "remove": 1, "filename": "/services/scheduler/actions.py", "badparts": ["async def restart(_: Node, server: Server, shutdown: Optional[bool] = False, rotate: Optional[bool] = False,"], "goodparts": ["async def restart(node: Node, server: Server, shutdown: Optional[bool] = False, rotate: Optional[bool] = False,"]}], "source": "\nimport asyncio import os from core import Server, ServiceRegistry, Node, PersistentReport, Report, Status from services import BotService, ServiceBus from typing import Optional async def report(file: str, channel: int, node: Node, persistent: Optional[bool]=True, server: Optional[Server]=None): if not node.master: return bot=ServiceRegistry.get(BotService).bot if persistent: r=PersistentReport(bot, 'scheduler', file, channel_id=channel, server=server, embed_name=os.path.basename(file)[:-5]) await r.render(node=node, server=server) else: r=Report(bot, 'scheduler', file) env=await r.render(node=node, server=server) await bot.get_channel(channel).send(embed=env.embed) async def restart(_: Node, server: Server, shutdown: Optional[bool]=False, rotate: Optional[bool]=False, run_extensions: Optional[bool]=True): if not server or server.status in[Status.SHUTDOWN, Status.UNREGISTERED]: return server.maintenance=True if shutdown: ServiceRegistry.get(ServiceBus).send_to_node({\"command\": \"onShutdown\", \"server_name\": server.name}) await asyncio.sleep(1) await server.shutdown() await server.startup() elif rotate: await server.loadNextMission(modify_mission=run_extensions) else: await server.restart(modify_mission=run_extensions) ", "sourceWithComments": "import asyncio\nimport os\n\nfrom core import Server, ServiceRegistry, Node, PersistentReport, Report, Status\nfrom services import BotService, ServiceBus\nfrom typing import Optional\n\n\nasync def report(file: str, channel: int, node: Node, persistent: Optional[bool] = True,\n                 server: Optional[Server] = None):\n    # we can only render on the master node\n    if not node.master:\n        return\n    bot = ServiceRegistry.get(BotService).bot\n    if persistent:\n        r = PersistentReport(bot, 'scheduler', file, channel_id=channel, server=server,\n                             embed_name=os.path.basename(file)[:-5])\n        await r.render(node=node, server=server)\n    else:\n        r = Report(bot, 'scheduler', file)\n        env = await r.render(node=node, server=server)\n        await bot.get_channel(channel).send(embed=env.embed)\n\n\nasync def restart(_: Node, server: Server, shutdown: Optional[bool] = False, rotate: Optional[bool] = False,\n                  run_extensions: Optional[bool] = True):\n    if not server or server.status in [Status.SHUTDOWN, Status.UNREGISTERED]:\n        return\n    server.maintenance = True\n    if shutdown:\n        ServiceRegistry.get(ServiceBus).send_to_node({\"command\": \"onShutdown\", \"server_name\": server.name})\n        await asyncio.sleep(1)\n        await server.shutdown()\n        await server.startup()\n    elif rotate:\n        await server.loadNextMission(modify_mission=run_extensions)\n    else:\n        await server.restart(modify_mission=run_extensions)\n"}}, "msg": "CHANGES:\n- Removed one deprecated Python call.\n- Some code cleanups\n- Fixed some places for possible SQL injections"}}}