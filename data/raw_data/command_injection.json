{"https://github.com/SovereignCloudStack/sonic-buildimage": {"92d25be08f3866b4ae37f8eeba7ef53369851803": {"url": "https://api.github.com/repos/SovereignCloudStack/sonic-buildimage/commits/92d25be08f3866b4ae37f8eeba7ef53369851803", "html_url": "https://github.com/SovereignCloudStack/sonic-buildimage/commit/92d25be08f3866b4ae37f8eeba7ef53369851803", "sha": "92d25be08f3866b4ae37f8eeba7ef53369851803", "keyword": "command injection malicious", "diff": "diff --git a/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py b/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py\nindex bcb05b9cb..9c994c572 100755\n--- a/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py\n@@ -17,13 +17,11 @@\n \n try:\n     import os\n-    import commands\n-    import sys, getopt\n-    import logging\n     import re\n     import time\n     import syslog\n     from sonic_sfp.bcmshell import bcmshell\n+    from sonic_py_common.general import getstatusoutput_noshell\n     \n except ImportError as e:\n     raise ImportError(\"%s - required module not found\" % str(e))\n@@ -53,10 +51,10 @@ def initialLoop():\n             bcm_obj = BCMUtil()\n             bcm_obj.execute_command(\"echo\")\n             initialNotOK = False\n-            print bcm_obj\n+            print(bcm_obj)\n             log_message( syslog.LOG_INFO, \"BCMUtil Object initialed successfully\" )  \n-        except Exception, e:   \n-            print \"Exception. The warning is {0}\".format(str(e)) \n+        except Exception as e:   \n+            print(\"Exception. The warning is {0}\".format(str(e)))\n             time.sleep(10)\n             \n class BCMUtil(bcmshell):\n@@ -66,7 +64,7 @@ class BCMUtil(bcmshell):\n     \n     def get_platform(self):\n         if self.platform is None:\n-            self.platform = os.popen(\"uname -n\").read().strip()\n+            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"]).strip()\n         return self.platform\n         \n     def get_asic_temperature( self ):\n@@ -102,14 +100,18 @@ def main():\n                         content = readPtr.read().strip()\n                         if bcm_obj.get_platform() == INV_SEQUOIA_PLATFORM :\n                             if content == \"inv_bmc\" and SWITCH_TEMP_FILE_NAME in file_list :\n-                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n+                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)\n+                                with open(file, 'w') as f:\n+                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')\n                                 break\n                         else :\n                             if content == \"inv_psoc\" and SWITCH_TEMP_FILE_NAME in file_list :\n-                                print \"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME )\n-                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n+                                print(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME))\n+                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)\n+                                with open(file, 'w') as f:\n+                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')\n                                 break\n-        except Exception, e:\n+        except Exception as e:\n             log_message( syslog.LOG_WARNING, \"Exception. The warning is {0}\".format(str(e)) )\n             initialLoop()            \n         time.sleep(5)\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py b/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py\nindex bab0e2daf..8f4564287 100755\n--- a/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py\n@@ -20,6 +20,7 @@\n import syslog\n import re\n from sonic_sfp.bcmshell import bcmshell\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n # =====================================================================\n@@ -120,8 +121,8 @@ def _board_init():\n     global SYNC_S\n     global SYNC_P\n \n-    cmd = \"uname -n\"\n-    platform = os.popen(cmd).read()\n+    cmd = [\"uname\", \"-n\"]\n+    _, platform = getstatusoutput_noshell(cmd)\n \n     if platform.rstrip() == INV_MAGNOLIA:\n         BOARD_TPYE      = \"inventec_d6254qs\"\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py b/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py\nindex f1e7f7fec..d73687e02 100755\n--- a/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py\n@@ -2,6 +2,7 @@\n \n import os\n import socket\n+import subprocess\n from collections import OrderedDict\n \n # Purpose:  Shutdown DUT upon receiving thermaltrip event from kernel (inv_pthread)\n@@ -59,6 +60,6 @@ def next_events(self):\n \n             # Receive thermaltrip event\n             if event['ACTION'] == 'remove' and event['DEVPATH'] == '/kernel/platform_status/fan':\n-                os.system(\"shutdown -h now\")\n+                subprocess.call([\"shutdown\", \"-h\", \"now\"])\n                 \n \ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py b/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py\nindex 9e4a44c16..453c33dee 100755\n--- a/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py\n@@ -28,6 +28,7 @@\n     import syslog\n     from sfputil import SfpUtil\n     from sonic_sfp.bcmshell import bcmshell\n+    from sonic_py_common.general import getstatusoutput_noshell\n     \n except ImportError as e:\n     raise ImportError(\"%s - required module not found\" % str(e))\n@@ -127,7 +128,7 @@ class BCMUtil(bcmshell):\n     \n     def get_platform(self):\n         if self.platform is None:\n-            self.platform = os.popen(\"uname -n\").read().strip()\n+            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"])\n         return self.platform\n     \n     def get_port_to_bcm_mapping(self):  \ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py b/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py\nindex b1f8799ab..f71a19d00 100644\n--- a/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py\n@@ -8,6 +8,7 @@\n try:\n     import os\n     import logging\n+    import subprocess\n     from ctypes import create_string_buffer\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8436 import sff8436Dom\n@@ -120,7 +121,7 @@ def __set_attr_value(self, attr_path, value):\n         return True\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/device'\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py b/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py\nindex a468a323d..d467fd8fb 100755\n--- a/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py\n@@ -33,6 +33,7 @@\n import logging\n import syslog\n import time\n+from sonic_py_common.general import getstatusoutput_noshell_pipe\n \n DEBUG = False\n args = []\n@@ -236,8 +237,9 @@ def system_install(boot_option):\n \t      return status\n     for addr_offset in range (0,FAN_NUM):\n         addr=FAN_VPD_ADDR_BASE+addr_offset\n-        cmd = \"i2cdetect -y \"+str(FAN_VPD_CHANNEL)+\" \"+str(addr)+\" \"+str(addr)+\" | grep \"+str(hex(addr)).replace('0x','')\n-        result=os.system(cmd)\n+        cmd1 = [\"i2cdetect\", \"-y\", str(FAN_VPD_CHANNEL), str(addr), str(addr)]\n+        cmd2 = [\"grep\", f'{addr:x}']\n+        result, _ = getstatusoutput_noshell_pipe(cmd1, cmd2)\n         if( result==0 ):\n             cmd=\"echo inv_eeprom \"+str(addr)+\" > /sys/bus/i2c/devices/i2c-\"+FAN_VPD_CHANNEL\n             status, output = exec_cmd(cmd,1)\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py b/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py\nindex fccde46df..22eae317f 100644\n--- a/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py\n@@ -9,6 +9,7 @@\n     import os\n     import sys\n     import time\n+    import subprocess\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8436 import sff8436Dom\n     from sonic_platform_base.sonic_sfp.sff8436 import sff8436InterfaceId\n@@ -108,7 +109,7 @@ def __get_attr_value(self, attr_path):\n         return retval\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/device'\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py b/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py\nindex 5c75a8749..de8d50b7a 100644\n--- a/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py\n@@ -7,7 +7,7 @@\n \n try:\n     import os\n-    import sys\n+    import subprocess\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472InterfaceId\n@@ -95,7 +95,7 @@ def __get_attr_value(self, attr_path):\n         return retval\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/device'\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py b/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py\nindex 9d6337195..ee5768a64 100644\n--- a/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py\n@@ -153,7 +153,7 @@ class Sfp(SfpBase):\n     # Path to QSFP sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-inventec_d7054q28b-r0\"\n     HWSKU  = \"INVENTEC-D7054Q28B-S48-Q6\"\n@@ -285,7 +285,7 @@ def __read_txt_file(self, file_path):\n         return \"\"\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n", "message": "", "files": {"/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py": {"changes": [{"diff": "\n \n try:\n     import os\n-    import commands\n-    import sys, getopt\n-    import logging\n     import re\n     import time\n     import syslog\n     from sonic_sfp.bcmshell import bcmshell\n+    from sonic_py_common.general import getstatusoutput_noshell\n     \n except ImportError as e:\n     raise ImportError(\"%s - required module not found\" % str(e))\n", "add": 1, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py", "badparts": ["    import commands", "    import sys, getopt", "    import logging"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n             bcm_obj = BCMUtil()\n             bcm_obj.execute_command(\"echo\")\n             initialNotOK = False\n-            print bcm_obj\n+            print(bcm_obj)\n             log_message( syslog.LOG_INFO, \"BCMUtil Object initialed successfully\" )  \n-        except Exception, e:   \n-            print \"Exception. The warning is {0}\".format(str(e)) \n+        except Exception as e:   \n+            print(\"Exception. The warning is {0}\".format(str(e)))\n             time.sleep(10)\n             \n class BCMUtil(bcmshell):\n", "add": 3, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py", "badparts": ["            print bcm_obj", "        except Exception, e:   ", "            print \"Exception. The warning is {0}\".format(str(e)) "], "goodparts": ["            print(bcm_obj)", "        except Exception as e:   ", "            print(\"Exception. The warning is {0}\".format(str(e)))"]}, {"diff": "\n     \n     def get_platform(self):\n         if self.platform is None:\n-            self.platform = os.popen(\"uname -n\").read().strip()\n+            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"]).strip()\n         return self.platform\n         \n     def get_asic_temperature( self ):\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py", "badparts": ["            self.platform = os.popen(\"uname -n\").read().strip()"], "goodparts": ["            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"]).strip()"]}, {"diff": "\n                         content = readPtr.read().strip()\n                         if bcm_obj.get_platform() == INV_SEQUOIA_PLATFORM :\n                             if content == \"inv_bmc\" and SWITCH_TEMP_FILE_NAME in file_list :\n-                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n+                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)\n+                                with open(file, 'w') as f:\n+                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')\n                                 break\n                         else :\n                             if content == \"inv_psoc\" and SWITCH_TEMP_FILE_NAME in file_list :\n-                                print \"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME )\n-                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n+                                print(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME))\n+                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)\n+                                with open(file, 'w') as f:\n+                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')\n                                 break\n-        except Exception, e:\n+        except Exception as e:\n             log_message( syslog.LOG_WARNING, \"Exception. The warning is {0}\".format(str(e)) )\n             initialLoop()            \n         time.sleep(5)", "add": 8, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py", "badparts": ["                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))", "                                print \"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME )", "                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))", "        except Exception, e:"], "goodparts": ["                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)", "                                with open(file, 'w') as f:", "                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')", "                                print(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME))", "                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)", "                                with open(file, 'w') as f:", "                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')", "        except Exception as e:"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object Auto detecting the Chipset temperature and update options: -h | --help : this help message -d | --debug : run with debug mode \"\"\" try: import os import commands import sys, getopt import logging import re import time import syslog from sonic_sfp.bcmshell import bcmshell except ImportError as e: raise ImportError(\"%s -required module not found\" % str(e)) args=[] INV_REDWOOD_PLATFORM=\"SONiC-Inventec-d7032-100\" INV_CYPRESS_PLATFORM=\"SONiC-Inventec-d7054\" INV_SEQUOIA_PLATFORM=\"SONiC-Inventec-d7264\" INV_MAPLE_PLATFORM=\"SONiC-Inventec-d6556\" INV_MAGNOLIA_PLATFORM=\"SONiC-Inventec-d6254qs\" PSOC_NAME=\"name\" HWMON_PATH=\"/sys/class/hwmon/\" SWITCH_TEMP_FILE_NAME=\"switch_tmp\" def log_message( level, string): syslog.openlog(\"asic_monitor\", syslog.LOG_PID, facility=syslog.LOG_DAEMON) syslog.syslog( level, string) def initialLoop(): global bcm_obj initialNotOK=True while initialNotOK: try: bcm_obj=BCMUtil() bcm_obj.execute_command(\"echo\") initialNotOK=False print bcm_obj log_message( syslog.LOG_INFO, \"BCMUtil Object initialed successfully\") except Exception, e: print \"Exception. The warning is{0}\".format(str(e)) time.sleep(10) class BCMUtil(bcmshell): asic_temperature=0 platform=None def get_platform(self): if self.platform is None: self.platform=os.popen(\"uname -n\").read().strip() return self.platform def get_asic_temperature( self): return self.asic_temperature def set_asic_temperature( self, temp): self.asic_temperature=temp def parsing_asic_temp(self): content=self.run(\"show temp\") for line in content.split(\"\\n\"): TempObject=re.search(r\"(average current temperature is)\\s+(?P<temperature_high>\\d+)\\.(?P<temperature_low>\\d+)\",line) if TempObject is not None: self.set_asic_temperature( int( TempObject.group(\"temperature_high\"))) def execute_command(self, cmd): return self.run(cmd) def main(): global bcm_obj initialLoop() log_message( syslog.LOG_INFO, \"Object initialed successfully\") while 1: try: bcm_obj.parsing_asic_temp() for index in os.listdir(HWMON_PATH): file_list=os.listdir(\"{0}/{1}/device/\".format(HWMON_PATH,index)) if PSOC_NAME in file_list: with open( \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, PSOC_NAME), 'rb') as readPtr: content=readPtr.read().strip() if bcm_obj.get_platform()==INV_SEQUOIA_PLATFORM: if content==\"inv_bmc\" and SWITCH_TEMP_FILE_NAME in file_list: os.system(\"echo{0} >{1}/{2}/device/{3}\".format(( bcm_obj.get_asic_temperature() * 1000), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)) break else: if content==\"inv_psoc\" and SWITCH_TEMP_FILE_NAME in file_list: print \"echo{0} >{1}/{2}/device/{3}\".format(( bcm_obj.get_asic_temperature() * 1000), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME) os.system(\"echo{0} >{1}/{2}/device/{3}\".format(( bcm_obj.get_asic_temperature() * 1000), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)) break except Exception, e: log_message( syslog.LOG_WARNING, \"Exception. The warning is{0}\".format(str(e))) initialLoop() time.sleep(5) syslog.closelog() del bcm_obj if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2018 Inventec, Inc.\n# \n# Editor: James Huang ( Huang.James@inventec.com )\n#  \n\"\"\"\nUsage: %(scriptName)s [options] command object\n\nAuto detecting the Chipset temperature and update\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n   \n\"\"\"\n\ntry:\n    import os\n    import commands\n    import sys, getopt\n    import logging\n    import re\n    import time\n    import syslog\n    from sonic_sfp.bcmshell import bcmshell\n    \nexcept ImportError as e:\n    raise ImportError(\"%s - required module not found\" % str(e))\n\nargs = []\nINV_REDWOOD_PLATFORM = \"SONiC-Inventec-d7032-100\"\nINV_CYPRESS_PLATFORM = \"SONiC-Inventec-d7054\"\nINV_SEQUOIA_PLATFORM = \"SONiC-Inventec-d7264\"\nINV_MAPLE_PLATFORM = \"SONiC-Inventec-d6556\"\nINV_MAGNOLIA_PLATFORM = \"SONiC-Inventec-d6254qs\"\n\nPSOC_NAME = \"name\"\nHWMON_PATH = \"/sys/class/hwmon/\"\nSWITCH_TEMP_FILE_NAME = \"switch_tmp\"\n\ndef log_message( level, string ):\n    syslog.openlog(\"asic_monitor\", syslog.LOG_PID, facility=syslog.LOG_DAEMON)\n    syslog.syslog( level, string )\n\ndef initialLoop():\n\n    global bcm_obj\n    initialNotOK = True\n    \n    while initialNotOK :        \n        try:                \n            bcm_obj = BCMUtil()\n            bcm_obj.execute_command(\"echo\")\n            initialNotOK = False\n            print bcm_obj\n            log_message( syslog.LOG_INFO, \"BCMUtil Object initialed successfully\" )  \n        except Exception, e:   \n            print \"Exception. The warning is {0}\".format(str(e)) \n            time.sleep(10)\n            \nclass BCMUtil(bcmshell):\n\n    asic_temperature = 0\n    platform = None\n    \n    def get_platform(self):\n        if self.platform is None:\n            self.platform = os.popen(\"uname -n\").read().strip()\n        return self.platform\n        \n    def get_asic_temperature( self ):\n        return self.asic_temperature\n        \n    def set_asic_temperature( self, temp ):\n        self.asic_temperature = temp\n                \n    def parsing_asic_temp(self):\n        content = self.run(\"show temp\")\n        for line in content.split(\"\\n\"):\n            TempObject = re.search(r\"(average current temperature is)\\s+(?P<temperature_high>\\d+)\\.(?P<temperature_low>\\d+)\",line)\n            if TempObject is not None:\n                self.set_asic_temperature( int( TempObject.group(\"temperature_high\") ) )\n        \n    def execute_command(self, cmd):\n        return self.run(cmd)\n     \n        \ndef main():\n\n    global bcm_obj\n    initialLoop()\n    log_message( syslog.LOG_INFO, \"Object initialed successfully\" )\n\n    while 1 :\n        try:\n            bcm_obj.parsing_asic_temp()\n            for index in os.listdir(HWMON_PATH):\n                file_list = os.listdir(\"{0}/{1}/device/\".format(HWMON_PATH,index))\n                if PSOC_NAME in file_list :\n                    with open( \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, PSOC_NAME), 'rb') as readPtr:\n                        content = readPtr.read().strip()\n                        if bcm_obj.get_platform() == INV_SEQUOIA_PLATFORM :\n                            if content == \"inv_bmc\" and SWITCH_TEMP_FILE_NAME in file_list :\n                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n                                break\n                        else :\n                            if content == \"inv_psoc\" and SWITCH_TEMP_FILE_NAME in file_list :\n                                print \"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME )\n                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n                                break\n        except Exception, e:\n            log_message( syslog.LOG_WARNING, \"Exception. The warning is {0}\".format(str(e)) )\n            initialLoop()            \n        time.sleep(5)\n\n    syslog.closelog()\n    del bcm_obj\n\nif __name__ == \"__main__\":\n    main()\n\n\n\n\n\n"}, "/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py": {"changes": [{"diff": "\n     global SYNC_S\n     global SYNC_P\n \n-    cmd = \"uname -n\"\n-    platform = os.popen(cmd).read()\n+    cmd = [\"uname\", \"-n\"]\n+    _, platform = getstatusoutput_noshell(cmd)\n \n     if platform.rstrip() == INV_MAGNOLIA:\n         BOARD_TPYE      = \"inventec_d6254qs", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py", "badparts": ["    cmd = \"uname -n\"", "    platform = os.popen(cmd).read()"], "goodparts": ["    cmd = [\"uname\", \"-n\"]", "    _, platform = getstatusoutput_noshell(cmd)"]}], "source": "\n import os import time import syslog import re from sonic_sfp.bcmshell import bcmshell PORT_LIST =[] BCM_SHELL =None SHELL_READY=False STATUS_RX =1<<0 STATUS_TX =1<<1 PORT_DATA_OFFSET_ADDR =0xA0 INV_MAGNOLIA =\"SONiC-Inventec-d6254qs\" INV_REDWOOD =\"SONiC-Inventec-d7032-100\" INV_CYPRESS =\"SONiC-Inventec-d7054\" INV_MAPLE =\"SONiC-Inventec-d6556\" INV_SEQUOIA =\"\" BOARD_TPYE =\"\" EAGLE_CORE =[] BIT_LINK =None BIT_FAULT =None BIT_TX =None BIT_RX =None BIT_SPEED0 =None BIT_SPEED1 =None SPEED_100G =100 SPEED_40G =40 SPEED_25G =25 SPEED_10G =10 class Port(): port_num =None name =None bcm_id =None led_up =None s_addr =None write2_up =None led_index =None link_status =None speed =None def write_data_ram(self, data): BCM_SHELL.cmd(\"setreg CMIC_LEDUP{0}_DATA_RAM({1}){2}\".format(self.write2_up, self.led_index, data)) def read_data_ram(self): r_string=BCM_SHELL.run(\"getreg CMIC_LEDUP{0}_DATA_RAM({1})\".format(self.led_up, self.s_addr)) for line in r_string.split(\"\\n\"): re_obj=re.search(r\"\\<DATA\\=(?P<data>.+)\\>\", line) if re_obj is not None: return int(re_obj.group(\"data\"), 16) def _remap_registers(fp): content=fp.readlines() fp.close() err=False for line in content: try: BCM_SHELL.cmd(line.rstrip()) except Exception, e: err=True syslog.syslog(syslog.LOG_ERR, \"remap register abnormal:{0}\".format(str(e))) if not err: syslog.syslog(syslog.LOG_INFO, \"remap Led registers successfully\") def _board_init(): global BOARD_TPYE global BIT_LINK global BIT_FAULT global BIT_TX global BIT_RX global BIT_SPEED0 global BIT_SPEED1 global EAGLE_CORE global TOTAL_SCAN_BITS global SYNC_S global SYNC_P cmd=\"uname -n\" platform=os.popen(cmd).read() if platform.rstrip()==INV_MAGNOLIA: BOARD_TPYE =\"inventec_d6254qs\" BIT_RX =1<<0 BIT_TX =1<<1 BIT_SPEED1 =1<<4 BIT_LINK =1<<7 fp=open('/usr/share/sonic/device/x86_64-inventec_d6254qs-r0/led_proc_init.soc', \"r\") _remap_registers(fp) elif platform.rstrip()==INV_REDWOOD: BOARD_TPYE =\"inventec_d7032q28b\" BIT_RX =1<<0 BIT_TX =1<<1 BIT_SPEED0 =1<<3 BIT_SPEED1 =1<<4 BIT_FAULT =1<<6 BIT_LINK =1<<7 EAGLE_CORE =[66, 100] fp=open('/usr/share/sonic/device/x86_64-inventec_d7032q28b-r0/led_proc_init.soc', \"r\") _remap_registers(fp) elif platform.rstrip()==INV_CYPRESS: BOARD_TPYE =\"inventec_d7054q28b\" BIT_LINK =1<<0 BIT_FAULT =1<<1 BIT_SPEED0 =1<<2 EAGLE_CORE =[66, 100] elif platform.rstrip()==INV_SEQUOIA: BOARD_TPYE=\"inventec_d7264q28b\" elif platform.rstrip()==INV_MAPLE: BOARD_TPYE=\"inventec_d6556\" fp=open('/usr/share/sonic/device/x86_64-inventec_d6556-r0/led_proc_init.soc', \"r\") _remap_registers(fp) syslog.syslog(syslog.LOG_INFO, \"Found device:{0}\".format(BOARD_TPYE)) exit(0) else: BOARD_TPYE=\"not found\" syslog.syslog(syslog.LOG_ERR, \"Found device:{0}\".format(BOARD_TPYE)) exit(0) syslog.syslog(syslog.LOG_INFO, \"Found device:{0}\".format(BOARD_TPYE)) def _lookup_led_index(p): index=0 if BOARD_TPYE==\"inventec_d6254qs\": if 0 <=p.port_num <=47: index=p.port_num +(p.port_num / 4) p.write2_up=0 elif 48 <=p.port_num <=71: index=p.port_num -48 p.write2_up=1 if p.led_up==0: p.s_addr=p.port_num * 2 elif p.led_up==1: p.s_addr=(p.port_num -36) * 2 elif BOARD_TPYE==\"inventec_d7032q28b\": p.write2_up=0 index=p.port_num if 0 <=p.port_num <=7: p.s_addr=p.port_num * 8 elif 8 <=p.port_num <=23: p.s_addr=(p.port_num -8) * 8 elif 24 <=p.port_num <=31: p.s_addr=(p.port_num -16) * 8 else: p.write2_up=p.led_up for port in PORT_LIST: if p.bcm_id==port.bcm_id: break if p.led_up==port.led_up: index +=1 return PORT_DATA_OFFSET_ADDR +index def _update_port_list(only_update): global PORT_LIST number =0 count =0 content=BCM_SHELL.run(\"ps\") for line in content.split(\"\\n\"): re_obj=re.search(r\"(?P<port_name>(xe|ce)\\d+)\\(\\s*(?P<bcm_id>\\d+)\\)\\s+(?P<link>(up|down|!ena)).+\\s+(?P<speed>\\d+)G\", line) if re_obj is not None: if int(re_obj.group(\"bcm_id\")) not in EAGLE_CORE: if only_update: PORT_LIST[number].link_status=re_obj.group(\"link\") else: port_obj=Port() port_obj.port_num=number port_obj.name=re_obj.group(\"port_name\") port_obj.bcm_id=int(re_obj.group(\"bcm_id\")) port_obj.link_status=re_obj.group(\"link\") port_obj.speed=int(re_obj.group(\"speed\")) PORT_LIST.append(port_obj) number +=1 if not only_update: content=BCM_SHELL.run(\"led status\") for line in content.split(\"\\n\"): re_obj=re.search(r\"(?P<bcm_id>\\d+).+(?P<led_up>\\d)\\:\", line) if re_obj is not None: if int(re_obj.group(\"bcm_id\")) not in EAGLE_CORE: PORT_LIST[count].led_up=int(re_obj.group(\"led_up\")) PORT_LIST[count].led_index=_lookup_led_index(PORT_LIST[count]) count +=1 if number is not count: PORT_LIST=[] syslog.syslog(syslog.LOG_ERR, \"The amount of port is not match\") def sync_bcmsh_socket(): global BCM_SHELL global SHELL_READY waitSyncd =True retryCount =0 while waitSyncd: time.sleep(10) try: BCM_SHELL=bcmshell() BCM_SHELL.run(\"Echo\") waitSyncd=False except Exception, e: print \"{0}, Retry times({1})\".format(str(e),retryCount) retryCount +=1 syslog.syslog(syslog.LOG_INFO, \"bcmshell socket create successfully\") if SHELL_READY is False: SHELL_READY=True return elif SHELL_READY is True: update_led_status() def update_led_status(): led_thread =True reset_sec =2 count_down =0 queue_active =[] port_data =None s_byte =None while led_thread: try: if count_down==0: queue_active=[] _update_port_list(1) for port in PORT_LIST: if port.link_status==\"up\": queue_active.append(port) else: port_data=0 port.write_data_ram(port_data) count_down=reset_sec else: for port in queue_active: port_data=0 if BOARD_TPYE==\"inventec_d6254qs\": s_byte=port.read_data_ram() if s_byte&STATUS_RX: port_data |=BIT_RX if s_byte&STATUS_TX: port_data |=BIT_TX port_data |=BIT_LINK elif BOARD_TPYE==\"inventec_d7032q28b\": s_byte=port.read_data_ram() if s_byte&STATUS_RX: port_data |=BIT_RX if s_byte&STATUS_TX: port_data |=BIT_TX if port.speed==SPEED_100G: port_data |=BIT_SPEED0 port_data |=BIT_SPEED1 elif port.speed==SPEED_40G: port_data |=BIT_SPEED1 elif port.speed==SPEED_25G: port_data |=BIT_SPEED0 else: pass port_data |=BIT_LINK elif BOARD_TPYE==\"inventec_d7054q28b\": if port.speed !=SPEED_100G and port.speed !=SPEED_25G: port_data |=BIT_SPEED0 port.write_data_ram(port_data) time.sleep(0.5) count_down -=1 except Exception, e: syslog.syslog(syslog.LOG_WARNING, \"{0}\".format(str(e))) sync_bcmsh_socket() def debug_print(): for port in PORT_LIST: output=\"\" output +=\"name:{0} | \".format(port.name) output +=\"port_num:{0} | \".format(port.port_num) output +=\"bcm_id:{0} | \".format(port.bcm_id) output +=\"link_status:{0} | \".format(port.link_status) output +=\"speed:{0} | \".format(port.speed) output +=\"led_up:{0} | \".format(port.led_up) output +=\"s_addr:{0} | \".format(port.s_addr) output +=\"write2_up:{0} | \".format(port.write2_up) output +=\"led_index:{0} | \".format(port.led_index) print output if __name__==\"__main__\": syslog.openlog(\"led_proc\", syslog.LOG_PID, facility=syslog.LOG_DAEMON) sync_bcmsh_socket() _board_init() _update_port_list(0) update_led_status() syslog.closelog() ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2018 Inventec, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport time\nimport syslog\nimport re\nfrom sonic_sfp.bcmshell import bcmshell\n\n\n# =====================================================================\n#  global variable init\n# =====================================================================\n# port object\nPORT_LIST               = []\n# object is to execute bcm shell command\nBCM_SHELL   = None\nSHELL_READY = False\n# port status that is auto update by chip in data ram\nSTATUS_RX               = 1<<0\nSTATUS_TX               = 1<<1\n# define data ram address\nPORT_DATA_OFFSET_ADDR   = 0xA0\n# define board type\nINV_MAGNOLIA            = \"SONiC-Inventec-d6254qs\"\nINV_REDWOOD             = \"SONiC-Inventec-d7032-100\"\nINV_CYPRESS             = \"SONiC-Inventec-d7054\"\nINV_MAPLE               = \"SONiC-Inventec-d6556\"\nINV_SEQUOIA             = \"\"\nBOARD_TPYE              = \"\"\nEAGLE_CORE              = []\n# define port data for bit streaming\nBIT_LINK                = None\nBIT_FAULT               = None\nBIT_TX                  = None\nBIT_RX                  = None\nBIT_SPEED0              = None\nBIT_SPEED1              = None\n# define port speed\nSPEED_100G              = 100\nSPEED_40G               = 40\nSPEED_25G               = 25\nSPEED_10G               = 10\n\n\n# =====================================================================\n#  class object\n# =====================================================================\nclass Port():\n\n    port_num        = None\n    name            = None\n    bcm_id          = None\n    led_up          = None\n    s_addr          = None\n    write2_up       = None\n    led_index       = None\n    link_status     = None\n    speed           = None\n\n    def write_data_ram(self, data):\n        BCM_SHELL.cmd(\"setreg CMIC_LEDUP{0}_DATA_RAM({1}) {2}\".format(self.write2_up, self.led_index, data))\n\n    def read_data_ram(self):\n        r_string = BCM_SHELL.run(\"getreg CMIC_LEDUP{0}_DATA_RAM({1})\".format(self.led_up, self.s_addr))\n        for line in r_string.split(\"\\n\"):\n            re_obj = re.search(r\"\\<DATA\\=(?P<data>.+)\\>\", line)\n            if re_obj is not None:\n                #syslog.syslog(syslog.LOG_DEBUG, \"Read Led({0}) data_ram({1}): {2}\".format(self.up, addr, re_obj.group(\"data\")))\n                return int(re_obj.group(\"data\"), 16)\n\n\n\n# =====================================================================\n#  Function\n# =====================================================================\ndef _remap_registers(fp):\n\n    content = fp.readlines()\n    fp.close()\n    err = False\n\n    for line in content:\n        try:\n            BCM_SHELL.cmd(line.rstrip())\n        except Exception, e:\n            err = True\n            syslog.syslog(syslog.LOG_ERR, \"remap register abnormal: {0}\".format(str(e)))\n\n    if not err:\n        syslog.syslog(syslog.LOG_INFO, \"remap Led registers successfully\")\n\n\n\ndef _board_init():\n\n    global BOARD_TPYE\n    global BIT_LINK\n    global BIT_FAULT\n    global BIT_TX\n    global BIT_RX\n    global BIT_SPEED0\n    global BIT_SPEED1\n    global EAGLE_CORE\n    global TOTAL_SCAN_BITS\n    global SYNC_S\n    global SYNC_P\n\n    cmd = \"uname -n\"\n    platform = os.popen(cmd).read()\n\n    if platform.rstrip() == INV_MAGNOLIA:\n        BOARD_TPYE      = \"inventec_d6254qs\"\n        BIT_RX          = 1<<0  #0x01\n        BIT_TX          = 1<<1  #0x02\n        BIT_SPEED1      = 1<<4  #0x10\n        BIT_LINK        = 1<<7  #0x80\n        fp = open('/usr/share/sonic/device/x86_64-inventec_d6254qs-r0/led_proc_init.soc', \"r\")\n        _remap_registers(fp)\n\n    elif platform.rstrip() == INV_REDWOOD:\n        BOARD_TPYE      = \"inventec_d7032q28b\"\n        BIT_RX          = 1<<0  #0x01\n        BIT_TX          = 1<<1  #0x02\n        BIT_SPEED0      = 1<<3  #0x08\n        BIT_SPEED1      = 1<<4  #0x10\n        BIT_FAULT       = 1<<6  #0x40\n        BIT_LINK        = 1<<7  #0x80\n        EAGLE_CORE      = [66, 100]\n        fp = open('/usr/share/sonic/device/x86_64-inventec_d7032q28b-r0/led_proc_init.soc', \"r\")\n        _remap_registers(fp)\n\n    elif platform.rstrip() == INV_CYPRESS:\n        BOARD_TPYE      = \"inventec_d7054q28b\"\n        BIT_LINK        = 1<<0  #0x01\n        BIT_FAULT       = 1<<1  #0x02\n        BIT_SPEED0      = 1<<2  #0x04\n        EAGLE_CORE      = [66, 100]\n\n    elif platform.rstrip() == INV_SEQUOIA:\n        BOARD_TPYE = \"inventec_d7264q28b\"\n\n    elif platform.rstrip() == INV_MAPLE:\n        BOARD_TPYE = \"inventec_d6556\"\n        fp = open('/usr/share/sonic/device/x86_64-inventec_d6556-r0/led_proc_init.soc', \"r\")\n        _remap_registers(fp)\n        #led process: m0 led process that is controlled by linkscan_led_fw.bin and custom_led.bin\n        syslog.syslog(syslog.LOG_INFO, \"Found device: {0}\".format(BOARD_TPYE))\n        exit(0)\n\n    else:\n        BOARD_TPYE = \"not found\"\n        syslog.syslog(syslog.LOG_ERR, \"Found device: {0}\".format(BOARD_TPYE))\n        exit(0)\n\n    syslog.syslog(syslog.LOG_INFO, \"Found device: {0}\".format(BOARD_TPYE))\n\n\n\ndef _lookup_led_index(p):\n\n    index = 0\n    if BOARD_TPYE == \"inventec_d6254qs\":\n        if 0 <= p.port_num <= 47:\n            index = p.port_num + (p.port_num / 4)\n            p.write2_up = 0\n        elif 48 <= p.port_num <= 71:\n            index = p.port_num - 48\n            p.write2_up = 1\n        if p.led_up == 0:\n            p.s_addr = p.port_num * 2\n        elif p.led_up == 1:\n            p.s_addr = (p.port_num - 36) * 2\n\n    elif BOARD_TPYE == \"inventec_d7032q28b\":\n        p.write2_up = 0\n        index = p.port_num\n        if 0 <= p.port_num <= 7:\n            p.s_addr = p.port_num * 8\n        elif 8 <= p.port_num <= 23:\n            p.s_addr = (p.port_num - 8) * 8\n        elif 24 <= p.port_num <= 31:\n            p.s_addr = (p.port_num - 16) * 8\n\n    else:\n        p.write2_up = p.led_up\n        for port in PORT_LIST:\n            if p.bcm_id == port.bcm_id:\n                break\n            if p.led_up == port.led_up:\n                index += 1\n\n    return PORT_DATA_OFFSET_ADDR + index\n\n\ndef _update_port_list(only_update):\n\n    global PORT_LIST\n    number      = 0\n    count       = 0\n\n    content = BCM_SHELL.run(\"ps\")\n    for line in content.split(\"\\n\"):\n        re_obj = re.search(r\"(?P<port_name>(xe|ce)\\d+)\\(\\s*(?P<bcm_id>\\d+)\\)\\s+(?P<link>(up|down|!ena)).+\\s+(?P<speed>\\d+)G\", line)\n        if re_obj is not None:\n            if int(re_obj.group(\"bcm_id\")) not in EAGLE_CORE:\n                if only_update:\n                    PORT_LIST[number].link_status = re_obj.group(\"link\")\n                else:\n                    # create port object while first time\n                    port_obj = Port()\n                    port_obj.port_num = number\n                    port_obj.name = re_obj.group(\"port_name\")\n                    port_obj.bcm_id = int(re_obj.group(\"bcm_id\"))\n                    port_obj.link_status = re_obj.group(\"link\")\n                    port_obj.speed = int(re_obj.group(\"speed\"))\n                    PORT_LIST.append(port_obj)\n                number += 1\n\n    if not only_update:\n        content = BCM_SHELL.run(\"led status\")\n        for line in content.split(\"\\n\"):\n            re_obj = re.search(r\"(?P<bcm_id>\\d+).+(?P<led_up>\\d)\\:\", line)\n            if re_obj is not None:\n                if int(re_obj.group(\"bcm_id\")) not in EAGLE_CORE:\n                    PORT_LIST[count].led_up = int(re_obj.group(\"led_up\"))\n                    PORT_LIST[count].led_index = _lookup_led_index(PORT_LIST[count])\n                    count += 1\n\n        if number is not count:\n            PORT_LIST = []\n            syslog.syslog(syslog.LOG_ERR, \"The amount of port is not match\")\n\n\n\ndef sync_bcmsh_socket():\n\n    global BCM_SHELL\n    global SHELL_READY\n    waitSyncd   = True\n    retryCount  = 0\n\n    while waitSyncd:\n        time.sleep(10)\n        try:\n            BCM_SHELL = bcmshell()\n            BCM_SHELL.run(\"Echo\")\n            waitSyncd = False\n        except Exception, e:\n            print \"{0}, Retry times({1})\".format(str(e),retryCount)\n            #syslog.syslog(syslog.LOG_DEBUG, \"{0}, Retry times({1})\".format(str(e),retryCount))\n            retryCount += 1\n\n    syslog.syslog(syslog.LOG_INFO, \"bcmshell socket create successfully\")\n\n    if SHELL_READY is False:\n        SHELL_READY = True\n        return\n    elif SHELL_READY is True:\n        update_led_status()\n\n\n\ndef update_led_status():\n\n    led_thread      = True  # True/False (gate to turn on/off)\n    reset_sec       = 2\n    count_down      = 0\n    queue_active    = []\n    port_data       = None\n    s_byte          = None\n\n\n    # thread for keeping update port status in data ram\n    while led_thread:\n        try:\n            if count_down == 0:\n                queue_active = []\n                _update_port_list(1)\n                for port in PORT_LIST:\n                    if port.link_status == \"up\":\n                        queue_active.append(port)\n                    else:\n                        port_data = 0\n                        port.write_data_ram(port_data)\n                count_down = reset_sec\n            else:\n                for port in queue_active:\n                    port_data = 0\n\n                    if BOARD_TPYE == \"inventec_d6254qs\":\n                        s_byte = port.read_data_ram()\n                        if s_byte&STATUS_RX:\n                            port_data |= BIT_RX\n                        if s_byte&STATUS_TX:\n                            port_data |= BIT_TX\n                        port_data |= BIT_LINK\n\n                    elif BOARD_TPYE == \"inventec_d7032q28b\":\n                        s_byte = port.read_data_ram()\n                        if s_byte&STATUS_RX:\n                            port_data |= BIT_RX\n                        if s_byte&STATUS_TX:\n                            port_data |= BIT_TX\n                        if port.speed == SPEED_100G:\n                            port_data |= BIT_SPEED0\n                            port_data |= BIT_SPEED1\n                        elif port.speed == SPEED_40G:\n                            port_data |= BIT_SPEED1\n                        elif port.speed == SPEED_25G:\n                            port_data |= BIT_SPEED0\n                        else:\n                            pass\n                        port_data |= BIT_LINK\n\n                    elif BOARD_TPYE == \"inventec_d7054q28b\":\n                        if port.speed != SPEED_100G and port.speed != SPEED_25G:\n                            port_data |= BIT_SPEED0\n\n                    # write data to update data ram for specific port\n                    port.write_data_ram(port_data)\n\n                time.sleep(0.5)\n                count_down -= 1\n\n        except Exception, e:\n            syslog.syslog(syslog.LOG_WARNING, \"{0}\".format(str(e)))\n            sync_bcmsh_socket()\n\n\n\ndef debug_print():\n\n    for port in PORT_LIST:\n        output = \"\"\n        output += \"name:{0} | \".format(port.name)\n        output += \"port_num:{0} | \".format(port.port_num)\n        output += \"bcm_id:{0} | \".format(port.bcm_id)\n        output += \"link_status:{0} | \".format(port.link_status)\n        output += \"speed:{0} | \".format(port.speed)\n        output += \"led_up:{0} | \".format(port.led_up)\n        output += \"s_addr:{0} | \".format(port.s_addr)\n        output += \"write2_up:{0} | \".format(port.write2_up)\n        output += \"led_index:{0} | \".format(port.led_index)\n        print output\n\n\nif __name__ == \"__main__\":\n\n    syslog.openlog(\"led_proc\", syslog.LOG_PID, facility=syslog.LOG_DAEMON)\n\n    sync_bcmsh_socket()\n    _board_init()\n    _update_port_list(0)\n    #debug_print()\n    update_led_status()\n\n    syslog.closelog()\n"}, "/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py": {"changes": [{"diff": "\n \n             # Receive thermaltrip event\n             if event['ACTION'] == 'remove' and event['DEVPATH'] == '/kernel/platform_status/fan':\n-                os.system(\"shutdown -h now\")\n+                subprocess.call([\"shutdown\", \"-h\", \"now\"])\n                 ", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py", "badparts": ["                os.system(\"shutdown -h now\")"], "goodparts": ["                subprocess.call([\"shutdown\", \"-h\", \"now\"])"]}], "source": "\n import os import socket from collections import OrderedDict NETLINK_KOBJECT_UEVENT=15 class KernelEventMonitor(object): def __init__(self): self.received_events=OrderedDict() self.socket=socket.socket(socket.AF_NETLINK, socket.SOCK_DGRAM, NETLINK_KOBJECT_UEVENT) def start(self): self.socket.bind((os.getpid(), -1)) def stop(self): self.socket.close() def __enter__(self): self.start() return self def __exit__(self, exc_type, exc_value, traceback): self.stop() def __iter__(self): while True: for item in monitor.next_events(): yield item def next_events(self): data=self.socket.recv(16384) event={} for item in data.split(b'\\x00'): if not item: if event and event['SEQNUM'] not in self.received_events: self.received_events[event['SEQNUM']]=None if(len(self.received_events) > 100): self.received_events.popitem(last=False) yield event event={} else: try: k, v=item.split(b'=', 1) event[k.decode('ascii')]=v.decode('ascii') except ValueError: pass if __name__=='__main__': with KernelEventMonitor() as monitor: for event in monitor: if event['SUBSYSTEM']=='platform_status': print('subsystem is platform_status') if event['ACTION']=='remove' and event['DEVPATH']=='/kernel/platform_status/fan': os.system(\"shutdown -h now\") ", "sourceWithComments": "#!/usr/bin/env python\n\nimport os\nimport socket\nfrom collections import OrderedDict\n\n# Purpose:  Shutdown DUT upon receiving thermaltrip event from kernel (inv_pthread)\n\nNETLINK_KOBJECT_UEVENT = 15\n\nclass KernelEventMonitor(object):\n\n    def __init__(self):\n        self.received_events = OrderedDict()\n        self.socket = socket.socket(socket.AF_NETLINK, socket.SOCK_DGRAM, NETLINK_KOBJECT_UEVENT)\n\n    def start(self):\n        self.socket.bind((os.getpid(), -1))\n\n    def stop(self):\n        self.socket.close()\n\n    def __enter__(self):\n        self.start()\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.stop()\n\n    def __iter__(self):\n        while True:\n          for item in monitor.next_events():\n              yield item\n\n    def next_events(self):\n        data = self.socket.recv(16384)\n        event = {}\n        for item in data.split(b'\\x00'):\n            if not item:        \n                #check if we have an event and if we already received it\n                if event and event['SEQNUM'] not in self.received_events:\n                    self.received_events[event['SEQNUM']] = None\n                    if (len(self.received_events) > 100):\n                        self.received_events.popitem(last=False)\n                    yield event\n                event = {}\n            else:\n                try:\n                    k, v = item.split(b'=', 1)\n                    event[k.decode('ascii')] = v.decode('ascii')\n                except ValueError:\n                    pass\n\nif __name__ == '__main__':\n    with KernelEventMonitor() as monitor:\n        for event in monitor:\n            if event['SUBSYSTEM'] == 'platform_status':\n                print('subsystem is platform_status')\n\n            # Receive thermaltrip event\n            if event['ACTION'] == 'remove' and event['DEVPATH'] == '/kernel/platform_status/fan':\n                os.system(\"shutdown -h now\")\n                \n\n"}, "/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py": {"changes": [{"diff": "\n     \n     def get_platform(self):\n         if self.platform is None:\n-            self.platform = os.popen(\"uname -n\").read().strip()\n+            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"])\n         return self.platform\n     \n     def get_port_to_bcm_mapping(self)", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py", "badparts": ["            self.platform = os.popen(\"uname -n\").read().strip()"], "goodparts": ["            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"])"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object Auto detecting the transceiver and set the correct if_type value options: -h | --help : this help message -d | --debug : run with debug mode \"\"\" try: import os import commands import sys, getopt import logging import re import time import datetime import syslog from sfputil import SfpUtil from sonic_sfp.bcmshell import bcmshell except ImportError as e: raise ImportError(\"%s -required module not found\" % str(e)) DEBUG=False args=[] INV_REDWOOD_PLATFORM=\"SONiC-Inventec-d7032-100\" INV_CYPRESS_PLATFORM=\"SONiC-Inventec-d7054\" INV_SEQUOIA_PLATFORM=\"SONiC-Inventec-d7264\" INV_MAPLE_PLATFORM=\"SONiC-Inventec-d6556\" INV_MAGNOLIA_PLATFORM=\"SONiC-Inventec-d6254qs\" transceiver_type_dict={ \"FCBG110SD1C03\": \"SR\", \"FCBG110SD1C05\": \"SR\", \"FTLX8571D3BCL\": \"SR\", \"FTLX8574D3BCL\": \"SR\", \"AFBR-709DMZ\": \"SR\", \"AFBR-709SMZ\": \"SR\", \"FTLX8571D3BCV\": \"SR\", \"FTLX1471D3BCL\": \"SR\", \"FTLX1871M3BCL\": \"SR\", \"FTLF8536P4BCL\": \"SR\", \"FCBG125SD1C05\": \"SR\", \"FCBG125SD1C30\": \"SR\", \"FCBG125SD1C03\": \"SR\", \"FCBG410QB1C03-1E\": \"SR4\", \"FCBG4100QB1C030-1E\": \"SR4\", \"885350163\": \"SR4\", \"88535017\": \"SR4\", \"FTL410QE2C\": \"SR4\", \"FTL410QD3C\": \"SR4\", \"FTL410QD2C\": \"SR4\", \"AFBR-79E3PZ\": \"SR4\", \"AFBR-79Q4Z\": \"SR4\", \"FTL4C1QE1C\": \"SR4\", \"FTLC9551REPM\": \"SR4\", \"FTLC1151RDPL\": \"SR4\", \"DAC-010SS-X50\": \"KR\", \"DAC-010QQ-X50\": \"KR4\", \"DAC-040QS-007\": \"KR4\", \"DAC-040QQ-007\": \"KR4\", \"DAC-040QQ-005\": \"KR4\", \"DAC-040QS-005\": \"KR4\", \"NDAAFF-0001\": \"KR4\", \"L0HQF001-SD-R\": \"KR4\", \"DAC-Q28/Q28-28-01\": \"KR4\", \"NDAAFF-0003\": \"KR4\", \"NDAQGF0001\": \"KR4\", \"L0HQF003-SD-R\": \"KR4\", \"NDAQGJ-0003\": \"KR4\", \"L0HQF004-SD-R\": \"KR4\", \"L0HSF006-SD-R\": \"KR\", \"L0HSF007-SD-R\": \"KR\", \"L0HSF008-SD-R\": \"KR\", \"L0HQF009-SD-R\": \"KR4\", \"FSPP-H7-M85-X3D\": \"SR\", \"PT0-M3-4D33K-C2\": \"SR\", \"RTXM228-551\": \"SR\", \"RTXM330-003\": \"SR\", \"RTXM330-030\": \"SR\", \"MFA2P10-A005\": \"SR\", \"QAB-OA03MC\": \"SR4\", \"QAB-OA05MC\": \"SR4\", \"RTXM320-571\": \"SR4\", \"AFBR-89CDDZ\": \"SR4\", \"RTXM420-550\": \"SR4\", \"MMA1B00-C100D\": \"SR4\", \"RTXM420-551\": \"SR4\", \"E04025QTXA000\": \"SR4\", \"LQ210PR-Oxxx\": \"SR4\", \"TR-FC13L-N00\": \"SR4\", \"SPQ-CE-LR-CDFL\": \"SR4\", \"FIM37700/170\": \"SR4\", \"FCBN425QE1C03\": \"SR4\", \"TQS-Q14H8-XCAXX\": \"SR4\", \"FPD-203R008-10/3\": \"SR4\", \"LTA8531-PC+\": \"SR4\" } initial_command=[] def show_help(): print __doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]} sys.exit(0) def log_message( string): syslog.openlog(\"transceiver_monitor\", syslog.LOG_PID, facility=syslog.LOG_DAEMON) syslog.syslog(syslog.LOG_NOTICE, string) class BCMUtil(bcmshell): port_to_bcm_mapping=dict() sal_config_list=dict() eagle_list=[] platform=None def get_platform(self): if self.platform is None: self.platform=os.popen(\"uname -n\").read().strip() return self.platform def get_port_to_bcm_mapping(self): if self.port_to_bcm_mapping is None: return dict() else: return self.port_to_bcm_mapping def show_port_to_bcm_mapping(self): for key,value in self.port_to_bcm_mapping.iteritems(): print \"{0}---{1}\".format(key, value) def get_eagle_port(self): return self.eagle_list def parsing_eagle_port(self): name=self.get_platform() if name is not None: if name==INV_REDWOOD_PLATFORM: self.eagle_list=[66,100] elif name==INV_CYPRESS_PLATFORM: self.eagle_list=[66,100] elif name==INV_SEQUOIA_PLATFORM: self.eagle_list=[66,100] elif name==INV_MAPLE_PLATFORM: self.eagle_list=[66,130] else: self.eagle_list=[] def get_sal_config_list(self): return self.sal_config_list def show_sal_config_list(self): for key,value in self.sal_config_list.iteritems(): print \"{0}---{1}\".format(key, value) def initial_sal_config_list( self): content=self.run(\"config\") for line in content.split(\"\\n\"): ConfigObject=re.search(r\"portmap\\_(?P<bcm_id>\\d+)\\=(?P<lane_id>\\d+)\\:\\d+\",line) if ConfigObject is not None: if int(ConfigObject.group(\"bcm_id\")) not in self.get_eagle_port(): self.get_sal_config_list()[int(ConfigObject.group(\"bcm_id\"))]={\"lane\": int(ConfigObject.group(\"lane_id\")), \"speed\": None, \"portname\": None} def parsing_port_list(self): content=self.run(\"ps\") count=0 for line in content.split(\"\\n\"): PSObject=re.search(r\"(?P<port_name>(xe|ce)\\d+)\\(\\s*(?P<bcm_id>\\d+)\\).+\\s+(?P<speed>\\d+)G\",line) if PSObject is not None: if int(PSObject.group(\"bcm_id\")) not in self.get_eagle_port(): if self.get_sal_config_list().has_key(int(PSObject.group(\"bcm_id\"))): self.get_sal_config_list()[int(PSObject.group(\"bcm_id\"))][\"portname\"]=PSObject.group(\"port_name\") self.get_sal_config_list()[int(PSObject.group(\"bcm_id\"))][\"speed\"]=int(PSObject.group(\"speed\"))*1000 self.port_to_bcm_mapping[count]=int(PSObject.group(\"bcm_id\")) count=count +1 def execute_command(self, cmd): self.cmd(cmd) class TransceiverUtil(SfpUtil): transceiver_port_mapping=dict() def get_transceiver_port_mapping(self): return self.transceiver_port_mapping def show_transceiver_port_mapping(self): for key,value in self.transceiver_port_mapping.iteritems(): print \"{0}---{1}\".format(key, value) def get_bcm_port_name(self, index): if self.transceiver_port_mapping.has_key(index) and bcm_obj.get_sal_config_list().has_key(self.transceiver_port_mapping[index][\"bcm\"]): return bcm_obj.get_sal_config_list()[self.transceiver_port_mapping[index][\"bcm\"]][\"portname\"] else: return \"\" def get_port_to_i2c_mapping(self): if self.port_to_i2c_mapping is None: return dict() else: return self.port_to_i2c_mapping def show_port_to_i2c_mapping(self): for key,value in self.port_to_i2c_mapping.iteritems(): print \"{0}---{1}\".format(key, value) def get_eeprom_partNum(self, portNum): tempdict=dict() tempdict=self.get_eeprom_dict(portNum) self.get_eeprom_partNum_from_parser_eeprom_dict(tempdict) def get_eeprom_dict_info(self, portNum): return self.get_eeprom_dict(portNum) def get_eeprom_partNum_from_parser_eeprom_dict(self, tempdict): if tempdict is not None: if tempdict[\"interface\"][\"data\"].has_key(\"VendorPN\"): return tempdict[\"interface\"][\"data\"][\"VendorPN\"] elif tempdict[\"interface\"][\"data\"].has_key(\"Vendor PN\"): return tempdict[\"interface\"][\"data\"][\"Vendor PN\"] else: return None else: return None def get_transceiver_type(self, pn): if pn is not None: if transceiver_type_dict.has_key(pn.upper()): return transceiver_type_dict[pn.upper()] else: return None def set_transceiver_type( self, portNum, pn): type=self.get_transceiver_type( pn) if type is not None: if bcm_obj.get_platform()==INV_SEQUOIA_PLATFORM or bcm_obj.get_platform()==INV_MAPLE_PLATFORM: speed=bcm_obj.get_sal_config_list()[self.transceiver_port_mapping[portNum][\"bcm\"]][\"speed\"] bcm_obj.execute_command( \"port %s if=%s speed=%d\" %( self.get_bcm_port_name(portNum), type, speed)) else: bcm_obj.execute_command( \"port %s if=%s\" %( self.get_bcm_port_name(portNum), type)) print \"Detecting port{0}({1}) need to change interface type{2}({3})\".format( self.get_bcm_port_name(portNum), portNum, type, self.get_transceiver_port_mapping()[portNum][\"pn\"]) log_message(\"Detecting port{0} need to change interface type{1}({2})\".format(self.get_bcm_port_name(portNum), type, self.get_transceiver_port_mapping()[portNum][\"pn\"])) def initial_transceiver_port_mapping(self): for index in self.get_port_to_i2c_mapping().keys(): if self.transceiver_port_mapping.has_key(index) is False: i2cValue=self.get_port_to_i2c_mapping()[index] bcmValue=bcm_obj.get_port_to_bcm_mapping()[index] self.transceiver_port_mapping[index]={\"i2c\": i2cValue, \"bcm\": bcmValue, \"pn\": None} def set_power_mode_for_QSFP(self): for index in self.get_port_to_i2c_mapping().keys(): if index >=self.qsfp_port_start and index <=self.qsfp_port_end: self.set_low_power_mode(index, False) else: self.set_tx_disable(index) def set_tx_disable(self, port_num): if port_num >=self.qsfp_port_start and port_num <=self.qsfp_port_end: pass else: try: tx_file=open(\"/sys/class/swps/port\"+str(port_num)+\"/tx_disable\", \"r+\") except IOError as e: print \"Error: unable to open file: %s\" % str(e) return False reg_value=int(tx_file.readline().rstrip()) if reg_value==1: reg_value=0 tx_file.write(hex(reg_value)) tx_file.close() def main(): global DEBUG global transceiver_obj global bcm_obj initalNotOK=True retestCount=0 while initalNotOK: try: transceiver_obj=TransceiverUtil() bcm_obj=BCMUtil() initalNotOK=False except Exception, e: log_message(\"Exception. The warning is{0}, Retry again({1})\".format(str(e),retestCount)) retestCount=retestCount +1 time.sleep(5) log_message( \"Object initialed successfully\") options, args=getopt.getopt(sys.argv[1:], 'hd',['help', 'debug' ]) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) else: logging.info(\"no option\") initalNotOK=True while initalNotOK: try: for cmd_index in initial_command: bcm_obj.execute_command(cmd_index) bcm_obj.parsing_eagle_port() bcm_obj.initial_sal_config_list() bcm_obj.parsing_port_list() transceiver_obj.initial_transceiver_port_mapping() initalNotOK=False except Exception, e: log_message(\"Exception. The warning is{0}\".format(str(e))) time.sleep(5) transceiver_obj.set_power_mode_for_QSFP() while 1: try: if bcm_obj.get_platform()==INV_SEQUOIA_PLATFORM: bcm_obj.parsing_port_list() for index in transceiver_obj.get_port_to_i2c_mapping().keys(): info=transceiver_obj.get_eeprom_dict_info(index) value=transceiver_obj.get_eeprom_partNum_from_parser_eeprom_dict(info) if transceiver_obj.get_transceiver_port_mapping().has_key(index) is not False and transceiver_obj.get_transceiver_port_mapping()[index][\"pn\"] <> value: transceiver_obj.get_transceiver_port_mapping()[index][\"pn\"]=value transceiver_obj.set_transceiver_type(index,value) transceiver_obj.set_tx_disable(index) except Exception, e: log_message(\"Exception. The warning is{0}\".format(str(e))) time.sleep(1) syslog.closelog() del transceiver_obj del bcm_obj if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2018 Inventec, Inc.\n# \n# Editor: James Huang ( Huang.James@inventec.com )\n#  \n# \n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\nAuto detecting the transceiver and set the correct if_type value\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n   \n\"\"\"\n\ntry:\n    import os\n    import commands\n    import sys, getopt\n    import logging\n    import re\n    import time\n    import datetime\n    import syslog\n    from sfputil import SfpUtil\n    from sonic_sfp.bcmshell import bcmshell\n    \nexcept ImportError as e:\n    raise ImportError(\"%s - required module not found\" % str(e))\n\nDEBUG = False\nargs = []\nINV_REDWOOD_PLATFORM = \"SONiC-Inventec-d7032-100\"\nINV_CYPRESS_PLATFORM = \"SONiC-Inventec-d7054\"\nINV_SEQUOIA_PLATFORM = \"SONiC-Inventec-d7264\"\nINV_MAPLE_PLATFORM = \"SONiC-Inventec-d6556\"\nINV_MAGNOLIA_PLATFORM = \"SONiC-Inventec-d6254qs\"\n\ntransceiver_type_dict = { \n                          \"FCBG110SD1C03\": \"SR\",\n                          \"FCBG110SD1C05\": \"SR\",\n                          \"FTLX8571D3BCL\": \"SR\",\n                          \"FTLX8574D3BCL\": \"SR\",\n                          \"AFBR-709DMZ\": \"SR\",\n                          \"AFBR-709SMZ\": \"SR\",\n                          \"FTLX8571D3BCV\": \"SR\",\n                          \"FTLX1471D3BCL\": \"SR\",\n                          \"FTLX1871M3BCL\": \"SR\",\n                          \"FTLF8536P4BCL\": \"SR\",\n                          \"FCBG125SD1C05\": \"SR\",\n                          \"FCBG125SD1C30\": \"SR\",\n                          \"FCBG125SD1C03\": \"SR\",\n                          \"FCBG410QB1C03-1E\": \"SR4\",\n                          \"FCBG4100QB1C030-1E\": \"SR4\",\n                          \"885350163\": \"SR4\",\n                          \"88535017\": \"SR4\",\n                          \"FTL410QE2C\": \"SR4\",\n                          \"FTL410QD3C\": \"SR4\",\n                          \"FTL410QD2C\": \"SR4\",\n                          \"AFBR-79E3PZ\": \"SR4\",\n                          \"AFBR-79Q4Z\": \"SR4\",\n                          \"FTL4C1QE1C\": \"SR4\",\n                          \"FTLC9551REPM\": \"SR4\",\n                          \"FTLC1151RDPL\": \"SR4\",\n                          \"DAC-010SS-X50\" : \"KR\",\n                          \"DAC-010QQ-X50\": \"KR4\",\n                          \"DAC-040QS-007\": \"KR4\",\n                          \"DAC-040QQ-007\": \"KR4\",\n                          \"DAC-040QQ-005\": \"KR4\",\n                          \"DAC-040QS-005\": \"KR4\",\n                          \"NDAAFF-0001\": \"KR4\",\n                          \"L0HQF001-SD-R\": \"KR4\",\n                          \"DAC-Q28/Q28-28-01\": \"KR4\",\n                          \"NDAAFF-0003\": \"KR4\",\n                          \"NDAQGF0001\": \"KR4\",\n                          \"L0HQF003-SD-R\": \"KR4\",\n                          \"NDAQGJ-0003\": \"KR4\",\n                          \"L0HQF004-SD-R\": \"KR4\",\n                          \"L0HSF006-SD-R\": \"KR\",\n                          \"L0HSF007-SD-R\": \"KR\",\n                          \"L0HSF008-SD-R\": \"KR\",\n                          \"L0HQF009-SD-R\": \"KR4\",\n                          \"FSPP-H7-M85-X3D\": \"SR\",   \n                          \"PT0-M3-4D33K-C2\": \"SR\",\n                          \"RTXM228-551\": \"SR\",\n                          \"RTXM330-003\": \"SR\",\n                          \"RTXM330-030\": \"SR\",   \n                          \"MFA2P10-A005\": \"SR\",\n                          \"QAB-OA03MC\": \"SR4\",\n                          \"QAB-OA05MC\": \"SR4\",\n                          \"RTXM320-571\": \"SR4\",\n                          \"AFBR-89CDDZ\": \"SR4\",\n                          \"RTXM420-550\": \"SR4\",\n                          \"MMA1B00-C100D\": \"SR4\",\n                          \"RTXM420-551\": \"SR4\",\n                          \"E04025QTXA000\": \"SR4\",\n                          \"LQ210PR-Oxxx\": \"SR4\",\n                          \"TR-FC13L-N00\": \"SR4\",  \n                          \"SPQ-CE-LR-CDFL\": \"SR4\",\n                          \"FIM37700/170\": \"SR4\",\n                          \"FCBN425QE1C03\": \"SR4\",\n                          \"TQS-Q14H8-XCAXX\": \"SR4\",\n                          \"FPD-203R008-10/3\": \"SR4\",\n                          \"LTA8531-PC+\": \"SR4\"                       \n                        }\n \ninitial_command = []\n\ndef show_help():\n    print __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]}\n    sys.exit(0)\n\ndef log_message( string ):\n    syslog.openlog(\"transceiver_monitor\", syslog.LOG_PID, facility=syslog.LOG_DAEMON)\n    syslog.syslog(syslog.LOG_NOTICE, string)\n\nclass BCMUtil(bcmshell):\n\n    port_to_bcm_mapping = dict()         \n    sal_config_list = dict()\n    eagle_list = []\n    platform = None\n    \n    def get_platform(self):\n        if self.platform is None:\n            self.platform = os.popen(\"uname -n\").read().strip()\n        return self.platform\n    \n    def get_port_to_bcm_mapping(self):  \n        if self.port_to_bcm_mapping is None:\n            return dict()\n        else:\n            return self.port_to_bcm_mapping     \n    \n    def show_port_to_bcm_mapping(self): \n        for key,value in self.port_to_bcm_mapping.iteritems():\n            print \"{0}---{1}\".format(key, value)    \n    \n    def get_eagle_port(self):\n        return self.eagle_list\n        \n    def parsing_eagle_port(self):\n        name = self.get_platform()\n        if name is not None:\n            if name == INV_REDWOOD_PLATFORM:\n                self.eagle_list = [66,100]\n            elif name == INV_CYPRESS_PLATFORM:\n                self.eagle_list = [66,100]\n            elif name == INV_SEQUOIA_PLATFORM:\n                self.eagle_list = [66,100]\n            elif name == INV_MAPLE_PLATFORM:\n                self.eagle_list = [66,130]\n            else:\n                self.eagle_list = []\n                \n    def get_sal_config_list(self):\n        return self.sal_config_list\n\n    def show_sal_config_list(self):\n        for key,value in self.sal_config_list.iteritems():\n            print \"{0}---{1}\".format(key, value)\n        \n    def initial_sal_config_list( self ):\n        content = self.run(\"config\")  \n        for line in content.split(\"\\n\"):\n            ConfigObject = re.search(r\"portmap\\_(?P<bcm_id>\\d+)\\=(?P<lane_id>\\d+)\\:\\d+\",line)\n            if ConfigObject is not None:   \n                if int(ConfigObject.group(\"bcm_id\")) not in self.get_eagle_port():\n                    self.get_sal_config_list()[int(ConfigObject.group(\"bcm_id\"))]={\"lane\": int(ConfigObject.group(\"lane_id\")), \"speed\": None, \"portname\": None} \n                \n    def parsing_port_list(self):\n        content = self.run(\"ps\")\n        count = 0\n        for line in content.split(\"\\n\"):\n            PSObject = re.search(r\"(?P<port_name>(xe|ce)\\d+)\\(\\s*(?P<bcm_id>\\d+)\\).+\\s+(?P<speed>\\d+)G\",line)\n            if PSObject is not None:\n                if int(PSObject.group(\"bcm_id\")) not in self.get_eagle_port():                    \n                    if self.get_sal_config_list().has_key(int(PSObject.group(\"bcm_id\"))):\n                        self.get_sal_config_list()[int(PSObject.group(\"bcm_id\"))][\"portname\"] = PSObject.group(\"port_name\")\n                        self.get_sal_config_list()[int(PSObject.group(\"bcm_id\"))][\"speed\"] = int(PSObject.group(\"speed\"))*1000\n                        self.port_to_bcm_mapping[count] = int(PSObject.group(\"bcm_id\"))\n                        count = count +1\n                \n    \n    def execute_command(self, cmd):\n        self.cmd(cmd)\n\nclass TransceiverUtil(SfpUtil):     \n    \n    transceiver_port_mapping = dict()\n    \n    def get_transceiver_port_mapping(self):\n        return self.transceiver_port_mapping\n        \n    def show_transceiver_port_mapping(self):\n        for key,value in self.transceiver_port_mapping.iteritems():\n            print \"{0}---{1}\".format(key, value)     \n       \n    def get_bcm_port_name(self, index):\n        if self.transceiver_port_mapping.has_key(index) and bcm_obj.get_sal_config_list().has_key(self.transceiver_port_mapping[index][\"bcm\"]):\n            return bcm_obj.get_sal_config_list()[self.transceiver_port_mapping[index][\"bcm\"]][\"portname\"]            \n        else:\n            return \"\"\n                \n    def get_port_to_i2c_mapping(self):\n        if self.port_to_i2c_mapping is None:\n            return dict()\n        else:\n            return self.port_to_i2c_mapping\n    \n    def show_port_to_i2c_mapping(self):\n        for key,value in self.port_to_i2c_mapping.iteritems():\n            print \"{0}---{1}\".format(key, value)\n        \n    def get_eeprom_partNum(self, portNum):\n        tempdict = dict()\n        tempdict = self.get_eeprom_dict(portNum)\n        self.get_eeprom_partNum_from_parser_eeprom_dict(tempdict)\n    \n    def get_eeprom_dict_info(self, portNum): \n        return self.get_eeprom_dict(portNum) \n                \n    def get_eeprom_partNum_from_parser_eeprom_dict(self, tempdict ):\n        if tempdict is not None:\n            if tempdict[\"interface\"][\"data\"].has_key(\"VendorPN\"):\n               return tempdict[\"interface\"][\"data\"][\"VendorPN\"]\n            elif tempdict[\"interface\"][\"data\"].has_key(\"Vendor PN\"):\n                return tempdict[\"interface\"][\"data\"][\"Vendor PN\"]\n            else:\n                return None\n        else:\n            return None\n            \n    def get_transceiver_type(self, pn ):\n        if pn is not None:\n            if transceiver_type_dict.has_key(pn.upper()):\n                return transceiver_type_dict[pn.upper()]\n            else:\n                return None    \n\n    def set_transceiver_type( self, portNum, pn ):\n        type = self.get_transceiver_type( pn )\n        if type is not None:             \n            if bcm_obj.get_platform() == INV_SEQUOIA_PLATFORM or bcm_obj.get_platform() == INV_MAPLE_PLATFORM :\n                speed = bcm_obj.get_sal_config_list()[self.transceiver_port_mapping[portNum][\"bcm\"]][\"speed\"]\n                bcm_obj.execute_command( \"port %s if=%s speed=%d\" % ( self.get_bcm_port_name(portNum), type, speed ) )\n            else:\n                bcm_obj.execute_command( \"port %s if=%s\" % ( self.get_bcm_port_name(portNum), type ) )\n            print \"Detecting port {0}({1})  need to change interface type {2} ({3})\".format( self.get_bcm_port_name(portNum), portNum, type, self.get_transceiver_port_mapping()[portNum][\"pn\"])\n            log_message(\"Detecting port {0} need to change interface type {1} ({2})\".format(self.get_bcm_port_name(portNum), type, self.get_transceiver_port_mapping()[portNum][\"pn\"]) )\n    \n    def initial_transceiver_port_mapping(self):\n        for index in self.get_port_to_i2c_mapping().keys():\n            if self.transceiver_port_mapping.has_key(index) is False :\n                i2cValue = self.get_port_to_i2c_mapping()[index]\n                bcmValue = bcm_obj.get_port_to_bcm_mapping()[index]\n                self.transceiver_port_mapping[index]={\"i2c\": i2cValue, \"bcm\": bcmValue , \"pn\": None}\n            \n    def set_power_mode_for_QSFP(self):\n        for index in self.get_port_to_i2c_mapping().keys():\n            if index >= self.qsfp_port_start and index <= self.qsfp_port_end :\n                self.set_low_power_mode(index, False)\n            else:\n                # To set tx_disable\n                self.set_tx_disable(index)\n\n    def set_tx_disable(self, port_num):\n        if port_num >= self.qsfp_port_start and port_num <= self.qsfp_port_end :\n            pass\n        else:\n            try:\n                tx_file = open(\"/sys/class/swps/port\"+str(port_num)+\"/tx_disable\", \"r+\")\n            except IOError as e:\n                print \"Error: unable to open file: %s\" % str(e)\n                return False\n\n            reg_value = int(tx_file.readline().rstrip())\n\n            # always set 0 to tx_disable field\n            if reg_value == 1 :\n                reg_value = 0        \n                tx_file.write(hex(reg_value))\n                tx_file.close()\n\n        \ndef main():\n\n    global DEBUG  \n    global transceiver_obj\n    global bcm_obj\n    \n    initalNotOK = True\n    retestCount = 0 \n    while initalNotOK :\n        try:                \n            transceiver_obj = TransceiverUtil()\n            bcm_obj = BCMUtil()\n            initalNotOK = False\n        except Exception, e:               \n            log_message(\"Exception. The warning is {0}, Retry again ({1})\".format(str(e),retestCount) )                    \n            retestCount = retestCount + 1\n        time.sleep(5)\n     \n    log_message( \"Object initialed successfully\" )  \n    options, args = getopt.getopt(sys.argv[1:], 'hd', ['help',\n                                                       'debug'\n                                                          ])\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):            \n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        else:\n            logging.info(\"no option\")\n    \n    initalNotOK = True\n    while initalNotOK :\n        try :\n            # Before loop, You could execute specific command to initial chip\n            for cmd_index in initial_command :\n                bcm_obj.execute_command(cmd_index)\n            \n            # Initial the sal config list\n            bcm_obj.parsing_eagle_port()\n            bcm_obj.initial_sal_config_list()\n            # bcm_obj.show_sal_config_list()\n            bcm_obj.parsing_port_list()                 \n            #bcm_obj.show_port_to_bcm_mapping()                 \n            #bcm_obj.show_sal_config_list()\n            # transceiver_obj.show_port_to_i2c_mapping()\n            \n            # Initial the transceiver_obj \n            transceiver_obj.initial_transceiver_port_mapping()       \n            # transceiver_obj.show_transceiver_port_mapping()\n             \n            initalNotOK = False\n        except Exception, e:               \n            log_message(\"Exception. The warning is {0}\".format(str(e)) )\n        time.sleep(5)            \n    \n    # Improve the power mode for QSFP ports\n    transceiver_obj.set_power_mode_for_QSFP()\n\n    while 1 :\n        try:\n            if bcm_obj.get_platform() == INV_SEQUOIA_PLATFORM:\n                bcm_obj.parsing_port_list()  \n            for index in transceiver_obj.get_port_to_i2c_mapping().keys():\n                info = transceiver_obj.get_eeprom_dict_info(index)\n                value = transceiver_obj.get_eeprom_partNum_from_parser_eeprom_dict(info)\n                if transceiver_obj.get_transceiver_port_mapping().has_key(index) is not False and transceiver_obj.get_transceiver_port_mapping()[index][\"pn\"] <> value:\n                    transceiver_obj.get_transceiver_port_mapping()[index][\"pn\"] = value\n                    transceiver_obj.set_transceiver_type(index,value) \n                    transceiver_obj.set_tx_disable(index)\n                    #transceiver_obj.show_transceiver_port_mapping()     \n            # transceiver_obj.show_transceiver_port_mapping()       \n        except Exception, e:\n            log_message(\"Exception. The warning is {0}\".format(str(e)) )            \n        time.sleep(1)\n\n    syslog.closelog()\n    del transceiver_obj\n    del bcm_obj\n\nif __name__ == \"__main__\":\n    main()\n\n\n\n\n\n\n\n"}, "/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py": {"changes": [{"diff": "\n         return True\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/dev", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py", "badparts": ["        return os.system(\"docker > /dev/null 2>&1\") == 0"], "goodparts": ["        return subprocess.call([\"docker\"]) == 0"]}]}, "/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py": {"changes": [{"diff": "\n \t      return status\n     for addr_offset in range (0,FAN_NUM):\n         addr=FAN_VPD_ADDR_BASE+addr_offset\n-        cmd = \"i2cdetect -y \"+str(FAN_VPD_CHANNEL)+\" \"+str(addr)+\" \"+str(addr)+\" | grep \"+str(hex(addr)).replace('0x','')\n-        result=os.system(cmd)\n+        cmd1 = [\"i2cdetect\", \"-y\", str(FAN_VPD_CHANNEL), str(addr), str(addr)]\n+        cmd2 = [\"grep\", f'{addr:x}']\n+        result, _ = getstatusoutput_noshell_pipe(cmd1, cmd2)\n         if( result==0 ):\n             cmd=\"echo inv_eeprom \"+str(addr)+\" > /sys/bus/i2c/devices/i2c-\"+FAN_VPD_CHANNEL\n             status, output = exec_cmd(c", "add": 3, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py", "badparts": ["        cmd = \"i2cdetect -y \"+str(FAN_VPD_CHANNEL)+\" \"+str(addr)+\" \"+str(addr)+\" | grep \"+str(hex(addr)).replace('0x','')", "        result=os.system(cmd)"], "goodparts": ["        cmd1 = [\"i2cdetect\", \"-y\", str(FAN_VPD_CHANNEL), str(addr), str(addr)]", "        cmd2 = [\"grep\", f'{addr:x}']", "        result, _ = getstatusoutput_noshell_pipe(cmd1, cmd2)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes \"\"\" import os import commands import sys, getopt import logging import syslog import time DEBUG=False args=[] FORCE=0 FAN_VPD_CHANNEL=1 FAN_VPD_ADDR_BASE=0x52 FAN_NUM=5 RETRY_LIMIT=5 i2c_prefix='/sys/bus/i2c/devices/' if DEBUG==True: print sys.argv[0] print 'ARGV: ', sys.argv[1:] def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print options print args print len(sys.argv) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': install() elif arg=='clean': uninstall() else: show_help() return 0 def show_help(): print __doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]} sys.exit(0) def show_log(txt): if DEBUG==True: print \"[D6332]\"+txt return def exec_cmd(cmd, show): logging.info('Run:'+cmd) status, output=commands.getstatusoutput(cmd) show_log(cmd +\" with result:\" +str(status)) show_log(\" output:\"+output) if status: logging.info('Failed:'+cmd) if show: print('Failed:'+cmd) return status, output def link_dir(prefix,dst): retry=0 ret=False while(ret==False and retry<RETRY_LIMIT): ret=os.path.isdir(prefix) if ret==True: break time.sleep(0.5) retry+=1 if ret==True: dirs=os.listdir(prefix) ret=False for i in dirs: if i.startswith('hwmon'): src=prefix+i os.symlink(src,dst) ret=True break if ret==False: syslog.syslog(syslog.LOG_ERR, \"Can't find proper dir to link under %s\" % prefix) else: syslog.syslog(syslog.LOG_ERR,\"Path %s is not a dir\" % prefix) _path_prefix_list=[ \"/sys/bus/i2c/devices/i2c-pmbus-1/hwmon/\", \"/sys/bus/i2c/devices/i2c-pmbus-2/hwmon/\", \"/sys/devices/platform/coretemp.0/hwmon/\", \"/sys/bus/i2c/devices/i2c-tmp75-1/hwmon/\", \"/sys/bus/i2c/devices/i2c-tmp75-2/hwmon/\", \"/sys/bus/i2c/devices/i2c-tmp75-3/hwmon/\", \"/sys/bus/i2c/devices/i2c-tmp75-4/hwmon/\" ] _path_dst_list=[ \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/psu1\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/psu2\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/coretemp\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_1\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_2\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_3\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_4\", ] instantiate=[ 'echo inv_eeprom 0x55 > /sys/bus/i2c/devices/i2c-0/new_device' ] drivers=[ 'gpio_ich', 'lpc_ich', 'i2c-i801', 'i2c-mux', 'i2c-mux-pca954x', 'i2c-mux-pca9541', 'i2c-dev', 'ucd9000', 'inv_eeprom', 'inv_cpld', 'lm75', 'inv_platform', 'swps'] def system_install(boot_option): global FORCE status, output=exec_cmd(\"rmmod i2c_ismt \", 1) if status: print output if FORCE==0: return status status, output=exec_cmd(\"rmmod i2c-i801 \", 1) if status: print output if FORCE==0: return status status, output=exec_cmd(\"rmmod gpio_ich \", 1) if status: print output if FORCE==0: return status status, output=exec_cmd(\"rmmod lpc_ich \", 1) if status: print output if FORCE==0: return status ''' boot_option: 0 -normal, 1 -fast-reboot''' for i in range(0,len(drivers)): if drivers[i]==\"swps\": if boot_option==1: status, output=exec_cmd(\"modprobe swps io_no_init=1\", 1) else: status, output=exec_cmd(\"modprobe \"+drivers[i], 1) else: status, output=exec_cmd(\"modprobe \"+drivers[i], 1) if status: \t print output \t if FORCE==0: \t return status for i in range(0,len(instantiate)): status, output=exec_cmd(instantiate[i], 1) if status: \t print output \t if FORCE==0: \t return status for addr_offset in range(0,FAN_NUM): addr=FAN_VPD_ADDR_BASE+addr_offset cmd=\"i2cdetect -y \"+str(FAN_VPD_CHANNEL)+\" \"+str(addr)+\" \"+str(addr)+\" | grep \"+str(hex(addr)).replace('0x','') result=os.system(cmd) if( result==0): cmd=\"echo inv_eeprom \"+str(addr)+\" > /sys/bus/i2c/devices/i2c-\"+FAN_VPD_CHANNEL status, output=exec_cmd(cmd,1) if status: print output if FORCE==0: return status for i in range(12,20): cmd=\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-4/i2c-\"+str(i)+\"/new_device\" status, output=exec_cmd(cmd,1) if status: print output if FORCE==0: return status for i in range(20,28): status, output=exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-5/i2c-\"+str(i)+\"/new_device\", 1) if status: print output if FORCE==0: return status for i in range(28,36): status, output=exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-6/i2c-\"+str(i)+\"/new_device\", 1) if status: print output if FORCE==0: return status for i in range(36,44): status, output=exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-7/i2c-\"+str(i)+\"/new_device\", 1) if status: print output if FORCE==0: return status for i in range(0,len(_path_prefix_list)): if( os.path.islink(_path_dst_list[i])): os.unlink(_path_dst_list[i]) syslog.syslog(syslog.LOG_WARNING, \"Path %s exists, remove before link again\" % _path_dst_list[i]) link_dir(_path_prefix_list[i],_path_dst_list[i]) return def system_ready(): if not device_found(): return False return True def install(boot_option=0): ''' boot_option: 0 -normal, 1 -fast-reboot ''' if not device_found(): print \"No device, installing....\" status=system_install(boot_option) if status: if FORCE==0: return status else: print \"D6332 devices detected....\" return def uninstall(): global FORCE for i in range(len(drivers)-1,-1,-1): status, output=exec_cmd(\"rmmod \"+drivers[i], 1) if status: \t print output \t if FORCE==0: \t return status return def device_found(): ret1, log=exec_cmd(\"ls \"+i2c_prefix+\"*0072\", 0) ret2, log=exec_cmd(\"ls \"+i2c_prefix+\"i2c-5\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2017 Inventec, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean \ncommand:\n    install         : install drivers and generate related sysfs nodes\n    clean           : uninstall drivers and remove related sysfs nodes\n\"\"\"\n\nimport os\nimport commands\nimport sys, getopt\nimport logging\nimport syslog\nimport time\n\nDEBUG = False\nargs = []\nFORCE = 0\nFAN_VPD_CHANNEL= 1\nFAN_VPD_ADDR_BASE=0x52\nFAN_NUM=5\nRETRY_LIMIT = 5\ni2c_prefix = '/sys/bus/i2c/devices/'\n\n\nif DEBUG == True:\n    print sys.argv[0]\n    print 'ARGV: ', sys.argv[1:]\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n\n\n    if len(sys.argv)<2:\n        show_help()\n\n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:\n        print options\n        print args\n        print len(sys.argv)\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n            install()\n        elif arg == 'clean':\n            uninstall()\n        else:\n            show_help()\n\n\n    return 0\n\ndef show_help():\n    print __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]}\n    sys.exit(0)\n\ndef show_log(txt):\n    if DEBUG == True:\n        print \"[D6332]\"+txt\n    return\n\ndef exec_cmd(cmd, show):\n    logging.info('Run :'+cmd)\n    status, output = commands.getstatusoutput(cmd)\n    show_log (cmd +\" with result:\" + str(status))\n    show_log (\"      output:\"+output)\n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print('Failed :'+cmd)\n    return  status, output\n\ndef link_dir(prefix,dst):\n    retry=0\n    ret=False\n    while(ret==False and retry<RETRY_LIMIT):\n        ret=os.path.isdir(prefix)\n        if ret==True:\n            break\n        time.sleep(0.5)\n        retry+=1\n\n    if ret==True:\n        dirs=os.listdir(prefix)\n        ret=False\n        for i in dirs:\n            if i.startswith('hwmon'):\n                src=prefix+i\n                os.symlink(src,dst)\n                ret=True\n                break\n        if ret==False:\n            syslog.syslog(syslog.LOG_ERR, \"Can't find proper dir to link under %s\" % prefix)\n    else:\n        syslog.syslog(syslog.LOG_ERR,\"Path %s is not a dir\" % prefix)\n\n_path_prefix_list=[\n    \"/sys/bus/i2c/devices/i2c-pmbus-1/hwmon/\",\n    \"/sys/bus/i2c/devices/i2c-pmbus-2/hwmon/\",\n    \"/sys/devices/platform/coretemp.0/hwmon/\",\n    \"/sys/bus/i2c/devices/i2c-tmp75-1/hwmon/\",\n    \"/sys/bus/i2c/devices/i2c-tmp75-2/hwmon/\",\n    \"/sys/bus/i2c/devices/i2c-tmp75-3/hwmon/\",\n    \"/sys/bus/i2c/devices/i2c-tmp75-4/hwmon/\"\n]\n\n_path_dst_list=[\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/psu1\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/psu2\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/coretemp\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_1\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_2\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_3\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_4\",\n]\n\ninstantiate = [\n'echo inv_eeprom 0x55 > /sys/bus/i2c/devices/i2c-0/new_device'\n#'echo inv_cpld 0x33 > /sys/bus/i2c/devices/i2c-0/i2c-2/new_device',\n#'echo inv_cpld 0x77 > /sys/bus/i2c/devices/i2c-0/i2c-2/new_device'\n]\n\n\ndrivers =[\n#kernel-dirvers\n'gpio_ich',\n'lpc_ich',\n'i2c-i801',\n'i2c-mux',\n'i2c-mux-pca954x',\n'i2c-mux-pca9541',\n'i2c-dev',\n'ucd9000',\n#inv-modules\n'inv_eeprom',\n'inv_cpld',\n'lm75',\n'inv_platform',\n#'monitor',\n'swps']\n\n\n# Modify for fast-reboot\ndef system_install(boot_option):\n    global FORCE\n\n    #remove default drivers to avoid modprobe order conflicts\n    status, output = exec_cmd(\"rmmod i2c_ismt \", 1)\n    if status:\n       print output\n       if FORCE == 0:\n          return status\n\n    status, output = exec_cmd(\"rmmod i2c-i801 \", 1)\n    if status:\n       print output\n       if FORCE == 0:\n          return status\n\n    status, output = exec_cmd(\"rmmod gpio_ich \", 1)\n    if status:\n       print output\n       if FORCE == 0:\n          return status\n\n    status, output = exec_cmd(\"rmmod lpc_ich \", 1)\n    if status:\n       print output\n       if FORCE == 0:\n          return status\n\n    #insert extra module\n    #status, output = exec_cmd(\"insmod /lib/modules/4.9.0-9-2-amd64/kernel/drivers/gpio/gpio-ich.ko gpiobase=0\",1)\n\n    #install drivers\n    ''' boot_option: 0 - normal, 1 - fast-reboot'''\n    for i in range(0,len(drivers)):\n       if drivers[i] == \"swps\":\n           if boot_option == 1:\n               status, output = exec_cmd(\"modprobe swps io_no_init=1\", 1)\n           else:\n               status, output = exec_cmd(\"modprobe \"+drivers[i], 1)\n       else:\n           status, output = exec_cmd(\"modprobe \"+drivers[i], 1)\n\n    if status:\n\t   print output\n\t   if FORCE == 0:\n\t      return status\n\n    #instantiate devices\n    for i in range(0,len(instantiate)):\n       #time.sleep(1)\n       status, output = exec_cmd(instantiate[i], 1)\n    if status:\n\t   print output\n\t   if FORCE == 0:                \n\t      return status\n    for addr_offset in range (0,FAN_NUM):\n        addr=FAN_VPD_ADDR_BASE+addr_offset\n        cmd = \"i2cdetect -y \"+str(FAN_VPD_CHANNEL)+\" \"+str(addr)+\" \"+str(addr)+\" | grep \"+str(hex(addr)).replace('0x','')\n        result=os.system(cmd)\n        if( result==0 ):\n            cmd=\"echo inv_eeprom \"+str(addr)+\" > /sys/bus/i2c/devices/i2c-\"+FAN_VPD_CHANNEL\n            status, output = exec_cmd(cmd,1)\n            if status:\n               print output\n               if FORCE == 0:                \n                  return status\n#\n# INV_FIX-4037\n# It replaces the original sff8436 driver with the optoe driver\n#\n    #optoe map to i2c-bus\\\n    for i in range(12,20):\n        cmd=\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-4/i2c-\"+str(i)+\"/new_device\"\n        status, output =exec_cmd(cmd,1)\n        if status:\n            print output\n            if FORCE == 0:\n                return status\n    for i in range(20,28):\n        status, output =exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-5/i2c-\"+str(i)+\"/new_device\", 1)\n        if status:\n            print output\n            if FORCE == 0:\n                return status\n    for i in range(28,36):\n        status, output =exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-6/i2c-\"+str(i)+\"/new_device\", 1)\n        if status:\n            print output\n            if FORCE == 0:\n                return status\n    for i in range(36,44):\n        status, output =exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-7/i2c-\"+str(i)+\"/new_device\", 1)\n        if status:\n            print output\n            if FORCE == 0:\n                return status\n                \n    #make softlink for device info\n    for i in range(0,len(_path_prefix_list)):\n        if( os.path.islink(_path_dst_list[i]) ):\n            os.unlink(_path_dst_list[i])\n            syslog.syslog(syslog.LOG_WARNING, \"Path %s exists, remove before link again\" % _path_dst_list[i] )\n        link_dir(_path_prefix_list[i],_path_dst_list[i])\n\n    return\n\n\ndef system_ready():\n    if not device_found():\n        return False\n    return True\n\ndef install(boot_option=0):\n    ''' boot_option: 0 - normal, 1 - fast-reboot '''\n    if not device_found():\n        print \"No device, installing....\"\n        status = system_install(boot_option)\n        if status:\n            if FORCE == 0:\n                return status\n    else:\n        print \"D6332 devices detected....\"\n    return\n\ndef uninstall():\n    global FORCE\n    #uninstall drivers\n    for i in range(len(drivers)-1,-1,-1):\n       status, output = exec_cmd(\"rmmod \"+drivers[i], 1)\n    if status:\n\t   print output\n\t   if FORCE == 0:\n\t      return status\n    return\n\ndef device_found():\n    ret1, log = exec_cmd(\"ls \"+i2c_prefix+\"*0072\", 0)\n    ret2, log = exec_cmd(\"ls \"+i2c_prefix+\"i2c-5\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"}, "/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py": {"changes": [{"diff": "\n         return retval\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/d", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py", "badparts": ["        return os.system(\"docker > /dev/null 2>&1\") == 0"], "goodparts": ["        return subprocess.call([\"docker\"]) == 0"]}]}, "/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py": {"changes": [{"diff": "\n \n try:\n     import os\n-    import sys\n+    import subprocess\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472InterfaceId\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py", "badparts": ["    import sys"], "goodparts": ["    import subprocess"]}, {"diff": "\n         return retval\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py", "badparts": ["        return os.system(\"docker > /dev/null 2>&1\") == 0"], "goodparts": ["        return subprocess.call([\"docker\"]) == 0"]}]}, "/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to QSFP sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-inventec_d7054q28b-r0\"\n     HWSKU  = \"INVENTEC-D7054Q28B-S48-Q6\"\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         return \"\"\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}]}}, "msg": "[inventec] Replace os.system and remove subprocess with shell=True (#12108)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\nDependency: [https://github.com/sonic-net/sonic-buildimage/pull/12065](https://github.com/sonic-net/sonic-buildimage/pull/12065)\r\n#### Why I did it\r\n1. `getstatusoutput` is used without a static string and it uses `shell=True`\r\n2. `subprocess()` - when using with `shell=True` is dangerous. Using subprocess function without a static string can lead to command injection.\r\n3. `os` - not secure against maliciously constructed input and dangerous if used to evaluate dynamic content.\r\n#### How I did it\r\n1. use `getstatusoutput` without shell=True\r\n2. `subprocess()` - use `shell=False` instead. use an array string. Ref: [https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation](https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation)\r\n3. `os` - use with `subprocess`"}, "35c4e9912de88dcc821ac5c8aebcc994ddcb9838": {"url": "https://api.github.com/repos/SovereignCloudStack/sonic-buildimage/commits/35c4e9912de88dcc821ac5c8aebcc994ddcb9838", "html_url": "https://github.com/SovereignCloudStack/sonic-buildimage/commit/35c4e9912de88dcc821ac5c8aebcc994ddcb9838", "sha": "35c4e9912de88dcc821ac5c8aebcc994ddcb9838", "keyword": "command injection malicious", "diff": "diff --git a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py\nindex 56e9d8664..12f1cc8ed 100644\n--- a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py\n@@ -37,14 +37,14 @@ def get_pcie_device(self):\n         pciList = []\n         p1 = \"^(\\w+):(\\w+)\\.(\\w)\\s(.*)\\s*\\(*.*\\)*\"\n         p2 = \"^.*:.*:.*:(\\w+)\\s*\\(*.*\\)*\"\n-        command1 = \"sudo lspci\"\n-        command2 = \"sudo lspci -n\"\n+        command1 = [\"sudo\", \"lspci\"]\n+        command2 = [\"sudo\", \"lspci\", \"-n\"]\n         # run command 1\n-        proc1 = subprocess.Popen(command1, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc1 = subprocess.Popen(command1, universal_newlines=True, stdout=subprocess.PIPE)\n         output1 = proc1.stdout.readlines()\n         proc1.communicate()\n         # run command 2\n-        proc2 = subprocess.Popen(command2, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc2 = subprocess.Popen(command2, universal_newlines=True, stdout=subprocess.PIPE)\n         output2 = proc2.stdout.readlines()\n         proc2.communicate()\n \ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py\nindex ea4048e19..18ca047cb 100644\n--- a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py\n@@ -10,13 +10,13 @@\n \n try:\n     import time\n-    import subprocess\n     from sonic_platform_base.chassis_base import ChassisBase\n     from sonic_platform.common import Common\n     from sonic_platform.sfp import Sfp\n     from sonic_platform.sfp import PORT_START\n     from sonic_platform.sfp import PORTS_IN_BLOCK\n     from sonic_platform.logger import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -36,17 +36,17 @@ def __init__(self):\n         self.SFP_STATUS_INSERTED = \"1\"\n         self.SFP_STATUS_REMOVED = \"0\"\n         self.port_dict = {}\n-        self.enable_read= \"i2cset -f -y 2 0x35 0x2a 0x01\"\n-        self.disable_read = \"i2cset -f -y 2 0x35 0x2a 0x00\"\n-        self.enable_write = \"i2cset -f -y 2 0x35 0x2b 0x00\"\n-        self.disable_write = \"i2cset -f -y 2 0x35 0x2b 0x01\"\n-        self.enable_erase = \"i2cset -f -y 2 0x35 0x2c 0x01\"\n-        self.disable_erase = \"i2cset -f -y 2 0x35 0x2c 0x00\"\n-        self.read_value = \"i2cget -f -y 2 0x35 0x25\"\n-        self.write_value = \"i2cset -f -y 2 0x35 0x21 0x0a\"\n-        self.set_sys_led_cmd = \"i2cset -f -y 2 0x33 0xb2 \"\n-        self.get_sys_led_cmd = \"i2cget -f -y 2 0x33 0xb2\"\n-        self.led_status = \"red\"\n+        self.enable_read= [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x01\"]\n+        self.disable_read = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x00\"]\n+        self.enable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x00\"]\n+        self.disable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x01\"]\n+        self.enable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x01\"]\n+        self.disable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x00\"]\n+        self.read_value = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x25\"]\n+        self.write_value = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x21\", \"0x0a\"]\n+        self.set_sys_led_cmd = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]\n+        self.get_sys_led_cmd = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]\n+        self.led_status = \"red\" \n         # Initialize SFP list\n         # sfp.py will read eeprom contents and retrive the eeprom data.\n         # It will also provide support sfp controls like reset and setting\n@@ -210,25 +210,25 @@ def get_reboot_cause(self):\n         try:\n             is_power_loss = False\n             # enable read\n-            subprocess.getstatusoutput(self.disable_write)\n-            subprocess.getstatusoutput(self.enable_read)\n-            ret , log = subprocess.getstatusoutput(self.read_value)\n+            getstatusoutput_noshell(self.disable_write)\n+            getstatusoutput_noshell(self.enable_read)\n+            ret , log = getstatusoutput_noshell(self.read_value)\n             if ret == 0 and \"0x0a\" in log:\n                 is_power_loss = True\n \n             # erase i2c and e2\n-            subprocess.getstatusoutput(self.enable_erase)\n+            getstatusoutput_noshell(self.enable_erase)\n             time.sleep(1)\n-            subprocess.getstatusoutput(self.disable_erase)\n+            getstatusoutput_noshell(self.disable_erase)\n             # clear data\n-            subprocess.getstatusoutput(self.enable_write)\n-            subprocess.getstatusoutput(self.disable_read)\n-            subprocess.getstatusoutput(self.disable_write)\n-            subprocess.getstatusoutput(self.enable_read)\n+            getstatusoutput_noshell(self.enable_write)\n+            getstatusoutput_noshell(self.disable_read)\n+            getstatusoutput_noshell(self.disable_write)\n+            getstatusoutput_noshell(self.enable_read)\n             # enable write and set data\n-            subprocess.getstatusoutput(self.enable_write)\n-            subprocess.getstatusoutput(self.disable_read)\n-            subprocess.getstatusoutput(self.write_value)\n+            getstatusoutput_noshell(self.enable_write)\n+            getstatusoutput_noshell(self.disable_read)\n+            getstatusoutput_noshell(self.write_value)\n             if is_power_loss:\n                 return(self.REBOOT_CAUSE_POWER_LOSS, None)\n         except Exception as e:\n@@ -417,7 +417,8 @@ def set_status_led(self, color):\n         if regval is None:\n             print(\"Invaild color input.\")\n             return False\n-        ret , log = subprocess.getstatusoutput(self.set_sys_led_cmd + regval)\n+        cmd = self.set_sys_led_cmd + [regval]\n+        ret, log = getstatusoutput_noshell(cmd)\n         if ret != 0:\n             print(\"Cannot execute %s\" % self.set_sys_led_cmd + regval)\n             return False\n@@ -431,7 +432,7 @@ def get_status_led(self):\n             A string, one of the valid LED color strings which could be vendor\n             specified.\n         \"\"\"\n-        ret , log = subprocess.getstatusoutput(self.get_sys_led_cmd)\n+        ret , log = getstatusoutput_noshell(self.get_sys_led_cmd)\n         if ret != 0:\n             print(\"Cannot execute %s\" % self.get_sys_led_cmd)\n             return False\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py\nindex c1a85f618..e1bef19c2 100644\n--- a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py\n@@ -1,6 +1,6 @@\n import os\n import yaml\n-\n+import subprocess\n from sonic_py_common import device_info\n \n \n@@ -10,13 +10,13 @@ class Common:\n     PMON_PLATFORM_PATH = '/usr/share/sonic/platform/'\n     CONFIG_DIR = 'sonic_platform_config'\n \n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def load_json_file(self, path):\n         \"\"\"\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py\nindex 33ff6ef8b..26e83fb19 100644\n--- a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py\n@@ -8,10 +8,10 @@\n ########################################################################\n \n try:\n-    import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n     from sonic_platform.regutil import Reg\n     from sonic_platform.logger import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -70,12 +70,12 @@ def install_firmware(self, image_path):\n         \"\"\"\n         try:\n             successtips = \"CPLD Upgrade succeeded!\"\n-            status, output = subprocess.getstatusoutput(\"which firmware_upgrade\")\n+            status, output = getstatusoutput_noshell([\"which\", \"firmware_upgrade\"])\n             if status or len(output) <= 0:\n                 logger.error(\"no upgrade tool.\")\n                 return False\n-            cmdstr = \"%s %s cpld %d cpld\"%(output,image_path,self.slot)\n-            ret, log = subprocess.getstatusoutput(cmdstr)\n+            cmdstr = [output, image_path, \"cpld\", self.slot, \"cpld\"]\n+            ret, log = getstatusoutput_noshell(cmdstr)\n             if ret == 0 and successtips in log:\n                 return True\n             logger.error(\"upgrade failed. ret:%d, log:\\n%s\" % (ret, log))\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py b/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py\nindex 46f3089bb..88453c9e9 100644\n--- a/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py\n@@ -6,7 +6,6 @@\n #\n #######################################################\n \n-import subprocess\n import time\n import glob\n import re\n@@ -14,6 +13,7 @@\n from rjutil.smbus import SMBus\n import time\n from  functools import wraps\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n def retry(maxretry =6, delay = 0.01):\n@@ -80,13 +80,13 @@ def rji2csetword_python(bus, addr, reg, value):\n \n     @staticmethod\n     def command(cmdstr):\n-        retcode, output = subprocess.getstatusoutput(cmdstr)\n+        retcode, output = getstatusoutput_noshell(cmdstr)\n         return retcode, output\n \n \n     @staticmethod\n     def geti2cword_i2ctool(bus, addr, offset):\n-        command_line = \"i2cget -f -y %d 0x%02x 0x%02x  wp\" % (bus, addr, offset)\n+        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%02x\"%offset, \"wp\"]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n@@ -99,7 +99,7 @@ def geti2cword_i2ctool(bus, addr, offset):\n \n     @staticmethod\n     def seti2cword_i2ctool(bus, addr, offset, val):\n-        command_line = \"i2cset -f -y %d 0x%02x 0x%0x 0x%04x wp\" % (bus, addr, offset, val)\n+        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%0x\"%offset, \"0x%04x\"%val, \"wp\"]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n@@ -111,7 +111,7 @@ def seti2cword_i2ctool(bus, addr, offset, val):\n \n     @staticmethod\n     def rji2cget_i2ctool(bus, devno, address):\n-        command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)\n+        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n@@ -123,8 +123,7 @@ def rji2cget_i2ctool(bus, devno, address):\n \n     @staticmethod\n     def rji2cset_i2ctool(bus, devno, address, byte):\n-        command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (\n-            bus, devno, address, byte)\n+        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address, \"0x%02x\"%byte]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n@@ -166,7 +165,7 @@ def readsysfs(location):\n \n     @staticmethod\n     def getdevmem(addr, digit, mask):\n-        command_line = \"devmem 0x%02x %d\" %(addr, digit)\n+        command_line = [\"devmem\", \"0x%02x\"%addr, str(digit)]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n@@ -179,13 +178,13 @@ def getdevmem(addr, digit, mask):\n \n     @staticmethod\n     def rj_os_system(cmd):\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         return status, output\n \n     @staticmethod\n     def getsdkreg(reg):\n         try:\n-            cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg\n+            cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]\n             ret, result = osutil.rj_os_system(cmd)\n             result_t = result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n             if ret != 0 or \"Error:\" in result_t:\n@@ -203,8 +202,8 @@ def getmactemp():\n             result = {}\n             #waitForDocker()\n             #need to exec twice\n-            osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n-            ret, log = osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n+            osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n+            ret, log = osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n             if ret:\n                 return False, result\n             else:\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py b/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py\nindex 35bca09c0..c812ba295 100755\n--- a/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py\n@@ -6,7 +6,7 @@\n import subprocess\n import time\n from  ruijieconfig import GLOBALCONFIG, GLOBALINITPARAM, GLOBALINITCOMMAND, MAC_LED_RESET, STARTMODULE, i2ccheck_params\n-\n+from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe\n from  ruijieutil   import rjpciwr\n \n CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])\n@@ -46,7 +46,7 @@ def write_sysfs_value(reg_name, value):\n \n def check_driver():\n     u'''whether there is driver start with rg'''\n-    status, output = log_os_system(\"lsmod | grep rg | wc -l\")\n+    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", \"rg\"], [\"wc\", \"-l\"])\n     #System execution error\n     if status: \n         return False\n@@ -70,61 +70,59 @@ def i2c_getPid(name):\n     return ret\n \n def startAvscontrol():\n-    cmd = \"nohup avscontrol.py start >/dev/null 2>&1 &\"\n+    cmd = [\"avscontrol.py\", \"start\"]\n     rets = i2c_getPid(\"avscontrol.py\")\n     if len(rets) == 0:\n-        os.system(cmd)\n+        subprocess.Popen(cmd)\n \n def startFanctrol():\n     if STARTMODULE['fancontrol'] == 1:\n-        cmd = \"nohup fancontrol.py start >/dev/null 2>&1 &\"\n+        cmd = [\"fancontrol.py\", \"start\"]\n         rets = i2c_getPid(\"fancontrol.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def starthal_fanctrl():\n     if STARTMODULE.get('hal_fanctrl',0) == 1:\n-        cmd = \"nohup hal_fanctrl.py start >/dev/null 2>&1 &\"\n+        cmd = [\"hal_fanctrl.py\", \"start\"]\n         rets = i2c_getPid(\"hal_fanctrl.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def starthal_ledctrl():\n     if STARTMODULE.get('hal_ledctrl',0) == 1:\n-        cmd = \"nohup hal_ledctrl.py start >/dev/null 2>&1 &\"\n+        cmd = [\"hal_ledctrl.py\", \"start\"]\n         rets = i2c_getPid(\"hal_ledctrl.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n-\n+            subprocess.Popen(cmd)\n def startDevmonitor():\n     if STARTMODULE.get('dev_monitor',0) == 1:\n-        cmd = \"nohup dev_monitor.py start >/dev/null 2>&1 &\"\n+        cmd = [\"dev_monitor.py\", \"start\"]\n         rets = i2c_getPid(\"dev_monitor.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n-\n+            subprocess.Popen(cmd)\n def startSlotmonitor():\n     if STARTMODULE.get('slot_monitor',0) == 1:\n-        cmd = \"nohup slot_monitor.py start >/dev/null 2>&1 &\"\n+        cmd = [\"slot_monitor.py\", \"start\"]\n         rets = i2c_getPid(\"slot_monitor.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def stopFanctrol():\n     u'''disable fan timer service'''\n     if STARTMODULE['fancontrol'] == 1:\n         rets = i2c_getPid(\"fancontrol.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def stophal_ledctrl():\n     if STARTMODULE.get('hal_ledctrl',0) == 1:\n         rets = i2c_getPid(\"hal_ledctrl.py\")\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n \n@@ -133,8 +131,8 @@ def stopDevmonitor():\n     if STARTMODULE.get('dev_monitor',0) == 1:\n         rets = i2c_getPid(\"dev_monitor.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def stopSlotmonitor():\n@@ -142,15 +140,16 @@ def stopSlotmonitor():\n     if STARTMODULE.get('slot_monitor',0) == 1:\n         rets = i2c_getPid(\"slot_monitor.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def removeDev(bus, loc):\n-    cmd = \"echo  0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device\" % (loc, bus)\n     devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n     if os.path.exists(devpath):\n-        log_os_system(cmd)\n+        file = \"/sys/bus/i2c/devices/i2c-%d/delete_device\" % bus\n+        with open(file, 'w') as f:\n+            f.write('0x%02x\\n'%str(bus))\n         \n def addDev(name, bus, loc):\n     if name == \"lm75\":\n@@ -163,10 +162,11 @@ def addDev(name, bus, loc):\n         if i % 10 == 0:\n             click.echo(\"%%DEVICE_I2C-INIT: %s not found, wait 0.1 second ! i %d \" % (pdevpath,i))\n             \n-    cmd = \"echo  %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device\" % (name, loc, bus)\n     devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n     if os.path.exists(devpath) == False:\n-        os.system(cmd)\n+        file = \"/sys/bus/i2c/devices/i2c-%d/new_device\" % bus\n+        with open(file, 'w') as f:\n+            f.write('%s 0x%02x\\n' % (name, loc))\n \n def removedevs():\n     devs = GLOBALCONFIG[\"DEVS\"]\n@@ -179,8 +179,7 @@ def adddevs():\n         addDev(devs[dev][\"name\"], devs[dev][\"bus\"] , devs[dev][\"loc\"])\n \n def checksignaldriver(name):\n-    modisexistcmd = \"lsmod | grep %s | wc -l\" % name\n-    status, output = log_os_system(modisexistcmd)\n+    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", name], [\"wc\", \"-l\"])\n     #System execution error\n     if status: \n         return False\n@@ -190,17 +189,17 @@ def checksignaldriver(name):\n         return False\n \n def adddriver(name, delay):\n-    cmd = \"modprobe %s\" % name\n+    cmd = [\"modprobe\", name]\n     if delay != 0:\n         time.sleep(delay)\n     if checksignaldriver(name) != True:\n-        log_os_system(cmd)\n+        getstatusoutput_noshell(cmd)\n \n def removedriver(name, delay):\n     realname = name.lstrip().split(\" \")[0];\n-    cmd = \"rmmod -f %s\" % realname\n+    cmd = [\"rmmod\", \"-f\", realname]\n     if checksignaldriver(realname):\n-        log_os_system(cmd)\n+        getstatusoutput_noshell(cmd)\n \n def removedrivers():\n     u'''remove all drivers'''\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py b/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py\nindex 87fb01e5f..e12bb25d7 100755\n--- a/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py\n@@ -4,6 +4,7 @@\n import os\n import time\n import syslog\n+import subprocess\n from ruijieconfig import MONITOR_CONST, FANCTROLDEBUG, MONITOR_FANS_LED, DEV_LEDS, MONITOR_PSU_STATUS, \\\n         MONITOR_SYS_PSU_LED, MONITOR_DEV_STATUS, MONITOR_FAN_STATUS, MONITOR_DEV_STATUS_DECODE, \\\n         MONITOR_SYS_FAN_LED, MONITOR_SYS_LED, fanloc\n@@ -766,7 +767,7 @@ def checkCrit(self):\n                     self.fanSpeedSetMax()  # fan full speed\n                     self.critnum += 1 # anti-shake\n                     if self.critnum >= MONITOR_CONST.CRITICAL_NUM:\n-                       os.system(\"reboot\")\n+                        subprocess.call([\"reboot\"])\n                     fanwarningdebuglog(DEBUG_FANCONTROL,\"crit\u6b21\u6570:%d\" % self.critnum)\n                 else:\n                     self.critnum = 0\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py b/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py\nindex ff594b72e..9d1930ec0 100755\n--- a/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py\n@@ -11,7 +11,6 @@\n import sys\n import os\n import re\n-import subprocess\n import syslog\n import time\n import binascii\n@@ -20,6 +19,7 @@\n import threading\n import click\n import mmap\n+from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe\n from ruijieconfig import rg_eeprom, FRULISTS, MAC_DEFAULT_PARAM, MAC_AVS_PARAM, FANS_DEF, \\\n         FAN_PROTECT, E2_LOC, E2_PROTECT, RUIJIE_SERVICE_TAG, RUIJIE_DIAG_VERSION, \\\n         STARTMODULE, RUIJIE_CARDID, RUIJIE_PRODUCTNAME, RUIJIE_PART_NUMBER, \\\n@@ -538,8 +538,8 @@ def __new__(cls, *args, **kwargs):\n \n def getSdkReg(reg):\n     try:\n-        cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg\n-        ret, result = rj_os_system(cmd)\n+        cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]\n+        ret, result = getstatusoutput_noshell(cmd)\n         result_t = result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n         if ret != 0 or \"Error:\" in result_t:\n             return False, result\n@@ -632,8 +632,8 @@ def getMacTemp():\n     result = {}\n     #waitForDocker()\n     # exec twice, get the second result\n-    rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n-    ret, log = rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n+    getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n+    ret, log = getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n     if ret:\n         return False, result\n     else:\n@@ -689,21 +689,21 @@ def getMacTemp_sysfs(mactempconf):\n \n def restartDockerService(force=False):\n     container_name = [\"database\",\"snmp\",\"syncd\",\"swss\",\"dhcp_relay\",\"radv\",\"teamd\",\"pmon\"]\n-    ret, status = rj_os_system(\"docker ps\")\n+    ret, status = getstatusoutput_noshell([\"docker\", \"ps\"])\n     if ret == 0 :\n         for tmpname in container_name:\n             if (tmpname not in status):\n                 if (force == True):\n-                    rj_os_system(\"docker restart %s\"%tmpname)\n+                    getstatusoutput_noshell([\"docker\", \"restart\", tmpname])\n                 else:\n-                    rj_os_system(\"systemctl restart %s\"%tmpname)\n+                    getstatusoutput_noshell([\"systemctl\", \"restart\", tmpname])\n \n \n def waitForDhcp(timeout):\n     time_cnt = 0\n     while True:\n         try:\n-            ret, status = rj_os_system(\"systemctl status dhcp_relay.service\")\n+            ret, status = getstatusoutput_noshell([\"systemctl\", \"status\", \"dhcp_relay.service\"])\n             if (ret == 0 and \"running\" in status)  or \"SUCCESS\" in status:\n                 break\n             else:\n@@ -839,8 +839,10 @@ def util_setmac(eth, mac):\n     rulefile = \"/etc/udev/rules.d/70-persistent-net.rules\"\n     if isValidMac(mac) == False:\n         return False, \"MAC invaild\"\n-    cmd = \"ethtool -e %s | grep 0x0010 | awk '{print \\\"0x\\\"$13$12$15$14}'\" % eth\n-    ret, log = rj_os_system(cmd)\n+    cmd1 = [\"ethtool\", \"-e\", eth] \n+    cmd2 = [\"grep\", \"0x0010\"]\n+    cmd3 = [\"awk\", '{print \\\"0x\\\"$13$12$15$14}']\n+    ret, log = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)\n     log_debug(log)\n     magic = \"\"\n     if ret == 0 and len(log):\n@@ -848,23 +850,22 @@ def util_setmac(eth, mac):\n     macs = mac.upper().split(\":\")\n \n     # chage ETH0 to value after setmac\n-    ifconfigcmd = \"ifconfig eth0 hw ether %s\" % mac\n-    log_debug(ifconfigcmd)\n-    ret, status = rj_os_system(ifconfigcmd)\n+    ifconfigcmd = [\"ifconfig\", \"eth0\", \"hw\", \"ether\", mac]\n+    log_debug(' '.join(ifconfigcmd))\n+    ret, status = getstatusoutput_noshell(ifconfigcmd)\n     if ret:\n         raise SETMACException(\"software set  Internet cardMAC error\")\n     index = 0\n     for item in macs:\n-        cmd = \"ethtool -E %s magic %s offset %d value 0x%s\" % (\n-            eth, magic, index, item)\n+        cmd = [\"ethtool\", \"-E\", eht, \"magic\", magic, \"offset\", str(index), \"value\", \"0x\"+item]\n         log_debug(cmd)\n         index += 1\n-        ret, log = rj_os_system(cmd)\n+        ret, log = getstatusoutput_noshell(cmd)\n         if ret != 0:\n             raise SETMACException(\" set hardware Internet card MAC error\")\n     # get value after setting \n-    cmd_t = \"ethtool -e eth0 offset 0 length 6\"\n-    ret, log = rj_os_system(cmd_t)\n+    cmd_t = [\"ethtool\", \"-e\", \"eth0\", \"offset\", \"0\", \"length\", \"6\"]\n+    ret, log = getstatusoutput_noshell(cmd_t)\n     m = re.split(':', log)[-1].strip().upper()\n     mac_result = m.upper().split(\" \")\n \n@@ -979,11 +980,11 @@ def generate_ext(cardid):\n \n \n def rji2cget(bus, devno, address):\n-    command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)\n+    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address)]\n     retrytime = 6\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n         time.sleep(0.1)\n@@ -991,12 +992,11 @@ def rji2cget(bus, devno, address):\n \n \n def rji2cset(bus, devno, address, byte):\n-    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (\n-        bus, devno, address, byte)\n+    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%02x\"%str(byte)]\n     retrytime = 6\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n     return False, ret_t\n@@ -1033,31 +1033,30 @@ def rjpciwr(pcibus , slot ,fn, bar, offset, data):\n     data.close()\n \n def rjsysset(location, value):\n-    command_line = \"echo 0x%02x > %s\" % (value, location)\n     retrytime = 6\n-    ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n-        if ret == 0:\n-            return True, ret_t\n-    return False, ret_t\n+        try:\n+            with open(location, 'w') as f:\n+                f.write('0x%02x\\n'%value)\n+        except (IOError, FileNotFoundError) as e:\n+            return False, str(e)\n+    return True, ''\n \n \n def rji2cgetWord(bus, devno, address):\n-    command_line = \"i2cget -f -y %d 0x%02x 0x%02x w\" % (bus, devno, address)\n+    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"w\"]\n     retrytime = 3\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n     return False, ret_t\n \n \n def rji2csetWord(bus, devno, address, byte):\n-    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%x w\" % (\n-        bus, devno, address, byte)\n-    rj_os_system(command_line)\n+    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%x\"%str(byte), \"w\"]\n+    getstatusoutput_noshell(command_line)\n \n \n def fan_setmac():\n@@ -1264,14 +1263,15 @@ def writeToEEprom(rst_arr):\n     elif dealtype == \"io\":\n         io_wr(E2_PROTECT[\"io_addr\"], E2_PROTECT[\"close\"])\n     # deal last drivers\n-    os.system(\"rmmod at24 \")\n-    os.system(\"modprobe at24 \")\n-    os.system(\"rm -f /var/cache/sonic/decode-syseeprom/syseeprom_cache\")\n+    getstatusoutput_noshell([\"rmmod\", \"at24\"])\n+    getstatusoutput_noshell([\"modprobe\", \"at24\"])\n+    getstatusoutput_noshell([\"rm\", \"-f\", \"/var/cache/sonic/decode-syseeprom/syseeprom_cache\"])\n \n \n def get_local_eth0_mac():\n-    cmd = \"ifconfig eth0 |grep HWaddr\"\n-    print(rj_os_system(cmd))\n+    cmd1 = [\"ifconfig\", \"eth0\"]\n+    cmd2 = [\"grep\", \"HWaddr\"]\n+    print(getstatusoutput_noshell_pipe(cmd1, cmd2))\n \n def getonieversion():\n     if not os.path.isfile('/host/machine.conf'):\n@@ -1348,12 +1348,12 @@ def fac_board_setmac():\n \n def ipmi_set_mac(mac):\n     macs = mac.split(\":\")\n-    cmdinit = \"ipmitool raw 0x0c 0x01 0x01 0xc2 0x00\"\n-    cmdset = \"ipmitool raw 0x0c 0x01 0x01 0x05\"\n+    cmdinit = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0xc2\", \"0x00\"]\n+    cmdset = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0x05\"]\n     for ind in range(len(macs)):\n-        cmdset += \" 0x%02x\" % int(macs[ind], 16)\n-    rj_os_system(cmdinit)\n-    ret, status = rj_os_system(cmdset)\n+        cmdset.append(\"0x%02x\" % int(macs[ind], 16))\n+    getstatusoutput_noshell(cmdinit)\n+    ret, status = getstatusoutput_noshell(cmdset)\n     if ret:\n         RJPRINTERR(\"\\n\\n%s\\n\\n\" % status)\n         return False\n@@ -1393,11 +1393,11 @@ def closeProtocol():\n     log_info(\"disable LLDP\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n-    rj_os_system(\"systemctl stop lldp.service\")\n+    getstatusoutput_noshell([\"systemctl\", \"stop\", \"lldp.service\"])\n     log_info(\"disable lldp service\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n-    rj_os_system(\"systemctl stop bgp.service\")\n+    getstatusoutput_noshell([\"systemctl\", \"stop\", \"bgp.service\"])\n     log_info(\"disable bgp service\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n@@ -1420,8 +1420,8 @@ def checkSdkMem():\n     with open(file_name, \"w\") as f:\n         f.write(file_data)\n     print(\"change SDK memory to 256, reboot required\")\n-    rj_os_system(\"sync\")\n-    rj_os_system(\"reboot\")\n+    getstatusoutput_noshell([\"sync\"])\n+    getstatusoutput_noshell([\"reboot\"])\n \n ##########################################################################\n # receives a character setting\n@@ -1604,25 +1604,22 @@ def getCardId():\n             return item.get('value',None)\n     return None\n \n-# ====================================\n-# execute shell command\n-# ====================================\n-def rj_os_system(cmd):\n-    status, output = subprocess.getstatusoutput(cmd)\n-    return status, output\n \n ###########################################\n # get memory slot and number via DMI command\n ###########################################\n def getsysmeminfo():\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \"|grep -P -A5 \\\"Memory\\s+Device\\\"|grep Size|grep -v Range\"\n+    cmd1 = [log[0].rstrip('\\n')]\n+    cmd2 = [\"grep\", \"-P\", \"-A5\", \"Memory\\s+Device\"]\n+    cmd3 = [\"grep\", \"Size\"]\n+    cmd4 = [\"grep\", \"-v\", \"Range\"]\n     # get total number first\n     result = []\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3, cmd4)\n     if ret1 == 0 and len(log1):\n         log1 = log1.lstrip()\n         arr = log1.split(\"\\n\")\n@@ -1642,15 +1639,16 @@ def getsysmeminfo():\n # return various arrays\n ###########################################\n def getsysmeminfo_detail():\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \" -t 17 | grep  -A21 \\\"Memory Device\\\"\"  # 17\n+    cmd1 = [log[0].rstrip('\\n')] + [\"-t\", \"17\"]\n+    cmd2 = [\"grep\", \"-A21\", \"Memory Device\"]  # 17\n     # get total number\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)\n     if ret1 != 0 or len(log1) <= 0:\n-        return False, \"command execution error[%s]\" % cmd\n+        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)\n     result_t = log1.split(\"--\")\n     mem_rets = []\n     for item in result_t:\n@@ -1669,13 +1667,13 @@ def getsysmeminfo_detail():\n # get BIOS info via DMI command\n ###########################################\n def getDmiSysByType(type_t):\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \" -t %s\" % type_t\n+    cmd = [log[0].rstrip('\\n')] + [\"-t\", str(type_t)]\n     # get total number\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell(cmd)\n     if ret1 != 0 or len(log1) <= 0:\n         return False, \"command execution error[%s]\" % cmd\n     its = log1.replace(\"\\t\", \"\").strip().split(\"\\n\")\n@@ -1742,11 +1740,12 @@ def getusbinfo():\n         return False, \"Err\"\n \n def get_cpu_info():\n-    cmd = \"cat /proc/cpuinfo |grep processor -A18\"  # 17\n+    cmd1 = [\"cat\", \"/proc/cpuinfo\"]\n+    cmd2 = [\"grep\", \"processor\", \"-A18\"]  # 17\n \n-    ret, log1 = rj_os_system(cmd)\n+    ret, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)\n     if ret != 0 or len(log1) <= 0:\n-        return False, \"command execution error[%s]\" % cmd\n+        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)\n     result_t = log1.split(\"--\")\n     mem_rets = []\n     for item in result_t:\n", "message": "", "files": {"/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py": {"changes": [{"diff": "\n         pciList = []\n         p1 = \"^(\\w+):(\\w+)\\.(\\w)\\s(.*)\\s*\\(*.*\\)*\"\n         p2 = \"^.*:.*:.*:(\\w+)\\s*\\(*.*\\)*\"\n-        command1 = \"sudo lspci\"\n-        command2 = \"sudo lspci -n\"\n+        command1 = [\"sudo\", \"lspci\"]\n+        command2 = [\"sudo\", \"lspci\", \"-n\"]\n         # run command 1\n-        proc1 = subprocess.Popen(command1, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc1 = subprocess.Popen(command1, universal_newlines=True, stdout=subprocess.PIPE)\n         output1 = proc1.stdout.readlines()\n         proc1.communicate()\n         # run command 2\n-        proc2 = subprocess.Popen(command2, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc2 = subprocess.Popen(command2, universal_newlines=True, stdout=subprocess.PIPE)\n         output2 = proc2.stdout.readlines()\n         proc2.communicate()\n ", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py", "badparts": ["        command1 = \"sudo lspci\"", "        command2 = \"sudo lspci -n\"", "        proc1 = subprocess.Popen(command1, shell=True, universal_newlines=True, stdout=subprocess.PIPE)", "        proc2 = subprocess.Popen(command2, shell=True, universal_newlines=True, stdout=subprocess.PIPE)"], "goodparts": ["        command1 = [\"sudo\", \"lspci\"]", "        command2 = [\"sudo\", \"lspci\", \"-n\"]", "        proc1 = subprocess.Popen(command1, universal_newlines=True, stdout=subprocess.PIPE)", "        proc2 = subprocess.Popen(command2, universal_newlines=True, stdout=subprocess.PIPE)"]}], "source": "\n import os import yaml import subprocess import re import sys from copy import deepcopy try: from.pcie import PcieBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class PcieUtil(PcieBase): \"\"\"Platform-specific PCIEutil class\"\"\" def __init__(self, path): self.config_path=path def load_config_file(self): config_file=self.config_path +\"/\" +\"pcie.yaml\" try: with open(config_file) as conf_file: self.confInfo=yaml.load(conf_file) except IOError as e: print(\"Error:{}\".format(str(e))) print(\"Not found config file, please add a config file manually, or generate it by running[pcieutil pcie_generate]\") sys.exit() def get_pcie_device(self): pciDict={} pciList=[] p1=\"^(\\w+):(\\w+)\\.(\\w)\\s(.*)\\s*\\(*.*\\)*\" p2=\"^.*:.*:.*:(\\w+)\\s*\\(*.*\\)*\" command1=\"sudo lspci\" command2=\"sudo lspci -n\" proc1=subprocess.Popen(command1, shell=True, universal_newlines=True, stdout=subprocess.PIPE) output1=proc1.stdout.readlines() proc1.communicate() proc2=subprocess.Popen(command2, shell=True, universal_newlines=True, stdout=subprocess.PIPE) output2=proc2.stdout.readlines() proc2.communicate() if proc1.returncode > 0: for line1 in output1: print(line1.strip()) return elif proc2.returncode > 0: for line2 in output2: print(line2.strip()) return else: for(line1, line2) in zip(output1, output2): pciDict.clear() match1=re.search(p1, line1.strip()) match2=re.search(p2, line2.strip()) if match1 and match2: Bus=match1.group(1) Dev=match1.group(2) Fn=match1.group(3) Name=match1.group(4) Id=match2.group(1) pciDict[\"name\"]=Name pciDict[\"bus\"]=Bus pciDict[\"dev\"]=Dev pciDict[\"fn\"]=Fn pciDict[\"id\"]=Id pciList.append(pciDict) pciDict=deepcopy(pciDict) else: print(\"CAN NOT MATCH PCIe DEVICE\") return pciList def check_pcie_sysfs(self, domain=0, bus=0, device=0, func=0): dev_path=os.path.join('/sys/bus/pci/devices', '%04x:%02x:%02x.%d' %(domain, bus, device, func)) if os.path.exists(dev_path): return True return False def get_pcie_check(self): self.load_config_file() for item_conf in self.confInfo: bus_conf=item_conf[\"bus\"] dev_conf=item_conf[\"dev\"] fn_conf=item_conf[\"fn\"] if self.check_pcie_sysfs(bus=int(bus_conf, base=16), device=int(dev_conf, base=16), func=int(fn_conf, base=16)): item_conf[\"result\"]=\"Passed\" else: item_conf[\"result\"]=\"Failed\" return self.confInfo def dump_conf_yaml(self): curInfo=self.get_pcie_device() with open(self.config_path +\"/\" +\"pcie.yaml\", \"w\") as conf_file: yaml.dump(curInfo, conf_file, default_flow_style=False) return ", "sourceWithComments": "# pcie_common.py\n# Common PCIE check interfaces for SONIC\n#\n\nimport os\nimport yaml\nimport subprocess\nimport re\nimport sys\nfrom copy import deepcopy\ntry:\n    from .pcie import PcieBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass PcieUtil(PcieBase):\n    \"\"\"Platform-specific PCIEutil class\"\"\"\n    # got the config file path\n    def __init__(self, path):\n        self.config_path = path\n\n    # load the config file\n    def load_config_file(self):\n        config_file = self.config_path + \"/\" + \"pcie.yaml\"\n        try:\n            with open(config_file) as conf_file:\n                self.confInfo = yaml.load(conf_file)\n        except IOError as e:\n            print(\"Error: {}\".format(str(e)))\n            print(\"Not found config file, please add a config file manually, or generate it by running [pcieutil pcie_generate]\")\n            sys.exit()\n\n    # load current PCIe device\n    def get_pcie_device(self):\n        pciDict = {}\n        pciList = []\n        p1 = \"^(\\w+):(\\w+)\\.(\\w)\\s(.*)\\s*\\(*.*\\)*\"\n        p2 = \"^.*:.*:.*:(\\w+)\\s*\\(*.*\\)*\"\n        command1 = \"sudo lspci\"\n        command2 = \"sudo lspci -n\"\n        # run command 1\n        proc1 = subprocess.Popen(command1, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n        output1 = proc1.stdout.readlines()\n        proc1.communicate()\n        # run command 2\n        proc2 = subprocess.Popen(command2, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n        output2 = proc2.stdout.readlines()\n        proc2.communicate()\n\n        if proc1.returncode > 0:\n            for line1 in output1:\n                print(line1.strip())\n            return\n        elif proc2.returncode > 0:\n            for line2 in output2:\n                print(line2.strip())\n            return\n        else:\n            for (line1, line2) in zip(output1, output2):\n                pciDict.clear()\n                match1 = re.search(p1, line1.strip())\n                match2 = re.search(p2, line2.strip())\n                if match1 and match2:\n                    Bus = match1.group(1)\n                    Dev = match1.group(2)\n                    Fn = match1.group(3)\n                    Name = match1.group(4)\n                    Id = match2.group(1)\n                    pciDict[\"name\"] = Name\n                    pciDict[\"bus\"] = Bus\n                    pciDict[\"dev\"] = Dev\n                    pciDict[\"fn\"] = Fn\n                    pciDict[\"id\"] = Id\n                    pciList.append(pciDict)\n                    pciDict = deepcopy(pciDict)\n                else:\n                    print(\"CAN NOT MATCH PCIe DEVICE\")\n        return pciList\n\n    # check the sysfs tree for each PCIe device\n    def check_pcie_sysfs(self, domain=0, bus=0, device=0, func=0):\n        dev_path = os.path.join('/sys/bus/pci/devices', '%04x:%02x:%02x.%d' % (domain, bus, device, func))\n        if os.path.exists(dev_path):\n            return True\n        return False\n\n    # check the current PCIe device with config file and return the result\n    def get_pcie_check(self):\n        self.load_config_file()\n        for item_conf in self.confInfo:\n            bus_conf = item_conf[\"bus\"]\n            dev_conf = item_conf[\"dev\"]\n            fn_conf = item_conf[\"fn\"]\n            if self.check_pcie_sysfs(bus=int(bus_conf, base=16), device=int(dev_conf, base=16), func=int(fn_conf, base=16)):\n                item_conf[\"result\"] = \"Passed\"\n            else:\n                item_conf[\"result\"] = \"Failed\"\n        return self.confInfo\n\n    # generate the config file with current pci device\n    def dump_conf_yaml(self):\n        curInfo = self.get_pcie_device()\n        with open(self.config_path + \"/\" + \"pcie.yaml\", \"w\") as conf_file:\n            yaml.dump(curInfo, conf_file, default_flow_style=False)\n        return\n\n"}, "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py": {"changes": [{"diff": "\n \n try:\n     import time\n-    import subprocess\n     from sonic_platform_base.chassis_base import ChassisBase\n     from sonic_platform.common import Common\n     from sonic_platform.sfp import Sfp\n     from sonic_platform.sfp import PORT_START\n     from sonic_platform.sfp import PORTS_IN_BLOCK\n     from sonic_platform.logger import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py", "badparts": ["    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         self.SFP_STATUS_INSERTED = \"1\"\n         self.SFP_STATUS_REMOVED = \"0\"\n         self.port_dict = {}\n-        self.enable_read= \"i2cset -f -y 2 0x35 0x2a 0x01\"\n-        self.disable_read = \"i2cset -f -y 2 0x35 0x2a 0x00\"\n-        self.enable_write = \"i2cset -f -y 2 0x35 0x2b 0x00\"\n-        self.disable_write = \"i2cset -f -y 2 0x35 0x2b 0x01\"\n-        self.enable_erase = \"i2cset -f -y 2 0x35 0x2c 0x01\"\n-        self.disable_erase = \"i2cset -f -y 2 0x35 0x2c 0x00\"\n-        self.read_value = \"i2cget -f -y 2 0x35 0x25\"\n-        self.write_value = \"i2cset -f -y 2 0x35 0x21 0x0a\"\n-        self.set_sys_led_cmd = \"i2cset -f -y 2 0x33 0xb2 \"\n-        self.get_sys_led_cmd = \"i2cget -f -y 2 0x33 0xb2\"\n-        self.led_status = \"red\"\n+        self.enable_read= [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x01\"]\n+        self.disable_read = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x00\"]\n+        self.enable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x00\"]\n+        self.disable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x01\"]\n+        self.enable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x01\"]\n+        self.disable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x00\"]\n+        self.read_value = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x25\"]\n+        self.write_value = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x21\", \"0x0a\"]\n+        self.set_sys_led_cmd = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]\n+        self.get_sys_led_cmd = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]\n+        self.led_status = \"red\" \n         # Initialize SFP list\n         # sfp.py will read eeprom contents and retrive the eeprom data.\n         # It will also provide support sfp controls like reset and setting\n", "add": 11, "remove": 11, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py", "badparts": ["        self.enable_read= \"i2cset -f -y 2 0x35 0x2a 0x01\"", "        self.disable_read = \"i2cset -f -y 2 0x35 0x2a 0x00\"", "        self.enable_write = \"i2cset -f -y 2 0x35 0x2b 0x00\"", "        self.disable_write = \"i2cset -f -y 2 0x35 0x2b 0x01\"", "        self.enable_erase = \"i2cset -f -y 2 0x35 0x2c 0x01\"", "        self.disable_erase = \"i2cset -f -y 2 0x35 0x2c 0x00\"", "        self.read_value = \"i2cget -f -y 2 0x35 0x25\"", "        self.write_value = \"i2cset -f -y 2 0x35 0x21 0x0a\"", "        self.set_sys_led_cmd = \"i2cset -f -y 2 0x33 0xb2 \"", "        self.get_sys_led_cmd = \"i2cget -f -y 2 0x33 0xb2\"", "        self.led_status = \"red\""], "goodparts": ["        self.enable_read= [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x01\"]", "        self.disable_read = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x00\"]", "        self.enable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x00\"]", "        self.disable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x01\"]", "        self.enable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x01\"]", "        self.disable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x00\"]", "        self.read_value = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x25\"]", "        self.write_value = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x21\", \"0x0a\"]", "        self.set_sys_led_cmd = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]", "        self.get_sys_led_cmd = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]", "        self.led_status = \"red\" "]}, {"diff": "\n         try:\n             is_power_loss = False\n             # enable read\n-            subprocess.getstatusoutput(self.disable_write)\n-            subprocess.getstatusoutput(self.enable_read)\n-            ret , log = subprocess.getstatusoutput(self.read_value)\n+            getstatusoutput_noshell(self.disable_write)\n+            getstatusoutput_noshell(self.enable_read)\n+            ret , log = getstatusoutput_noshell(self.read_value)\n             if ret == 0 and \"0x0a\" in log:\n                 is_power_loss = True\n \n             # erase i2c and e2\n-            subprocess.getstatusoutput(self.enable_erase)\n+            getstatusoutput_noshell(self.enable_erase)\n             time.sleep(1)\n-            subprocess.getstatusoutput(self.disable_erase)\n+            getstatusoutput_noshell(self.disable_erase)\n             # clear data\n-            subprocess.getstatusoutput(self.enable_write)\n-            subprocess.getstatusoutput(self.disable_read)\n-            subprocess.getstatusoutput(self.disable_write)\n-            subprocess.getstatusoutput(self.enable_read)\n+            getstatusoutput_noshell(self.enable_write)\n+            getstatusoutput_noshell(self.disable_read)\n+            getstatusoutput_noshell(self.disable_write)\n+            getstatusoutput_noshell(self.enable_read)\n             # enable write and set data\n-            subprocess.getstatusoutput(self.enable_write)\n-            subprocess.getstatusoutput(self.disable_read)\n-            subprocess.getstatusoutput(self.write_value)\n+            getstatusoutput_noshell(self.enable_write)\n+            getstatusoutput_noshell(self.disable_read)\n+            getstatusoutput_noshell(self.write_value)\n             if is_power_loss:\n                 return(self.REBOOT_CAUSE_POWER_LOSS, None)\n         except Exception as e:\n", "add": 12, "remove": 12, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py", "badparts": ["            subprocess.getstatusoutput(self.disable_write)", "            subprocess.getstatusoutput(self.enable_read)", "            ret , log = subprocess.getstatusoutput(self.read_value)", "            subprocess.getstatusoutput(self.enable_erase)", "            subprocess.getstatusoutput(self.disable_erase)", "            subprocess.getstatusoutput(self.enable_write)", "            subprocess.getstatusoutput(self.disable_read)", "            subprocess.getstatusoutput(self.disable_write)", "            subprocess.getstatusoutput(self.enable_read)", "            subprocess.getstatusoutput(self.enable_write)", "            subprocess.getstatusoutput(self.disable_read)", "            subprocess.getstatusoutput(self.write_value)"], "goodparts": ["            getstatusoutput_noshell(self.disable_write)", "            getstatusoutput_noshell(self.enable_read)", "            ret , log = getstatusoutput_noshell(self.read_value)", "            getstatusoutput_noshell(self.enable_erase)", "            getstatusoutput_noshell(self.disable_erase)", "            getstatusoutput_noshell(self.enable_write)", "            getstatusoutput_noshell(self.disable_read)", "            getstatusoutput_noshell(self.disable_write)", "            getstatusoutput_noshell(self.enable_read)", "            getstatusoutput_noshell(self.enable_write)", "            getstatusoutput_noshell(self.disable_read)", "            getstatusoutput_noshell(self.write_value)"]}, {"diff": "\n         if regval is None:\n             print(\"Invaild color input.\")\n             return False\n-        ret , log = subprocess.getstatusoutput(self.set_sys_led_cmd + regval)\n+        cmd = self.set_sys_led_cmd + [regval]\n+        ret, log = getstatusoutput_noshell(cmd)\n         if ret != 0:\n             print(\"Cannot execute %s\" % self.set_sys_led_cmd + regval)\n             return False\n", "add": 2, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py", "badparts": ["        ret , log = subprocess.getstatusoutput(self.set_sys_led_cmd + regval)"], "goodparts": ["        cmd = self.set_sys_led_cmd + [regval]", "        ret, log = getstatusoutput_noshell(cmd)"]}, {"diff": "\n             A string, one of the valid LED color strings which could be vendor\n             specified.\n         \"\"\"\n-        ret , log = subprocess.getstatusoutput(self.get_sys_led_cmd)\n+        ret , log = getstatusoutput_noshell(self.get_sys_led_cmd)\n         if ret != 0:\n             print(\"Cannot execute %s\" % self.get_sys_led_cmd)\n             return Fals", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py", "badparts": ["        ret , log = subprocess.getstatusoutput(self.get_sys_led_cmd)"], "goodparts": ["        ret , log = getstatusoutput_noshell(self.get_sys_led_cmd)"]}], "source": "\n try: import time import subprocess from sonic_platform_base.chassis_base import ChassisBase from sonic_platform.common import Common from sonic_platform.sfp import Sfp from sonic_platform.sfp import PORT_START from sonic_platform.sfp import PORTS_IN_BLOCK from sonic_platform.logger import logger except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class Chassis(ChassisBase): \"\"\" Ruijie B6510-48VS8CQ Platform-specific Chassis class \"\"\" def __init__(self): ChassisBase.__init__(self) self.CHASSIS_CONFIG='chassis.json' self.THERMAL_CONFIG='thermal.json' self.SFP_CONFIG='sfp.json' self.PSU_CONFIG='psu.json' self.FAN_CONFIG='fan.json' self.COMPONENT_CONFIG='component.json' self.SFP_STATUS_INSERTED=\"1\" self.SFP_STATUS_REMOVED=\"0\" self.port_dict={} self.enable_read=\"i2cset -f -y 2 0x35 0x2a 0x01\" self.disable_read=\"i2cset -f -y 2 0x35 0x2a 0x00\" self.enable_write=\"i2cset -f -y 2 0x35 0x2b 0x00\" self.disable_write=\"i2cset -f -y 2 0x35 0x2b 0x01\" self.enable_erase=\"i2cset -f -y 2 0x35 0x2c 0x01\" self.disable_erase=\"i2cset -f -y 2 0x35 0x2c 0x00\" self.read_value=\"i2cget -f -y 2 0x35 0x25\" self.write_value=\"i2cset -f -y 2 0x35 0x21 0x0a\" self.set_sys_led_cmd=\"i2cset -f -y 2 0x33 0xb2 \" self.get_sys_led_cmd=\"i2cget -f -y 2 0x33 0xb2\" self.led_status=\"red\" for index in range(PORT_START, PORTS_IN_BLOCK): sfp_node=Sfp(index) self._sfp_list.append(sfp_node) if sfp_node.get_presence(): self.port_dict[index]=self.SFP_STATUS_INSERTED else: self.port_dict[index]=self.SFP_STATUS_REMOVED self._api_common=Common() config_path=self._api_common.get_config_path(self.CHASSIS_CONFIG) self._config=self._api_common.load_json_file(config_path) self.__initialize_eeprom() if self._api_common.is_host(): self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() else: self.__initialize_components() def __initialize_fan(self): from sonic_platform.fan import Fan from sonic_platform.fan_drawer import FanDrawer fan_config_path=self._api_common.get_config_path(self.FAN_CONFIG) self.fan_config=self._api_common.load_json_file(fan_config_path)[\"fans\"] if self.fan_config: drawer_fan_list=[] for index in range(0, len(self.fan_config)): fan=Fan(index, config=self.fan_config[index]) self._fan_list.append(fan) drawer_fan_list.append(fan) fan_drawer=FanDrawer(0, fan_list=drawer_fan_list) self._fan_drawer_list.append(fan_drawer) def __initialize_psu(self): from sonic_platform.psu import Psu psu_config_path=self._api_common.get_config_path(self.PSU_CONFIG) self.psu_config=self._api_common.load_json_file(psu_config_path)[\"psus\"] if self.psu_config: for index in range(0, len(self.psu_config)): psu=Psu(index, config=self.psu_config[index]) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal thermal_config_path=self._api_common.get_config_path(self.THERMAL_CONFIG) self.thermal_config=self._api_common.load_json_file(thermal_config_path)['thermals'] if self.thermal_config: for index in range(0, len(self.thermal_config)): thermal=Thermal(index, config=self.thermal_config[index]) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Eeprom self._eeprom=Eeprom(config=self._config[\"eeprom\"]) def __initialize_components(self): from sonic_platform.component import Component component_config_path=self._api_common.get_config_path(self.COMPONENT_CONFIG) self.component_config=self._api_common.load_json_file(component_config_path)['components'] if self.component_config: for index in range(0, len(self.component_config)): component=Component(index, config=self.component_config[index]) self._component_list.append(component) def _init_standard_config(self, conflist, class_name, objlist): for conf in conflist: obj=globals()[class_name](conf.get(\"name\"), config=conf) objlist.append(obj) def _init_by_hal(self, hal_interface): self.hal_interface=hal_interface self.hal_interface.get_fans() def get_name(self): \"\"\" Retrieves the name of the chassis Returns: string: The name of the chassis \"\"\" return self._eeprom.modelstr() def get_presence(self): \"\"\" Retrieves the presence of the chassis Returns: bool: True if chassis is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the chassis Returns: string: Model/part number of chassis \"\"\" return self._eeprom.part_number_str() def get_serial(self): \"\"\" Retrieves the serial number of the chassis(Service tag) Returns: string: Serial number of chassis \"\"\" return self._eeprom.serial_str() def get_status(self): \"\"\" Retrieves the operational status of the chassis Returns: bool: A boolean value, True if chassis is operating properly False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.base_mac_addr() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.system_eeprom_info() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" try: is_power_loss=False subprocess.getstatusoutput(self.disable_write) subprocess.getstatusoutput(self.enable_read) ret, log=subprocess.getstatusoutput(self.read_value) if ret==0 and \"0x0a\" in log: is_power_loss=True subprocess.getstatusoutput(self.enable_erase) time.sleep(1) subprocess.getstatusoutput(self.disable_erase) subprocess.getstatusoutput(self.enable_write) subprocess.getstatusoutput(self.disable_read) subprocess.getstatusoutput(self.disable_write) subprocess.getstatusoutput(self.enable_read) subprocess.getstatusoutput(self.enable_write) subprocess.getstatusoutput(self.disable_read) subprocess.getstatusoutput(self.write_value) if is_power_loss: return(self.REBOOT_CAUSE_POWER_LOSS, None) except Exception as e: logger.error(str(e)) return(self.REBOOT_CAUSE_NON_HARDWARE, None) def get_change_event(self, timeout=0): \"\"\" Returns a nested dictionary containing all devices which have experienced a change at chassis level Args: timeout: Timeout in milliseconds(optional). If timeout==0, this method will block until a change is detected. Returns: (bool, dict): -True if call successful, False if not; -A nested dictionary where key is a device type, value is a dictionary with key:value pairs in the format of {'device_id':'device_event'}, where device_id is the device ID for this device and device_event, status='1' represents device inserted, status='0' represents device removed. Ex.{'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}} indicates that fan 0 has been removed, fan 2 has been inserted and sfp 11 has been removed. Specifically for SFP event, besides SFP plug in and plug out, there are some other error event could be raised from SFP, when these error happened, SFP eeprom will not be avalaible, XCVRD shall stop to read eeprom before SFP recovered from error status. status='2' I2C bus stuck, status='3' Bad eeprom, status='4' Unsupported cable, status='5' High Temperature, status='6' Bad cable. \"\"\" change_event_dict={\"fan\":{}, \"sfp\":{}} sfp_status, sfp_change_dict=self.get_transceiver_change_event(timeout) change_event_dict[\"sfp\"]=sfp_change_dict if sfp_status is True: return True, change_event_dict return False,{} def get_transceiver_change_event(self, timeout=0): start_time=time.time() currernt_port_dict={} forever=False if timeout==0: forever=True elif timeout > 0: timeout=timeout / float(1000) else: print(\"get_transceiver_change_event:Invalid timeout value\", timeout) return False,{} end_time=start_time +timeout if start_time > end_time: print( \"get_transceiver_change_event:\" \"time wrap / invalid timeout value\", timeout, ) return False,{} while timeout >=0: for index in range(PORT_START, PORTS_IN_BLOCK): if self._sfp_list[index].get_presence(): currernt_port_dict[index]=self.SFP_STATUS_INSERTED else: currernt_port_dict[index]=self.SFP_STATUS_REMOVED if currernt_port_dict==self.port_dict: if forever: time.sleep(1) else: timeout=end_time -time.time() if timeout >=1: time.sleep(1) else: if timeout > 0: time.sleep(timeout) return True,{} else: self.port_dict=currernt_port_dict print(self.port_dict) return True, self.port_dict print(\"get_transceiver_change_event: Should not reach here.\") return False,{} def get_all_components(self): return self._component_list def get_all_fans(self): return self._fan_list def get_all_psus(self): return self._psu_list def get_all_thermals(self): return self._thermal_list def get_supervisor_slot(self): \"\"\" Retrieves the physical-slot of the supervisor-module in the modular chassis. On the supervisor or line-card modules, it will return the physical-slot of the supervisor-module. On the fixed-platforms, the API can be ignored. Users of the API can catch the exception and return a default ModuleBase.MODULE_INVALID_SLOT and bypass code for fixed-platforms. Returns: An integer, the vendor specific physical slot identifier of the supervisor module in the modular-chassis. \"\"\" return 0 def get_my_slot(self): \"\"\" Retrieves the physical-slot of this module in the modular chassis. On the supervisor, it will return the physical-slot of the supervisor module. On the linecard, it will return the physical-slot of the linecard module where this instance of SONiC is running. On the fixed-platforms, the API can be ignored. Users of the API can catch the exception and return a default ModuleBase.MODULE_INVALID_SLOT and bypass code for fixed-platforms. Returns: An integer, the vendor specific physical slot identifier of this module in the modular-chassis. \"\"\" return 0 def is_modular_chassis(self): \"\"\" Retrieves whether the sonic instance is part of modular chassis Returns: A bool value, should return False by default or for fixed-platforms. Should return True for supervisor-cards, line-cards etc running as part of modular-chassis. \"\"\" return True def init_midplane_switch(self): \"\"\" Initializes the midplane functionality of the modular chassis. For example, any validation of midplane, populating any lookup tables etc can be done here. The expectation is that the required kernel modules, ip-address assignment etc are done before the pmon, database dockers are up. Returns: A bool value, should return True if the midplane initialized successfully. \"\"\" return True def get_module_index(self, module_name): \"\"\" Retrieves module index from the module name Args: module_name: A string, prefixed by SUPERVISOR, LINE-CARD or FABRIC-CARD Ex. SUPERVISOR0, LINE-CARD1, FABRIC-CARD5 Returns: An integer, the index of the ModuleBase object in the module_list \"\"\" return 0 def set_status_led(self, color): \"\"\" Sets the state of the system LED Args: color: A string representing the color with which to set the system LED Returns: bool: True if system LED state is set successfully, False if not \"\"\" colors={ \"amber\": \"0x00\", \"red\": \"0x02\", \"green\": \"0x04\" } regval=colors.get(color, None) if regval is None: print(\"Invaild color input.\") return False ret, log=subprocess.getstatusoutput(self.set_sys_led_cmd +regval) if ret !=0: print(\"Cannot execute %s\" % self.set_sys_led_cmd +regval) return False self.led_status=color return True def get_status_led(self): \"\"\" Gets the state of the system LED Returns: A string, one of the valid LED color strings which could be vendor specified. \"\"\" ret, log=subprocess.getstatusoutput(self.get_sys_led_cmd) if ret !=0: print(\"Cannot execute %s\" % self.get_sys_led_cmd) return False colors={ \"0x00\": \"amber\", \"0x02\": \"red\", \"0x04\": \"green\" } color=colors.get(log, None) if color is None: return \"Unknown color status\" self.led_status=color return self.led_status ", "sourceWithComments": "# -*- coding: utf-8 -*-\n\n#############################################################################\n# Ruijie B6510-48VS8CQ\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the platform information\n#\n#############################################################################\n\ntry:\n    import time\n    import subprocess\n    from sonic_platform_base.chassis_base import ChassisBase\n    from sonic_platform.common import Common\n    from sonic_platform.sfp import Sfp\n    from sonic_platform.sfp import PORT_START\n    from sonic_platform.sfp import PORTS_IN_BLOCK\n    from sonic_platform.logger import logger\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nclass Chassis(ChassisBase):\n    \"\"\"\n    Ruijie B6510-48VS8CQ Platform-specific Chassis class\n    \"\"\"\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self.CHASSIS_CONFIG = 'chassis.json'\n        self.THERMAL_CONFIG = 'thermal.json'\n        self.SFP_CONFIG = 'sfp.json'\n        self.PSU_CONFIG = 'psu.json'\n        self.FAN_CONFIG = 'fan.json'\n        self.COMPONENT_CONFIG = 'component.json'\n\n        self.SFP_STATUS_INSERTED = \"1\"\n        self.SFP_STATUS_REMOVED = \"0\"\n        self.port_dict = {}\n        self.enable_read= \"i2cset -f -y 2 0x35 0x2a 0x01\"\n        self.disable_read = \"i2cset -f -y 2 0x35 0x2a 0x00\"\n        self.enable_write = \"i2cset -f -y 2 0x35 0x2b 0x00\"\n        self.disable_write = \"i2cset -f -y 2 0x35 0x2b 0x01\"\n        self.enable_erase = \"i2cset -f -y 2 0x35 0x2c 0x01\"\n        self.disable_erase = \"i2cset -f -y 2 0x35 0x2c 0x00\"\n        self.read_value = \"i2cget -f -y 2 0x35 0x25\"\n        self.write_value = \"i2cset -f -y 2 0x35 0x21 0x0a\"\n        self.set_sys_led_cmd = \"i2cset -f -y 2 0x33 0xb2 \"\n        self.get_sys_led_cmd = \"i2cget -f -y 2 0x33 0xb2\"\n        self.led_status = \"red\"\n        # Initialize SFP list\n        # sfp.py will read eeprom contents and retrive the eeprom data.\n        # It will also provide support sfp controls like reset and setting\n        # low power mode.\n        # We pass the eeprom path and sfp control path from chassis.py\n        # So that sfp.py implementation can be generic to all platforms\n        for index in range(PORT_START, PORTS_IN_BLOCK):\n            sfp_node = Sfp(index)\n            self._sfp_list.append(sfp_node)\n            if sfp_node.get_presence():\n                self.port_dict[index] = self.SFP_STATUS_INSERTED\n            else:\n                self.port_dict[index] = self.SFP_STATUS_REMOVED\n\n        self._api_common = Common()\n        config_path = self._api_common.get_config_path(self.CHASSIS_CONFIG)\n        self._config = self._api_common.load_json_file(config_path)\n        self.__initialize_eeprom()\n\n        if self._api_common.is_host():\n            self.__initialize_fan()\n            self.__initialize_psu()\n            self.__initialize_thermals()\n        else:\n            self.__initialize_components()\n\n    def __initialize_fan(self):\n        from sonic_platform.fan import Fan\n        from sonic_platform.fan_drawer import FanDrawer\n\n        fan_config_path = self._api_common.get_config_path(self.FAN_CONFIG)\n        self.fan_config = self._api_common.load_json_file(fan_config_path)[\"fans\"]\n\n        if self.fan_config:\n            drawer_fan_list = []\n            for index in range(0, len(self.fan_config)):\n                fan = Fan(index, config=self.fan_config[index])\n                self._fan_list.append(fan)\n                drawer_fan_list.append(fan)\n            fan_drawer = FanDrawer(0, fan_list=drawer_fan_list)\n            self._fan_drawer_list.append(fan_drawer)\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n\n        psu_config_path = self._api_common.get_config_path(self.PSU_CONFIG)\n        self.psu_config = self._api_common.load_json_file(psu_config_path)[\"psus\"]\n\n        if self.psu_config:\n            for index in range(0, len(self.psu_config)):\n                psu = Psu(index, config=self.psu_config[index])\n                self._psu_list.append(psu)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n\n        thermal_config_path = self._api_common.get_config_path(self.THERMAL_CONFIG)\n        self.thermal_config = self._api_common.load_json_file(thermal_config_path)['thermals']\n\n        if self.thermal_config:\n            for index in range(0, len(self.thermal_config)):\n                thermal = Thermal(index, config=self.thermal_config[index])\n                self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Eeprom\n        self._eeprom = Eeprom(config=self._config[\"eeprom\"])\n\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n\n        component_config_path = self._api_common.get_config_path(self.COMPONENT_CONFIG)\n        self.component_config = self._api_common.load_json_file(component_config_path)['components']\n\n        if self.component_config:\n            for index in range(0, len(self.component_config)):\n                component = Component(index, config=self.component_config[index])\n                self._component_list.append(component)\n\n    def _init_standard_config(self, conflist, class_name, objlist):\n        for conf in conflist:\n            obj = globals()[class_name](conf.get(\"name\"), config=conf)\n            objlist.append(obj)\n\n    def _init_by_hal(self, hal_interface):\n        self.hal_interface = hal_interface\n        self.hal_interface.get_fans()\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the chassis\n        Returns:\n            string: The name of the chassis\n        \"\"\"\n        return self._eeprom.modelstr()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the chassis\n        Returns:\n            bool: True if chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the chassis\n        Returns:\n            string: Model/part number of chassis\n        \"\"\"\n        return self._eeprom.part_number_str()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the chassis (Service tag)\n        Returns:\n            string: Serial number of chassis\n        \"\"\"\n        return self._eeprom.serial_str()\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the chassis\n        Returns:\n            bool: A boolean value, True if chassis is operating properly\n            False if not\n        \"\"\"\n        return True\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.base_mac_addr()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.system_eeprom_info()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        try:\n            is_power_loss = False\n            # enable read\n            subprocess.getstatusoutput(self.disable_write)\n            subprocess.getstatusoutput(self.enable_read)\n            ret , log = subprocess.getstatusoutput(self.read_value)\n            if ret == 0 and \"0x0a\" in log:\n                is_power_loss = True\n\n            # erase i2c and e2\n            subprocess.getstatusoutput(self.enable_erase)\n            time.sleep(1)\n            subprocess.getstatusoutput(self.disable_erase)\n            # clear data\n            subprocess.getstatusoutput(self.enable_write)\n            subprocess.getstatusoutput(self.disable_read)\n            subprocess.getstatusoutput(self.disable_write)\n            subprocess.getstatusoutput(self.enable_read)\n            # enable write and set data\n            subprocess.getstatusoutput(self.enable_write)\n            subprocess.getstatusoutput(self.disable_read)\n            subprocess.getstatusoutput(self.write_value)\n            if is_power_loss:\n                return(self.REBOOT_CAUSE_POWER_LOSS, None)\n        except Exception as e:\n            logger.error(str(e))\n\n        return (self.REBOOT_CAUSE_NON_HARDWARE, None)\n\n    def get_change_event(self, timeout=0):\n        \"\"\"\n        Returns a nested dictionary containing all devices which have\n        experienced a change at chassis level\n\n        Args:\n            timeout: Timeout in milliseconds (optional). If timeout == 0,\n                this method will block until a change is detected.\n\n        Returns:\n            (bool, dict):\n                - True if call successful, False if not;\n                - A nested dictionary where key is a device type,\n                  value is a dictionary with key:value pairs in the format of\n                  {'device_id':'device_event'},\n                  where device_id is the device ID for this device and\n                        device_event,\n                             status='1' represents device inserted,\n                             status='0' represents device removed.\n                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}\n                      indicates that fan 0 has been removed, fan 2\n                      has been inserted and sfp 11 has been removed.\n                  Specifically for SFP event, besides SFP plug in and plug out,\n                  there are some other error event could be raised from SFP, when\n                  these error happened, SFP eeprom will not be avalaible, XCVRD shall\n                  stop to read eeprom before SFP recovered from error status.\n                      status='2' I2C bus stuck,\n                      status='3' Bad eeprom,\n                      status='4' Unsupported cable,\n                      status='5' High Temperature,\n                      status='6' Bad cable.\n        \"\"\"\n        change_event_dict = {\"fan\": {}, \"sfp\": {}}\n        sfp_status, sfp_change_dict = self.get_transceiver_change_event(timeout)\n        change_event_dict[\"sfp\"] = sfp_change_dict\n        if sfp_status is True:\n            return True, change_event_dict\n\n        return False, {}\n\n    def get_transceiver_change_event(self, timeout=0):\n\n        start_time = time.time()\n        currernt_port_dict = {}\n        forever = False\n\n        if timeout == 0:\n            forever = True\n        elif timeout > 0:\n            timeout = timeout / float(1000)  # Convert to secs\n        else:\n            print(\"get_transceiver_change_event:Invalid timeout value\", timeout)\n            return False, {}\n\n        end_time = start_time + timeout\n        if start_time > end_time:\n            print(\n                \"get_transceiver_change_event:\" \"time wrap / invalid timeout value\",\n                timeout,\n            )\n            return False, {}  # Time wrap or possibly incorrect timeout\n\n        while timeout >= 0:\n            # Check for OIR events and return updated port_dict\n            for index in range(PORT_START, PORTS_IN_BLOCK):\n                if self._sfp_list[index].get_presence():\n                    currernt_port_dict[index] = self.SFP_STATUS_INSERTED\n                else:\n                    currernt_port_dict[index] = self.SFP_STATUS_REMOVED\n            if currernt_port_dict == self.port_dict:\n                if forever:\n                    time.sleep(1)\n                else:\n                    timeout = end_time - time.time()\n                    if timeout >= 1:\n                        time.sleep(1)  # We poll at 1 second granularity\n                    else:\n                        if timeout > 0:\n                            time.sleep(timeout)\n                        return True, {}\n            else:\n                # Update reg value\n                self.port_dict = currernt_port_dict\n                print(self.port_dict)\n                return True, self.port_dict\n        print(\"get_transceiver_change_event: Should not reach here.\")\n        return False, {}\n\n    def get_all_components(self):\n        return self._component_list\n\n    def get_all_fans(self):\n        return self._fan_list\n\n    def get_all_psus(self):\n        return self._psu_list\n\n    def get_all_thermals(self):\n        return self._thermal_list\n\n    def get_supervisor_slot(self):\n        \"\"\"\n        Retrieves the physical-slot of the supervisor-module in the modular\n        chassis. On the supervisor or line-card modules, it will return the\n        physical-slot of the supervisor-module.\n        On the fixed-platforms, the API can be ignored.\n        Users of the API can catch the exception and return a default\n        ModuleBase.MODULE_INVALID_SLOT and bypass code for fixed-platforms.\n        Returns:\n            An integer, the vendor specific physical slot identifier of the\n            supervisor module in the modular-chassis.\n        \"\"\"\n        return 0\n\n    def get_my_slot(self):\n        \"\"\"\n        Retrieves the physical-slot of this module in the modular chassis.\n        On the supervisor, it will return the physical-slot of the supervisor\n        module. On the linecard, it will return the physical-slot of the\n        linecard module where this instance of SONiC is running.\n        On the fixed-platforms, the API can be ignored.\n        Users of the API can catch the exception and return a default\n        ModuleBase.MODULE_INVALID_SLOT and bypass code for fixed-platforms.\n        Returns:\n            An integer, the vendor specific physical slot identifier of this\n            module in the modular-chassis.\n        \"\"\"\n        return 0\n\n    def is_modular_chassis(self):\n        \"\"\"\n        Retrieves whether the sonic instance is part of modular chassis\n        Returns:\n            A bool value, should return False by default or for fixed-platforms.\n            Should return True for supervisor-cards, line-cards etc running as part\n            of modular-chassis.\n        \"\"\"\n        return True\n\n    def init_midplane_switch(self):\n        \"\"\"\n        Initializes the midplane functionality of the modular chassis. For\n        example, any validation of midplane, populating any lookup tables etc\n        can be done here. The expectation is that the required kernel modules,\n        ip-address assignment etc are done before the pmon, database dockers\n        are up.\n        Returns:\n            A bool value, should return True if the midplane initialized\n            successfully.\n        \"\"\"\n        return True\n\n    def get_module_index(self, module_name):\n        \"\"\"\n        Retrieves module index from the module name\n        Args:\n            module_name: A string, prefixed by SUPERVISOR, LINE-CARD or FABRIC-CARD\n            Ex. SUPERVISOR0, LINE-CARD1, FABRIC-CARD5\n        Returns:\n            An integer, the index of the ModuleBase object in the module_list\n        \"\"\"\n        return 0\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the system LED\n        Args:\n            color: A string representing the color with which to set the\n                   system LED\n        Returns:\n            bool: True if system LED state is set successfully, False if not\n        \"\"\"\n        colors = {\n            \"amber\" : \"0x00\",\n            \"red\" : \"0x02\",\n            \"green\" : \"0x04\"\n        }\n        regval = colors.get(color, None)\n        if regval is None:\n            print(\"Invaild color input.\")\n            return False\n        ret , log = subprocess.getstatusoutput(self.set_sys_led_cmd + regval)\n        if ret != 0:\n            print(\"Cannot execute %s\" % self.set_sys_led_cmd + regval)\n            return False\n        self.led_status = color\n        return True\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the system LED\n        Returns:\n            A string, one of the valid LED color strings which could be vendor\n            specified.\n        \"\"\"\n        ret , log = subprocess.getstatusoutput(self.get_sys_led_cmd)\n        if ret != 0:\n            print(\"Cannot execute %s\" % self.get_sys_led_cmd)\n            return False\n        colors = {\n            \"0x00\" : \"amber\",\n            \"0x02\" : \"red\",\n            \"0x04\" : \"green\"\n        }\n        color = colors.get(log, None)\n        if color is None:\n            return \"Unknown color status\"\n        self.led_status = color\n        return self.led_status\n\n"}, "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py": {"changes": [{"diff": "\n     PMON_PLATFORM_PATH = '/usr/share/sonic/platform/'\n     CONFIG_DIR = 'sonic_platform_config'\n \n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def load_json_file(self, path):\n         \"", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"", "        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]", "        return subprocess.call(self.HOST_CHK_CMD) == 0"]}], "source": "\nimport os import yaml from sonic_py_common import device_info class Common: DEVICE_PATH='/usr/share/sonic/device/' PMON_PLATFORM_PATH='/usr/share/sonic/platform/' CONFIG_DIR='sonic_platform_config' HOST_CHK_CMD=\"docker > /dev/null 2>&1\" def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(self.HOST_CHK_CMD)==0 def load_json_file(self, path): \"\"\" Retrieves the json object from json file path Returns: A json object \"\"\" with open(path, 'r') as f: json_data=yaml.safe_load(f) return json_data def get_config_path(self, config_name): \"\"\" Retrieves the path to platform api config directory Args: config_name: A string containing the name of config file. Returns: A string containing the path to json file \"\"\" return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name) ", "sourceWithComments": "import os\nimport yaml\n\nfrom sonic_py_common import device_info\n\n\nclass Common:\n\n    DEVICE_PATH = '/usr/share/sonic/device/'\n    PMON_PLATFORM_PATH = '/usr/share/sonic/platform/'\n    CONFIG_DIR = 'sonic_platform_config'\n\n    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def load_json_file(self, path):\n        \"\"\"\n        Retrieves the json object from json file path\n\n        Returns:\n            A json object\n        \"\"\"\n        with open(path, 'r') as f:\n            json_data = yaml.safe_load(f)\n\n        return json_data\n\n    def get_config_path(self, config_name):\n        \"\"\"\n        Retrieves the path to platform api config directory\n\n        Args:\n            config_name: A string containing the name of config file.\n\n        Returns:\n            A string containing the path to json file\n        \"\"\"\n        return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\n\n"}, "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py": {"changes": [{"diff": "\n ########################################################################\n \n try:\n-    import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n     from sonic_platform.regutil import Reg\n     from sonic_platform.logger import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py", "badparts": ["    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         \"\"\"\n         try:\n             successtips = \"CPLD Upgrade succeeded!\"\n-            status, output = subprocess.getstatusoutput(\"which firmware_upgrade\")\n+            status, output = getstatusoutput_noshell([\"which\", \"firmware_upgrade\"])\n             if status or len(output) <= 0:\n                 logger.error(\"no upgrade tool.\")\n                 return False\n-            cmdstr = \"%s %s cpld %d cpld\"%(output,image_path,self.slot)\n-            ret, log = subprocess.getstatusoutput(cmdstr)\n+            cmdstr = [output, image_path, \"cpld\", self.slot, \"cpld\"]\n+            ret, log = getstatusoutput_noshell(cmdstr)\n             if ret == 0 and successtips in log:\n                 return True\n             logger.error(\"upgrade failed. ret:%d, log:\\n%s\" % (ret, lo", "add": 3, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py", "badparts": ["            status, output = subprocess.getstatusoutput(\"which firmware_upgrade\")", "            cmdstr = \"%s %s cpld %d cpld\"%(output,image_path,self.slot)", "            ret, log = subprocess.getstatusoutput(cmdstr)"], "goodparts": ["            status, output = getstatusoutput_noshell([\"which\", \"firmware_upgrade\"])", "            cmdstr = [output, image_path, \"cpld\", self.slot, \"cpld\"]", "            ret, log = getstatusoutput_noshell(cmdstr)"]}], "source": "\n try: import subprocess from sonic_platform_base.component_base import ComponentBase from sonic_platform.regutil import Reg from sonic_platform.logger import logger except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class Component(ComponentBase): \"\"\"Ruijie Platform-specific Component class\"\"\" def __init__(self, index, config=None): self.index=index self.name=config.get(\"name\") self._reg_fm_ver=Reg(config.get(\"firmware_version\")) self.description=config.get(\"desc\") self.slot=config.get(\"slot\") def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return self.name def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return self.description def get_firmware_version(self): \"\"\" Retrieves the firmware version of the component Returns: A string containing the firmware version of the component \"\"\" try: return self._reg_fm_ver.decode() except Exception as e: logger.error(str(e)) return \"\" def install_firmware(self, image_path): \"\"\" Installs firmware to the component Args: image_path: A string, path to firmware image Returns: A boolean, True if install was successful, False if not \"\"\" try: successtips=\"CPLD Upgrade succeeded!\" status, output=subprocess.getstatusoutput(\"which firmware_upgrade\") if status or len(output) <=0: logger.error(\"no upgrade tool.\") return False cmdstr=\"%s %s cpld %d cpld\"%(output,image_path,self.slot) ret, log=subprocess.getstatusoutput(cmdstr) if ret==0 and successtips in log: return True logger.error(\"upgrade failed. ret:%d, log:\\n%s\" %(ret, log)) except Exception as e: logger.error(str(e)) return False ", "sourceWithComments": "########################################################################\n# Ruijie B6510-48VS8CQ\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Components' (e.g., BIOS, CPLD, FPGA, etc.) available in\n# the platform\n#\n########################################################################\n\ntry:\n    import subprocess\n    from sonic_platform_base.component_base import ComponentBase\n    from sonic_platform.regutil import Reg\n    from sonic_platform.logger import logger\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass Component(ComponentBase):\n    \"\"\"Ruijie Platform-specific Component class\"\"\"\n\n    def __init__(self, index, config=None):\n        self.index = index\n        self.name = config.get(\"name\")\n        self._reg_fm_ver = Reg(config.get(\"firmware_version\"))\n        self.description = config.get(\"desc\")\n        self.slot = config.get(\"slot\")\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n\n        Returns:\n            A string containing the name of the component\n        \"\"\"\n        return self.name\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n\n        Returns:\n            A string containing the description of the component\n        \"\"\"\n        return self.description\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of the component\n\n        Returns:\n            A string containing the firmware version of the component\n        \"\"\"\n        try:\n            return self._reg_fm_ver.decode()\n        except Exception as e:\n            logger.error(str(e))\n\n        return \"\"\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Installs firmware to the component\n\n        Args:\n            image_path: A string, path to firmware image\n\n        Returns:\n            A boolean, True if install was successful, False if not\n        \"\"\"\n        try:\n            successtips = \"CPLD Upgrade succeeded!\"\n            status, output = subprocess.getstatusoutput(\"which firmware_upgrade\")\n            if status or len(output) <= 0:\n                logger.error(\"no upgrade tool.\")\n                return False\n            cmdstr = \"%s %s cpld %d cpld\"%(output,image_path,self.slot)\n            ret, log = subprocess.getstatusoutput(cmdstr)\n            if ret == 0 and successtips in log:\n                return True\n            logger.error(\"upgrade failed. ret:%d, log:\\n%s\" % (ret, log))\n        except Exception as e:\n            logger.error(str(e))\n        return False\n        \n"}, "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py": {"changes": [{"diff": "\n #\n #######################################################\n \n-import subprocess\n import time\n import glob\n import re\n", "add": 0, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["import subprocess"], "goodparts": []}, {"diff": "\n \n     @staticmethod\n     def command(cmdstr):\n-        retcode, output = subprocess.getstatusoutput(cmdstr)\n+        retcode, output = getstatusoutput_noshell(cmdstr)\n         return retcode, output\n \n \n     @staticmethod\n     def geti2cword_i2ctool(bus, addr, offset):\n-        command_line = \"i2cget -f -y %d 0x%02x 0x%02x  wp\" % (bus, addr, offset)\n+        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%02x\"%offset, \"wp\"]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        retcode, output = subprocess.getstatusoutput(cmdstr)", "        command_line = \"i2cget -f -y %d 0x%02x 0x%02x  wp\" % (bus, addr, offset)"], "goodparts": ["        retcode, output = getstatusoutput_noshell(cmdstr)", "        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%02x\"%offset, \"wp\"]"]}, {"diff": "\n \n     @staticmethod\n     def seti2cword_i2ctool(bus, addr, offset, val):\n-        command_line = \"i2cset -f -y %d 0x%02x 0x%0x 0x%04x wp\" % (bus, addr, offset, val)\n+        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%0x\"%offset, \"0x%04x\"%val, \"wp\"]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        command_line = \"i2cset -f -y %d 0x%02x 0x%0x 0x%04x wp\" % (bus, addr, offset, val)"], "goodparts": ["        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%0x\"%offset, \"0x%04x\"%val, \"wp\"]"]}, {"diff": "\n \n     @staticmethod\n     def rji2cget_i2ctool(bus, devno, address):\n-        command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)\n+        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)"], "goodparts": ["        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address]"]}, {"diff": "\n \n     @staticmethod\n     def rji2cset_i2ctool(bus, devno, address, byte):\n-        command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (\n-            bus, devno, address, byte)\n+        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address, \"0x%02x\"%byte]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n", "add": 1, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (", "            bus, devno, address, byte)"], "goodparts": ["        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address, \"0x%02x\"%byte]"]}, {"diff": "\n \n     @staticmethod\n     def getdevmem(addr, digit, mask):\n-        command_line = \"devmem 0x%02x %d\" %(addr, digit)\n+        command_line = [\"devmem\", \"0x%02x\"%addr, str(digit)]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        command_line = \"devmem 0x%02x %d\" %(addr, digit)"], "goodparts": ["        command_line = [\"devmem\", \"0x%02x\"%addr, str(digit)]"]}, {"diff": "\n \n     @staticmethod\n     def rj_os_system(cmd):\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         return status, output\n \n     @staticmethod\n     def getsdkreg(reg):\n         try:\n-            cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg\n+            cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]\n             ret, result = osutil.rj_os_system(cmd)\n             result_t = result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n             if ret != 0 or \"Error:\" in result_t:\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        status, output = subprocess.getstatusoutput(cmd)", "            cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg"], "goodparts": ["        status, output = getstatusoutput_noshell(cmd)", "            cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]"]}, {"diff": "\n             result = {}\n             #waitForDocker()\n             #need to exec twice\n-            osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n-            ret, log = osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n+            osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n+            ret, log = osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n             if ret:\n                 return False, result\n             e", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["            osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")", "            ret, log = osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")"], "goodparts": ["            osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])", "            ret, log = osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])"]}], "source": "\n import subprocess import time import glob import re from rjutil.smbus import SMBus import time from functools import wraps def retry(maxretry=6, delay=0.01): ''' maxretry: max retry times delay : interval after last retry ''' def decorator(f): @wraps(f) def wrapper(*args, **kwargs): time_retry=maxretry time_delay=delay result_msg=\"\" while time_retry: try: val, result_msg=f(*args, **kwargs) if val is False: time_retry -=1 time.sleep(time_delay) continue else: return val, result_msg except Exception as e: time_retry -=1 result_msg=str(e) time.sleep(time_delay) return False, \"max time retry last errmsg is{}\".format(result_msg) return wrapper return decorator class osutil(object): \"\"\" osutil \"\"\" @staticmethod @retry(maxretry=6) def rji2cget_python(bus, addr, reg): with SMBus(bus) as y: val, ind =y.read_byte_data(addr, reg, True) return val, ind @staticmethod @retry(maxretry=6) def rji2cset_python(bus, addr, reg, value): with SMBus(bus) as y: val, ind =y.write_byte_data(addr, reg, value, True) return val, ind @staticmethod @retry(maxretry=6) def rji2cgetword_python(bus, addr, reg): with SMBus(bus) as y: val, ind =y.read_word_data(addr, reg, True) return val, ind @staticmethod @retry(maxretry=6) def rji2csetword_python(bus, addr, reg, value): with SMBus(bus) as y: val, ind =y.write_word_data(addr, reg, value, True) return val, ind @staticmethod def command(cmdstr): retcode, output=subprocess.getstatusoutput(cmdstr) return retcode, output @staticmethod def geti2cword_i2ctool(bus, addr, offset): command_line=\"i2cget -f -y %d 0x%02x 0x%02x wp\" %(bus, addr, offset) retrytime=6 ret_t=\"\" for i in range(retrytime): ret, ret_t=osutil.command(command_line) if ret==0: return True, int(ret_t, 16) time.sleep(0.1) return False, ret_t @staticmethod def seti2cword_i2ctool(bus, addr, offset, val): command_line=\"i2cset -f -y %d 0x%02x 0x%0x 0x%04x wp\" %(bus, addr, offset, val) retrytime=6 ret_t=\"\" for i in range(retrytime): ret, ret_t=osutil.command(command_line) if ret==0: return True, ret_t time.sleep(0.1) return False, ret_t @staticmethod def rji2cget_i2ctool(bus, devno, address): command_line=\"i2cget -f -y %d 0x%02x 0x%02x \" %(bus, devno, address) retrytime=6 ret_t=\"\" for i in range(retrytime): ret, ret_t=osutil.command(command_line) if ret==0: return True, int(ret_t, 16) time.sleep(0.1) return False, ret_t @staticmethod def rji2cset_i2ctool(bus, devno, address, byte): command_line=\"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" %( bus, devno, address, byte) retrytime=6 ret_t=\"\" for i in range(retrytime): ret, ret_t=osutil.command(command_line) if ret==0: return True, ret_t return False, ret_t @staticmethod def geti2cword(bus, addr, offset): return osutil.rji2cgetword_python(bus, addr, offset) @staticmethod def seti2cword(bus, addr, offset, val): return osutil.rji2csetword_python(bus, addr, offset, val) @staticmethod def rji2cget(bus, devno, address): return osutil.rji2cget_python(bus, devno, address) @staticmethod def rji2cset(bus, devno, address, byte): return osutil.rji2cset_python(bus, devno, address, byte) @staticmethod def byteTostr(val): strtmp='' for i in range(len(val)): strtmp +=chr(val[i]) return strtmp @staticmethod def readsysfs(location): try: locations=glob.glob(location) with open(locations[0], 'rb') as fd1: retval=fd1.read() retval=retval.strip() except Exception as e: return False,(str(e)+\" location[%s]\" % location) return True, retval.decode(\"utf-8\", \"ignore\") @staticmethod def getdevmem(addr, digit, mask): command_line=\"devmem 0x%02x %d\" %(addr, digit) retrytime=6 ret_t=\"\" for i in range(retrytime): ret, ret_t=osutil.command(command_line) if ret==0: if mask !=None: ret_t=str(int(ret_t, 16) & mask) return True, ret_t return False, ret_t @staticmethod def rj_os_system(cmd): status, output=subprocess.getstatusoutput(cmd) return status, output @staticmethod def getsdkreg(reg): try: cmd=\"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg ret, result=osutil.rj_os_system(cmd) result_t=result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\") if ret !=0 or \"Error:\" in result_t: return False, result patt=r\"%s.(.*):(.*)>drivshell\" % reg rt=re.findall(patt, result_t, re.S) test=re.findall(\"=(.*)\", rt[0][0])[0] except Exception as e: return False, 'get sdk register error' return True, test @staticmethod def getmactemp(): try: result={} osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\") ret, log=osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\") if ret: return False, result else: logs=log.splitlines() for line in logs: if \"average\" in line: b=re.findall(r'\\d+.\\d+', line) result[\"average\"]=b[0] elif \"maximum\" in line: b=re.findall(r'\\d+.\\d+', line) result[\"maximum\"]=b[0] except Exception as e: return False, str(e) return True, result ", "sourceWithComments": "#######################################################\n#\n# osutil.py\n# Python implementation of the Class osutil\n# Original author: sonic_rd@ruijie.com.cn\n#\n#######################################################\n\nimport subprocess\nimport time\nimport glob\nimport re\n#import chardet\nfrom rjutil.smbus import SMBus\nimport time\nfrom  functools import wraps\n\n\ndef retry(maxretry =6, delay = 0.01):\n    '''\n        maxretry:  max retry times\n        delay   :  interval after last retry\n    '''\n    def decorator(f):\n        @wraps(f)\n        def wrapper(*args, **kwargs):\n            time_retry = maxretry\n            time_delay = delay\n            result_msg = \"\"\n            while time_retry:\n                try:\n                    val , result_msg = f(*args, **kwargs)\n                    if val is False:\n                        time_retry -=1\n                        time.sleep(time_delay)\n                        continue\n                    else:\n                        return val, result_msg\n                except Exception as e:\n                    time_retry -= 1\n                    result_msg = str(e)\n                    time.sleep(time_delay)\n            return False, \"max time retry last errmsg is {}\".format(result_msg)\n        return wrapper\n    return decorator\n\nclass osutil(object):\n    \"\"\"\n       osutil\n    \"\"\"\n\n    @staticmethod\n    @retry(maxretry = 6)\n    def rji2cget_python(bus, addr, reg):\n        with SMBus(bus) as y:\n            val , ind  = y.read_byte_data(addr, reg, True)\n        return val , ind\n\n\n    @staticmethod\n    @retry(maxretry = 6)\n    def rji2cset_python(bus, addr, reg, value):\n        with SMBus(bus) as y:\n            val , ind  = y.write_byte_data(addr, reg, value, True)\n        return val , ind\n\n    @staticmethod\n    @retry(maxretry = 6)\n    def rji2cgetword_python(bus, addr, reg):\n        with SMBus(bus) as y:\n            val , ind  = y.read_word_data(addr, reg, True)\n        return val , ind\n\n    @staticmethod\n    @retry(maxretry = 6)\n    def rji2csetword_python(bus, addr, reg, value):\n        with SMBus(bus) as y:\n            val , ind  = y.write_word_data(addr, reg, value, True)\n        return val , ind\n\n    @staticmethod\n    def command(cmdstr):\n        retcode, output = subprocess.getstatusoutput(cmdstr)\n        return retcode, output\n\n\n    @staticmethod\n    def geti2cword_i2ctool(bus, addr, offset):\n        command_line = \"i2cget -f -y %d 0x%02x 0x%02x  wp\" % (bus, addr, offset)\n        retrytime = 6\n        ret_t = \"\"\n        for i in range(retrytime):\n            ret, ret_t = osutil.command(command_line)\n            if ret == 0:\n                return True, int(ret_t, 16)\n            time.sleep(0.1)\n        return False, ret_t\n\n\n    @staticmethod\n    def seti2cword_i2ctool(bus, addr, offset, val):\n        command_line = \"i2cset -f -y %d 0x%02x 0x%0x 0x%04x wp\" % (bus, addr, offset, val)\n        retrytime = 6\n        ret_t = \"\"\n        for i in range(retrytime):\n            ret, ret_t = osutil.command(command_line)\n            if ret == 0:\n                return True, ret_t\n            time.sleep(0.1)\n        return False, ret_t\n\n    @staticmethod\n    def rji2cget_i2ctool(bus, devno, address):\n        command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)\n        retrytime = 6\n        ret_t = \"\"\n        for i in range(retrytime):\n            ret, ret_t = osutil.command(command_line)\n            if ret == 0:\n                return True, int(ret_t, 16)\n            time.sleep(0.1)\n        return False, ret_t\n\n    @staticmethod\n    def rji2cset_i2ctool(bus, devno, address, byte):\n        command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (\n            bus, devno, address, byte)\n        retrytime = 6\n        ret_t = \"\"\n        for i in range(retrytime):\n            ret, ret_t = osutil.command(command_line)\n            if ret == 0:\n                return True, ret_t\n        return False, ret_t\n\n    @staticmethod\n    def geti2cword(bus, addr, offset):\n        return osutil.rji2cgetword_python(bus, addr, offset)\n    @staticmethod\n    def seti2cword(bus, addr, offset, val):\n        return osutil.rji2csetword_python(bus, addr, offset, val)\n    @staticmethod\n    def rji2cget(bus, devno, address):\n        return osutil.rji2cget_python(bus, devno, address)\n    @staticmethod\n    def rji2cset(bus, devno, address, byte):\n        return osutil.rji2cset_python(bus, devno, address, byte)\n\n    @staticmethod\n    def byteTostr(val):\n        strtmp = ''\n        for i in range(len(val)):\n            strtmp += chr(val[i])\n        return strtmp\n\n    @staticmethod\n    def readsysfs(location):\n        try:\n            locations = glob.glob(location)\n            with open(locations[0], 'rb') as fd1:\n                retval = fd1.read()\n            retval = retval.strip()\n        except Exception as e:\n            return False, (str(e)+\" location[%s]\" % location)\n        return True, retval.decode(\"utf-8\", \"ignore\")\n\n    @staticmethod\n    def getdevmem(addr, digit, mask):\n        command_line = \"devmem 0x%02x %d\" %(addr, digit)\n        retrytime = 6\n        ret_t = \"\"\n        for i in range(retrytime):\n            ret, ret_t = osutil.command(command_line)\n            if ret == 0:\n                if mask != None:\n                    ret_t = str(int(ret_t, 16) & mask)\n            return True, ret_t\n        return False, ret_t\n\n    @staticmethod\n    def rj_os_system(cmd):\n        status, output = subprocess.getstatusoutput(cmd)\n        return status, output\n\n    @staticmethod\n    def getsdkreg(reg):\n        try:\n            cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg\n            ret, result = osutil.rj_os_system(cmd)\n            result_t = result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n            if ret != 0 or \"Error:\" in result_t:\n                return False, result\n            patt = r\"%s.(.*):(.*)>drivshell\" % reg\n            rt = re.findall(patt, result_t, re.S)\n            test = re.findall(\"=(.*)\", rt[0][0])[0]\n        except Exception as e:\n            return False, 'get sdk register error'\n        return True, test\n\n    @staticmethod\n    def getmactemp():\n        try:\n            result = {}\n            #waitForDocker()\n            #need to exec twice\n            osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n            ret, log = osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n            if ret:\n                return False, result\n            else:\n                logs = log.splitlines()\n                for line in logs:\n                    if \"average\" in line:\n                        b = re.findall(r'\\d+.\\d+', line)\n                        result[\"average\"] = b[0]\n                    elif \"maximum\" in line:\n                        b = re.findall(r'\\d+.\\d+', line)\n                        result[\"maximum\"] = b[0]\n        except Exception as e:\n            return False, str(e)\n        return True, result\n\n"}, "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py": {"changes": [{"diff": "\n \n def check_driver():\n     u'''whether there is driver start with rg'''\n-    status, output = log_os_system(\"lsmod | grep rg | wc -l\")\n+    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", \"rg\"], [\"wc\", \"-l\"])\n     #System execution error\n     if status: \n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["    status, output = log_os_system(\"lsmod | grep rg | wc -l\")"], "goodparts": ["    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", \"rg\"], [\"wc\", \"-l\"])"]}, {"diff": "\n     return ret\n \n def startAvscontrol():\n-    cmd = \"nohup avscontrol.py start >/dev/null 2>&1 &\"\n+    cmd = [\"avscontrol.py\", \"start\"]\n     rets = i2c_getPid(\"avscontrol.py\")\n     if len(rets) == 0:\n-        os.system(cmd)\n+        subprocess.Popen(cmd)\n \n def startFanctrol():\n     if STARTMODULE['fancontrol'] == 1:\n-        cmd = \"nohup fancontrol.py start >/dev/null 2>&1 &\"\n+        cmd = [\"fancontrol.py\", \"start\"]\n         rets = i2c_getPid(\"fancontrol.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def starthal_fanctrl():\n     if STARTMODULE.get('hal_fanctrl',0) == 1:\n-        cmd = \"nohup hal_fanctrl.py start >/dev/null 2>&1 &\"\n+        cmd = [\"hal_fanctrl.py\", \"start\"]\n         rets = i2c_getPid(\"hal_fanctrl.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def starthal_ledctrl():\n     if STARTMODULE.get('hal_ledctrl',0) == 1:\n-        cmd = \"nohup hal_ledctrl.py start >/dev/null 2>&1 &\"\n+        cmd = [\"hal_ledctrl.py\", \"start\"]\n         rets = i2c_getPid(\"hal_ledctrl.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n-\n+            subprocess.Popen(cmd)\n def startDevmonitor():\n     if STARTMODULE.get('dev_monitor',0) == 1:\n-        cmd = \"nohup dev_monitor.py start >/dev/null 2>&1 &\"\n+        cmd = [\"dev_monitor.py\", \"start\"]\n         rets = i2c_getPid(\"dev_monitor.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n-\n+            subprocess.Popen(cmd)\n def startSlotmonitor():\n     if STARTMODULE.get('slot_monitor',0) == 1:\n-        cmd = \"nohup slot_monitor.py start >/dev/null 2>&1 &\"\n+        cmd = [\"slot_monitor.py\", \"start\"]\n         rets = i2c_getPid(\"slot_monitor.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def stopFanctrol():\n     u'''disable fan timer service'''\n     if STARTMODULE['fancontrol'] == 1:\n         rets = i2c_getPid(\"fancontrol.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def stophal_ledctrl():\n     if STARTMODULE.get('hal_ledctrl',0) == 1:\n         rets = i2c_getPid(\"hal_ledctrl.py\")\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n \n", "add": 16, "remove": 18, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["    cmd = \"nohup avscontrol.py start >/dev/null 2>&1 &\"", "        os.system(cmd)", "        cmd = \"nohup fancontrol.py start >/dev/null 2>&1 &\"", "            os.system(cmd)", "        cmd = \"nohup hal_fanctrl.py start >/dev/null 2>&1 &\"", "            os.system(cmd)", "        cmd = \"nohup hal_ledctrl.py start >/dev/null 2>&1 &\"", "            os.system(cmd)", "        cmd = \"nohup dev_monitor.py start >/dev/null 2>&1 &\"", "            os.system(cmd)", "        cmd = \"nohup slot_monitor.py start >/dev/null 2>&1 &\"", "            os.system(cmd)", "            cmd = \"kill \"+ ret", "            os.system(cmd)", "            cmd = \"kill \"+ ret", "            os.system(cmd)"], "goodparts": ["    cmd = [\"avscontrol.py\", \"start\"]", "        subprocess.Popen(cmd)", "        cmd = [\"fancontrol.py\", \"start\"]", "            subprocess.Popen(cmd)", "        cmd = [\"hal_fanctrl.py\", \"start\"]", "            subprocess.Popen(cmd)", "        cmd = [\"hal_ledctrl.py\", \"start\"]", "            subprocess.Popen(cmd)", "        cmd = [\"dev_monitor.py\", \"start\"]", "            subprocess.Popen(cmd)", "        cmd = [\"slot_monitor.py\", \"start\"]", "            subprocess.Popen(cmd)", "            cmd = [\"kill\", ret]", "            subprocess.call(cmd)", "            cmd = [\"kill\", ret]", "            subprocess.call(cmd)"]}, {"diff": "\n     if STARTMODULE.get('dev_monitor',0) == 1:\n         rets = i2c_getPid(\"dev_monitor.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def stopSlotmonitor():\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["            cmd = \"kill \"+ ret", "            os.system(cmd)"], "goodparts": ["            cmd = [\"kill\", ret]", "            subprocess.call(cmd)"]}, {"diff": "\n     if STARTMODULE.get('slot_monitor',0) == 1:\n         rets = i2c_getPid(\"slot_monitor.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def removeDev(bus, loc):\n-    cmd = \"echo  0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device\" % (loc, bus)\n     devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n     if os.path.exists(devpath):\n-        log_os_system(cmd)\n+        file = \"/sys/bus/i2c/devices/i2c-%d/delete_device\" % bus\n+        with open(file, 'w') as f:\n+            f.write('0x%02x\\n'%str(bus))\n         \n def addDev(name, bus, loc):\n     if name == \"lm75\":\n", "add": 5, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["            cmd = \"kill \"+ ret", "            os.system(cmd)", "    cmd = \"echo  0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device\" % (loc, bus)", "        log_os_system(cmd)"], "goodparts": ["            cmd = [\"kill\", ret]", "            subprocess.call(cmd)", "        file = \"/sys/bus/i2c/devices/i2c-%d/delete_device\" % bus", "        with open(file, 'w') as f:", "            f.write('0x%02x\\n'%str(bus))"]}, {"diff": "\n         if i % 10 == 0:\n             click.echo(\"%%DEVICE_I2C-INIT: %s not found, wait 0.1 second ! i %d \" % (pdevpath,i))\n             \n-    cmd = \"echo  %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device\" % (name, loc, bus)\n     devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n     if os.path.exists(devpath) == False:\n-        os.system(cmd)\n+        file = \"/sys/bus/i2c/devices/i2c-%d/new_device\" % bus\n+        with open(file, 'w') as f:\n+            f.write('%s 0x%02x\\n' % (name, loc))\n \n def removedevs():\n     devs = GLOBALCONFIG[\"DEVS\"]\n", "add": 3, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["    cmd = \"echo  %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device\" % (name, loc, bus)", "        os.system(cmd)"], "goodparts": ["        file = \"/sys/bus/i2c/devices/i2c-%d/new_device\" % bus", "        with open(file, 'w') as f:", "            f.write('%s 0x%02x\\n' % (name, loc))"]}, {"diff": "\n         addDev(devs[dev][\"name\"], devs[dev][\"bus\"] , devs[dev][\"loc\"])\n \n def checksignaldriver(name):\n-    modisexistcmd = \"lsmod | grep %s | wc -l\" % name\n-    status, output = log_os_system(modisexistcmd)\n+    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", name], [\"wc\", \"-l\"])\n     #System execution error\n     if status: \n         return False\n", "add": 1, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["    modisexistcmd = \"lsmod | grep %s | wc -l\" % name", "    status, output = log_os_system(modisexistcmd)"], "goodparts": ["    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", name], [\"wc\", \"-l\"])"]}, {"diff": "\n         return False\n \n def adddriver(name, delay):\n-    cmd = \"modprobe %s\" % name\n+    cmd = [\"modprobe\", name]\n     if delay != 0:\n         time.sleep(delay)\n     if checksignaldriver(name) != True:\n-        log_os_system(cmd)\n+        getstatusoutput_noshell(cmd)\n \n def removedriver(name, delay):\n     realname = name.lstrip().split(\" \")[0];\n-    cmd = \"rmmod -f %s\" % realname\n+    cmd = [\"rmmod\", \"-f\", realname]\n     if checksignaldriver(realname):\n-        log_os_system(cmd)\n+        getstatusoutput_noshell(cmd)\n \n def removedrivers():\n     u'''remove all drive", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["    cmd = \"modprobe %s\" % name", "        log_os_system(cmd)", "    cmd = \"rmmod -f %s\" % realname", "        log_os_system(cmd)"], "goodparts": ["    cmd = [\"modprobe\", name]", "        getstatusoutput_noshell(cmd)", "    cmd = [\"rmmod\", \"-f\", realname]", "        getstatusoutput_noshell(cmd)"]}], "source": "\n import click import os import subprocess import time from ruijieconfig import GLOBALCONFIG, GLOBALINITPARAM, GLOBALINITCOMMAND, MAC_LED_RESET, STARTMODULE, i2ccheck_params from ruijieutil import rjpciwr CONTEXT_SETTINGS=dict(help_option_names=['-h', '--help']) class AliasedGroup(click.Group): def get_command(self, ctx, cmd_name): rv=click.Group.get_command(self, ctx, cmd_name) if rv is not None: return rv matches=[x for x in self.list_commands(ctx) if x.startswith(cmd_name)] if not matches: return None elif len(matches)==1: return click.Group.get_command(self, ctx, matches[0]) ctx.fail('Too many matches: %s' % ', '.join(sorted(matches))) def log_os_system(cmd): u'''execute shell command''' status, output=subprocess.getstatusoutput(cmd) if status: print(output) return status, output def write_sysfs_value(reg_name, value): u'''write sysfs file''' mb_reg_file=\"/sys/bus/i2c/devices/\" +reg_name if(not os.path.isfile(mb_reg_file)): print(mb_reg_file, 'not found !') return False try: with open(mb_reg_file, 'w') as fd: fd.write(value) except Exception as error: return False return True def check_driver(): u'''whether there is driver start with rg''' status, output=log_os_system(\"lsmod | grep rg | wc -l\") if status: return False if output.isdigit() and int(output) > 0: return True else: return False def i2c_getPid(name): ret=[] for dirname in os.listdir('/proc'): if dirname=='curproc': continue try: with open('/proc/{}/cmdline'.format(dirname), mode='r') as fd: content=fd.read() except Exception: continue if name in content: ret.append(dirname) return ret def startAvscontrol(): cmd=\"nohup avscontrol.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"avscontrol.py\") if len(rets)==0: os.system(cmd) def startFanctrol(): if STARTMODULE['fancontrol']==1: cmd=\"nohup fancontrol.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"fancontrol.py\") if len(rets)==0: os.system(cmd) def starthal_fanctrl(): if STARTMODULE.get('hal_fanctrl',0)==1: cmd=\"nohup hal_fanctrl.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"hal_fanctrl.py\") if len(rets)==0: os.system(cmd) def starthal_ledctrl(): if STARTMODULE.get('hal_ledctrl',0)==1: cmd=\"nohup hal_ledctrl.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"hal_ledctrl.py\") if len(rets)==0: os.system(cmd) def startDevmonitor(): if STARTMODULE.get('dev_monitor',0)==1: cmd=\"nohup dev_monitor.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"dev_monitor.py\") if len(rets)==0: os.system(cmd) def startSlotmonitor(): if STARTMODULE.get('slot_monitor',0)==1: cmd=\"nohup slot_monitor.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"slot_monitor.py\") if len(rets)==0: os.system(cmd) def stopFanctrol(): u'''disable fan timer service''' if STARTMODULE['fancontrol']==1: rets=i2c_getPid(\"fancontrol.py\") for ret in rets: cmd=\"kill \"+ret os.system(cmd) return True def stophal_ledctrl(): if STARTMODULE.get('hal_ledctrl',0)==1: rets=i2c_getPid(\"hal_ledctrl.py\") for ret in rets: cmd=\"kill \"+ret os.system(cmd) return True def stopDevmonitor(): u'''disable the fan timer service''' if STARTMODULE.get('dev_monitor',0)==1: rets=i2c_getPid(\"dev_monitor.py\") for ret in rets: cmd=\"kill \"+ret os.system(cmd) return True def stopSlotmonitor(): u'''disable slot timer service''' if STARTMODULE.get('slot_monitor',0)==1: rets=i2c_getPid(\"slot_monitor.py\") for ret in rets: cmd=\"kill \"+ret os.system(cmd) return True def removeDev(bus, loc): cmd=\"echo 0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device\" %(loc, bus) devpath=\"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc) if os.path.exists(devpath): log_os_system(cmd) def addDev(name, bus, loc): if name==\"lm75\": time.sleep(0.1) pdevpath=\"/sys/bus/i2c/devices/i2c-%d/\" %(bus) for i in range(1, 100): if os.path.exists(pdevpath)==True: break time.sleep(0.1) if i % 10==0: click.echo(\"%%DEVICE_I2C-INIT: %s not found, wait 0.1 second ! i %d \" %(pdevpath,i)) cmd=\"echo %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device\" %(name, loc, bus) devpath=\"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc) if os.path.exists(devpath)==False: os.system(cmd) def removedevs(): devs=GLOBALCONFIG[\"DEVS\"] for index in range(len(devs)-1, -1, -1): removeDev(devs[index][\"bus\"], devs[index][\"loc\"]) def adddevs(): devs=GLOBALCONFIG[\"DEVS\"] for dev in range(0, devs.__len__()): addDev(devs[dev][\"name\"], devs[dev][\"bus\"], devs[dev][\"loc\"]) def checksignaldriver(name): modisexistcmd=\"lsmod | grep %s | wc -l\" % name status, output=log_os_system(modisexistcmd) if status: return False if output.isdigit() and int(output) > 0: return True else: return False def adddriver(name, delay): cmd=\"modprobe %s\" % name if delay !=0: time.sleep(delay) if checksignaldriver(name) !=True: log_os_system(cmd) def removedriver(name, delay): realname=name.lstrip().split(\" \")[0]; cmd=\"rmmod -f %s\" % realname if checksignaldriver(realname): log_os_system(cmd) def removedrivers(): u'''remove all drivers''' if GLOBALCONFIG is None: click.echo(\"%%DEVICE_I2C-INIT: load global config failed.\") return drivers=GLOBALCONFIG.get(\"DRIVERLISTS\", None) if drivers is None: click.echo(\"%%DEVICE_I2C-INIT: load driver list failed.\") return for index in range(len(drivers)-1, -1, -1): delay=0 name=\"\" if type(drivers[index])==dict and \"delay\" in drivers[index]: name=drivers[index].get(\"name\") delay=drivers[index][\"delay\"] else: name=drivers[index] removedriver(name, delay) def adddrivers(): u'''add drivers''' if GLOBALCONFIG is None: click.echo(\"%%DEVICE_I2C-INIT: load global config failed.\") return drivers=GLOBALCONFIG.get(\"DRIVERLISTS\", None) if drivers is None: click.echo(\"%%DEVICE_I2C-INIT: load driver list failed.\") return for index in range(0,len(drivers)): delay=0 name=\"\" if type(drivers[index])==dict and \"delay\" in drivers[index]: name=drivers[index].get(\"name\") delay=drivers[index][\"delay\"] else: name=drivers[index] adddriver(name, delay) def otherinit(): for index in GLOBALINITPARAM: write_sysfs_value(index[\"loc\"], index[\"value\"]) for index in GLOBALINITCOMMAND: log_os_system(index) def unload_driver(): u'''remove devices and drivers''' stopDevmonitor() stopFanctrol() removedevs() removedrivers() def reload_driver(): u'''reload devices and drivers''' removedevs() removedrivers() time.sleep(1) adddrivers() adddevs() def i2c_check(bus,retrytime=6): try: i2cpath=\"/sys/bus/i2c/devices/\" +bus while retrytime and not os.path.exists(i2cpath): click.echo(\"%%DEVICE_I2C-HA: i2c bus abnormal, last bus %s is not exist.\" % i2cpath) reload_driver() retrytime -=1 time.sleep(1) except Exception as e: click.echo(\"%%DEVICE_I2C-HA: %s\" % str(e)) return def MacLedSet(data): '''write pci register''' pcibus=MAC_LED_RESET.get(\"pcibus\") slot=MAC_LED_RESET.get(\"slot\") fn=MAC_LED_RESET.get(\"fn\") bar=MAC_LED_RESET.get(\"bar\") offset=MAC_LED_RESET.get(\"offset\") val=MAC_LED_RESET.get(data, None) if val is None: click.echo(\"%%DEVICE_I2C-INIT: MacLedSet wrong input\") return rjpciwr(pcibus, slot, fn, bar, offset, val) def load_driver(): u'''load devices and drivers''' adddrivers() adddevs() if STARTMODULE.get(\"i2ccheck\",0)==1: busend=i2ccheck_params.get(\"busend\") retrytime=i2ccheck_params.get(\"retrytime\") i2c_check(busend,retrytime) startFanctrol() starthal_fanctrl() starthal_ledctrl() if STARTMODULE['avscontrol']==1: startAvscontrol() startDevmonitor() startSlotmonitor() otherinit(); if STARTMODULE.get(\"macledreset\",0)==1: MacLedSet(\"reset\") @click.group(cls=AliasedGroup, context_settings=CONTEXT_SETTINGS) def main(): '''device operator''' pass @main.command() def start(): '''load device ''' if check_driver(): unload_driver() load_driver() @main.command() def stop(): '''stop device ''' unload_driver() @main.command() def restart(): '''restart device''' unload_driver() load_driver() if __name__=='__main__': u'''device_i2c operation''' main() ", "sourceWithComments": "#!/usr/bin/env python3\n# -*- coding: UTF-8 -*-\n\nimport click\nimport os\nimport subprocess\nimport time\nfrom  ruijieconfig import GLOBALCONFIG, GLOBALINITPARAM, GLOBALINITCOMMAND, MAC_LED_RESET, STARTMODULE, i2ccheck_params\n\nfrom  ruijieutil   import rjpciwr\n\nCONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])\n\nclass AliasedGroup(click.Group):\n    def get_command(self, ctx, cmd_name):\n        rv = click.Group.get_command(self, ctx, cmd_name)\n        if rv is not None:\n            return rv\n        matches = [x for x in self.list_commands(ctx)\n                   if x.startswith(cmd_name)]\n        if not matches:\n            return None\n        elif len(matches) == 1:\n            return click.Group.get_command(self, ctx, matches[0])\n        ctx.fail('Too many matches: %s' % ', '.join(sorted(matches)))\n   \ndef log_os_system(cmd):\n    u'''execute shell command'''\n    status, output = subprocess.getstatusoutput(cmd)\n    if status:\n        print(output)\n    return  status, output\n\ndef write_sysfs_value(reg_name, value):\n    u'''write sysfs file'''\n    mb_reg_file = \"/sys/bus/i2c/devices/\" + reg_name\n    if (not os.path.isfile(mb_reg_file)):\n        print(mb_reg_file,  'not found !')\n        return False\n    try:\n        with open(mb_reg_file, 'w') as fd:\n            fd.write(value)\n    except Exception as error:\n        return False\n    return True\n\ndef check_driver():\n    u'''whether there is driver start with rg'''\n    status, output = log_os_system(\"lsmod | grep rg | wc -l\")\n    #System execution error\n    if status: \n        return False\n    if output.isdigit() and int(output) > 0:\n        return True\n    else:\n        return False\n\ndef i2c_getPid(name):\n    ret = []\n    for dirname in os.listdir('/proc'):\n        if dirname == 'curproc':\n            continue\n        try:\n            with open('/proc/{}/cmdline'.format(dirname), mode='r') as fd:\n                content = fd.read()\n        except Exception:\n            continue\n        if name in content:\n            ret.append(dirname)\n    return ret\n\ndef startAvscontrol():\n    cmd = \"nohup avscontrol.py start >/dev/null 2>&1 &\"\n    rets = i2c_getPid(\"avscontrol.py\")\n    if len(rets) == 0:\n        os.system(cmd)\n\ndef startFanctrol():\n    if STARTMODULE['fancontrol'] == 1:\n        cmd = \"nohup fancontrol.py start >/dev/null 2>&1 &\"\n        rets = i2c_getPid(\"fancontrol.py\")\n        if len(rets) == 0:\n            os.system(cmd)\n\ndef starthal_fanctrl():\n    if STARTMODULE.get('hal_fanctrl',0) == 1:\n        cmd = \"nohup hal_fanctrl.py start >/dev/null 2>&1 &\"\n        rets = i2c_getPid(\"hal_fanctrl.py\")\n        if len(rets) == 0:\n            os.system(cmd)\n\ndef starthal_ledctrl():\n    if STARTMODULE.get('hal_ledctrl',0) == 1:\n        cmd = \"nohup hal_ledctrl.py start >/dev/null 2>&1 &\"\n        rets = i2c_getPid(\"hal_ledctrl.py\")\n        if len(rets) == 0:\n            os.system(cmd)\n\ndef startDevmonitor():\n    if STARTMODULE.get('dev_monitor',0) == 1:\n        cmd = \"nohup dev_monitor.py start >/dev/null 2>&1 &\"\n        rets = i2c_getPid(\"dev_monitor.py\")\n        if len(rets) == 0:\n            os.system(cmd)\n\ndef startSlotmonitor():\n    if STARTMODULE.get('slot_monitor',0) == 1:\n        cmd = \"nohup slot_monitor.py start >/dev/null 2>&1 &\"\n        rets = i2c_getPid(\"slot_monitor.py\")\n        if len(rets) == 0:\n            os.system(cmd)\n\ndef stopFanctrol():\n    u'''disable fan timer service'''\n    if STARTMODULE['fancontrol'] == 1:\n        rets = i2c_getPid(\"fancontrol.py\")  #\n        for ret in rets:\n            cmd = \"kill \"+ ret\n            os.system(cmd)\n        return True\n\ndef stophal_ledctrl():\n    if STARTMODULE.get('hal_ledctrl',0) == 1:\n        rets = i2c_getPid(\"hal_ledctrl.py\")\n        for ret in rets:\n            cmd = \"kill \"+ ret\n            os.system(cmd)\n        return True\n\n\ndef stopDevmonitor():\n    u'''disable the fan timer service'''\n    if STARTMODULE.get('dev_monitor',0) == 1:\n        rets = i2c_getPid(\"dev_monitor.py\")  #\n        for ret in rets:\n            cmd = \"kill \"+ ret\n            os.system(cmd)\n        return True\n\ndef stopSlotmonitor():\n    u'''disable slot timer service'''\n    if STARTMODULE.get('slot_monitor',0) == 1:\n        rets = i2c_getPid(\"slot_monitor.py\")  #\n        for ret in rets:\n            cmd = \"kill \"+ ret\n            os.system(cmd)\n        return True\n\ndef removeDev(bus, loc):\n    cmd = \"echo  0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device\" % (loc, bus)\n    devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n    if os.path.exists(devpath):\n        log_os_system(cmd)\n        \ndef addDev(name, bus, loc):\n    if name == \"lm75\":\n        time.sleep(0.1)\n    pdevpath = \"/sys/bus/i2c/devices/i2c-%d/\" % (bus)\n    for i in range(1, 100):#wait for mother-bus generation\uff0cmaximum wait time is 10s\n        if os.path.exists(pdevpath) == True: \n            break\n        time.sleep(0.1)\n        if i % 10 == 0:\n            click.echo(\"%%DEVICE_I2C-INIT: %s not found, wait 0.1 second ! i %d \" % (pdevpath,i))\n            \n    cmd = \"echo  %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device\" % (name, loc, bus)\n    devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n    if os.path.exists(devpath) == False:\n        os.system(cmd)\n\ndef removedevs():\n    devs = GLOBALCONFIG[\"DEVS\"]\n    for index in range(len(devs)-1, -1, -1 ):\n        removeDev(devs[index][\"bus\"] , devs[index][\"loc\"])\n        \ndef adddevs():\n    devs = GLOBALCONFIG[\"DEVS\"]\n    for dev in range(0, devs.__len__()):\n        addDev(devs[dev][\"name\"], devs[dev][\"bus\"] , devs[dev][\"loc\"])\n\ndef checksignaldriver(name):\n    modisexistcmd = \"lsmod | grep %s | wc -l\" % name\n    status, output = log_os_system(modisexistcmd)\n    #System execution error\n    if status: \n        return False\n    if output.isdigit() and int(output) > 0:\n        return True\n    else:\n        return False\n\ndef adddriver(name, delay):\n    cmd = \"modprobe %s\" % name\n    if delay != 0:\n        time.sleep(delay)\n    if checksignaldriver(name) != True:\n        log_os_system(cmd)\n\ndef removedriver(name, delay):\n    realname = name.lstrip().split(\" \")[0];\n    cmd = \"rmmod -f %s\" % realname\n    if checksignaldriver(realname):\n        log_os_system(cmd)\n\ndef removedrivers():\n    u'''remove all drivers'''\n    if GLOBALCONFIG is None:\n        click.echo(\"%%DEVICE_I2C-INIT: load global config failed.\")\n        return\n    drivers = GLOBALCONFIG.get(\"DRIVERLISTS\", None)\n    if drivers is None:\n        click.echo(\"%%DEVICE_I2C-INIT: load driver list failed.\")\n        return \n    for index in range(len(drivers)-1, -1, -1 ):\n        delay = 0\n        name = \"\"\n        if type(drivers[index]) == dict and \"delay\" in drivers[index]:\n            name = drivers[index].get(\"name\")\n            delay = drivers[index][\"delay\"]\n        else:\n            name = drivers[index]\n        removedriver(name, delay)\n\ndef adddrivers():\n    u'''add drivers'''\n    if GLOBALCONFIG is None:\n        click.echo(\"%%DEVICE_I2C-INIT: load global config failed.\")\n        return\n    drivers = GLOBALCONFIG.get(\"DRIVERLISTS\", None)\n    if drivers is None:\n        click.echo(\"%%DEVICE_I2C-INIT: load driver list failed.\")\n        return \n    for index in range(0 ,len(drivers)):\n        delay = 0\n        name = \"\"\n        if type(drivers[index]) == dict and \"delay\" in drivers[index]:\n            name = drivers[index].get(\"name\")\n            delay = drivers[index][\"delay\"]\n        else:\n            name = drivers[index]\n        adddriver(name, delay)\n\ndef otherinit():\n    for index in GLOBALINITPARAM:\n        write_sysfs_value(index[\"loc\"], index[\"value\"])\n\n    for index in GLOBALINITCOMMAND:\n        log_os_system(index)\n    \ndef unload_driver():\n    u'''remove devices and drivers'''\n    stopDevmonitor() # disable removable device driver monitors\n    stopFanctrol()  # disable fan-control service\n    removedevs()    # remove other devices\n    removedrivers() # remove drivers\n\ndef reload_driver():\n    u'''reload devices and drivers'''\n    removedevs()    # remove other devices\n    removedrivers() # remove drivers\n    time.sleep(1)\n    adddrivers()\n    adddevs()\n\n\ndef i2c_check(bus,retrytime = 6):\n    try:\n        i2cpath = \"/sys/bus/i2c/devices/\" + bus\n        while retrytime and not os.path.exists(i2cpath):\n            click.echo(\"%%DEVICE_I2C-HA: i2c bus abnormal, last bus %s is not exist.\" % i2cpath)\n            reload_driver()\n            retrytime -= 1\n            time.sleep(1)\n    except Exception as e:\n        click.echo(\"%%DEVICE_I2C-HA: %s\" % str(e))\n    return \n\ndef MacLedSet(data):\n    '''write pci register'''\n    pcibus = MAC_LED_RESET.get(\"pcibus\")\n    slot = MAC_LED_RESET.get(\"slot\")\n    fn = MAC_LED_RESET.get(\"fn\")\n    bar = MAC_LED_RESET.get(\"bar\")\n    offset = MAC_LED_RESET.get(\"offset\")\n    val = MAC_LED_RESET.get(data, None)\n    if val is None:\n        click.echo(\"%%DEVICE_I2C-INIT: MacLedSet wrong input\")\n        return\n    rjpciwr(pcibus, slot, fn, bar, offset, val)\n\ndef load_driver():\n    u'''load devices and drivers'''\n    adddrivers()\n    adddevs()\n    if STARTMODULE.get(\"i2ccheck\",0) == 1: #i2c HA\n        busend = i2ccheck_params.get(\"busend\")\n        retrytime = i2ccheck_params.get(\"retrytime\")\n        i2c_check(busend,retrytime)\n    startFanctrol() # enable fan\n    starthal_fanctrl() # enable fan control\n    starthal_ledctrl() # enable LED control\n    if STARTMODULE['avscontrol'] == 1:\n        startAvscontrol() # avs voltage-adjustment\n    startDevmonitor() # enable removable device driver monitors\n    startSlotmonitor() # slot insertion and removal initialization monitor\n    otherinit();    # other initialization, QSFP initialization\n    if STARTMODULE.get(\"macledreset\",0) == 1:\n        MacLedSet(\"reset\")\n    \n@click.group(cls=AliasedGroup, context_settings=CONTEXT_SETTINGS)\ndef main():\n    '''device operator'''\n    pass\n\n\n@main.command()\ndef start():\n    '''load device '''\n    if check_driver():\n        unload_driver()\n    load_driver()\n\n@main.command()\ndef stop():\n    '''stop device '''\n    unload_driver()\n\n@main.command()\ndef restart():\n    '''restart device'''\n    unload_driver()\n    load_driver()\n\nif __name__ == '__main__':\n    u'''device_i2c operation'''\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py": {"changes": [{"diff": "\n                     self.fanSpeedSetMax()  # fan full speed\n                     self.critnum += 1 # anti-shake\n                     if self.critnum >= MONITOR_CONST.CRITICAL_NUM:\n-                       os.system(\"reboot\")\n+                        subprocess.call([\"reboot\"])\n                     fanwarningdebuglog(DEBUG_FANCONTROL,\"crit\u6b21\u6570:%d\" % self.critnum)\n                 else:\n                     self.critn", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py", "badparts": ["                       os.system(\"reboot\")"], "goodparts": ["                        subprocess.call([\"reboot\"])"]}]}, "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py": {"changes": [{"diff": "\n import sys\n import os\n import re\n-import subprocess\n import syslog\n import time\n import binascii\n", "add": 0, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["import subprocess"], "goodparts": []}, {"diff": "\n \n def getSdkReg(reg):\n     try:\n-        cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg\n-        ret, result = rj_os_system(cmd)\n+        cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]\n+        ret, result = getstatusoutput_noshell(cmd)\n         result_t = result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n         if ret != 0 or \"Error:\" in result_t:\n             return False, result\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["        cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg", "        ret, result = rj_os_system(cmd)"], "goodparts": ["        cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]", "        ret, result = getstatusoutput_noshell(cmd)"]}, {"diff": "\n     result = {}\n     #waitForDocker()\n     # exec twice, get the second result\n-    rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n-    ret, log = rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n+    getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n+    ret, log = getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n     if ret:\n         return False, result\n     else:\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")", "    ret, log = rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")"], "goodparts": ["    getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])", "    ret, log = getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])"]}, {"diff": "\n \n def restartDockerService(force=False):\n     container_name = [\"database\",\"snmp\",\"syncd\",\"swss\",\"dhcp_relay\",\"radv\",\"teamd\",\"pmon\"]\n-    ret, status = rj_os_system(\"docker ps\")\n+    ret, status = getstatusoutput_noshell([\"docker\", \"ps\"])\n     if ret == 0 :\n         for tmpname in container_name:\n             if (tmpname not in status):\n                 if (force == True):\n-                    rj_os_system(\"docker restart %s\"%tmpname)\n+                    getstatusoutput_noshell([\"docker\", \"restart\", tmpname])\n                 else:\n-                    rj_os_system(\"systemctl restart %s\"%tmpname)\n+                    getstatusoutput_noshell([\"systemctl\", \"restart\", tmpname])\n \n \n def waitForDhcp(timeout):\n     time_cnt = 0\n     while True:\n         try:\n-            ret, status = rj_os_system(\"systemctl status dhcp_relay.service\")\n+            ret, status = getstatusoutput_noshell([\"systemctl\", \"status\", \"dhcp_relay.service\"])\n             if (ret == 0 and \"running\" in status)  or \"SUCCESS\" in status:\n                 break\n             else:\n", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    ret, status = rj_os_system(\"docker ps\")", "                    rj_os_system(\"docker restart %s\"%tmpname)", "                    rj_os_system(\"systemctl restart %s\"%tmpname)", "            ret, status = rj_os_system(\"systemctl status dhcp_relay.service\")"], "goodparts": ["    ret, status = getstatusoutput_noshell([\"docker\", \"ps\"])", "                    getstatusoutput_noshell([\"docker\", \"restart\", tmpname])", "                    getstatusoutput_noshell([\"systemctl\", \"restart\", tmpname])", "            ret, status = getstatusoutput_noshell([\"systemctl\", \"status\", \"dhcp_relay.service\"])"]}, {"diff": "\n     rulefile = \"/etc/udev/rules.d/70-persistent-net.rules\"\n     if isValidMac(mac) == False:\n         return False, \"MAC invaild\"\n-    cmd = \"ethtool -e %s | grep 0x0010 | awk '{print \\\"0x\\\"$13$12$15$14}'\" % eth\n-    ret, log = rj_os_system(cmd)\n+    cmd1 = [\"ethtool\", \"-e\", eth] \n+    cmd2 = [\"grep\", \"0x0010\"]\n+    cmd3 = [\"awk\", '{print \\\"0x\\\"$13$12$15$14}']\n+    ret, log = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)\n     log_debug(log)\n     magic = \"\"\n     if ret == 0 and len(log):\n", "add": 4, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    cmd = \"ethtool -e %s | grep 0x0010 | awk '{print \\\"0x\\\"$13$12$15$14}'\" % eth", "    ret, log = rj_os_system(cmd)"], "goodparts": ["    cmd1 = [\"ethtool\", \"-e\", eth] ", "    cmd2 = [\"grep\", \"0x0010\"]", "    cmd3 = [\"awk\", '{print \\\"0x\\\"$13$12$15$14}']", "    ret, log = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)"]}, {"diff": "\n     macs = mac.upper().split(\":\")\n \n     # chage ETH0 to value after setmac\n-    ifconfigcmd = \"ifconfig eth0 hw ether %s\" % mac\n-    log_debug(ifconfigcmd)\n-    ret, status = rj_os_system(ifconfigcmd)\n+    ifconfigcmd = [\"ifconfig\", \"eth0\", \"hw\", \"ether\", mac]\n+    log_debug(' '.join(ifconfigcmd))\n+    ret, status = getstatusoutput_noshell(ifconfigcmd)\n     if ret:\n         raise SETMACException(\"software set  Internet cardMAC error\")\n     index = 0\n     for item in macs:\n-        cmd = \"ethtool -E %s magic %s offset %d value 0x%s\" % (\n-            eth, magic, index, item)\n+        cmd = [\"ethtool\", \"-E\", eht, \"magic\", magic, \"offset\", str(index), \"value\", \"0x\"+item]\n         log_debug(cmd)\n         index += 1\n-        ret, log = rj_os_system(cmd)\n+        ret, log = getstatusoutput_noshell(cmd)\n         if ret != 0:\n             raise SETMACException(\" set hardware Internet card MAC error\")\n     # get value after setting \n-    cmd_t = \"ethtool -e eth0 offset 0 length 6\"\n-    ret, log = rj_os_system(cmd_t)\n+    cmd_t = [\"ethtool\", \"-e\", \"eth0\", \"offset\", \"0\", \"length\", \"6\"]\n+    ret, log = getstatusoutput_noshell(cmd_t)\n     m = re.split(':', log)[-1].strip().upper()\n     mac_result = m.upper().split(\" \")\n \n", "add": 7, "remove": 8, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    ifconfigcmd = \"ifconfig eth0 hw ether %s\" % mac", "    log_debug(ifconfigcmd)", "    ret, status = rj_os_system(ifconfigcmd)", "        cmd = \"ethtool -E %s magic %s offset %d value 0x%s\" % (", "            eth, magic, index, item)", "        ret, log = rj_os_system(cmd)", "    cmd_t = \"ethtool -e eth0 offset 0 length 6\"", "    ret, log = rj_os_system(cmd_t)"], "goodparts": ["    ifconfigcmd = [\"ifconfig\", \"eth0\", \"hw\", \"ether\", mac]", "    log_debug(' '.join(ifconfigcmd))", "    ret, status = getstatusoutput_noshell(ifconfigcmd)", "        cmd = [\"ethtool\", \"-E\", eht, \"magic\", magic, \"offset\", str(index), \"value\", \"0x\"+item]", "        ret, log = getstatusoutput_noshell(cmd)", "    cmd_t = [\"ethtool\", \"-e\", \"eth0\", \"offset\", \"0\", \"length\", \"6\"]", "    ret, log = getstatusoutput_noshell(cmd_t)"]}, {"diff": "\n \n \n def rji2cget(bus, devno, address):\n-    command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)\n+    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address)]\n     retrytime = 6\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n         time.sleep(0.1)\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)", "        ret, ret_t = rj_os_system(command_line)"], "goodparts": ["    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address)]", "        ret, ret_t = getstatusoutput_noshell(command_line)"]}, {"diff": "\n \n \n def rji2cset(bus, devno, address, byte):\n-    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (\n-        bus, devno, address, byte)\n+    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%02x\"%str(byte)]\n     retrytime = 6\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n     return False, ret_t\n", "add": 2, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (", "        bus, devno, address, byte)", "        ret, ret_t = rj_os_system(command_line)"], "goodparts": ["    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%02x\"%str(byte)]", "        ret, ret_t = getstatusoutput_noshell(command_line)"]}, {"diff": "\n     data.close()\n \n def rjsysset(location, value):\n-    command_line = \"echo 0x%02x > %s\" % (value, location)\n     retrytime = 6\n-    ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n-        if ret == 0:\n-            return True, ret_t\n-    return False, ret_t\n+        try:\n+            with open(location, 'w') as f:\n+                f.write('0x%02x\\n'%value)\n+        except (IOError, FileNotFoundError) as e:\n+            return False, str(e)\n+    return True, ''\n \n \n def rji2cgetWord(bus, devno, address):\n-    command_line = \"i2cget -f -y %d 0x%02x 0x%02x w\" % (bus, devno, address)\n+    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"w\"]\n     retrytime = 3\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n     return False, ret_t\n \n \n def rji2csetWord(bus, devno, address, byte):\n-    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%x w\" % (\n-        bus, devno, address, byte)\n-    rj_os_system(command_line)\n+    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%x\"%str(byte), \"w\"]\n+    getstatusoutput_noshell(command_line)\n \n \n def fan_setmac():\n", "add": 10, "remove": 11, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    command_line = \"echo 0x%02x > %s\" % (value, location)", "    ret_t = \"\"", "        ret, ret_t = rj_os_system(command_line)", "        if ret == 0:", "            return True, ret_t", "    return False, ret_t", "    command_line = \"i2cget -f -y %d 0x%02x 0x%02x w\" % (bus, devno, address)", "        ret, ret_t = rj_os_system(command_line)", "    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%x w\" % (", "        bus, devno, address, byte)", "    rj_os_system(command_line)"], "goodparts": ["        try:", "            with open(location, 'w') as f:", "                f.write('0x%02x\\n'%value)", "        except (IOError, FileNotFoundError) as e:", "            return False, str(e)", "    return True, ''", "    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"w\"]", "        ret, ret_t = getstatusoutput_noshell(command_line)", "    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%x\"%str(byte), \"w\"]", "    getstatusoutput_noshell(command_line)"]}, {"diff": "\n     elif dealtype == \"io\":\n         io_wr(E2_PROTECT[\"io_addr\"], E2_PROTECT[\"close\"])\n     # deal last drivers\n-    os.system(\"rmmod at24 \")\n-    os.system(\"modprobe at24 \")\n-    os.system(\"rm -f /var/cache/sonic/decode-syseeprom/syseeprom_cache\")\n+    getstatusoutput_noshell([\"rmmod\", \"at24\"])\n+    getstatusoutput_noshell([\"modprobe\", \"at24\"])\n+    getstatusoutput_noshell([\"rm\", \"-f\", \"/var/cache/sonic/decode-syseeprom/syseeprom_cache\"])\n \n \n def get_local_eth0_mac():\n-    cmd = \"ifconfig eth0 |grep HWaddr\"\n-    print(rj_os_system(cmd))\n+    cmd1 = [\"ifconfig\", \"eth0\"]\n+    cmd2 = [\"grep\", \"HWaddr\"]\n+    print(getstatusoutput_noshell_pipe(cmd1, cmd2))\n \n def getonieversion():\n     if not os.path.isfile('/host/machine.conf'):\n", "add": 6, "remove": 5, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    os.system(\"rmmod at24 \")", "    os.system(\"modprobe at24 \")", "    os.system(\"rm -f /var/cache/sonic/decode-syseeprom/syseeprom_cache\")", "    cmd = \"ifconfig eth0 |grep HWaddr\"", "    print(rj_os_system(cmd))"], "goodparts": ["    getstatusoutput_noshell([\"rmmod\", \"at24\"])", "    getstatusoutput_noshell([\"modprobe\", \"at24\"])", "    getstatusoutput_noshell([\"rm\", \"-f\", \"/var/cache/sonic/decode-syseeprom/syseeprom_cache\"])", "    cmd1 = [\"ifconfig\", \"eth0\"]", "    cmd2 = [\"grep\", \"HWaddr\"]", "    print(getstatusoutput_noshell_pipe(cmd1, cmd2))"]}, {"diff": "\n \n def ipmi_set_mac(mac):\n     macs = mac.split(\":\")\n-    cmdinit = \"ipmitool raw 0x0c 0x01 0x01 0xc2 0x00\"\n-    cmdset = \"ipmitool raw 0x0c 0x01 0x01 0x05\"\n+    cmdinit = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0xc2\", \"0x00\"]\n+    cmdset = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0x05\"]\n     for ind in range(len(macs)):\n-        cmdset += \" 0x%02x\" % int(macs[ind], 16)\n-    rj_os_system(cmdinit)\n-    ret, status = rj_os_system(cmdset)\n+        cmdset.append(\"0x%02x\" % int(macs[ind], 16))\n+    getstatusoutput_noshell(cmdinit)\n+    ret, status = getstatusoutput_noshell(cmdset)\n     if ret:\n         RJPRINTERR(\"\\n\\n%s\\n\\n\" % status)\n         return False\n", "add": 5, "remove": 5, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    cmdinit = \"ipmitool raw 0x0c 0x01 0x01 0xc2 0x00\"", "    cmdset = \"ipmitool raw 0x0c 0x01 0x01 0x05\"", "        cmdset += \" 0x%02x\" % int(macs[ind], 16)", "    rj_os_system(cmdinit)", "    ret, status = rj_os_system(cmdset)"], "goodparts": ["    cmdinit = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0xc2\", \"0x00\"]", "    cmdset = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0x05\"]", "        cmdset.append(\"0x%02x\" % int(macs[ind], 16))", "    getstatusoutput_noshell(cmdinit)", "    ret, status = getstatusoutput_noshell(cmdset)"]}, {"diff": "\n     log_info(\"disable LLDP\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n-    rj_os_system(\"systemctl stop lldp.service\")\n+    getstatusoutput_noshell([\"systemctl\", \"stop\", \"lldp.service\"])\n     log_info(\"disable lldp service\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n-    rj_os_system(\"systemctl stop bgp.service\")\n+    getstatusoutput_noshell([\"systemctl\", \"stop\", \"bgp.service\"])\n     log_info(\"disable bgp service\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    rj_os_system(\"systemctl stop lldp.service\")", "    rj_os_system(\"systemctl stop bgp.service\")"], "goodparts": ["    getstatusoutput_noshell([\"systemctl\", \"stop\", \"lldp.service\"])", "    getstatusoutput_noshell([\"systemctl\", \"stop\", \"bgp.service\"])"]}, {"diff": "\n     with open(file_name, \"w\") as f:\n         f.write(file_data)\n     print(\"change SDK memory to 256, reboot required\")\n-    rj_os_system(\"sync\")\n-    rj_os_system(\"reboot\")\n+    getstatusoutput_noshell([\"sync\"])\n+    getstatusoutput_noshell([\"reboot\"])\n \n ##########################################################################\n # receives a character setting\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    rj_os_system(\"sync\")", "    rj_os_system(\"reboot\")"], "goodparts": ["    getstatusoutput_noshell([\"sync\"])", "    getstatusoutput_noshell([\"reboot\"])"]}, {"diff": "\n             return item.get('value',None)\n     return None\n \n-# ====================================\n-# execute shell command\n-# ====================================\n-def rj_os_system(cmd):\n-    status, output = subprocess.getstatusoutput(cmd)\n-    return status, output\n \n ###########################################\n # get memory slot and number via DMI command\n ###########################################\n def getsysmeminfo():\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \"|grep -P -A5 \\\"Memory\\s+Device\\\"|grep Size|grep -v Range\"\n+    cmd1 = [log[0].rstrip('\\n')]\n+    cmd2 = [\"grep\", \"-P\", \"-A5\", \"Memory\\s+Device\"]\n+    cmd3 = [\"grep\", \"Size\"]\n+    cmd4 = [\"grep\", \"-v\", \"Range\"]\n     # get total number first\n     result = []\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3, cmd4)\n     if ret1 == 0 and len(log1):\n         log1 = log1.lstrip()\n         arr = log1.split(\"\\n\")\n", "add": 6, "remove": 9, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["def rj_os_system(cmd):", "    status, output = subprocess.getstatusoutput(cmd)", "    return status, output", "    ret, log = rj_os_system(\"which dmidecode \")", "    cmd = log + \"|grep -P -A5 \\\"Memory\\s+Device\\\"|grep Size|grep -v Range\"", "    ret1, log1 = rj_os_system(cmd)"], "goodparts": ["    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])", "    cmd1 = [log[0].rstrip('\\n')]", "    cmd2 = [\"grep\", \"-P\", \"-A5\", \"Memory\\s+Device\"]", "    cmd3 = [\"grep\", \"Size\"]", "    cmd4 = [\"grep\", \"-v\", \"Range\"]", "    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3, cmd4)"]}, {"diff": "\n # return various arrays\n ###########################################\n def getsysmeminfo_detail():\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \" -t 17 | grep  -A21 \\\"Memory Device\\\"\"  # 17\n+    cmd1 = [log[0].rstrip('\\n')] + [\"-t\", \"17\"]\n+    cmd2 = [\"grep\", \"-A21\", \"Memory Device\"]  # 17\n     # get total number\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)\n     if ret1 != 0 or len(log1) <= 0:\n-        return False, \"command execution error[%s]\" % cmd\n+        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)\n     result_t = log1.split(\"--\")\n     mem_rets = []\n     for item in result_t:\n", "add": 5, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    ret, log = rj_os_system(\"which dmidecode \")", "    cmd = log + \" -t 17 | grep  -A21 \\\"Memory Device\\\"\"  # 17", "    ret1, log1 = rj_os_system(cmd)", "        return False, \"command execution error[%s]\" % cmd"], "goodparts": ["    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])", "    cmd1 = [log[0].rstrip('\\n')] + [\"-t\", \"17\"]", "    cmd2 = [\"grep\", \"-A21\", \"Memory Device\"]  # 17", "    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)", "        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)"]}, {"diff": "\n # get BIOS info via DMI command\n ###########################################\n def getDmiSysByType(type_t):\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \" -t %s\" % type_t\n+    cmd = [log[0].rstrip('\\n')] + [\"-t\", str(type_t)]\n     # get total number\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell(cmd)\n     if ret1 != 0 or len(log1) <= 0:\n         return False, \"command execution error[%s]\" % cmd\n     its = log1.replace(\"\\t\", \"\").strip().split(\"\\n\")\n", "add": 3, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    ret, log = rj_os_system(\"which dmidecode \")", "    cmd = log + \" -t %s\" % type_t", "    ret1, log1 = rj_os_system(cmd)"], "goodparts": ["    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])", "    cmd = [log[0].rstrip('\\n')] + [\"-t\", str(type_t)]", "    ret1, log1 = getstatusoutput_noshell(cmd)"]}, {"diff": "\n         return False, \"Err\"\n \n def get_cpu_info():\n-    cmd = \"cat /proc/cpuinfo |grep processor -A18\"  # 17\n+    cmd1 = [\"cat\", \"/proc/cpuinfo\"]\n+    cmd2 = [\"grep\", \"processor\", \"-A18\"]  # 17\n \n-    ret, log1 = rj_os_system(cmd)\n+    ret, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)\n     if ret != 0 or len(log1) <= 0:\n-        return False, \"command execution error[%s]\" % cmd\n+        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)\n     result_t = log1.split(\"--\")\n     mem_rets = []\n     for item in result_t:\n", "add": 4, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    cmd = \"cat /proc/cpuinfo |grep processor -A18\"  # 17", "    ret, log1 = rj_os_system(cmd)", "        return False, \"command execution error[%s]\" % cmd"], "goodparts": ["    cmd1 = [\"cat\", \"/proc/cpuinfo\"]", "    cmd2 = [\"grep\", \"processor\", \"-A18\"]  # 17", "    ret, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)", "        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)"]}]}}, "msg": "[ruijie] Replace os.system and remove subprocess with shell=True (#12107)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\nDependency: [https://github.com/sonic-net/sonic-buildimage/pull/12065](https://github.com/sonic-net/sonic-buildimage/pull/12065)\r\n#### Why I did it\r\n1. `getstatusoutput` is used without a static string and it uses `shell=True`\r\n2. `subprocess()` - when using with `shell=True` is dangerous. Using subprocess function without a static string can lead to command injection.\r\n3. `os` - not secure against maliciously constructed input and dangerous if used to evaluate dynamic content.\r\n#### How I did it\r\n1. use `getstatusoutput` without shell=True\r\n2. `subprocess()` - use `shell=False` instead. use an array string. Ref: [https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation](https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation)\r\n3. `os` - use with `subprocess`"}, "51a1eb112b8a3e00b4c5857afb470bb0e4d24433": {"url": "https://api.github.com/repos/SovereignCloudStack/sonic-buildimage/commits/51a1eb112b8a3e00b4c5857afb470bb0e4d24433", "html_url": "https://github.com/SovereignCloudStack/sonic-buildimage/commit/51a1eb112b8a3e00b4c5857afb470bb0e4d24433", "sha": "51a1eb112b8a3e00b4c5857afb470bb0e4d24433", "keyword": "command injection attack", "diff": "diff --git a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py\nindex 4b081f4e3..35c045dad 100644\n--- a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py\n+++ b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py\n@@ -24,7 +24,6 @@\n RESET_REGISTER = \"0x112\"\n HOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/previous-reboot-cause.txt\"\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n STATUS_LED_PATH = \"/sys/devices/platform/e1031.smc/master_led\"\n \n \ndiff --git a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py\nindex 08e8fc414..7d3b37e36 100644\n--- a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py\n+++ b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py\n@@ -1,8 +1,8 @@\n import os\r\n+import ast\r\n import imp\r\n import yaml\r\n import subprocess\r\n-\r\n from sonic_py_common import device_info\r\n \r\n \r\n@@ -24,7 +24,7 @@ class Common:\n \r\n     SET_METHOD_IPMI = 'ipmitool'\r\n     NULL_VAL = 'N/A'\r\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\r\n+    HOST_CHK_CMD = [\"docker\"]\r\n     REF_KEY = '$ref:'\r\n \r\n     def __init__(self, conf=None):\r\n@@ -46,8 +46,7 @@ def run_command(self, command):\n         status = False\r\n         output = \"\"\r\n         try:\r\n-            p = subprocess.Popen(\r\n-                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n+            p = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n             raw_data, err = p.communicate()\r\n             if p.returncode == 0:\r\n                 status, output = True, raw_data.strip()\r\n@@ -67,7 +66,7 @@ def _clean_input(self, input, config):\n             cleaned_input = input_translator.get(input)\r\n \r\n         elif type(input_translator) is str:\r\n-            cleaned_input = eval(input_translator.format(input))\r\n+            cleaned_input = ast.literal_eval(input_translator.format(input))\r\n \r\n         return cleaned_input\r\n \r\n@@ -77,19 +76,12 @@ def _clean_output(self, index, output, config):\n         if type(output_translator) is dict:\r\n             output = output_translator.get(output)\r\n         elif type(output_translator) is str:\r\n-            output = eval(output_translator.format(output))\r\n+            output = ast.literal_eval(output_translator.format(output))\r\n         elif type(output_translator) is list:\r\n-            output = eval(output_translator[index].format(output))\r\n+            output = ast.literal_eval(output_translator[index].format(output))\r\n \r\n         return output\r\n \r\n-    def _ipmi_get(self, index, config):\r\n-        argument = config.get('argument')\r\n-        cmd = config['command'].format(\r\n-            config['argument'][index]) if argument else config['command']\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n-\r\n     def _sysfs_read(self, index, config):\r\n         sysfs_path = config.get('sysfs_path')\r\n         argument = config.get('argument', '')\r\n@@ -132,10 +124,6 @@ def _sysfs_write(self, index, config, input):\n             return False, output\r\n         return True, output\r\n \r\n-    def _ipmi_set(self, index, config, input):\r\n-        arg = config['argument'][index].format(input)\r\n-        return self.run_command(config['command'].format(arg))\r\n-\r\n     def _hex_ver_decode(self, hver, num_of_bits, num_of_points):\r\n         ver_list = []\r\n         c_bit = 0\r\n@@ -159,14 +147,16 @@ def _get_class(self, config):\n         return class_\r\n \r\n     def get_reg(self, path, reg_addr):\r\n-        cmd = \"echo {1} > {0}; cat {0}\".format(path, reg_addr)\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n+        with open(path, 'w') as file:\r\n+            file.write(reg_addr + '\\n')\r\n+        with open(path, 'r') as file:\r\n+            output = file.readline().strip()\r\n+        return output\r\n \r\n     def set_reg(self, path, reg_addr, value):\r\n-        cmd = \"echo {0} {1} > {2}\".format(reg_addr, value, path)\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n+        with open(path, 'w') as file:\r\n+            file.write(\"{0} {1}\\n\".format(reg_addr, value))\r\n+        return None\r\n \r\n     def read_txt_file(self, path):\r\n         try:\r\n@@ -195,7 +185,11 @@ def write_txt_file(self, file_path, value):\n         return True\r\n \r\n     def is_host(self):\r\n-        return os.system(self.HOST_CHK_CMD) == 0\r\n+        try:\r\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\r\n+        except FileNotFoundError:\r\n+            return False\r\n+        return True\r\n \r\n     def load_json_file(self, path):\r\n         \"\"\"\r\n@@ -221,87 +215,6 @@ def get_config_path(self, config_name):\n         \"\"\"\r\n         return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\r\n \r\n-    def get_output(self, index, config, default):\r\n-        \"\"\"\r\n-        Retrieves the output for each function base on config\r\n-\r\n-        Args:\r\n-            index: An integer containing the index of device.\r\n-            config: A dict object containing the configuration of specified function.\r\n-            default: A string containing the default output of specified function.\r\n-\r\n-        Returns:\r\n-            A string containing the output of specified function in config\r\n-        \"\"\"\r\n-        output_source = config.get('output_source')\r\n-\r\n-        if output_source == self.OUTPUT_SOURCE_IPMI:\r\n-            output = self._ipmi_get(index, config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VALUE:\r\n-            output = config[\"value\"]\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_CLASS:\r\n-            output = self._get_class(config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_LIST:\r\n-            output = config[\"value_list\"][index]\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_SYSFS:\r\n-            output = self._sysfs_read(index, config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_FUNC:\r\n-            func_conf = self._main_conf[config['function'][index]]\r\n-            output = self.get_output(index, func_conf, default)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\r\n-            path = config.get('path')\r\n-            output = self.read_txt_file(path)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\r\n-            path = config.get('path')\r\n-            hex_ver = self.read_txt_file(path)\r\n-            output = self._hex_ver_decode(\r\n-                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\r\n-            path = config.get('path')\r\n-            addr = config.get('reg_addr')\r\n-            hex_ver = self.get_reg(path, addr)\r\n-            output = self._hex_ver_decode(\r\n-                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n-\r\n-        else:\r\n-            output = default\r\n-\r\n-        return self._clean_output(index, output, config) or default\r\n-\r\n-    def set_output(self, index, input, config):\r\n-        \"\"\"\r\n-        Sets the output of specified function on config\r\n-\r\n-        Args:\r\n-            config: A dict object containing the configuration of specified function.\r\n-            index: An integer containing the index of device.\r\n-            input: A string containing the input of specified function.\r\n-\r\n-        Returns:\r\n-            bool: True if set function is successfully, False if not\r\n-        \"\"\"\r\n-        cleaned_input = self._clean_input(input, config)\r\n-        if not cleaned_input:\r\n-            return False\r\n-\r\n-        set_method = config.get('set_method')\r\n-        if set_method == self.SET_METHOD_IPMI:\r\n-            output = self._ipmi_set(index, config, cleaned_input)[0]\r\n-        elif set_method == self.OUTPUT_SOURCE_SYSFS:\r\n-            output = self._sysfs_write(index, config, cleaned_input)[0]\r\n-        else:\r\n-            output = False\r\n-\r\n-        return output\r\n-\r\n     def get_event(self, timeout, config, sfp_list):\r\n         \"\"\"\r\n         Returns a nested dictionary containing all devices which have\r\ndiff --git a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py\nindex 56fae3591..6e33e3340 100644\n--- a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py\n+++ b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py\n@@ -10,7 +10,6 @@\n try:\n     import os.path\n     import shutil\n-    import shlex\n     import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n except ImportError as e:\n@@ -39,8 +38,7 @@ def __init__(self, component_index):\n     def __run_command(self, command):\n         # Run bash command and print output to stdout\n         try:\n-            process = subprocess.Popen(\n-                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n+            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n             while True:\n                 output = process.stdout.readline()\n                 if output == '' and process.poll() is not None:\n@@ -63,12 +61,10 @@ def __get_bios_version(self):\n \n     def get_register_value(self, register):\n         # Retrieves the cpld register value\n-        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n-        p = subprocess.Popen(\n-            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-        raw_data, err = p.communicate()\n-        if err is not '':\n-            return None\n+        with open(GETREG_PATH, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(GETREG_PATH, 'r') as file:\n+            raw_data = file.readline()\n         return raw_data.strip()\n \n     def __get_cpld_version(self):\n@@ -76,11 +72,11 @@ def __get_cpld_version(self):\n         cpld_version = dict()\n         with open(SMC_CPLD_PATH, 'r') as fd:\n             smc_cpld_version = fd.read()\n-        smc_cpld_version = 'None' if smc_cpld_version is 'None' else \"{}.{}\".format(\n+        smc_cpld_version = 'None' if smc_cpld_version == 'None' else \"{}.{}\".format(\n             int(smc_cpld_version[2], 16), int(smc_cpld_version[3], 16))\n \n         mmc_cpld_version = self.get_register_value(MMC_CPLD_ADDR)\n-        mmc_cpld_version = 'None' if mmc_cpld_version is 'None' else \"{}.{}\".format(\n+        mmc_cpld_version = 'None' if mmc_cpld_version == 'None' else \"{}.{}\".format(\n             int(mmc_cpld_version[2], 16), int(mmc_cpld_version[3], 16))\n \n         cpld_version[\"SMC_CPLD\"] = smc_cpld_version\n@@ -159,7 +155,7 @@ def install_firmware(self, image_path):\n             ext = \".vme\" if ext == \"\" else ext\n             new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n             shutil.copy(image_path, new_image_path)\n-            install_command = \"ispvm %s\" % new_image_path\n+            install_command = [\"ispvm\", str(new_image_path)]\n         # elif self.name == \"BIOS\":\n         #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n         return self.__run_command(install_command)\ndiff --git a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py\nindex 75307d291..144fdae21 100644\n--- a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py\n+++ b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py\n@@ -73,6 +73,5 @@ def execute(self, thermal_info_dict):\n         thermal_overload_position = Common().read_txt_file(\r\n             thermal_overload_position_path)\r\n \r\n-        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\r\n-            thermal_overload_position)\r\n+        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', thermal_overload_position]\r\n         Common().run_command(cmd)\r\ndiff --git a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py\nindex 2e379f8c2..28e113fb7 100644\n--- a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py\n+++ b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py\n@@ -6,7 +6,7 @@\n \n \n class ThermalManager(ThermalManagerBase):\n-    FSC_ALGORITHM_CMD = ' supervisorctl {} fancontrol'\n+    FSC_ALGORITHM_CMD = ['supervisorctl', '', 'fancontrol']\n \n     @classmethod\n     def start_thermal_control_algorithm(cls):\n@@ -43,5 +43,5 @@ def _enable_fancontrol_service(cls, enable):\n         Returns:\n             bool: True if set success, False if fail.\n         \"\"\"\n-        cmd = 'start' if enable else 'stop'\n-        return Common().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n+        cls.FSC_ALGORITHM_CMD[1] = 'start' if enable else 'stop'\n+        return Common().run_command(cls.FSC_ALGORITHM_CMD)\ndiff --git a/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py b/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py\nindex 0c93576e1..13c19841e 100644\n--- a/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py\n+++ b/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py\n@@ -6,8 +6,6 @@\n #\n #############################################################################\n \n-import os.path\n-import subprocess\n \n try:\n     from sonic_psu.psu_base import PsuBase\ndiff --git a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py\nindex 8a9ed1713..2fc2c60fd 100644\n--- a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py\n+++ b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py\n@@ -26,7 +26,6 @@\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n GETREG_PATH = \"/sys/devices/platform/dx010_cpld/getreg\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n STATUS_LED_PATH = \"/sys/devices/platform/leds_dx010/leds/dx010:green:stat/brightness\"\n \n \ndiff --git a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py\nindex 782708025..da735d2ac 100644\n--- a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py\n+++ b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py\n@@ -8,7 +8,6 @@\n \n import os.path\n import shutil\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -52,12 +51,10 @@ def __get_bios_version(self):\n \n     def get_register_value(self, register):\n         # Retrieves the cpld register value\n-        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n-        p = subprocess.Popen(\n-            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-        raw_data, err = p.communicate()\n-        if err is not '':\n-            return None\n+        with open(GETREG_PATH, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(GETREG_PATH, 'r') as file:\n+            raw_data = file.readline()\n         return raw_data.strip()\n \n     def __get_cpld_version(self):\n@@ -146,11 +143,11 @@ def install_firmware(self, image_path):\n             ext = \".vme\" if ext == \"\" else ext\n             new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n             shutil.copy(image_path, new_image_path)\n-            install_command = \"ispvm %s\" % new_image_path\n+            install_command = [\"ispvm\", str(new_image_path)]\n         # elif self.name == \"BIOS\":\n         #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n \n-        return self.__run_command(install_command)\n+        return self._api_helper.run_command(install_command)\n \n \n     def update_firmware(self, image_path):\ndiff --git a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py\nindex 140c62c08..a77d27837 100644\n--- a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py\n+++ b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py\n@@ -5,7 +5,7 @@\n \n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -15,7 +15,11 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -35,7 +39,7 @@ def run_command(self, cmd):\n         result = \"\"\n         try:\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = raw_data.strip()\n@@ -43,13 +47,6 @@ def run_command(self, cmd):\n             status = False\n         return status, result\n \n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n@@ -77,57 +74,9 @@ def write_txt_file(self, file_path, value):\n         return True\n \n     def get_cpld_reg_value(self, getreg_path, register):\n-        cmd = \"echo {1} > {0}; cat {0}\".format(getreg_path, register)\n-        status, result = self.run_command(cmd)\n-        return result if status else None\n+        with open(getreg_path, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(getreg_path, 'r') as file:\n+            result = file.readline()\n+        return result\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(\n-                str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status, result\ndiff --git a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py\nindex 545db861f..fc55445d0 100644\n--- a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py\n+++ b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py\n@@ -73,6 +73,5 @@ def execute(self, thermal_info_dict):\n         thermal_overload_position = APIHelper().read_one_line_file(\n             thermal_overload_position_path)\n \n-        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\n-            thermal_overload_position)\n+        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', str(thermal_overload_position)]\n         APIHelper().run_command(cmd)\ndiff --git a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py\nindex 9f057cf1f..dfd4abc40 100644\n--- a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py\n+++ b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py\n@@ -5,7 +5,7 @@\n from .thermal_infos import *\n \n class ThermalManager(ThermalManagerBase):\n-    FSC_ALGORITHM_CMD = 'service fancontrol {}'\n+    FSC_ALGORITHM_CMD = ['service', 'fancontrol', '']\n \n     @classmethod\n     def start_thermal_control_algorithm(cls):\n@@ -42,5 +42,5 @@ def _enable_fancontrol_service(cls, enable):\n         Returns:\n             bool: True if set success, False if fail.\n         \"\"\"\n-        cmd = 'start' if enable else 'stop'\n-        return APIHelper().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n+        cls.FSC_ALGORITHM_CMD[2] = 'start' if enable else 'stop'\n+        return APIHelper().run_command(cls.FSC_ALGORITHM_CMD)\ndiff --git a/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py b/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py\nindex cc5461ccb..2eb92eb91 100644\n--- a/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py\n+++ b/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py\n@@ -1,10 +1,9 @@\n-import os.path\n-import subprocess\n import sys\n import re\n \n try:\n     from sonic_psu.psu_base import PsuBase\n+    from sonic_py_common.general import getstatusoutput_noshell_pipe\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -13,16 +12,16 @@ class PsuUtil(PsuBase):\n     \"\"\"Platform-specific PSUutil class\"\"\"\n \n     def __init__(self):\n-        self.ipmi_sensor = \"ipmitool sensor\"\n+        self.ipmi_sensor = [\"ipmitool\", \"sensor\"]\n         PsuBase.__init__(self)\n \n-    def run_command(self, command):\n-        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n-        (out, err) = proc.communicate()\n-\n-        if proc.returncode != 0:\n-            sys.exit(proc.returncode)\n-\n+    def run_command(self, cmd1, cmd2):\n+        exitcode, out = getstatusoutput_noshell_pipe(cmd1, cmd2)\n+        i = 0\n+        while i < 2:\n+            if exitcode[i] != 0:\n+                sys.exit(exitcode[i])\n+            i += 1\n         return out\n \n     def find_value(self, grep_string):\n@@ -50,7 +49,8 @@ def get_psu_status(self, index):\n             return False\n \n         grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n-        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n+        grep_cmd = [\"grep\", grep_key]\n+        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)\n         status_byte = self.find_value(grep_string)\n \n         if status_byte is None:\n@@ -74,7 +74,8 @@ def get_psu_presence(self, index):\n             return False\n \n         grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n-        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n+        grep_cmd = [\"grep\", grep_key]\n+        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)\n         status_byte = self.find_value(grep_string)\n \n         if status_byte is None:\ndiff --git a/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py b/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py\nindex ca75ad983..46684aae0 100644\n--- a/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py\n+++ b/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py\n@@ -1,4 +1,3 @@\n-import os.path\n import subprocess\n import sys\n import re\n@@ -13,13 +12,13 @@ class PsuUtil(PsuBase):\n     \"\"\"Platform-specific PSUutil class\"\"\"\n \n     def __init__(self):\n-        self.ipmi_raw = \"docker exec -ti pmon ipmitool raw 0x4 0x2d\"\n+        self.ipmi_raw = [\"docker\", \"exec\", \"-ti\", \"pmon\", \"ipmitool\", \"raw\", \"0x4\", \"0x2d\", \"\"]\n         self.psu1_id = \"0x2f\"\n         self.psu2_id = \"0x39\"\n         PsuBase.__init__(self)\n \n     def run_command(self, command):\n-        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n         (out, err) = proc.communicate()\n \n         if proc.returncode != 0:\n@@ -52,7 +51,8 @@ def get_psu_status(self, index):\n             return False\n \n         psu_id = self.psu1_id if index == 1 else self.psu2_id\n-        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n+        self.ipmi_raw[8] = psu_id\n+        res_string = self.run_command(self.ipmi_raw)\n         status_byte = self.find_value(res_string)\n \n         if status_byte is None:\n@@ -76,7 +76,8 @@ def get_psu_presence(self, index):\n             return False\n \n         psu_id = self.psu1_id if index == 1 else self.psu2_id\n-        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n+        self.ipmi_raw[8] = psu_id\n+        res_string = self.run_command(self.ipmi_raw)\n         status_byte = self.find_value(res_string)\n \n         if status_byte is None:\ndiff --git a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py\nindex bbbb9f1d4..ba7742c66 100644\n--- a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py\n+++ b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py\n@@ -6,7 +6,6 @@\n #\n #############################################################################\n \n-import json\n import os.path\n \n try:\n@@ -24,14 +23,18 @@\n ]\n SW_CPLD_VER_PATH = \"/sys/module/switch_cpld/version\"\n BASE_CPLD_VER_PATH = \"/sys/module/baseboard_lpc/version\"\n-CPLD_UPGRADE_OPT = 4\n BIOS_VER_PATH = \"/sys/class/dmi/id/bios_version\"\n-BIOS__UPGRADE_OPT = 2\n-BMC_VER_CMD = \"ipmitool mc info | grep 'Firmware Revision'\"\n-BMC_UPGRADE_OPT = 1\n-CFUFLASH_FW_UPGRADE_CMD = \"CFUFLASH -cd -d {} -mse 3 {}\"\n+BMC_VER_CMD1 = [\"ipmitool\", \"mc\", \"info\"]\n+BMC_VER_CMD2 = [\"grep\", \"Firmware Revision\"]\n+CFUFLASH_FW_UPGRADE_CMD = [\"CFUFLASH\", \"-cd\", \"-d\", \"\", \"-mse\", \"3\", \"\"]\n MEM_PCI_RESOURCE = \"/sys/bus/pci/devices/0000:09:00.0/resource0\"\n FPGA_VER_MEM_OFFSET = 0\n+UPGRADE_OPT = {\n+    'BMC': '1',\n+    'BIOS': '2',\n+    'SWITCH_CPLD': '4',\n+    'BASE_CPLD': '4'\n+}\n \n \n class Component(ComponentBase):\n@@ -47,7 +50,7 @@ def __init__(self, component_index):\n \n     def __get_bmc_ver(self):\n         bmc_ver = \"Unknown\"\n-        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD)\n+        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD1, BMC_VER_CMD2)\n         if status:\n             bmc_ver_data = raw_bmc_data.split(\":\")\n             bmc_ver = bmc_ver_data[-1].strip() if len(\n@@ -104,16 +107,12 @@ def install_firmware(self, image_path):\n         Returns:\n             A boolean, True if install successfully, False if not\n         \"\"\"\n-        install_command = {\n-            \"BMC\": CFUFLASH_FW_UPGRADE_CMD.format(BMC_UPGRADE_OPT, image_path),\n-            \"BIOS\": CFUFLASH_FW_UPGRADE_CMD.format(BIOS__UPGRADE_OPT, image_path),\n-            \"SWITCH_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path),\n-            \"BASE_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path)\n-        }.get(self.name, None)\n-\n-        if not os.path.isfile(image_path) or install_command is None:\n+        CFUFLASH_FW_UPGRADE_CMD[3] = UPGRADE_OPT.get(self.name)\n+        CFUFLASH_FW_UPGRADE_CMD[6] = image_path\n+\n+        if not os.path.isfile(image_path):\n             return False\n \n         # print(install_command)\n-        status = self._api_helper.run_interactive_command(install_command)\n+        status = self._api_helper.run_interactive_command(CFUFLASH_FW_UPGRADE_CMD)\n         return status\ndiff --git a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py\nindex 144d9e154..d53de841e 100644\n--- a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py\n+++ b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py\n@@ -2,8 +2,9 @@\n import struct\n import subprocess\n from mmap import *\n+from sonic_py_common.general import check_output_pipe\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -13,7 +14,11 @@ def __init__(self):\n         pass\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -28,22 +33,18 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n+    def run_command(self, cmd1_args, cmd2_args):\n         status = True\n         result = \"\"\n         try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except:\n+            result = check_output_pipe(cmd1_args, cmd2_args)\n+        except subprocess.CalledProcessError:\n             status = False\n         return status, result\n \n     def run_interactive_command(self, cmd):\n         try:\n-            os.system(cmd)\n+            subprocess.call(cmd)\n         except:\n             return False\n         return True\n@@ -61,9 +62,9 @@ def ipmi_raw(self, netfn, cmd):\n         status = True\n         result = \"\"\n         try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n+            cmd = [\"ipmitool\", \"raw\", str(netfn), str(cmd)]\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = raw_data.strip()\n@@ -76,28 +77,30 @@ def ipmi_raw(self, netfn, cmd):\n     def ipmi_fru_id(self, id, key=None):\n         status = True\n         result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n+        cmd1_args = [\"ipmitool\", \"fru\", \"print\", str(id)]\n+        if not key:\n+            try:\n+                p = subprocess.Popen(\n+                    cmd1_args, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                raw_data, err = p.communicate()\n+                if err == '':\n+                    result = raw_data.strip()\n+                else:\n+                    status = False\n+            except:\n                 status = False\n-        except:\n-            status = False\n+        else:\n+            cmd2_args = [\"grep\", str(key)]\n+            status, result = self.run_command(cmd1_args, cmd2_args)\n         return status, result\n \n     def ipmi_set_ss_thres(self, id, threshold_key, value):\n         status = True\n         result = \"\"\n         try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n+            cmd = [\"ipmitool\", \"sensor\", \"thresh\", str(id), str(threshold_key), str(value)]\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = raw_data.strip()\ndiff --git a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py\nindex 9ad0f1dc9..a6c805d3c 100644\n--- a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py\n+++ b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py\n@@ -33,20 +33,15 @@\n PSU_LED_GREEN_CMD = \"0x01\"\n PSU_LED_AMBER_CMD = \"0x02\"\n \n-PSU1_VOUT_SS_ID = \"0x36\"\n-PSU1_COUT_SS_ID = \"0x37\"\n-PSU1_POUT_SS_ID = \"0x38\"\n-PSU1_STATUS_REG = \"0x39\"\n-\n-PSU2_VOUT_SS_ID = \"0x40\"\n-PSU2_COUT_SS_ID = \"0x41\"\n-PSU2_POUT_SS_ID = \"0x42\"\n-PSU2_STATUS_REG = \"0x2f\"\n-\n PSU1_FRU_ID = 3\n \n SS_READ_OFFSET = 0\n \n+PSU_VOUT_SS_ID = [\"0x36\", \"0x40\"]\n+PSU_COUT_SS_ID = [\"0x37\", \"0x41\"]\n+PSU_POUT_SS_ID = [\"0x38\", \"0x42\"]\n+PSU_STATUS_REG = [\"0x39\", \"0x2f\"]\n+\n \n class Psu(PsuBase):\n     \"\"\"Platform-specific Psu class\"\"\"\n@@ -71,7 +66,7 @@ def get_voltage(self):\n             e.g. 12.1\n         \"\"\"\n         psu_voltage = 0.0\n-        psu_vout_key = globals()['PSU{}_VOUT_SS_ID'.format(self.index+1)]\n+        psu_vout_key = PSU_VOUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_vout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n@@ -87,7 +82,7 @@ def get_current(self):\n             A float number, the electric current in amperes, e.g 15.4\n         \"\"\"\n         psu_current = 0.0\n-        psu_cout_key = globals()['PSU{}_COUT_SS_ID'.format(self.index+1)]\n+        psu_cout_key = PSU_COUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_cout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n@@ -103,7 +98,7 @@ def get_power(self):\n             A float number, the power in watts, e.g. 302.6\n         \"\"\"\n         psu_power = 0.0\n-        psu_pout_key = globals()['PSU{}_POUT_SS_ID'.format(self.index+1)]\n+        psu_pout_key = PSU_POUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n@@ -176,7 +171,7 @@ def get_presence(self):\n             bool: True if PSU is present, False if not\n         \"\"\"\n         psu_presence = False\n-        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n+        psu_pstatus_key = PSU_STATUS_REG[self.index]\n         status, raw_status_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n         status_byte = self.find_value(raw_status_read)\n@@ -228,7 +223,7 @@ def get_status(self):\n             A boolean value, True if device is operating properly, False if not\n         \"\"\"\n         psu_status = False\n-        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n+        psu_pstatus_key = PSU_STATUS_REG[self.index]\n         status, raw_status_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n         status_byte = self.find_value(raw_status_read)\ndiff --git a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py\nindex c22c7a9b7..4ad97b42f 100644\n--- a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py\n+++ b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py\n@@ -6,7 +6,6 @@\n #\n #############################################################################\n \n-import os\n import time\n import subprocess\n from ctypes import create_string_buffer\n@@ -168,7 +167,7 @@ class Sfp(SfpBase):\n     # Path to QSFP sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-cel_silverstone-r0\"\n     HWSKU = \"Silverstone\"\n@@ -270,7 +269,11 @@ def __convert_string_to_num(self, value_str):\n             return 'N/A'\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py b/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py\nindex e4f3e1257..7fee0aee5 100644\n--- a/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py\n+++ b/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py\n@@ -8,19 +8,18 @@\n #\r\n #############################################################################\r\n \r\n-import os.path\r\n import subprocess\r\n-import time\r\n-import os\r\n \r\n try:\r\n     from sonic_platform_base.component_base import ComponentBase\r\n+    from sonic_py_common.general import getstatusoutput_noshell_pipe\r\n     #from helper import APIHelper\r\n except ImportError as e:\r\n     raise ImportError(str(e) + \"- required module not found\")\r\n \r\n-SWCPLD_VERSION_PATH = \"i2cget -y -f 2 0x32 0\"\r\n-BIOS_VERSION_PATH = \"dmidecode -t bios | grep Version\"\r\n+SWCPLD_VERSION_PATH = [\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0\"]\r\n+BIOS_VERSION_PATH_CMD1 = [\"dmidecode\", \"-t\", \"bios\"]\r\n+BIOS_VERSION_PATH_CMD2 = [\"grep\", \"Version\"]\r\n COMPONENT_NAME_LIST = [\"SWCPLD\", \"Main_BIOS\", \"Backup_BIOS\"]\r\n COMPONENT_DES_LIST = [\"Use for boot control and BIOS switch\",\r\n                       \"Main basic Input/Output System\",\r\n@@ -39,15 +38,15 @@ def __init__(self, component_index):\n         self.name = self.get_name()\r\n \r\n     def run_command(self,cmd):\r\n-        responses = os.popen(cmd).read()\r\n+        responses = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()\r\n         return responses\r\n \r\n     def __get_bios_version(self):\r\n         # Retrieves the BIOS firmware version\r\n-        result = self.run_command(\"i2cget -y -f 2 0x32 0x19\")\r\n+        result = self.run_command([\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0x19\"])\r\n         if result.strip() == \"0x01\":\r\n             if self.name == \"Main_BIOS\":\r\n-                version = self.run_command(BIOS_VERSION_PATH)\r\n+                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r\n                 bios_version = version.strip().split(\" \")[1]\r\n                 return str(bios_version)\r\n             elif self.name == \"Backup_BIOS\":\r\n@@ -56,7 +55,7 @@ def __get_bios_version(self):\n                 \r\n         elif result.strip() == \"0x03\":\r\n             if self.name == \"Backup_BIOS\":\r\n-                version = self.run_command(BIOS_VERSION_PATH)\r\n+                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r\n                 bios_version = version.strip().split(\" \")[1]\r\n                 return str(bios_version)\r\n             elif self.name == \"Main_BIOS\":\r\ndiff --git a/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py b/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py\nindex 36e95f2c0..d5ee08049 100644\n--- a/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py\n+++ b/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py\n@@ -1,6 +1,6 @@\n try:\n     from sonic_platform_pddf_base.pddf_fan import PddfFan\n-    import os\n+    import subprocess\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n # ------------------------------------------------------------------\n@@ -47,8 +47,9 @@ def get_direction(self):\n         \"\"\"\n         if self.is_psu_fan:\n             cmd_num = \"58\" if self.fans_psu_index == 1 else \"59\"\n-            cmd = \"i2cget -y -f 4 0x%s 0x80\" % cmd_num\n-            res = os.popen(cmd).read()\n+            cmd = [\"i2cget\", \"-y\", \"-f\", \"4\", \"\", \"0x80\"]\n+            cmd[4] = \"0x\" + cmd_num\n+            res = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()\n             # F2B \n             if res.strip() == \"0x01\":\n                 direction = \"EXHAUST\"\ndiff --git a/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py b/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py\nindex 017a04709..5ce0469a0 100755\n--- a/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py\n@@ -23,13 +23,13 @@\n try:\n     import sys\n     import getopt\n-    import subprocess\n     import logging\n     import logging.config\n     import time  # this is only being used as part of the example\n     import signal\n     import math\n     from sonic_platform import platform\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n@@ -224,7 +224,7 @@ def handler(signum, frame):\n         else:\n             logging.debug('INFO: FAIL. set_fan_duty_cycle (%d)' % DUTY_MAX)\n         # Enable the CPLD Heartbeat back\n-        status, output = subprocess.getstatusoutput('i2cset -f -y 75 0x40 0x22 0x00')\n+        status, output = getstatusoutput_noshell([\"i2cset\", \"-f\", \"-y\", \"75\", \"0x40\", \"0x22\", \"0x00\"])\n         if status == 0:\n             logging.debug('INFO: CPLD Heartbeat check is enabled back')\n     sys.exit(0)\n@@ -258,7 +258,7 @@ def main(argv):\n     signal.signal(signal.SIGINT, handler)\n     signal.signal(signal.SIGTERM, handler)\n     # Disaable the CPLD Heartbeat check to control Fan speed from CPU via ADT7470\n-    subprocess.getstatusoutput('i2cset -f -y 2 0x32 0x30 0x01')\n+    getstatusoutput_noshell(['i2cset', '-f', '-y', '2', '0x32', '0x30', '0x01'])\n \n     monitor = cel_belgite_monitor(log_file, log_level)\n \ndiff --git a/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py b/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py\nindex 697308b8c..2d9683599 100644\n--- a/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py\n+++ b/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py\n@@ -1,4 +1,5 @@\n import os\n+import ast\n import imp\n import yaml\n import subprocess\n@@ -24,7 +25,7 @@ class Common:\n \n     SET_METHOD_IPMI = 'ipmitool'\n     NULL_VAL = 'N/A'\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n     REF_KEY = '$ref:'\n \n     def __init__(self, conf=None):\n@@ -56,7 +57,7 @@ def _clean_input(self, input, config):\n             cleaned_input = input_translator.get(input)\n \n         elif type(input_translator) is str:\n-            cleaned_input = eval(input_translator.format(input))\n+            cleaned_input = ast.literal_eval(input_translator.format(input))\n \n         return cleaned_input\n \n@@ -66,9 +67,9 @@ def _clean_output(self, index, output, config):\n         if type(output_translator) is dict:\n             output = output_translator.get(output)\n         elif type(output_translator) is str:\n-            output = eval(output_translator.format(output))\n+            output = ast.literal_eval(output_translator.format(output))\n         elif type(output_translator) is list:\n-            output = eval(output_translator[index].format(output))\n+            output = ast.literal_eval(output_translator[index].format(output))\n \n         return output\n \n@@ -166,7 +167,11 @@ def write_txt_file(self, file_path, value):\n         return True\n \n     def is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def load_json_file(self, path):\n         \"\"\"\ndiff --git a/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py b/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py\nindex 186ee6c54..1aa1c0719 100755\n--- a/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py\n+++ b/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py\n@@ -12,7 +12,7 @@\n import logging\n import subprocess\n \n-IPMI_SDR_CMD = \"ipmitool sdr elist\"\n+IPMI_SDR_CMD = [\"ipmitool\", \"sdr\", \"elist\"]\n MAX_NUM_FANS = 7\n MAX_NUM_PSUS = 2\n \n@@ -23,7 +23,7 @@ def ipmi_sensor_dump(cmd):\n     '''\n     sensor_dump = ''\n     try:\n-        sensor_dump = subprocess.check_output(cmd, shell=True)\n+        sensor_dump = subprocess.check_output(cmd)\n     except subprocess.CalledProcessError as e:\n         logging.error('Error! Failed to execute: {}'.format(cmd))\n         sys.exit(1)\n", "message": "", "files": {"/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n RESET_REGISTER = \"0x112\"\n HOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/previous-reboot-cause.txt\"\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n STATUS_LED_PATH = \"/sys/devices/platform/e1031.smc/master_led\"\n \n ", "add": 0, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": []}], "source": "\n try: from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper from sonic_platform_base.chassis_base import ChassisBase from sonic_py_common import device_info from.common import Common from.event import SfpEvent except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=3 NUM_PSU=2 NUM_THERMAL=7 NUM_SFP=55 NUM_COMPONENT=3 RESET_REGISTER=\"0x112\" HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/previous-reboot-cause.txt\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/previous-reboot-cause.txt\" HOST_CHK_CMD=\"docker > /dev/null 2>&1\" STATUS_LED_PATH=\"/sys/devices/platform/e1031.smc/master_led\" class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_common=Common() self._is_host=self._api_common.is_host() self.__initialize_eeprom() self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.sfp_module_initialized=False self._reboot_cause_path=HOST_REBOOT_CAUSE_PATH if self._is_host else PMON_REBOOT_CAUSE_PATH def __initialize_sfp(self): sfputil_helper=SfpUtilHelper() port_config_file_path=device_info.get_path_to_port_config_file() sfputil_helper.read_porttab_mappings(port_config_file_path, 0) from.sfp import Sfp for index in range(0, NUM_SFP): sfp=Sfp(index, sfputil_helper.logical[index]) self._sfp_list.append(sfp) self.sfp_module_initialized=True def __initialize_psu(self): from.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_fan(self): from.fan_drawer import FanDrawer for i in range(NUM_FAN_TRAY): fandrawer=FanDrawer(i) self._fan_drawer_list.append(fandrawer) self._fan_list +=fandrawer.get_all_fans() def __initialize_thermals(self): from.thermal import Thermal airflow=self.__get_air_flow() for index in range(0, NUM_THERMAL): thermal=Thermal(index, airflow) self._thermal_list.append(thermal) def __initialize_eeprom(self): from.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __get_air_flow(self): air_flow_path='/usr/share/sonic/device/{}/fan_airflow'.format( self._api_common.get_platform()) if self._is_host else '/usr/share/sonic/platform/fan_airflow' air_flow=self._api_common.read_txt_file(air_flow_path) return air_flow or 'B2F' def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_serial_number(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" description='None' reboot_cause=self.REBOOT_CAUSE_HARDWARE_OTHER hw_reboot_cause=self._component_list[0].get_register_value( RESET_REGISTER) sw_reboot_cause=self._api_common.read_txt_file( self._reboot_cause_path) or \"Unknown\" if hw_reboot_cause==\"0x55\": reboot_cause=self.REBOOT_CAUSE_NON_HARDWARE description=sw_reboot_cause elif hw_reboot_cause==\"0x11\": reboot_cause=self.REBOOT_CAUSE_POWER_LOSS elif hw_reboot_cause==\"0x33\": reboot_cause=self.REBOOT_CAUSE_WATCHDOG elif hw_reboot_cause==\"0x88\": reboot_cause=self.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU elif hw_reboot_cause==\"0x99\": reboot_cause=self.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC else: reboot_cause=self.REBOOT_CAUSE_NON_HARDWARE description='Unknown reason' return(reboot_cause, description) def get_watchdog(self): \"\"\" Retreives hardware watchdog device on this chassis Returns: An object derived from WatchdogBase representing the hardware watchdog device \"\"\" if self._watchdog is None: from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() return self._watchdog def get_change_event(self, timeout=0): \"\"\" Returns a nested dictionary containing all devices which have experienced a change at chassis level Args: timeout: Timeout in milliseconds(optional). If timeout==0, this method will block until a change is detected. Returns: (bool, dict): -True if call successful, False if not; -A nested dictionary where key is a device type, value is a dictionary with key:value pairs in the format of {'device_id':'device_event'}, where device_id is the device ID for this device and device_event, status='1' represents device inserted, status='0' represents device removed. Ex.{'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}} indicates that fan 0 has been removed, fan 2 has been inserted and sfp 11 has been removed. \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() sfp_event=SfpEvent(self._sfp_list).get_sfp_event(timeout) if sfp_event: return True,{'sfp': sfp_event} return False,{'sfp':{}} def get_num_sfps(self): \"\"\" Retrieves the number of sfps available on this chassis Returns: An integer, the number of sfps available on this chassis \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() return len(self._sfp_list) def get_all_sfps(self): \"\"\" Retrieves all sfps available on this chassis Returns: A list of objects derived from SfpBase representing all sfps available on this chassis \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfp_list def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() return super(Chassis, self).get_sfp(index -1) def get_thermal_manager(self): from.thermal_manager import ThermalManager return ThermalManager def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._api_common.get_hwsku() def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return self.get_serial_number() def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def set_status_led(self, color): \"\"\" Sets the state of the PSU status LED Args: color: A string representing the color with which to set the PSU status LED Note: Only support green and off Returns: bool: True if status LED state is set successfully, False if not \"\"\" status_str={ self.STATUS_LED_COLOR_GREEN: 'green', self.STATUS_LED_COLOR_AMBER: 'amber', self.STATUS_LED_COLOR_OFF: 'off' }.get(color, 'off') return self._api_common.write_txt_file(STATUS_LED_PATH, status_str) def get_status_led(self): \"\"\" Gets the state of the PSU status LED Returns: A string, one of the predefined STATUS_LED_COLOR_* strings above \"\"\" status=self._api_common.read_txt_file(STATUS_LED_PATH) status_str={ 'on': self.STATUS_LED_COLOR_GREEN, 'amber': self.STATUS_LED_COLOR_AMBER, 'off': self.STATUS_LED_COLOR_OFF }.get(status, None) return status_str ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\n\ntry:\n    from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper\n    from sonic_platform_base.chassis_base import ChassisBase\n    from sonic_py_common import device_info\n    from .common import Common\n    from .event import SfpEvent\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 3\nNUM_PSU = 2\nNUM_THERMAL = 7\nNUM_SFP = 55\nNUM_COMPONENT = 3\nRESET_REGISTER = \"0x112\"\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/previous-reboot-cause.txt\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nSTATUS_LED_PATH = \"/sys/devices/platform/e1031.smc/master_led\"\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n\n        self._api_common = Common()\n        self._is_host = self._api_common.is_host()\n\n        self.__initialize_eeprom()\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n\n        self.sfp_module_initialized = False\n        self._reboot_cause_path = HOST_REBOOT_CAUSE_PATH if self._is_host else PMON_REBOOT_CAUSE_PATH\n\n    def __initialize_sfp(self):\n        sfputil_helper = SfpUtilHelper()\n        port_config_file_path = device_info.get_path_to_port_config_file()\n        sfputil_helper.read_porttab_mappings(port_config_file_path, 0)\n\n        from .sfp import Sfp\n        for index in range(0, NUM_SFP):\n            sfp = Sfp(index, sfputil_helper.logical[index])\n            self._sfp_list.append(sfp)\n        self.sfp_module_initialized = True\n\n    def __initialize_psu(self):\n        from .psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_fan(self):\n        from .fan_drawer import FanDrawer\n        for i in range(NUM_FAN_TRAY):\n            fandrawer = FanDrawer(i)\n            self._fan_drawer_list.append(fandrawer)\n            self._fan_list += fandrawer.get_all_fans()\n\n    def __initialize_thermals(self):\n        from .thermal import Thermal\n        airflow = self.__get_air_flow()\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index, airflow)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from .eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from .component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __get_air_flow(self):\n        air_flow_path = '/usr/share/sonic/device/{}/fan_airflow'.format(\n            self._api_common.get_platform()) if self._is_host else '/usr/share/sonic/platform/fan_airflow'\n        air_flow = self._api_common.read_txt_file(air_flow_path)\n        return air_flow or 'B2F'\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_serial_number(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        description = 'None'\n        reboot_cause = self.REBOOT_CAUSE_HARDWARE_OTHER\n        hw_reboot_cause = self._component_list[0].get_register_value(\n            RESET_REGISTER)\n        sw_reboot_cause = self._api_common.read_txt_file(\n            self._reboot_cause_path) or \"Unknown\"\n\n        if hw_reboot_cause == \"0x55\":\n            reboot_cause = self.REBOOT_CAUSE_NON_HARDWARE\n            description = sw_reboot_cause\n        elif hw_reboot_cause == \"0x11\":\n            reboot_cause = self.REBOOT_CAUSE_POWER_LOSS\n        elif hw_reboot_cause == \"0x33\":\n            reboot_cause = self.REBOOT_CAUSE_WATCHDOG\n        elif hw_reboot_cause == \"0x88\":\n            reboot_cause = self.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU\n        elif hw_reboot_cause == \"0x99\":\n            reboot_cause = self.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC\n        else:\n            reboot_cause = self.REBOOT_CAUSE_NON_HARDWARE\n            description = 'Unknown reason'\n        return (reboot_cause, description)\n\n    def get_watchdog(self):\n        \"\"\"\n        Retreives hardware watchdog device on this chassis\n        Returns:\n            An object derived from WatchdogBase representing the hardware\n            watchdog device\n        \"\"\"\n        if self._watchdog is None:\n            from sonic_platform.watchdog import Watchdog\n            self._watchdog = Watchdog()\n\n        return self._watchdog\n\n    def get_change_event(self, timeout=0):\n        \"\"\"\n        Returns a nested dictionary containing all devices which have\n        experienced a change at chassis level\n        Args:\n            timeout: Timeout in milliseconds (optional). If timeout == 0,\n                this method will block until a change is detected.\n        Returns:\n            (bool, dict):\n                - True if call successful, False if not;\n                - A nested dictionary where key is a device type,\n                  value is a dictionary with key:value pairs in the format of\n                  {'device_id':'device_event'},\n                  where device_id is the device ID for this device and\n                        device_event,\n                             status='1' represents device inserted,\n                             status='0' represents device removed.\n                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}\n                      indicates that fan 0 has been removed, fan 2\n                      has been inserted and sfp 11 has been removed.\n        \"\"\"\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        sfp_event = SfpEvent(self._sfp_list).get_sfp_event(timeout)\n        if sfp_event:\n            return True, {'sfp': sfp_event}\n\n        return False, {'sfp': {}}\n\n    ##############################################################\n    ######################## SFP methods #########################\n    ##############################################################\n\n    def get_num_sfps(self):\n        \"\"\"\n        Retrieves the number of sfps available on this chassis\n        Returns:\n            An integer, the number of sfps available on this chassis\n        \"\"\"\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return len(self._sfp_list)\n\n    def get_all_sfps(self):\n        \"\"\"\n        Retrieves all sfps available on this chassis\n        Returns:\n            A list of objects derived from SfpBase representing all sfps\n            available on this chassis\n        \"\"\"\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return self._sfp_list\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return super(Chassis, self).get_sfp(index - 1)\n\n    ##############################################################\n    ################## ThermalManager methods ####################\n    ##############################################################\n\n    def get_thermal_manager(self):\n        from .thermal_manager import ThermalManager\n        return ThermalManager\n\n    ##############################################################\n    ###################### Device methods ########################\n    ##############################################################\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return self._api_common.get_hwsku()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return self.get_serial_number()\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the PSU status LED\n        Args:\n            color: A string representing the color with which to set the PSU status LED\n                   Note: Only support green and off\n        Returns:\n            bool: True if status LED state is set successfully, False if not\n        \"\"\"\n\n        status_str = {\n            self.STATUS_LED_COLOR_GREEN: 'green',\n            self.STATUS_LED_COLOR_AMBER: 'amber',\n            self.STATUS_LED_COLOR_OFF: 'off'\n        }.get(color, 'off')\n\n        return self._api_common.write_txt_file(STATUS_LED_PATH, status_str)\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the PSU status LED\n        Returns:\n            A string, one of the predefined STATUS_LED_COLOR_* strings above\n        \"\"\"\n        status = self._api_common.read_txt_file(STATUS_LED_PATH)\n        status_str = {\n            'on': self.STATUS_LED_COLOR_GREEN,\n            'amber': self.STATUS_LED_COLOR_AMBER,\n            'off': self.STATUS_LED_COLOR_OFF\n        }.get(status, None)\n\n        return status_str\n"}, "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py": {"changes": [{"diff": "\n import os\r\n+import ast\r\n import imp\r\n import yaml\r\n import subprocess\r\n-\r\n from sonic_py_common import device_info\r\n \r\n \r\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["\r"], "goodparts": ["import ast\r"]}, {"diff": "\n \r\n     SET_METHOD_IPMI = 'ipmitool'\r\n     NULL_VAL = 'N/A'\r\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\r\n+    HOST_CHK_CMD = [\"docker\"]\r\n     REF_KEY = '$ref:'\r\n \r\n     def __init__(self, conf=None):\r\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\r"], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]\r"]}, {"diff": "\n         status = False\r\n         output = \"\"\r\n         try:\r\n-            p = subprocess.Popen(\r\n-                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n+            p = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n             raw_data, err = p.communicate()\r\n             if p.returncode == 0:\r\n                 status, output = True, raw_data.strip()\r\n", "add": 1, "remove": 2, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["            p = subprocess.Popen(\r", "                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r"], "goodparts": ["            p = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r"]}, {"diff": "\n             cleaned_input = input_translator.get(input)\r\n \r\n         elif type(input_translator) is str:\r\n-            cleaned_input = eval(input_translator.format(input))\r\n+            cleaned_input = ast.literal_eval(input_translator.format(input))\r\n \r\n         return cleaned_input\r\n \r\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["            cleaned_input = eval(input_translator.format(input))\r"], "goodparts": ["            cleaned_input = ast.literal_eval(input_translator.format(input))\r"]}, {"diff": "\n         if type(output_translator) is dict:\r\n             output = output_translator.get(output)\r\n         elif type(output_translator) is str:\r\n-            output = eval(output_translator.format(output))\r\n+            output = ast.literal_eval(output_translator.format(output))\r\n         elif type(output_translator) is list:\r\n-            output = eval(output_translator[index].format(output))\r\n+            output = ast.literal_eval(output_translator[index].format(output))\r\n \r\n         return output\r\n \r\n-    def _ipmi_get(self, index, config):\r\n-        argument = config.get('argument')\r\n-        cmd = config['command'].format(\r\n-            config['argument'][index]) if argument else config['command']\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n-\r\n     def _sysfs_read(self, index, config):\r\n         sysfs_path = config.get('sysfs_path')\r\n         argument = config.get('argument', '')\r\n", "add": 2, "remove": 9, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["            output = eval(output_translator.format(output))\r", "            output = eval(output_translator[index].format(output))\r", "    def _ipmi_get(self, index, config):\r", "        argument = config.get('argument')\r", "        cmd = config['command'].format(\r", "            config['argument'][index]) if argument else config['command']\r", "        status, output = self.run_command(cmd)\r", "        return output if status else None\r", "\r"], "goodparts": ["            output = ast.literal_eval(output_translator.format(output))\r", "            output = ast.literal_eval(output_translator[index].format(output))\r"]}, {"diff": "\n             return False, output\r\n         return True, output\r\n \r\n-    def _ipmi_set(self, index, config, input):\r\n-        arg = config['argument'][index].format(input)\r\n-        return self.run_command(config['command'].format(arg))\r\n-\r\n     def _hex_ver_decode(self, hver, num_of_bits, num_of_points):\r\n         ver_list = []\r\n         c_bit = 0\r\n", "add": 0, "remove": 4, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["    def _ipmi_set(self, index, config, input):\r", "        arg = config['argument'][index].format(input)\r", "        return self.run_command(config['command'].format(arg))\r", "\r"], "goodparts": []}, {"diff": "\n         return class_\r\n \r\n     def get_reg(self, path, reg_addr):\r\n-        cmd = \"echo {1} > {0}; cat {0}\".format(path, reg_addr)\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n+        with open(path, 'w') as file:\r\n+            file.write(reg_addr + '\\n')\r\n+        with open(path, 'r') as file:\r\n+            output = file.readline().strip()\r\n+        return output\r\n \r\n     def set_reg(self, path, reg_addr, value):\r\n-        cmd = \"echo {0} {1} > {2}\".format(reg_addr, value, path)\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n+        with open(path, 'w') as file:\r\n+            file.write(\"{0} {1}\\n\".format(reg_addr, value))\r\n+        return None\r\n \r\n     def read_txt_file(self, path):\r\n         try:\r\n", "add": 8, "remove": 6, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["        cmd = \"echo {1} > {0}; cat {0}\".format(path, reg_addr)\r", "        status, output = self.run_command(cmd)\r", "        return output if status else None\r", "        cmd = \"echo {0} {1} > {2}\".format(reg_addr, value, path)\r", "        status, output = self.run_command(cmd)\r", "        return output if status else None\r"], "goodparts": ["        with open(path, 'w') as file:\r", "            file.write(reg_addr + '\\n')\r", "        with open(path, 'r') as file:\r", "            output = file.readline().strip()\r", "        return output\r", "        with open(path, 'w') as file:\r", "            file.write(\"{0} {1}\\n\".format(reg_addr, value))\r", "        return None\r"]}, {"diff": "\n         return True\r\n \r\n     def is_host(self):\r\n-        return os.system(self.HOST_CHK_CMD) == 0\r\n+        try:\r\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\r\n+        except FileNotFoundError:\r\n+            return False\r\n+        return True\r\n \r\n     def load_json_file(self, path):\r\n         \"\"\"\r\n", "add": 5, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0\r"], "goodparts": ["        try:\r", "            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\r", "        except FileNotFoundError:\r", "            return False\r", "        return True\r"]}, {"diff": "\n         \"\"\"\r\n         return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\r\n \r\n-    def get_output(self, index, config, default):\r\n-        \"\"\"\r\n-        Retrieves the output for each function base on config\r\n-\r\n-        Args:\r\n-            index: An integer containing the index of device.\r\n-            config: A dict object containing the configuration of specified function.\r\n-            default: A string containing the default output of specified function.\r\n-\r\n-        Returns:\r\n-            A string containing the output of specified function in config\r\n-        \"\"\"\r\n-        output_source = config.get('output_source')\r\n-\r\n-        if output_source == self.OUTPUT_SOURCE_IPMI:\r\n-            output = self._ipmi_get(index, config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VALUE:\r\n-            output = config[\"value\"]\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_CLASS:\r\n-            output = self._get_class(config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_LIST:\r\n-            output = config[\"value_list\"][index]\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_SYSFS:\r\n-            output = self._sysfs_read(index, config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_FUNC:\r\n-            func_conf = self._main_conf[config['function'][index]]\r\n-            output = self.get_output(index, func_conf, default)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\r\n-            path = config.get('path')\r\n-            output = self.read_txt_file(path)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\r\n-            path = config.get('path')\r\n-            hex_ver = self.read_txt_file(path)\r\n-            output = self._hex_ver_decode(\r\n-                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\r\n-            path = config.get('path')\r\n-            addr = config.get('reg_addr')\r\n-            hex_ver = self.get_reg(path, addr)\r\n-            output = self._hex_ver_decode(\r\n-                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n-\r\n-        else:\r\n-            output = default\r\n-\r\n-        return self._clean_output(index, output, config) or default\r\n-\r\n-    def set_output(self, index, input, config):\r\n-        \"\"\"\r\n-        Sets the output of specified function on config\r\n-\r\n-        Args:\r\n-            config: A dict object containing the configuration of specified function.\r\n-            index: An integer containing the index of device.\r\n-            input: A string containing the input of specified function.\r\n-\r\n-        Returns:\r\n-            bool: True if set function is successfully, False if not\r\n-        \"\"\"\r\n-        cleaned_input = self._clean_input(input, config)\r\n-        if not cleaned_input:\r\n-            return False\r\n-\r\n-        set_method = config.get('set_method')\r\n-        if set_method == self.SET_METHOD_IPMI:\r\n-            output = self._ipmi_set(index, config, cleaned_input)[0]\r\n-        elif set_method == self.OUTPUT_SOURCE_SYSFS:\r\n-            output = self._sysfs_write(index, config, cleaned_input)[0]\r\n-        else:\r\n-            output = False\r\n-\r\n-        return output\r\n-\r\n     def get_event(self, timeout, config, sfp_list):\r\n         \"\"\"\r\n         Returns a nested dictionary containing all devices which have", "add": 0, "remove": 81, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["    def get_output(self, index, config, default):\r", "        \"\"\"\r", "        Retrieves the output for each function base on config\r", "\r", "        Args:\r", "            index: An integer containing the index of device.\r", "            config: A dict object containing the configuration of specified function.\r", "            default: A string containing the default output of specified function.\r", "\r", "        Returns:\r", "            A string containing the output of specified function in config\r", "        \"\"\"\r", "        output_source = config.get('output_source')\r", "\r", "        if output_source == self.OUTPUT_SOURCE_IPMI:\r", "            output = self._ipmi_get(index, config)\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_VALUE:\r", "            output = config[\"value\"]\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_CLASS:\r", "            output = self._get_class(config)\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_LIST:\r", "            output = config[\"value_list\"][index]\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_SYSFS:\r", "            output = self._sysfs_read(index, config)\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_FUNC:\r", "            func_conf = self._main_conf[config['function'][index]]\r", "            output = self.get_output(index, func_conf, default)\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\r", "            path = config.get('path')\r", "            output = self.read_txt_file(path)\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\r", "            path = config.get('path')\r", "            hex_ver = self.read_txt_file(path)\r", "            output = self._hex_ver_decode(\r", "                hex_ver, config['num_of_bits'], config['num_of_points'])\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\r", "            path = config.get('path')\r", "            addr = config.get('reg_addr')\r", "            hex_ver = self.get_reg(path, addr)\r", "            output = self._hex_ver_decode(\r", "                hex_ver, config['num_of_bits'], config['num_of_points'])\r", "\r", "        else:\r", "            output = default\r", "\r", "        return self._clean_output(index, output, config) or default\r", "\r", "    def set_output(self, index, input, config):\r", "        \"\"\"\r", "        Sets the output of specified function on config\r", "\r", "        Args:\r", "            config: A dict object containing the configuration of specified function.\r", "            index: An integer containing the index of device.\r", "            input: A string containing the input of specified function.\r", "\r", "        Returns:\r", "            bool: True if set function is successfully, False if not\r", "        \"\"\"\r", "        cleaned_input = self._clean_input(input, config)\r", "        if not cleaned_input:\r", "            return False\r", "\r", "        set_method = config.get('set_method')\r", "        if set_method == self.SET_METHOD_IPMI:\r", "            output = self._ipmi_set(index, config, cleaned_input)[0]\r", "        elif set_method == self.OUTPUT_SOURCE_SYSFS:\r", "            output = self._sysfs_write(index, config, cleaned_input)[0]\r", "        else:\r", "            output = False\r", "\r", "        return output\r", "\r"], "goodparts": []}], "source": "\nimport os\r import imp\r import yaml\r import subprocess\r \r from sonic_py_common import device_info\r \r \r class Common:\r \r DEVICE_PATH='/usr/share/sonic/device/'\r PMON_PLATFORM_PATH='/usr/share/sonic/platform/'\r CONFIG_DIR='sonic_platform_config'\r \r OUTPUT_SOURCE_IPMI='ipmitool'\r OUTPUT_SOURCE_GIVEN_LIST='value_list'\r OUTPUT_SOURCE_GIVEN_VALUE='value'\r OUTPUT_SOURCE_GIVEN_CLASS='class'\r OUTPUT_SOURCE_SYSFS='sysfs_value'\r OUTPUT_SOURCE_FUNC='function'\r OUTPUT_SOURCE_GIVEN_TXT_FILE='txt_file'\r OUTPUT_SOURCE_GIVEN_VER_HEX_FILE='hex_version_file'\r OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR='hex_version_getreg'\r \r SET_METHOD_IPMI='ipmitool'\r NULL_VAL='N/A'\r HOST_CHK_CMD=\"docker > /dev/null 2>&1\"\r REF_KEY='$ref:'\r \r def __init__(self, conf=None):\r self._main_conf=conf\r self.platform=None\r self.hwsku=None\r \r def get_platform(self):\r (self.platform, self.hwsku)=device_info.get_platform_and_hwsku(\r ) if not self.platform else(self.platform, self.hwsku)\r return self.platform\r \r def get_hwsku(self):\r (self.platform, self.hwsku)=device_info.get_platform_and_hwsku(\r ) if not self.hwsku else(self.platform, self.hwsku)\r return self.hwsku\r \r def run_command(self, command):\r status=False\r output=\"\"\r try:\r p=subprocess.Popen(\r command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r raw_data, err=p.communicate()\r if p.returncode==0:\r status, output=True, raw_data.strip()\r except Exception:\r pass\r return status, output\r \r def _clean_input(self, input, config):\r cleaned_input=input\r \r ai=config.get('avaliable_input')\r if ai and input not in ai:\r return None\r \r input_translator=config.get('input_translator')\r if type(input_translator) is dict:\r cleaned_input=input_translator.get(input)\r \r elif type(input_translator) is str:\r cleaned_input=eval(input_translator.format(input))\r \r return cleaned_input\r \r def _clean_output(self, index, output, config):\r output_translator=config.get('output_translator')\r \r if type(output_translator) is dict:\r output=output_translator.get(output)\r elif type(output_translator) is str:\r output=eval(output_translator.format(output))\r elif type(output_translator) is list:\r output=eval(output_translator[index].format(output))\r \r return output\r \r def _ipmi_get(self, index, config):\r argument=config.get('argument')\r cmd=config['command'].format(\r config['argument'][index]) if argument else config['command']\r status, output=self.run_command(cmd)\r return output if status else None\r \r def _sysfs_read(self, index, config):\r sysfs_path=config.get('sysfs_path')\r argument=config.get('argument', '')\r \r if self.REF_KEY in argument:\r argument=self._main_conf[argument.split(\":\")[1]]\r \r if type(argument) is list:\r sysfs_path=sysfs_path.format(argument[index])\r \r content=\"\"\r try:\r content=open(sysfs_path)\r content=content.readline().rstrip()\r except IOError as e:\r print(\"Error: unable to open file: %s\" % str(e))\r return False\r \r return content\r \r def _sysfs_write(self, index, config, input):\r sysfs_path=config.get('sysfs_path')\r argument=config.get('argument', '')\r \r if self.REF_KEY in argument:\r argument=self._main_conf[argument.split(\":\")[1]]\r \r if type(argument) is list:\r sysfs_path=sysfs_path.format(argument[index])\r \r write_offset=int(config.get('write_offset', 0))\r output=\"\"\r try:\r open_file=open(sysfs_path, \"r+\")\r open_file.seek(write_offset)\r open_file.write(input)\r open_file.close()\r except IOError as e:\r print(\"Error: unable to open file: %s\" % str(e))\r return False, output\r return True, output\r \r def _ipmi_set(self, index, config, input):\r arg=config['argument'][index].format(input)\r return self.run_command(config['command'].format(arg))\r \r def _hex_ver_decode(self, hver, num_of_bits, num_of_points):\r ver_list=[]\r c_bit=0\r bin_val=bin(int(hver, 16))[2:].zfill(num_of_bits)\r bit_split=num_of_bits /(num_of_points +1)\r for x in range(0, num_of_points+1):\r split_bin=bin_val[c_bit:c_bit+bit_split]\r ver_list.append(str(int(split_bin, 2)))\r c_bit +=bit_split\r return '.'.join(ver_list)\r \r def _get_class(self, config):\r \"\"\"\r Retreives value of expected attribute\r Returns:\r A value of the attribute of object\r \"\"\"\r path=config['host_path'] if self.is_host() else config['pmon_path']\r module=imp.load_source(config['class'], path)\r class_=getattr(module, config['class'])\r return class_\r \r def get_reg(self, path, reg_addr):\r cmd=\"echo{1} >{0}; cat{0}\".format(path, reg_addr)\r status, output=self.run_command(cmd)\r return output if status else None\r \r def set_reg(self, path, reg_addr, value):\r cmd=\"echo{0}{1} >{2}\".format(reg_addr, value, path)\r status, output=self.run_command(cmd)\r return output if status else None\r \r def read_txt_file(self, path):\r try:\r with open(path, 'r') as f:\r output=f.readline()\r return output.strip('\\n')\r except Exception:\r pass\r return ''\r \r def read_one_line_file(self, file_path):\r try:\r with open(file_path, 'r') as fd:\r data=fd.readline()\r return data.strip()\r except IOError:\r pass\r return ''\r \r def write_txt_file(self, file_path, value):\r try:\r with open(file_path, 'w') as fd:\r fd.write(str(value))\r except Exception:\r return False\r return True\r \r def is_host(self):\r return os.system(self.HOST_CHK_CMD)==0\r \r def load_json_file(self, path):\r \"\"\"\r Retrieves the json object from json file path\r \r Returns:\r A json object\r \"\"\"\r with open(path, 'r') as f:\r json_data=yaml.safe_load(f)\r \r return json_data\r \r def get_config_path(self, config_name):\r \"\"\"\r Retrieves the path to platform api config directory\r \r Args:\r config_name: A string containing the name of config file.\r \r Returns:\r A string containing the path to json file\r \"\"\"\r return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\r \r def get_output(self, index, config, default):\r \"\"\"\r Retrieves the output for each function base on config\r \r Args:\r index: An integer containing the index of device.\r config: A dict object containing the configuration of specified function.\r default: A string containing the default output of specified function.\r \r Returns:\r A string containing the output of specified function in config\r \"\"\"\r output_source=config.get('output_source')\r \r if output_source==self.OUTPUT_SOURCE_IPMI:\r output=self._ipmi_get(index, config)\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_VALUE:\r output=config[\"value\"]\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_CLASS:\r output=self._get_class(config)\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_LIST:\r output=config[\"value_list\"][index]\r \r elif output_source==self.OUTPUT_SOURCE_SYSFS:\r output=self._sysfs_read(index, config)\r \r elif output_source==self.OUTPUT_SOURCE_FUNC:\r func_conf=self._main_conf[config['function'][index]]\r output=self.get_output(index, func_conf, default)\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\r path=config.get('path')\r output=self.read_txt_file(path)\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\r path=config.get('path')\r hex_ver=self.read_txt_file(path)\r output=self._hex_ver_decode(\r hex_ver, config['num_of_bits'], config['num_of_points'])\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\r path=config.get('path')\r addr=config.get('reg_addr')\r hex_ver=self.get_reg(path, addr)\r output=self._hex_ver_decode(\r hex_ver, config['num_of_bits'], config['num_of_points'])\r \r else:\r output=default\r \r return self._clean_output(index, output, config) or default\r \r def set_output(self, index, input, config):\r \"\"\"\r Sets the output of specified function on config\r \r Args:\r config: A dict object containing the configuration of specified function.\r index: An integer containing the index of device.\r input: A string containing the input of specified function.\r \r Returns:\r bool: True if set function is successfully, False if not\r \"\"\"\r cleaned_input=self._clean_input(input, config)\r if not cleaned_input:\r return False\r \r set_method=config.get('set_method')\r if set_method==self.SET_METHOD_IPMI:\r output=self._ipmi_set(index, config, cleaned_input)[0]\r elif set_method==self.OUTPUT_SOURCE_SYSFS:\r output=self._sysfs_write(index, config, cleaned_input)[0]\r else:\r output=False\r \r return output\r \r def get_event(self, timeout, config, sfp_list):\r \"\"\"\r Returns a nested dictionary containing all devices which have\r experienced a change at chassis level\r \r \"\"\"\r event_class=self._get_class(config)\r return event_class(sfp_list).get_event(timeout)\r ", "sourceWithComments": "import os\r\nimport imp\r\nimport yaml\r\nimport subprocess\r\n\r\nfrom sonic_py_common import device_info\r\n\r\n\r\nclass Common:\r\n\r\n    DEVICE_PATH = '/usr/share/sonic/device/'\r\n    PMON_PLATFORM_PATH = '/usr/share/sonic/platform/'\r\n    CONFIG_DIR = 'sonic_platform_config'\r\n\r\n    OUTPUT_SOURCE_IPMI = 'ipmitool'\r\n    OUTPUT_SOURCE_GIVEN_LIST = 'value_list'\r\n    OUTPUT_SOURCE_GIVEN_VALUE = 'value'\r\n    OUTPUT_SOURCE_GIVEN_CLASS = 'class'\r\n    OUTPUT_SOURCE_SYSFS = 'sysfs_value'\r\n    OUTPUT_SOURCE_FUNC = 'function'\r\n    OUTPUT_SOURCE_GIVEN_TXT_FILE = 'txt_file'\r\n    OUTPUT_SOURCE_GIVEN_VER_HEX_FILE = 'hex_version_file'\r\n    OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR = 'hex_version_getreg'\r\n\r\n    SET_METHOD_IPMI = 'ipmitool'\r\n    NULL_VAL = 'N/A'\r\n    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\r\n    REF_KEY = '$ref:'\r\n\r\n    def __init__(self, conf=None):\r\n        self._main_conf = conf\r\n        self.platform = None\r\n        self.hwsku = None\r\n\r\n    def get_platform(self):\r\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku(\r\n        ) if not self.platform else (self.platform, self.hwsku)\r\n        return self.platform\r\n\r\n    def get_hwsku(self):\r\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku(\r\n        ) if not self.hwsku else (self.platform, self.hwsku)\r\n        return self.hwsku\r\n\r\n    def run_command(self, command):\r\n        status = False\r\n        output = \"\"\r\n        try:\r\n            p = subprocess.Popen(\r\n                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n            raw_data, err = p.communicate()\r\n            if p.returncode == 0:\r\n                status, output = True, raw_data.strip()\r\n        except Exception:\r\n            pass\r\n        return status, output\r\n\r\n    def _clean_input(self, input, config):\r\n        cleaned_input = input\r\n\r\n        ai = config.get('avaliable_input')\r\n        if ai and input not in ai:\r\n            return None\r\n\r\n        input_translator = config.get('input_translator')\r\n        if type(input_translator) is dict:\r\n            cleaned_input = input_translator.get(input)\r\n\r\n        elif type(input_translator) is str:\r\n            cleaned_input = eval(input_translator.format(input))\r\n\r\n        return cleaned_input\r\n\r\n    def _clean_output(self, index, output, config):\r\n        output_translator = config.get('output_translator')\r\n\r\n        if type(output_translator) is dict:\r\n            output = output_translator.get(output)\r\n        elif type(output_translator) is str:\r\n            output = eval(output_translator.format(output))\r\n        elif type(output_translator) is list:\r\n            output = eval(output_translator[index].format(output))\r\n\r\n        return output\r\n\r\n    def _ipmi_get(self, index, config):\r\n        argument = config.get('argument')\r\n        cmd = config['command'].format(\r\n            config['argument'][index]) if argument else config['command']\r\n        status, output = self.run_command(cmd)\r\n        return output if status else None\r\n\r\n    def _sysfs_read(self, index, config):\r\n        sysfs_path = config.get('sysfs_path')\r\n        argument = config.get('argument', '')\r\n\r\n        if self.REF_KEY in argument:\r\n            argument = self._main_conf[argument.split(\":\")[1]]\r\n\r\n        if type(argument) is list:\r\n            sysfs_path = sysfs_path.format(argument[index])\r\n\r\n        content = \"\"\r\n        try:\r\n            content = open(sysfs_path)\r\n            content = content.readline().rstrip()\r\n        except IOError as e:\r\n            print(\"Error: unable to open file: %s\" % str(e))\r\n            return False\r\n\r\n        return content\r\n\r\n    def _sysfs_write(self, index, config, input):\r\n        sysfs_path = config.get('sysfs_path')\r\n        argument = config.get('argument', '')\r\n\r\n        if self.REF_KEY in argument:\r\n            argument = self._main_conf[argument.split(\":\")[1]]\r\n\r\n        if type(argument) is list:\r\n            sysfs_path = sysfs_path.format(argument[index])\r\n\r\n        write_offset = int(config.get('write_offset', 0))\r\n        output = \"\"\r\n        try:\r\n            open_file = open(sysfs_path, \"r+\")\r\n            open_file.seek(write_offset)\r\n            open_file.write(input)\r\n            open_file.close()\r\n        except IOError as e:\r\n            print(\"Error: unable to open file: %s\" % str(e))\r\n            return False, output\r\n        return True, output\r\n\r\n    def _ipmi_set(self, index, config, input):\r\n        arg = config['argument'][index].format(input)\r\n        return self.run_command(config['command'].format(arg))\r\n\r\n    def _hex_ver_decode(self, hver, num_of_bits, num_of_points):\r\n        ver_list = []\r\n        c_bit = 0\r\n        bin_val = bin(int(hver, 16))[2:].zfill(num_of_bits)\r\n        bit_split = num_of_bits / (num_of_points + 1)\r\n        for x in range(0, num_of_points+1):\r\n            split_bin = bin_val[c_bit:c_bit+bit_split]\r\n            ver_list.append(str(int(split_bin, 2)))\r\n            c_bit += bit_split\r\n        return '.'.join(ver_list)\r\n\r\n    def _get_class(self, config):\r\n        \"\"\"\r\n        Retreives value of expected attribute\r\n        Returns:\r\n            A value of the attribute of object\r\n        \"\"\"\r\n        path = config['host_path'] if self.is_host() else config['pmon_path']\r\n        module = imp.load_source(config['class'], path)\r\n        class_ = getattr(module, config['class'])\r\n        return class_\r\n\r\n    def get_reg(self, path, reg_addr):\r\n        cmd = \"echo {1} > {0}; cat {0}\".format(path, reg_addr)\r\n        status, output = self.run_command(cmd)\r\n        return output if status else None\r\n\r\n    def set_reg(self, path, reg_addr, value):\r\n        cmd = \"echo {0} {1} > {2}\".format(reg_addr, value, path)\r\n        status, output = self.run_command(cmd)\r\n        return output if status else None\r\n\r\n    def read_txt_file(self, path):\r\n        try:\r\n            with open(path, 'r') as f:\r\n                output = f.readline()\r\n            return output.strip('\\n')\r\n        except Exception:\r\n            pass\r\n        return ''\r\n\r\n    def read_one_line_file(self, file_path):\r\n        try:\r\n            with open(file_path, 'r') as fd:\r\n                data = fd.readline()\r\n                return data.strip()\r\n        except IOError:\r\n            pass\r\n        return ''\r\n\r\n    def write_txt_file(self, file_path, value):\r\n        try:\r\n            with open(file_path, 'w') as fd:\r\n                fd.write(str(value))\r\n        except Exception:\r\n            return False\r\n        return True\r\n\r\n    def is_host(self):\r\n        return os.system(self.HOST_CHK_CMD) == 0\r\n\r\n    def load_json_file(self, path):\r\n        \"\"\"\r\n        Retrieves the json object from json file path\r\n\r\n        Returns:\r\n            A json object\r\n        \"\"\"\r\n        with open(path, 'r') as f:\r\n            json_data = yaml.safe_load(f)\r\n\r\n        return json_data\r\n\r\n    def get_config_path(self, config_name):\r\n        \"\"\"\r\n        Retrieves the path to platform api config directory\r\n\r\n        Args:\r\n            config_name: A string containing the name of config file.\r\n\r\n        Returns:\r\n            A string containing the path to json file\r\n        \"\"\"\r\n        return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\r\n\r\n    def get_output(self, index, config, default):\r\n        \"\"\"\r\n        Retrieves the output for each function base on config\r\n\r\n        Args:\r\n            index: An integer containing the index of device.\r\n            config: A dict object containing the configuration of specified function.\r\n            default: A string containing the default output of specified function.\r\n\r\n        Returns:\r\n            A string containing the output of specified function in config\r\n        \"\"\"\r\n        output_source = config.get('output_source')\r\n\r\n        if output_source == self.OUTPUT_SOURCE_IPMI:\r\n            output = self._ipmi_get(index, config)\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VALUE:\r\n            output = config[\"value\"]\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_CLASS:\r\n            output = self._get_class(config)\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_LIST:\r\n            output = config[\"value_list\"][index]\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_SYSFS:\r\n            output = self._sysfs_read(index, config)\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_FUNC:\r\n            func_conf = self._main_conf[config['function'][index]]\r\n            output = self.get_output(index, func_conf, default)\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\r\n            path = config.get('path')\r\n            output = self.read_txt_file(path)\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\r\n            path = config.get('path')\r\n            hex_ver = self.read_txt_file(path)\r\n            output = self._hex_ver_decode(\r\n                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\r\n            path = config.get('path')\r\n            addr = config.get('reg_addr')\r\n            hex_ver = self.get_reg(path, addr)\r\n            output = self._hex_ver_decode(\r\n                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n\r\n        else:\r\n            output = default\r\n\r\n        return self._clean_output(index, output, config) or default\r\n\r\n    def set_output(self, index, input, config):\r\n        \"\"\"\r\n        Sets the output of specified function on config\r\n\r\n        Args:\r\n            config: A dict object containing the configuration of specified function.\r\n            index: An integer containing the index of device.\r\n            input: A string containing the input of specified function.\r\n\r\n        Returns:\r\n            bool: True if set function is successfully, False if not\r\n        \"\"\"\r\n        cleaned_input = self._clean_input(input, config)\r\n        if not cleaned_input:\r\n            return False\r\n\r\n        set_method = config.get('set_method')\r\n        if set_method == self.SET_METHOD_IPMI:\r\n            output = self._ipmi_set(index, config, cleaned_input)[0]\r\n        elif set_method == self.OUTPUT_SOURCE_SYSFS:\r\n            output = self._sysfs_write(index, config, cleaned_input)[0]\r\n        else:\r\n            output = False\r\n\r\n        return output\r\n\r\n    def get_event(self, timeout, config, sfp_list):\r\n        \"\"\"\r\n        Returns a nested dictionary containing all devices which have\r\n        experienced a change at chassis level\r\n\r\n        \"\"\"\r\n        event_class = self._get_class(config)\r\n        return event_class(sfp_list).get_event(timeout)\r\n"}, "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py": {"changes": [{"diff": "\n try:\n     import os.path\n     import shutil\n-    import shlex\n     import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n except ImportError as e:\n", "add": 0, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py", "badparts": ["    import shlex"], "goodparts": []}, {"diff": "\n     def __run_command(self, command):\n         # Run bash command and print output to stdout\n         try:\n-            process = subprocess.Popen(\n-                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n+            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n             while True:\n                 output = process.stdout.readline()\n                 if output == '' and process.poll() is not None:\n", "add": 1, "remove": 2, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py", "badparts": ["            process = subprocess.Popen(", "                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)"], "goodparts": ["            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)"]}, {"diff": "\n \n     def get_register_value(self, register):\n         # Retrieves the cpld register value\n-        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n-        p = subprocess.Popen(\n-            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-        raw_data, err = p.communicate()\n-        if err is not '':\n-            return None\n+        with open(GETREG_PATH, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(GETREG_PATH, 'r') as file:\n+            raw_data = file.readline()\n         return raw_data.strip()\n \n     def __get_cpld_version(self):\n", "add": 4, "remove": 6, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py", "badparts": ["        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)", "        p = subprocess.Popen(", "            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "        raw_data, err = p.communicate()", "        if err is not '':", "            return None"], "goodparts": ["        with open(GETREG_PATH, 'w') as file:", "            file.write(register + '\\n')", "        with open(GETREG_PATH, 'r') as file:", "            raw_data = file.readline()"]}, {"diff": "\n         cpld_version = dict()\n         with open(SMC_CPLD_PATH, 'r') as fd:\n             smc_cpld_version = fd.read()\n-        smc_cpld_version = 'None' if smc_cpld_version is 'None' else \"{}.{}\".format(\n+        smc_cpld_version = 'None' if smc_cpld_version == 'None' else \"{}.{}\".format(\n             int(smc_cpld_version[2], 16), int(smc_cpld_version[3], 16))\n \n         mmc_cpld_version = self.get_register_value(MMC_CPLD_ADDR)\n-        mmc_cpld_version = 'None' if mmc_cpld_version is 'None' else \"{}.{}\".format(\n+        mmc_cpld_version = 'None' if mmc_cpld_version == 'None' else \"{}.{}\".format(\n             int(mmc_cpld_version[2], 16), int(mmc_cpld_version[3], 16))\n \n         cpld_version[\"SMC_CPLD\"] = smc_cpld_version\n", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py", "badparts": ["        smc_cpld_version = 'None' if smc_cpld_version is 'None' else \"{}.{}\".format(", "        mmc_cpld_version = 'None' if mmc_cpld_version is 'None' else \"{}.{}\".format("], "goodparts": ["        smc_cpld_version = 'None' if smc_cpld_version == 'None' else \"{}.{}\".format(", "        mmc_cpld_version = 'None' if mmc_cpld_version == 'None' else \"{}.{}\".format("]}, {"diff": "\n             ext = \".vme\" if ext == \"\" else ext\n             new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n             shutil.copy(image_path, new_image_path)\n-            install_command = \"ispvm %s\" % new_image_path\n+            install_command = [\"ispvm\", str(new_image_path)]\n         # elif self.name == \"BIOS\":\n         #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n         return self.__run_command(install_comman", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py", "badparts": ["            install_command = \"ispvm %s\" % new_image_path"], "goodparts": ["            install_command = [\"ispvm\", str(new_image_path)]"]}], "source": "\n try: import os.path import shutil import shlex import subprocess from sonic_platform_base.component_base import ComponentBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") MMC_CPLD_ADDR='0x100' BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" CONFIG_DB_PATH=\"/etc/sonic/config_db.json\" SMC_CPLD_PATH=\"/sys/devices/platform/e1031.smc/version\" GETREG_PATH=\"/sys/devices/platform/e1031.smc/getreg\" COMPONENT_NAME_LIST=[\"SMC_CPLD\", \"MMC_CPLD\", \"BIOS\"] COMPONENT_DES_LIST=[\"System Management Controller\", \"Module Management CPLD\", \"Basic Input/Output System\"] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index): ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def get_register_value(self, register): cmd=\"echo{1} >{0}; cat{0}\".format(GETREG_PATH, register) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err is not '': return None return raw_data.strip() def __get_cpld_version(self): cpld_version=dict() with open(SMC_CPLD_PATH, 'r') as fd: smc_cpld_version=fd.read() smc_cpld_version='None' if smc_cpld_version is 'None' else \"{}.{}\".format( int(smc_cpld_version[2], 16), int(smc_cpld_version[3], 16)) mmc_cpld_version=self.get_register_value(MMC_CPLD_ADDR) mmc_cpld_version='None' if mmc_cpld_version is 'None' else \"{}.{}\".format( int(mmc_cpld_version[2], 16), int(mmc_cpld_version[3], 16)) cpld_version[\"SMC_CPLD\"]=smc_cpld_version cpld_version[\"MMC_CPLD\"]=mmc_cpld_version return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_NAME_LIST[self.index] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_DES_LIST[self.index] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def get_available_firmware_version(self, image_path): \"\"\" Retrieves the available firmware version of the component Note: the firmware version will be read from image Args: image_path: A string, path to firmware image Returns: A string containing the available firmware version of the component \"\"\" return \"N/A\" def get_firmware_update_notification(self, image_path): \"\"\" Retrieves a notification on what should be done in order to complete the component firmware update Args: image_path: A string, path to firmware image Returns: A string containing the component firmware update notification if required. By default 'None' value will be used, which indicates that no actions are required \"\"\" return \"None\" def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" if not os.path.isfile(image_path): return False if \"CPLD\" in self.name: img_name=os.path.basename(image_path) root, ext=os.path.splitext(img_name) ext=\".vme\" if ext==\"\" else ext new_image_path=os.path.join(\"/tmp\",(root.lower() +ext)) shutil.copy(image_path, new_image_path) install_command=\"ispvm %s\" % new_image_path return self.__run_command(install_command) def update_firmware(self, image_path): \"\"\" Updates firmware of the component This API performs firmware update: it assumes firmware installation and loading in a single call. In case platform component requires some extra steps(apart from calling Low Level Utility) to load the installed firmware(e.g, reboot, power cycle, etc.) -this will be done automatically by API Args: image_path: A string, path to firmware image Raises: RuntimeError: update failed \"\"\" return False def get_presence(self): \"\"\" Retrieves the presence of the FAN Returns: bool: True if FAN is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return 'N/A' def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return 'N/A' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is'0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\n\ntry:\n    import os.path\n    import shutil\n    import shlex\n    import subprocess\n    from sonic_platform_base.component_base import ComponentBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nMMC_CPLD_ADDR = '0x100'\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCONFIG_DB_PATH = \"/etc/sonic/config_db.json\"\nSMC_CPLD_PATH = \"/sys/devices/platform/e1031.smc/version\"\nGETREG_PATH = \"/sys/devices/platform/e1031.smc/getreg\"\nCOMPONENT_NAME_LIST = [\"SMC_CPLD\", \"MMC_CPLD\", \"BIOS\"]\nCOMPONENT_DES_LIST = [\"System Management Controller\",\n                      \"Module Management CPLD\", \"Basic Input/Output System\"]\n\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index):\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def get_register_value(self, register):\n        # Retrieves the cpld register value\n        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n        p = subprocess.Popen(\n            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        raw_data, err = p.communicate()\n        if err is not '':\n            return None\n        return raw_data.strip()\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        with open(SMC_CPLD_PATH, 'r') as fd:\n            smc_cpld_version = fd.read()\n        smc_cpld_version = 'None' if smc_cpld_version is 'None' else \"{}.{}\".format(\n            int(smc_cpld_version[2], 16), int(smc_cpld_version[3], 16))\n\n        mmc_cpld_version = self.get_register_value(MMC_CPLD_ADDR)\n        mmc_cpld_version = 'None' if mmc_cpld_version is 'None' else \"{}.{}\".format(\n            int(mmc_cpld_version[2], 16), int(mmc_cpld_version[3], 16))\n\n        cpld_version[\"SMC_CPLD\"] = smc_cpld_version\n        cpld_version[\"MMC_CPLD\"] = mmc_cpld_version\n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_NAME_LIST[self.index]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_DES_LIST[self.index]\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def get_available_firmware_version(self, image_path):\n        \"\"\"\n        Retrieves the available firmware version of the component\n        Note: the firmware version will be read from image\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A string containing the available firmware version of the component\n        \"\"\"\n        return \"N/A\"\n\n    def get_firmware_update_notification(self, image_path):\n        \"\"\"\n        Retrieves a notification on what should be done in order to complete\n        the component firmware update\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A string containing the component firmware update notification if required.\n            By default 'None' value will be used, which indicates that no actions are required\n        \"\"\"\n        return \"None\"\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        if not os.path.isfile(image_path):\n            return False\n\n        if \"CPLD\" in self.name:\n            img_name = os.path.basename(image_path)\n            root, ext = os.path.splitext(img_name)\n            ext = \".vme\" if ext == \"\" else ext\n            new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n            shutil.copy(image_path, new_image_path)\n            install_command = \"ispvm %s\" % new_image_path\n        # elif self.name == \"BIOS\":\n        #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n        return self.__run_command(install_command)\n\n    def update_firmware(self, image_path):\n        \"\"\"\n        Updates firmware of the component\n        This API performs firmware update: it assumes firmware installation and loading in a single call.\n        In case platform component requires some extra steps (apart from calling Low Level Utility)\n        to load the installed firmware (e.g, reboot, power cycle, etc.) - this will be done automatically by API\n        Args:\n            image_path: A string, path to firmware image\n        Raises:\n            RuntimeError: update failed\n        \"\"\"\n        return False\n\n    ##############################################################\n    ###################### Device methods ########################\n    ##############################################################\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the FAN\n        Returns:\n            bool: True if FAN is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of\n        entPhysicalContainedIn is'0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device\n            or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py": {"changes": [{"diff": "\n         thermal_overload_position = Common().read_txt_file(\r\n             thermal_overload_position_path)\r\n \r\n-        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\r\n-            thermal_overload_position)\r\n+        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', thermal_overload_position]\r\n         Common().run_command(cm", "add": 1, "remove": 2, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py", "badparts": ["        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\r", "            thermal_overload_position)\r"], "goodparts": ["        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', thermal_overload_position]\r"]}], "source": "\nfrom sonic_platform_base.sonic_thermal_control.thermal_action_base import ThermalPolicyActionBase\r from sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object\r from.thermal_infos import ChassisInfo\r from.common import Common\r \r \r @thermal_json_object('thermal_control.control')\r class ControlThermalAlgoAction(ThermalPolicyActionBase):\r \"\"\"\r Action to control the thermal control algorithm\r \"\"\"\r JSON_FIELD_STATUS='status'\r \r def __init__(self):\r self.status=True\r \r def load_from_json(self, json_obj):\r \"\"\"\r Construct ControlThermalAlgoAction via JSON. JSON example:\r {\r \"type\": \"thermal_control.control\"\r \"status\": \"true\"\r }\r :param json_obj: A JSON object representing a ControlThermalAlgoAction action.\r :return:\r \"\"\"\r if ControlThermalAlgoAction.JSON_FIELD_STATUS in json_obj:\r status_str=json_obj[ControlThermalAlgoAction.JSON_FIELD_STATUS].lower(\r )\r if status_str=='true':\r self.status=True\r elif status_str=='false':\r self.status=False\r else:\r raise ValueError('Invalid{} field value, please specify true of false'.\r format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\r else:\r raise ValueError('ControlThermalAlgoAction '\r 'missing mandatory field{} in JSON policy file'.\r format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\r \r def execute(self, thermal_info_dict):\r \"\"\"\r Disable thermal control algorithm\r :param thermal_info_dict: A dictionary stores all thermal information.\r :return:\r \"\"\"\r if ChassisInfo.INFO_NAME in thermal_info_dict:\r chassis_info_obj=thermal_info_dict[ChassisInfo.INFO_NAME]\r chassis=chassis_info_obj.get_chassis()\r thermal_manager=chassis.get_thermal_manager()\r if self.status:\r thermal_manager.start_thermal_control_algorithm()\r else:\r thermal_manager.stop_thermal_control_algorithm()\r \r \r @thermal_json_object('switch.power_cycling')\r class SwitchPolicyAction(ThermalPolicyActionBase):\r \"\"\"\r Base class for thermal action. Once all thermal conditions in a thermal policy are matched,\r all predefined thermal action will be executed.\r \"\"\"\r \r def execute(self, thermal_info_dict):\r \"\"\"\r Take action when thermal condition matches. For example, power cycle the switch.\r :param thermal_info_dict: A dictionary stores all thermal information.\r :return:\r \"\"\"\r thermal_overload_position_path='/tmp/thermal_overload_position'\r thermal_overload_position=Common().read_txt_file(\r thermal_overload_position_path)\r \r cmd='bash /usr/share/sonic/platform/thermal_overload_control.sh{}'.format(\r thermal_overload_position)\r Common().run_command(cmd)\r ", "sourceWithComments": "from sonic_platform_base.sonic_thermal_control.thermal_action_base import ThermalPolicyActionBase\r\nfrom sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object\r\nfrom .thermal_infos import ChassisInfo\r\nfrom .common import Common\r\n\r\n\r\n@thermal_json_object('thermal_control.control')\r\nclass ControlThermalAlgoAction(ThermalPolicyActionBase):\r\n    \"\"\"\r\n    Action to control the thermal control algorithm\r\n    \"\"\"\r\n    # JSON field definition\r\n    JSON_FIELD_STATUS = 'status'\r\n\r\n    def __init__(self):\r\n        self.status = True\r\n\r\n    def load_from_json(self, json_obj):\r\n        \"\"\"\r\n        Construct ControlThermalAlgoAction via JSON. JSON example:\r\n            {\r\n                \"type\": \"thermal_control.control\"\r\n                \"status\": \"true\"\r\n            }\r\n        :param json_obj: A JSON object representing a ControlThermalAlgoAction action.\r\n        :return:\r\n        \"\"\"\r\n        if ControlThermalAlgoAction.JSON_FIELD_STATUS in json_obj:\r\n            status_str = json_obj[ControlThermalAlgoAction.JSON_FIELD_STATUS].lower(\r\n            )\r\n            if status_str == 'true':\r\n                self.status = True\r\n            elif status_str == 'false':\r\n                self.status = False\r\n            else:\r\n                raise ValueError('Invalid {} field value, please specify true of false'.\r\n                                 format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\r\n        else:\r\n            raise ValueError('ControlThermalAlgoAction '\r\n                             'missing mandatory field {} in JSON policy file'.\r\n                             format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\r\n\r\n    def execute(self, thermal_info_dict):\r\n        \"\"\"\r\n        Disable thermal control algorithm\r\n        :param thermal_info_dict: A dictionary stores all thermal information.\r\n        :return:\r\n        \"\"\"\r\n        if ChassisInfo.INFO_NAME in thermal_info_dict:\r\n            chassis_info_obj = thermal_info_dict[ChassisInfo.INFO_NAME]\r\n            chassis = chassis_info_obj.get_chassis()\r\n            thermal_manager = chassis.get_thermal_manager()\r\n            if self.status:\r\n                thermal_manager.start_thermal_control_algorithm()\r\n            else:\r\n                thermal_manager.stop_thermal_control_algorithm()\r\n\r\n\r\n@thermal_json_object('switch.power_cycling')\r\nclass SwitchPolicyAction(ThermalPolicyActionBase):\r\n    \"\"\"\r\n    Base class for thermal action. Once all thermal conditions in a thermal policy are matched,\r\n    all predefined thermal action will be executed.\r\n    \"\"\"\r\n\r\n    def execute(self, thermal_info_dict):\r\n        \"\"\"\r\n        Take action when thermal condition matches. For example, power cycle the switch.\r\n        :param thermal_info_dict: A dictionary stores all thermal information.\r\n        :return:\r\n        \"\"\"\r\n        thermal_overload_position_path = '/tmp/thermal_overload_position'\r\n        thermal_overload_position = Common().read_txt_file(\r\n            thermal_overload_position_path)\r\n\r\n        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\r\n            thermal_overload_position)\r\n        Common().run_command(cmd)\r\n"}, "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py": {"changes": [{"diff": "\n \n \n class ThermalManager(ThermalManagerBase):\n-    FSC_ALGORITHM_CMD = ' supervisorctl {} fancontrol'\n+    FSC_ALGORITHM_CMD = ['supervisorctl', '', 'fancontrol']\n \n     @classmethod\n     def start_thermal_control_algorithm(cls):\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py", "badparts": ["    FSC_ALGORITHM_CMD = ' supervisorctl {} fancontrol'"], "goodparts": ["    FSC_ALGORITHM_CMD = ['supervisorctl', '', 'fancontrol']"]}, {"diff": "\n         Returns:\n             bool: True if set success, False if fail.\n         \"\"\"\n-        cmd = 'start' if enable else 'stop'\n-        return Common().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n+        cls.FSC_ALGORITHM_CMD[1] = 'start' if enable else 'stop'\n+        return Common().run_command(cls.FSC_ALGORITHM_", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py", "badparts": ["        cmd = 'start' if enable else 'stop'", "        return Common().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))"], "goodparts": ["        cls.FSC_ALGORITHM_CMD[1] = 'start' if enable else 'stop'", "        return Common().run_command(cls.FSC_ALGORITHM_"]}], "source": "\nfrom sonic_platform_base.sonic_thermal_control.thermal_manager_base import ThermalManagerBase from.common import Common from.thermal_actions import * from.thermal_conditions import * from.thermal_infos import * class ThermalManager(ThermalManagerBase): FSC_ALGORITHM_CMD=' supervisorctl{} fancontrol' @classmethod def start_thermal_control_algorithm(cls): \"\"\" Start vendor specific thermal control algorithm. The default behavior of this function is a no-op. :return: \"\"\" return cls._enable_fancontrol_service(True) @classmethod def stop_thermal_control_algorithm(cls): \"\"\" Stop thermal control algorithm Returns: bool: True if set success, False if fail. \"\"\" return cls._enable_fancontrol_service(False) @classmethod def deinitialize(cls): \"\"\" Destroy thermal manager, including any vendor specific cleanup. The default behavior of this function is a no-op. :return: \"\"\" return cls._enable_fancontrol_service(True) @classmethod def _enable_fancontrol_service(cls, enable): \"\"\" Control thermal by fcs algorithm Args: enable: Bool, indicate enable the algorithm or not Returns: bool: True if set success, False if fail. \"\"\" cmd='start' if enable else 'stop' return Common().run_command(cls.FSC_ALGORITHM_CMD.format(cmd)) ", "sourceWithComments": "from sonic_platform_base.sonic_thermal_control.thermal_manager_base import ThermalManagerBase\nfrom .common import Common\nfrom .thermal_actions import *\nfrom .thermal_conditions import *\nfrom .thermal_infos import *\n\n\nclass ThermalManager(ThermalManagerBase):\n    FSC_ALGORITHM_CMD = ' supervisorctl {} fancontrol'\n\n    @classmethod\n    def start_thermal_control_algorithm(cls):\n        \"\"\"\n        Start vendor specific thermal control algorithm. The default behavior of this function is a no-op.\n        :return:\n        \"\"\"\n        return cls._enable_fancontrol_service(True)\n\n    @classmethod\n    def stop_thermal_control_algorithm(cls):\n        \"\"\"\n        Stop thermal control algorithm\n        Returns:\n            bool: True if set success, False if fail.\n        \"\"\"\n        return cls._enable_fancontrol_service(False)\n\n    @classmethod\n    def deinitialize(cls):\n        \"\"\"\n        Destroy thermal manager, including any vendor specific cleanup. The default behavior of this function\n        is a no-op.\n        :return:\n        \"\"\"\n        return cls._enable_fancontrol_service(True)\n\n    @classmethod\n    def _enable_fancontrol_service(cls, enable):\n        \"\"\"\n        Control thermal by fcs algorithm\n        Args:\n            enable: Bool, indicate enable the algorithm or not\n        Returns:\n            bool: True if set success, False if fail.\n        \"\"\"\n        cmd = 'start' if enable else 'stop'\n        return Common().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n"}, "/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import os.path\n-import subprocess\n \n try:\n     from sonic_psu.psu_base import Ps", "add": 0, "remove": 2, "filename": "/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py", "badparts": ["import subprocess"], "goodparts": []}], "source": "\n import os.path import subprocess try: from sonic_psu.psu_base import PsuBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class PsuUtil(PsuBase): \"\"\"Platform-specific PSUutil class\"\"\" def __init__(self): PsuBase.__init__(self) def get_num_psus(self): \"\"\" Retrieves the number of PSUs available on the device :return: An integer, the number of PSUs available on the device \"\"\" return 2 def get_psu_status(self, index): \"\"\" Retrieves the oprational status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is operating properly, False if PSU is faulty \"\"\" if index is None: return False status=1 return status==1 def get_psu_presence(self, index): \"\"\" Retrieves the presence status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is plugged, False if not \"\"\" if index is None: return False status=1 return status==1 ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Module contains an implementation of SONiC PSU Base API and\n# provides the PSUs status which are available in the platform\n#\n#############################################################################\n\nimport os.path\nimport subprocess\n\ntry:\n    from sonic_psu.psu_base import PsuBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass PsuUtil(PsuBase):\n    \"\"\"Platform-specific PSUutil class\"\"\"\n\n    def __init__(self):\n        PsuBase.__init__(self)\n\n    def get_num_psus(self):\n        \"\"\"\n        Retrieves the number of PSUs available on the device\n\n        :return: An integer, the number of PSUs available on the device\n        \"\"\"\n        return 2\n\n    def get_psu_status(self, index):\n        \"\"\"\n        Retrieves the oprational status of power supply unit (PSU) defined\n                by 1-based index <index>\n\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is operating properly, False if PSU is faulty\n        \"\"\"\n        if index is None:\n            return False\n\n        status = 1\n        return status == 1\n\n    def get_psu_presence(self, index):\n        \"\"\"\n        Retrieves the presence status of power supply unit (PSU) defined\n                by 1-based index <index>\n\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is plugged, False if not\n        \"\"\"\n        if index is None:\n            return False\n\n        status = 1\n        return status == 1\n"}, "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n GETREG_PATH = \"/sys/devices/platform/dx010_cpld/getreg\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n STATUS_LED_PATH = \"/sys/devices/platform/leds_dx010/leds/dx010:green:stat/brightnes", "add": 0, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": []}], "source": "\n try: import sys from sonic_platform_base.chassis_base import ChassisBase from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper from sonic_py_common import device_info from.event import SfpEvent from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=5 NUM_PSU=2 NUM_THERMAL=5 NUM_SFP=32 NUM_COMPONENT=5 RESET_REGISTER=\"0x103\" HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" GETREG_PATH=\"/sys/devices/platform/dx010_cpld/getreg\" HOST_CHK_CMD=\"docker > /dev/null 2>&1\" STATUS_LED_PATH=\"/sys/devices/platform/leds_dx010/leds/dx010:green:stat/brightness\" class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self.sfp_module_initialized=False self.__initialize_eeprom() self.is_host=self._api_helper.is_host() self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() def __initialize_sfp(self): sfputil_helper=SfpUtilHelper() port_config_file_path=device_info.get_path_to_port_config_file() sfputil_helper.read_porttab_mappings(port_config_file_path, 0) from sonic_platform.sfp import Sfp for index in range(0, NUM_SFP): sfp=Sfp(index, sfputil_helper.logical[index]) self._sfp_list.append(sfp) self.sfp_module_initialized=True def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for i in range(NUM_FAN_TRAY): fandrawer=FanDrawer(i) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_thermals(self): from sonic_platform.thermal import Thermal airflow=self.__get_air_flow() for index in range(0, NUM_THERMAL): thermal=Thermal(index, airflow) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __get_air_flow(self): air_flow_path='/usr/share/sonic/device/{}/fan_airflow'.format( self._api_helper.platform) \\ if self.is_host else '/usr/share/sonic/platform/fan_airflow' air_flow=self._api_helper.read_one_line_file(air_flow_path) return air_flow or 'B2F' def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. REBOOT_CAUSE_POWER_LOSS=\"Power Loss\" REBOOT_CAUSE_THERMAL_OVERLOAD_CPU=\"Thermal Overload: CPU\" REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC=\"Thermal Overload: ASIC\" REBOOT_CAUSE_THERMAL_OVERLOAD_OTHER=\"Thermal Overload: Other\" REBOOT_CAUSE_INSUFFICIENT_FAN_SPEED=\"Insufficient Fan Speed\" REBOOT_CAUSE_WATCHDOG=\"Watchdog\" REBOOT_CAUSE_HARDWARE_OTHER=\"Hardware -Other\" REBOOT_CAUSE_NON_HARDWARE=\"Non-Hardware\" \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" hw_reboot_cause=self._api_helper.get_cpld_reg_value( GETREG_PATH, RESET_REGISTER) prev_reboot_cause={ '0x11':(self.REBOOT_CAUSE_POWER_LOSS, 'Power on reset'), '0x22':(self.REBOOT_CAUSE_HARDWARE_OTHER, 'CPLD_WD_RESET'), '0x33':(self.REBOOT_CAUSE_HARDWARE_OTHER, 'Power cycle reset triggered by CPU'), '0x44':(self.REBOOT_CAUSE_HARDWARE_OTHER, 'Power cycle reset triggered by reset button'), '0x55':(self.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU, ''), '0x66':(self.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC, ''), '0x77':(self.REBOOT_CAUSE_WATCHDOG, '') }.get(hw_reboot_cause,(self.REBOOT_CAUSE_HARDWARE_OTHER, 'Unknown reason')) if sw_reboot_cause !='Unknown' and hw_reboot_cause=='0x11': prev_reboot_cause=( self.REBOOT_CAUSE_NON_HARDWARE, sw_reboot_cause) return prev_reboot_cause def get_change_event(self, timeout=0): \"\"\" Returns a nested dictionary containing all devices which have experienced a change at chassis level Args: timeout: Timeout in milliseconds(optional). If timeout==0, this method will block until a change is detected. Returns: (bool, dict): -True if call successful, False if not; -A nested dictionary where key is a device type, value is a dictionary with key:value pairs in the format of {'device_id':'device_event'}, where device_id is the device ID for this device and device_event, status='1' represents device inserted, status='0' represents device removed. Ex.{'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}} indicates that fan 0 has been removed, fan 2 has been inserted and sfp 11 has been removed. \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() sfp_event=SfpEvent(self._sfp_list).get_sfp_event(timeout) if sfp_event: return True,{'sfp': sfp_event} return False,{'sfp':{}} def get_num_sfps(self): \"\"\" Retrieves the number of sfps available on this chassis Returns: An integer, the number of sfps available on this chassis \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() return len(self._sfp_list) def get_all_sfps(self): \"\"\" Retrieves all sfps available on this chassis Returns: A list of objects derived from SfpBase representing all sfps available on this chassis \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfp_list def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index -1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_watchdog(self): \"\"\" Retreives hardware watchdog device on this chassis Returns: An object derived from WatchdogBase representing the hardware watchdog device \"\"\" if self._watchdog is None: from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() return self._watchdog def get_thermal_manager(self): from.thermal_manager import ThermalManager return ThermalManager def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._api_helper.hwsku def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return self._eeprom.get_serial() def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def set_status_led(self, color): \"\"\" Sets the state of the PSU status LED Args: color: A string representing the color with which to set the PSU status LED Note: Only support green and off Returns: bool: True if status LED state is set successfully, False if not \"\"\" set_status_str={ self.STATUS_LED_COLOR_GREEN: '1', self.STATUS_LED_COLOR_OFF: '0' }.get(color, None) if not set_status_str: return False return self._api_helper.write_txt_file(STATUS_LED_PATH, set_status_str) def get_status_led(self): \"\"\" Gets the state of the PSU status LED Returns: A string, one of the predefined STATUS_LED_COLOR_* strings above \"\"\" status=self._api_helper.read_txt_file(STATUS_LED_PATH) status_str={ '255': self.STATUS_LED_COLOR_GREEN, '0': self.STATUS_LED_COLOR_OFF }.get(status, None) return status_str ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\ntry:\n    import sys\n    from sonic_platform_base.chassis_base import ChassisBase\n    from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper\n    from sonic_py_common import device_info\n    from .event import SfpEvent\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 5\nNUM_PSU = 2\nNUM_THERMAL = 5\nNUM_SFP = 32\nNUM_COMPONENT = 5\nRESET_REGISTER = \"0x103\"\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nGETREG_PATH = \"/sys/devices/platform/dx010_cpld/getreg\"\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nSTATUS_LED_PATH = \"/sys/devices/platform/leds_dx010/leds/dx010:green:stat/brightness\"\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self.sfp_module_initialized = False\n        self.__initialize_eeprom()\n        self.is_host = self._api_helper.is_host()\n\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n\n    def __initialize_sfp(self):\n        sfputil_helper = SfpUtilHelper()\n        port_config_file_path = device_info.get_path_to_port_config_file()\n        sfputil_helper.read_porttab_mappings(port_config_file_path, 0)\n\n        from sonic_platform.sfp import Sfp\n        for index in range(0, NUM_SFP):\n            sfp = Sfp(index, sfputil_helper.logical[index])\n            self._sfp_list.append(sfp)\n        self.sfp_module_initialized = True\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_fan(self):\n        from sonic_platform.fan_drawer import FanDrawer\n        for i in range(NUM_FAN_TRAY):\n            fandrawer = FanDrawer(i)\n            self._fan_drawer_list.append(fandrawer)\n            self._fan_list.extend(fandrawer._fan_list)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        airflow = self.__get_air_flow()\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index, airflow)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __get_air_flow(self):\n        air_flow_path = '/usr/share/sonic/device/{}/fan_airflow'.format(\n            self._api_helper.platform) \\\n            if self.is_host else '/usr/share/sonic/platform/fan_airflow'\n        air_flow = self._api_helper.read_one_line_file(air_flow_path)\n        return air_flow or 'B2F'\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n\n            REBOOT_CAUSE_POWER_LOSS = \"Power Loss\"\n            REBOOT_CAUSE_THERMAL_OVERLOAD_CPU = \"Thermal Overload: CPU\"\n            REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC = \"Thermal Overload: ASIC\"\n            REBOOT_CAUSE_THERMAL_OVERLOAD_OTHER = \"Thermal Overload: Other\"\n            REBOOT_CAUSE_INSUFFICIENT_FAN_SPEED = \"Insufficient Fan Speed\"\n            REBOOT_CAUSE_WATCHDOG = \"Watchdog\"\n            REBOOT_CAUSE_HARDWARE_OTHER = \"Hardware - Other\"\n            REBOOT_CAUSE_NON_HARDWARE = \"Non-Hardware\"\n\n        \"\"\"\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n        hw_reboot_cause = self._api_helper.get_cpld_reg_value(\n            GETREG_PATH, RESET_REGISTER)\n\n        prev_reboot_cause = {\n            '0x11': (self.REBOOT_CAUSE_POWER_LOSS, 'Power on reset'),\n            '0x22': (self.REBOOT_CAUSE_HARDWARE_OTHER, 'CPLD_WD_RESET'),\n            '0x33': (self.REBOOT_CAUSE_HARDWARE_OTHER, 'Power cycle reset triggered by CPU'),\n            '0x44': (self.REBOOT_CAUSE_HARDWARE_OTHER, 'Power cycle reset triggered by reset button'),\n            '0x55': (self.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU, ''),\n            '0x66': (self.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC, ''),\n            '0x77': (self.REBOOT_CAUSE_WATCHDOG, '')\n        }.get(hw_reboot_cause, (self.REBOOT_CAUSE_HARDWARE_OTHER, 'Unknown reason'))\n\n        if sw_reboot_cause != 'Unknown' and hw_reboot_cause == '0x11':\n            prev_reboot_cause = (\n                self.REBOOT_CAUSE_NON_HARDWARE, sw_reboot_cause)\n\n        return prev_reboot_cause\n\n    def get_change_event(self, timeout=0):\n        \"\"\"\n        Returns a nested dictionary containing all devices which have\n        experienced a change at chassis level\n        Args:\n            timeout: Timeout in milliseconds (optional). If timeout == 0,\n                this method will block until a change is detected.\n        Returns:\n            (bool, dict):\n                - True if call successful, False if not;\n                - A nested dictionary where key is a device type,\n                  value is a dictionary with key:value pairs in the format of\n                  {'device_id':'device_event'},\n                  where device_id is the device ID for this device and\n                        device_event,\n                             status='1' represents device inserted,\n                             status='0' represents device removed.\n                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}\n                      indicates that fan 0 has been removed, fan 2\n                      has been inserted and sfp 11 has been removed.\n        \"\"\"\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        sfp_event = SfpEvent(self._sfp_list).get_sfp_event(timeout)\n        if sfp_event:\n            return True, {'sfp': sfp_event}\n\n        return False, {'sfp': {}}\n\n    ##############################################################\n    ######################## SFP methods #########################\n    ##############################################################\n\n    def get_num_sfps(self):\n        \"\"\"\n        Retrieves the number of sfps available on this chassis\n        Returns:\n            An integer, the number of sfps available on this chassis\n        \"\"\"\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return len(self._sfp_list)\n\n    def get_all_sfps(self):\n        \"\"\"\n        Retrieves all sfps available on this chassis\n        Returns:\n            A list of objects derived from SfpBase representing all sfps\n            available on this chassis\n        \"\"\"\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return self._sfp_list\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index - 1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    ##############################################################\n    ####################### Other methods ########################\n    ##############################################################\n\n    def get_watchdog(self):\n        \"\"\"\n        Retreives hardware watchdog device on this chassis\n        Returns:\n            An object derived from WatchdogBase representing the hardware\n            watchdog device\n        \"\"\"\n        if self._watchdog is None:\n            from sonic_platform.watchdog import Watchdog\n            self._watchdog = Watchdog()\n\n        return self._watchdog\n\n    def get_thermal_manager(self):\n        from .thermal_manager import ThermalManager\n        return ThermalManager\n\n    ##############################################################\n    ###################### Device methods ########################\n    ##############################################################\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return self._api_helper.hwsku\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the PSU status LED\n        Args:\n            color: A string representing the color with which to set the PSU status LED\n                   Note: Only support green and off\n        Returns:\n            bool: True if status LED state is set successfully, False if not\n        \"\"\"\n\n        set_status_str = {\n            self.STATUS_LED_COLOR_GREEN: '1',\n            self.STATUS_LED_COLOR_OFF: '0'\n        }.get(color, None)\n\n        if not set_status_str:\n            return False\n\n        return self._api_helper.write_txt_file(STATUS_LED_PATH, set_status_str)\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the PSU status LED\n        Returns:\n            A string, one of the predefined STATUS_LED_COLOR_* strings above\n        \"\"\"\n        status = self._api_helper.read_txt_file(STATUS_LED_PATH)\n        status_str = {\n            '255': self.STATUS_LED_COLOR_GREEN,\n            '0': self.STATUS_LED_COLOR_OFF\n        }.get(status, None)\n\n        return status_str\n"}, "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py": {"changes": [{"diff": "\n \n import os.path\n import shutil\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py", "badparts": ["import subprocess"], "goodparts": []}, {"diff": "\n \n     def get_register_value(self, register):\n         # Retrieves the cpld register value\n-        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n-        p = subprocess.Popen(\n-            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-        raw_data, err = p.communicate()\n-        if err is not '':\n-            return None\n+        with open(GETREG_PATH, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(GETREG_PATH, 'r') as file:\n+            raw_data = file.readline()\n         return raw_data.strip()\n \n     def __get_cpld_version(self):\n", "add": 4, "remove": 6, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py", "badparts": ["        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)", "        p = subprocess.Popen(", "            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "        raw_data, err = p.communicate()", "        if err is not '':", "            return None"], "goodparts": ["        with open(GETREG_PATH, 'w') as file:", "            file.write(register + '\\n')", "        with open(GETREG_PATH, 'r') as file:", "            raw_data = file.readline()"]}, {"diff": "\n             ext = \".vme\" if ext == \"\" else ext\n             new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n             shutil.copy(image_path, new_image_path)\n-            install_command = \"ispvm %s\" % new_image_path\n+            install_command = [\"ispvm\", str(new_image_path)]\n         # elif self.name == \"BIOS\":\n         #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n \n-        return self.__run_command(install_command)\n+        return self._api_helper.run_command(install_command)\n \n \n     def update_firmware(self, image", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py", "badparts": ["            install_command = \"ispvm %s\" % new_image_path", "        return self.__run_command(install_command)"], "goodparts": ["            install_command = [\"ispvm\", str(new_image_path)]", "        return self._api_helper.run_command(install_command)"]}], "source": "\n import os.path import shutil import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"0x100\", \"CPLD2\": \"0x200\", \"CPLD3\": \"0x280\", \"CPLD4\": \"0x300\", \"CPLD5\": \"0x380\" } GETREG_PATH=\"/sys/devices/platform/dx010_cpld/getreg\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_NAME_LIST=[\"CPLD1\", \"CPLD2\", \"CPLD3\", \"CPLD4\", \"BIOS\"] COMPONENT_DES_LIST=[\"Used for managing the CPU\", \"Used for managing QSFP+ports(1-10)\", \"Used for managing QSFP+ports(11-20)\", \"Used for managing QSFP+ports(22-32)\", \"Basic Input/Output System\"] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index): ComponentBase.__init__(self) self.index=component_index self._api_helper=APIHelper() self.name=self.get_name() def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def get_register_value(self, register): cmd=\"echo{1} >{0}; cat{0}\".format(GETREG_PATH, register) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err is not '': return None return raw_data.strip() def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_addr=CPLD_ADDR_MAPPING[cpld_name] cpld_version_raw=self.get_register_value(cpld_addr) cpld_version_str=\"{}.{}\".format(int(cpld_version_raw[2], 16), int( cpld_version_raw[3], 16)) if cpld_version_raw is not None else 'None' cpld_version[cpld_name]=cpld_version_str except Exception as e: cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_NAME_LIST[self.index] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_DES_LIST[self.index] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def get_available_firmware_version(self, image_path): \"\"\" Retrieves the available firmware version of the component Note: the firmware version will be read from image Args: image_path: A string, path to firmware image Returns: A string containing the available firmware version of the component \"\"\" return \"N/A\" def get_firmware_update_notification(self, image_path): \"\"\" Retrieves a notification on what should be done in order to complete the component firmware update Args: image_path: A string, path to firmware image Returns: A string containing the component firmware update notification if required. By default 'None' value will be used, which indicates that no actions are required \"\"\" return \"None\" def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" if not os.path.isfile(image_path): return False if \"CPLD\" in self.name: img_name=os.path.basename(image_path) root, ext=os.path.splitext(img_name) ext=\".vme\" if ext==\"\" else ext new_image_path=os.path.join(\"/tmp\",(root.lower() +ext)) shutil.copy(image_path, new_image_path) install_command=\"ispvm %s\" % new_image_path return self.__run_command(install_command) def update_firmware(self, image_path): \"\"\" Updates firmware of the component This API performs firmware update: it assumes firmware installation and loading in a single call. In case platform component requires some extra steps(apart from calling Low Level Utility) to load the installed firmware(e.g, reboot, power cycle, etc.) -this will be done automatically by API Args: image_path: A string, path to firmware image Raises: RuntimeError: update failed \"\"\" return False def get_presence(self): \"\"\" Retrieves the presence of the FAN Returns: bool: True if FAN is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return 'N/A' def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return 'N/A' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is'0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport os.path\nimport shutil\nimport subprocess\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"0x100\",\n    \"CPLD2\": \"0x200\",\n    \"CPLD3\": \"0x280\",\n    \"CPLD4\": \"0x300\",\n    \"CPLD5\": \"0x380\"\n}\nGETREG_PATH = \"/sys/devices/platform/dx010_cpld/getreg\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_NAME_LIST = [\"CPLD1\", \"CPLD2\", \"CPLD3\", \"CPLD4\", \"BIOS\"]\nCOMPONENT_DES_LIST = [\"Used for managing the CPU\",\n                      \"Used for managing QSFP+ ports (1-10)\", \"Used for managing QSFP+ ports (11-20)\", \"Used for managing QSFP+ ports (22-32)\", \"Basic Input/Output System\"]\n\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index):\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self._api_helper = APIHelper()\n        self.name = self.get_name()\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def get_register_value(self, register):\n        # Retrieves the cpld register value\n        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n        p = subprocess.Popen(\n            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        raw_data, err = p.communicate()\n        if err is not '':\n            return None\n        return raw_data.strip()\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_addr = CPLD_ADDR_MAPPING[cpld_name]\n                cpld_version_raw = self.get_register_value(cpld_addr)\n                cpld_version_str = \"{}.{}\".format(int(cpld_version_raw[2], 16), int(\n                    cpld_version_raw[3], 16)) if cpld_version_raw is not None else 'None'\n                cpld_version[cpld_name] = cpld_version_str\n            except Exception as e:\n                cpld_version[cpld_name] = 'None'\n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_NAME_LIST[self.index]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_DES_LIST[self.index]\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def get_available_firmware_version(self, image_path):\n        \"\"\"\n        Retrieves the available firmware version of the component\n        Note: the firmware version will be read from image\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A string containing the available firmware version of the component\n        \"\"\"\n        return \"N/A\"\n\n    def get_firmware_update_notification(self, image_path):\n        \"\"\"\n        Retrieves a notification on what should be done in order to complete\n        the component firmware update\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A string containing the component firmware update notification if required.\n            By default 'None' value will be used, which indicates that no actions are required\n        \"\"\"\n        return \"None\"\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        if not os.path.isfile(image_path):\n            return False\n\n        if \"CPLD\" in self.name:\n            img_name = os.path.basename(image_path)\n            root, ext = os.path.splitext(img_name)\n            ext = \".vme\" if ext == \"\" else ext\n            new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n            shutil.copy(image_path, new_image_path)\n            install_command = \"ispvm %s\" % new_image_path\n        # elif self.name == \"BIOS\":\n        #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n\n        return self.__run_command(install_command)\n\n\n    def update_firmware(self, image_path):\n        \"\"\"\n        Updates firmware of the component\n        This API performs firmware update: it assumes firmware installation and loading in a single call.\n        In case platform component requires some extra steps (apart from calling Low Level Utility)\n        to load the installed firmware (e.g, reboot, power cycle, etc.) - this will be done automatically by API\n        Args:\n            image_path: A string, path to firmware image\n        Raises:\n            RuntimeError: update failed\n        \"\"\"\n        return False\n\n\n    ##############################################################\n    ###################### Device methods ########################\n    ##############################################################\n\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the FAN\n        Returns:\n            bool: True if FAN is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of\n        entPhysicalContainedIn is'0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device\n            or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n \n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 5, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        try:", "            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)", "        except FileNotFoundError:", "            return False", "        return True"]}, {"diff": "\n         result = \"\"\n         try:\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = raw_data.strip()\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py", "badparts": ["                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"], "goodparts": ["                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n", "add": 0, "remove": 7, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py", "badparts": ["    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n         return True\n \n     def get_cpld_reg_value(self, getreg_path, register):\n-        cmd = \"echo {1} > {0}; cat {0}\".format(getreg_path, register)\n-        status, result = self.run_command(cmd)\n-        return result if status else None\n+        with open(getreg_path, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(getreg_path, 'r') as file:\n+            result = file.readline()\n+        return result\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(\n-                str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status", "add": 5, "remove": 53, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py", "badparts": ["        cmd = \"echo {1} > {0}; cat {0}\".format(getreg_path, register)", "        status, result = self.run_command(cmd)", "        return result if status else None", "    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(", "                str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except:", "            status = False", "        return status"], "goodparts": ["        with open(getreg_path, 'w') as file:", "            file.write(register + '\\n')", "        with open(getreg_path, 'r') as file:", "            result = file.readline()", "        return result"]}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def read_one_line_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.readline() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except Exception: return False return True def get_cpld_reg_value(self, getreg_path, register): cmd=\"echo{1} >{0}; cat{0}\".format(getreg_path, register) status, result=self.run_command(cmd) return result if status else None def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format( str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\n\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def read_one_line_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.readline()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except Exception:\n            return False\n        return True\n\n    def get_cpld_reg_value(self, getreg_path, register):\n        cmd = \"echo {1} > {0}; cat {0}\".format(getreg_path, register)\n        status, result = self.run_command(cmd)\n        return result if status else None\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(\n                str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n"}, "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py": {"changes": [{"diff": "\n         thermal_overload_position = APIHelper().read_one_line_file(\n             thermal_overload_position_path)\n \n-        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\n-            thermal_overload_position)\n+        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', str(thermal_overload_position)]\n         APIHelper().run_com", "add": 1, "remove": 2, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py", "badparts": ["        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(", "            thermal_overload_position)"], "goodparts": ["        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', str(thermal_overload_position)]"]}], "source": "\n\nfrom sonic_platform_base.sonic_thermal_control.thermal_action_base import ThermalPolicyActionBase from sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object from.thermal_infos import ChassisInfo from.helper import APIHelper @thermal_json_object('thermal_control.control') class ControlThermalAlgoAction(ThermalPolicyActionBase): \"\"\" Action to control the thermal control algorithm \"\"\" JSON_FIELD_STATUS='status' def __init__(self): self.status=True def load_from_json(self, json_obj): \"\"\" Construct ControlThermalAlgoAction via JSON. JSON example: { \"type\": \"thermal_control.control\" \"status\": \"true\" } :param json_obj: A JSON object representing a ControlThermalAlgoAction action. :return: \"\"\" if ControlThermalAlgoAction.JSON_FIELD_STATUS in json_obj: status_str=json_obj[ControlThermalAlgoAction.JSON_FIELD_STATUS].lower() if status_str=='true': self.status=True elif status_str=='false': self.status=False else: raise ValueError('Invalid{} field value, please specify true of false'. format(ControlThermalAlgoAction.JSON_FIELD_STATUS)) else: raise ValueError('ControlThermalAlgoAction ' 'missing mandatory field{} in JSON policy file'. format(ControlThermalAlgoAction.JSON_FIELD_STATUS)) def execute(self, thermal_info_dict): \"\"\" Disable thermal control algorithm :param thermal_info_dict: A dictionary stores all thermal information. :return: \"\"\" if ChassisInfo.INFO_NAME in thermal_info_dict: chassis_info_obj=thermal_info_dict[ChassisInfo.INFO_NAME] chassis=chassis_info_obj.get_chassis() thermal_manager=chassis.get_thermal_manager() if self.status: thermal_manager.start_thermal_control_algorithm() else: thermal_manager.stop_thermal_control_algorithm() @thermal_json_object('switch.power_cycling') class SwitchPolicyAction(ThermalPolicyActionBase): \"\"\" Base class for thermal action. Once all thermal conditions in a thermal policy are matched, all predefined thermal action will be executed. \"\"\" def execute(self, thermal_info_dict): \"\"\" Take action when thermal condition matches. For example, power cycle the switch. :param thermal_info_dict: A dictionary stores all thermal information. :return: \"\"\" thermal_overload_position_path='/tmp/thermal_overload_position' thermal_overload_position=APIHelper().read_one_line_file( thermal_overload_position_path) cmd='bash /usr/share/sonic/platform/thermal_overload_control.sh{}'.format( thermal_overload_position) APIHelper().run_command(cmd) ", "sourceWithComments": "\nfrom sonic_platform_base.sonic_thermal_control.thermal_action_base import ThermalPolicyActionBase\nfrom sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object\nfrom .thermal_infos import ChassisInfo\nfrom .helper import APIHelper\n\n\n@thermal_json_object('thermal_control.control')\nclass ControlThermalAlgoAction(ThermalPolicyActionBase):\n    \"\"\"\n    Action to control the thermal control algorithm\n    \"\"\"\n    # JSON field definition\n    JSON_FIELD_STATUS = 'status'\n\n    def __init__(self):\n        self.status = True\n\n    def load_from_json(self, json_obj):\n        \"\"\"\n        Construct ControlThermalAlgoAction via JSON. JSON example:\n            {\n                \"type\": \"thermal_control.control\"\n                \"status\": \"true\"\n            }\n        :param json_obj: A JSON object representing a ControlThermalAlgoAction action.\n        :return:\n        \"\"\"\n        if ControlThermalAlgoAction.JSON_FIELD_STATUS in json_obj:\n            status_str = json_obj[ControlThermalAlgoAction.JSON_FIELD_STATUS].lower()\n            if status_str == 'true':\n                self.status = True\n            elif status_str == 'false':\n                self.status = False\n            else:\n                raise ValueError('Invalid {} field value, please specify true of false'.\n                                 format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\n        else:\n            raise ValueError('ControlThermalAlgoAction '\n                             'missing mandatory field {} in JSON policy file'.\n                             format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\n\n    def execute(self, thermal_info_dict):\n        \"\"\"\n        Disable thermal control algorithm\n        :param thermal_info_dict: A dictionary stores all thermal information.\n        :return:\n        \"\"\"\n        if ChassisInfo.INFO_NAME in thermal_info_dict:\n            chassis_info_obj = thermal_info_dict[ChassisInfo.INFO_NAME]\n            chassis = chassis_info_obj.get_chassis()\n            thermal_manager = chassis.get_thermal_manager()\n            if self.status:\n                thermal_manager.start_thermal_control_algorithm()\n            else:\n                thermal_manager.stop_thermal_control_algorithm()\n\n\n@thermal_json_object('switch.power_cycling')\nclass SwitchPolicyAction(ThermalPolicyActionBase):\n    \"\"\"\n    Base class for thermal action. Once all thermal conditions in a thermal policy are matched,\n    all predefined thermal action will be executed.\n    \"\"\"\n\n    def execute(self, thermal_info_dict):\n        \"\"\"\n        Take action when thermal condition matches. For example, power cycle the switch.\n        :param thermal_info_dict: A dictionary stores all thermal information.\n        :return:\n        \"\"\"\n        thermal_overload_position_path = '/tmp/thermal_overload_position'\n        thermal_overload_position = APIHelper().read_one_line_file(\n            thermal_overload_position_path)\n\n        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\n            thermal_overload_position)\n        APIHelper().run_command(cmd)\n"}, "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py": {"changes": [{"diff": "\n from .thermal_infos import *\n \n class ThermalManager(ThermalManagerBase):\n-    FSC_ALGORITHM_CMD = 'service fancontrol {}'\n+    FSC_ALGORITHM_CMD = ['service', 'fancontrol', '']\n \n     @classmethod\n     def start_thermal_control_algorithm(cls):\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py", "badparts": ["    FSC_ALGORITHM_CMD = 'service fancontrol {}'"], "goodparts": ["    FSC_ALGORITHM_CMD = ['service', 'fancontrol', '']"]}, {"diff": "\n         Returns:\n             bool: True if set success, False if fail.\n         \"\"\"\n-        cmd = 'start' if enable else 'stop'\n-        return APIHelper().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n+        cls.FSC_ALGORITHM_CMD[2] = 'start' if enable else 'stop'\n+        return APIHelper().run_command(cls.FSC_ALGO", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py", "badparts": ["        cmd = 'start' if enable else 'stop'", "        return APIHelper().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))"], "goodparts": ["        cls.FSC_ALGORITHM_CMD[2] = 'start' if enable else 'stop'", "        return APIHelper().run_command(cls.FSC_ALGO"]}], "source": "\nfrom sonic_platform_base.sonic_thermal_control.thermal_manager_base import ThermalManagerBase from.helper import APIHelper from.thermal_actions import * from.thermal_conditions import * from.thermal_infos import * class ThermalManager(ThermalManagerBase): FSC_ALGORITHM_CMD='service fancontrol{}' @classmethod def start_thermal_control_algorithm(cls): \"\"\" Start vendor specific thermal control algorithm. The default behavior of this function is a no-op. :return: \"\"\" return cls._enable_fancontrol_service(True) @classmethod def stop_thermal_control_algorithm(cls): \"\"\" Stop thermal control algorithm Returns: bool: True if set success, False if fail. \"\"\" return cls._enable_fancontrol_service(False) @classmethod def deinitialize(cls): \"\"\" Destroy thermal manager, including any vendor specific cleanup. The default behavior of this function is a no-op. :return: \"\"\" return cls._enable_fancontrol_service(True) @classmethod def _enable_fancontrol_service(cls, enable): \"\"\" Control thermal by fcs algorithm Args: enable: Bool, indicate enable the algorithm or not Returns: bool: True if set success, False if fail. \"\"\" cmd='start' if enable else 'stop' return APIHelper().run_command(cls.FSC_ALGORITHM_CMD.format(cmd)) ", "sourceWithComments": "from sonic_platform_base.sonic_thermal_control.thermal_manager_base import ThermalManagerBase\nfrom .helper import APIHelper\nfrom .thermal_actions import *\nfrom .thermal_conditions import *\nfrom .thermal_infos import *\n\nclass ThermalManager(ThermalManagerBase):\n    FSC_ALGORITHM_CMD = 'service fancontrol {}'\n\n    @classmethod\n    def start_thermal_control_algorithm(cls):\n        \"\"\"\n        Start vendor specific thermal control algorithm. The default behavior of this function is a no-op.\n        :return:\n        \"\"\"\n        return cls._enable_fancontrol_service(True)\n\n    @classmethod\n    def stop_thermal_control_algorithm(cls):\n        \"\"\"\n        Stop thermal control algorithm\n        Returns:\n            bool: True if set success, False if fail.\n        \"\"\"\n        return cls._enable_fancontrol_service(False)\n\n    @classmethod\n    def deinitialize(cls):\n        \"\"\"\n        Destroy thermal manager, including any vendor specific cleanup. The default behavior of this function\n        is a no-op.\n        :return:\n        \"\"\"\n        return cls._enable_fancontrol_service(True)\n\n    @classmethod\n    def _enable_fancontrol_service(cls, enable):\n        \"\"\"\n        Control thermal by fcs algorithm\n        Args:\n            enable: Bool, indicate enable the algorithm or not\n        Returns:\n            bool: True if set success, False if fail.\n        \"\"\"\n        cmd = 'start' if enable else 'stop'\n        return APIHelper().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n"}, "/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py": {"changes": [{"diff": "\n-import os.path\n-import subprocess\n import sys\n import re\n \n try:\n     from sonic_psu.psu_base import PsuBase\n+    from sonic_py_common.general import getstatusoutput_noshell_pipe\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n", "add": 1, "remove": 2, "filename": "/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py", "badparts": ["import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell_pipe"]}, {"diff": "\n     \"\"\"Platform-specific PSUutil class\"\"\"\n \n     def __init__(self):\n-        self.ipmi_sensor = \"ipmitool sensor\"\n+        self.ipmi_sensor = [\"ipmitool\", \"sensor\"]\n         PsuBase.__init__(self)\n \n-    def run_command(self, command):\n-        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n-        (out, err) = proc.communicate()\n-\n-        if proc.returncode != 0:\n-            sys.exit(proc.returncode)\n-\n+    def run_command(self, cmd1, cmd2):\n+        exitcode, out = getstatusoutput_noshell_pipe(cmd1, cmd2)\n+        i = 0\n+        while i < 2:\n+            if exitcode[i] != 0:\n+                sys.exit(exitcode[i])\n+            i += 1\n         return out\n \n     def find_value(self, grep_string):\n", "add": 8, "remove": 8, "filename": "/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py", "badparts": ["        self.ipmi_sensor = \"ipmitool sensor\"", "    def run_command(self, command):", "        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)", "        (out, err) = proc.communicate()", "        if proc.returncode != 0:", "            sys.exit(proc.returncode)"], "goodparts": ["        self.ipmi_sensor = [\"ipmitool\", \"sensor\"]", "    def run_command(self, cmd1, cmd2):", "        exitcode, out = getstatusoutput_noshell_pipe(cmd1, cmd2)", "        i = 0", "        while i < 2:", "            if exitcode[i] != 0:", "                sys.exit(exitcode[i])", "            i += 1"]}, {"diff": "\n             return False\n \n         grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n-        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n+        grep_cmd = [\"grep\", grep_key]\n+        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)\n         status_byte = self.find_value(grep_string)\n \n         if status_byte is None:\n", "add": 2, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py", "badparts": ["        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)"], "goodparts": ["        grep_cmd = [\"grep\", grep_key]", "        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)"]}, {"diff": "\n             return False\n \n         grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n-        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n+        grep_cmd = [\"grep\", grep_key]\n+        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)\n         status_byte = self.find_value(grep_string)\n \n         if status_by", "add": 2, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py", "badparts": ["        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)"], "goodparts": ["        grep_cmd = [\"grep\", grep_key]", "        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)"]}], "source": "\nimport os.path import subprocess import sys import re try: from sonic_psu.psu_base import PsuBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class PsuUtil(PsuBase): \"\"\"Platform-specific PSUutil class\"\"\" def __init__(self): self.ipmi_sensor=\"ipmitool sensor\" PsuBase.__init__(self) def run_command(self, command): proc=subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE) (out, err)=proc.communicate() if proc.returncode !=0: sys.exit(proc.returncode) return out def find_value(self, grep_string): result=re.search(\".+\\|(0x\\d{2})\\d{2}\\|.+\", grep_string) if result: return result.group(1) else: return result def get_num_psus(self): \"\"\" Retrieves the number of PSUs available on the device :return: An integer, the number of PSUs available on the device \"\"\" return 2 def get_psu_status(self, index): \"\"\" Retrieves the oprational status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is operating properly, False if PSU is faulty \"\"\" if index is None: return False grep_key=\"PSUL_Status\" if index==1 else \"PSUR_Status\" grep_string=self.run_command(self.ipmi_sensor +' | grep ' +grep_key) status_byte=self.find_value(grep_string) if status_byte is None: return False failure_detected=(int(status_byte, 16) >> 1) & 1 input_lost=(int(status_byte, 16) >> 3) & 1 if failure_detected or input_lost: return False else: return True def get_psu_presence(self, index): \"\"\" Retrieves the presence status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is plugged, False if not \"\"\" if index is None: return False grep_key=\"PSUL_Status\" if index==1 else \"PSUR_Status\" grep_string=self.run_command(self.ipmi_sensor +' | grep ' +grep_key) status_byte=self.find_value(grep_string) if status_byte is None: return False presence=(int(status_byte, 16) >> 0) & 1 if presence: return True else: return False ", "sourceWithComments": "import os.path\nimport subprocess\nimport sys\nimport re\n\ntry:\n    from sonic_psu.psu_base import PsuBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass PsuUtil(PsuBase):\n    \"\"\"Platform-specific PSUutil class\"\"\"\n\n    def __init__(self):\n        self.ipmi_sensor = \"ipmitool sensor\"\n        PsuBase.__init__(self)\n\n    def run_command(self, command):\n        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n        (out, err) = proc.communicate()\n\n        if proc.returncode != 0:\n            sys.exit(proc.returncode)\n\n        return out\n\n    def find_value(self, grep_string):\n        result = re.search(\".+\\| (0x\\d{2})\\d{2}\\|.+\", grep_string)\n        if result:\n            return result.group(1)\n        else:\n            return result\n\n    def get_num_psus(self):\n        \"\"\"\n        Retrieves the number of PSUs available on the device\n        :return: An integer, the number of PSUs available on the device\n        \"\"\"\n        return 2\n\n    def get_psu_status(self, index):\n        \"\"\"\n        Retrieves the oprational status of power supply unit (PSU) defined\n                by 1-based index <index>\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is operating properly, False if PSU is faulty\n        \"\"\"\n        if index is None:\n            return False\n\n        grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n        status_byte = self.find_value(grep_string)\n\n        if status_byte is None:\n            return False\n\n        failure_detected = (int(status_byte, 16) >> 1) & 1\n        input_lost = (int(status_byte, 16) >> 3) & 1\n        if failure_detected or input_lost:\n            return False\n        else:\n            return True\n\n    def get_psu_presence(self, index):\n        \"\"\"\n        Retrieves the presence status of power supply unit (PSU) defined\n                by 1-based index <index>\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is plugged, False if not\n        \"\"\"\n        if index is None:\n            return False\n\n        grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n        status_byte = self.find_value(grep_string)\n\n        if status_byte is None:\n            return False\n\n        presence = (int(status_byte, 16) >> 0) & 1\n        if presence:\n            return True\n        else:\n            return False\n"}, "/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py": {"changes": [{"diff": "\n     \"\"\"Platform-specific PSUutil class\"\"\"\n \n     def __init__(self):\n-        self.ipmi_raw = \"docker exec -ti pmon ipmitool raw 0x4 0x2d\"\n+        self.ipmi_raw = [\"docker\", \"exec\", \"-ti\", \"pmon\", \"ipmitool\", \"raw\", \"0x4\", \"0x2d\", \"\"]\n         self.psu1_id = \"0x2f\"\n         self.psu2_id = \"0x39\"\n         PsuBase.__init__(self)\n \n     def run_command(self, command):\n-        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n         (out, err) = proc.communicate()\n \n         if proc.returncode != 0:\n", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py", "badparts": ["        self.ipmi_raw = \"docker exec -ti pmon ipmitool raw 0x4 0x2d\"", "        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)"], "goodparts": ["        self.ipmi_raw = [\"docker\", \"exec\", \"-ti\", \"pmon\", \"ipmitool\", \"raw\", \"0x4\", \"0x2d\", \"\"]", "        proc = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)"]}, {"diff": "\n             return False\n \n         psu_id = self.psu1_id if index == 1 else self.psu2_id\n-        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n+        self.ipmi_raw[8] = psu_id\n+        res_string = self.run_command(self.ipmi_raw)\n         status_byte = self.find_value(res_string)\n \n         if status_byte is None:\n", "add": 2, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py", "badparts": ["        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)"], "goodparts": ["        self.ipmi_raw[8] = psu_id", "        res_string = self.run_command(self.ipmi_raw)"]}, {"diff": "\n             return False\n \n         psu_id = self.psu1_id if index == 1 else self.psu2_id\n-        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n+        self.ipmi_raw[8] = psu_id\n+        res_string = self.run_command(self.ipmi_raw)\n         status_byte = self.find_value(res_string)\n \n         if status_b", "add": 2, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py", "badparts": ["        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)"], "goodparts": ["        self.ipmi_raw[8] = psu_id", "        res_string = self.run_command(self.ipmi_raw)"]}], "source": "\nimport os.path import subprocess import sys import re try: from sonic_psu.psu_base import PsuBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class PsuUtil(PsuBase): \"\"\"Platform-specific PSUutil class\"\"\" def __init__(self): self.ipmi_raw=\"docker exec -ti pmon ipmitool raw 0x4 0x2d\" self.psu1_id=\"0x2f\" self.psu2_id=\"0x39\" PsuBase.__init__(self) def run_command(self, command): proc=subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE) (out, err)=proc.communicate() if proc.returncode !=0: sys.exit(proc.returncode) return out def find_value(self, in_string): result=re.search(\"^.+([0-9a-f]{2}).+$\", in_string) if result: return result.group(1) else: return result def get_num_psus(self): \"\"\" Retrieves the number of PSUs available on the device :return: An integer, the number of PSUs available on the device \"\"\" return 2 def get_psu_status(self, index): \"\"\" Retrieves the oprational status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is operating properly, False if PSU is faulty \"\"\" if index is None: return False psu_id=self.psu1_id if index==1 else self.psu2_id res_string=self.run_command(self.ipmi_raw +' ' +psu_id) status_byte=self.find_value(res_string) if status_byte is None: return False failure_detected=(int(status_byte, 16) >> 1) & 1 input_lost=(int(status_byte, 16) >> 3) & 1 if failure_detected or input_lost: return False else: return True def get_psu_presence(self, index): \"\"\" Retrieves the presence status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is plugged, False if not \"\"\" if index is None: return False psu_id=self.psu1_id if index==1 else self.psu2_id res_string=self.run_command(self.ipmi_raw +' ' +psu_id) status_byte=self.find_value(res_string) if status_byte is None: return False presence=(int(status_byte, 16) >> 0) & 1 if presence: return True else: return False ", "sourceWithComments": "import os.path\nimport subprocess\nimport sys\nimport re\n\ntry:\n    from sonic_psu.psu_base import PsuBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass PsuUtil(PsuBase):\n    \"\"\"Platform-specific PSUutil class\"\"\"\n\n    def __init__(self):\n        self.ipmi_raw = \"docker exec -ti pmon ipmitool raw 0x4 0x2d\"\n        self.psu1_id = \"0x2f\"\n        self.psu2_id = \"0x39\"\n        PsuBase.__init__(self)\n\n    def run_command(self, command):\n        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n        (out, err) = proc.communicate()\n\n        if proc.returncode != 0:\n            sys.exit(proc.returncode)\n\n        return out\n\n    def find_value(self, in_string):\n        result = re.search(\"^.+ ([0-9a-f]{2}) .+$\", in_string)\n        if result:\n            return result.group(1)\n        else:\n            return result\n\n    def get_num_psus(self):\n        \"\"\"\n        Retrieves the number of PSUs available on the device\n        :return: An integer, the number of PSUs available on the device\n        \"\"\"\n        return 2\n\n    def get_psu_status(self, index):\n        \"\"\"\n        Retrieves the oprational status of power supply unit (PSU) defined\n                by 1-based index <index>\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is operating properly, False if PSU is faulty\n        \"\"\"\n        if index is None:\n            return False\n\n        psu_id = self.psu1_id if index == 1 else self.psu2_id\n        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n        status_byte = self.find_value(res_string)\n\n        if status_byte is None:\n            return False\n\n        failure_detected = (int(status_byte, 16) >> 1) & 1\n        input_lost = (int(status_byte, 16) >> 3) & 1\n        if failure_detected or input_lost:\n            return False\n        else:\n            return True\n\n    def get_psu_presence(self, index):\n        \"\"\"\n        Retrieves the presence status of power supply unit (PSU) defined\n                by 1-based index <index>\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is plugged, False if not\n        \"\"\"\n        if index is None:\n            return False\n\n        psu_id = self.psu1_id if index == 1 else self.psu2_id\n        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n        status_byte = self.find_value(res_string)\n\n        if status_byte is None:\n            return False\n\n        presence = (int(status_byte, 16) >> 0) & 1\n        if presence:\n            return True\n        else:\n            return False\n"}, "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import json\n import os.path\n \n try:\n", "add": 0, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py", "badparts": ["import json"], "goodparts": []}, {"diff": "\n SW_CPLD_VER_PATH = \"/sys/module/switch_cpld/version\"\n BASE_CPLD_VER_PATH = \"/sys/module/baseboard_lpc/version\"\n-CPLD_UPGRADE_OPT = 4\n BIOS_VER_PATH = \"/sys/class/dmi/id/bios_version\"\n-BIOS__UPGRADE_OPT = 2\n-BMC_VER_CMD = \"ipmitool mc info | grep 'Firmware Revision'\"\n-BMC_UPGRADE_OPT = 1\n-CFUFLASH_FW_UPGRADE_CMD = \"CFUFLASH -cd -d {} -mse 3 {}\"\n+BMC_VER_CMD1 = [\"ipmitool\", \"mc\", \"info\"]\n+BMC_VER_CMD2 = [\"grep\", \"Firmware Revision\"]\n+CFUFLASH_FW_UPGRADE_CMD = [\"CFUFLASH\", \"-cd\", \"-d\", \"\", \"-mse\", \"3\", \"\"]\n MEM_PCI_RESOURCE = \"/sys/bus/pci/devices/0000:09:00.0/resource0\"\n FPGA_VER_MEM_OFFSET = 0\n+UPGRADE_OPT = {\n+    'BMC': '1',\n+    'BIOS': '2',\n+    'SWITCH_CPLD': '4',\n+    'BASE_CPLD': '4'\n+}\n \n \n class Component(ComponentBase):\n", "add": 9, "remove": 5, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py", "badparts": ["CPLD_UPGRADE_OPT = 4", "BIOS__UPGRADE_OPT = 2", "BMC_VER_CMD = \"ipmitool mc info | grep 'Firmware Revision'\"", "BMC_UPGRADE_OPT = 1", "CFUFLASH_FW_UPGRADE_CMD = \"CFUFLASH -cd -d {} -mse 3 {}\""], "goodparts": ["BMC_VER_CMD1 = [\"ipmitool\", \"mc\", \"info\"]", "BMC_VER_CMD2 = [\"grep\", \"Firmware Revision\"]", "CFUFLASH_FW_UPGRADE_CMD = [\"CFUFLASH\", \"-cd\", \"-d\", \"\", \"-mse\", \"3\", \"\"]", "UPGRADE_OPT = {", "    'BMC': '1',", "    'BIOS': '2',", "    'SWITCH_CPLD': '4',", "    'BASE_CPLD': '4'", "}"]}, {"diff": "\n \n     def __get_bmc_ver(self):\n         bmc_ver = \"Unknown\"\n-        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD)\n+        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD1, BMC_VER_CMD2)\n         if status:\n             bmc_ver_data = raw_bmc_data.split(\":\")\n             bmc_ver = bmc_ver_data[-1].strip() if len(\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py", "badparts": ["        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD)"], "goodparts": ["        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD1, BMC_VER_CMD2)"]}, {"diff": "\n         Returns:\n             A boolean, True if install successfully, False if not\n         \"\"\"\n-        install_command = {\n-            \"BMC\": CFUFLASH_FW_UPGRADE_CMD.format(BMC_UPGRADE_OPT, image_path),\n-            \"BIOS\": CFUFLASH_FW_UPGRADE_CMD.format(BIOS__UPGRADE_OPT, image_path),\n-            \"SWITCH_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path),\n-            \"BASE_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path)\n-        }.get(self.name, None)\n-\n-        if not os.path.isfile(image_path) or install_command is None:\n+        CFUFLASH_FW_UPGRADE_CMD[3] = UPGRADE_OPT.get(self.name)\n+        CFUFLASH_FW_UPGRADE_CMD[6] = image_path\n+\n+        if not os.path.isfile(image_path):\n             return False\n \n         # print(install_command)\n-        status = self._api_helper.run_interactive_command(install_command)\n+        status = self._api_helper.run_interactive_command(CFUFLASH_FW_UPGRADE_CMD)\n         ", "add": 5, "remove": 9, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py", "badparts": ["        install_command = {", "            \"BMC\": CFUFLASH_FW_UPGRADE_CMD.format(BMC_UPGRADE_OPT, image_path),", "            \"BIOS\": CFUFLASH_FW_UPGRADE_CMD.format(BIOS__UPGRADE_OPT, image_path),", "            \"SWITCH_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path),", "            \"BASE_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path)", "        }.get(self.name, None)", "        if not os.path.isfile(image_path) or install_command is None:", "        status = self._api_helper.run_interactive_command(install_command)"], "goodparts": ["        CFUFLASH_FW_UPGRADE_CMD[3] = UPGRADE_OPT.get(self.name)", "        CFUFLASH_FW_UPGRADE_CMD[6] = image_path", "        if not os.path.isfile(image_path):", "        status = self._api_helper.run_interactive_command(CFUFLASH_FW_UPGRADE_CMD)"]}], "source": "\n import json import os.path try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") COMPONENT_LIST=[ (\"BIOS\", \"Basic Input/Output System\"), (\"BMC\", \"Baseboard Management Controller\"), (\"SWITCH_CPLD\", \"Switch board CPLD\"), (\"BASE_CPLD\", \"Base board CPLD\"), (\"FPGA\", \"Field-programmable gate array\") ] SW_CPLD_VER_PATH=\"/sys/module/switch_cpld/version\" BASE_CPLD_VER_PATH=\"/sys/module/baseboard_lpc/version\" CPLD_UPGRADE_OPT=4 BIOS_VER_PATH=\"/sys/class/dmi/id/bios_version\" BIOS__UPGRADE_OPT=2 BMC_VER_CMD=\"ipmitool mc info | grep 'Firmware Revision'\" BMC_UPGRADE_OPT=1 CFUFLASH_FW_UPGRADE_CMD=\"CFUFLASH -cd -d{} -mse 3{}\" MEM_PCI_RESOURCE=\"/sys/bus/pci/devices/0000:09:00.0/resource0\" FPGA_VER_MEM_OFFSET=0 class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index): ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() self._api_helper=APIHelper() def __get_bmc_ver(self): bmc_ver=\"Unknown\" status, raw_bmc_data=self._api_helper.run_command(BMC_VER_CMD) if status: bmc_ver_data=raw_bmc_data.split(\":\") bmc_ver=bmc_ver_data[-1].strip() if len( bmc_ver_data) > 1 else bmc_ver return bmc_ver def __get_fpga_ver(self): fpga_ver=\"Unknown\" status, reg_val=self._api_helper.pci_get_value( MEM_PCI_RESOURCE, FPGA_VER_MEM_OFFSET) if status: major=reg_val[0] >> 16 minor=int(bin(reg_val[0])[16:32], 2) fpga_ver='{}.{}'.format(major, minor) return fpga_ver def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version={ \"BIOS\": self._api_helper.read_txt_file(BIOS_VER_PATH), \"BMC\": self.__get_bmc_ver(), \"FPGA\": self.__get_fpga_ver(), \"SWITCH_CPLD\": self._api_helper.read_txt_file(SW_CPLD_VER_PATH), \"BASE_CPLD\": self._api_helper.read_txt_file(BASE_CPLD_VER_PATH), }.get(self.name, \"Unknown\") return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" install_command={ \"BMC\": CFUFLASH_FW_UPGRADE_CMD.format(BMC_UPGRADE_OPT, image_path), \"BIOS\": CFUFLASH_FW_UPGRADE_CMD.format(BIOS__UPGRADE_OPT, image_path), \"SWITCH_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path), \"BASE_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path) }.get(self.name, None) if not os.path.isfile(image_path) or install_command is None: return False status=self._api_helper.run_interactive_command(install_command) return status ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport json\nimport os.path\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCOMPONENT_LIST = [\n    (\"BIOS\",        \"Basic Input/Output System\"),\n    (\"BMC\",         \"Baseboard Management Controller\"),\n    (\"SWITCH_CPLD\", \"Switch board CPLD\"),\n    (\"BASE_CPLD\",   \"Base board CPLD\"),\n    (\"FPGA\",        \"Field-programmable gate array\")\n]\nSW_CPLD_VER_PATH = \"/sys/module/switch_cpld/version\"\nBASE_CPLD_VER_PATH = \"/sys/module/baseboard_lpc/version\"\nCPLD_UPGRADE_OPT = 4\nBIOS_VER_PATH = \"/sys/class/dmi/id/bios_version\"\nBIOS__UPGRADE_OPT = 2\nBMC_VER_CMD = \"ipmitool mc info | grep 'Firmware Revision'\"\nBMC_UPGRADE_OPT = 1\nCFUFLASH_FW_UPGRADE_CMD = \"CFUFLASH -cd -d {} -mse 3 {}\"\nMEM_PCI_RESOURCE = \"/sys/bus/pci/devices/0000:09:00.0/resource0\"\nFPGA_VER_MEM_OFFSET = 0\n\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index):\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n        self._api_helper = APIHelper()\n\n    def __get_bmc_ver(self):\n        bmc_ver = \"Unknown\"\n        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD)\n        if status:\n            bmc_ver_data = raw_bmc_data.split(\":\")\n            bmc_ver = bmc_ver_data[-1].strip() if len(\n                bmc_ver_data) > 1 else bmc_ver\n        return bmc_ver\n\n    def __get_fpga_ver(self):\n        fpga_ver = \"Unknown\"\n        status, reg_val = self._api_helper.pci_get_value(\n            MEM_PCI_RESOURCE, FPGA_VER_MEM_OFFSET)\n        if status:\n            major = reg_val[0] >> 16\n            minor = int(bin(reg_val[0])[16:32], 2)\n            fpga_ver = '{}.{}'.format(major, minor)\n        return fpga_ver\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = {\n            \"BIOS\": self._api_helper.read_txt_file(BIOS_VER_PATH),\n            \"BMC\": self.__get_bmc_ver(),\n            \"FPGA\": self.__get_fpga_ver(),\n            \"SWITCH_CPLD\": self._api_helper.read_txt_file(SW_CPLD_VER_PATH),\n            \"BASE_CPLD\": self._api_helper.read_txt_file(BASE_CPLD_VER_PATH),\n        }.get(self.name, \"Unknown\")\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        install_command = {\n            \"BMC\": CFUFLASH_FW_UPGRADE_CMD.format(BMC_UPGRADE_OPT, image_path),\n            \"BIOS\": CFUFLASH_FW_UPGRADE_CMD.format(BIOS__UPGRADE_OPT, image_path),\n            \"SWITCH_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path),\n            \"BASE_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path)\n        }.get(self.name, None)\n\n        if not os.path.isfile(image_path) or install_command is None:\n            return False\n\n        # print(install_command)\n        status = self._api_helper.run_interactive_command(install_command)\n        return status\n"}, "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n import struct\n import subprocess\n from mmap import *\n+from sonic_py_common.general import check_output_pipe\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 2, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["from sonic_py_common.general import check_output_pipe", "HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         pass\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 5, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        try:", "            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)", "        except FileNotFoundError:", "            return False", "        return True"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n+    def run_command(self, cmd1_args, cmd2_args):\n         status = True\n         result = \"\"\n         try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except:\n+            result = check_output_pipe(cmd1_args, cmd2_args)\n+        except subprocess.CalledProcessError:\n             status = False\n         return status, result\n \n     def run_interactive_command(self, cmd):\n         try:\n-            os.system(cmd)\n+            subprocess.call(cmd)\n         except:\n             return False\n         return True\n", "add": 4, "remove": 8, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "            p = subprocess.Popen(", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except:", "            os.system(cmd)"], "goodparts": ["    def run_command(self, cmd1_args, cmd2_args):", "            result = check_output_pipe(cmd1_args, cmd2_args)", "        except subprocess.CalledProcessError:", "            subprocess.call(cmd)"]}, {"diff": "\n         status = True\n         result = \"\"\n         try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n+            cmd = [\"ipmitool\", \"raw\", str(netfn), str(cmd)]\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = raw_data.strip()\n", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py", "badparts": ["            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"], "goodparts": ["            cmd = [\"ipmitool\", \"raw\", str(netfn), str(cmd)]", "                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"]}, {"diff": "\n     def ipmi_fru_id(self, id, key=None):\n         status = True\n         result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n+        cmd1_args = [\"ipmitool\", \"fru\", \"print\", str(id)]\n+        if not key:\n+            try:\n+                p = subprocess.Popen(\n+                    cmd1_args, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                raw_data, err = p.communicate()\n+                if err == '':\n+                    result = raw_data.strip()\n+                else:\n+                    status = False\n+            except:\n                 status = False\n-        except:\n-            status = False\n+        else:\n+            cmd2_args = [\"grep\", str(key)]\n+            status, result = self.run_command(cmd1_args, cmd2_args)\n         return status, result\n \n     def ipmi_set_ss_thres(self, id, threshold_key, value):\n         status = True\n         result = \"\"\n         try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n+            cmd = [\"ipmitool\", \"sensor\", \"thresh\", str(id), str(threshold_key), str(value)]\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = ra", "add": 16, "remove": 14, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py", "badparts": ["        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "        except:", "            status = False", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"], "goodparts": ["        cmd1_args = [\"ipmitool\", \"fru\", \"print\", str(id)]", "        if not key:", "            try:", "                p = subprocess.Popen(", "                    cmd1_args, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "                raw_data, err = p.communicate()", "                if err == '':", "                    result = raw_data.strip()", "                else:", "                    status = False", "            except:", "        else:", "            cmd2_args = [\"grep\", str(key)]", "            status, result = self.run_command(cmd1_args, cmd2_args)", "            cmd = [\"ipmitool\", \"sensor\", \"thresh\", str(id), str(threshold_key), str(value)]", "                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"]}], "source": "\nimport os import struct import subprocess from mmap import * HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): pass def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        pass\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n"}, "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py": {"changes": [{"diff": "\n PSU_LED_GREEN_CMD = \"0x01\"\n PSU_LED_AMBER_CMD = \"0x02\"\n \n-PSU1_VOUT_SS_ID = \"0x36\"\n-PSU1_COUT_SS_ID = \"0x37\"\n-PSU1_POUT_SS_ID = \"0x38\"\n-PSU1_STATUS_REG = \"0x39\"\n-\n-PSU2_VOUT_SS_ID = \"0x40\"\n-PSU2_COUT_SS_ID = \"0x41\"\n-PSU2_POUT_SS_ID = \"0x42\"\n-PSU2_STATUS_REG = \"0x2f\"\n-\n PSU1_FRU_ID = 3\n \n SS_READ_OFFSET = 0\n \n+PSU_VOUT_SS_ID = [\"0x36\", \"0x40\"]\n+PSU_COUT_SS_ID = [\"0x37\", \"0x41\"]\n+PSU_POUT_SS_ID = [\"0x38\", \"0x42\"]\n+PSU_STATUS_REG = [\"0x39\", \"0x2f\"]\n+\n \n class Psu(PsuBase):\n     \"\"\"Platform-specific Psu class\"\"\"\n", "add": 5, "remove": 10, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["PSU1_VOUT_SS_ID = \"0x36\"", "PSU1_COUT_SS_ID = \"0x37\"", "PSU1_POUT_SS_ID = \"0x38\"", "PSU1_STATUS_REG = \"0x39\"", "PSU2_VOUT_SS_ID = \"0x40\"", "PSU2_COUT_SS_ID = \"0x41\"", "PSU2_POUT_SS_ID = \"0x42\"", "PSU2_STATUS_REG = \"0x2f\""], "goodparts": ["PSU_VOUT_SS_ID = [\"0x36\", \"0x40\"]", "PSU_COUT_SS_ID = [\"0x37\", \"0x41\"]", "PSU_POUT_SS_ID = [\"0x38\", \"0x42\"]", "PSU_STATUS_REG = [\"0x39\", \"0x2f\"]"]}, {"diff": "\n             e.g. 12.1\n         \"\"\"\n         psu_voltage = 0.0\n-        psu_vout_key = globals()['PSU{}_VOUT_SS_ID'.format(self.index+1)]\n+        psu_vout_key = PSU_VOUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_vout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["        psu_vout_key = globals()['PSU{}_VOUT_SS_ID'.format(self.index+1)]"], "goodparts": ["        psu_vout_key = PSU_VOUT_SS_ID[self.index]"]}, {"diff": "\n             A float number, the electric current in amperes, e.g 15.4\n         \"\"\"\n         psu_current = 0.0\n-        psu_cout_key = globals()['PSU{}_COUT_SS_ID'.format(self.index+1)]\n+        psu_cout_key = PSU_COUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_cout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["        psu_cout_key = globals()['PSU{}_COUT_SS_ID'.format(self.index+1)]"], "goodparts": ["        psu_cout_key = PSU_COUT_SS_ID[self.index]"]}, {"diff": "\n             A float number, the power in watts, e.g. 302.6\n         \"\"\"\n         psu_power = 0.0\n-        psu_pout_key = globals()['PSU{}_POUT_SS_ID'.format(self.index+1)]\n+        psu_pout_key = PSU_POUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["        psu_pout_key = globals()['PSU{}_POUT_SS_ID'.format(self.index+1)]"], "goodparts": ["        psu_pout_key = PSU_POUT_SS_ID[self.index]"]}, {"diff": "\n             bool: True if PSU is present, False if not\n         \"\"\"\n         psu_presence = False\n-        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n+        psu_pstatus_key = PSU_STATUS_REG[self.index]\n         status, raw_status_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n         status_byte = self.find_value(raw_status_read)\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]"], "goodparts": ["        psu_pstatus_key = PSU_STATUS_REG[self.index]"]}, {"diff": "\n             A boolean value, True if device is operating properly, False if not\n         \"\"\"\n         psu_status = False\n-        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n+        psu_pstatus_key = PSU_STATUS_REG[self.index]\n         status, raw_status_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n         status_byte = self.find_value(r", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]"], "goodparts": ["        psu_pstatus_key = PSU_STATUS_REG[self.index]"]}], "source": "\n import os import re import math import sonic_platform try: from sonic_platform_base.psu_base import PsuBase from.helper import APIHelper from sonic_platform.fan import Fan except ImportError as e: raise ImportError(str(e) +\"-required module not found\") PSU_NAME_LIST=[\"PSU-1\", \"PSU-2\"] PSU_NUM_FAN=[1, 1] IPMI_SENSOR_NETFN=\"0x04\" IPMI_OEM_NETFN=\"0x3A\" IPMI_SS_READ_CMD=\"0x2D{}\" IPMI_SET_PSU_LED_CMD=\"0x07 0x02{}\" IPMI_GET_PSU_LED_CMD=\"0x08 0x02\" IPMI_FRU_MODEL_KEY=\"Board Part Number\" IPMI_FRU_SERIAL_KEY=\"Board Serial\" PSU_LED_OFF_CMD=\"0x00\" PSU_LED_GREEN_CMD=\"0x01\" PSU_LED_AMBER_CMD=\"0x02\" PSU1_VOUT_SS_ID=\"0x36\" PSU1_COUT_SS_ID=\"0x37\" PSU1_POUT_SS_ID=\"0x38\" PSU1_STATUS_REG=\"0x39\" PSU2_VOUT_SS_ID=\"0x40\" PSU2_COUT_SS_ID=\"0x41\" PSU2_POUT_SS_ID=\"0x42\" PSU2_STATUS_REG=\"0x2f\" PSU1_FRU_ID=3 SS_READ_OFFSET=0 class Psu(PsuBase): \"\"\"Platform-specific Psu class\"\"\" def __init__(self, psu_index): PsuBase.__init__(self) self.index=psu_index for fan_index in range(0, PSU_NUM_FAN[self.index]): fan=Fan(fan_index, 0, is_psu_fan=True, psu_index=self.index) self._fan_list.append(fan) self._api_helper=APIHelper() def find_value(self, in_string): result=re.search(\"^.+([0-9a-f]{2}).+$\", in_string) return result.group(1) if result else result def get_voltage(self): \"\"\" Retrieves current PSU voltage output Returns: A float number, the output voltage in volts, e.g. 12.1 \"\"\" psu_voltage=0.0 psu_vout_key=globals()['PSU{}_VOUT_SS_ID'.format(self.index+1)] status, raw_ss_read=self._api_helper.ipmi_raw( IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_vout_key)) ss_read=raw_ss_read.split()[SS_READ_OFFSET] psu_voltage=int(ss_read, 16) * math.pow(10, -1) return psu_voltage def get_current(self): \"\"\" Retrieves present electric current supplied by PSU Returns: A float number, the electric current in amperes, e.g 15.4 \"\"\" psu_current=0.0 psu_cout_key=globals()['PSU{}_COUT_SS_ID'.format(self.index+1)] status, raw_ss_read=self._api_helper.ipmi_raw( IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_cout_key)) ss_read=raw_ss_read.split()[SS_READ_OFFSET] psu_current=int(ss_read, 16) * 5 * math.pow(10, -1) return psu_current def get_power(self): \"\"\" Retrieves current energy supplied by PSU Returns: A float number, the power in watts, e.g. 302.6 \"\"\" psu_power=0.0 psu_pout_key=globals()['PSU{}_POUT_SS_ID'.format(self.index+1)] status, raw_ss_read=self._api_helper.ipmi_raw( IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pout_key)) ss_read=raw_ss_read.split()[SS_READ_OFFSET] psu_power=int(ss_read, 16) * 6 return psu_power def get_powergood_status(self): \"\"\" Retrieves the powergood status of PSU Returns: A boolean, True if PSU has stablized its output voltages and passed all its internal self-tests, False if not. \"\"\" return self.get_status() def set_status_led(self, color): \"\"\" Sets the state of the PSU status LED Args: color: A string representing the color with which to set the PSU status LED Note: Only support green and off Returns: bool: True if status LED state is set successfully, False if not Note Set manual ipmitool raw 0x3a 0x09 0x2 0x0 \"\"\" led_cmd={ self.STATUS_LED_COLOR_GREEN: PSU_LED_GREEN_CMD, self.STATUS_LED_COLOR_AMBER: PSU_LED_AMBER_CMD, self.STATUS_LED_COLOR_OFF: PSU_LED_OFF_CMD }.get(color) status, set_led=self._api_helper.ipmi_raw( IPMI_OEM_NETFN, IPMI_SET_PSU_LED_CMD.format(led_cmd)) set_status_led=False if not status else True return set_status_led def get_status_led(self): \"\"\" Gets the state of the PSU status LED Returns: A string, one of the predefined STATUS_LED_COLOR_* strings above \"\"\" status, hx_color=self._api_helper.ipmi_raw( IPMI_OEM_NETFN, IPMI_GET_PSU_LED_CMD) status_led={ \"00\": self.STATUS_LED_COLOR_OFF, \"01\": self.STATUS_LED_COLOR_GREEN, \"02\": self.STATUS_LED_COLOR_AMBER, }.get(hx_color, self.STATUS_LED_COLOR_OFF) return status_led def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return PSU_NAME_LIST[self.index] def get_presence(self): \"\"\" Retrieves the presence of the PSU Returns: bool: True if PSU is present, False if not \"\"\" psu_presence=False psu_pstatus_key=globals()['PSU{}_STATUS_REG'.format(self.index+1)] status, raw_status_read=self._api_helper.ipmi_raw( IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key)) status_byte=self.find_value(raw_status_read) if status: presence_int=(int(status_byte, 16) >> 0) & 1 psu_presence=True if presence_int else False return psu_presence def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" model=\"Unknown\" ipmi_fru_idx=self.index +PSU1_FRU_ID status, raw_model=self._api_helper.ipmi_fru_id( ipmi_fru_idx, IPMI_FRU_MODEL_KEY) fru_pn_list=raw_model.split() if len(fru_pn_list) > 4: model=fru_pn_list[4] return model def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" serial=\"Unknown\" ipmi_fru_idx=self.index +PSU1_FRU_ID status, raw_model=self._api_helper.ipmi_fru_id( ipmi_fru_idx, IPMI_FRU_SERIAL_KEY) fru_sr_list=raw_model.split() if len(fru_sr_list) > 3: serial=fru_sr_list[3] return serial def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" psu_status=False psu_pstatus_key=globals()['PSU{}_STATUS_REG'.format(self.index+1)] status, raw_status_read=self._api_helper.ipmi_raw( IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key)) status_byte=self.find_value(raw_status_read) if status: failure_detected=(int(status_byte, 16) >> 1) & 1 input_lost=(int(status_byte, 16) >> 3) & 1 psu_status=False if(input_lost or failure_detected) else True return psu_status ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the PSUs status which are available in the platform\n#\n#############################################################################\n\nimport os\nimport re\nimport math\nimport sonic_platform\n\ntry:\n    from sonic_platform_base.psu_base import PsuBase\n    from .helper import APIHelper\n    from sonic_platform.fan import Fan\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nPSU_NAME_LIST = [\"PSU-1\", \"PSU-2\"]\nPSU_NUM_FAN = [1, 1]\n\nIPMI_SENSOR_NETFN = \"0x04\"\nIPMI_OEM_NETFN = \"0x3A\"\nIPMI_SS_READ_CMD = \"0x2D {}\"\nIPMI_SET_PSU_LED_CMD = \"0x07 0x02 {}\"\nIPMI_GET_PSU_LED_CMD = \"0x08 0x02\"\nIPMI_FRU_MODEL_KEY = \"Board Part Number\"\nIPMI_FRU_SERIAL_KEY = \"Board Serial\"\n\nPSU_LED_OFF_CMD = \"0x00\"\nPSU_LED_GREEN_CMD = \"0x01\"\nPSU_LED_AMBER_CMD = \"0x02\"\n\nPSU1_VOUT_SS_ID = \"0x36\"\nPSU1_COUT_SS_ID = \"0x37\"\nPSU1_POUT_SS_ID = \"0x38\"\nPSU1_STATUS_REG = \"0x39\"\n\nPSU2_VOUT_SS_ID = \"0x40\"\nPSU2_COUT_SS_ID = \"0x41\"\nPSU2_POUT_SS_ID = \"0x42\"\nPSU2_STATUS_REG = \"0x2f\"\n\nPSU1_FRU_ID = 3\n\nSS_READ_OFFSET = 0\n\n\nclass Psu(PsuBase):\n    \"\"\"Platform-specific Psu class\"\"\"\n\n    def __init__(self, psu_index):\n        PsuBase.__init__(self)\n        self.index = psu_index\n        for fan_index in range(0, PSU_NUM_FAN[self.index]):\n            fan = Fan(fan_index, 0, is_psu_fan=True, psu_index=self.index)\n            self._fan_list.append(fan)\n        self._api_helper = APIHelper()\n\n    def find_value(self, in_string):\n        result = re.search(\"^.+ ([0-9a-f]{2}) .+$\", in_string)\n        return result.group(1) if result else result\n\n    def get_voltage(self):\n        \"\"\"\n        Retrieves current PSU voltage output\n        Returns:\n            A float number, the output voltage in volts,\n            e.g. 12.1\n        \"\"\"\n        psu_voltage = 0.0\n        psu_vout_key = globals()['PSU{}_VOUT_SS_ID'.format(self.index+1)]\n        status, raw_ss_read = self._api_helper.ipmi_raw(\n            IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_vout_key))\n        ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n        # Formula: Rx1x10^-1\n        psu_voltage = int(ss_read, 16) * math.pow(10, -1)\n\n        return psu_voltage\n\n    def get_current(self):\n        \"\"\"\n        Retrieves present electric current supplied by PSU\n        Returns:\n            A float number, the electric current in amperes, e.g 15.4\n        \"\"\"\n        psu_current = 0.0\n        psu_cout_key = globals()['PSU{}_COUT_SS_ID'.format(self.index+1)]\n        status, raw_ss_read = self._api_helper.ipmi_raw(\n            IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_cout_key))\n        ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n        # Formula: Rx5x10^-1\n        psu_current = int(ss_read, 16) * 5 * math.pow(10, -1)\n\n        return psu_current\n\n    def get_power(self):\n        \"\"\"\n        Retrieves current energy supplied by PSU\n        Returns:\n            A float number, the power in watts, e.g. 302.6\n        \"\"\"\n        psu_power = 0.0\n        psu_pout_key = globals()['PSU{}_POUT_SS_ID'.format(self.index+1)]\n        status, raw_ss_read = self._api_helper.ipmi_raw(\n            IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pout_key))\n        ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n        # Formula: Rx6x10^0\n        psu_power = int(ss_read, 16) * 6\n        return psu_power\n\n    def get_powergood_status(self):\n        \"\"\"\n        Retrieves the powergood status of PSU\n        Returns:\n            A boolean, True if PSU has stablized its output voltages and passed all\n            its internal self-tests, False if not.\n        \"\"\"\n        return self.get_status()\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the PSU status LED\n        Args:\n            color: A string representing the color with which to set the PSU status LED\n                   Note: Only support green and off\n        Returns:\n            bool: True if status LED state is set successfully, False if not\n        Note\n            Set manual\n            ipmitool raw 0x3a 0x09 0x2 0x0\n        \"\"\"\n        led_cmd = {\n            self.STATUS_LED_COLOR_GREEN: PSU_LED_GREEN_CMD,\n            self.STATUS_LED_COLOR_AMBER: PSU_LED_AMBER_CMD,\n            self.STATUS_LED_COLOR_OFF: PSU_LED_OFF_CMD\n        }.get(color)\n\n        status, set_led = self._api_helper.ipmi_raw(\n            IPMI_OEM_NETFN, IPMI_SET_PSU_LED_CMD.format(led_cmd))\n        set_status_led = False if not status else True\n\n        return set_status_led\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the PSU status LED\n        Returns:\n            A string, one of the predefined STATUS_LED_COLOR_* strings above\n        \"\"\"\n        status, hx_color = self._api_helper.ipmi_raw(\n            IPMI_OEM_NETFN, IPMI_GET_PSU_LED_CMD)\n\n        status_led = {\n            \"00\": self.STATUS_LED_COLOR_OFF,\n            \"01\": self.STATUS_LED_COLOR_GREEN,\n            \"02\": self.STATUS_LED_COLOR_AMBER,\n        }.get(hx_color, self.STATUS_LED_COLOR_OFF)\n\n        return status_led\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return PSU_NAME_LIST[self.index]\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the PSU\n        Returns:\n            bool: True if PSU is present, False if not\n        \"\"\"\n        psu_presence = False\n        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n        status, raw_status_read = self._api_helper.ipmi_raw(\n            IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n        status_byte = self.find_value(raw_status_read)\n\n        if status:\n            presence_int = (int(status_byte, 16) >> 0) & 1\n            psu_presence = True if presence_int else False\n\n        return psu_presence\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        model = \"Unknown\"\n        ipmi_fru_idx = self.index + PSU1_FRU_ID\n        status, raw_model = self._api_helper.ipmi_fru_id(\n            ipmi_fru_idx, IPMI_FRU_MODEL_KEY)\n\n        fru_pn_list = raw_model.split()\n        if len(fru_pn_list) > 4:\n            model = fru_pn_list[4]\n\n        return model\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        serial = \"Unknown\"\n        ipmi_fru_idx = self.index + PSU1_FRU_ID\n        status, raw_model = self._api_helper.ipmi_fru_id(\n            ipmi_fru_idx, IPMI_FRU_SERIAL_KEY)\n\n        fru_sr_list = raw_model.split()\n        if len(fru_sr_list) > 3:\n            serial = fru_sr_list[3]\n\n        return serial\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        psu_status = False\n        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n        status, raw_status_read = self._api_helper.ipmi_raw(\n            IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n        status_byte = self.find_value(raw_status_read)\n\n        if status:\n            failure_detected = (int(status_byte, 16) >> 1) & 1\n            input_lost = (int(status_byte, 16) >> 3) & 1\n            psu_status = False if (input_lost or failure_detected) else True\n\n        return psu_status\n"}, "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to QSFP sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-cel_silverstone-r0\"\n     HWSKU = \"Silverstone\"\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n             return 'N/A'\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH,", "add": 5, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        try:", "            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)", "        except FileNotFoundError:", "            return False", "        return True"]}]}, "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py": {"changes": [{"diff": "\n #\r\n #############################################################################\r\n \r\n-import os.path\r\n import subprocess\r\n-import time\r\n-import os\r\n \r\n try:\r\n     from sonic_platform_base.component_base import ComponentBase\r\n+    from sonic_py_common.general import getstatusoutput_noshell_pipe\r\n     #from helper import APIHelper\r\n except ImportError as e:\r\n     raise ImportError(str(e) + \"- required module not found\")\r\n \r\n-SWCPLD_VERSION_PATH = \"i2cget -y -f 2 0x32 0\"\r\n-BIOS_VERSION_PATH = \"dmidecode -t bios | grep Version\"\r\n+SWCPLD_VERSION_PATH = [\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0\"]\r\n+BIOS_VERSION_PATH_CMD1 = [\"dmidecode\", \"-t\", \"bios\"]\r\n+BIOS_VERSION_PATH_CMD2 = [\"grep\", \"Version\"]\r\n COMPONENT_NAME_LIST = [\"SWCPLD\", \"Main_BIOS\", \"Backup_BIOS\"]\r\n COMPONENT_DES_LIST = [\"Use for boot control and BIOS switch\",\r\n                       \"Main basic Input/Output System\",\r\n", "add": 4, "remove": 5, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py", "badparts": ["import time\r", "SWCPLD_VERSION_PATH = \"i2cget -y -f 2 0x32 0\"\r", "BIOS_VERSION_PATH = \"dmidecode -t bios | grep Version\"\r"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell_pipe\r", "SWCPLD_VERSION_PATH = [\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0\"]\r", "BIOS_VERSION_PATH_CMD1 = [\"dmidecode\", \"-t\", \"bios\"]\r", "BIOS_VERSION_PATH_CMD2 = [\"grep\", \"Version\"]\r"]}, {"diff": "\n         self.name = self.get_name()\r\n \r\n     def run_command(self,cmd):\r\n-        responses = os.popen(cmd).read()\r\n+        responses = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()\r\n         return responses\r\n \r\n     def __get_bios_version(self):\r\n         # Retrieves the BIOS firmware version\r\n-        result = self.run_command(\"i2cget -y -f 2 0x32 0x19\")\r\n+        result = self.run_command([\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0x19\"])\r\n         if result.strip() == \"0x01\":\r\n             if self.name == \"Main_BIOS\":\r\n-                version = self.run_command(BIOS_VERSION_PATH)\r\n+                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r\n                 bios_version = version.strip().split(\" \")[1]\r\n                 return str(bios_version)\r\n             elif self.name == \"Backup_BIOS\":\r\n", "add": 3, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py", "badparts": ["        responses = os.popen(cmd).read()\r", "        result = self.run_command(\"i2cget -y -f 2 0x32 0x19\")\r", "                version = self.run_command(BIOS_VERSION_PATH)\r"], "goodparts": ["        responses = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()\r", "        result = self.run_command([\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0x19\"])\r", "                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r"]}, {"diff": "\n                 \r\n         elif result.strip() == \"0x03\":\r\n             if self.name == \"Backup_BIOS\":\r\n-                version = self.run_command(BIOS_VERSION_PATH)\r\n+                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r\n                 bios_version = version.strip().split(\" \")[1]\r\n                 return str(bios_version)\r\n             elif self.name", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py", "badparts": ["                version = self.run_command(BIOS_VERSION_PATH)\r"], "goodparts": ["                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r"]}], "source": "\n\n\r \r import os.path\r import subprocess\r import time\r import os\r \r try:\r from sonic_platform_base.component_base import ComponentBase\r except ImportError as e:\r raise ImportError(str(e) +\"-required module not found\")\r \r SWCPLD_VERSION_PATH=\"i2cget -y -f 2 0x32 0\"\r BIOS_VERSION_PATH=\"dmidecode -t bios | grep Version\"\r COMPONENT_NAME_LIST=[\"SWCPLD\", \"Main_BIOS\", \"Backup_BIOS\"]\r COMPONENT_DES_LIST=[\"Use for boot control and BIOS switch\",\r \"Main basic Input/Output System\",\r \"Backup basic Input/Output System\"]\r \r \r class Component(ComponentBase):\r \"\"\"Platform-specific Component class\"\"\"\r \r DEVICE_TYPE=\"component\"\r \r def __init__(self, component_index):\r ComponentBase.__init__(self)\r self.index=component_index\r self.name=self.get_name()\r \r def run_command(self,cmd):\r responses=os.popen(cmd).read()\r return responses\r \r def __get_bios_version(self):\r result=self.run_command(\"i2cget -y -f 2 0x32 0x19\")\r if result.strip()==\"0x01\":\r if self.name==\"Main_BIOS\":\r version=self.run_command(BIOS_VERSION_PATH)\r bios_version=version.strip().split(\" \")[1]\r return str(bios_version)\r elif self.name==\"Backup_BIOS\":\r bios_version=\"na\"\r return bios_version\r \r elif result.strip()==\"0x03\":\r if self.name==\"Backup_BIOS\":\r version=self.run_command(BIOS_VERSION_PATH)\r bios_version=version.strip().split(\" \")[1]\r return str(bios_version)\r elif self.name==\"Main_BIOS\":\r bios_version=\"na\"\r return bios_version\r \r def __get_cpld_version(self):\r if self.name==\"SWCPLD\":\r ver=self.run_command(SWCPLD_VERSION_PATH)\r print(\"ver is %s\" % ver)\r ver=ver.strip().split(\"x\")[1]\r print(\"ver2 is %s\" % ver)\r version=int(ver.strip()) / 10\r return str(version)\r \r \r def get_name(self):\r \"\"\"\r Retrieves the name of the component\r Returns:\r A string containing the name of the component\r \"\"\"\r return COMPONENT_NAME_LIST[self.index]\r \r def get_description(self):\r \"\"\"\r Retrieves the description of the component\r Returns:\r A string containing the description of the component\r \"\"\"\r return COMPONENT_DES_LIST[self.index]\r \r def get_firmware_version(self):\r \"\"\"\r Retrieves the firmware version of module\r Returns:\r string: The firmware versions of the module\r \"\"\"\r fw_version=None\r \r if \"BIOS\" in self.name:\r fw_version=self.__get_bios_version()\r elif \"CPLD\" in self.name:\r fw_version=self.__get_cpld_version()\r \r return fw_version\r \r def install_firmware(self, image_path):\r \"\"\"\r Install firmware to module\r Args:\r image_path: A string, path to firmware image\r Returns:\r A boolean, True if install successfully, False if not\r \"\"\"\r return False\r \r def update_firmware(self, image_path):\r return False\r \r def get_available_firmware_version(self, image_path):\r return 'N/A'\r \r def get_firmware_update_notification(self, image_path):\r return \"None\"\r \r def get_model(self):\r return 'N/A'\r \r def get_position_in_parent(self):\r return -1\r \r def get_presence(self):\r return True\r \r def get_serial(self):\r return 'N/A'\r \r def get_status(self):\r return True\r \r def is_replaceable(self):\r return False\r ", "sourceWithComments": "#!/usr/bin/env python\r\n\r\n#############################################################################\r\n# Celestica\r\n#\r\n# Component contains an implementation of SONiC Platform Base API and\r\n# provides the components firmware management function\r\n#\r\n#############################################################################\r\n\r\nimport os.path\r\nimport subprocess\r\nimport time\r\nimport os\r\n\r\ntry:\r\n    from sonic_platform_base.component_base import ComponentBase\r\n    #from helper import APIHelper\r\nexcept ImportError as e:\r\n    raise ImportError(str(e) + \"- required module not found\")\r\n\r\nSWCPLD_VERSION_PATH = \"i2cget -y -f 2 0x32 0\"\r\nBIOS_VERSION_PATH = \"dmidecode -t bios | grep Version\"\r\nCOMPONENT_NAME_LIST = [\"SWCPLD\", \"Main_BIOS\", \"Backup_BIOS\"]\r\nCOMPONENT_DES_LIST = [\"Use for boot control and BIOS switch\",\r\n                      \"Main basic Input/Output System\",\r\n                      \"Backup basic Input/Output System\"]\r\n\r\n\r\nclass Component(ComponentBase):\r\n    \"\"\"Platform-specific Component class\"\"\"\r\n\r\n    DEVICE_TYPE = \"component\"\r\n\r\n    def __init__(self, component_index):\r\n        ComponentBase.__init__(self)\r\n        self.index = component_index\r\n        #self._api_helper = APIHelper()\r\n        self.name = self.get_name()\r\n\r\n    def run_command(self,cmd):\r\n        responses = os.popen(cmd).read()\r\n        return responses\r\n\r\n    def __get_bios_version(self):\r\n        # Retrieves the BIOS firmware version\r\n        result = self.run_command(\"i2cget -y -f 2 0x32 0x19\")\r\n        if result.strip() == \"0x01\":\r\n            if self.name == \"Main_BIOS\":\r\n                version = self.run_command(BIOS_VERSION_PATH)\r\n                bios_version = version.strip().split(\" \")[1]\r\n                return str(bios_version)\r\n            elif self.name == \"Backup_BIOS\":\r\n                bios_version = \"na\"\r\n                return bios_version\r\n                \r\n        elif result.strip() == \"0x03\":\r\n            if self.name == \"Backup_BIOS\":\r\n                version = self.run_command(BIOS_VERSION_PATH)\r\n                bios_version = version.strip().split(\" \")[1]\r\n                return str(bios_version)\r\n            elif self.name == \"Main_BIOS\":\r\n                bios_version = \"na\"\r\n                return bios_version\r\n\r\n    def __get_cpld_version(self):\r\n        if self.name == \"SWCPLD\":\r\n            ver = self.run_command(SWCPLD_VERSION_PATH)\r\n            print(\"ver is %s\" % ver)\r\n            ver = ver.strip().split(\"x\")[1]\r\n            print(\"ver2 is %s\" % ver)\r\n            version = int(ver.strip()) / 10\r\n            return str(version)\r\n\r\n                \r\n    def get_name(self):\r\n        \"\"\"\r\n        Retrieves the name of the component\r\n         Returns:\r\n            A string containing the name of the component\r\n        \"\"\"\r\n        return COMPONENT_NAME_LIST[self.index]\r\n\r\n    def get_description(self):\r\n        \"\"\"\r\n        Retrieves the description of the component\r\n            Returns:\r\n            A string containing the description of the component\r\n        \"\"\"\r\n        return COMPONENT_DES_LIST[self.index]\r\n\r\n    def get_firmware_version(self):\r\n        \"\"\"\r\n        Retrieves the firmware version of module\r\n        Returns:\r\n            string: The firmware versions of the module\r\n        \"\"\"\r\n        fw_version = None\r\n        \r\n        if \"BIOS\" in self.name:\r\n            fw_version = self.__get_bios_version()\r\n        elif \"CPLD\" in self.name:\r\n            fw_version = self.__get_cpld_version()\r\n            \r\n        return fw_version\r\n\r\n    def install_firmware(self, image_path):\r\n        \"\"\"\r\n        Install firmware to module\r\n        Args:\r\n            image_path: A string, path to firmware image\r\n        Returns:\r\n            A boolean, True if install successfully, False if not\r\n        \"\"\"\r\n        return False\r\n\r\n    def update_firmware(self, image_path):\r\n        return False\r\n\r\n    def get_available_firmware_version(self, image_path):\r\n        return 'N/A'\r\n\r\n    def get_firmware_update_notification(self, image_path):\r\n        return \"None\"\r\n\r\n    def get_model(self):\r\n        return 'N/A'\r\n\r\n    def get_position_in_parent(self):\r\n        return -1\r\n\r\n    def get_presence(self):\r\n        return True\r\n \r\n    def get_serial(self):\r\n        return 'N/A'\r\n\r\n    def get_status(self):\r\n        return True\r\n\r\n    def is_replaceable(self):\r\n        return False\r\n"}, "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py": {"changes": [{"diff": "\n         \"\"\"\n         if self.is_psu_fan:\n             cmd_num = \"58\" if self.fans_psu_index == 1 else \"59\"\n-            cmd = \"i2cget -y -f 4 0x%s 0x80\" % cmd_num\n-            res = os.popen(cmd).read()\n+            cmd = [\"i2cget\", \"-y\", \"-f\", \"4\", \"\", \"0x80\"]\n+            cmd[4] = \"0x\" + cmd_num\n+            res = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()\n             # F2B \n             if res.strip() == \"0x01\":\n                 dir", "add": 3, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py", "badparts": ["            cmd = \"i2cget -y -f 4 0x%s 0x80\" % cmd_num", "            res = os.popen(cmd).read()"], "goodparts": ["            cmd = [\"i2cget\", \"-y\", \"-f\", \"4\", \"\", \"0x80\"]", "            cmd[4] = \"0x\" + cmd_num", "            res = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()"]}], "source": "\ntry: from sonic_platform_pddf_base.pddf_fan import PddfFan import os except ImportError as e: raise ImportError(str(e) +\"-required module not found\") FAN_DIRECTION_FILE_PATH=\"/var/fan_direction\" class Fan(PddfFan): \"\"\"PDDF Platform-Specific Fan class\"\"\" def __init__(self, tray_idx, fan_idx=0, pddf_data=None, pddf_plugin_data=None, is_psu_fan=False, psu_index=0): PddfFan.__init__(self, tray_idx, fan_idx, pddf_data, pddf_plugin_data, is_psu_fan, psu_index) def get_speed_tolerance(self): \"\"\" Retrieves the speed tolerance of the fan Returns: An integer, the percentage of variance from target speed which is considered tolerable \"\"\" return 20 def get_presence(self): return True def get_direction(self): \"\"\" Retrieves the direction of fan Returns: A string, either FAN_DIRECTION_INTAKE or FAN_DIRECTION_EXHAUST depending on fan direction \"\"\" if self.is_psu_fan: cmd_num=\"58\" if self.fans_psu_index==1 else \"59\" cmd=\"i2cget -y -f 4 0x%s 0x80\" % cmd_num res=os.popen(cmd).read() if res.strip()==\"0x01\": direction=\"EXHAUST\" else: direction=\"INTAKE\" else: direction=\"INTAKE\" with open(FAN_DIRECTION_FILE_PATH, \"r\") as f: fan_direction=f.read() if fan_direction.strip()==\"FB\": direction=\"EXHAUST\" return direction def get_status(self): speed=self.get_speed_rpm() status=True if(speed !=0) else False return status def get_target_speed(self): \"\"\" Retrieves the target(expected) speed of the fan Returns: An integer, the percentage of full fan speed, in the range 0(off) to 100(full speed) \"\"\" target_speed=0 if self.is_psu_fan: target_speed=\"N/A\" else: idx=(self.fantray_index -1) * 1 +self.fan_index attr=\"fan\" +str(idx) +\"_pwm\" pwm_path=\"/sys/devices/pci0000:00/0000:00:12.0/i2c-0/i2c-2/2-0066/\" +attr pwm=0 with open(pwm_path, \"r\") as f: pwm=f.read() percentage=int(pwm.strip()) speed_percentage=int(round(percentage / 255 * 100)) target_speed=speed_percentage return target_speed def set_status_led(self, color): color_dict={\"green\": \"STATUS_LED_COLOR_GREEN\", \"red\": \"STATUS_LED_COLOR_AMBER\"} color=color_dict.get(color, \"off\") index=str(self.fantray_index -1) led_device_name=\"FANTRAY{}\".format(self.fantray_index) +\"_LED\" result, msg=self.pddf_obj.is_supported_sysled_state(led_device_name, color) if result is False: return False device_name=self.pddf_obj.data[led_device_name]['dev_info']['device_name'] self.pddf_obj.create_attr('device_name', device_name, self.pddf_obj.get_led_path()) self.pddf_obj.create_attr('index', index, self.pddf_obj.get_led_path()) self.pddf_obj.create_attr('color', color, self.pddf_obj.get_led_cur_state_path()) self.pddf_obj.create_attr('dev_ops', 'set_status', self.pddf_obj.get_led_path()) return True @staticmethod def get_model(): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" model=\"Unknown\" return model @staticmethod def get_serial(): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" serial=\"Unknown\" return serial def get_position_in_parent(self): \"\"\" Retrieves the fan/psu fan index number \"\"\" return self.fantray_index if not self.is_psu_fan else self.fans_psu_index +4 \t\t @staticmethod def is_replaceable(): \"\"\" Retrieves whether the device is replaceable \"\"\" return False ", "sourceWithComments": "try:\n    from sonic_platform_pddf_base.pddf_fan import PddfFan\n    import os\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n# ------------------------------------------------------------------\n# HISTORY:\n#    5/1/2022 (A.D.)\n#    add function:set_status_led,\n#    Solve the problem that when a fan is pulled out, the Fan LED on the front panel is still green Issue-#11525\n# ------------------------------------------------------------------\nFAN_DIRECTION_FILE_PATH = \"/var/fan_direction\"\n\n\nclass Fan(PddfFan):\n    \"\"\"PDDF Platform-Specific Fan class\"\"\"\n\n    def __init__(self, tray_idx, fan_idx=0, pddf_data=None, pddf_plugin_data=None, is_psu_fan=False, psu_index=0):\n        # idx is 0-based\n        PddfFan.__init__(self, tray_idx, fan_idx, pddf_data, pddf_plugin_data, is_psu_fan, psu_index)\n\n\n    def get_speed_tolerance(self):\n        \"\"\"\n        Retrieves the speed tolerance of the fan\n\n        Returns:\n            An integer, the percentage of variance from target speed which is\n                 considered tolerable\n        \"\"\"\n        # Fix the speed vairance to 10 percent. If it changes based on platforms, overwrite\n        # this value in derived pddf fan class\n        return 20\n    \n    \n    def get_presence(self):\n        #Overwirte the PDDF Common since the FANs on Belgite are all Fixed and present\n        return True \n\n    def get_direction(self):\n        \"\"\"\n        Retrieves the direction of fan\n\n        Returns:\n            A string, either FAN_DIRECTION_INTAKE or FAN_DIRECTION_EXHAUST\n            depending on fan direction\n        \"\"\"\n        if self.is_psu_fan:\n            cmd_num = \"58\" if self.fans_psu_index == 1 else \"59\"\n            cmd = \"i2cget -y -f 4 0x%s 0x80\" % cmd_num\n            res = os.popen(cmd).read()\n            # F2B \n            if res.strip() == \"0x01\":\n                direction = \"EXHAUST\"\n            else:\n                direction = \"INTAKE\"\n        else:\n            direction = \"INTAKE\"\n            with open(FAN_DIRECTION_FILE_PATH, \"r\") as f:\n                fan_direction = f.read()\n                if fan_direction.strip() == \"FB\":\n                    direction = \"EXHAUST\"\n        return direction\n    \n\n    def get_status(self):\n        speed = self.get_speed_rpm()\n        status = True if (speed != 0) else False\n        return status\n\n    def get_target_speed(self):\n        \"\"\"\n        Retrieves the target (expected) speed of the fan\n\n        Returns:\n            An integer, the percentage of full fan speed, in the range 0 (off)\n                 to 100 (full speed)\n        \"\"\"\n        target_speed = 0\n        if self.is_psu_fan:\n            # Target speed not usually supported for PSU fans\n            target_speed = \"N/A\"\n        else:\n            idx = (self.fantray_index - 1) * 1 + self.fan_index\n            attr = \"fan\" + str(idx) + \"_pwm\"\n            pwm_path = \"/sys/devices/pci0000:00/0000:00:12.0/i2c-0/i2c-2/2-0066/\" + attr\n            pwm = 0\n            with open(pwm_path, \"r\") as f:\n                pwm = f.read()\n\n            percentage = int(pwm.strip())\n            speed_percentage = int(round(percentage / 255 * 100))\n            target_speed = speed_percentage\n\n        return target_speed\n\n    def set_status_led(self, color):\n        color_dict = {\"green\": \"STATUS_LED_COLOR_GREEN\",\n                      \"red\": \"STATUS_LED_COLOR_AMBER\"}\n        color = color_dict.get(color, \"off\")\n        index = str(self.fantray_index - 1)\n        led_device_name = \"FANTRAY{}\".format(self.fantray_index) + \"_LED\"\n\n        result, msg = self.pddf_obj.is_supported_sysled_state(led_device_name, color)\n        if result is False:\n            return False\n        device_name = self.pddf_obj.data[led_device_name]['dev_info']['device_name']\n        self.pddf_obj.create_attr('device_name', device_name, self.pddf_obj.get_led_path())\n        self.pddf_obj.create_attr('index', index, self.pddf_obj.get_led_path())\n        self.pddf_obj.create_attr('color', color, self.pddf_obj.get_led_cur_state_path())\n\n        self.pddf_obj.create_attr('dev_ops', 'set_status', self.pddf_obj.get_led_path())\n        return True\n\n    @staticmethod\n    def get_model():\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        model = \"Unknown\"\n        return model\n\n    @staticmethod\n    def get_serial():\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        serial = \"Unknown\"\n        return serial\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves the fan/psu fan index number\n        \"\"\"\n        return self.fantray_index if not self.is_psu_fan else self.fans_psu_index + 4\n\t\t\n    @staticmethod\n    def is_replaceable():\n        \"\"\"\n        Retrieves whether the device is replaceable\n        \"\"\"\n        return False\n"}, "/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py": {"changes": [{"diff": "\n try:\n     import sys\n     import getopt\n-    import subprocess\n     import logging\n     import logging.config\n     import time  # this is only being used as part of the example\n     import signal\n     import math\n     from sonic_platform import platform\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py", "badparts": ["    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         else:\n             logging.debug('INFO: FAIL. set_fan_duty_cycle (%d)' % DUTY_MAX)\n         # Enable the CPLD Heartbeat back\n-        status, output = subprocess.getstatusoutput('i2cset -f -y 75 0x40 0x22 0x00')\n+        status, output = getstatusoutput_noshell([\"i2cset\", \"-f\", \"-y\", \"75\", \"0x40\", \"0x22\", \"0x00\"])\n         if status == 0:\n             logging.debug('INFO: CPLD Heartbeat check is enabled back')\n     sys.exit(0)\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py", "badparts": ["        status, output = subprocess.getstatusoutput('i2cset -f -y 75 0x40 0x22 0x00')"], "goodparts": ["        status, output = getstatusoutput_noshell([\"i2cset\", \"-f\", \"-y\", \"75\", \"0x40\", \"0x22\", \"0x00\"])"]}, {"diff": "\n     signal.signal(signal.SIGINT, handler)\n     signal.signal(signal.SIGTERM, handler)\n     # Disaable the CPLD Heartbeat check to control Fan speed from CPU via ADT7470\n-    subprocess.getstatusoutput('i2cset -f -y 2 0x32 0x30 0x01')\n+    getstatusoutput_noshell(['i2cset', '-f', '-y', '2', '0x32', '0x30', '0x01'])\n \n     monitor = cel_belgite_monitor(log", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py", "badparts": ["    subprocess.getstatusoutput('i2cset -f -y 2 0x32 0x30 0x01')"], "goodparts": ["    getstatusoutput_noshell(['i2cset', '-f', '-y', '2', '0x32', '0x30', '0x01'])"]}], "source": "\n try: import sys import getopt import subprocess import logging import logging.config import time import signal import math from sonic_platform import platform except ImportError as e: raise ImportError('%s -required module not found' % str(e)) FUNCTION_NAME='cel_belgite_monitor' DUTY_MAX=100 FAN_NUMBER=3 SENSOR_NUMBER=4 CPU_CORE_TEMP=r\"/sys/devices/platform/coretemp.0/hwmon/hwmon1/temp1_input\" class cel_belgite_monitor(object): \"\"\" Make a class we can use to capture stdout and sterr in the log \"\"\" _ori_temp=0 _new_perc=DUTY_MAX / 2 syslog=logging.getLogger(\"[\" +FUNCTION_NAME +\"]\") init_fan_temperature=[0, 0, 0, 0] def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" formatter=logging.Formatter('%(name)s %(message)s') sys_handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setFormatter(formatter) sys_handler.ident='common' self.syslog.setLevel(logging.WARNING) self.syslog.addHandler(sys_handler) self.platform_chassis_obj=platform.Platform().get_chassis() logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) logging.debug('SET. logfile:%s / loglevel:%d' %(log_file, log_level)) def get_all_temperature(self): \"\"\" return: all temperature \"\"\" all_temperature_list=list() for sensor_index in range(SENSOR_NUMBER): temp=self.platform_chassis_obj.get_thermal(sensor_index).get_temperature() if temp is None or str(temp).strip()==\"\": return False temp=temp*1000 all_temperature_list.append(temp) u4_temperature=all_temperature_list[0] u7_temperature=all_temperature_list[1] cpu_temperature=70000 try: with open(CPU_CORE_TEMP, \"r\") as f: cpu_temperature=float(f.read().strip()) except Exception as E: logging.debug('Error: %s' % E) u60_temperature=all_temperature_list[3] return[u4_temperature, u7_temperature, cpu_temperature, u60_temperature] def get_fan_speed_by_temperature(self, temp_list): fan1_direction=self.platform_chassis_obj.get_fan(0).get_direction() logging.debug('INFO: fan direction: %s' % str(fan1_direction)) all_temp=self.get_all_temperature() logging.debug('INFO: all_temp: %s' % str(all_temp)) a=1 if fan1_direction.lower()==\"intake\" else 0 sensor_temp=all_temp[a] cup_temp=all_temp[2] u60_temp=all_temp[3] logging.debug('sensor_temp:%d cup_temp:%d u60_temp:%d' %(sensor_temp, cup_temp, u60_temp)) update_temp_sensor, update_temp_cpu, update_temp_u60=True, True, True if all_temp[a] -temp_list[a] < 0: update_temp_sensor=False if cup_temp -temp_list[2] < 0: update_temp_cpu=False if u60_temp -temp_list[3] < 0: update_temp_u60=False if not update_temp_sensor: b=math.trunc(1400/13) if sensor_temp <=32000: sensor_temp_speed=40 elif sensor_temp >=45000: sensor_temp_speed=100 else: sensor_temp_speed=int(math.trunc(60 / 13) * math.trunc(sensor_temp / 1000) -b) else: b=math.trunc(1580 / 13) if sensor_temp <=35000: sensor_temp_speed=40 elif sensor_temp >=48000: sensor_temp_speed=100 else: sensor_temp_speed=int(math.trunc(60/13) * math.trunc(sensor_temp/1000) -b) if not update_temp_cpu: b=228 if cup_temp <=67000: cpu_temp_speed=40 elif cup_temp >=82000: cpu_temp_speed=100 else: cpu_temp_speed=int(4 *(cup_temp / 1000) -b) else: b=240 if cup_temp <=70000: cpu_temp_speed=40 elif cup_temp >=85000: cpu_temp_speed=100 else: cpu_temp_speed=int(4 *(cup_temp / 1000) -b) if not update_temp_u60: b=168 if u60_temp <=52000: u60_temp_speed=40 elif u60_temp >=67000: u60_temp_speed=100 else: u60_temp_speed=int(4 *(u60_temp / 1000) -b) else: b=180 if u60_temp <=55000: u60_temp_speed=40 elif u60_temp >=70000: u60_temp_speed=100 else: u60_temp_speed=int(4 *(u60_temp / 1000) -b) return max([sensor_temp_speed, cpu_temp_speed, u60_temp_speed]) def manage_fans(self): fan_presence_list=[True, True, True] for fan_index in range(FAN_NUMBER): if not self.platform_chassis_obj.get_fan(fan_index).get_presence() or not \\ self.platform_chassis_obj.get_fan(fan_index).get_status(): fan_presence_list[fan_index]=False logging.debug('self.platform_chassis_obj.get_fan(fan_index).get_presence():%s' % str(self.platform_chassis_obj.get_fan(fan_index).get_presence())) logging.debug('self.platform_chassis_obj.get_fan(fan_index).get_status():%s' % str(self.platform_chassis_obj.get_fan(fan_index).get_status())) else: fan_presence_list[fan_index]=True fans_inserted_num=FAN_NUMBER -fan_presence_list.count(False) if fans_inserted_num==0: self.syslog.critical(\"No fans inserted. Severe overheating hazard. \" \"Please insert Fans immediately or power off the device\\n\") elif fans_inserted_num in[1, 2]: self._new_perc=DUTY_MAX else: self._new_perc=self.get_fan_speed_by_temperature(self.init_fan_temperature) logging.debug('INFO: 3 fans inserted: self._new_perc: %s' % str(self._new_perc)) self.init_fan_temperature=self.get_all_temperature() for i in range(FAN_NUMBER): aa=self.platform_chassis_obj.get_fan(i).get_speed() logging.debug(\"INFO: Get before setting fan speed: %s\" % aa) if self._new_perc < 40: self._new_perc=40 if self._new_perc > 100: self._new_perc=100 set_stat=self.platform_chassis_obj.get_fan(i).set_speed(self._new_perc) if set_stat is True: logging.debug('INFO: PASS. set_fan%d_duty_cycle(%d)' %(i, self._new_perc)) else: logging.debug('INFO: FAIL. set_fan%d_duty_cycle(%d)' %(i, self._new_perc)) def handler(signum, frame): platform_chassis=platform.Platform().get_chassis() for _ in range(FAN_NUMBER): set_stat=platform_chassis.get_fan(_).set_speed(DUTY_MAX) if set_stat is True: logging.debug('INFO:Cause signal %d, set fan speed max.' % signum) else: logging.debug('INFO: FAIL. set_fan_duty_cycle(%d)' % DUTY_MAX) status, output=subprocess.getstatusoutput('i2cset -f -y 75 0x40 0x22 0x00') if status==0: logging.debug('INFO: CPLD Heartbeat check is enabled back') sys.exit(0) def main(argv): global test_temp log_file='/home/admin/%s.log' % FUNCTION_NAME log_level=logging.INFO if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv, 'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv) !=6: print(\"temp test, need input 4 temp\") return 0 signal.signal(signal.SIGINT, handler) signal.signal(signal.SIGTERM, handler) subprocess.getstatusoutput('i2cset -f -y 2 0x32 0x30 0x01') monitor=cel_belgite_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(10) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# Copyright (C) Celestica Technology Corporation\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    9/16/2021 (A.D.)\n# ------------------------------------------------------------------\n\ntry:\n    import sys\n    import getopt\n    import subprocess\n    import logging\n    import logging.config\n    import time  # this is only being used as part of the example\n    import signal\n    import math\n    from sonic_platform import platform\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nFUNCTION_NAME = 'cel_belgite_monitor'\nDUTY_MAX = 100\nFAN_NUMBER = 3\nSENSOR_NUMBER = 4\nCPU_CORE_TEMP = r\"/sys/devices/platform/coretemp.0/hwmon/hwmon1/temp1_input\"\n\n\nclass cel_belgite_monitor(object):\n    \"\"\"\n    Make a class we can use to capture stdout and sterr in the log\n    \"\"\"\n    # static temp var\n    _ori_temp = 0\n    _new_perc = DUTY_MAX / 2\n    syslog = logging.getLogger(\"[\" + FUNCTION_NAME + \"]\")\n    init_fan_temperature = [0, 0, 0, 0]\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        formatter = logging.Formatter('%(name)s %(message)s')\n        sys_handler = logging.handlers.SysLogHandler(address='/dev/log')\n        sys_handler.setFormatter(formatter)\n        sys_handler.ident = 'common'\n        self.syslog.setLevel(logging.WARNING)\n        self.syslog.addHandler(sys_handler)\n        self.platform_chassis_obj = platform.Platform().get_chassis()\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format='[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n        logging.debug('SET. logfile:%s / loglevel:%d' % (log_file, log_level))\n\n    def get_all_temperature(self):\n        \"\"\"\n        return: all temperature\n        \"\"\"\n        all_temperature_list = list()\n        for sensor_index in range(SENSOR_NUMBER):\n            temp = self.platform_chassis_obj.get_thermal(sensor_index).get_temperature()\n            if temp is None or str(temp).strip() == \"\":\n                return False\n            temp = temp*1000\n            all_temperature_list.append(temp)\n        u4_temperature = all_temperature_list[0]\n        u7_temperature = all_temperature_list[1]\n        # default CPU temperature 70\n        cpu_temperature = 70000\n        try:\n            with open(CPU_CORE_TEMP, \"r\") as f:\n                cpu_temperature = float(f.read().strip())\n        except Exception as E:\n            logging.debug('Error: %s' % E)\n        u60_temperature = all_temperature_list[3]   \n        return [u4_temperature, u7_temperature, cpu_temperature, u60_temperature]\n\n    def get_fan_speed_by_temperature(self, temp_list):\n        fan1_direction = self.platform_chassis_obj.get_fan(0).get_direction()\n        logging.debug('INFO: fan direction: %s' % str(fan1_direction))\n        all_temp = self.get_all_temperature()\n        logging.debug('INFO: all_temp: %s' % str(all_temp))\n        # B2F=intake: U7 temperature\uff0c F2B-EXHAUST: U4 temperature\n        a = 1 if fan1_direction.lower() == \"intake\" else 0\n        sensor_temp = all_temp[a]\n        cup_temp = all_temp[2]\n        u60_temp = all_temp[3]\n        logging.debug('sensor_temp:%d cup_temp:%d u60_temp:%d' % (sensor_temp, cup_temp, u60_temp))\n        update_temp_sensor, update_temp_cpu, update_temp_u60 = True, True, True\n        if all_temp[a] - temp_list[a] < 0:\n            update_temp_sensor = False\n        if cup_temp - temp_list[2] < 0:\n            update_temp_cpu = False\n        if u60_temp - temp_list[3] < 0:\n            update_temp_u60 = False\n\n        # U4 U7\n        if not update_temp_sensor:  # temperature down\n            b = math.trunc(1400/13)\n            if sensor_temp <= 32000:\n                sensor_temp_speed = 40\n            elif sensor_temp >= 45000:\n                sensor_temp_speed = 100\n            else:\n                sensor_temp_speed = int(math.trunc(60 / 13) * math.trunc(sensor_temp / 1000) - b)\n        else:   # temperature up\n            b = math.trunc(1580 / 13)\n            if sensor_temp <= 35000:\n                sensor_temp_speed = 40\n            elif sensor_temp >= 48000:\n                sensor_temp_speed = 100\n            else:\n                sensor_temp_speed = int(math.trunc(60/13) * math.trunc(sensor_temp/1000) - b)\n\n        # CPU\n        if not update_temp_cpu:  # temperature down\n            b = 228\n            if cup_temp <= 67000:\n                cpu_temp_speed = 40\n            elif cup_temp >= 82000:\n                cpu_temp_speed = 100\n            else:\n                cpu_temp_speed = int(4 * (cup_temp / 1000) - b)\n        else:   # temperature up\n            b = 240\n            if cup_temp <= 70000:\n                cpu_temp_speed = 40\n            elif cup_temp >= 85000:\n                cpu_temp_speed = 100\n            else:\n                cpu_temp_speed = int(4 * (cup_temp / 1000) - b)\n\n        # U60\n        if not update_temp_u60:  # temperature down\n            b = 168\n            if u60_temp <= 52000:\n                u60_temp_speed = 40\n            elif u60_temp >= 67000:\n                u60_temp_speed = 100\n            else:\n                u60_temp_speed = int(4 * (u60_temp / 1000) - b)\n        else:   # temperature up\n            b = 180\n            if u60_temp <= 55000:\n                u60_temp_speed = 40\n            elif u60_temp >= 70000:\n                u60_temp_speed = 100\n            else:\n                u60_temp_speed = int(4 * (u60_temp / 1000) - b)\n        return max([sensor_temp_speed, cpu_temp_speed, u60_temp_speed])\n\n    def manage_fans(self):\n        fan_presence_list = [True, True, True]  # whether fan is absent or not \n        for fan_index in range(FAN_NUMBER):\n            if not self.platform_chassis_obj.get_fan(fan_index).get_presence() or not \\\n                    self.platform_chassis_obj.get_fan(fan_index).get_status():\n                fan_presence_list[fan_index] = False\n                logging.debug('self.platform_chassis_obj.get_fan(fan_index).get_presence():%s'\n                              % str(self.platform_chassis_obj.get_fan(fan_index).get_presence()))\n                logging.debug('self.platform_chassis_obj.get_fan(fan_index).get_status():%s'\n                              % str(self.platform_chassis_obj.get_fan(fan_index).get_status()))\n            else:\n                fan_presence_list[fan_index] = True\n\n        fans_inserted_num = FAN_NUMBER - fan_presence_list.count(False)\n        if fans_inserted_num == 0:  # all fans broken, power off \n            self.syslog.critical(\"No fans inserted. Severe overheating hazard. \"\n                                 \"Please insert Fans immediately or power off the device\\n\")\n\n            # power off \n        elif fans_inserted_num in [1, 2]:   # 1 or 2 present, full speed \n            self._new_perc = DUTY_MAX\n        else:   # 3 fans normal, manage the fans follow thermal policy \n            self._new_perc = self.get_fan_speed_by_temperature(self.init_fan_temperature)\n            logging.debug('INFO: 3 fans inserted: self._new_perc: %s' % str(self._new_perc))\n            self.init_fan_temperature = self.get_all_temperature()\n\n        for i in range(FAN_NUMBER):\n            aa = self.platform_chassis_obj.get_fan(i).get_speed()\n            logging.debug(\"INFO: Get before setting fan speed: %s\" % aa)\n            if self._new_perc < 40:\n                self._new_perc = 40\n            if self._new_perc > 100:\n                self._new_perc = 100\n            set_stat = self.platform_chassis_obj.get_fan(i).set_speed(self._new_perc)\n            if set_stat is True:\n                logging.debug('INFO: PASS. set_fan%d_duty_cycle (%d)' % (i, self._new_perc))\n            else:\n                logging.debug('INFO: FAIL. set_fan%d_duty_cycle (%d)' % (i, self._new_perc))\n\n\ndef handler(signum, frame):\n    platform_chassis = platform.Platform().get_chassis()\n    for _ in range(FAN_NUMBER):\n        set_stat = platform_chassis.get_fan(_).set_speed(DUTY_MAX)\n        if set_stat is True:\n            logging.debug('INFO:Cause signal %d, set fan speed max.' % signum)\n        else:\n            logging.debug('INFO: FAIL. set_fan_duty_cycle (%d)' % DUTY_MAX)\n        # Enable the CPLD Heartbeat back\n        status, output = subprocess.getstatusoutput('i2cset -f -y 75 0x40 0x22 0x00')\n        if status == 0:\n            logging.debug('INFO: CPLD Heartbeat check is enabled back')\n    sys.exit(0)\n\n\ndef main(argv):\n    global test_temp\n\n    log_file = '/home/admin/%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv, 'hdlt:', ['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg\n\n        if sys.argv[1] == '-t':\n            if len(sys.argv) != 6:\n                print(\"temp test, need input 4 temp\")\n                return 0\n\n    signal.signal(signal.SIGINT, handler)\n    signal.signal(signal.SIGTERM, handler)\n    # Disaable the CPLD Heartbeat check to control Fan speed from CPU via ADT7470\n    subprocess.getstatusoutput('i2cset -f -y 2 0x32 0x30 0x01')\n\n    monitor = cel_belgite_monitor(log_file, log_level)\n\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(10)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n"}, "/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py": {"changes": [{"diff": "\n \n     SET_METHOD_IPMI = 'ipmitool'\n     NULL_VAL = 'N/A'\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n     REF_KEY = '$ref:'\n \n     def __init__(self, conf=None):\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n             cleaned_input = input_translator.get(input)\n \n         elif type(input_translator) is str:\n-            cleaned_input = eval(input_translator.format(input))\n+            cleaned_input = ast.literal_eval(input_translator.format(input))\n \n         return cleaned_input\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py", "badparts": ["            cleaned_input = eval(input_translator.format(input))"], "goodparts": ["            cleaned_input = ast.literal_eval(input_translator.format(input))"]}, {"diff": "\n         if type(output_translator) is dict:\n             output = output_translator.get(output)\n         elif type(output_translator) is str:\n-            output = eval(output_translator.format(output))\n+            output = ast.literal_eval(output_translator.format(output))\n         elif type(output_translator) is list:\n-            output = eval(output_translator[index].format(output))\n+            output = ast.literal_eval(output_translator[index].format(output))\n \n         return output\n \n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py", "badparts": ["            output = eval(output_translator.format(output))", "            output = eval(output_translator[index].format(output))"], "goodparts": ["            output = ast.literal_eval(output_translator.format(output))", "            output = ast.literal_eval(output_translator[index].format(output))"]}, {"diff": "\n         return True\n \n     def is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def load_json_file(self,", "add": 5, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        try:", "            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)", "        except FileNotFoundError:", "            return False", "        return True"]}], "source": "\nimport os import imp import yaml import subprocess from sonic_py_common import device_info class Common: DEVICE_PATH='/usr/share/sonic/device/' PMON_PLATFORM_PATH='/usr/share/sonic/platform/' CONFIG_DIR='sonic_platform_config' OUTPUT_SOURCE_IPMI='ipmitool' OUTPUT_SOURCE_GIVEN_LIST='value_list' OUTPUT_SOURCE_GIVEN_VALUE='value' OUTPUT_SOURCE_GIVEN_CLASS='class' OUTPUT_SOURCE_SYSFS='sysfs_value' OUTPUT_SOURCE_FUNC='function' OUTPUT_SOURCE_GIVEN_TXT_FILE='txt_file' OUTPUT_SOURCE_GIVEN_VER_HEX_FILE='hex_version_file' OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR='hex_version_getreg' SET_METHOD_IPMI='ipmitool' NULL_VAL='N/A' HOST_CHK_CMD=\"docker > /dev/null 2>&1\" REF_KEY='$ref:' def __init__(self, conf=None): self._main_conf=conf (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def _run_command(self, command): status=False output=\"\" try: p=subprocess.Popen( command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': status, output=True, raw_data.strip() except Exception: pass return status, output def _clean_input(self, input, config): cleaned_input=input ai=config.get('avaliable_input') if ai and input not in ai: return None input_translator=config.get('input_translator') if type(input_translator) is dict: cleaned_input=input_translator.get(input) elif type(input_translator) is str: cleaned_input=eval(input_translator.format(input)) return cleaned_input def _clean_output(self, index, output, config): output_translator=config.get('output_translator') if type(output_translator) is dict: output=output_translator.get(output) elif type(output_translator) is str: output=eval(output_translator.format(output)) elif type(output_translator) is list: output=eval(output_translator[index].format(output)) return output def _ipmi_get(self, index, config): argument=config.get('argument') cmd=config['command'].format( config['argument'][index]) if argument else config['command'] status, output=self._run_command(cmd) return output if status else None def _sysfs_read(self, index, config): sysfs_path=config.get('sysfs_path') argument=config.get('argument', '') if self.REF_KEY in argument: argument=self._main_conf[argument.split(\":\")[1]] if type(argument) is list: sysfs_path=sysfs_path.format(argument[index]) content=\"\" try: content=open(sysfs_path) content=content.readline().rstrip() except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False return content def _sysfs_write(self, index, config, input): sysfs_path=config.get('sysfs_path') argument=config.get('argument', '') if self.REF_KEY in argument: argument=self._main_conf[argument.split(\":\")[1]] if type(argument) is list: sysfs_path=sysfs_path.format(argument[index]) write_offset=int(config.get('write_offset', 0)) output=\"\" try: open_file=open(sysfs_path, \"r+\") open_file.seek(write_offset) open_file.write(input) open_file.close() except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False, output return True, output def _ipmi_set(self, index, config, input): arg=config['argument'][index].format(input) return self._run_command(config['command'].format(arg)) def _hex_ver_decode(self, hver, num_of_bits, num_of_points): ver_list=[] c_bit=0 bin_val=bin(int(hver, 16))[2:].zfill(num_of_bits) bit_split=num_of_bits /(num_of_points +1) for x in range(0, num_of_points+1): split_bin=bin_val[c_bit:c_bit+bit_split] ver_list.append(str(int(split_bin, 2))) c_bit +=bit_split return '.'.join(ver_list) def _get_class(self, config): \"\"\" Retreives value of expected attribute Returns: A value of the attribute of object \"\"\" path=config['host_path'] if self.is_host() else config['pmon_path'] module=imp.load_source(config['class'], path) class_=getattr(module, config['class']) return class_ def get_reg(self, path, reg_addr): cmd=\"echo{1} >{0}; cat{0}\".format(path, reg_addr) status, output=self._run_command(cmd) return output if status else None def read_txt_file(self, path): with open(path, 'r') as f: output=f.readline() return output.strip('\\n') def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except Exception: return False return True def is_host(self): return os.system(self.HOST_CHK_CMD)==0 def load_json_file(self, path): \"\"\" Retrieves the json object from json file path Returns: A json object \"\"\" with open(path, 'r') as f: json_data=yaml.safe_load(f) return json_data def get_config_path(self, config_name): \"\"\" Retrieves the path to platform api config directory Args: config_name: A string containing the name of config file. Returns: A string containing the path to json file \"\"\" return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name) def get_output(self, index, config, default): \"\"\" Retrieves the output for each function base on config Args: index: An integer containing the index of device. config: A dict object containing the configuration of specified function. default: A string containing the default output of specified function. Returns: A string containing the output of specified function in config \"\"\" output_source=config.get('output_source') if output_source==self.OUTPUT_SOURCE_IPMI: output=self._ipmi_get(index, config) elif output_source==self.OUTPUT_SOURCE_GIVEN_VALUE: output=config[\"value\"] elif output_source==self.OUTPUT_SOURCE_GIVEN_CLASS: output=self._get_class(config) elif output_source==self.OUTPUT_SOURCE_GIVEN_LIST: output=config[\"value_list\"][index] elif output_source==self.OUTPUT_SOURCE_SYSFS: output=self._sysfs_read(index, config) elif output_source==self.OUTPUT_SOURCE_FUNC: func_conf=self._main_conf[config['function'][index]] output=self.get_output(index, func_conf, default) elif output_source==self.OUTPUT_SOURCE_GIVEN_TXT_FILE: path=config.get('path') output=self.read_txt_file(path) elif output_source==self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE: path=config.get('path') hex_ver=self.read_txt_file(path) output=self._hex_ver_decode( hex_ver, config['num_of_bits'], config['num_of_points']) elif output_source==self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR: path=config.get('path') addr=config.get('reg_addr') hex_ver=self.get_reg(path, addr) output=self._hex_ver_decode( hex_ver, config['num_of_bits'], config['num_of_points']) else: output=default return self._clean_output(index, output, config) or default def set_output(self, index, input, config): \"\"\" Sets the output of specified function on config Args: config: A dict object containing the configuration of specified function. index: An integer containing the index of device. input: A string containing the input of specified function. Returns: bool: True if set function is successfully, False if not \"\"\" cleaned_input=self._clean_input(input, config) if not cleaned_input: return False set_method=config.get('set_method') if set_method==self.SET_METHOD_IPMI: output=self._ipmi_set(index, config, cleaned_input)[0] elif set_method==self.OUTPUT_SOURCE_SYSFS: output=self._sysfs_write(index, config, cleaned_input)[0] else: output=False return output def get_event(self, timeout, config, sfp_list): \"\"\" Returns a nested dictionary containing all devices which have experienced a change at chassis level \"\"\" event_class=self._get_class(config) return event_class(sfp_list).get_event(timeout) ", "sourceWithComments": "import os\nimport imp\nimport yaml\nimport subprocess\n\nfrom sonic_py_common import device_info\n\n\nclass Common:\n\n    DEVICE_PATH = '/usr/share/sonic/device/'\n    PMON_PLATFORM_PATH = '/usr/share/sonic/platform/'\n    CONFIG_DIR = 'sonic_platform_config'\n\n    OUTPUT_SOURCE_IPMI = 'ipmitool'\n    OUTPUT_SOURCE_GIVEN_LIST = 'value_list'\n    OUTPUT_SOURCE_GIVEN_VALUE = 'value'\n    OUTPUT_SOURCE_GIVEN_CLASS = 'class'\n    OUTPUT_SOURCE_SYSFS = 'sysfs_value'\n    OUTPUT_SOURCE_FUNC = 'function'\n    OUTPUT_SOURCE_GIVEN_TXT_FILE = 'txt_file'\n    OUTPUT_SOURCE_GIVEN_VER_HEX_FILE = 'hex_version_file'\n    OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR = 'hex_version_getreg'\n\n    SET_METHOD_IPMI = 'ipmitool'\n    NULL_VAL = 'N/A'\n    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n    REF_KEY = '$ref:'\n\n    def __init__(self, conf=None):\n        self._main_conf = conf\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def _run_command(self, command):\n        status = False\n        output = \"\"\n        try:\n            p = subprocess.Popen(\n                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                status, output = True, raw_data.strip()\n        except Exception:\n            pass\n        return status, output\n\n    def _clean_input(self, input, config):\n        cleaned_input = input\n\n        ai = config.get('avaliable_input')\n        if ai and input not in ai:\n            return None\n\n        input_translator = config.get('input_translator')\n        if type(input_translator) is dict:\n            cleaned_input = input_translator.get(input)\n\n        elif type(input_translator) is str:\n            cleaned_input = eval(input_translator.format(input))\n\n        return cleaned_input\n\n    def _clean_output(self, index, output, config):\n        output_translator = config.get('output_translator')\n\n        if type(output_translator) is dict:\n            output = output_translator.get(output)\n        elif type(output_translator) is str:\n            output = eval(output_translator.format(output))\n        elif type(output_translator) is list:\n            output = eval(output_translator[index].format(output))\n\n        return output\n\n    def _ipmi_get(self, index, config):\n        argument = config.get('argument')\n        cmd = config['command'].format(\n            config['argument'][index]) if argument else config['command']\n        status, output = self._run_command(cmd)\n        return output if status else None\n\n    def _sysfs_read(self, index, config):\n        sysfs_path = config.get('sysfs_path')\n        argument = config.get('argument', '')\n\n        if self.REF_KEY in argument:\n            argument = self._main_conf[argument.split(\":\")[1]]\n\n        if type(argument) is list:\n            sysfs_path = sysfs_path.format(argument[index])\n\n        content = \"\"\n        try:\n            content = open(sysfs_path)\n            content = content.readline().rstrip()\n        except IOError as e:\n            print(\"Error: unable to open file: %s\" % str(e))\n            return False\n\n        return content\n\n    def _sysfs_write(self, index, config, input):\n        sysfs_path = config.get('sysfs_path')\n        argument = config.get('argument', '')\n\n        if self.REF_KEY in argument:\n            argument = self._main_conf[argument.split(\":\")[1]]\n\n        if type(argument) is list:\n            sysfs_path = sysfs_path.format(argument[index])\n\n        write_offset = int(config.get('write_offset', 0))\n        output = \"\"\n        try:\n            open_file = open(sysfs_path, \"r+\")\n            open_file.seek(write_offset)\n            open_file.write(input)\n            open_file.close()\n        except IOError as e:\n            print(\"Error: unable to open file: %s\" % str(e))\n            return False, output\n        return True, output\n\n    def _ipmi_set(self, index, config, input):\n        arg = config['argument'][index].format(input)\n        return self._run_command(config['command'].format(arg))\n\n    def _hex_ver_decode(self, hver, num_of_bits, num_of_points):\n        ver_list = []\n        c_bit = 0\n        bin_val = bin(int(hver, 16))[2:].zfill(num_of_bits)\n        bit_split = num_of_bits / (num_of_points + 1)\n        for x in range(0, num_of_points+1):\n            split_bin = bin_val[c_bit:c_bit+bit_split]\n            ver_list.append(str(int(split_bin, 2)))\n            c_bit += bit_split\n        return '.'.join(ver_list)\n\n    def _get_class(self, config):\n        \"\"\"\n        Retreives value of expected attribute\n        Returns:\n            A value of the attribute of object\n        \"\"\"\n        path = config['host_path'] if self.is_host() else config['pmon_path']\n        module = imp.load_source(config['class'], path)\n        class_ = getattr(module, config['class'])\n        return class_\n\n    def get_reg(self, path, reg_addr):\n        cmd = \"echo {1} > {0}; cat {0}\".format(path, reg_addr)\n        status, output = self._run_command(cmd)\n        return output if status else None\n\n    def read_txt_file(self, path):\n        with open(path, 'r') as f:\n            output = f.readline()\n        return output.strip('\\n')\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except Exception:\n            return False\n        return True\n\n    def is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def load_json_file(self, path):\n        \"\"\"\n        Retrieves the json object from json file path\n\n        Returns:\n            A json object\n        \"\"\"\n        with open(path, 'r') as f:\n            json_data = yaml.safe_load(f)\n\n        return json_data\n\n    def get_config_path(self, config_name):\n        \"\"\"\n        Retrieves the path to platform api config directory\n\n        Args:\n            config_name: A string containing the name of config file.\n\n        Returns:\n            A string containing the path to json file\n        \"\"\"\n        return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\n\n    def get_output(self, index, config, default):\n        \"\"\"\n        Retrieves the output for each function base on config\n\n        Args:\n            index: An integer containing the index of device.\n            config: A dict object containing the configuration of specified function.\n            default: A string containing the default output of specified function.\n\n        Returns:\n            A string containing the output of specified function in config\n        \"\"\"\n        output_source = config.get('output_source')\n\n        if output_source == self.OUTPUT_SOURCE_IPMI:\n            output = self._ipmi_get(index, config)\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VALUE:\n            output = config[\"value\"]\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_CLASS:\n            output = self._get_class(config)\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_LIST:\n            output = config[\"value_list\"][index]\n\n        elif output_source == self.OUTPUT_SOURCE_SYSFS:\n            output = self._sysfs_read(index, config)\n\n        elif output_source == self.OUTPUT_SOURCE_FUNC:\n            func_conf = self._main_conf[config['function'][index]]\n            output = self.get_output(index, func_conf, default)\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\n            path = config.get('path')\n            output = self.read_txt_file(path)\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\n            path = config.get('path')\n            hex_ver = self.read_txt_file(path)\n            output = self._hex_ver_decode(\n                hex_ver, config['num_of_bits'], config['num_of_points'])\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\n            path = config.get('path')\n            addr = config.get('reg_addr')\n            hex_ver = self.get_reg(path, addr)\n            output = self._hex_ver_decode(\n                hex_ver, config['num_of_bits'], config['num_of_points'])\n\n        else:\n            output = default\n\n        return self._clean_output(index, output, config) or default\n\n    def set_output(self, index, input, config):\n        \"\"\"\n        Sets the output of specified function on config\n\n        Args:\n            config: A dict object containing the configuration of specified function.\n            index: An integer containing the index of device.\n            input: A string containing the input of specified function.\n\n        Returns:\n            bool: True if set function is successfully, False if not\n        \"\"\"\n        cleaned_input = self._clean_input(input, config)\n        if not cleaned_input:\n            return False\n\n        set_method = config.get('set_method')\n        if set_method == self.SET_METHOD_IPMI:\n            output = self._ipmi_set(index, config, cleaned_input)[0]\n        elif set_method == self.OUTPUT_SOURCE_SYSFS:\n            output = self._sysfs_write(index, config, cleaned_input)[0]\n        else:\n            output = False\n\n        return output\n\n    def get_event(self, timeout, config, sfp_list):\n        \"\"\"\n        Returns a nested dictionary containing all devices which have\n        experienced a change at chassis level\n\n        \"\"\"\n        event_class = self._get_class(config)\n        return event_class(sfp_list).get_event(timeout)\n"}, "/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py": {"changes": [{"diff": "\n import logging\n import subprocess\n \n-IPMI_SDR_CMD = \"ipmitool sdr elist\"\n+IPMI_SDR_CMD = [\"ipmitool\", \"sdr\", \"elist\"]\n MAX_NUM_FANS = 7\n MAX_NUM_PSUS = 2\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py", "badparts": ["IPMI_SDR_CMD = \"ipmitool sdr elist\""], "goodparts": ["IPMI_SDR_CMD = [\"ipmitool\", \"sdr\", \"elist\"]"]}, {"diff": "\n     '''\n     sensor_dump = ''\n     try:\n-        sensor_dump = subprocess.check_output(cmd, shell=True)\n+        sensor_dump = subprocess.check_output(cmd)\n     except subprocess.CalledProcessError as e:\n         logging.error('Error! Failed to execute: {}'.format(cmd))\n         sys.exit(1)\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py", "badparts": ["        sensor_dump = subprocess.check_output(cmd, shell=True)"], "goodparts": ["        sensor_dump = subprocess.check_output(cmd)"]}], "source": "\n import sys import logging import subprocess IPMI_SDR_CMD=\"ipmitool sdr elist\" MAX_NUM_FANS=7 MAX_NUM_PSUS=2 def ipmi_sensor_dump(cmd): ''' Execute ipmitool command return dump output exit if any error occur. ''' sensor_dump='' try: sensor_dump=subprocess.check_output(cmd, shell=True) except subprocess.CalledProcessError as e: logging.error('Error! Failed to execute:{}'.format(cmd)) sys.exit(1) return sensor_dump def get_reading_by_name(sensor_name, sdr_elist_dump): ''' Search for the match sensor name, return sensor reading value and unit, return object epmtry string if search not match. The output of sensor dump: TEMP_FAN_U52 | 00h | ok | 7.1 | 31 degrees C TEMP_FAN_U17 | 01h | ok | 7.1 | 27 degrees C TEMP_SW_U52 | 02h | ok | 7.1 | 30 degrees C Fan2_Status | 07h | ok | 29.2 | Present Fan2_Front | 0Eh | ok | 29.2 | 12000 RPM Fan2_Rear | 46h | ok | 29.2 | 14700 RPM PSU2_Status | 39h | ok | 10.2 | Presence detected PSU2_Fan | 3Dh | ok | 10.2 | 16000 RPM PSU2_VIn | 3Ah | ok | 10.2 | 234.30 Volts PSU2_CIn | 3Bh | ok | 10.2 | 0.80 Amps ''' found='' for line in sdr_elist_dump.split(\"\\n\"): if sensor_name in line: found=line.strip() break if not found: logging.error('Cannot find sensor name:' +sensor_name) else: try: found=found.split('|')[4] except IndexError: logging.error('Cannot get sensor data of:' +sensor_name) logging.basicConfig(level=logging.DEBUG) return found def read_temperature_sensors(ipmi_sdr_elist): sensor_list=[ ('TEMP_FAN_U52', 'Fan Tray Middle Temp'), ('TEMP_FAN_U17', 'Fan Tray Right Temp'), ('TEMP_SW_U52', 'Switchboard Left Inlet Temp'), ('TEMP_SW_U16', 'Switchboard Right Inlet Temp'), ('TEMP_BB_U3', 'Baseboard Temp'), ('TEMP_CPU', 'CPU Internal Temp'), ('TEMP_SW_Internal', 'ASIC Internal Temp'), ('SW_U04_Temp', 'IR3595 Chip Left Temp'), ('SW_U14_Temp', 'IR3595 Chip Right Temp'), ('SW_U4403_Temp', 'IR3584 Chip Temp'), ] output='' sensor_format='{0:{width}}{1}\\n' max_name_width=max(len(sensor[1]) for sensor in sensor_list) output +=\"Temperature Sensors\\n\" output +=\"Adapter: IPMI adapter\\n\" for sensor in sensor_list: reading=get_reading_by_name(sensor[0],ipmi_sdr_elist) output +=sensor_format.format('{}:'.format(sensor[1]), reading, width=str(max_name_width+1)) output +='\\n' return output def read_fan_sensors(num_fans, ipmi_sdr_elist): sensor_list=[ ('Fan{}_Status', 'Status'), ('Fan{}_Front', 'Fan{} front'), ('Fan{}_Rear', 'Fan{} rear'), ] output='' sensor_format='{0:{width}}{1}\\n' max_name_width=max(len(sensor[1]) for sensor in sensor_list) output +=\"Fan Trays\\n\" output +=\"Adapter: IPMI adapter\\n\" for fan_num in range(1, num_fans+1): for sensor in sensor_list: ipmi_sensor_name=sensor[0].format(fan_num) display_sensor_name=sensor[1].format(fan_num) reading=get_reading_by_name(ipmi_sensor_name, ipmi_sdr_elist) output +=sensor_format.format('{}:'.format(display_sensor_name), reading, width=str(max_name_width+1)) output +='\\n' return output def read_psu_sensors(num_psus, ipmi_sdr_elist): sensor_list=[ ('PSU{}_Status', 'PSU{} Status'), ('PSU{}_Fan', 'PSU{} Fan'), ('PSU{}_VIn', 'PSU{} Input Voltag'), ('PSU{}_CIn', 'PSU{} Input Current'), ('PSU{}_PIn', 'PSU{} Input Power'), ('PSU{}_Temp1', 'PSU{} Temp1'), ('PSU{}_Temp2', 'PSU{} Temp2'), ('PSU{}_VOut', 'PSU{} Output Voltag'), ('PSU{}_COut', 'PSU{} Output Current'), ('PSU{}_POut', 'PSU{} Output Power'), ] output='' sensor_format='{0:{width}}{1}\\n' max_name_width=max(len(sensor[1]) for sensor in sensor_list) output +=\"PSU\\n\" output +=\"Adapter: IPMI adapter\\n\" for psu_num in range(1, num_psus+1): for sensor in sensor_list: ipmi_sensor_name=sensor[0].format(psu_num) display_sensor_name=sensor[1].format(psu_num) reading=get_reading_by_name(ipmi_sensor_name, ipmi_sdr_elist) output +=sensor_format.format('{}:'.format(display_sensor_name), reading, width=str(max_name_width+1)) output +='\\n' return output def main(): output_string='' ipmi_sdr_elist=ipmi_sensor_dump(IPMI_SDR_CMD) output_string +=read_temperature_sensors(ipmi_sdr_elist) output_string +=read_psu_sensors(MAX_NUM_PSUS, ipmi_sdr_elist) output_string +=read_fan_sensors(MAX_NUM_FANS, ipmi_sdr_elist) print(output_string) if __name__=='__main__': main() ", "sourceWithComments": "#!/usr/bin/python\n#\n# Silverstone platform sensors. This script get the sensor data from BMC \n# using ipmitool and display them in lm-sensor alike format.\n#\n# The following data is support:\n#  1. Temperature sensors\n#  2. PSUs\n#  3. Fan trays\n\nimport sys\nimport logging\nimport subprocess\n\nIPMI_SDR_CMD = \"ipmitool sdr elist\"\nMAX_NUM_FANS = 7\nMAX_NUM_PSUS = 2\n\n\ndef ipmi_sensor_dump(cmd):\n    ''' Execute ipmitool command return dump output\n        exit if any error occur.\n    '''\n    sensor_dump = ''\n    try:\n        sensor_dump = subprocess.check_output(cmd, shell=True)\n    except subprocess.CalledProcessError as e:\n        logging.error('Error! Failed to execute: {}'.format(cmd))\n        sys.exit(1)\n    return sensor_dump\n\ndef get_reading_by_name(sensor_name, sdr_elist_dump):\n    '''\n        Search for the match sensor name, return sensor\n        reading value and unit, return object epmtry string \n        if search not match.\n\n        The output of sensor dump:\n        TEMP_FAN_U52     | 00h | ok  |  7.1 | 31 degrees C\n        TEMP_FAN_U17     | 01h | ok  |  7.1 | 27 degrees C\n        TEMP_SW_U52      | 02h | ok  |  7.1 | 30 degrees C\n        Fan2_Status      | 07h | ok  | 29.2 | Present\n        Fan2_Front       | 0Eh | ok  | 29.2 | 12000 RPM\n        Fan2_Rear        | 46h | ok  | 29.2 | 14700 RPM\n        PSU2_Status      | 39h | ok  | 10.2 | Presence detected\n        PSU2_Fan         | 3Dh | ok  | 10.2 | 16000 RPM\n        PSU2_VIn         | 3Ah | ok  | 10.2 | 234.30 Volts\n        PSU2_CIn         | 3Bh | ok  | 10.2 | 0.80 Amps\n    '''\n    found = ''\n\n    for line in sdr_elist_dump.split(\"\\n\"):\n        if sensor_name in line:\n            found = line.strip()\n            break\n\n    if not found:\n        logging.error('Cannot find sensor name:' + sensor_name)\n\n    else:\n        try:\n            found = found.split('|')[4]\n        except IndexError:\n            logging.error('Cannot get sensor data of:' + sensor_name)\n\n    logging.basicConfig(level=logging.DEBUG)\n    return found\n\n\ndef read_temperature_sensors(ipmi_sdr_elist):\n\n    sensor_list = [\n        ('TEMP_FAN_U52',        'Fan Tray Middle Temp'),\n        ('TEMP_FAN_U17',        'Fan Tray Right Temp'),\n        ('TEMP_SW_U52',         'Switchboard Left Inlet Temp'),\n        ('TEMP_SW_U16',         'Switchboard Right Inlet Temp'),\n        ('TEMP_BB_U3',          'Baseboard Temp'),\n        ('TEMP_CPU',            'CPU Internal Temp'),\n        ('TEMP_SW_Internal',    'ASIC Internal Temp'),\n        ('SW_U04_Temp',         'IR3595 Chip Left Temp'),\n        ('SW_U14_Temp',         'IR3595 Chip Right Temp'),\n        ('SW_U4403_Temp',       'IR3584 Chip Temp'),\n    ]\n\n    output = ''\n    sensor_format = '{0:{width}}{1}\\n'\n    # Find max length of sensor calling name\n    max_name_width = max(len(sensor[1]) for sensor in sensor_list)\n\n    output += \"Temperature Sensors\\n\"\n    output += \"Adapter: IPMI adapter\\n\"\n    for sensor in sensor_list:\n        reading = get_reading_by_name(sensor[0],ipmi_sdr_elist)\n        output += sensor_format.format('{}:'.format(sensor[1]),\n                                       reading,\n                                       width=str(max_name_width+1))\n    output += '\\n'\n    return output\n\n\ndef read_fan_sensors(num_fans, ipmi_sdr_elist):\n\n    sensor_list = [\n        ('Fan{}_Status',    'Status'),\n        ('Fan{}_Front',     'Fan {} front'),\n        ('Fan{}_Rear',      'Fan {} rear'),\n    ]\n\n    output = ''\n    sensor_format = '{0:{width}}{1}\\n'\n    # Find max length of sensor calling name\n    max_name_width = max(len(sensor[1]) for sensor in sensor_list)\n\n    output += \"Fan Trays\\n\"\n    output += \"Adapter: IPMI adapter\\n\"\n    for fan_num in range(1, num_fans+1):\n        for sensor in sensor_list:\n            ipmi_sensor_name = sensor[0].format(fan_num)\n            display_sensor_name = sensor[1].format(fan_num)\n            reading = get_reading_by_name(ipmi_sensor_name, ipmi_sdr_elist)\n            output += sensor_format.format('{}:'.format(display_sensor_name),\n                                           reading,\n                                           width=str(max_name_width+1))\n    output += '\\n'\n    return output\n\n\ndef read_psu_sensors(num_psus, ipmi_sdr_elist):\n\n    sensor_list = [\n        ('PSU{}_Status',    'PSU {} Status'),\n        ('PSU{}_Fan',       'PSU {} Fan'),\n        ('PSU{}_VIn',       'PSU {} Input Voltag'),\n        ('PSU{}_CIn',       'PSU {} Input Current'),\n        ('PSU{}_PIn',       'PSU {} Input Power'),\n        ('PSU{}_Temp1',     'PSU {} Temp1'),\n        ('PSU{}_Temp2',     'PSU {} Temp2'),\n        ('PSU{}_VOut',      'PSU {} Output Voltag'),\n        ('PSU{}_COut',      'PSU {} Output Current'),\n        ('PSU{}_POut',      'PSU {} Output Power'),\n    ]\n\n    output = ''\n    sensor_format = '{0:{width}}{1}\\n'\n    # Find max length of sensor calling name\n    max_name_width = max(len(sensor[1]) for sensor in sensor_list)\n\n    output += \"PSU\\n\"\n    output += \"Adapter: IPMI adapter\\n\"\n    for psu_num in range(1, num_psus+1):\n        for sensor in sensor_list:\n            ipmi_sensor_name = sensor[0].format(psu_num)\n            display_sensor_name = sensor[1].format(psu_num)\n            reading = get_reading_by_name(ipmi_sensor_name, ipmi_sdr_elist)\n            output += sensor_format.format('{}:'.format(display_sensor_name),\n                                           reading,\n                                           width=str(max_name_width+1))\n    output += '\\n'\n    return output\n\n\ndef main():\n    output_string = ''\n\n    ipmi_sdr_elist = ipmi_sensor_dump(IPMI_SDR_CMD)\n    output_string += read_temperature_sensors(ipmi_sdr_elist)\n    output_string += read_psu_sensors(MAX_NUM_PSUS, ipmi_sdr_elist)\n    output_string += read_fan_sensors(MAX_NUM_FANS, ipmi_sdr_elist)\n    print(output_string)\n\n\nif __name__ == '__main__':\n    main()\n"}}, "msg": "[device/celestica] Mitigation for command injection vulnerability (#11740)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\nDependency: [PR (#12065)](https://github.com/sonic-net/sonic-buildimage/pull/12065) needs to merge first.\r\n#### Why I did it\r\n1. `eval()` - not secure against maliciously constructed input, can be dangerous if used to evaluate dynamic content. This may be a code injection vulnerability.\r\n2. `subprocess()` - when using with `shell=True` is dangerous. Using subprocess function without a static string can lead to command injection.\r\n3. `os` - not secure against maliciously constructed input and dangerous if used to evaluate dynamic content.\r\n4. `is` operator - string comparison should not be used with reference equality.\r\n5. `globals()` - extremely dangerous because it may allow an attacker to execute arbitrary code on the system\r\n#### How I did it\r\n1. `eval()` - use `literal_eval()`\r\n2. `subprocess()` - use `shell=False` instead. use an array string. Ref: [https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation](https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation)\r\n3. `os` - use with `subprocess`\r\n4. `is` - replace by `==` operator for value equality\r\n5. `globals()` - avoid the use of globals()"}}, "https://github.com/SaranyaAzhgamuthaiyan/sonic-buildimage": {"92d25be08f3866b4ae37f8eeba7ef53369851803": {"url": "https://api.github.com/repos/SaranyaAzhgamuthaiyan/sonic-buildimage/commits/92d25be08f3866b4ae37f8eeba7ef53369851803", "html_url": "https://github.com/SaranyaAzhgamuthaiyan/sonic-buildimage/commit/92d25be08f3866b4ae37f8eeba7ef53369851803", "sha": "92d25be08f3866b4ae37f8eeba7ef53369851803", "keyword": "command injection malicious", "diff": "diff --git a/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py b/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py\nindex bcb05b9cb..9c994c572 100755\n--- a/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py\n@@ -17,13 +17,11 @@\n \n try:\n     import os\n-    import commands\n-    import sys, getopt\n-    import logging\n     import re\n     import time\n     import syslog\n     from sonic_sfp.bcmshell import bcmshell\n+    from sonic_py_common.general import getstatusoutput_noshell\n     \n except ImportError as e:\n     raise ImportError(\"%s - required module not found\" % str(e))\n@@ -53,10 +51,10 @@ def initialLoop():\n             bcm_obj = BCMUtil()\n             bcm_obj.execute_command(\"echo\")\n             initialNotOK = False\n-            print bcm_obj\n+            print(bcm_obj)\n             log_message( syslog.LOG_INFO, \"BCMUtil Object initialed successfully\" )  \n-        except Exception, e:   \n-            print \"Exception. The warning is {0}\".format(str(e)) \n+        except Exception as e:   \n+            print(\"Exception. The warning is {0}\".format(str(e)))\n             time.sleep(10)\n             \n class BCMUtil(bcmshell):\n@@ -66,7 +64,7 @@ class BCMUtil(bcmshell):\n     \n     def get_platform(self):\n         if self.platform is None:\n-            self.platform = os.popen(\"uname -n\").read().strip()\n+            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"]).strip()\n         return self.platform\n         \n     def get_asic_temperature( self ):\n@@ -102,14 +100,18 @@ def main():\n                         content = readPtr.read().strip()\n                         if bcm_obj.get_platform() == INV_SEQUOIA_PLATFORM :\n                             if content == \"inv_bmc\" and SWITCH_TEMP_FILE_NAME in file_list :\n-                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n+                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)\n+                                with open(file, 'w') as f:\n+                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')\n                                 break\n                         else :\n                             if content == \"inv_psoc\" and SWITCH_TEMP_FILE_NAME in file_list :\n-                                print \"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME )\n-                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n+                                print(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME))\n+                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)\n+                                with open(file, 'w') as f:\n+                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')\n                                 break\n-        except Exception, e:\n+        except Exception as e:\n             log_message( syslog.LOG_WARNING, \"Exception. The warning is {0}\".format(str(e)) )\n             initialLoop()            \n         time.sleep(5)\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py b/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py\nindex bab0e2daf..8f4564287 100755\n--- a/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py\n@@ -20,6 +20,7 @@\n import syslog\n import re\n from sonic_sfp.bcmshell import bcmshell\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n # =====================================================================\n@@ -120,8 +121,8 @@ def _board_init():\n     global SYNC_S\n     global SYNC_P\n \n-    cmd = \"uname -n\"\n-    platform = os.popen(cmd).read()\n+    cmd = [\"uname\", \"-n\"]\n+    _, platform = getstatusoutput_noshell(cmd)\n \n     if platform.rstrip() == INV_MAGNOLIA:\n         BOARD_TPYE      = \"inventec_d6254qs\"\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py b/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py\nindex f1e7f7fec..d73687e02 100755\n--- a/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py\n@@ -2,6 +2,7 @@\n \n import os\n import socket\n+import subprocess\n from collections import OrderedDict\n \n # Purpose:  Shutdown DUT upon receiving thermaltrip event from kernel (inv_pthread)\n@@ -59,6 +60,6 @@ def next_events(self):\n \n             # Receive thermaltrip event\n             if event['ACTION'] == 'remove' and event['DEVPATH'] == '/kernel/platform_status/fan':\n-                os.system(\"shutdown -h now\")\n+                subprocess.call([\"shutdown\", \"-h\", \"now\"])\n                 \n \ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py b/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py\nindex 9e4a44c16..453c33dee 100755\n--- a/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py\n@@ -28,6 +28,7 @@\n     import syslog\n     from sfputil import SfpUtil\n     from sonic_sfp.bcmshell import bcmshell\n+    from sonic_py_common.general import getstatusoutput_noshell\n     \n except ImportError as e:\n     raise ImportError(\"%s - required module not found\" % str(e))\n@@ -127,7 +128,7 @@ class BCMUtil(bcmshell):\n     \n     def get_platform(self):\n         if self.platform is None:\n-            self.platform = os.popen(\"uname -n\").read().strip()\n+            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"])\n         return self.platform\n     \n     def get_port_to_bcm_mapping(self):  \ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py b/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py\nindex b1f8799ab..f71a19d00 100644\n--- a/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py\n@@ -8,6 +8,7 @@\n try:\n     import os\n     import logging\n+    import subprocess\n     from ctypes import create_string_buffer\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8436 import sff8436Dom\n@@ -120,7 +121,7 @@ def __set_attr_value(self, attr_path, value):\n         return True\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/device'\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py b/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py\nindex a468a323d..d467fd8fb 100755\n--- a/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py\n@@ -33,6 +33,7 @@\n import logging\n import syslog\n import time\n+from sonic_py_common.general import getstatusoutput_noshell_pipe\n \n DEBUG = False\n args = []\n@@ -236,8 +237,9 @@ def system_install(boot_option):\n \t      return status\n     for addr_offset in range (0,FAN_NUM):\n         addr=FAN_VPD_ADDR_BASE+addr_offset\n-        cmd = \"i2cdetect -y \"+str(FAN_VPD_CHANNEL)+\" \"+str(addr)+\" \"+str(addr)+\" | grep \"+str(hex(addr)).replace('0x','')\n-        result=os.system(cmd)\n+        cmd1 = [\"i2cdetect\", \"-y\", str(FAN_VPD_CHANNEL), str(addr), str(addr)]\n+        cmd2 = [\"grep\", f'{addr:x}']\n+        result, _ = getstatusoutput_noshell_pipe(cmd1, cmd2)\n         if( result==0 ):\n             cmd=\"echo inv_eeprom \"+str(addr)+\" > /sys/bus/i2c/devices/i2c-\"+FAN_VPD_CHANNEL\n             status, output = exec_cmd(cmd,1)\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py b/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py\nindex fccde46df..22eae317f 100644\n--- a/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py\n@@ -9,6 +9,7 @@\n     import os\n     import sys\n     import time\n+    import subprocess\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8436 import sff8436Dom\n     from sonic_platform_base.sonic_sfp.sff8436 import sff8436InterfaceId\n@@ -108,7 +109,7 @@ def __get_attr_value(self, attr_path):\n         return retval\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/device'\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py b/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py\nindex 5c75a8749..de8d50b7a 100644\n--- a/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py\n@@ -7,7 +7,7 @@\n \n try:\n     import os\n-    import sys\n+    import subprocess\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472InterfaceId\n@@ -95,7 +95,7 @@ def __get_attr_value(self, attr_path):\n         return retval\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/device'\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py b/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py\nindex 9d6337195..ee5768a64 100644\n--- a/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py\n@@ -153,7 +153,7 @@ class Sfp(SfpBase):\n     # Path to QSFP sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-inventec_d7054q28b-r0\"\n     HWSKU  = \"INVENTEC-D7054Q28B-S48-Q6\"\n@@ -285,7 +285,7 @@ def __read_txt_file(self, file_path):\n         return \"\"\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n", "message": "", "files": {"/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py": {"changes": [{"diff": "\n \n try:\n     import os\n-    import commands\n-    import sys, getopt\n-    import logging\n     import re\n     import time\n     import syslog\n     from sonic_sfp.bcmshell import bcmshell\n+    from sonic_py_common.general import getstatusoutput_noshell\n     \n except ImportError as e:\n     raise ImportError(\"%s - required module not found\" % str(e))\n", "add": 1, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py", "badparts": ["    import commands", "    import sys, getopt", "    import logging"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n             bcm_obj = BCMUtil()\n             bcm_obj.execute_command(\"echo\")\n             initialNotOK = False\n-            print bcm_obj\n+            print(bcm_obj)\n             log_message( syslog.LOG_INFO, \"BCMUtil Object initialed successfully\" )  \n-        except Exception, e:   \n-            print \"Exception. The warning is {0}\".format(str(e)) \n+        except Exception as e:   \n+            print(\"Exception. The warning is {0}\".format(str(e)))\n             time.sleep(10)\n             \n class BCMUtil(bcmshell):\n", "add": 3, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py", "badparts": ["            print bcm_obj", "        except Exception, e:   ", "            print \"Exception. The warning is {0}\".format(str(e)) "], "goodparts": ["            print(bcm_obj)", "        except Exception as e:   ", "            print(\"Exception. The warning is {0}\".format(str(e)))"]}, {"diff": "\n     \n     def get_platform(self):\n         if self.platform is None:\n-            self.platform = os.popen(\"uname -n\").read().strip()\n+            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"]).strip()\n         return self.platform\n         \n     def get_asic_temperature( self ):\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py", "badparts": ["            self.platform = os.popen(\"uname -n\").read().strip()"], "goodparts": ["            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"]).strip()"]}, {"diff": "\n                         content = readPtr.read().strip()\n                         if bcm_obj.get_platform() == INV_SEQUOIA_PLATFORM :\n                             if content == \"inv_bmc\" and SWITCH_TEMP_FILE_NAME in file_list :\n-                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n+                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)\n+                                with open(file, 'w') as f:\n+                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')\n                                 break\n                         else :\n                             if content == \"inv_psoc\" and SWITCH_TEMP_FILE_NAME in file_list :\n-                                print \"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME )\n-                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n+                                print(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME))\n+                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)\n+                                with open(file, 'w') as f:\n+                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')\n                                 break\n-        except Exception, e:\n+        except Exception as e:\n             log_message( syslog.LOG_WARNING, \"Exception. The warning is {0}\".format(str(e)) )\n             initialLoop()            \n         time.sleep(5)", "add": 8, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py", "badparts": ["                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))", "                                print \"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME )", "                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))", "        except Exception, e:"], "goodparts": ["                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)", "                                with open(file, 'w') as f:", "                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')", "                                print(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME))", "                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)", "                                with open(file, 'w') as f:", "                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')", "        except Exception as e:"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object Auto detecting the Chipset temperature and update options: -h | --help : this help message -d | --debug : run with debug mode \"\"\" try: import os import commands import sys, getopt import logging import re import time import syslog from sonic_sfp.bcmshell import bcmshell except ImportError as e: raise ImportError(\"%s -required module not found\" % str(e)) args=[] INV_REDWOOD_PLATFORM=\"SONiC-Inventec-d7032-100\" INV_CYPRESS_PLATFORM=\"SONiC-Inventec-d7054\" INV_SEQUOIA_PLATFORM=\"SONiC-Inventec-d7264\" INV_MAPLE_PLATFORM=\"SONiC-Inventec-d6556\" INV_MAGNOLIA_PLATFORM=\"SONiC-Inventec-d6254qs\" PSOC_NAME=\"name\" HWMON_PATH=\"/sys/class/hwmon/\" SWITCH_TEMP_FILE_NAME=\"switch_tmp\" def log_message( level, string): syslog.openlog(\"asic_monitor\", syslog.LOG_PID, facility=syslog.LOG_DAEMON) syslog.syslog( level, string) def initialLoop(): global bcm_obj initialNotOK=True while initialNotOK: try: bcm_obj=BCMUtil() bcm_obj.execute_command(\"echo\") initialNotOK=False print bcm_obj log_message( syslog.LOG_INFO, \"BCMUtil Object initialed successfully\") except Exception, e: print \"Exception. The warning is{0}\".format(str(e)) time.sleep(10) class BCMUtil(bcmshell): asic_temperature=0 platform=None def get_platform(self): if self.platform is None: self.platform=os.popen(\"uname -n\").read().strip() return self.platform def get_asic_temperature( self): return self.asic_temperature def set_asic_temperature( self, temp): self.asic_temperature=temp def parsing_asic_temp(self): content=self.run(\"show temp\") for line in content.split(\"\\n\"): TempObject=re.search(r\"(average current temperature is)\\s+(?P<temperature_high>\\d+)\\.(?P<temperature_low>\\d+)\",line) if TempObject is not None: self.set_asic_temperature( int( TempObject.group(\"temperature_high\"))) def execute_command(self, cmd): return self.run(cmd) def main(): global bcm_obj initialLoop() log_message( syslog.LOG_INFO, \"Object initialed successfully\") while 1: try: bcm_obj.parsing_asic_temp() for index in os.listdir(HWMON_PATH): file_list=os.listdir(\"{0}/{1}/device/\".format(HWMON_PATH,index)) if PSOC_NAME in file_list: with open( \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, PSOC_NAME), 'rb') as readPtr: content=readPtr.read().strip() if bcm_obj.get_platform()==INV_SEQUOIA_PLATFORM: if content==\"inv_bmc\" and SWITCH_TEMP_FILE_NAME in file_list: os.system(\"echo{0} >{1}/{2}/device/{3}\".format(( bcm_obj.get_asic_temperature() * 1000), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)) break else: if content==\"inv_psoc\" and SWITCH_TEMP_FILE_NAME in file_list: print \"echo{0} >{1}/{2}/device/{3}\".format(( bcm_obj.get_asic_temperature() * 1000), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME) os.system(\"echo{0} >{1}/{2}/device/{3}\".format(( bcm_obj.get_asic_temperature() * 1000), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)) break except Exception, e: log_message( syslog.LOG_WARNING, \"Exception. The warning is{0}\".format(str(e))) initialLoop() time.sleep(5) syslog.closelog() del bcm_obj if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2018 Inventec, Inc.\n# \n# Editor: James Huang ( Huang.James@inventec.com )\n#  \n\"\"\"\nUsage: %(scriptName)s [options] command object\n\nAuto detecting the Chipset temperature and update\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n   \n\"\"\"\n\ntry:\n    import os\n    import commands\n    import sys, getopt\n    import logging\n    import re\n    import time\n    import syslog\n    from sonic_sfp.bcmshell import bcmshell\n    \nexcept ImportError as e:\n    raise ImportError(\"%s - required module not found\" % str(e))\n\nargs = []\nINV_REDWOOD_PLATFORM = \"SONiC-Inventec-d7032-100\"\nINV_CYPRESS_PLATFORM = \"SONiC-Inventec-d7054\"\nINV_SEQUOIA_PLATFORM = \"SONiC-Inventec-d7264\"\nINV_MAPLE_PLATFORM = \"SONiC-Inventec-d6556\"\nINV_MAGNOLIA_PLATFORM = \"SONiC-Inventec-d6254qs\"\n\nPSOC_NAME = \"name\"\nHWMON_PATH = \"/sys/class/hwmon/\"\nSWITCH_TEMP_FILE_NAME = \"switch_tmp\"\n\ndef log_message( level, string ):\n    syslog.openlog(\"asic_monitor\", syslog.LOG_PID, facility=syslog.LOG_DAEMON)\n    syslog.syslog( level, string )\n\ndef initialLoop():\n\n    global bcm_obj\n    initialNotOK = True\n    \n    while initialNotOK :        \n        try:                \n            bcm_obj = BCMUtil()\n            bcm_obj.execute_command(\"echo\")\n            initialNotOK = False\n            print bcm_obj\n            log_message( syslog.LOG_INFO, \"BCMUtil Object initialed successfully\" )  \n        except Exception, e:   \n            print \"Exception. The warning is {0}\".format(str(e)) \n            time.sleep(10)\n            \nclass BCMUtil(bcmshell):\n\n    asic_temperature = 0\n    platform = None\n    \n    def get_platform(self):\n        if self.platform is None:\n            self.platform = os.popen(\"uname -n\").read().strip()\n        return self.platform\n        \n    def get_asic_temperature( self ):\n        return self.asic_temperature\n        \n    def set_asic_temperature( self, temp ):\n        self.asic_temperature = temp\n                \n    def parsing_asic_temp(self):\n        content = self.run(\"show temp\")\n        for line in content.split(\"\\n\"):\n            TempObject = re.search(r\"(average current temperature is)\\s+(?P<temperature_high>\\d+)\\.(?P<temperature_low>\\d+)\",line)\n            if TempObject is not None:\n                self.set_asic_temperature( int( TempObject.group(\"temperature_high\") ) )\n        \n    def execute_command(self, cmd):\n        return self.run(cmd)\n     \n        \ndef main():\n\n    global bcm_obj\n    initialLoop()\n    log_message( syslog.LOG_INFO, \"Object initialed successfully\" )\n\n    while 1 :\n        try:\n            bcm_obj.parsing_asic_temp()\n            for index in os.listdir(HWMON_PATH):\n                file_list = os.listdir(\"{0}/{1}/device/\".format(HWMON_PATH,index))\n                if PSOC_NAME in file_list :\n                    with open( \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, PSOC_NAME), 'rb') as readPtr:\n                        content = readPtr.read().strip()\n                        if bcm_obj.get_platform() == INV_SEQUOIA_PLATFORM :\n                            if content == \"inv_bmc\" and SWITCH_TEMP_FILE_NAME in file_list :\n                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n                                break\n                        else :\n                            if content == \"inv_psoc\" and SWITCH_TEMP_FILE_NAME in file_list :\n                                print \"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME )\n                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n                                break\n        except Exception, e:\n            log_message( syslog.LOG_WARNING, \"Exception. The warning is {0}\".format(str(e)) )\n            initialLoop()            \n        time.sleep(5)\n\n    syslog.closelog()\n    del bcm_obj\n\nif __name__ == \"__main__\":\n    main()\n\n\n\n\n\n"}, "/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py": {"changes": [{"diff": "\n     global SYNC_S\n     global SYNC_P\n \n-    cmd = \"uname -n\"\n-    platform = os.popen(cmd).read()\n+    cmd = [\"uname\", \"-n\"]\n+    _, platform = getstatusoutput_noshell(cmd)\n \n     if platform.rstrip() == INV_MAGNOLIA:\n         BOARD_TPYE      = \"inventec_d6254qs", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py", "badparts": ["    cmd = \"uname -n\"", "    platform = os.popen(cmd).read()"], "goodparts": ["    cmd = [\"uname\", \"-n\"]", "    _, platform = getstatusoutput_noshell(cmd)"]}], "source": "\n import os import time import syslog import re from sonic_sfp.bcmshell import bcmshell PORT_LIST =[] BCM_SHELL =None SHELL_READY=False STATUS_RX =1<<0 STATUS_TX =1<<1 PORT_DATA_OFFSET_ADDR =0xA0 INV_MAGNOLIA =\"SONiC-Inventec-d6254qs\" INV_REDWOOD =\"SONiC-Inventec-d7032-100\" INV_CYPRESS =\"SONiC-Inventec-d7054\" INV_MAPLE =\"SONiC-Inventec-d6556\" INV_SEQUOIA =\"\" BOARD_TPYE =\"\" EAGLE_CORE =[] BIT_LINK =None BIT_FAULT =None BIT_TX =None BIT_RX =None BIT_SPEED0 =None BIT_SPEED1 =None SPEED_100G =100 SPEED_40G =40 SPEED_25G =25 SPEED_10G =10 class Port(): port_num =None name =None bcm_id =None led_up =None s_addr =None write2_up =None led_index =None link_status =None speed =None def write_data_ram(self, data): BCM_SHELL.cmd(\"setreg CMIC_LEDUP{0}_DATA_RAM({1}){2}\".format(self.write2_up, self.led_index, data)) def read_data_ram(self): r_string=BCM_SHELL.run(\"getreg CMIC_LEDUP{0}_DATA_RAM({1})\".format(self.led_up, self.s_addr)) for line in r_string.split(\"\\n\"): re_obj=re.search(r\"\\<DATA\\=(?P<data>.+)\\>\", line) if re_obj is not None: return int(re_obj.group(\"data\"), 16) def _remap_registers(fp): content=fp.readlines() fp.close() err=False for line in content: try: BCM_SHELL.cmd(line.rstrip()) except Exception, e: err=True syslog.syslog(syslog.LOG_ERR, \"remap register abnormal:{0}\".format(str(e))) if not err: syslog.syslog(syslog.LOG_INFO, \"remap Led registers successfully\") def _board_init(): global BOARD_TPYE global BIT_LINK global BIT_FAULT global BIT_TX global BIT_RX global BIT_SPEED0 global BIT_SPEED1 global EAGLE_CORE global TOTAL_SCAN_BITS global SYNC_S global SYNC_P cmd=\"uname -n\" platform=os.popen(cmd).read() if platform.rstrip()==INV_MAGNOLIA: BOARD_TPYE =\"inventec_d6254qs\" BIT_RX =1<<0 BIT_TX =1<<1 BIT_SPEED1 =1<<4 BIT_LINK =1<<7 fp=open('/usr/share/sonic/device/x86_64-inventec_d6254qs-r0/led_proc_init.soc', \"r\") _remap_registers(fp) elif platform.rstrip()==INV_REDWOOD: BOARD_TPYE =\"inventec_d7032q28b\" BIT_RX =1<<0 BIT_TX =1<<1 BIT_SPEED0 =1<<3 BIT_SPEED1 =1<<4 BIT_FAULT =1<<6 BIT_LINK =1<<7 EAGLE_CORE =[66, 100] fp=open('/usr/share/sonic/device/x86_64-inventec_d7032q28b-r0/led_proc_init.soc', \"r\") _remap_registers(fp) elif platform.rstrip()==INV_CYPRESS: BOARD_TPYE =\"inventec_d7054q28b\" BIT_LINK =1<<0 BIT_FAULT =1<<1 BIT_SPEED0 =1<<2 EAGLE_CORE =[66, 100] elif platform.rstrip()==INV_SEQUOIA: BOARD_TPYE=\"inventec_d7264q28b\" elif platform.rstrip()==INV_MAPLE: BOARD_TPYE=\"inventec_d6556\" fp=open('/usr/share/sonic/device/x86_64-inventec_d6556-r0/led_proc_init.soc', \"r\") _remap_registers(fp) syslog.syslog(syslog.LOG_INFO, \"Found device:{0}\".format(BOARD_TPYE)) exit(0) else: BOARD_TPYE=\"not found\" syslog.syslog(syslog.LOG_ERR, \"Found device:{0}\".format(BOARD_TPYE)) exit(0) syslog.syslog(syslog.LOG_INFO, \"Found device:{0}\".format(BOARD_TPYE)) def _lookup_led_index(p): index=0 if BOARD_TPYE==\"inventec_d6254qs\": if 0 <=p.port_num <=47: index=p.port_num +(p.port_num / 4) p.write2_up=0 elif 48 <=p.port_num <=71: index=p.port_num -48 p.write2_up=1 if p.led_up==0: p.s_addr=p.port_num * 2 elif p.led_up==1: p.s_addr=(p.port_num -36) * 2 elif BOARD_TPYE==\"inventec_d7032q28b\": p.write2_up=0 index=p.port_num if 0 <=p.port_num <=7: p.s_addr=p.port_num * 8 elif 8 <=p.port_num <=23: p.s_addr=(p.port_num -8) * 8 elif 24 <=p.port_num <=31: p.s_addr=(p.port_num -16) * 8 else: p.write2_up=p.led_up for port in PORT_LIST: if p.bcm_id==port.bcm_id: break if p.led_up==port.led_up: index +=1 return PORT_DATA_OFFSET_ADDR +index def _update_port_list(only_update): global PORT_LIST number =0 count =0 content=BCM_SHELL.run(\"ps\") for line in content.split(\"\\n\"): re_obj=re.search(r\"(?P<port_name>(xe|ce)\\d+)\\(\\s*(?P<bcm_id>\\d+)\\)\\s+(?P<link>(up|down|!ena)).+\\s+(?P<speed>\\d+)G\", line) if re_obj is not None: if int(re_obj.group(\"bcm_id\")) not in EAGLE_CORE: if only_update: PORT_LIST[number].link_status=re_obj.group(\"link\") else: port_obj=Port() port_obj.port_num=number port_obj.name=re_obj.group(\"port_name\") port_obj.bcm_id=int(re_obj.group(\"bcm_id\")) port_obj.link_status=re_obj.group(\"link\") port_obj.speed=int(re_obj.group(\"speed\")) PORT_LIST.append(port_obj) number +=1 if not only_update: content=BCM_SHELL.run(\"led status\") for line in content.split(\"\\n\"): re_obj=re.search(r\"(?P<bcm_id>\\d+).+(?P<led_up>\\d)\\:\", line) if re_obj is not None: if int(re_obj.group(\"bcm_id\")) not in EAGLE_CORE: PORT_LIST[count].led_up=int(re_obj.group(\"led_up\")) PORT_LIST[count].led_index=_lookup_led_index(PORT_LIST[count]) count +=1 if number is not count: PORT_LIST=[] syslog.syslog(syslog.LOG_ERR, \"The amount of port is not match\") def sync_bcmsh_socket(): global BCM_SHELL global SHELL_READY waitSyncd =True retryCount =0 while waitSyncd: time.sleep(10) try: BCM_SHELL=bcmshell() BCM_SHELL.run(\"Echo\") waitSyncd=False except Exception, e: print \"{0}, Retry times({1})\".format(str(e),retryCount) retryCount +=1 syslog.syslog(syslog.LOG_INFO, \"bcmshell socket create successfully\") if SHELL_READY is False: SHELL_READY=True return elif SHELL_READY is True: update_led_status() def update_led_status(): led_thread =True reset_sec =2 count_down =0 queue_active =[] port_data =None s_byte =None while led_thread: try: if count_down==0: queue_active=[] _update_port_list(1) for port in PORT_LIST: if port.link_status==\"up\": queue_active.append(port) else: port_data=0 port.write_data_ram(port_data) count_down=reset_sec else: for port in queue_active: port_data=0 if BOARD_TPYE==\"inventec_d6254qs\": s_byte=port.read_data_ram() if s_byte&STATUS_RX: port_data |=BIT_RX if s_byte&STATUS_TX: port_data |=BIT_TX port_data |=BIT_LINK elif BOARD_TPYE==\"inventec_d7032q28b\": s_byte=port.read_data_ram() if s_byte&STATUS_RX: port_data |=BIT_RX if s_byte&STATUS_TX: port_data |=BIT_TX if port.speed==SPEED_100G: port_data |=BIT_SPEED0 port_data |=BIT_SPEED1 elif port.speed==SPEED_40G: port_data |=BIT_SPEED1 elif port.speed==SPEED_25G: port_data |=BIT_SPEED0 else: pass port_data |=BIT_LINK elif BOARD_TPYE==\"inventec_d7054q28b\": if port.speed !=SPEED_100G and port.speed !=SPEED_25G: port_data |=BIT_SPEED0 port.write_data_ram(port_data) time.sleep(0.5) count_down -=1 except Exception, e: syslog.syslog(syslog.LOG_WARNING, \"{0}\".format(str(e))) sync_bcmsh_socket() def debug_print(): for port in PORT_LIST: output=\"\" output +=\"name:{0} | \".format(port.name) output +=\"port_num:{0} | \".format(port.port_num) output +=\"bcm_id:{0} | \".format(port.bcm_id) output +=\"link_status:{0} | \".format(port.link_status) output +=\"speed:{0} | \".format(port.speed) output +=\"led_up:{0} | \".format(port.led_up) output +=\"s_addr:{0} | \".format(port.s_addr) output +=\"write2_up:{0} | \".format(port.write2_up) output +=\"led_index:{0} | \".format(port.led_index) print output if __name__==\"__main__\": syslog.openlog(\"led_proc\", syslog.LOG_PID, facility=syslog.LOG_DAEMON) sync_bcmsh_socket() _board_init() _update_port_list(0) update_led_status() syslog.closelog() ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2018 Inventec, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport time\nimport syslog\nimport re\nfrom sonic_sfp.bcmshell import bcmshell\n\n\n# =====================================================================\n#  global variable init\n# =====================================================================\n# port object\nPORT_LIST               = []\n# object is to execute bcm shell command\nBCM_SHELL   = None\nSHELL_READY = False\n# port status that is auto update by chip in data ram\nSTATUS_RX               = 1<<0\nSTATUS_TX               = 1<<1\n# define data ram address\nPORT_DATA_OFFSET_ADDR   = 0xA0\n# define board type\nINV_MAGNOLIA            = \"SONiC-Inventec-d6254qs\"\nINV_REDWOOD             = \"SONiC-Inventec-d7032-100\"\nINV_CYPRESS             = \"SONiC-Inventec-d7054\"\nINV_MAPLE               = \"SONiC-Inventec-d6556\"\nINV_SEQUOIA             = \"\"\nBOARD_TPYE              = \"\"\nEAGLE_CORE              = []\n# define port data for bit streaming\nBIT_LINK                = None\nBIT_FAULT               = None\nBIT_TX                  = None\nBIT_RX                  = None\nBIT_SPEED0              = None\nBIT_SPEED1              = None\n# define port speed\nSPEED_100G              = 100\nSPEED_40G               = 40\nSPEED_25G               = 25\nSPEED_10G               = 10\n\n\n# =====================================================================\n#  class object\n# =====================================================================\nclass Port():\n\n    port_num        = None\n    name            = None\n    bcm_id          = None\n    led_up          = None\n    s_addr          = None\n    write2_up       = None\n    led_index       = None\n    link_status     = None\n    speed           = None\n\n    def write_data_ram(self, data):\n        BCM_SHELL.cmd(\"setreg CMIC_LEDUP{0}_DATA_RAM({1}) {2}\".format(self.write2_up, self.led_index, data))\n\n    def read_data_ram(self):\n        r_string = BCM_SHELL.run(\"getreg CMIC_LEDUP{0}_DATA_RAM({1})\".format(self.led_up, self.s_addr))\n        for line in r_string.split(\"\\n\"):\n            re_obj = re.search(r\"\\<DATA\\=(?P<data>.+)\\>\", line)\n            if re_obj is not None:\n                #syslog.syslog(syslog.LOG_DEBUG, \"Read Led({0}) data_ram({1}): {2}\".format(self.up, addr, re_obj.group(\"data\")))\n                return int(re_obj.group(\"data\"), 16)\n\n\n\n# =====================================================================\n#  Function\n# =====================================================================\ndef _remap_registers(fp):\n\n    content = fp.readlines()\n    fp.close()\n    err = False\n\n    for line in content:\n        try:\n            BCM_SHELL.cmd(line.rstrip())\n        except Exception, e:\n            err = True\n            syslog.syslog(syslog.LOG_ERR, \"remap register abnormal: {0}\".format(str(e)))\n\n    if not err:\n        syslog.syslog(syslog.LOG_INFO, \"remap Led registers successfully\")\n\n\n\ndef _board_init():\n\n    global BOARD_TPYE\n    global BIT_LINK\n    global BIT_FAULT\n    global BIT_TX\n    global BIT_RX\n    global BIT_SPEED0\n    global BIT_SPEED1\n    global EAGLE_CORE\n    global TOTAL_SCAN_BITS\n    global SYNC_S\n    global SYNC_P\n\n    cmd = \"uname -n\"\n    platform = os.popen(cmd).read()\n\n    if platform.rstrip() == INV_MAGNOLIA:\n        BOARD_TPYE      = \"inventec_d6254qs\"\n        BIT_RX          = 1<<0  #0x01\n        BIT_TX          = 1<<1  #0x02\n        BIT_SPEED1      = 1<<4  #0x10\n        BIT_LINK        = 1<<7  #0x80\n        fp = open('/usr/share/sonic/device/x86_64-inventec_d6254qs-r0/led_proc_init.soc', \"r\")\n        _remap_registers(fp)\n\n    elif platform.rstrip() == INV_REDWOOD:\n        BOARD_TPYE      = \"inventec_d7032q28b\"\n        BIT_RX          = 1<<0  #0x01\n        BIT_TX          = 1<<1  #0x02\n        BIT_SPEED0      = 1<<3  #0x08\n        BIT_SPEED1      = 1<<4  #0x10\n        BIT_FAULT       = 1<<6  #0x40\n        BIT_LINK        = 1<<7  #0x80\n        EAGLE_CORE      = [66, 100]\n        fp = open('/usr/share/sonic/device/x86_64-inventec_d7032q28b-r0/led_proc_init.soc', \"r\")\n        _remap_registers(fp)\n\n    elif platform.rstrip() == INV_CYPRESS:\n        BOARD_TPYE      = \"inventec_d7054q28b\"\n        BIT_LINK        = 1<<0  #0x01\n        BIT_FAULT       = 1<<1  #0x02\n        BIT_SPEED0      = 1<<2  #0x04\n        EAGLE_CORE      = [66, 100]\n\n    elif platform.rstrip() == INV_SEQUOIA:\n        BOARD_TPYE = \"inventec_d7264q28b\"\n\n    elif platform.rstrip() == INV_MAPLE:\n        BOARD_TPYE = \"inventec_d6556\"\n        fp = open('/usr/share/sonic/device/x86_64-inventec_d6556-r0/led_proc_init.soc', \"r\")\n        _remap_registers(fp)\n        #led process: m0 led process that is controlled by linkscan_led_fw.bin and custom_led.bin\n        syslog.syslog(syslog.LOG_INFO, \"Found device: {0}\".format(BOARD_TPYE))\n        exit(0)\n\n    else:\n        BOARD_TPYE = \"not found\"\n        syslog.syslog(syslog.LOG_ERR, \"Found device: {0}\".format(BOARD_TPYE))\n        exit(0)\n\n    syslog.syslog(syslog.LOG_INFO, \"Found device: {0}\".format(BOARD_TPYE))\n\n\n\ndef _lookup_led_index(p):\n\n    index = 0\n    if BOARD_TPYE == \"inventec_d6254qs\":\n        if 0 <= p.port_num <= 47:\n            index = p.port_num + (p.port_num / 4)\n            p.write2_up = 0\n        elif 48 <= p.port_num <= 71:\n            index = p.port_num - 48\n            p.write2_up = 1\n        if p.led_up == 0:\n            p.s_addr = p.port_num * 2\n        elif p.led_up == 1:\n            p.s_addr = (p.port_num - 36) * 2\n\n    elif BOARD_TPYE == \"inventec_d7032q28b\":\n        p.write2_up = 0\n        index = p.port_num\n        if 0 <= p.port_num <= 7:\n            p.s_addr = p.port_num * 8\n        elif 8 <= p.port_num <= 23:\n            p.s_addr = (p.port_num - 8) * 8\n        elif 24 <= p.port_num <= 31:\n            p.s_addr = (p.port_num - 16) * 8\n\n    else:\n        p.write2_up = p.led_up\n        for port in PORT_LIST:\n            if p.bcm_id == port.bcm_id:\n                break\n            if p.led_up == port.led_up:\n                index += 1\n\n    return PORT_DATA_OFFSET_ADDR + index\n\n\ndef _update_port_list(only_update):\n\n    global PORT_LIST\n    number      = 0\n    count       = 0\n\n    content = BCM_SHELL.run(\"ps\")\n    for line in content.split(\"\\n\"):\n        re_obj = re.search(r\"(?P<port_name>(xe|ce)\\d+)\\(\\s*(?P<bcm_id>\\d+)\\)\\s+(?P<link>(up|down|!ena)).+\\s+(?P<speed>\\d+)G\", line)\n        if re_obj is not None:\n            if int(re_obj.group(\"bcm_id\")) not in EAGLE_CORE:\n                if only_update:\n                    PORT_LIST[number].link_status = re_obj.group(\"link\")\n                else:\n                    # create port object while first time\n                    port_obj = Port()\n                    port_obj.port_num = number\n                    port_obj.name = re_obj.group(\"port_name\")\n                    port_obj.bcm_id = int(re_obj.group(\"bcm_id\"))\n                    port_obj.link_status = re_obj.group(\"link\")\n                    port_obj.speed = int(re_obj.group(\"speed\"))\n                    PORT_LIST.append(port_obj)\n                number += 1\n\n    if not only_update:\n        content = BCM_SHELL.run(\"led status\")\n        for line in content.split(\"\\n\"):\n            re_obj = re.search(r\"(?P<bcm_id>\\d+).+(?P<led_up>\\d)\\:\", line)\n            if re_obj is not None:\n                if int(re_obj.group(\"bcm_id\")) not in EAGLE_CORE:\n                    PORT_LIST[count].led_up = int(re_obj.group(\"led_up\"))\n                    PORT_LIST[count].led_index = _lookup_led_index(PORT_LIST[count])\n                    count += 1\n\n        if number is not count:\n            PORT_LIST = []\n            syslog.syslog(syslog.LOG_ERR, \"The amount of port is not match\")\n\n\n\ndef sync_bcmsh_socket():\n\n    global BCM_SHELL\n    global SHELL_READY\n    waitSyncd   = True\n    retryCount  = 0\n\n    while waitSyncd:\n        time.sleep(10)\n        try:\n            BCM_SHELL = bcmshell()\n            BCM_SHELL.run(\"Echo\")\n            waitSyncd = False\n        except Exception, e:\n            print \"{0}, Retry times({1})\".format(str(e),retryCount)\n            #syslog.syslog(syslog.LOG_DEBUG, \"{0}, Retry times({1})\".format(str(e),retryCount))\n            retryCount += 1\n\n    syslog.syslog(syslog.LOG_INFO, \"bcmshell socket create successfully\")\n\n    if SHELL_READY is False:\n        SHELL_READY = True\n        return\n    elif SHELL_READY is True:\n        update_led_status()\n\n\n\ndef update_led_status():\n\n    led_thread      = True  # True/False (gate to turn on/off)\n    reset_sec       = 2\n    count_down      = 0\n    queue_active    = []\n    port_data       = None\n    s_byte          = None\n\n\n    # thread for keeping update port status in data ram\n    while led_thread:\n        try:\n            if count_down == 0:\n                queue_active = []\n                _update_port_list(1)\n                for port in PORT_LIST:\n                    if port.link_status == \"up\":\n                        queue_active.append(port)\n                    else:\n                        port_data = 0\n                        port.write_data_ram(port_data)\n                count_down = reset_sec\n            else:\n                for port in queue_active:\n                    port_data = 0\n\n                    if BOARD_TPYE == \"inventec_d6254qs\":\n                        s_byte = port.read_data_ram()\n                        if s_byte&STATUS_RX:\n                            port_data |= BIT_RX\n                        if s_byte&STATUS_TX:\n                            port_data |= BIT_TX\n                        port_data |= BIT_LINK\n\n                    elif BOARD_TPYE == \"inventec_d7032q28b\":\n                        s_byte = port.read_data_ram()\n                        if s_byte&STATUS_RX:\n                            port_data |= BIT_RX\n                        if s_byte&STATUS_TX:\n                            port_data |= BIT_TX\n                        if port.speed == SPEED_100G:\n                            port_data |= BIT_SPEED0\n                            port_data |= BIT_SPEED1\n                        elif port.speed == SPEED_40G:\n                            port_data |= BIT_SPEED1\n                        elif port.speed == SPEED_25G:\n                            port_data |= BIT_SPEED0\n                        else:\n                            pass\n                        port_data |= BIT_LINK\n\n                    elif BOARD_TPYE == \"inventec_d7054q28b\":\n                        if port.speed != SPEED_100G and port.speed != SPEED_25G:\n                            port_data |= BIT_SPEED0\n\n                    # write data to update data ram for specific port\n                    port.write_data_ram(port_data)\n\n                time.sleep(0.5)\n                count_down -= 1\n\n        except Exception, e:\n            syslog.syslog(syslog.LOG_WARNING, \"{0}\".format(str(e)))\n            sync_bcmsh_socket()\n\n\n\ndef debug_print():\n\n    for port in PORT_LIST:\n        output = \"\"\n        output += \"name:{0} | \".format(port.name)\n        output += \"port_num:{0} | \".format(port.port_num)\n        output += \"bcm_id:{0} | \".format(port.bcm_id)\n        output += \"link_status:{0} | \".format(port.link_status)\n        output += \"speed:{0} | \".format(port.speed)\n        output += \"led_up:{0} | \".format(port.led_up)\n        output += \"s_addr:{0} | \".format(port.s_addr)\n        output += \"write2_up:{0} | \".format(port.write2_up)\n        output += \"led_index:{0} | \".format(port.led_index)\n        print output\n\n\nif __name__ == \"__main__\":\n\n    syslog.openlog(\"led_proc\", syslog.LOG_PID, facility=syslog.LOG_DAEMON)\n\n    sync_bcmsh_socket()\n    _board_init()\n    _update_port_list(0)\n    #debug_print()\n    update_led_status()\n\n    syslog.closelog()\n"}, "/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py": {"changes": [{"diff": "\n \n             # Receive thermaltrip event\n             if event['ACTION'] == 'remove' and event['DEVPATH'] == '/kernel/platform_status/fan':\n-                os.system(\"shutdown -h now\")\n+                subprocess.call([\"shutdown\", \"-h\", \"now\"])\n                 ", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py", "badparts": ["                os.system(\"shutdown -h now\")"], "goodparts": ["                subprocess.call([\"shutdown\", \"-h\", \"now\"])"]}], "source": "\n import os import socket from collections import OrderedDict NETLINK_KOBJECT_UEVENT=15 class KernelEventMonitor(object): def __init__(self): self.received_events=OrderedDict() self.socket=socket.socket(socket.AF_NETLINK, socket.SOCK_DGRAM, NETLINK_KOBJECT_UEVENT) def start(self): self.socket.bind((os.getpid(), -1)) def stop(self): self.socket.close() def __enter__(self): self.start() return self def __exit__(self, exc_type, exc_value, traceback): self.stop() def __iter__(self): while True: for item in monitor.next_events(): yield item def next_events(self): data=self.socket.recv(16384) event={} for item in data.split(b'\\x00'): if not item: if event and event['SEQNUM'] not in self.received_events: self.received_events[event['SEQNUM']]=None if(len(self.received_events) > 100): self.received_events.popitem(last=False) yield event event={} else: try: k, v=item.split(b'=', 1) event[k.decode('ascii')]=v.decode('ascii') except ValueError: pass if __name__=='__main__': with KernelEventMonitor() as monitor: for event in monitor: if event['SUBSYSTEM']=='platform_status': print('subsystem is platform_status') if event['ACTION']=='remove' and event['DEVPATH']=='/kernel/platform_status/fan': os.system(\"shutdown -h now\") ", "sourceWithComments": "#!/usr/bin/env python\n\nimport os\nimport socket\nfrom collections import OrderedDict\n\n# Purpose:  Shutdown DUT upon receiving thermaltrip event from kernel (inv_pthread)\n\nNETLINK_KOBJECT_UEVENT = 15\n\nclass KernelEventMonitor(object):\n\n    def __init__(self):\n        self.received_events = OrderedDict()\n        self.socket = socket.socket(socket.AF_NETLINK, socket.SOCK_DGRAM, NETLINK_KOBJECT_UEVENT)\n\n    def start(self):\n        self.socket.bind((os.getpid(), -1))\n\n    def stop(self):\n        self.socket.close()\n\n    def __enter__(self):\n        self.start()\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.stop()\n\n    def __iter__(self):\n        while True:\n          for item in monitor.next_events():\n              yield item\n\n    def next_events(self):\n        data = self.socket.recv(16384)\n        event = {}\n        for item in data.split(b'\\x00'):\n            if not item:        \n                #check if we have an event and if we already received it\n                if event and event['SEQNUM'] not in self.received_events:\n                    self.received_events[event['SEQNUM']] = None\n                    if (len(self.received_events) > 100):\n                        self.received_events.popitem(last=False)\n                    yield event\n                event = {}\n            else:\n                try:\n                    k, v = item.split(b'=', 1)\n                    event[k.decode('ascii')] = v.decode('ascii')\n                except ValueError:\n                    pass\n\nif __name__ == '__main__':\n    with KernelEventMonitor() as monitor:\n        for event in monitor:\n            if event['SUBSYSTEM'] == 'platform_status':\n                print('subsystem is platform_status')\n\n            # Receive thermaltrip event\n            if event['ACTION'] == 'remove' and event['DEVPATH'] == '/kernel/platform_status/fan':\n                os.system(\"shutdown -h now\")\n                \n\n"}, "/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py": {"changes": [{"diff": "\n     \n     def get_platform(self):\n         if self.platform is None:\n-            self.platform = os.popen(\"uname -n\").read().strip()\n+            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"])\n         return self.platform\n     \n     def get_port_to_bcm_mapping(self)", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py", "badparts": ["            self.platform = os.popen(\"uname -n\").read().strip()"], "goodparts": ["            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"])"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object Auto detecting the transceiver and set the correct if_type value options: -h | --help : this help message -d | --debug : run with debug mode \"\"\" try: import os import commands import sys, getopt import logging import re import time import datetime import syslog from sfputil import SfpUtil from sonic_sfp.bcmshell import bcmshell except ImportError as e: raise ImportError(\"%s -required module not found\" % str(e)) DEBUG=False args=[] INV_REDWOOD_PLATFORM=\"SONiC-Inventec-d7032-100\" INV_CYPRESS_PLATFORM=\"SONiC-Inventec-d7054\" INV_SEQUOIA_PLATFORM=\"SONiC-Inventec-d7264\" INV_MAPLE_PLATFORM=\"SONiC-Inventec-d6556\" INV_MAGNOLIA_PLATFORM=\"SONiC-Inventec-d6254qs\" transceiver_type_dict={ \"FCBG110SD1C03\": \"SR\", \"FCBG110SD1C05\": \"SR\", \"FTLX8571D3BCL\": \"SR\", \"FTLX8574D3BCL\": \"SR\", \"AFBR-709DMZ\": \"SR\", \"AFBR-709SMZ\": \"SR\", \"FTLX8571D3BCV\": \"SR\", \"FTLX1471D3BCL\": \"SR\", \"FTLX1871M3BCL\": \"SR\", \"FTLF8536P4BCL\": \"SR\", \"FCBG125SD1C05\": \"SR\", \"FCBG125SD1C30\": \"SR\", \"FCBG125SD1C03\": \"SR\", \"FCBG410QB1C03-1E\": \"SR4\", \"FCBG4100QB1C030-1E\": \"SR4\", \"885350163\": \"SR4\", \"88535017\": \"SR4\", \"FTL410QE2C\": \"SR4\", \"FTL410QD3C\": \"SR4\", \"FTL410QD2C\": \"SR4\", \"AFBR-79E3PZ\": \"SR4\", \"AFBR-79Q4Z\": \"SR4\", \"FTL4C1QE1C\": \"SR4\", \"FTLC9551REPM\": \"SR4\", \"FTLC1151RDPL\": \"SR4\", \"DAC-010SS-X50\": \"KR\", \"DAC-010QQ-X50\": \"KR4\", \"DAC-040QS-007\": \"KR4\", \"DAC-040QQ-007\": \"KR4\", \"DAC-040QQ-005\": \"KR4\", \"DAC-040QS-005\": \"KR4\", \"NDAAFF-0001\": \"KR4\", \"L0HQF001-SD-R\": \"KR4\", \"DAC-Q28/Q28-28-01\": \"KR4\", \"NDAAFF-0003\": \"KR4\", \"NDAQGF0001\": \"KR4\", \"L0HQF003-SD-R\": \"KR4\", \"NDAQGJ-0003\": \"KR4\", \"L0HQF004-SD-R\": \"KR4\", \"L0HSF006-SD-R\": \"KR\", \"L0HSF007-SD-R\": \"KR\", \"L0HSF008-SD-R\": \"KR\", \"L0HQF009-SD-R\": \"KR4\", \"FSPP-H7-M85-X3D\": \"SR\", \"PT0-M3-4D33K-C2\": \"SR\", \"RTXM228-551\": \"SR\", \"RTXM330-003\": \"SR\", \"RTXM330-030\": \"SR\", \"MFA2P10-A005\": \"SR\", \"QAB-OA03MC\": \"SR4\", \"QAB-OA05MC\": \"SR4\", \"RTXM320-571\": \"SR4\", \"AFBR-89CDDZ\": \"SR4\", \"RTXM420-550\": \"SR4\", \"MMA1B00-C100D\": \"SR4\", \"RTXM420-551\": \"SR4\", \"E04025QTXA000\": \"SR4\", \"LQ210PR-Oxxx\": \"SR4\", \"TR-FC13L-N00\": \"SR4\", \"SPQ-CE-LR-CDFL\": \"SR4\", \"FIM37700/170\": \"SR4\", \"FCBN425QE1C03\": \"SR4\", \"TQS-Q14H8-XCAXX\": \"SR4\", \"FPD-203R008-10/3\": \"SR4\", \"LTA8531-PC+\": \"SR4\" } initial_command=[] def show_help(): print __doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]} sys.exit(0) def log_message( string): syslog.openlog(\"transceiver_monitor\", syslog.LOG_PID, facility=syslog.LOG_DAEMON) syslog.syslog(syslog.LOG_NOTICE, string) class BCMUtil(bcmshell): port_to_bcm_mapping=dict() sal_config_list=dict() eagle_list=[] platform=None def get_platform(self): if self.platform is None: self.platform=os.popen(\"uname -n\").read().strip() return self.platform def get_port_to_bcm_mapping(self): if self.port_to_bcm_mapping is None: return dict() else: return self.port_to_bcm_mapping def show_port_to_bcm_mapping(self): for key,value in self.port_to_bcm_mapping.iteritems(): print \"{0}---{1}\".format(key, value) def get_eagle_port(self): return self.eagle_list def parsing_eagle_port(self): name=self.get_platform() if name is not None: if name==INV_REDWOOD_PLATFORM: self.eagle_list=[66,100] elif name==INV_CYPRESS_PLATFORM: self.eagle_list=[66,100] elif name==INV_SEQUOIA_PLATFORM: self.eagle_list=[66,100] elif name==INV_MAPLE_PLATFORM: self.eagle_list=[66,130] else: self.eagle_list=[] def get_sal_config_list(self): return self.sal_config_list def show_sal_config_list(self): for key,value in self.sal_config_list.iteritems(): print \"{0}---{1}\".format(key, value) def initial_sal_config_list( self): content=self.run(\"config\") for line in content.split(\"\\n\"): ConfigObject=re.search(r\"portmap\\_(?P<bcm_id>\\d+)\\=(?P<lane_id>\\d+)\\:\\d+\",line) if ConfigObject is not None: if int(ConfigObject.group(\"bcm_id\")) not in self.get_eagle_port(): self.get_sal_config_list()[int(ConfigObject.group(\"bcm_id\"))]={\"lane\": int(ConfigObject.group(\"lane_id\")), \"speed\": None, \"portname\": None} def parsing_port_list(self): content=self.run(\"ps\") count=0 for line in content.split(\"\\n\"): PSObject=re.search(r\"(?P<port_name>(xe|ce)\\d+)\\(\\s*(?P<bcm_id>\\d+)\\).+\\s+(?P<speed>\\d+)G\",line) if PSObject is not None: if int(PSObject.group(\"bcm_id\")) not in self.get_eagle_port(): if self.get_sal_config_list().has_key(int(PSObject.group(\"bcm_id\"))): self.get_sal_config_list()[int(PSObject.group(\"bcm_id\"))][\"portname\"]=PSObject.group(\"port_name\") self.get_sal_config_list()[int(PSObject.group(\"bcm_id\"))][\"speed\"]=int(PSObject.group(\"speed\"))*1000 self.port_to_bcm_mapping[count]=int(PSObject.group(\"bcm_id\")) count=count +1 def execute_command(self, cmd): self.cmd(cmd) class TransceiverUtil(SfpUtil): transceiver_port_mapping=dict() def get_transceiver_port_mapping(self): return self.transceiver_port_mapping def show_transceiver_port_mapping(self): for key,value in self.transceiver_port_mapping.iteritems(): print \"{0}---{1}\".format(key, value) def get_bcm_port_name(self, index): if self.transceiver_port_mapping.has_key(index) and bcm_obj.get_sal_config_list().has_key(self.transceiver_port_mapping[index][\"bcm\"]): return bcm_obj.get_sal_config_list()[self.transceiver_port_mapping[index][\"bcm\"]][\"portname\"] else: return \"\" def get_port_to_i2c_mapping(self): if self.port_to_i2c_mapping is None: return dict() else: return self.port_to_i2c_mapping def show_port_to_i2c_mapping(self): for key,value in self.port_to_i2c_mapping.iteritems(): print \"{0}---{1}\".format(key, value) def get_eeprom_partNum(self, portNum): tempdict=dict() tempdict=self.get_eeprom_dict(portNum) self.get_eeprom_partNum_from_parser_eeprom_dict(tempdict) def get_eeprom_dict_info(self, portNum): return self.get_eeprom_dict(portNum) def get_eeprom_partNum_from_parser_eeprom_dict(self, tempdict): if tempdict is not None: if tempdict[\"interface\"][\"data\"].has_key(\"VendorPN\"): return tempdict[\"interface\"][\"data\"][\"VendorPN\"] elif tempdict[\"interface\"][\"data\"].has_key(\"Vendor PN\"): return tempdict[\"interface\"][\"data\"][\"Vendor PN\"] else: return None else: return None def get_transceiver_type(self, pn): if pn is not None: if transceiver_type_dict.has_key(pn.upper()): return transceiver_type_dict[pn.upper()] else: return None def set_transceiver_type( self, portNum, pn): type=self.get_transceiver_type( pn) if type is not None: if bcm_obj.get_platform()==INV_SEQUOIA_PLATFORM or bcm_obj.get_platform()==INV_MAPLE_PLATFORM: speed=bcm_obj.get_sal_config_list()[self.transceiver_port_mapping[portNum][\"bcm\"]][\"speed\"] bcm_obj.execute_command( \"port %s if=%s speed=%d\" %( self.get_bcm_port_name(portNum), type, speed)) else: bcm_obj.execute_command( \"port %s if=%s\" %( self.get_bcm_port_name(portNum), type)) print \"Detecting port{0}({1}) need to change interface type{2}({3})\".format( self.get_bcm_port_name(portNum), portNum, type, self.get_transceiver_port_mapping()[portNum][\"pn\"]) log_message(\"Detecting port{0} need to change interface type{1}({2})\".format(self.get_bcm_port_name(portNum), type, self.get_transceiver_port_mapping()[portNum][\"pn\"])) def initial_transceiver_port_mapping(self): for index in self.get_port_to_i2c_mapping().keys(): if self.transceiver_port_mapping.has_key(index) is False: i2cValue=self.get_port_to_i2c_mapping()[index] bcmValue=bcm_obj.get_port_to_bcm_mapping()[index] self.transceiver_port_mapping[index]={\"i2c\": i2cValue, \"bcm\": bcmValue, \"pn\": None} def set_power_mode_for_QSFP(self): for index in self.get_port_to_i2c_mapping().keys(): if index >=self.qsfp_port_start and index <=self.qsfp_port_end: self.set_low_power_mode(index, False) else: self.set_tx_disable(index) def set_tx_disable(self, port_num): if port_num >=self.qsfp_port_start and port_num <=self.qsfp_port_end: pass else: try: tx_file=open(\"/sys/class/swps/port\"+str(port_num)+\"/tx_disable\", \"r+\") except IOError as e: print \"Error: unable to open file: %s\" % str(e) return False reg_value=int(tx_file.readline().rstrip()) if reg_value==1: reg_value=0 tx_file.write(hex(reg_value)) tx_file.close() def main(): global DEBUG global transceiver_obj global bcm_obj initalNotOK=True retestCount=0 while initalNotOK: try: transceiver_obj=TransceiverUtil() bcm_obj=BCMUtil() initalNotOK=False except Exception, e: log_message(\"Exception. The warning is{0}, Retry again({1})\".format(str(e),retestCount)) retestCount=retestCount +1 time.sleep(5) log_message( \"Object initialed successfully\") options, args=getopt.getopt(sys.argv[1:], 'hd',['help', 'debug' ]) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) else: logging.info(\"no option\") initalNotOK=True while initalNotOK: try: for cmd_index in initial_command: bcm_obj.execute_command(cmd_index) bcm_obj.parsing_eagle_port() bcm_obj.initial_sal_config_list() bcm_obj.parsing_port_list() transceiver_obj.initial_transceiver_port_mapping() initalNotOK=False except Exception, e: log_message(\"Exception. The warning is{0}\".format(str(e))) time.sleep(5) transceiver_obj.set_power_mode_for_QSFP() while 1: try: if bcm_obj.get_platform()==INV_SEQUOIA_PLATFORM: bcm_obj.parsing_port_list() for index in transceiver_obj.get_port_to_i2c_mapping().keys(): info=transceiver_obj.get_eeprom_dict_info(index) value=transceiver_obj.get_eeprom_partNum_from_parser_eeprom_dict(info) if transceiver_obj.get_transceiver_port_mapping().has_key(index) is not False and transceiver_obj.get_transceiver_port_mapping()[index][\"pn\"] <> value: transceiver_obj.get_transceiver_port_mapping()[index][\"pn\"]=value transceiver_obj.set_transceiver_type(index,value) transceiver_obj.set_tx_disable(index) except Exception, e: log_message(\"Exception. The warning is{0}\".format(str(e))) time.sleep(1) syslog.closelog() del transceiver_obj del bcm_obj if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2018 Inventec, Inc.\n# \n# Editor: James Huang ( Huang.James@inventec.com )\n#  \n# \n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\nAuto detecting the transceiver and set the correct if_type value\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n   \n\"\"\"\n\ntry:\n    import os\n    import commands\n    import sys, getopt\n    import logging\n    import re\n    import time\n    import datetime\n    import syslog\n    from sfputil import SfpUtil\n    from sonic_sfp.bcmshell import bcmshell\n    \nexcept ImportError as e:\n    raise ImportError(\"%s - required module not found\" % str(e))\n\nDEBUG = False\nargs = []\nINV_REDWOOD_PLATFORM = \"SONiC-Inventec-d7032-100\"\nINV_CYPRESS_PLATFORM = \"SONiC-Inventec-d7054\"\nINV_SEQUOIA_PLATFORM = \"SONiC-Inventec-d7264\"\nINV_MAPLE_PLATFORM = \"SONiC-Inventec-d6556\"\nINV_MAGNOLIA_PLATFORM = \"SONiC-Inventec-d6254qs\"\n\ntransceiver_type_dict = { \n                          \"FCBG110SD1C03\": \"SR\",\n                          \"FCBG110SD1C05\": \"SR\",\n                          \"FTLX8571D3BCL\": \"SR\",\n                          \"FTLX8574D3BCL\": \"SR\",\n                          \"AFBR-709DMZ\": \"SR\",\n                          \"AFBR-709SMZ\": \"SR\",\n                          \"FTLX8571D3BCV\": \"SR\",\n                          \"FTLX1471D3BCL\": \"SR\",\n                          \"FTLX1871M3BCL\": \"SR\",\n                          \"FTLF8536P4BCL\": \"SR\",\n                          \"FCBG125SD1C05\": \"SR\",\n                          \"FCBG125SD1C30\": \"SR\",\n                          \"FCBG125SD1C03\": \"SR\",\n                          \"FCBG410QB1C03-1E\": \"SR4\",\n                          \"FCBG4100QB1C030-1E\": \"SR4\",\n                          \"885350163\": \"SR4\",\n                          \"88535017\": \"SR4\",\n                          \"FTL410QE2C\": \"SR4\",\n                          \"FTL410QD3C\": \"SR4\",\n                          \"FTL410QD2C\": \"SR4\",\n                          \"AFBR-79E3PZ\": \"SR4\",\n                          \"AFBR-79Q4Z\": \"SR4\",\n                          \"FTL4C1QE1C\": \"SR4\",\n                          \"FTLC9551REPM\": \"SR4\",\n                          \"FTLC1151RDPL\": \"SR4\",\n                          \"DAC-010SS-X50\" : \"KR\",\n                          \"DAC-010QQ-X50\": \"KR4\",\n                          \"DAC-040QS-007\": \"KR4\",\n                          \"DAC-040QQ-007\": \"KR4\",\n                          \"DAC-040QQ-005\": \"KR4\",\n                          \"DAC-040QS-005\": \"KR4\",\n                          \"NDAAFF-0001\": \"KR4\",\n                          \"L0HQF001-SD-R\": \"KR4\",\n                          \"DAC-Q28/Q28-28-01\": \"KR4\",\n                          \"NDAAFF-0003\": \"KR4\",\n                          \"NDAQGF0001\": \"KR4\",\n                          \"L0HQF003-SD-R\": \"KR4\",\n                          \"NDAQGJ-0003\": \"KR4\",\n                          \"L0HQF004-SD-R\": \"KR4\",\n                          \"L0HSF006-SD-R\": \"KR\",\n                          \"L0HSF007-SD-R\": \"KR\",\n                          \"L0HSF008-SD-R\": \"KR\",\n                          \"L0HQF009-SD-R\": \"KR4\",\n                          \"FSPP-H7-M85-X3D\": \"SR\",   \n                          \"PT0-M3-4D33K-C2\": \"SR\",\n                          \"RTXM228-551\": \"SR\",\n                          \"RTXM330-003\": \"SR\",\n                          \"RTXM330-030\": \"SR\",   \n                          \"MFA2P10-A005\": \"SR\",\n                          \"QAB-OA03MC\": \"SR4\",\n                          \"QAB-OA05MC\": \"SR4\",\n                          \"RTXM320-571\": \"SR4\",\n                          \"AFBR-89CDDZ\": \"SR4\",\n                          \"RTXM420-550\": \"SR4\",\n                          \"MMA1B00-C100D\": \"SR4\",\n                          \"RTXM420-551\": \"SR4\",\n                          \"E04025QTXA000\": \"SR4\",\n                          \"LQ210PR-Oxxx\": \"SR4\",\n                          \"TR-FC13L-N00\": \"SR4\",  \n                          \"SPQ-CE-LR-CDFL\": \"SR4\",\n                          \"FIM37700/170\": \"SR4\",\n                          \"FCBN425QE1C03\": \"SR4\",\n                          \"TQS-Q14H8-XCAXX\": \"SR4\",\n                          \"FPD-203R008-10/3\": \"SR4\",\n                          \"LTA8531-PC+\": \"SR4\"                       \n                        }\n \ninitial_command = []\n\ndef show_help():\n    print __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]}\n    sys.exit(0)\n\ndef log_message( string ):\n    syslog.openlog(\"transceiver_monitor\", syslog.LOG_PID, facility=syslog.LOG_DAEMON)\n    syslog.syslog(syslog.LOG_NOTICE, string)\n\nclass BCMUtil(bcmshell):\n\n    port_to_bcm_mapping = dict()         \n    sal_config_list = dict()\n    eagle_list = []\n    platform = None\n    \n    def get_platform(self):\n        if self.platform is None:\n            self.platform = os.popen(\"uname -n\").read().strip()\n        return self.platform\n    \n    def get_port_to_bcm_mapping(self):  \n        if self.port_to_bcm_mapping is None:\n            return dict()\n        else:\n            return self.port_to_bcm_mapping     \n    \n    def show_port_to_bcm_mapping(self): \n        for key,value in self.port_to_bcm_mapping.iteritems():\n            print \"{0}---{1}\".format(key, value)    \n    \n    def get_eagle_port(self):\n        return self.eagle_list\n        \n    def parsing_eagle_port(self):\n        name = self.get_platform()\n        if name is not None:\n            if name == INV_REDWOOD_PLATFORM:\n                self.eagle_list = [66,100]\n            elif name == INV_CYPRESS_PLATFORM:\n                self.eagle_list = [66,100]\n            elif name == INV_SEQUOIA_PLATFORM:\n                self.eagle_list = [66,100]\n            elif name == INV_MAPLE_PLATFORM:\n                self.eagle_list = [66,130]\n            else:\n                self.eagle_list = []\n                \n    def get_sal_config_list(self):\n        return self.sal_config_list\n\n    def show_sal_config_list(self):\n        for key,value in self.sal_config_list.iteritems():\n            print \"{0}---{1}\".format(key, value)\n        \n    def initial_sal_config_list( self ):\n        content = self.run(\"config\")  \n        for line in content.split(\"\\n\"):\n            ConfigObject = re.search(r\"portmap\\_(?P<bcm_id>\\d+)\\=(?P<lane_id>\\d+)\\:\\d+\",line)\n            if ConfigObject is not None:   \n                if int(ConfigObject.group(\"bcm_id\")) not in self.get_eagle_port():\n                    self.get_sal_config_list()[int(ConfigObject.group(\"bcm_id\"))]={\"lane\": int(ConfigObject.group(\"lane_id\")), \"speed\": None, \"portname\": None} \n                \n    def parsing_port_list(self):\n        content = self.run(\"ps\")\n        count = 0\n        for line in content.split(\"\\n\"):\n            PSObject = re.search(r\"(?P<port_name>(xe|ce)\\d+)\\(\\s*(?P<bcm_id>\\d+)\\).+\\s+(?P<speed>\\d+)G\",line)\n            if PSObject is not None:\n                if int(PSObject.group(\"bcm_id\")) not in self.get_eagle_port():                    \n                    if self.get_sal_config_list().has_key(int(PSObject.group(\"bcm_id\"))):\n                        self.get_sal_config_list()[int(PSObject.group(\"bcm_id\"))][\"portname\"] = PSObject.group(\"port_name\")\n                        self.get_sal_config_list()[int(PSObject.group(\"bcm_id\"))][\"speed\"] = int(PSObject.group(\"speed\"))*1000\n                        self.port_to_bcm_mapping[count] = int(PSObject.group(\"bcm_id\"))\n                        count = count +1\n                \n    \n    def execute_command(self, cmd):\n        self.cmd(cmd)\n\nclass TransceiverUtil(SfpUtil):     \n    \n    transceiver_port_mapping = dict()\n    \n    def get_transceiver_port_mapping(self):\n        return self.transceiver_port_mapping\n        \n    def show_transceiver_port_mapping(self):\n        for key,value in self.transceiver_port_mapping.iteritems():\n            print \"{0}---{1}\".format(key, value)     \n       \n    def get_bcm_port_name(self, index):\n        if self.transceiver_port_mapping.has_key(index) and bcm_obj.get_sal_config_list().has_key(self.transceiver_port_mapping[index][\"bcm\"]):\n            return bcm_obj.get_sal_config_list()[self.transceiver_port_mapping[index][\"bcm\"]][\"portname\"]            \n        else:\n            return \"\"\n                \n    def get_port_to_i2c_mapping(self):\n        if self.port_to_i2c_mapping is None:\n            return dict()\n        else:\n            return self.port_to_i2c_mapping\n    \n    def show_port_to_i2c_mapping(self):\n        for key,value in self.port_to_i2c_mapping.iteritems():\n            print \"{0}---{1}\".format(key, value)\n        \n    def get_eeprom_partNum(self, portNum):\n        tempdict = dict()\n        tempdict = self.get_eeprom_dict(portNum)\n        self.get_eeprom_partNum_from_parser_eeprom_dict(tempdict)\n    \n    def get_eeprom_dict_info(self, portNum): \n        return self.get_eeprom_dict(portNum) \n                \n    def get_eeprom_partNum_from_parser_eeprom_dict(self, tempdict ):\n        if tempdict is not None:\n            if tempdict[\"interface\"][\"data\"].has_key(\"VendorPN\"):\n               return tempdict[\"interface\"][\"data\"][\"VendorPN\"]\n            elif tempdict[\"interface\"][\"data\"].has_key(\"Vendor PN\"):\n                return tempdict[\"interface\"][\"data\"][\"Vendor PN\"]\n            else:\n                return None\n        else:\n            return None\n            \n    def get_transceiver_type(self, pn ):\n        if pn is not None:\n            if transceiver_type_dict.has_key(pn.upper()):\n                return transceiver_type_dict[pn.upper()]\n            else:\n                return None    \n\n    def set_transceiver_type( self, portNum, pn ):\n        type = self.get_transceiver_type( pn )\n        if type is not None:             \n            if bcm_obj.get_platform() == INV_SEQUOIA_PLATFORM or bcm_obj.get_platform() == INV_MAPLE_PLATFORM :\n                speed = bcm_obj.get_sal_config_list()[self.transceiver_port_mapping[portNum][\"bcm\"]][\"speed\"]\n                bcm_obj.execute_command( \"port %s if=%s speed=%d\" % ( self.get_bcm_port_name(portNum), type, speed ) )\n            else:\n                bcm_obj.execute_command( \"port %s if=%s\" % ( self.get_bcm_port_name(portNum), type ) )\n            print \"Detecting port {0}({1})  need to change interface type {2} ({3})\".format( self.get_bcm_port_name(portNum), portNum, type, self.get_transceiver_port_mapping()[portNum][\"pn\"])\n            log_message(\"Detecting port {0} need to change interface type {1} ({2})\".format(self.get_bcm_port_name(portNum), type, self.get_transceiver_port_mapping()[portNum][\"pn\"]) )\n    \n    def initial_transceiver_port_mapping(self):\n        for index in self.get_port_to_i2c_mapping().keys():\n            if self.transceiver_port_mapping.has_key(index) is False :\n                i2cValue = self.get_port_to_i2c_mapping()[index]\n                bcmValue = bcm_obj.get_port_to_bcm_mapping()[index]\n                self.transceiver_port_mapping[index]={\"i2c\": i2cValue, \"bcm\": bcmValue , \"pn\": None}\n            \n    def set_power_mode_for_QSFP(self):\n        for index in self.get_port_to_i2c_mapping().keys():\n            if index >= self.qsfp_port_start and index <= self.qsfp_port_end :\n                self.set_low_power_mode(index, False)\n            else:\n                # To set tx_disable\n                self.set_tx_disable(index)\n\n    def set_tx_disable(self, port_num):\n        if port_num >= self.qsfp_port_start and port_num <= self.qsfp_port_end :\n            pass\n        else:\n            try:\n                tx_file = open(\"/sys/class/swps/port\"+str(port_num)+\"/tx_disable\", \"r+\")\n            except IOError as e:\n                print \"Error: unable to open file: %s\" % str(e)\n                return False\n\n            reg_value = int(tx_file.readline().rstrip())\n\n            # always set 0 to tx_disable field\n            if reg_value == 1 :\n                reg_value = 0        \n                tx_file.write(hex(reg_value))\n                tx_file.close()\n\n        \ndef main():\n\n    global DEBUG  \n    global transceiver_obj\n    global bcm_obj\n    \n    initalNotOK = True\n    retestCount = 0 \n    while initalNotOK :\n        try:                \n            transceiver_obj = TransceiverUtil()\n            bcm_obj = BCMUtil()\n            initalNotOK = False\n        except Exception, e:               \n            log_message(\"Exception. The warning is {0}, Retry again ({1})\".format(str(e),retestCount) )                    \n            retestCount = retestCount + 1\n        time.sleep(5)\n     \n    log_message( \"Object initialed successfully\" )  \n    options, args = getopt.getopt(sys.argv[1:], 'hd', ['help',\n                                                       'debug'\n                                                          ])\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):            \n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        else:\n            logging.info(\"no option\")\n    \n    initalNotOK = True\n    while initalNotOK :\n        try :\n            # Before loop, You could execute specific command to initial chip\n            for cmd_index in initial_command :\n                bcm_obj.execute_command(cmd_index)\n            \n            # Initial the sal config list\n            bcm_obj.parsing_eagle_port()\n            bcm_obj.initial_sal_config_list()\n            # bcm_obj.show_sal_config_list()\n            bcm_obj.parsing_port_list()                 \n            #bcm_obj.show_port_to_bcm_mapping()                 \n            #bcm_obj.show_sal_config_list()\n            # transceiver_obj.show_port_to_i2c_mapping()\n            \n            # Initial the transceiver_obj \n            transceiver_obj.initial_transceiver_port_mapping()       \n            # transceiver_obj.show_transceiver_port_mapping()\n             \n            initalNotOK = False\n        except Exception, e:               \n            log_message(\"Exception. The warning is {0}\".format(str(e)) )\n        time.sleep(5)            \n    \n    # Improve the power mode for QSFP ports\n    transceiver_obj.set_power_mode_for_QSFP()\n\n    while 1 :\n        try:\n            if bcm_obj.get_platform() == INV_SEQUOIA_PLATFORM:\n                bcm_obj.parsing_port_list()  \n            for index in transceiver_obj.get_port_to_i2c_mapping().keys():\n                info = transceiver_obj.get_eeprom_dict_info(index)\n                value = transceiver_obj.get_eeprom_partNum_from_parser_eeprom_dict(info)\n                if transceiver_obj.get_transceiver_port_mapping().has_key(index) is not False and transceiver_obj.get_transceiver_port_mapping()[index][\"pn\"] <> value:\n                    transceiver_obj.get_transceiver_port_mapping()[index][\"pn\"] = value\n                    transceiver_obj.set_transceiver_type(index,value) \n                    transceiver_obj.set_tx_disable(index)\n                    #transceiver_obj.show_transceiver_port_mapping()     \n            # transceiver_obj.show_transceiver_port_mapping()       \n        except Exception, e:\n            log_message(\"Exception. The warning is {0}\".format(str(e)) )            \n        time.sleep(1)\n\n    syslog.closelog()\n    del transceiver_obj\n    del bcm_obj\n\nif __name__ == \"__main__\":\n    main()\n\n\n\n\n\n\n\n"}, "/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py": {"changes": [{"diff": "\n         return True\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/dev", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py", "badparts": ["        return os.system(\"docker > /dev/null 2>&1\") == 0"], "goodparts": ["        return subprocess.call([\"docker\"]) == 0"]}]}, "/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py": {"changes": [{"diff": "\n \t      return status\n     for addr_offset in range (0,FAN_NUM):\n         addr=FAN_VPD_ADDR_BASE+addr_offset\n-        cmd = \"i2cdetect -y \"+str(FAN_VPD_CHANNEL)+\" \"+str(addr)+\" \"+str(addr)+\" | grep \"+str(hex(addr)).replace('0x','')\n-        result=os.system(cmd)\n+        cmd1 = [\"i2cdetect\", \"-y\", str(FAN_VPD_CHANNEL), str(addr), str(addr)]\n+        cmd2 = [\"grep\", f'{addr:x}']\n+        result, _ = getstatusoutput_noshell_pipe(cmd1, cmd2)\n         if( result==0 ):\n             cmd=\"echo inv_eeprom \"+str(addr)+\" > /sys/bus/i2c/devices/i2c-\"+FAN_VPD_CHANNEL\n             status, output = exec_cmd(c", "add": 3, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py", "badparts": ["        cmd = \"i2cdetect -y \"+str(FAN_VPD_CHANNEL)+\" \"+str(addr)+\" \"+str(addr)+\" | grep \"+str(hex(addr)).replace('0x','')", "        result=os.system(cmd)"], "goodparts": ["        cmd1 = [\"i2cdetect\", \"-y\", str(FAN_VPD_CHANNEL), str(addr), str(addr)]", "        cmd2 = [\"grep\", f'{addr:x}']", "        result, _ = getstatusoutput_noshell_pipe(cmd1, cmd2)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes \"\"\" import os import commands import sys, getopt import logging import syslog import time DEBUG=False args=[] FORCE=0 FAN_VPD_CHANNEL=1 FAN_VPD_ADDR_BASE=0x52 FAN_NUM=5 RETRY_LIMIT=5 i2c_prefix='/sys/bus/i2c/devices/' if DEBUG==True: print sys.argv[0] print 'ARGV: ', sys.argv[1:] def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print options print args print len(sys.argv) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': install() elif arg=='clean': uninstall() else: show_help() return 0 def show_help(): print __doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]} sys.exit(0) def show_log(txt): if DEBUG==True: print \"[D6332]\"+txt return def exec_cmd(cmd, show): logging.info('Run:'+cmd) status, output=commands.getstatusoutput(cmd) show_log(cmd +\" with result:\" +str(status)) show_log(\" output:\"+output) if status: logging.info('Failed:'+cmd) if show: print('Failed:'+cmd) return status, output def link_dir(prefix,dst): retry=0 ret=False while(ret==False and retry<RETRY_LIMIT): ret=os.path.isdir(prefix) if ret==True: break time.sleep(0.5) retry+=1 if ret==True: dirs=os.listdir(prefix) ret=False for i in dirs: if i.startswith('hwmon'): src=prefix+i os.symlink(src,dst) ret=True break if ret==False: syslog.syslog(syslog.LOG_ERR, \"Can't find proper dir to link under %s\" % prefix) else: syslog.syslog(syslog.LOG_ERR,\"Path %s is not a dir\" % prefix) _path_prefix_list=[ \"/sys/bus/i2c/devices/i2c-pmbus-1/hwmon/\", \"/sys/bus/i2c/devices/i2c-pmbus-2/hwmon/\", \"/sys/devices/platform/coretemp.0/hwmon/\", \"/sys/bus/i2c/devices/i2c-tmp75-1/hwmon/\", \"/sys/bus/i2c/devices/i2c-tmp75-2/hwmon/\", \"/sys/bus/i2c/devices/i2c-tmp75-3/hwmon/\", \"/sys/bus/i2c/devices/i2c-tmp75-4/hwmon/\" ] _path_dst_list=[ \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/psu1\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/psu2\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/coretemp\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_1\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_2\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_3\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_4\", ] instantiate=[ 'echo inv_eeprom 0x55 > /sys/bus/i2c/devices/i2c-0/new_device' ] drivers=[ 'gpio_ich', 'lpc_ich', 'i2c-i801', 'i2c-mux', 'i2c-mux-pca954x', 'i2c-mux-pca9541', 'i2c-dev', 'ucd9000', 'inv_eeprom', 'inv_cpld', 'lm75', 'inv_platform', 'swps'] def system_install(boot_option): global FORCE status, output=exec_cmd(\"rmmod i2c_ismt \", 1) if status: print output if FORCE==0: return status status, output=exec_cmd(\"rmmod i2c-i801 \", 1) if status: print output if FORCE==0: return status status, output=exec_cmd(\"rmmod gpio_ich \", 1) if status: print output if FORCE==0: return status status, output=exec_cmd(\"rmmod lpc_ich \", 1) if status: print output if FORCE==0: return status ''' boot_option: 0 -normal, 1 -fast-reboot''' for i in range(0,len(drivers)): if drivers[i]==\"swps\": if boot_option==1: status, output=exec_cmd(\"modprobe swps io_no_init=1\", 1) else: status, output=exec_cmd(\"modprobe \"+drivers[i], 1) else: status, output=exec_cmd(\"modprobe \"+drivers[i], 1) if status: \t print output \t if FORCE==0: \t return status for i in range(0,len(instantiate)): status, output=exec_cmd(instantiate[i], 1) if status: \t print output \t if FORCE==0: \t return status for addr_offset in range(0,FAN_NUM): addr=FAN_VPD_ADDR_BASE+addr_offset cmd=\"i2cdetect -y \"+str(FAN_VPD_CHANNEL)+\" \"+str(addr)+\" \"+str(addr)+\" | grep \"+str(hex(addr)).replace('0x','') result=os.system(cmd) if( result==0): cmd=\"echo inv_eeprom \"+str(addr)+\" > /sys/bus/i2c/devices/i2c-\"+FAN_VPD_CHANNEL status, output=exec_cmd(cmd,1) if status: print output if FORCE==0: return status for i in range(12,20): cmd=\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-4/i2c-\"+str(i)+\"/new_device\" status, output=exec_cmd(cmd,1) if status: print output if FORCE==0: return status for i in range(20,28): status, output=exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-5/i2c-\"+str(i)+\"/new_device\", 1) if status: print output if FORCE==0: return status for i in range(28,36): status, output=exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-6/i2c-\"+str(i)+\"/new_device\", 1) if status: print output if FORCE==0: return status for i in range(36,44): status, output=exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-7/i2c-\"+str(i)+\"/new_device\", 1) if status: print output if FORCE==0: return status for i in range(0,len(_path_prefix_list)): if( os.path.islink(_path_dst_list[i])): os.unlink(_path_dst_list[i]) syslog.syslog(syslog.LOG_WARNING, \"Path %s exists, remove before link again\" % _path_dst_list[i]) link_dir(_path_prefix_list[i],_path_dst_list[i]) return def system_ready(): if not device_found(): return False return True def install(boot_option=0): ''' boot_option: 0 -normal, 1 -fast-reboot ''' if not device_found(): print \"No device, installing....\" status=system_install(boot_option) if status: if FORCE==0: return status else: print \"D6332 devices detected....\" return def uninstall(): global FORCE for i in range(len(drivers)-1,-1,-1): status, output=exec_cmd(\"rmmod \"+drivers[i], 1) if status: \t print output \t if FORCE==0: \t return status return def device_found(): ret1, log=exec_cmd(\"ls \"+i2c_prefix+\"*0072\", 0) ret2, log=exec_cmd(\"ls \"+i2c_prefix+\"i2c-5\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2017 Inventec, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean \ncommand:\n    install         : install drivers and generate related sysfs nodes\n    clean           : uninstall drivers and remove related sysfs nodes\n\"\"\"\n\nimport os\nimport commands\nimport sys, getopt\nimport logging\nimport syslog\nimport time\n\nDEBUG = False\nargs = []\nFORCE = 0\nFAN_VPD_CHANNEL= 1\nFAN_VPD_ADDR_BASE=0x52\nFAN_NUM=5\nRETRY_LIMIT = 5\ni2c_prefix = '/sys/bus/i2c/devices/'\n\n\nif DEBUG == True:\n    print sys.argv[0]\n    print 'ARGV: ', sys.argv[1:]\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n\n\n    if len(sys.argv)<2:\n        show_help()\n\n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:\n        print options\n        print args\n        print len(sys.argv)\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n            install()\n        elif arg == 'clean':\n            uninstall()\n        else:\n            show_help()\n\n\n    return 0\n\ndef show_help():\n    print __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]}\n    sys.exit(0)\n\ndef show_log(txt):\n    if DEBUG == True:\n        print \"[D6332]\"+txt\n    return\n\ndef exec_cmd(cmd, show):\n    logging.info('Run :'+cmd)\n    status, output = commands.getstatusoutput(cmd)\n    show_log (cmd +\" with result:\" + str(status))\n    show_log (\"      output:\"+output)\n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print('Failed :'+cmd)\n    return  status, output\n\ndef link_dir(prefix,dst):\n    retry=0\n    ret=False\n    while(ret==False and retry<RETRY_LIMIT):\n        ret=os.path.isdir(prefix)\n        if ret==True:\n            break\n        time.sleep(0.5)\n        retry+=1\n\n    if ret==True:\n        dirs=os.listdir(prefix)\n        ret=False\n        for i in dirs:\n            if i.startswith('hwmon'):\n                src=prefix+i\n                os.symlink(src,dst)\n                ret=True\n                break\n        if ret==False:\n            syslog.syslog(syslog.LOG_ERR, \"Can't find proper dir to link under %s\" % prefix)\n    else:\n        syslog.syslog(syslog.LOG_ERR,\"Path %s is not a dir\" % prefix)\n\n_path_prefix_list=[\n    \"/sys/bus/i2c/devices/i2c-pmbus-1/hwmon/\",\n    \"/sys/bus/i2c/devices/i2c-pmbus-2/hwmon/\",\n    \"/sys/devices/platform/coretemp.0/hwmon/\",\n    \"/sys/bus/i2c/devices/i2c-tmp75-1/hwmon/\",\n    \"/sys/bus/i2c/devices/i2c-tmp75-2/hwmon/\",\n    \"/sys/bus/i2c/devices/i2c-tmp75-3/hwmon/\",\n    \"/sys/bus/i2c/devices/i2c-tmp75-4/hwmon/\"\n]\n\n_path_dst_list=[\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/psu1\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/psu2\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/coretemp\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_1\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_2\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_3\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_4\",\n]\n\ninstantiate = [\n'echo inv_eeprom 0x55 > /sys/bus/i2c/devices/i2c-0/new_device'\n#'echo inv_cpld 0x33 > /sys/bus/i2c/devices/i2c-0/i2c-2/new_device',\n#'echo inv_cpld 0x77 > /sys/bus/i2c/devices/i2c-0/i2c-2/new_device'\n]\n\n\ndrivers =[\n#kernel-dirvers\n'gpio_ich',\n'lpc_ich',\n'i2c-i801',\n'i2c-mux',\n'i2c-mux-pca954x',\n'i2c-mux-pca9541',\n'i2c-dev',\n'ucd9000',\n#inv-modules\n'inv_eeprom',\n'inv_cpld',\n'lm75',\n'inv_platform',\n#'monitor',\n'swps']\n\n\n# Modify for fast-reboot\ndef system_install(boot_option):\n    global FORCE\n\n    #remove default drivers to avoid modprobe order conflicts\n    status, output = exec_cmd(\"rmmod i2c_ismt \", 1)\n    if status:\n       print output\n       if FORCE == 0:\n          return status\n\n    status, output = exec_cmd(\"rmmod i2c-i801 \", 1)\n    if status:\n       print output\n       if FORCE == 0:\n          return status\n\n    status, output = exec_cmd(\"rmmod gpio_ich \", 1)\n    if status:\n       print output\n       if FORCE == 0:\n          return status\n\n    status, output = exec_cmd(\"rmmod lpc_ich \", 1)\n    if status:\n       print output\n       if FORCE == 0:\n          return status\n\n    #insert extra module\n    #status, output = exec_cmd(\"insmod /lib/modules/4.9.0-9-2-amd64/kernel/drivers/gpio/gpio-ich.ko gpiobase=0\",1)\n\n    #install drivers\n    ''' boot_option: 0 - normal, 1 - fast-reboot'''\n    for i in range(0,len(drivers)):\n       if drivers[i] == \"swps\":\n           if boot_option == 1:\n               status, output = exec_cmd(\"modprobe swps io_no_init=1\", 1)\n           else:\n               status, output = exec_cmd(\"modprobe \"+drivers[i], 1)\n       else:\n           status, output = exec_cmd(\"modprobe \"+drivers[i], 1)\n\n    if status:\n\t   print output\n\t   if FORCE == 0:\n\t      return status\n\n    #instantiate devices\n    for i in range(0,len(instantiate)):\n       #time.sleep(1)\n       status, output = exec_cmd(instantiate[i], 1)\n    if status:\n\t   print output\n\t   if FORCE == 0:                \n\t      return status\n    for addr_offset in range (0,FAN_NUM):\n        addr=FAN_VPD_ADDR_BASE+addr_offset\n        cmd = \"i2cdetect -y \"+str(FAN_VPD_CHANNEL)+\" \"+str(addr)+\" \"+str(addr)+\" | grep \"+str(hex(addr)).replace('0x','')\n        result=os.system(cmd)\n        if( result==0 ):\n            cmd=\"echo inv_eeprom \"+str(addr)+\" > /sys/bus/i2c/devices/i2c-\"+FAN_VPD_CHANNEL\n            status, output = exec_cmd(cmd,1)\n            if status:\n               print output\n               if FORCE == 0:                \n                  return status\n#\n# INV_FIX-4037\n# It replaces the original sff8436 driver with the optoe driver\n#\n    #optoe map to i2c-bus\\\n    for i in range(12,20):\n        cmd=\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-4/i2c-\"+str(i)+\"/new_device\"\n        status, output =exec_cmd(cmd,1)\n        if status:\n            print output\n            if FORCE == 0:\n                return status\n    for i in range(20,28):\n        status, output =exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-5/i2c-\"+str(i)+\"/new_device\", 1)\n        if status:\n            print output\n            if FORCE == 0:\n                return status\n    for i in range(28,36):\n        status, output =exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-6/i2c-\"+str(i)+\"/new_device\", 1)\n        if status:\n            print output\n            if FORCE == 0:\n                return status\n    for i in range(36,44):\n        status, output =exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-7/i2c-\"+str(i)+\"/new_device\", 1)\n        if status:\n            print output\n            if FORCE == 0:\n                return status\n                \n    #make softlink for device info\n    for i in range(0,len(_path_prefix_list)):\n        if( os.path.islink(_path_dst_list[i]) ):\n            os.unlink(_path_dst_list[i])\n            syslog.syslog(syslog.LOG_WARNING, \"Path %s exists, remove before link again\" % _path_dst_list[i] )\n        link_dir(_path_prefix_list[i],_path_dst_list[i])\n\n    return\n\n\ndef system_ready():\n    if not device_found():\n        return False\n    return True\n\ndef install(boot_option=0):\n    ''' boot_option: 0 - normal, 1 - fast-reboot '''\n    if not device_found():\n        print \"No device, installing....\"\n        status = system_install(boot_option)\n        if status:\n            if FORCE == 0:\n                return status\n    else:\n        print \"D6332 devices detected....\"\n    return\n\ndef uninstall():\n    global FORCE\n    #uninstall drivers\n    for i in range(len(drivers)-1,-1,-1):\n       status, output = exec_cmd(\"rmmod \"+drivers[i], 1)\n    if status:\n\t   print output\n\t   if FORCE == 0:\n\t      return status\n    return\n\ndef device_found():\n    ret1, log = exec_cmd(\"ls \"+i2c_prefix+\"*0072\", 0)\n    ret2, log = exec_cmd(\"ls \"+i2c_prefix+\"i2c-5\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"}, "/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py": {"changes": [{"diff": "\n         return retval\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/d", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py", "badparts": ["        return os.system(\"docker > /dev/null 2>&1\") == 0"], "goodparts": ["        return subprocess.call([\"docker\"]) == 0"]}]}, "/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py": {"changes": [{"diff": "\n \n try:\n     import os\n-    import sys\n+    import subprocess\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472InterfaceId\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py", "badparts": ["    import sys"], "goodparts": ["    import subprocess"]}, {"diff": "\n         return retval\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py", "badparts": ["        return os.system(\"docker > /dev/null 2>&1\") == 0"], "goodparts": ["        return subprocess.call([\"docker\"]) == 0"]}]}, "/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to QSFP sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-inventec_d7054q28b-r0\"\n     HWSKU  = \"INVENTEC-D7054Q28B-S48-Q6\"\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         return \"\"\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}]}}, "msg": "[inventec] Replace os.system and remove subprocess with shell=True (#12108)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\nDependency: [https://github.com/sonic-net/sonic-buildimage/pull/12065](https://github.com/sonic-net/sonic-buildimage/pull/12065)\r\n#### Why I did it\r\n1. `getstatusoutput` is used without a static string and it uses `shell=True`\r\n2. `subprocess()` - when using with `shell=True` is dangerous. Using subprocess function without a static string can lead to command injection.\r\n3. `os` - not secure against maliciously constructed input and dangerous if used to evaluate dynamic content.\r\n#### How I did it\r\n1. use `getstatusoutput` without shell=True\r\n2. `subprocess()` - use `shell=False` instead. use an array string. Ref: [https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation](https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation)\r\n3. `os` - use with `subprocess`"}, "35c4e9912de88dcc821ac5c8aebcc994ddcb9838": {"url": "https://api.github.com/repos/SaranyaAzhgamuthaiyan/sonic-buildimage/commits/35c4e9912de88dcc821ac5c8aebcc994ddcb9838", "html_url": "https://github.com/SaranyaAzhgamuthaiyan/sonic-buildimage/commit/35c4e9912de88dcc821ac5c8aebcc994ddcb9838", "sha": "35c4e9912de88dcc821ac5c8aebcc994ddcb9838", "keyword": "command injection malicious", "diff": "diff --git a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py\nindex 56e9d8664..12f1cc8ed 100644\n--- a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py\n@@ -37,14 +37,14 @@ def get_pcie_device(self):\n         pciList = []\n         p1 = \"^(\\w+):(\\w+)\\.(\\w)\\s(.*)\\s*\\(*.*\\)*\"\n         p2 = \"^.*:.*:.*:(\\w+)\\s*\\(*.*\\)*\"\n-        command1 = \"sudo lspci\"\n-        command2 = \"sudo lspci -n\"\n+        command1 = [\"sudo\", \"lspci\"]\n+        command2 = [\"sudo\", \"lspci\", \"-n\"]\n         # run command 1\n-        proc1 = subprocess.Popen(command1, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc1 = subprocess.Popen(command1, universal_newlines=True, stdout=subprocess.PIPE)\n         output1 = proc1.stdout.readlines()\n         proc1.communicate()\n         # run command 2\n-        proc2 = subprocess.Popen(command2, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc2 = subprocess.Popen(command2, universal_newlines=True, stdout=subprocess.PIPE)\n         output2 = proc2.stdout.readlines()\n         proc2.communicate()\n \ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py\nindex ea4048e19..18ca047cb 100644\n--- a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py\n@@ -10,13 +10,13 @@\n \n try:\n     import time\n-    import subprocess\n     from sonic_platform_base.chassis_base import ChassisBase\n     from sonic_platform.common import Common\n     from sonic_platform.sfp import Sfp\n     from sonic_platform.sfp import PORT_START\n     from sonic_platform.sfp import PORTS_IN_BLOCK\n     from sonic_platform.logger import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -36,17 +36,17 @@ def __init__(self):\n         self.SFP_STATUS_INSERTED = \"1\"\n         self.SFP_STATUS_REMOVED = \"0\"\n         self.port_dict = {}\n-        self.enable_read= \"i2cset -f -y 2 0x35 0x2a 0x01\"\n-        self.disable_read = \"i2cset -f -y 2 0x35 0x2a 0x00\"\n-        self.enable_write = \"i2cset -f -y 2 0x35 0x2b 0x00\"\n-        self.disable_write = \"i2cset -f -y 2 0x35 0x2b 0x01\"\n-        self.enable_erase = \"i2cset -f -y 2 0x35 0x2c 0x01\"\n-        self.disable_erase = \"i2cset -f -y 2 0x35 0x2c 0x00\"\n-        self.read_value = \"i2cget -f -y 2 0x35 0x25\"\n-        self.write_value = \"i2cset -f -y 2 0x35 0x21 0x0a\"\n-        self.set_sys_led_cmd = \"i2cset -f -y 2 0x33 0xb2 \"\n-        self.get_sys_led_cmd = \"i2cget -f -y 2 0x33 0xb2\"\n-        self.led_status = \"red\"\n+        self.enable_read= [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x01\"]\n+        self.disable_read = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x00\"]\n+        self.enable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x00\"]\n+        self.disable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x01\"]\n+        self.enable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x01\"]\n+        self.disable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x00\"]\n+        self.read_value = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x25\"]\n+        self.write_value = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x21\", \"0x0a\"]\n+        self.set_sys_led_cmd = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]\n+        self.get_sys_led_cmd = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]\n+        self.led_status = \"red\" \n         # Initialize SFP list\n         # sfp.py will read eeprom contents and retrive the eeprom data.\n         # It will also provide support sfp controls like reset and setting\n@@ -210,25 +210,25 @@ def get_reboot_cause(self):\n         try:\n             is_power_loss = False\n             # enable read\n-            subprocess.getstatusoutput(self.disable_write)\n-            subprocess.getstatusoutput(self.enable_read)\n-            ret , log = subprocess.getstatusoutput(self.read_value)\n+            getstatusoutput_noshell(self.disable_write)\n+            getstatusoutput_noshell(self.enable_read)\n+            ret , log = getstatusoutput_noshell(self.read_value)\n             if ret == 0 and \"0x0a\" in log:\n                 is_power_loss = True\n \n             # erase i2c and e2\n-            subprocess.getstatusoutput(self.enable_erase)\n+            getstatusoutput_noshell(self.enable_erase)\n             time.sleep(1)\n-            subprocess.getstatusoutput(self.disable_erase)\n+            getstatusoutput_noshell(self.disable_erase)\n             # clear data\n-            subprocess.getstatusoutput(self.enable_write)\n-            subprocess.getstatusoutput(self.disable_read)\n-            subprocess.getstatusoutput(self.disable_write)\n-            subprocess.getstatusoutput(self.enable_read)\n+            getstatusoutput_noshell(self.enable_write)\n+            getstatusoutput_noshell(self.disable_read)\n+            getstatusoutput_noshell(self.disable_write)\n+            getstatusoutput_noshell(self.enable_read)\n             # enable write and set data\n-            subprocess.getstatusoutput(self.enable_write)\n-            subprocess.getstatusoutput(self.disable_read)\n-            subprocess.getstatusoutput(self.write_value)\n+            getstatusoutput_noshell(self.enable_write)\n+            getstatusoutput_noshell(self.disable_read)\n+            getstatusoutput_noshell(self.write_value)\n             if is_power_loss:\n                 return(self.REBOOT_CAUSE_POWER_LOSS, None)\n         except Exception as e:\n@@ -417,7 +417,8 @@ def set_status_led(self, color):\n         if regval is None:\n             print(\"Invaild color input.\")\n             return False\n-        ret , log = subprocess.getstatusoutput(self.set_sys_led_cmd + regval)\n+        cmd = self.set_sys_led_cmd + [regval]\n+        ret, log = getstatusoutput_noshell(cmd)\n         if ret != 0:\n             print(\"Cannot execute %s\" % self.set_sys_led_cmd + regval)\n             return False\n@@ -431,7 +432,7 @@ def get_status_led(self):\n             A string, one of the valid LED color strings which could be vendor\n             specified.\n         \"\"\"\n-        ret , log = subprocess.getstatusoutput(self.get_sys_led_cmd)\n+        ret , log = getstatusoutput_noshell(self.get_sys_led_cmd)\n         if ret != 0:\n             print(\"Cannot execute %s\" % self.get_sys_led_cmd)\n             return False\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py\nindex c1a85f618..e1bef19c2 100644\n--- a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py\n@@ -1,6 +1,6 @@\n import os\n import yaml\n-\n+import subprocess\n from sonic_py_common import device_info\n \n \n@@ -10,13 +10,13 @@ class Common:\n     PMON_PLATFORM_PATH = '/usr/share/sonic/platform/'\n     CONFIG_DIR = 'sonic_platform_config'\n \n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def load_json_file(self, path):\n         \"\"\"\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py\nindex 33ff6ef8b..26e83fb19 100644\n--- a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py\n@@ -8,10 +8,10 @@\n ########################################################################\n \n try:\n-    import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n     from sonic_platform.regutil import Reg\n     from sonic_platform.logger import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -70,12 +70,12 @@ def install_firmware(self, image_path):\n         \"\"\"\n         try:\n             successtips = \"CPLD Upgrade succeeded!\"\n-            status, output = subprocess.getstatusoutput(\"which firmware_upgrade\")\n+            status, output = getstatusoutput_noshell([\"which\", \"firmware_upgrade\"])\n             if status or len(output) <= 0:\n                 logger.error(\"no upgrade tool.\")\n                 return False\n-            cmdstr = \"%s %s cpld %d cpld\"%(output,image_path,self.slot)\n-            ret, log = subprocess.getstatusoutput(cmdstr)\n+            cmdstr = [output, image_path, \"cpld\", self.slot, \"cpld\"]\n+            ret, log = getstatusoutput_noshell(cmdstr)\n             if ret == 0 and successtips in log:\n                 return True\n             logger.error(\"upgrade failed. ret:%d, log:\\n%s\" % (ret, log))\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py b/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py\nindex 46f3089bb..88453c9e9 100644\n--- a/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py\n@@ -6,7 +6,6 @@\n #\n #######################################################\n \n-import subprocess\n import time\n import glob\n import re\n@@ -14,6 +13,7 @@\n from rjutil.smbus import SMBus\n import time\n from  functools import wraps\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n def retry(maxretry =6, delay = 0.01):\n@@ -80,13 +80,13 @@ def rji2csetword_python(bus, addr, reg, value):\n \n     @staticmethod\n     def command(cmdstr):\n-        retcode, output = subprocess.getstatusoutput(cmdstr)\n+        retcode, output = getstatusoutput_noshell(cmdstr)\n         return retcode, output\n \n \n     @staticmethod\n     def geti2cword_i2ctool(bus, addr, offset):\n-        command_line = \"i2cget -f -y %d 0x%02x 0x%02x  wp\" % (bus, addr, offset)\n+        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%02x\"%offset, \"wp\"]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n@@ -99,7 +99,7 @@ def geti2cword_i2ctool(bus, addr, offset):\n \n     @staticmethod\n     def seti2cword_i2ctool(bus, addr, offset, val):\n-        command_line = \"i2cset -f -y %d 0x%02x 0x%0x 0x%04x wp\" % (bus, addr, offset, val)\n+        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%0x\"%offset, \"0x%04x\"%val, \"wp\"]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n@@ -111,7 +111,7 @@ def seti2cword_i2ctool(bus, addr, offset, val):\n \n     @staticmethod\n     def rji2cget_i2ctool(bus, devno, address):\n-        command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)\n+        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n@@ -123,8 +123,7 @@ def rji2cget_i2ctool(bus, devno, address):\n \n     @staticmethod\n     def rji2cset_i2ctool(bus, devno, address, byte):\n-        command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (\n-            bus, devno, address, byte)\n+        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address, \"0x%02x\"%byte]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n@@ -166,7 +165,7 @@ def readsysfs(location):\n \n     @staticmethod\n     def getdevmem(addr, digit, mask):\n-        command_line = \"devmem 0x%02x %d\" %(addr, digit)\n+        command_line = [\"devmem\", \"0x%02x\"%addr, str(digit)]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n@@ -179,13 +178,13 @@ def getdevmem(addr, digit, mask):\n \n     @staticmethod\n     def rj_os_system(cmd):\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         return status, output\n \n     @staticmethod\n     def getsdkreg(reg):\n         try:\n-            cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg\n+            cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]\n             ret, result = osutil.rj_os_system(cmd)\n             result_t = result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n             if ret != 0 or \"Error:\" in result_t:\n@@ -203,8 +202,8 @@ def getmactemp():\n             result = {}\n             #waitForDocker()\n             #need to exec twice\n-            osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n-            ret, log = osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n+            osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n+            ret, log = osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n             if ret:\n                 return False, result\n             else:\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py b/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py\nindex 35bca09c0..c812ba295 100755\n--- a/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py\n@@ -6,7 +6,7 @@\n import subprocess\n import time\n from  ruijieconfig import GLOBALCONFIG, GLOBALINITPARAM, GLOBALINITCOMMAND, MAC_LED_RESET, STARTMODULE, i2ccheck_params\n-\n+from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe\n from  ruijieutil   import rjpciwr\n \n CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])\n@@ -46,7 +46,7 @@ def write_sysfs_value(reg_name, value):\n \n def check_driver():\n     u'''whether there is driver start with rg'''\n-    status, output = log_os_system(\"lsmod | grep rg | wc -l\")\n+    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", \"rg\"], [\"wc\", \"-l\"])\n     #System execution error\n     if status: \n         return False\n@@ -70,61 +70,59 @@ def i2c_getPid(name):\n     return ret\n \n def startAvscontrol():\n-    cmd = \"nohup avscontrol.py start >/dev/null 2>&1 &\"\n+    cmd = [\"avscontrol.py\", \"start\"]\n     rets = i2c_getPid(\"avscontrol.py\")\n     if len(rets) == 0:\n-        os.system(cmd)\n+        subprocess.Popen(cmd)\n \n def startFanctrol():\n     if STARTMODULE['fancontrol'] == 1:\n-        cmd = \"nohup fancontrol.py start >/dev/null 2>&1 &\"\n+        cmd = [\"fancontrol.py\", \"start\"]\n         rets = i2c_getPid(\"fancontrol.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def starthal_fanctrl():\n     if STARTMODULE.get('hal_fanctrl',0) == 1:\n-        cmd = \"nohup hal_fanctrl.py start >/dev/null 2>&1 &\"\n+        cmd = [\"hal_fanctrl.py\", \"start\"]\n         rets = i2c_getPid(\"hal_fanctrl.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def starthal_ledctrl():\n     if STARTMODULE.get('hal_ledctrl',0) == 1:\n-        cmd = \"nohup hal_ledctrl.py start >/dev/null 2>&1 &\"\n+        cmd = [\"hal_ledctrl.py\", \"start\"]\n         rets = i2c_getPid(\"hal_ledctrl.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n-\n+            subprocess.Popen(cmd)\n def startDevmonitor():\n     if STARTMODULE.get('dev_monitor',0) == 1:\n-        cmd = \"nohup dev_monitor.py start >/dev/null 2>&1 &\"\n+        cmd = [\"dev_monitor.py\", \"start\"]\n         rets = i2c_getPid(\"dev_monitor.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n-\n+            subprocess.Popen(cmd)\n def startSlotmonitor():\n     if STARTMODULE.get('slot_monitor',0) == 1:\n-        cmd = \"nohup slot_monitor.py start >/dev/null 2>&1 &\"\n+        cmd = [\"slot_monitor.py\", \"start\"]\n         rets = i2c_getPid(\"slot_monitor.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def stopFanctrol():\n     u'''disable fan timer service'''\n     if STARTMODULE['fancontrol'] == 1:\n         rets = i2c_getPid(\"fancontrol.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def stophal_ledctrl():\n     if STARTMODULE.get('hal_ledctrl',0) == 1:\n         rets = i2c_getPid(\"hal_ledctrl.py\")\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n \n@@ -133,8 +131,8 @@ def stopDevmonitor():\n     if STARTMODULE.get('dev_monitor',0) == 1:\n         rets = i2c_getPid(\"dev_monitor.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def stopSlotmonitor():\n@@ -142,15 +140,16 @@ def stopSlotmonitor():\n     if STARTMODULE.get('slot_monitor',0) == 1:\n         rets = i2c_getPid(\"slot_monitor.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def removeDev(bus, loc):\n-    cmd = \"echo  0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device\" % (loc, bus)\n     devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n     if os.path.exists(devpath):\n-        log_os_system(cmd)\n+        file = \"/sys/bus/i2c/devices/i2c-%d/delete_device\" % bus\n+        with open(file, 'w') as f:\n+            f.write('0x%02x\\n'%str(bus))\n         \n def addDev(name, bus, loc):\n     if name == \"lm75\":\n@@ -163,10 +162,11 @@ def addDev(name, bus, loc):\n         if i % 10 == 0:\n             click.echo(\"%%DEVICE_I2C-INIT: %s not found, wait 0.1 second ! i %d \" % (pdevpath,i))\n             \n-    cmd = \"echo  %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device\" % (name, loc, bus)\n     devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n     if os.path.exists(devpath) == False:\n-        os.system(cmd)\n+        file = \"/sys/bus/i2c/devices/i2c-%d/new_device\" % bus\n+        with open(file, 'w') as f:\n+            f.write('%s 0x%02x\\n' % (name, loc))\n \n def removedevs():\n     devs = GLOBALCONFIG[\"DEVS\"]\n@@ -179,8 +179,7 @@ def adddevs():\n         addDev(devs[dev][\"name\"], devs[dev][\"bus\"] , devs[dev][\"loc\"])\n \n def checksignaldriver(name):\n-    modisexistcmd = \"lsmod | grep %s | wc -l\" % name\n-    status, output = log_os_system(modisexistcmd)\n+    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", name], [\"wc\", \"-l\"])\n     #System execution error\n     if status: \n         return False\n@@ -190,17 +189,17 @@ def checksignaldriver(name):\n         return False\n \n def adddriver(name, delay):\n-    cmd = \"modprobe %s\" % name\n+    cmd = [\"modprobe\", name]\n     if delay != 0:\n         time.sleep(delay)\n     if checksignaldriver(name) != True:\n-        log_os_system(cmd)\n+        getstatusoutput_noshell(cmd)\n \n def removedriver(name, delay):\n     realname = name.lstrip().split(\" \")[0];\n-    cmd = \"rmmod -f %s\" % realname\n+    cmd = [\"rmmod\", \"-f\", realname]\n     if checksignaldriver(realname):\n-        log_os_system(cmd)\n+        getstatusoutput_noshell(cmd)\n \n def removedrivers():\n     u'''remove all drivers'''\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py b/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py\nindex 87fb01e5f..e12bb25d7 100755\n--- a/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py\n@@ -4,6 +4,7 @@\n import os\n import time\n import syslog\n+import subprocess\n from ruijieconfig import MONITOR_CONST, FANCTROLDEBUG, MONITOR_FANS_LED, DEV_LEDS, MONITOR_PSU_STATUS, \\\n         MONITOR_SYS_PSU_LED, MONITOR_DEV_STATUS, MONITOR_FAN_STATUS, MONITOR_DEV_STATUS_DECODE, \\\n         MONITOR_SYS_FAN_LED, MONITOR_SYS_LED, fanloc\n@@ -766,7 +767,7 @@ def checkCrit(self):\n                     self.fanSpeedSetMax()  # fan full speed\n                     self.critnum += 1 # anti-shake\n                     if self.critnum >= MONITOR_CONST.CRITICAL_NUM:\n-                       os.system(\"reboot\")\n+                        subprocess.call([\"reboot\"])\n                     fanwarningdebuglog(DEBUG_FANCONTROL,\"crit\u6b21\u6570:%d\" % self.critnum)\n                 else:\n                     self.critnum = 0\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py b/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py\nindex ff594b72e..9d1930ec0 100755\n--- a/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py\n@@ -11,7 +11,6 @@\n import sys\n import os\n import re\n-import subprocess\n import syslog\n import time\n import binascii\n@@ -20,6 +19,7 @@\n import threading\n import click\n import mmap\n+from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe\n from ruijieconfig import rg_eeprom, FRULISTS, MAC_DEFAULT_PARAM, MAC_AVS_PARAM, FANS_DEF, \\\n         FAN_PROTECT, E2_LOC, E2_PROTECT, RUIJIE_SERVICE_TAG, RUIJIE_DIAG_VERSION, \\\n         STARTMODULE, RUIJIE_CARDID, RUIJIE_PRODUCTNAME, RUIJIE_PART_NUMBER, \\\n@@ -538,8 +538,8 @@ def __new__(cls, *args, **kwargs):\n \n def getSdkReg(reg):\n     try:\n-        cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg\n-        ret, result = rj_os_system(cmd)\n+        cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]\n+        ret, result = getstatusoutput_noshell(cmd)\n         result_t = result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n         if ret != 0 or \"Error:\" in result_t:\n             return False, result\n@@ -632,8 +632,8 @@ def getMacTemp():\n     result = {}\n     #waitForDocker()\n     # exec twice, get the second result\n-    rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n-    ret, log = rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n+    getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n+    ret, log = getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n     if ret:\n         return False, result\n     else:\n@@ -689,21 +689,21 @@ def getMacTemp_sysfs(mactempconf):\n \n def restartDockerService(force=False):\n     container_name = [\"database\",\"snmp\",\"syncd\",\"swss\",\"dhcp_relay\",\"radv\",\"teamd\",\"pmon\"]\n-    ret, status = rj_os_system(\"docker ps\")\n+    ret, status = getstatusoutput_noshell([\"docker\", \"ps\"])\n     if ret == 0 :\n         for tmpname in container_name:\n             if (tmpname not in status):\n                 if (force == True):\n-                    rj_os_system(\"docker restart %s\"%tmpname)\n+                    getstatusoutput_noshell([\"docker\", \"restart\", tmpname])\n                 else:\n-                    rj_os_system(\"systemctl restart %s\"%tmpname)\n+                    getstatusoutput_noshell([\"systemctl\", \"restart\", tmpname])\n \n \n def waitForDhcp(timeout):\n     time_cnt = 0\n     while True:\n         try:\n-            ret, status = rj_os_system(\"systemctl status dhcp_relay.service\")\n+            ret, status = getstatusoutput_noshell([\"systemctl\", \"status\", \"dhcp_relay.service\"])\n             if (ret == 0 and \"running\" in status)  or \"SUCCESS\" in status:\n                 break\n             else:\n@@ -839,8 +839,10 @@ def util_setmac(eth, mac):\n     rulefile = \"/etc/udev/rules.d/70-persistent-net.rules\"\n     if isValidMac(mac) == False:\n         return False, \"MAC invaild\"\n-    cmd = \"ethtool -e %s | grep 0x0010 | awk '{print \\\"0x\\\"$13$12$15$14}'\" % eth\n-    ret, log = rj_os_system(cmd)\n+    cmd1 = [\"ethtool\", \"-e\", eth] \n+    cmd2 = [\"grep\", \"0x0010\"]\n+    cmd3 = [\"awk\", '{print \\\"0x\\\"$13$12$15$14}']\n+    ret, log = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)\n     log_debug(log)\n     magic = \"\"\n     if ret == 0 and len(log):\n@@ -848,23 +850,22 @@ def util_setmac(eth, mac):\n     macs = mac.upper().split(\":\")\n \n     # chage ETH0 to value after setmac\n-    ifconfigcmd = \"ifconfig eth0 hw ether %s\" % mac\n-    log_debug(ifconfigcmd)\n-    ret, status = rj_os_system(ifconfigcmd)\n+    ifconfigcmd = [\"ifconfig\", \"eth0\", \"hw\", \"ether\", mac]\n+    log_debug(' '.join(ifconfigcmd))\n+    ret, status = getstatusoutput_noshell(ifconfigcmd)\n     if ret:\n         raise SETMACException(\"software set  Internet cardMAC error\")\n     index = 0\n     for item in macs:\n-        cmd = \"ethtool -E %s magic %s offset %d value 0x%s\" % (\n-            eth, magic, index, item)\n+        cmd = [\"ethtool\", \"-E\", eht, \"magic\", magic, \"offset\", str(index), \"value\", \"0x\"+item]\n         log_debug(cmd)\n         index += 1\n-        ret, log = rj_os_system(cmd)\n+        ret, log = getstatusoutput_noshell(cmd)\n         if ret != 0:\n             raise SETMACException(\" set hardware Internet card MAC error\")\n     # get value after setting \n-    cmd_t = \"ethtool -e eth0 offset 0 length 6\"\n-    ret, log = rj_os_system(cmd_t)\n+    cmd_t = [\"ethtool\", \"-e\", \"eth0\", \"offset\", \"0\", \"length\", \"6\"]\n+    ret, log = getstatusoutput_noshell(cmd_t)\n     m = re.split(':', log)[-1].strip().upper()\n     mac_result = m.upper().split(\" \")\n \n@@ -979,11 +980,11 @@ def generate_ext(cardid):\n \n \n def rji2cget(bus, devno, address):\n-    command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)\n+    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address)]\n     retrytime = 6\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n         time.sleep(0.1)\n@@ -991,12 +992,11 @@ def rji2cget(bus, devno, address):\n \n \n def rji2cset(bus, devno, address, byte):\n-    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (\n-        bus, devno, address, byte)\n+    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%02x\"%str(byte)]\n     retrytime = 6\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n     return False, ret_t\n@@ -1033,31 +1033,30 @@ def rjpciwr(pcibus , slot ,fn, bar, offset, data):\n     data.close()\n \n def rjsysset(location, value):\n-    command_line = \"echo 0x%02x > %s\" % (value, location)\n     retrytime = 6\n-    ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n-        if ret == 0:\n-            return True, ret_t\n-    return False, ret_t\n+        try:\n+            with open(location, 'w') as f:\n+                f.write('0x%02x\\n'%value)\n+        except (IOError, FileNotFoundError) as e:\n+            return False, str(e)\n+    return True, ''\n \n \n def rji2cgetWord(bus, devno, address):\n-    command_line = \"i2cget -f -y %d 0x%02x 0x%02x w\" % (bus, devno, address)\n+    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"w\"]\n     retrytime = 3\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n     return False, ret_t\n \n \n def rji2csetWord(bus, devno, address, byte):\n-    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%x w\" % (\n-        bus, devno, address, byte)\n-    rj_os_system(command_line)\n+    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%x\"%str(byte), \"w\"]\n+    getstatusoutput_noshell(command_line)\n \n \n def fan_setmac():\n@@ -1264,14 +1263,15 @@ def writeToEEprom(rst_arr):\n     elif dealtype == \"io\":\n         io_wr(E2_PROTECT[\"io_addr\"], E2_PROTECT[\"close\"])\n     # deal last drivers\n-    os.system(\"rmmod at24 \")\n-    os.system(\"modprobe at24 \")\n-    os.system(\"rm -f /var/cache/sonic/decode-syseeprom/syseeprom_cache\")\n+    getstatusoutput_noshell([\"rmmod\", \"at24\"])\n+    getstatusoutput_noshell([\"modprobe\", \"at24\"])\n+    getstatusoutput_noshell([\"rm\", \"-f\", \"/var/cache/sonic/decode-syseeprom/syseeprom_cache\"])\n \n \n def get_local_eth0_mac():\n-    cmd = \"ifconfig eth0 |grep HWaddr\"\n-    print(rj_os_system(cmd))\n+    cmd1 = [\"ifconfig\", \"eth0\"]\n+    cmd2 = [\"grep\", \"HWaddr\"]\n+    print(getstatusoutput_noshell_pipe(cmd1, cmd2))\n \n def getonieversion():\n     if not os.path.isfile('/host/machine.conf'):\n@@ -1348,12 +1348,12 @@ def fac_board_setmac():\n \n def ipmi_set_mac(mac):\n     macs = mac.split(\":\")\n-    cmdinit = \"ipmitool raw 0x0c 0x01 0x01 0xc2 0x00\"\n-    cmdset = \"ipmitool raw 0x0c 0x01 0x01 0x05\"\n+    cmdinit = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0xc2\", \"0x00\"]\n+    cmdset = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0x05\"]\n     for ind in range(len(macs)):\n-        cmdset += \" 0x%02x\" % int(macs[ind], 16)\n-    rj_os_system(cmdinit)\n-    ret, status = rj_os_system(cmdset)\n+        cmdset.append(\"0x%02x\" % int(macs[ind], 16))\n+    getstatusoutput_noshell(cmdinit)\n+    ret, status = getstatusoutput_noshell(cmdset)\n     if ret:\n         RJPRINTERR(\"\\n\\n%s\\n\\n\" % status)\n         return False\n@@ -1393,11 +1393,11 @@ def closeProtocol():\n     log_info(\"disable LLDP\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n-    rj_os_system(\"systemctl stop lldp.service\")\n+    getstatusoutput_noshell([\"systemctl\", \"stop\", \"lldp.service\"])\n     log_info(\"disable lldp service\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n-    rj_os_system(\"systemctl stop bgp.service\")\n+    getstatusoutput_noshell([\"systemctl\", \"stop\", \"bgp.service\"])\n     log_info(\"disable bgp service\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n@@ -1420,8 +1420,8 @@ def checkSdkMem():\n     with open(file_name, \"w\") as f:\n         f.write(file_data)\n     print(\"change SDK memory to 256, reboot required\")\n-    rj_os_system(\"sync\")\n-    rj_os_system(\"reboot\")\n+    getstatusoutput_noshell([\"sync\"])\n+    getstatusoutput_noshell([\"reboot\"])\n \n ##########################################################################\n # receives a character setting\n@@ -1604,25 +1604,22 @@ def getCardId():\n             return item.get('value',None)\n     return None\n \n-# ====================================\n-# execute shell command\n-# ====================================\n-def rj_os_system(cmd):\n-    status, output = subprocess.getstatusoutput(cmd)\n-    return status, output\n \n ###########################################\n # get memory slot and number via DMI command\n ###########################################\n def getsysmeminfo():\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \"|grep -P -A5 \\\"Memory\\s+Device\\\"|grep Size|grep -v Range\"\n+    cmd1 = [log[0].rstrip('\\n')]\n+    cmd2 = [\"grep\", \"-P\", \"-A5\", \"Memory\\s+Device\"]\n+    cmd3 = [\"grep\", \"Size\"]\n+    cmd4 = [\"grep\", \"-v\", \"Range\"]\n     # get total number first\n     result = []\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3, cmd4)\n     if ret1 == 0 and len(log1):\n         log1 = log1.lstrip()\n         arr = log1.split(\"\\n\")\n@@ -1642,15 +1639,16 @@ def getsysmeminfo():\n # return various arrays\n ###########################################\n def getsysmeminfo_detail():\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \" -t 17 | grep  -A21 \\\"Memory Device\\\"\"  # 17\n+    cmd1 = [log[0].rstrip('\\n')] + [\"-t\", \"17\"]\n+    cmd2 = [\"grep\", \"-A21\", \"Memory Device\"]  # 17\n     # get total number\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)\n     if ret1 != 0 or len(log1) <= 0:\n-        return False, \"command execution error[%s]\" % cmd\n+        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)\n     result_t = log1.split(\"--\")\n     mem_rets = []\n     for item in result_t:\n@@ -1669,13 +1667,13 @@ def getsysmeminfo_detail():\n # get BIOS info via DMI command\n ###########################################\n def getDmiSysByType(type_t):\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \" -t %s\" % type_t\n+    cmd = [log[0].rstrip('\\n')] + [\"-t\", str(type_t)]\n     # get total number\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell(cmd)\n     if ret1 != 0 or len(log1) <= 0:\n         return False, \"command execution error[%s]\" % cmd\n     its = log1.replace(\"\\t\", \"\").strip().split(\"\\n\")\n@@ -1742,11 +1740,12 @@ def getusbinfo():\n         return False, \"Err\"\n \n def get_cpu_info():\n-    cmd = \"cat /proc/cpuinfo |grep processor -A18\"  # 17\n+    cmd1 = [\"cat\", \"/proc/cpuinfo\"]\n+    cmd2 = [\"grep\", \"processor\", \"-A18\"]  # 17\n \n-    ret, log1 = rj_os_system(cmd)\n+    ret, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)\n     if ret != 0 or len(log1) <= 0:\n-        return False, \"command execution error[%s]\" % cmd\n+        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)\n     result_t = log1.split(\"--\")\n     mem_rets = []\n     for item in result_t:\n", "message": "", "files": {"/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py": {"changes": [{"diff": "\n         pciList = []\n         p1 = \"^(\\w+):(\\w+)\\.(\\w)\\s(.*)\\s*\\(*.*\\)*\"\n         p2 = \"^.*:.*:.*:(\\w+)\\s*\\(*.*\\)*\"\n-        command1 = \"sudo lspci\"\n-        command2 = \"sudo lspci -n\"\n+        command1 = [\"sudo\", \"lspci\"]\n+        command2 = [\"sudo\", \"lspci\", \"-n\"]\n         # run command 1\n-        proc1 = subprocess.Popen(command1, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc1 = subprocess.Popen(command1, universal_newlines=True, stdout=subprocess.PIPE)\n         output1 = proc1.stdout.readlines()\n         proc1.communicate()\n         # run command 2\n-        proc2 = subprocess.Popen(command2, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc2 = subprocess.Popen(command2, universal_newlines=True, stdout=subprocess.PIPE)\n         output2 = proc2.stdout.readlines()\n         proc2.communicate()\n ", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py", "badparts": ["        command1 = \"sudo lspci\"", "        command2 = \"sudo lspci -n\"", "        proc1 = subprocess.Popen(command1, shell=True, universal_newlines=True, stdout=subprocess.PIPE)", "        proc2 = subprocess.Popen(command2, shell=True, universal_newlines=True, stdout=subprocess.PIPE)"], "goodparts": ["        command1 = [\"sudo\", \"lspci\"]", "        command2 = [\"sudo\", \"lspci\", \"-n\"]", "        proc1 = subprocess.Popen(command1, universal_newlines=True, stdout=subprocess.PIPE)", "        proc2 = subprocess.Popen(command2, universal_newlines=True, stdout=subprocess.PIPE)"]}], "source": "\n import os import yaml import subprocess import re import sys from copy import deepcopy try: from.pcie import PcieBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class PcieUtil(PcieBase): \"\"\"Platform-specific PCIEutil class\"\"\" def __init__(self, path): self.config_path=path def load_config_file(self): config_file=self.config_path +\"/\" +\"pcie.yaml\" try: with open(config_file) as conf_file: self.confInfo=yaml.load(conf_file) except IOError as e: print(\"Error:{}\".format(str(e))) print(\"Not found config file, please add a config file manually, or generate it by running[pcieutil pcie_generate]\") sys.exit() def get_pcie_device(self): pciDict={} pciList=[] p1=\"^(\\w+):(\\w+)\\.(\\w)\\s(.*)\\s*\\(*.*\\)*\" p2=\"^.*:.*:.*:(\\w+)\\s*\\(*.*\\)*\" command1=\"sudo lspci\" command2=\"sudo lspci -n\" proc1=subprocess.Popen(command1, shell=True, universal_newlines=True, stdout=subprocess.PIPE) output1=proc1.stdout.readlines() proc1.communicate() proc2=subprocess.Popen(command2, shell=True, universal_newlines=True, stdout=subprocess.PIPE) output2=proc2.stdout.readlines() proc2.communicate() if proc1.returncode > 0: for line1 in output1: print(line1.strip()) return elif proc2.returncode > 0: for line2 in output2: print(line2.strip()) return else: for(line1, line2) in zip(output1, output2): pciDict.clear() match1=re.search(p1, line1.strip()) match2=re.search(p2, line2.strip()) if match1 and match2: Bus=match1.group(1) Dev=match1.group(2) Fn=match1.group(3) Name=match1.group(4) Id=match2.group(1) pciDict[\"name\"]=Name pciDict[\"bus\"]=Bus pciDict[\"dev\"]=Dev pciDict[\"fn\"]=Fn pciDict[\"id\"]=Id pciList.append(pciDict) pciDict=deepcopy(pciDict) else: print(\"CAN NOT MATCH PCIe DEVICE\") return pciList def check_pcie_sysfs(self, domain=0, bus=0, device=0, func=0): dev_path=os.path.join('/sys/bus/pci/devices', '%04x:%02x:%02x.%d' %(domain, bus, device, func)) if os.path.exists(dev_path): return True return False def get_pcie_check(self): self.load_config_file() for item_conf in self.confInfo: bus_conf=item_conf[\"bus\"] dev_conf=item_conf[\"dev\"] fn_conf=item_conf[\"fn\"] if self.check_pcie_sysfs(bus=int(bus_conf, base=16), device=int(dev_conf, base=16), func=int(fn_conf, base=16)): item_conf[\"result\"]=\"Passed\" else: item_conf[\"result\"]=\"Failed\" return self.confInfo def dump_conf_yaml(self): curInfo=self.get_pcie_device() with open(self.config_path +\"/\" +\"pcie.yaml\", \"w\") as conf_file: yaml.dump(curInfo, conf_file, default_flow_style=False) return ", "sourceWithComments": "# pcie_common.py\n# Common PCIE check interfaces for SONIC\n#\n\nimport os\nimport yaml\nimport subprocess\nimport re\nimport sys\nfrom copy import deepcopy\ntry:\n    from .pcie import PcieBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass PcieUtil(PcieBase):\n    \"\"\"Platform-specific PCIEutil class\"\"\"\n    # got the config file path\n    def __init__(self, path):\n        self.config_path = path\n\n    # load the config file\n    def load_config_file(self):\n        config_file = self.config_path + \"/\" + \"pcie.yaml\"\n        try:\n            with open(config_file) as conf_file:\n                self.confInfo = yaml.load(conf_file)\n        except IOError as e:\n            print(\"Error: {}\".format(str(e)))\n            print(\"Not found config file, please add a config file manually, or generate it by running [pcieutil pcie_generate]\")\n            sys.exit()\n\n    # load current PCIe device\n    def get_pcie_device(self):\n        pciDict = {}\n        pciList = []\n        p1 = \"^(\\w+):(\\w+)\\.(\\w)\\s(.*)\\s*\\(*.*\\)*\"\n        p2 = \"^.*:.*:.*:(\\w+)\\s*\\(*.*\\)*\"\n        command1 = \"sudo lspci\"\n        command2 = \"sudo lspci -n\"\n        # run command 1\n        proc1 = subprocess.Popen(command1, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n        output1 = proc1.stdout.readlines()\n        proc1.communicate()\n        # run command 2\n        proc2 = subprocess.Popen(command2, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n        output2 = proc2.stdout.readlines()\n        proc2.communicate()\n\n        if proc1.returncode > 0:\n            for line1 in output1:\n                print(line1.strip())\n            return\n        elif proc2.returncode > 0:\n            for line2 in output2:\n                print(line2.strip())\n            return\n        else:\n            for (line1, line2) in zip(output1, output2):\n                pciDict.clear()\n                match1 = re.search(p1, line1.strip())\n                match2 = re.search(p2, line2.strip())\n                if match1 and match2:\n                    Bus = match1.group(1)\n                    Dev = match1.group(2)\n                    Fn = match1.group(3)\n                    Name = match1.group(4)\n                    Id = match2.group(1)\n                    pciDict[\"name\"] = Name\n                    pciDict[\"bus\"] = Bus\n                    pciDict[\"dev\"] = Dev\n                    pciDict[\"fn\"] = Fn\n                    pciDict[\"id\"] = Id\n                    pciList.append(pciDict)\n                    pciDict = deepcopy(pciDict)\n                else:\n                    print(\"CAN NOT MATCH PCIe DEVICE\")\n        return pciList\n\n    # check the sysfs tree for each PCIe device\n    def check_pcie_sysfs(self, domain=0, bus=0, device=0, func=0):\n        dev_path = os.path.join('/sys/bus/pci/devices', '%04x:%02x:%02x.%d' % (domain, bus, device, func))\n        if os.path.exists(dev_path):\n            return True\n        return False\n\n    # check the current PCIe device with config file and return the result\n    def get_pcie_check(self):\n        self.load_config_file()\n        for item_conf in self.confInfo:\n            bus_conf = item_conf[\"bus\"]\n            dev_conf = item_conf[\"dev\"]\n            fn_conf = item_conf[\"fn\"]\n            if self.check_pcie_sysfs(bus=int(bus_conf, base=16), device=int(dev_conf, base=16), func=int(fn_conf, base=16)):\n                item_conf[\"result\"] = \"Passed\"\n            else:\n                item_conf[\"result\"] = \"Failed\"\n        return self.confInfo\n\n    # generate the config file with current pci device\n    def dump_conf_yaml(self):\n        curInfo = self.get_pcie_device()\n        with open(self.config_path + \"/\" + \"pcie.yaml\", \"w\") as conf_file:\n            yaml.dump(curInfo, conf_file, default_flow_style=False)\n        return\n\n"}, "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py": {"changes": [{"diff": "\n \n try:\n     import time\n-    import subprocess\n     from sonic_platform_base.chassis_base import ChassisBase\n     from sonic_platform.common import Common\n     from sonic_platform.sfp import Sfp\n     from sonic_platform.sfp import PORT_START\n     from sonic_platform.sfp import PORTS_IN_BLOCK\n     from sonic_platform.logger import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py", "badparts": ["    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         self.SFP_STATUS_INSERTED = \"1\"\n         self.SFP_STATUS_REMOVED = \"0\"\n         self.port_dict = {}\n-        self.enable_read= \"i2cset -f -y 2 0x35 0x2a 0x01\"\n-        self.disable_read = \"i2cset -f -y 2 0x35 0x2a 0x00\"\n-        self.enable_write = \"i2cset -f -y 2 0x35 0x2b 0x00\"\n-        self.disable_write = \"i2cset -f -y 2 0x35 0x2b 0x01\"\n-        self.enable_erase = \"i2cset -f -y 2 0x35 0x2c 0x01\"\n-        self.disable_erase = \"i2cset -f -y 2 0x35 0x2c 0x00\"\n-        self.read_value = \"i2cget -f -y 2 0x35 0x25\"\n-        self.write_value = \"i2cset -f -y 2 0x35 0x21 0x0a\"\n-        self.set_sys_led_cmd = \"i2cset -f -y 2 0x33 0xb2 \"\n-        self.get_sys_led_cmd = \"i2cget -f -y 2 0x33 0xb2\"\n-        self.led_status = \"red\"\n+        self.enable_read= [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x01\"]\n+        self.disable_read = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x00\"]\n+        self.enable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x00\"]\n+        self.disable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x01\"]\n+        self.enable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x01\"]\n+        self.disable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x00\"]\n+        self.read_value = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x25\"]\n+        self.write_value = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x21\", \"0x0a\"]\n+        self.set_sys_led_cmd = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]\n+        self.get_sys_led_cmd = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]\n+        self.led_status = \"red\" \n         # Initialize SFP list\n         # sfp.py will read eeprom contents and retrive the eeprom data.\n         # It will also provide support sfp controls like reset and setting\n", "add": 11, "remove": 11, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py", "badparts": ["        self.enable_read= \"i2cset -f -y 2 0x35 0x2a 0x01\"", "        self.disable_read = \"i2cset -f -y 2 0x35 0x2a 0x00\"", "        self.enable_write = \"i2cset -f -y 2 0x35 0x2b 0x00\"", "        self.disable_write = \"i2cset -f -y 2 0x35 0x2b 0x01\"", "        self.enable_erase = \"i2cset -f -y 2 0x35 0x2c 0x01\"", "        self.disable_erase = \"i2cset -f -y 2 0x35 0x2c 0x00\"", "        self.read_value = \"i2cget -f -y 2 0x35 0x25\"", "        self.write_value = \"i2cset -f -y 2 0x35 0x21 0x0a\"", "        self.set_sys_led_cmd = \"i2cset -f -y 2 0x33 0xb2 \"", "        self.get_sys_led_cmd = \"i2cget -f -y 2 0x33 0xb2\"", "        self.led_status = \"red\""], "goodparts": ["        self.enable_read= [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x01\"]", "        self.disable_read = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x00\"]", "        self.enable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x00\"]", "        self.disable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x01\"]", "        self.enable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x01\"]", "        self.disable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x00\"]", "        self.read_value = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x25\"]", "        self.write_value = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x21\", \"0x0a\"]", "        self.set_sys_led_cmd = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]", "        self.get_sys_led_cmd = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]", "        self.led_status = \"red\" "]}, {"diff": "\n         try:\n             is_power_loss = False\n             # enable read\n-            subprocess.getstatusoutput(self.disable_write)\n-            subprocess.getstatusoutput(self.enable_read)\n-            ret , log = subprocess.getstatusoutput(self.read_value)\n+            getstatusoutput_noshell(self.disable_write)\n+            getstatusoutput_noshell(self.enable_read)\n+            ret , log = getstatusoutput_noshell(self.read_value)\n             if ret == 0 and \"0x0a\" in log:\n                 is_power_loss = True\n \n             # erase i2c and e2\n-            subprocess.getstatusoutput(self.enable_erase)\n+            getstatusoutput_noshell(self.enable_erase)\n             time.sleep(1)\n-            subprocess.getstatusoutput(self.disable_erase)\n+            getstatusoutput_noshell(self.disable_erase)\n             # clear data\n-            subprocess.getstatusoutput(self.enable_write)\n-            subprocess.getstatusoutput(self.disable_read)\n-            subprocess.getstatusoutput(self.disable_write)\n-            subprocess.getstatusoutput(self.enable_read)\n+            getstatusoutput_noshell(self.enable_write)\n+            getstatusoutput_noshell(self.disable_read)\n+            getstatusoutput_noshell(self.disable_write)\n+            getstatusoutput_noshell(self.enable_read)\n             # enable write and set data\n-            subprocess.getstatusoutput(self.enable_write)\n-            subprocess.getstatusoutput(self.disable_read)\n-            subprocess.getstatusoutput(self.write_value)\n+            getstatusoutput_noshell(self.enable_write)\n+            getstatusoutput_noshell(self.disable_read)\n+            getstatusoutput_noshell(self.write_value)\n             if is_power_loss:\n                 return(self.REBOOT_CAUSE_POWER_LOSS, None)\n         except Exception as e:\n", "add": 12, "remove": 12, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py", "badparts": ["            subprocess.getstatusoutput(self.disable_write)", "            subprocess.getstatusoutput(self.enable_read)", "            ret , log = subprocess.getstatusoutput(self.read_value)", "            subprocess.getstatusoutput(self.enable_erase)", "            subprocess.getstatusoutput(self.disable_erase)", "            subprocess.getstatusoutput(self.enable_write)", "            subprocess.getstatusoutput(self.disable_read)", "            subprocess.getstatusoutput(self.disable_write)", "            subprocess.getstatusoutput(self.enable_read)", "            subprocess.getstatusoutput(self.enable_write)", "            subprocess.getstatusoutput(self.disable_read)", "            subprocess.getstatusoutput(self.write_value)"], "goodparts": ["            getstatusoutput_noshell(self.disable_write)", "            getstatusoutput_noshell(self.enable_read)", "            ret , log = getstatusoutput_noshell(self.read_value)", "            getstatusoutput_noshell(self.enable_erase)", "            getstatusoutput_noshell(self.disable_erase)", "            getstatusoutput_noshell(self.enable_write)", "            getstatusoutput_noshell(self.disable_read)", "            getstatusoutput_noshell(self.disable_write)", "            getstatusoutput_noshell(self.enable_read)", "            getstatusoutput_noshell(self.enable_write)", "            getstatusoutput_noshell(self.disable_read)", "            getstatusoutput_noshell(self.write_value)"]}, {"diff": "\n         if regval is None:\n             print(\"Invaild color input.\")\n             return False\n-        ret , log = subprocess.getstatusoutput(self.set_sys_led_cmd + regval)\n+        cmd = self.set_sys_led_cmd + [regval]\n+        ret, log = getstatusoutput_noshell(cmd)\n         if ret != 0:\n             print(\"Cannot execute %s\" % self.set_sys_led_cmd + regval)\n             return False\n", "add": 2, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py", "badparts": ["        ret , log = subprocess.getstatusoutput(self.set_sys_led_cmd + regval)"], "goodparts": ["        cmd = self.set_sys_led_cmd + [regval]", "        ret, log = getstatusoutput_noshell(cmd)"]}, {"diff": "\n             A string, one of the valid LED color strings which could be vendor\n             specified.\n         \"\"\"\n-        ret , log = subprocess.getstatusoutput(self.get_sys_led_cmd)\n+        ret , log = getstatusoutput_noshell(self.get_sys_led_cmd)\n         if ret != 0:\n             print(\"Cannot execute %s\" % self.get_sys_led_cmd)\n             return Fals", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py", "badparts": ["        ret , log = subprocess.getstatusoutput(self.get_sys_led_cmd)"], "goodparts": ["        ret , log = getstatusoutput_noshell(self.get_sys_led_cmd)"]}], "source": "\n try: import time import subprocess from sonic_platform_base.chassis_base import ChassisBase from sonic_platform.common import Common from sonic_platform.sfp import Sfp from sonic_platform.sfp import PORT_START from sonic_platform.sfp import PORTS_IN_BLOCK from sonic_platform.logger import logger except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class Chassis(ChassisBase): \"\"\" Ruijie B6510-48VS8CQ Platform-specific Chassis class \"\"\" def __init__(self): ChassisBase.__init__(self) self.CHASSIS_CONFIG='chassis.json' self.THERMAL_CONFIG='thermal.json' self.SFP_CONFIG='sfp.json' self.PSU_CONFIG='psu.json' self.FAN_CONFIG='fan.json' self.COMPONENT_CONFIG='component.json' self.SFP_STATUS_INSERTED=\"1\" self.SFP_STATUS_REMOVED=\"0\" self.port_dict={} self.enable_read=\"i2cset -f -y 2 0x35 0x2a 0x01\" self.disable_read=\"i2cset -f -y 2 0x35 0x2a 0x00\" self.enable_write=\"i2cset -f -y 2 0x35 0x2b 0x00\" self.disable_write=\"i2cset -f -y 2 0x35 0x2b 0x01\" self.enable_erase=\"i2cset -f -y 2 0x35 0x2c 0x01\" self.disable_erase=\"i2cset -f -y 2 0x35 0x2c 0x00\" self.read_value=\"i2cget -f -y 2 0x35 0x25\" self.write_value=\"i2cset -f -y 2 0x35 0x21 0x0a\" self.set_sys_led_cmd=\"i2cset -f -y 2 0x33 0xb2 \" self.get_sys_led_cmd=\"i2cget -f -y 2 0x33 0xb2\" self.led_status=\"red\" for index in range(PORT_START, PORTS_IN_BLOCK): sfp_node=Sfp(index) self._sfp_list.append(sfp_node) if sfp_node.get_presence(): self.port_dict[index]=self.SFP_STATUS_INSERTED else: self.port_dict[index]=self.SFP_STATUS_REMOVED self._api_common=Common() config_path=self._api_common.get_config_path(self.CHASSIS_CONFIG) self._config=self._api_common.load_json_file(config_path) self.__initialize_eeprom() if self._api_common.is_host(): self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() else: self.__initialize_components() def __initialize_fan(self): from sonic_platform.fan import Fan from sonic_platform.fan_drawer import FanDrawer fan_config_path=self._api_common.get_config_path(self.FAN_CONFIG) self.fan_config=self._api_common.load_json_file(fan_config_path)[\"fans\"] if self.fan_config: drawer_fan_list=[] for index in range(0, len(self.fan_config)): fan=Fan(index, config=self.fan_config[index]) self._fan_list.append(fan) drawer_fan_list.append(fan) fan_drawer=FanDrawer(0, fan_list=drawer_fan_list) self._fan_drawer_list.append(fan_drawer) def __initialize_psu(self): from sonic_platform.psu import Psu psu_config_path=self._api_common.get_config_path(self.PSU_CONFIG) self.psu_config=self._api_common.load_json_file(psu_config_path)[\"psus\"] if self.psu_config: for index in range(0, len(self.psu_config)): psu=Psu(index, config=self.psu_config[index]) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal thermal_config_path=self._api_common.get_config_path(self.THERMAL_CONFIG) self.thermal_config=self._api_common.load_json_file(thermal_config_path)['thermals'] if self.thermal_config: for index in range(0, len(self.thermal_config)): thermal=Thermal(index, config=self.thermal_config[index]) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Eeprom self._eeprom=Eeprom(config=self._config[\"eeprom\"]) def __initialize_components(self): from sonic_platform.component import Component component_config_path=self._api_common.get_config_path(self.COMPONENT_CONFIG) self.component_config=self._api_common.load_json_file(component_config_path)['components'] if self.component_config: for index in range(0, len(self.component_config)): component=Component(index, config=self.component_config[index]) self._component_list.append(component) def _init_standard_config(self, conflist, class_name, objlist): for conf in conflist: obj=globals()[class_name](conf.get(\"name\"), config=conf) objlist.append(obj) def _init_by_hal(self, hal_interface): self.hal_interface=hal_interface self.hal_interface.get_fans() def get_name(self): \"\"\" Retrieves the name of the chassis Returns: string: The name of the chassis \"\"\" return self._eeprom.modelstr() def get_presence(self): \"\"\" Retrieves the presence of the chassis Returns: bool: True if chassis is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the chassis Returns: string: Model/part number of chassis \"\"\" return self._eeprom.part_number_str() def get_serial(self): \"\"\" Retrieves the serial number of the chassis(Service tag) Returns: string: Serial number of chassis \"\"\" return self._eeprom.serial_str() def get_status(self): \"\"\" Retrieves the operational status of the chassis Returns: bool: A boolean value, True if chassis is operating properly False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.base_mac_addr() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.system_eeprom_info() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" try: is_power_loss=False subprocess.getstatusoutput(self.disable_write) subprocess.getstatusoutput(self.enable_read) ret, log=subprocess.getstatusoutput(self.read_value) if ret==0 and \"0x0a\" in log: is_power_loss=True subprocess.getstatusoutput(self.enable_erase) time.sleep(1) subprocess.getstatusoutput(self.disable_erase) subprocess.getstatusoutput(self.enable_write) subprocess.getstatusoutput(self.disable_read) subprocess.getstatusoutput(self.disable_write) subprocess.getstatusoutput(self.enable_read) subprocess.getstatusoutput(self.enable_write) subprocess.getstatusoutput(self.disable_read) subprocess.getstatusoutput(self.write_value) if is_power_loss: return(self.REBOOT_CAUSE_POWER_LOSS, None) except Exception as e: logger.error(str(e)) return(self.REBOOT_CAUSE_NON_HARDWARE, None) def get_change_event(self, timeout=0): \"\"\" Returns a nested dictionary containing all devices which have experienced a change at chassis level Args: timeout: Timeout in milliseconds(optional). If timeout==0, this method will block until a change is detected. Returns: (bool, dict): -True if call successful, False if not; -A nested dictionary where key is a device type, value is a dictionary with key:value pairs in the format of {'device_id':'device_event'}, where device_id is the device ID for this device and device_event, status='1' represents device inserted, status='0' represents device removed. Ex.{'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}} indicates that fan 0 has been removed, fan 2 has been inserted and sfp 11 has been removed. Specifically for SFP event, besides SFP plug in and plug out, there are some other error event could be raised from SFP, when these error happened, SFP eeprom will not be avalaible, XCVRD shall stop to read eeprom before SFP recovered from error status. status='2' I2C bus stuck, status='3' Bad eeprom, status='4' Unsupported cable, status='5' High Temperature, status='6' Bad cable. \"\"\" change_event_dict={\"fan\":{}, \"sfp\":{}} sfp_status, sfp_change_dict=self.get_transceiver_change_event(timeout) change_event_dict[\"sfp\"]=sfp_change_dict if sfp_status is True: return True, change_event_dict return False,{} def get_transceiver_change_event(self, timeout=0): start_time=time.time() currernt_port_dict={} forever=False if timeout==0: forever=True elif timeout > 0: timeout=timeout / float(1000) else: print(\"get_transceiver_change_event:Invalid timeout value\", timeout) return False,{} end_time=start_time +timeout if start_time > end_time: print( \"get_transceiver_change_event:\" \"time wrap / invalid timeout value\", timeout, ) return False,{} while timeout >=0: for index in range(PORT_START, PORTS_IN_BLOCK): if self._sfp_list[index].get_presence(): currernt_port_dict[index]=self.SFP_STATUS_INSERTED else: currernt_port_dict[index]=self.SFP_STATUS_REMOVED if currernt_port_dict==self.port_dict: if forever: time.sleep(1) else: timeout=end_time -time.time() if timeout >=1: time.sleep(1) else: if timeout > 0: time.sleep(timeout) return True,{} else: self.port_dict=currernt_port_dict print(self.port_dict) return True, self.port_dict print(\"get_transceiver_change_event: Should not reach here.\") return False,{} def get_all_components(self): return self._component_list def get_all_fans(self): return self._fan_list def get_all_psus(self): return self._psu_list def get_all_thermals(self): return self._thermal_list def get_supervisor_slot(self): \"\"\" Retrieves the physical-slot of the supervisor-module in the modular chassis. On the supervisor or line-card modules, it will return the physical-slot of the supervisor-module. On the fixed-platforms, the API can be ignored. Users of the API can catch the exception and return a default ModuleBase.MODULE_INVALID_SLOT and bypass code for fixed-platforms. Returns: An integer, the vendor specific physical slot identifier of the supervisor module in the modular-chassis. \"\"\" return 0 def get_my_slot(self): \"\"\" Retrieves the physical-slot of this module in the modular chassis. On the supervisor, it will return the physical-slot of the supervisor module. On the linecard, it will return the physical-slot of the linecard module where this instance of SONiC is running. On the fixed-platforms, the API can be ignored. Users of the API can catch the exception and return a default ModuleBase.MODULE_INVALID_SLOT and bypass code for fixed-platforms. Returns: An integer, the vendor specific physical slot identifier of this module in the modular-chassis. \"\"\" return 0 def is_modular_chassis(self): \"\"\" Retrieves whether the sonic instance is part of modular chassis Returns: A bool value, should return False by default or for fixed-platforms. Should return True for supervisor-cards, line-cards etc running as part of modular-chassis. \"\"\" return True def init_midplane_switch(self): \"\"\" Initializes the midplane functionality of the modular chassis. For example, any validation of midplane, populating any lookup tables etc can be done here. The expectation is that the required kernel modules, ip-address assignment etc are done before the pmon, database dockers are up. Returns: A bool value, should return True if the midplane initialized successfully. \"\"\" return True def get_module_index(self, module_name): \"\"\" Retrieves module index from the module name Args: module_name: A string, prefixed by SUPERVISOR, LINE-CARD or FABRIC-CARD Ex. SUPERVISOR0, LINE-CARD1, FABRIC-CARD5 Returns: An integer, the index of the ModuleBase object in the module_list \"\"\" return 0 def set_status_led(self, color): \"\"\" Sets the state of the system LED Args: color: A string representing the color with which to set the system LED Returns: bool: True if system LED state is set successfully, False if not \"\"\" colors={ \"amber\": \"0x00\", \"red\": \"0x02\", \"green\": \"0x04\" } regval=colors.get(color, None) if regval is None: print(\"Invaild color input.\") return False ret, log=subprocess.getstatusoutput(self.set_sys_led_cmd +regval) if ret !=0: print(\"Cannot execute %s\" % self.set_sys_led_cmd +regval) return False self.led_status=color return True def get_status_led(self): \"\"\" Gets the state of the system LED Returns: A string, one of the valid LED color strings which could be vendor specified. \"\"\" ret, log=subprocess.getstatusoutput(self.get_sys_led_cmd) if ret !=0: print(\"Cannot execute %s\" % self.get_sys_led_cmd) return False colors={ \"0x00\": \"amber\", \"0x02\": \"red\", \"0x04\": \"green\" } color=colors.get(log, None) if color is None: return \"Unknown color status\" self.led_status=color return self.led_status ", "sourceWithComments": "# -*- coding: utf-8 -*-\n\n#############################################################################\n# Ruijie B6510-48VS8CQ\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the platform information\n#\n#############################################################################\n\ntry:\n    import time\n    import subprocess\n    from sonic_platform_base.chassis_base import ChassisBase\n    from sonic_platform.common import Common\n    from sonic_platform.sfp import Sfp\n    from sonic_platform.sfp import PORT_START\n    from sonic_platform.sfp import PORTS_IN_BLOCK\n    from sonic_platform.logger import logger\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nclass Chassis(ChassisBase):\n    \"\"\"\n    Ruijie B6510-48VS8CQ Platform-specific Chassis class\n    \"\"\"\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self.CHASSIS_CONFIG = 'chassis.json'\n        self.THERMAL_CONFIG = 'thermal.json'\n        self.SFP_CONFIG = 'sfp.json'\n        self.PSU_CONFIG = 'psu.json'\n        self.FAN_CONFIG = 'fan.json'\n        self.COMPONENT_CONFIG = 'component.json'\n\n        self.SFP_STATUS_INSERTED = \"1\"\n        self.SFP_STATUS_REMOVED = \"0\"\n        self.port_dict = {}\n        self.enable_read= \"i2cset -f -y 2 0x35 0x2a 0x01\"\n        self.disable_read = \"i2cset -f -y 2 0x35 0x2a 0x00\"\n        self.enable_write = \"i2cset -f -y 2 0x35 0x2b 0x00\"\n        self.disable_write = \"i2cset -f -y 2 0x35 0x2b 0x01\"\n        self.enable_erase = \"i2cset -f -y 2 0x35 0x2c 0x01\"\n        self.disable_erase = \"i2cset -f -y 2 0x35 0x2c 0x00\"\n        self.read_value = \"i2cget -f -y 2 0x35 0x25\"\n        self.write_value = \"i2cset -f -y 2 0x35 0x21 0x0a\"\n        self.set_sys_led_cmd = \"i2cset -f -y 2 0x33 0xb2 \"\n        self.get_sys_led_cmd = \"i2cget -f -y 2 0x33 0xb2\"\n        self.led_status = \"red\"\n        # Initialize SFP list\n        # sfp.py will read eeprom contents and retrive the eeprom data.\n        # It will also provide support sfp controls like reset and setting\n        # low power mode.\n        # We pass the eeprom path and sfp control path from chassis.py\n        # So that sfp.py implementation can be generic to all platforms\n        for index in range(PORT_START, PORTS_IN_BLOCK):\n            sfp_node = Sfp(index)\n            self._sfp_list.append(sfp_node)\n            if sfp_node.get_presence():\n                self.port_dict[index] = self.SFP_STATUS_INSERTED\n            else:\n                self.port_dict[index] = self.SFP_STATUS_REMOVED\n\n        self._api_common = Common()\n        config_path = self._api_common.get_config_path(self.CHASSIS_CONFIG)\n        self._config = self._api_common.load_json_file(config_path)\n        self.__initialize_eeprom()\n\n        if self._api_common.is_host():\n            self.__initialize_fan()\n            self.__initialize_psu()\n            self.__initialize_thermals()\n        else:\n            self.__initialize_components()\n\n    def __initialize_fan(self):\n        from sonic_platform.fan import Fan\n        from sonic_platform.fan_drawer import FanDrawer\n\n        fan_config_path = self._api_common.get_config_path(self.FAN_CONFIG)\n        self.fan_config = self._api_common.load_json_file(fan_config_path)[\"fans\"]\n\n        if self.fan_config:\n            drawer_fan_list = []\n            for index in range(0, len(self.fan_config)):\n                fan = Fan(index, config=self.fan_config[index])\n                self._fan_list.append(fan)\n                drawer_fan_list.append(fan)\n            fan_drawer = FanDrawer(0, fan_list=drawer_fan_list)\n            self._fan_drawer_list.append(fan_drawer)\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n\n        psu_config_path = self._api_common.get_config_path(self.PSU_CONFIG)\n        self.psu_config = self._api_common.load_json_file(psu_config_path)[\"psus\"]\n\n        if self.psu_config:\n            for index in range(0, len(self.psu_config)):\n                psu = Psu(index, config=self.psu_config[index])\n                self._psu_list.append(psu)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n\n        thermal_config_path = self._api_common.get_config_path(self.THERMAL_CONFIG)\n        self.thermal_config = self._api_common.load_json_file(thermal_config_path)['thermals']\n\n        if self.thermal_config:\n            for index in range(0, len(self.thermal_config)):\n                thermal = Thermal(index, config=self.thermal_config[index])\n                self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Eeprom\n        self._eeprom = Eeprom(config=self._config[\"eeprom\"])\n\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n\n        component_config_path = self._api_common.get_config_path(self.COMPONENT_CONFIG)\n        self.component_config = self._api_common.load_json_file(component_config_path)['components']\n\n        if self.component_config:\n            for index in range(0, len(self.component_config)):\n                component = Component(index, config=self.component_config[index])\n                self._component_list.append(component)\n\n    def _init_standard_config(self, conflist, class_name, objlist):\n        for conf in conflist:\n            obj = globals()[class_name](conf.get(\"name\"), config=conf)\n            objlist.append(obj)\n\n    def _init_by_hal(self, hal_interface):\n        self.hal_interface = hal_interface\n        self.hal_interface.get_fans()\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the chassis\n        Returns:\n            string: The name of the chassis\n        \"\"\"\n        return self._eeprom.modelstr()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the chassis\n        Returns:\n            bool: True if chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the chassis\n        Returns:\n            string: Model/part number of chassis\n        \"\"\"\n        return self._eeprom.part_number_str()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the chassis (Service tag)\n        Returns:\n            string: Serial number of chassis\n        \"\"\"\n        return self._eeprom.serial_str()\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the chassis\n        Returns:\n            bool: A boolean value, True if chassis is operating properly\n            False if not\n        \"\"\"\n        return True\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.base_mac_addr()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.system_eeprom_info()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        try:\n            is_power_loss = False\n            # enable read\n            subprocess.getstatusoutput(self.disable_write)\n            subprocess.getstatusoutput(self.enable_read)\n            ret , log = subprocess.getstatusoutput(self.read_value)\n            if ret == 0 and \"0x0a\" in log:\n                is_power_loss = True\n\n            # erase i2c and e2\n            subprocess.getstatusoutput(self.enable_erase)\n            time.sleep(1)\n            subprocess.getstatusoutput(self.disable_erase)\n            # clear data\n            subprocess.getstatusoutput(self.enable_write)\n            subprocess.getstatusoutput(self.disable_read)\n            subprocess.getstatusoutput(self.disable_write)\n            subprocess.getstatusoutput(self.enable_read)\n            # enable write and set data\n            subprocess.getstatusoutput(self.enable_write)\n            subprocess.getstatusoutput(self.disable_read)\n            subprocess.getstatusoutput(self.write_value)\n            if is_power_loss:\n                return(self.REBOOT_CAUSE_POWER_LOSS, None)\n        except Exception as e:\n            logger.error(str(e))\n\n        return (self.REBOOT_CAUSE_NON_HARDWARE, None)\n\n    def get_change_event(self, timeout=0):\n        \"\"\"\n        Returns a nested dictionary containing all devices which have\n        experienced a change at chassis level\n\n        Args:\n            timeout: Timeout in milliseconds (optional). If timeout == 0,\n                this method will block until a change is detected.\n\n        Returns:\n            (bool, dict):\n                - True if call successful, False if not;\n                - A nested dictionary where key is a device type,\n                  value is a dictionary with key:value pairs in the format of\n                  {'device_id':'device_event'},\n                  where device_id is the device ID for this device and\n                        device_event,\n                             status='1' represents device inserted,\n                             status='0' represents device removed.\n                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}\n                      indicates that fan 0 has been removed, fan 2\n                      has been inserted and sfp 11 has been removed.\n                  Specifically for SFP event, besides SFP plug in and plug out,\n                  there are some other error event could be raised from SFP, when\n                  these error happened, SFP eeprom will not be avalaible, XCVRD shall\n                  stop to read eeprom before SFP recovered from error status.\n                      status='2' I2C bus stuck,\n                      status='3' Bad eeprom,\n                      status='4' Unsupported cable,\n                      status='5' High Temperature,\n                      status='6' Bad cable.\n        \"\"\"\n        change_event_dict = {\"fan\": {}, \"sfp\": {}}\n        sfp_status, sfp_change_dict = self.get_transceiver_change_event(timeout)\n        change_event_dict[\"sfp\"] = sfp_change_dict\n        if sfp_status is True:\n            return True, change_event_dict\n\n        return False, {}\n\n    def get_transceiver_change_event(self, timeout=0):\n\n        start_time = time.time()\n        currernt_port_dict = {}\n        forever = False\n\n        if timeout == 0:\n            forever = True\n        elif timeout > 0:\n            timeout = timeout / float(1000)  # Convert to secs\n        else:\n            print(\"get_transceiver_change_event:Invalid timeout value\", timeout)\n            return False, {}\n\n        end_time = start_time + timeout\n        if start_time > end_time:\n            print(\n                \"get_transceiver_change_event:\" \"time wrap / invalid timeout value\",\n                timeout,\n            )\n            return False, {}  # Time wrap or possibly incorrect timeout\n\n        while timeout >= 0:\n            # Check for OIR events and return updated port_dict\n            for index in range(PORT_START, PORTS_IN_BLOCK):\n                if self._sfp_list[index].get_presence():\n                    currernt_port_dict[index] = self.SFP_STATUS_INSERTED\n                else:\n                    currernt_port_dict[index] = self.SFP_STATUS_REMOVED\n            if currernt_port_dict == self.port_dict:\n                if forever:\n                    time.sleep(1)\n                else:\n                    timeout = end_time - time.time()\n                    if timeout >= 1:\n                        time.sleep(1)  # We poll at 1 second granularity\n                    else:\n                        if timeout > 0:\n                            time.sleep(timeout)\n                        return True, {}\n            else:\n                # Update reg value\n                self.port_dict = currernt_port_dict\n                print(self.port_dict)\n                return True, self.port_dict\n        print(\"get_transceiver_change_event: Should not reach here.\")\n        return False, {}\n\n    def get_all_components(self):\n        return self._component_list\n\n    def get_all_fans(self):\n        return self._fan_list\n\n    def get_all_psus(self):\n        return self._psu_list\n\n    def get_all_thermals(self):\n        return self._thermal_list\n\n    def get_supervisor_slot(self):\n        \"\"\"\n        Retrieves the physical-slot of the supervisor-module in the modular\n        chassis. On the supervisor or line-card modules, it will return the\n        physical-slot of the supervisor-module.\n        On the fixed-platforms, the API can be ignored.\n        Users of the API can catch the exception and return a default\n        ModuleBase.MODULE_INVALID_SLOT and bypass code for fixed-platforms.\n        Returns:\n            An integer, the vendor specific physical slot identifier of the\n            supervisor module in the modular-chassis.\n        \"\"\"\n        return 0\n\n    def get_my_slot(self):\n        \"\"\"\n        Retrieves the physical-slot of this module in the modular chassis.\n        On the supervisor, it will return the physical-slot of the supervisor\n        module. On the linecard, it will return the physical-slot of the\n        linecard module where this instance of SONiC is running.\n        On the fixed-platforms, the API can be ignored.\n        Users of the API can catch the exception and return a default\n        ModuleBase.MODULE_INVALID_SLOT and bypass code for fixed-platforms.\n        Returns:\n            An integer, the vendor specific physical slot identifier of this\n            module in the modular-chassis.\n        \"\"\"\n        return 0\n\n    def is_modular_chassis(self):\n        \"\"\"\n        Retrieves whether the sonic instance is part of modular chassis\n        Returns:\n            A bool value, should return False by default or for fixed-platforms.\n            Should return True for supervisor-cards, line-cards etc running as part\n            of modular-chassis.\n        \"\"\"\n        return True\n\n    def init_midplane_switch(self):\n        \"\"\"\n        Initializes the midplane functionality of the modular chassis. For\n        example, any validation of midplane, populating any lookup tables etc\n        can be done here. The expectation is that the required kernel modules,\n        ip-address assignment etc are done before the pmon, database dockers\n        are up.\n        Returns:\n            A bool value, should return True if the midplane initialized\n            successfully.\n        \"\"\"\n        return True\n\n    def get_module_index(self, module_name):\n        \"\"\"\n        Retrieves module index from the module name\n        Args:\n            module_name: A string, prefixed by SUPERVISOR, LINE-CARD or FABRIC-CARD\n            Ex. SUPERVISOR0, LINE-CARD1, FABRIC-CARD5\n        Returns:\n            An integer, the index of the ModuleBase object in the module_list\n        \"\"\"\n        return 0\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the system LED\n        Args:\n            color: A string representing the color with which to set the\n                   system LED\n        Returns:\n            bool: True if system LED state is set successfully, False if not\n        \"\"\"\n        colors = {\n            \"amber\" : \"0x00\",\n            \"red\" : \"0x02\",\n            \"green\" : \"0x04\"\n        }\n        regval = colors.get(color, None)\n        if regval is None:\n            print(\"Invaild color input.\")\n            return False\n        ret , log = subprocess.getstatusoutput(self.set_sys_led_cmd + regval)\n        if ret != 0:\n            print(\"Cannot execute %s\" % self.set_sys_led_cmd + regval)\n            return False\n        self.led_status = color\n        return True\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the system LED\n        Returns:\n            A string, one of the valid LED color strings which could be vendor\n            specified.\n        \"\"\"\n        ret , log = subprocess.getstatusoutput(self.get_sys_led_cmd)\n        if ret != 0:\n            print(\"Cannot execute %s\" % self.get_sys_led_cmd)\n            return False\n        colors = {\n            \"0x00\" : \"amber\",\n            \"0x02\" : \"red\",\n            \"0x04\" : \"green\"\n        }\n        color = colors.get(log, None)\n        if color is None:\n            return \"Unknown color status\"\n        self.led_status = color\n        return self.led_status\n\n"}, "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py": {"changes": [{"diff": "\n     PMON_PLATFORM_PATH = '/usr/share/sonic/platform/'\n     CONFIG_DIR = 'sonic_platform_config'\n \n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def load_json_file(self, path):\n         \"", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"", "        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]", "        return subprocess.call(self.HOST_CHK_CMD) == 0"]}], "source": "\nimport os import yaml from sonic_py_common import device_info class Common: DEVICE_PATH='/usr/share/sonic/device/' PMON_PLATFORM_PATH='/usr/share/sonic/platform/' CONFIG_DIR='sonic_platform_config' HOST_CHK_CMD=\"docker > /dev/null 2>&1\" def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(self.HOST_CHK_CMD)==0 def load_json_file(self, path): \"\"\" Retrieves the json object from json file path Returns: A json object \"\"\" with open(path, 'r') as f: json_data=yaml.safe_load(f) return json_data def get_config_path(self, config_name): \"\"\" Retrieves the path to platform api config directory Args: config_name: A string containing the name of config file. Returns: A string containing the path to json file \"\"\" return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name) ", "sourceWithComments": "import os\nimport yaml\n\nfrom sonic_py_common import device_info\n\n\nclass Common:\n\n    DEVICE_PATH = '/usr/share/sonic/device/'\n    PMON_PLATFORM_PATH = '/usr/share/sonic/platform/'\n    CONFIG_DIR = 'sonic_platform_config'\n\n    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def load_json_file(self, path):\n        \"\"\"\n        Retrieves the json object from json file path\n\n        Returns:\n            A json object\n        \"\"\"\n        with open(path, 'r') as f:\n            json_data = yaml.safe_load(f)\n\n        return json_data\n\n    def get_config_path(self, config_name):\n        \"\"\"\n        Retrieves the path to platform api config directory\n\n        Args:\n            config_name: A string containing the name of config file.\n\n        Returns:\n            A string containing the path to json file\n        \"\"\"\n        return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\n\n"}, "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py": {"changes": [{"diff": "\n ########################################################################\n \n try:\n-    import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n     from sonic_platform.regutil import Reg\n     from sonic_platform.logger import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py", "badparts": ["    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         \"\"\"\n         try:\n             successtips = \"CPLD Upgrade succeeded!\"\n-            status, output = subprocess.getstatusoutput(\"which firmware_upgrade\")\n+            status, output = getstatusoutput_noshell([\"which\", \"firmware_upgrade\"])\n             if status or len(output) <= 0:\n                 logger.error(\"no upgrade tool.\")\n                 return False\n-            cmdstr = \"%s %s cpld %d cpld\"%(output,image_path,self.slot)\n-            ret, log = subprocess.getstatusoutput(cmdstr)\n+            cmdstr = [output, image_path, \"cpld\", self.slot, \"cpld\"]\n+            ret, log = getstatusoutput_noshell(cmdstr)\n             if ret == 0 and successtips in log:\n                 return True\n             logger.error(\"upgrade failed. ret:%d, log:\\n%s\" % (ret, lo", "add": 3, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py", "badparts": ["            status, output = subprocess.getstatusoutput(\"which firmware_upgrade\")", "            cmdstr = \"%s %s cpld %d cpld\"%(output,image_path,self.slot)", "            ret, log = subprocess.getstatusoutput(cmdstr)"], "goodparts": ["            status, output = getstatusoutput_noshell([\"which\", \"firmware_upgrade\"])", "            cmdstr = [output, image_path, \"cpld\", self.slot, \"cpld\"]", "            ret, log = getstatusoutput_noshell(cmdstr)"]}], "source": "\n try: import subprocess from sonic_platform_base.component_base import ComponentBase from sonic_platform.regutil import Reg from sonic_platform.logger import logger except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class Component(ComponentBase): \"\"\"Ruijie Platform-specific Component class\"\"\" def __init__(self, index, config=None): self.index=index self.name=config.get(\"name\") self._reg_fm_ver=Reg(config.get(\"firmware_version\")) self.description=config.get(\"desc\") self.slot=config.get(\"slot\") def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return self.name def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return self.description def get_firmware_version(self): \"\"\" Retrieves the firmware version of the component Returns: A string containing the firmware version of the component \"\"\" try: return self._reg_fm_ver.decode() except Exception as e: logger.error(str(e)) return \"\" def install_firmware(self, image_path): \"\"\" Installs firmware to the component Args: image_path: A string, path to firmware image Returns: A boolean, True if install was successful, False if not \"\"\" try: successtips=\"CPLD Upgrade succeeded!\" status, output=subprocess.getstatusoutput(\"which firmware_upgrade\") if status or len(output) <=0: logger.error(\"no upgrade tool.\") return False cmdstr=\"%s %s cpld %d cpld\"%(output,image_path,self.slot) ret, log=subprocess.getstatusoutput(cmdstr) if ret==0 and successtips in log: return True logger.error(\"upgrade failed. ret:%d, log:\\n%s\" %(ret, log)) except Exception as e: logger.error(str(e)) return False ", "sourceWithComments": "########################################################################\n# Ruijie B6510-48VS8CQ\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Components' (e.g., BIOS, CPLD, FPGA, etc.) available in\n# the platform\n#\n########################################################################\n\ntry:\n    import subprocess\n    from sonic_platform_base.component_base import ComponentBase\n    from sonic_platform.regutil import Reg\n    from sonic_platform.logger import logger\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass Component(ComponentBase):\n    \"\"\"Ruijie Platform-specific Component class\"\"\"\n\n    def __init__(self, index, config=None):\n        self.index = index\n        self.name = config.get(\"name\")\n        self._reg_fm_ver = Reg(config.get(\"firmware_version\"))\n        self.description = config.get(\"desc\")\n        self.slot = config.get(\"slot\")\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n\n        Returns:\n            A string containing the name of the component\n        \"\"\"\n        return self.name\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n\n        Returns:\n            A string containing the description of the component\n        \"\"\"\n        return self.description\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of the component\n\n        Returns:\n            A string containing the firmware version of the component\n        \"\"\"\n        try:\n            return self._reg_fm_ver.decode()\n        except Exception as e:\n            logger.error(str(e))\n\n        return \"\"\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Installs firmware to the component\n\n        Args:\n            image_path: A string, path to firmware image\n\n        Returns:\n            A boolean, True if install was successful, False if not\n        \"\"\"\n        try:\n            successtips = \"CPLD Upgrade succeeded!\"\n            status, output = subprocess.getstatusoutput(\"which firmware_upgrade\")\n            if status or len(output) <= 0:\n                logger.error(\"no upgrade tool.\")\n                return False\n            cmdstr = \"%s %s cpld %d cpld\"%(output,image_path,self.slot)\n            ret, log = subprocess.getstatusoutput(cmdstr)\n            if ret == 0 and successtips in log:\n                return True\n            logger.error(\"upgrade failed. ret:%d, log:\\n%s\" % (ret, log))\n        except Exception as e:\n            logger.error(str(e))\n        return False\n        \n"}, "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py": {"changes": [{"diff": "\n #\n #######################################################\n \n-import subprocess\n import time\n import glob\n import re\n", "add": 0, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["import subprocess"], "goodparts": []}, {"diff": "\n \n     @staticmethod\n     def command(cmdstr):\n-        retcode, output = subprocess.getstatusoutput(cmdstr)\n+        retcode, output = getstatusoutput_noshell(cmdstr)\n         return retcode, output\n \n \n     @staticmethod\n     def geti2cword_i2ctool(bus, addr, offset):\n-        command_line = \"i2cget -f -y %d 0x%02x 0x%02x  wp\" % (bus, addr, offset)\n+        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%02x\"%offset, \"wp\"]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        retcode, output = subprocess.getstatusoutput(cmdstr)", "        command_line = \"i2cget -f -y %d 0x%02x 0x%02x  wp\" % (bus, addr, offset)"], "goodparts": ["        retcode, output = getstatusoutput_noshell(cmdstr)", "        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%02x\"%offset, \"wp\"]"]}, {"diff": "\n \n     @staticmethod\n     def seti2cword_i2ctool(bus, addr, offset, val):\n-        command_line = \"i2cset -f -y %d 0x%02x 0x%0x 0x%04x wp\" % (bus, addr, offset, val)\n+        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%0x\"%offset, \"0x%04x\"%val, \"wp\"]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        command_line = \"i2cset -f -y %d 0x%02x 0x%0x 0x%04x wp\" % (bus, addr, offset, val)"], "goodparts": ["        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%0x\"%offset, \"0x%04x\"%val, \"wp\"]"]}, {"diff": "\n \n     @staticmethod\n     def rji2cget_i2ctool(bus, devno, address):\n-        command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)\n+        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)"], "goodparts": ["        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address]"]}, {"diff": "\n \n     @staticmethod\n     def rji2cset_i2ctool(bus, devno, address, byte):\n-        command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (\n-            bus, devno, address, byte)\n+        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address, \"0x%02x\"%byte]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n", "add": 1, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (", "            bus, devno, address, byte)"], "goodparts": ["        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address, \"0x%02x\"%byte]"]}, {"diff": "\n \n     @staticmethod\n     def getdevmem(addr, digit, mask):\n-        command_line = \"devmem 0x%02x %d\" %(addr, digit)\n+        command_line = [\"devmem\", \"0x%02x\"%addr, str(digit)]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        command_line = \"devmem 0x%02x %d\" %(addr, digit)"], "goodparts": ["        command_line = [\"devmem\", \"0x%02x\"%addr, str(digit)]"]}, {"diff": "\n \n     @staticmethod\n     def rj_os_system(cmd):\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         return status, output\n \n     @staticmethod\n     def getsdkreg(reg):\n         try:\n-            cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg\n+            cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]\n             ret, result = osutil.rj_os_system(cmd)\n             result_t = result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n             if ret != 0 or \"Error:\" in result_t:\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        status, output = subprocess.getstatusoutput(cmd)", "            cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg"], "goodparts": ["        status, output = getstatusoutput_noshell(cmd)", "            cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]"]}, {"diff": "\n             result = {}\n             #waitForDocker()\n             #need to exec twice\n-            osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n-            ret, log = osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n+            osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n+            ret, log = osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n             if ret:\n                 return False, result\n             e", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["            osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")", "            ret, log = osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")"], "goodparts": ["            osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])", "            ret, log = osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])"]}], "source": "\n import subprocess import time import glob import re from rjutil.smbus import SMBus import time from functools import wraps def retry(maxretry=6, delay=0.01): ''' maxretry: max retry times delay : interval after last retry ''' def decorator(f): @wraps(f) def wrapper(*args, **kwargs): time_retry=maxretry time_delay=delay result_msg=\"\" while time_retry: try: val, result_msg=f(*args, **kwargs) if val is False: time_retry -=1 time.sleep(time_delay) continue else: return val, result_msg except Exception as e: time_retry -=1 result_msg=str(e) time.sleep(time_delay) return False, \"max time retry last errmsg is{}\".format(result_msg) return wrapper return decorator class osutil(object): \"\"\" osutil \"\"\" @staticmethod @retry(maxretry=6) def rji2cget_python(bus, addr, reg): with SMBus(bus) as y: val, ind =y.read_byte_data(addr, reg, True) return val, ind @staticmethod @retry(maxretry=6) def rji2cset_python(bus, addr, reg, value): with SMBus(bus) as y: val, ind =y.write_byte_data(addr, reg, value, True) return val, ind @staticmethod @retry(maxretry=6) def rji2cgetword_python(bus, addr, reg): with SMBus(bus) as y: val, ind =y.read_word_data(addr, reg, True) return val, ind @staticmethod @retry(maxretry=6) def rji2csetword_python(bus, addr, reg, value): with SMBus(bus) as y: val, ind =y.write_word_data(addr, reg, value, True) return val, ind @staticmethod def command(cmdstr): retcode, output=subprocess.getstatusoutput(cmdstr) return retcode, output @staticmethod def geti2cword_i2ctool(bus, addr, offset): command_line=\"i2cget -f -y %d 0x%02x 0x%02x wp\" %(bus, addr, offset) retrytime=6 ret_t=\"\" for i in range(retrytime): ret, ret_t=osutil.command(command_line) if ret==0: return True, int(ret_t, 16) time.sleep(0.1) return False, ret_t @staticmethod def seti2cword_i2ctool(bus, addr, offset, val): command_line=\"i2cset -f -y %d 0x%02x 0x%0x 0x%04x wp\" %(bus, addr, offset, val) retrytime=6 ret_t=\"\" for i in range(retrytime): ret, ret_t=osutil.command(command_line) if ret==0: return True, ret_t time.sleep(0.1) return False, ret_t @staticmethod def rji2cget_i2ctool(bus, devno, address): command_line=\"i2cget -f -y %d 0x%02x 0x%02x \" %(bus, devno, address) retrytime=6 ret_t=\"\" for i in range(retrytime): ret, ret_t=osutil.command(command_line) if ret==0: return True, int(ret_t, 16) time.sleep(0.1) return False, ret_t @staticmethod def rji2cset_i2ctool(bus, devno, address, byte): command_line=\"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" %( bus, devno, address, byte) retrytime=6 ret_t=\"\" for i in range(retrytime): ret, ret_t=osutil.command(command_line) if ret==0: return True, ret_t return False, ret_t @staticmethod def geti2cword(bus, addr, offset): return osutil.rji2cgetword_python(bus, addr, offset) @staticmethod def seti2cword(bus, addr, offset, val): return osutil.rji2csetword_python(bus, addr, offset, val) @staticmethod def rji2cget(bus, devno, address): return osutil.rji2cget_python(bus, devno, address) @staticmethod def rji2cset(bus, devno, address, byte): return osutil.rji2cset_python(bus, devno, address, byte) @staticmethod def byteTostr(val): strtmp='' for i in range(len(val)): strtmp +=chr(val[i]) return strtmp @staticmethod def readsysfs(location): try: locations=glob.glob(location) with open(locations[0], 'rb') as fd1: retval=fd1.read() retval=retval.strip() except Exception as e: return False,(str(e)+\" location[%s]\" % location) return True, retval.decode(\"utf-8\", \"ignore\") @staticmethod def getdevmem(addr, digit, mask): command_line=\"devmem 0x%02x %d\" %(addr, digit) retrytime=6 ret_t=\"\" for i in range(retrytime): ret, ret_t=osutil.command(command_line) if ret==0: if mask !=None: ret_t=str(int(ret_t, 16) & mask) return True, ret_t return False, ret_t @staticmethod def rj_os_system(cmd): status, output=subprocess.getstatusoutput(cmd) return status, output @staticmethod def getsdkreg(reg): try: cmd=\"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg ret, result=osutil.rj_os_system(cmd) result_t=result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\") if ret !=0 or \"Error:\" in result_t: return False, result patt=r\"%s.(.*):(.*)>drivshell\" % reg rt=re.findall(patt, result_t, re.S) test=re.findall(\"=(.*)\", rt[0][0])[0] except Exception as e: return False, 'get sdk register error' return True, test @staticmethod def getmactemp(): try: result={} osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\") ret, log=osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\") if ret: return False, result else: logs=log.splitlines() for line in logs: if \"average\" in line: b=re.findall(r'\\d+.\\d+', line) result[\"average\"]=b[0] elif \"maximum\" in line: b=re.findall(r'\\d+.\\d+', line) result[\"maximum\"]=b[0] except Exception as e: return False, str(e) return True, result ", "sourceWithComments": "#######################################################\n#\n# osutil.py\n# Python implementation of the Class osutil\n# Original author: sonic_rd@ruijie.com.cn\n#\n#######################################################\n\nimport subprocess\nimport time\nimport glob\nimport re\n#import chardet\nfrom rjutil.smbus import SMBus\nimport time\nfrom  functools import wraps\n\n\ndef retry(maxretry =6, delay = 0.01):\n    '''\n        maxretry:  max retry times\n        delay   :  interval after last retry\n    '''\n    def decorator(f):\n        @wraps(f)\n        def wrapper(*args, **kwargs):\n            time_retry = maxretry\n            time_delay = delay\n            result_msg = \"\"\n            while time_retry:\n                try:\n                    val , result_msg = f(*args, **kwargs)\n                    if val is False:\n                        time_retry -=1\n                        time.sleep(time_delay)\n                        continue\n                    else:\n                        return val, result_msg\n                except Exception as e:\n                    time_retry -= 1\n                    result_msg = str(e)\n                    time.sleep(time_delay)\n            return False, \"max time retry last errmsg is {}\".format(result_msg)\n        return wrapper\n    return decorator\n\nclass osutil(object):\n    \"\"\"\n       osutil\n    \"\"\"\n\n    @staticmethod\n    @retry(maxretry = 6)\n    def rji2cget_python(bus, addr, reg):\n        with SMBus(bus) as y:\n            val , ind  = y.read_byte_data(addr, reg, True)\n        return val , ind\n\n\n    @staticmethod\n    @retry(maxretry = 6)\n    def rji2cset_python(bus, addr, reg, value):\n        with SMBus(bus) as y:\n            val , ind  = y.write_byte_data(addr, reg, value, True)\n        return val , ind\n\n    @staticmethod\n    @retry(maxretry = 6)\n    def rji2cgetword_python(bus, addr, reg):\n        with SMBus(bus) as y:\n            val , ind  = y.read_word_data(addr, reg, True)\n        return val , ind\n\n    @staticmethod\n    @retry(maxretry = 6)\n    def rji2csetword_python(bus, addr, reg, value):\n        with SMBus(bus) as y:\n            val , ind  = y.write_word_data(addr, reg, value, True)\n        return val , ind\n\n    @staticmethod\n    def command(cmdstr):\n        retcode, output = subprocess.getstatusoutput(cmdstr)\n        return retcode, output\n\n\n    @staticmethod\n    def geti2cword_i2ctool(bus, addr, offset):\n        command_line = \"i2cget -f -y %d 0x%02x 0x%02x  wp\" % (bus, addr, offset)\n        retrytime = 6\n        ret_t = \"\"\n        for i in range(retrytime):\n            ret, ret_t = osutil.command(command_line)\n            if ret == 0:\n                return True, int(ret_t, 16)\n            time.sleep(0.1)\n        return False, ret_t\n\n\n    @staticmethod\n    def seti2cword_i2ctool(bus, addr, offset, val):\n        command_line = \"i2cset -f -y %d 0x%02x 0x%0x 0x%04x wp\" % (bus, addr, offset, val)\n        retrytime = 6\n        ret_t = \"\"\n        for i in range(retrytime):\n            ret, ret_t = osutil.command(command_line)\n            if ret == 0:\n                return True, ret_t\n            time.sleep(0.1)\n        return False, ret_t\n\n    @staticmethod\n    def rji2cget_i2ctool(bus, devno, address):\n        command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)\n        retrytime = 6\n        ret_t = \"\"\n        for i in range(retrytime):\n            ret, ret_t = osutil.command(command_line)\n            if ret == 0:\n                return True, int(ret_t, 16)\n            time.sleep(0.1)\n        return False, ret_t\n\n    @staticmethod\n    def rji2cset_i2ctool(bus, devno, address, byte):\n        command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (\n            bus, devno, address, byte)\n        retrytime = 6\n        ret_t = \"\"\n        for i in range(retrytime):\n            ret, ret_t = osutil.command(command_line)\n            if ret == 0:\n                return True, ret_t\n        return False, ret_t\n\n    @staticmethod\n    def geti2cword(bus, addr, offset):\n        return osutil.rji2cgetword_python(bus, addr, offset)\n    @staticmethod\n    def seti2cword(bus, addr, offset, val):\n        return osutil.rji2csetword_python(bus, addr, offset, val)\n    @staticmethod\n    def rji2cget(bus, devno, address):\n        return osutil.rji2cget_python(bus, devno, address)\n    @staticmethod\n    def rji2cset(bus, devno, address, byte):\n        return osutil.rji2cset_python(bus, devno, address, byte)\n\n    @staticmethod\n    def byteTostr(val):\n        strtmp = ''\n        for i in range(len(val)):\n            strtmp += chr(val[i])\n        return strtmp\n\n    @staticmethod\n    def readsysfs(location):\n        try:\n            locations = glob.glob(location)\n            with open(locations[0], 'rb') as fd1:\n                retval = fd1.read()\n            retval = retval.strip()\n        except Exception as e:\n            return False, (str(e)+\" location[%s]\" % location)\n        return True, retval.decode(\"utf-8\", \"ignore\")\n\n    @staticmethod\n    def getdevmem(addr, digit, mask):\n        command_line = \"devmem 0x%02x %d\" %(addr, digit)\n        retrytime = 6\n        ret_t = \"\"\n        for i in range(retrytime):\n            ret, ret_t = osutil.command(command_line)\n            if ret == 0:\n                if mask != None:\n                    ret_t = str(int(ret_t, 16) & mask)\n            return True, ret_t\n        return False, ret_t\n\n    @staticmethod\n    def rj_os_system(cmd):\n        status, output = subprocess.getstatusoutput(cmd)\n        return status, output\n\n    @staticmethod\n    def getsdkreg(reg):\n        try:\n            cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg\n            ret, result = osutil.rj_os_system(cmd)\n            result_t = result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n            if ret != 0 or \"Error:\" in result_t:\n                return False, result\n            patt = r\"%s.(.*):(.*)>drivshell\" % reg\n            rt = re.findall(patt, result_t, re.S)\n            test = re.findall(\"=(.*)\", rt[0][0])[0]\n        except Exception as e:\n            return False, 'get sdk register error'\n        return True, test\n\n    @staticmethod\n    def getmactemp():\n        try:\n            result = {}\n            #waitForDocker()\n            #need to exec twice\n            osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n            ret, log = osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n            if ret:\n                return False, result\n            else:\n                logs = log.splitlines()\n                for line in logs:\n                    if \"average\" in line:\n                        b = re.findall(r'\\d+.\\d+', line)\n                        result[\"average\"] = b[0]\n                    elif \"maximum\" in line:\n                        b = re.findall(r'\\d+.\\d+', line)\n                        result[\"maximum\"] = b[0]\n        except Exception as e:\n            return False, str(e)\n        return True, result\n\n"}, "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py": {"changes": [{"diff": "\n \n def check_driver():\n     u'''whether there is driver start with rg'''\n-    status, output = log_os_system(\"lsmod | grep rg | wc -l\")\n+    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", \"rg\"], [\"wc\", \"-l\"])\n     #System execution error\n     if status: \n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["    status, output = log_os_system(\"lsmod | grep rg | wc -l\")"], "goodparts": ["    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", \"rg\"], [\"wc\", \"-l\"])"]}, {"diff": "\n     return ret\n \n def startAvscontrol():\n-    cmd = \"nohup avscontrol.py start >/dev/null 2>&1 &\"\n+    cmd = [\"avscontrol.py\", \"start\"]\n     rets = i2c_getPid(\"avscontrol.py\")\n     if len(rets) == 0:\n-        os.system(cmd)\n+        subprocess.Popen(cmd)\n \n def startFanctrol():\n     if STARTMODULE['fancontrol'] == 1:\n-        cmd = \"nohup fancontrol.py start >/dev/null 2>&1 &\"\n+        cmd = [\"fancontrol.py\", \"start\"]\n         rets = i2c_getPid(\"fancontrol.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def starthal_fanctrl():\n     if STARTMODULE.get('hal_fanctrl',0) == 1:\n-        cmd = \"nohup hal_fanctrl.py start >/dev/null 2>&1 &\"\n+        cmd = [\"hal_fanctrl.py\", \"start\"]\n         rets = i2c_getPid(\"hal_fanctrl.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def starthal_ledctrl():\n     if STARTMODULE.get('hal_ledctrl',0) == 1:\n-        cmd = \"nohup hal_ledctrl.py start >/dev/null 2>&1 &\"\n+        cmd = [\"hal_ledctrl.py\", \"start\"]\n         rets = i2c_getPid(\"hal_ledctrl.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n-\n+            subprocess.Popen(cmd)\n def startDevmonitor():\n     if STARTMODULE.get('dev_monitor',0) == 1:\n-        cmd = \"nohup dev_monitor.py start >/dev/null 2>&1 &\"\n+        cmd = [\"dev_monitor.py\", \"start\"]\n         rets = i2c_getPid(\"dev_monitor.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n-\n+            subprocess.Popen(cmd)\n def startSlotmonitor():\n     if STARTMODULE.get('slot_monitor',0) == 1:\n-        cmd = \"nohup slot_monitor.py start >/dev/null 2>&1 &\"\n+        cmd = [\"slot_monitor.py\", \"start\"]\n         rets = i2c_getPid(\"slot_monitor.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def stopFanctrol():\n     u'''disable fan timer service'''\n     if STARTMODULE['fancontrol'] == 1:\n         rets = i2c_getPid(\"fancontrol.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def stophal_ledctrl():\n     if STARTMODULE.get('hal_ledctrl',0) == 1:\n         rets = i2c_getPid(\"hal_ledctrl.py\")\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n \n", "add": 16, "remove": 18, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["    cmd = \"nohup avscontrol.py start >/dev/null 2>&1 &\"", "        os.system(cmd)", "        cmd = \"nohup fancontrol.py start >/dev/null 2>&1 &\"", "            os.system(cmd)", "        cmd = \"nohup hal_fanctrl.py start >/dev/null 2>&1 &\"", "            os.system(cmd)", "        cmd = \"nohup hal_ledctrl.py start >/dev/null 2>&1 &\"", "            os.system(cmd)", "        cmd = \"nohup dev_monitor.py start >/dev/null 2>&1 &\"", "            os.system(cmd)", "        cmd = \"nohup slot_monitor.py start >/dev/null 2>&1 &\"", "            os.system(cmd)", "            cmd = \"kill \"+ ret", "            os.system(cmd)", "            cmd = \"kill \"+ ret", "            os.system(cmd)"], "goodparts": ["    cmd = [\"avscontrol.py\", \"start\"]", "        subprocess.Popen(cmd)", "        cmd = [\"fancontrol.py\", \"start\"]", "            subprocess.Popen(cmd)", "        cmd = [\"hal_fanctrl.py\", \"start\"]", "            subprocess.Popen(cmd)", "        cmd = [\"hal_ledctrl.py\", \"start\"]", "            subprocess.Popen(cmd)", "        cmd = [\"dev_monitor.py\", \"start\"]", "            subprocess.Popen(cmd)", "        cmd = [\"slot_monitor.py\", \"start\"]", "            subprocess.Popen(cmd)", "            cmd = [\"kill\", ret]", "            subprocess.call(cmd)", "            cmd = [\"kill\", ret]", "            subprocess.call(cmd)"]}, {"diff": "\n     if STARTMODULE.get('dev_monitor',0) == 1:\n         rets = i2c_getPid(\"dev_monitor.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def stopSlotmonitor():\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["            cmd = \"kill \"+ ret", "            os.system(cmd)"], "goodparts": ["            cmd = [\"kill\", ret]", "            subprocess.call(cmd)"]}, {"diff": "\n     if STARTMODULE.get('slot_monitor',0) == 1:\n         rets = i2c_getPid(\"slot_monitor.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def removeDev(bus, loc):\n-    cmd = \"echo  0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device\" % (loc, bus)\n     devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n     if os.path.exists(devpath):\n-        log_os_system(cmd)\n+        file = \"/sys/bus/i2c/devices/i2c-%d/delete_device\" % bus\n+        with open(file, 'w') as f:\n+            f.write('0x%02x\\n'%str(bus))\n         \n def addDev(name, bus, loc):\n     if name == \"lm75\":\n", "add": 5, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["            cmd = \"kill \"+ ret", "            os.system(cmd)", "    cmd = \"echo  0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device\" % (loc, bus)", "        log_os_system(cmd)"], "goodparts": ["            cmd = [\"kill\", ret]", "            subprocess.call(cmd)", "        file = \"/sys/bus/i2c/devices/i2c-%d/delete_device\" % bus", "        with open(file, 'w') as f:", "            f.write('0x%02x\\n'%str(bus))"]}, {"diff": "\n         if i % 10 == 0:\n             click.echo(\"%%DEVICE_I2C-INIT: %s not found, wait 0.1 second ! i %d \" % (pdevpath,i))\n             \n-    cmd = \"echo  %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device\" % (name, loc, bus)\n     devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n     if os.path.exists(devpath) == False:\n-        os.system(cmd)\n+        file = \"/sys/bus/i2c/devices/i2c-%d/new_device\" % bus\n+        with open(file, 'w') as f:\n+            f.write('%s 0x%02x\\n' % (name, loc))\n \n def removedevs():\n     devs = GLOBALCONFIG[\"DEVS\"]\n", "add": 3, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["    cmd = \"echo  %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device\" % (name, loc, bus)", "        os.system(cmd)"], "goodparts": ["        file = \"/sys/bus/i2c/devices/i2c-%d/new_device\" % bus", "        with open(file, 'w') as f:", "            f.write('%s 0x%02x\\n' % (name, loc))"]}, {"diff": "\n         addDev(devs[dev][\"name\"], devs[dev][\"bus\"] , devs[dev][\"loc\"])\n \n def checksignaldriver(name):\n-    modisexistcmd = \"lsmod | grep %s | wc -l\" % name\n-    status, output = log_os_system(modisexistcmd)\n+    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", name], [\"wc\", \"-l\"])\n     #System execution error\n     if status: \n         return False\n", "add": 1, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["    modisexistcmd = \"lsmod | grep %s | wc -l\" % name", "    status, output = log_os_system(modisexistcmd)"], "goodparts": ["    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", name], [\"wc\", \"-l\"])"]}, {"diff": "\n         return False\n \n def adddriver(name, delay):\n-    cmd = \"modprobe %s\" % name\n+    cmd = [\"modprobe\", name]\n     if delay != 0:\n         time.sleep(delay)\n     if checksignaldriver(name) != True:\n-        log_os_system(cmd)\n+        getstatusoutput_noshell(cmd)\n \n def removedriver(name, delay):\n     realname = name.lstrip().split(\" \")[0];\n-    cmd = \"rmmod -f %s\" % realname\n+    cmd = [\"rmmod\", \"-f\", realname]\n     if checksignaldriver(realname):\n-        log_os_system(cmd)\n+        getstatusoutput_noshell(cmd)\n \n def removedrivers():\n     u'''remove all drive", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["    cmd = \"modprobe %s\" % name", "        log_os_system(cmd)", "    cmd = \"rmmod -f %s\" % realname", "        log_os_system(cmd)"], "goodparts": ["    cmd = [\"modprobe\", name]", "        getstatusoutput_noshell(cmd)", "    cmd = [\"rmmod\", \"-f\", realname]", "        getstatusoutput_noshell(cmd)"]}], "source": "\n import click import os import subprocess import time from ruijieconfig import GLOBALCONFIG, GLOBALINITPARAM, GLOBALINITCOMMAND, MAC_LED_RESET, STARTMODULE, i2ccheck_params from ruijieutil import rjpciwr CONTEXT_SETTINGS=dict(help_option_names=['-h', '--help']) class AliasedGroup(click.Group): def get_command(self, ctx, cmd_name): rv=click.Group.get_command(self, ctx, cmd_name) if rv is not None: return rv matches=[x for x in self.list_commands(ctx) if x.startswith(cmd_name)] if not matches: return None elif len(matches)==1: return click.Group.get_command(self, ctx, matches[0]) ctx.fail('Too many matches: %s' % ', '.join(sorted(matches))) def log_os_system(cmd): u'''execute shell command''' status, output=subprocess.getstatusoutput(cmd) if status: print(output) return status, output def write_sysfs_value(reg_name, value): u'''write sysfs file''' mb_reg_file=\"/sys/bus/i2c/devices/\" +reg_name if(not os.path.isfile(mb_reg_file)): print(mb_reg_file, 'not found !') return False try: with open(mb_reg_file, 'w') as fd: fd.write(value) except Exception as error: return False return True def check_driver(): u'''whether there is driver start with rg''' status, output=log_os_system(\"lsmod | grep rg | wc -l\") if status: return False if output.isdigit() and int(output) > 0: return True else: return False def i2c_getPid(name): ret=[] for dirname in os.listdir('/proc'): if dirname=='curproc': continue try: with open('/proc/{}/cmdline'.format(dirname), mode='r') as fd: content=fd.read() except Exception: continue if name in content: ret.append(dirname) return ret def startAvscontrol(): cmd=\"nohup avscontrol.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"avscontrol.py\") if len(rets)==0: os.system(cmd) def startFanctrol(): if STARTMODULE['fancontrol']==1: cmd=\"nohup fancontrol.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"fancontrol.py\") if len(rets)==0: os.system(cmd) def starthal_fanctrl(): if STARTMODULE.get('hal_fanctrl',0)==1: cmd=\"nohup hal_fanctrl.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"hal_fanctrl.py\") if len(rets)==0: os.system(cmd) def starthal_ledctrl(): if STARTMODULE.get('hal_ledctrl',0)==1: cmd=\"nohup hal_ledctrl.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"hal_ledctrl.py\") if len(rets)==0: os.system(cmd) def startDevmonitor(): if STARTMODULE.get('dev_monitor',0)==1: cmd=\"nohup dev_monitor.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"dev_monitor.py\") if len(rets)==0: os.system(cmd) def startSlotmonitor(): if STARTMODULE.get('slot_monitor',0)==1: cmd=\"nohup slot_monitor.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"slot_monitor.py\") if len(rets)==0: os.system(cmd) def stopFanctrol(): u'''disable fan timer service''' if STARTMODULE['fancontrol']==1: rets=i2c_getPid(\"fancontrol.py\") for ret in rets: cmd=\"kill \"+ret os.system(cmd) return True def stophal_ledctrl(): if STARTMODULE.get('hal_ledctrl',0)==1: rets=i2c_getPid(\"hal_ledctrl.py\") for ret in rets: cmd=\"kill \"+ret os.system(cmd) return True def stopDevmonitor(): u'''disable the fan timer service''' if STARTMODULE.get('dev_monitor',0)==1: rets=i2c_getPid(\"dev_monitor.py\") for ret in rets: cmd=\"kill \"+ret os.system(cmd) return True def stopSlotmonitor(): u'''disable slot timer service''' if STARTMODULE.get('slot_monitor',0)==1: rets=i2c_getPid(\"slot_monitor.py\") for ret in rets: cmd=\"kill \"+ret os.system(cmd) return True def removeDev(bus, loc): cmd=\"echo 0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device\" %(loc, bus) devpath=\"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc) if os.path.exists(devpath): log_os_system(cmd) def addDev(name, bus, loc): if name==\"lm75\": time.sleep(0.1) pdevpath=\"/sys/bus/i2c/devices/i2c-%d/\" %(bus) for i in range(1, 100): if os.path.exists(pdevpath)==True: break time.sleep(0.1) if i % 10==0: click.echo(\"%%DEVICE_I2C-INIT: %s not found, wait 0.1 second ! i %d \" %(pdevpath,i)) cmd=\"echo %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device\" %(name, loc, bus) devpath=\"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc) if os.path.exists(devpath)==False: os.system(cmd) def removedevs(): devs=GLOBALCONFIG[\"DEVS\"] for index in range(len(devs)-1, -1, -1): removeDev(devs[index][\"bus\"], devs[index][\"loc\"]) def adddevs(): devs=GLOBALCONFIG[\"DEVS\"] for dev in range(0, devs.__len__()): addDev(devs[dev][\"name\"], devs[dev][\"bus\"], devs[dev][\"loc\"]) def checksignaldriver(name): modisexistcmd=\"lsmod | grep %s | wc -l\" % name status, output=log_os_system(modisexistcmd) if status: return False if output.isdigit() and int(output) > 0: return True else: return False def adddriver(name, delay): cmd=\"modprobe %s\" % name if delay !=0: time.sleep(delay) if checksignaldriver(name) !=True: log_os_system(cmd) def removedriver(name, delay): realname=name.lstrip().split(\" \")[0]; cmd=\"rmmod -f %s\" % realname if checksignaldriver(realname): log_os_system(cmd) def removedrivers(): u'''remove all drivers''' if GLOBALCONFIG is None: click.echo(\"%%DEVICE_I2C-INIT: load global config failed.\") return drivers=GLOBALCONFIG.get(\"DRIVERLISTS\", None) if drivers is None: click.echo(\"%%DEVICE_I2C-INIT: load driver list failed.\") return for index in range(len(drivers)-1, -1, -1): delay=0 name=\"\" if type(drivers[index])==dict and \"delay\" in drivers[index]: name=drivers[index].get(\"name\") delay=drivers[index][\"delay\"] else: name=drivers[index] removedriver(name, delay) def adddrivers(): u'''add drivers''' if GLOBALCONFIG is None: click.echo(\"%%DEVICE_I2C-INIT: load global config failed.\") return drivers=GLOBALCONFIG.get(\"DRIVERLISTS\", None) if drivers is None: click.echo(\"%%DEVICE_I2C-INIT: load driver list failed.\") return for index in range(0,len(drivers)): delay=0 name=\"\" if type(drivers[index])==dict and \"delay\" in drivers[index]: name=drivers[index].get(\"name\") delay=drivers[index][\"delay\"] else: name=drivers[index] adddriver(name, delay) def otherinit(): for index in GLOBALINITPARAM: write_sysfs_value(index[\"loc\"], index[\"value\"]) for index in GLOBALINITCOMMAND: log_os_system(index) def unload_driver(): u'''remove devices and drivers''' stopDevmonitor() stopFanctrol() removedevs() removedrivers() def reload_driver(): u'''reload devices and drivers''' removedevs() removedrivers() time.sleep(1) adddrivers() adddevs() def i2c_check(bus,retrytime=6): try: i2cpath=\"/sys/bus/i2c/devices/\" +bus while retrytime and not os.path.exists(i2cpath): click.echo(\"%%DEVICE_I2C-HA: i2c bus abnormal, last bus %s is not exist.\" % i2cpath) reload_driver() retrytime -=1 time.sleep(1) except Exception as e: click.echo(\"%%DEVICE_I2C-HA: %s\" % str(e)) return def MacLedSet(data): '''write pci register''' pcibus=MAC_LED_RESET.get(\"pcibus\") slot=MAC_LED_RESET.get(\"slot\") fn=MAC_LED_RESET.get(\"fn\") bar=MAC_LED_RESET.get(\"bar\") offset=MAC_LED_RESET.get(\"offset\") val=MAC_LED_RESET.get(data, None) if val is None: click.echo(\"%%DEVICE_I2C-INIT: MacLedSet wrong input\") return rjpciwr(pcibus, slot, fn, bar, offset, val) def load_driver(): u'''load devices and drivers''' adddrivers() adddevs() if STARTMODULE.get(\"i2ccheck\",0)==1: busend=i2ccheck_params.get(\"busend\") retrytime=i2ccheck_params.get(\"retrytime\") i2c_check(busend,retrytime) startFanctrol() starthal_fanctrl() starthal_ledctrl() if STARTMODULE['avscontrol']==1: startAvscontrol() startDevmonitor() startSlotmonitor() otherinit(); if STARTMODULE.get(\"macledreset\",0)==1: MacLedSet(\"reset\") @click.group(cls=AliasedGroup, context_settings=CONTEXT_SETTINGS) def main(): '''device operator''' pass @main.command() def start(): '''load device ''' if check_driver(): unload_driver() load_driver() @main.command() def stop(): '''stop device ''' unload_driver() @main.command() def restart(): '''restart device''' unload_driver() load_driver() if __name__=='__main__': u'''device_i2c operation''' main() ", "sourceWithComments": "#!/usr/bin/env python3\n# -*- coding: UTF-8 -*-\n\nimport click\nimport os\nimport subprocess\nimport time\nfrom  ruijieconfig import GLOBALCONFIG, GLOBALINITPARAM, GLOBALINITCOMMAND, MAC_LED_RESET, STARTMODULE, i2ccheck_params\n\nfrom  ruijieutil   import rjpciwr\n\nCONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])\n\nclass AliasedGroup(click.Group):\n    def get_command(self, ctx, cmd_name):\n        rv = click.Group.get_command(self, ctx, cmd_name)\n        if rv is not None:\n            return rv\n        matches = [x for x in self.list_commands(ctx)\n                   if x.startswith(cmd_name)]\n        if not matches:\n            return None\n        elif len(matches) == 1:\n            return click.Group.get_command(self, ctx, matches[0])\n        ctx.fail('Too many matches: %s' % ', '.join(sorted(matches)))\n   \ndef log_os_system(cmd):\n    u'''execute shell command'''\n    status, output = subprocess.getstatusoutput(cmd)\n    if status:\n        print(output)\n    return  status, output\n\ndef write_sysfs_value(reg_name, value):\n    u'''write sysfs file'''\n    mb_reg_file = \"/sys/bus/i2c/devices/\" + reg_name\n    if (not os.path.isfile(mb_reg_file)):\n        print(mb_reg_file,  'not found !')\n        return False\n    try:\n        with open(mb_reg_file, 'w') as fd:\n            fd.write(value)\n    except Exception as error:\n        return False\n    return True\n\ndef check_driver():\n    u'''whether there is driver start with rg'''\n    status, output = log_os_system(\"lsmod | grep rg | wc -l\")\n    #System execution error\n    if status: \n        return False\n    if output.isdigit() and int(output) > 0:\n        return True\n    else:\n        return False\n\ndef i2c_getPid(name):\n    ret = []\n    for dirname in os.listdir('/proc'):\n        if dirname == 'curproc':\n            continue\n        try:\n            with open('/proc/{}/cmdline'.format(dirname), mode='r') as fd:\n                content = fd.read()\n        except Exception:\n            continue\n        if name in content:\n            ret.append(dirname)\n    return ret\n\ndef startAvscontrol():\n    cmd = \"nohup avscontrol.py start >/dev/null 2>&1 &\"\n    rets = i2c_getPid(\"avscontrol.py\")\n    if len(rets) == 0:\n        os.system(cmd)\n\ndef startFanctrol():\n    if STARTMODULE['fancontrol'] == 1:\n        cmd = \"nohup fancontrol.py start >/dev/null 2>&1 &\"\n        rets = i2c_getPid(\"fancontrol.py\")\n        if len(rets) == 0:\n            os.system(cmd)\n\ndef starthal_fanctrl():\n    if STARTMODULE.get('hal_fanctrl',0) == 1:\n        cmd = \"nohup hal_fanctrl.py start >/dev/null 2>&1 &\"\n        rets = i2c_getPid(\"hal_fanctrl.py\")\n        if len(rets) == 0:\n            os.system(cmd)\n\ndef starthal_ledctrl():\n    if STARTMODULE.get('hal_ledctrl',0) == 1:\n        cmd = \"nohup hal_ledctrl.py start >/dev/null 2>&1 &\"\n        rets = i2c_getPid(\"hal_ledctrl.py\")\n        if len(rets) == 0:\n            os.system(cmd)\n\ndef startDevmonitor():\n    if STARTMODULE.get('dev_monitor',0) == 1:\n        cmd = \"nohup dev_monitor.py start >/dev/null 2>&1 &\"\n        rets = i2c_getPid(\"dev_monitor.py\")\n        if len(rets) == 0:\n            os.system(cmd)\n\ndef startSlotmonitor():\n    if STARTMODULE.get('slot_monitor',0) == 1:\n        cmd = \"nohup slot_monitor.py start >/dev/null 2>&1 &\"\n        rets = i2c_getPid(\"slot_monitor.py\")\n        if len(rets) == 0:\n            os.system(cmd)\n\ndef stopFanctrol():\n    u'''disable fan timer service'''\n    if STARTMODULE['fancontrol'] == 1:\n        rets = i2c_getPid(\"fancontrol.py\")  #\n        for ret in rets:\n            cmd = \"kill \"+ ret\n            os.system(cmd)\n        return True\n\ndef stophal_ledctrl():\n    if STARTMODULE.get('hal_ledctrl',0) == 1:\n        rets = i2c_getPid(\"hal_ledctrl.py\")\n        for ret in rets:\n            cmd = \"kill \"+ ret\n            os.system(cmd)\n        return True\n\n\ndef stopDevmonitor():\n    u'''disable the fan timer service'''\n    if STARTMODULE.get('dev_monitor',0) == 1:\n        rets = i2c_getPid(\"dev_monitor.py\")  #\n        for ret in rets:\n            cmd = \"kill \"+ ret\n            os.system(cmd)\n        return True\n\ndef stopSlotmonitor():\n    u'''disable slot timer service'''\n    if STARTMODULE.get('slot_monitor',0) == 1:\n        rets = i2c_getPid(\"slot_monitor.py\")  #\n        for ret in rets:\n            cmd = \"kill \"+ ret\n            os.system(cmd)\n        return True\n\ndef removeDev(bus, loc):\n    cmd = \"echo  0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device\" % (loc, bus)\n    devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n    if os.path.exists(devpath):\n        log_os_system(cmd)\n        \ndef addDev(name, bus, loc):\n    if name == \"lm75\":\n        time.sleep(0.1)\n    pdevpath = \"/sys/bus/i2c/devices/i2c-%d/\" % (bus)\n    for i in range(1, 100):#wait for mother-bus generation\uff0cmaximum wait time is 10s\n        if os.path.exists(pdevpath) == True: \n            break\n        time.sleep(0.1)\n        if i % 10 == 0:\n            click.echo(\"%%DEVICE_I2C-INIT: %s not found, wait 0.1 second ! i %d \" % (pdevpath,i))\n            \n    cmd = \"echo  %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device\" % (name, loc, bus)\n    devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n    if os.path.exists(devpath) == False:\n        os.system(cmd)\n\ndef removedevs():\n    devs = GLOBALCONFIG[\"DEVS\"]\n    for index in range(len(devs)-1, -1, -1 ):\n        removeDev(devs[index][\"bus\"] , devs[index][\"loc\"])\n        \ndef adddevs():\n    devs = GLOBALCONFIG[\"DEVS\"]\n    for dev in range(0, devs.__len__()):\n        addDev(devs[dev][\"name\"], devs[dev][\"bus\"] , devs[dev][\"loc\"])\n\ndef checksignaldriver(name):\n    modisexistcmd = \"lsmod | grep %s | wc -l\" % name\n    status, output = log_os_system(modisexistcmd)\n    #System execution error\n    if status: \n        return False\n    if output.isdigit() and int(output) > 0:\n        return True\n    else:\n        return False\n\ndef adddriver(name, delay):\n    cmd = \"modprobe %s\" % name\n    if delay != 0:\n        time.sleep(delay)\n    if checksignaldriver(name) != True:\n        log_os_system(cmd)\n\ndef removedriver(name, delay):\n    realname = name.lstrip().split(\" \")[0];\n    cmd = \"rmmod -f %s\" % realname\n    if checksignaldriver(realname):\n        log_os_system(cmd)\n\ndef removedrivers():\n    u'''remove all drivers'''\n    if GLOBALCONFIG is None:\n        click.echo(\"%%DEVICE_I2C-INIT: load global config failed.\")\n        return\n    drivers = GLOBALCONFIG.get(\"DRIVERLISTS\", None)\n    if drivers is None:\n        click.echo(\"%%DEVICE_I2C-INIT: load driver list failed.\")\n        return \n    for index in range(len(drivers)-1, -1, -1 ):\n        delay = 0\n        name = \"\"\n        if type(drivers[index]) == dict and \"delay\" in drivers[index]:\n            name = drivers[index].get(\"name\")\n            delay = drivers[index][\"delay\"]\n        else:\n            name = drivers[index]\n        removedriver(name, delay)\n\ndef adddrivers():\n    u'''add drivers'''\n    if GLOBALCONFIG is None:\n        click.echo(\"%%DEVICE_I2C-INIT: load global config failed.\")\n        return\n    drivers = GLOBALCONFIG.get(\"DRIVERLISTS\", None)\n    if drivers is None:\n        click.echo(\"%%DEVICE_I2C-INIT: load driver list failed.\")\n        return \n    for index in range(0 ,len(drivers)):\n        delay = 0\n        name = \"\"\n        if type(drivers[index]) == dict and \"delay\" in drivers[index]:\n            name = drivers[index].get(\"name\")\n            delay = drivers[index][\"delay\"]\n        else:\n            name = drivers[index]\n        adddriver(name, delay)\n\ndef otherinit():\n    for index in GLOBALINITPARAM:\n        write_sysfs_value(index[\"loc\"], index[\"value\"])\n\n    for index in GLOBALINITCOMMAND:\n        log_os_system(index)\n    \ndef unload_driver():\n    u'''remove devices and drivers'''\n    stopDevmonitor() # disable removable device driver monitors\n    stopFanctrol()  # disable fan-control service\n    removedevs()    # remove other devices\n    removedrivers() # remove drivers\n\ndef reload_driver():\n    u'''reload devices and drivers'''\n    removedevs()    # remove other devices\n    removedrivers() # remove drivers\n    time.sleep(1)\n    adddrivers()\n    adddevs()\n\n\ndef i2c_check(bus,retrytime = 6):\n    try:\n        i2cpath = \"/sys/bus/i2c/devices/\" + bus\n        while retrytime and not os.path.exists(i2cpath):\n            click.echo(\"%%DEVICE_I2C-HA: i2c bus abnormal, last bus %s is not exist.\" % i2cpath)\n            reload_driver()\n            retrytime -= 1\n            time.sleep(1)\n    except Exception as e:\n        click.echo(\"%%DEVICE_I2C-HA: %s\" % str(e))\n    return \n\ndef MacLedSet(data):\n    '''write pci register'''\n    pcibus = MAC_LED_RESET.get(\"pcibus\")\n    slot = MAC_LED_RESET.get(\"slot\")\n    fn = MAC_LED_RESET.get(\"fn\")\n    bar = MAC_LED_RESET.get(\"bar\")\n    offset = MAC_LED_RESET.get(\"offset\")\n    val = MAC_LED_RESET.get(data, None)\n    if val is None:\n        click.echo(\"%%DEVICE_I2C-INIT: MacLedSet wrong input\")\n        return\n    rjpciwr(pcibus, slot, fn, bar, offset, val)\n\ndef load_driver():\n    u'''load devices and drivers'''\n    adddrivers()\n    adddevs()\n    if STARTMODULE.get(\"i2ccheck\",0) == 1: #i2c HA\n        busend = i2ccheck_params.get(\"busend\")\n        retrytime = i2ccheck_params.get(\"retrytime\")\n        i2c_check(busend,retrytime)\n    startFanctrol() # enable fan\n    starthal_fanctrl() # enable fan control\n    starthal_ledctrl() # enable LED control\n    if STARTMODULE['avscontrol'] == 1:\n        startAvscontrol() # avs voltage-adjustment\n    startDevmonitor() # enable removable device driver monitors\n    startSlotmonitor() # slot insertion and removal initialization monitor\n    otherinit();    # other initialization, QSFP initialization\n    if STARTMODULE.get(\"macledreset\",0) == 1:\n        MacLedSet(\"reset\")\n    \n@click.group(cls=AliasedGroup, context_settings=CONTEXT_SETTINGS)\ndef main():\n    '''device operator'''\n    pass\n\n\n@main.command()\ndef start():\n    '''load device '''\n    if check_driver():\n        unload_driver()\n    load_driver()\n\n@main.command()\ndef stop():\n    '''stop device '''\n    unload_driver()\n\n@main.command()\ndef restart():\n    '''restart device'''\n    unload_driver()\n    load_driver()\n\nif __name__ == '__main__':\n    u'''device_i2c operation'''\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py": {"changes": [{"diff": "\n                     self.fanSpeedSetMax()  # fan full speed\n                     self.critnum += 1 # anti-shake\n                     if self.critnum >= MONITOR_CONST.CRITICAL_NUM:\n-                       os.system(\"reboot\")\n+                        subprocess.call([\"reboot\"])\n                     fanwarningdebuglog(DEBUG_FANCONTROL,\"crit\u6b21\u6570:%d\" % self.critnum)\n                 else:\n                     self.critn", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py", "badparts": ["                       os.system(\"reboot\")"], "goodparts": ["                        subprocess.call([\"reboot\"])"]}]}, "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py": {"changes": [{"diff": "\n import sys\n import os\n import re\n-import subprocess\n import syslog\n import time\n import binascii\n", "add": 0, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["import subprocess"], "goodparts": []}, {"diff": "\n \n def getSdkReg(reg):\n     try:\n-        cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg\n-        ret, result = rj_os_system(cmd)\n+        cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]\n+        ret, result = getstatusoutput_noshell(cmd)\n         result_t = result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n         if ret != 0 or \"Error:\" in result_t:\n             return False, result\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["        cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg", "        ret, result = rj_os_system(cmd)"], "goodparts": ["        cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]", "        ret, result = getstatusoutput_noshell(cmd)"]}, {"diff": "\n     result = {}\n     #waitForDocker()\n     # exec twice, get the second result\n-    rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n-    ret, log = rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n+    getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n+    ret, log = getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n     if ret:\n         return False, result\n     else:\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")", "    ret, log = rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")"], "goodparts": ["    getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])", "    ret, log = getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])"]}, {"diff": "\n \n def restartDockerService(force=False):\n     container_name = [\"database\",\"snmp\",\"syncd\",\"swss\",\"dhcp_relay\",\"radv\",\"teamd\",\"pmon\"]\n-    ret, status = rj_os_system(\"docker ps\")\n+    ret, status = getstatusoutput_noshell([\"docker\", \"ps\"])\n     if ret == 0 :\n         for tmpname in container_name:\n             if (tmpname not in status):\n                 if (force == True):\n-                    rj_os_system(\"docker restart %s\"%tmpname)\n+                    getstatusoutput_noshell([\"docker\", \"restart\", tmpname])\n                 else:\n-                    rj_os_system(\"systemctl restart %s\"%tmpname)\n+                    getstatusoutput_noshell([\"systemctl\", \"restart\", tmpname])\n \n \n def waitForDhcp(timeout):\n     time_cnt = 0\n     while True:\n         try:\n-            ret, status = rj_os_system(\"systemctl status dhcp_relay.service\")\n+            ret, status = getstatusoutput_noshell([\"systemctl\", \"status\", \"dhcp_relay.service\"])\n             if (ret == 0 and \"running\" in status)  or \"SUCCESS\" in status:\n                 break\n             else:\n", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    ret, status = rj_os_system(\"docker ps\")", "                    rj_os_system(\"docker restart %s\"%tmpname)", "                    rj_os_system(\"systemctl restart %s\"%tmpname)", "            ret, status = rj_os_system(\"systemctl status dhcp_relay.service\")"], "goodparts": ["    ret, status = getstatusoutput_noshell([\"docker\", \"ps\"])", "                    getstatusoutput_noshell([\"docker\", \"restart\", tmpname])", "                    getstatusoutput_noshell([\"systemctl\", \"restart\", tmpname])", "            ret, status = getstatusoutput_noshell([\"systemctl\", \"status\", \"dhcp_relay.service\"])"]}, {"diff": "\n     rulefile = \"/etc/udev/rules.d/70-persistent-net.rules\"\n     if isValidMac(mac) == False:\n         return False, \"MAC invaild\"\n-    cmd = \"ethtool -e %s | grep 0x0010 | awk '{print \\\"0x\\\"$13$12$15$14}'\" % eth\n-    ret, log = rj_os_system(cmd)\n+    cmd1 = [\"ethtool\", \"-e\", eth] \n+    cmd2 = [\"grep\", \"0x0010\"]\n+    cmd3 = [\"awk\", '{print \\\"0x\\\"$13$12$15$14}']\n+    ret, log = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)\n     log_debug(log)\n     magic = \"\"\n     if ret == 0 and len(log):\n", "add": 4, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    cmd = \"ethtool -e %s | grep 0x0010 | awk '{print \\\"0x\\\"$13$12$15$14}'\" % eth", "    ret, log = rj_os_system(cmd)"], "goodparts": ["    cmd1 = [\"ethtool\", \"-e\", eth] ", "    cmd2 = [\"grep\", \"0x0010\"]", "    cmd3 = [\"awk\", '{print \\\"0x\\\"$13$12$15$14}']", "    ret, log = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)"]}, {"diff": "\n     macs = mac.upper().split(\":\")\n \n     # chage ETH0 to value after setmac\n-    ifconfigcmd = \"ifconfig eth0 hw ether %s\" % mac\n-    log_debug(ifconfigcmd)\n-    ret, status = rj_os_system(ifconfigcmd)\n+    ifconfigcmd = [\"ifconfig\", \"eth0\", \"hw\", \"ether\", mac]\n+    log_debug(' '.join(ifconfigcmd))\n+    ret, status = getstatusoutput_noshell(ifconfigcmd)\n     if ret:\n         raise SETMACException(\"software set  Internet cardMAC error\")\n     index = 0\n     for item in macs:\n-        cmd = \"ethtool -E %s magic %s offset %d value 0x%s\" % (\n-            eth, magic, index, item)\n+        cmd = [\"ethtool\", \"-E\", eht, \"magic\", magic, \"offset\", str(index), \"value\", \"0x\"+item]\n         log_debug(cmd)\n         index += 1\n-        ret, log = rj_os_system(cmd)\n+        ret, log = getstatusoutput_noshell(cmd)\n         if ret != 0:\n             raise SETMACException(\" set hardware Internet card MAC error\")\n     # get value after setting \n-    cmd_t = \"ethtool -e eth0 offset 0 length 6\"\n-    ret, log = rj_os_system(cmd_t)\n+    cmd_t = [\"ethtool\", \"-e\", \"eth0\", \"offset\", \"0\", \"length\", \"6\"]\n+    ret, log = getstatusoutput_noshell(cmd_t)\n     m = re.split(':', log)[-1].strip().upper()\n     mac_result = m.upper().split(\" \")\n \n", "add": 7, "remove": 8, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    ifconfigcmd = \"ifconfig eth0 hw ether %s\" % mac", "    log_debug(ifconfigcmd)", "    ret, status = rj_os_system(ifconfigcmd)", "        cmd = \"ethtool -E %s magic %s offset %d value 0x%s\" % (", "            eth, magic, index, item)", "        ret, log = rj_os_system(cmd)", "    cmd_t = \"ethtool -e eth0 offset 0 length 6\"", "    ret, log = rj_os_system(cmd_t)"], "goodparts": ["    ifconfigcmd = [\"ifconfig\", \"eth0\", \"hw\", \"ether\", mac]", "    log_debug(' '.join(ifconfigcmd))", "    ret, status = getstatusoutput_noshell(ifconfigcmd)", "        cmd = [\"ethtool\", \"-E\", eht, \"magic\", magic, \"offset\", str(index), \"value\", \"0x\"+item]", "        ret, log = getstatusoutput_noshell(cmd)", "    cmd_t = [\"ethtool\", \"-e\", \"eth0\", \"offset\", \"0\", \"length\", \"6\"]", "    ret, log = getstatusoutput_noshell(cmd_t)"]}, {"diff": "\n \n \n def rji2cget(bus, devno, address):\n-    command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)\n+    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address)]\n     retrytime = 6\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n         time.sleep(0.1)\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)", "        ret, ret_t = rj_os_system(command_line)"], "goodparts": ["    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address)]", "        ret, ret_t = getstatusoutput_noshell(command_line)"]}, {"diff": "\n \n \n def rji2cset(bus, devno, address, byte):\n-    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (\n-        bus, devno, address, byte)\n+    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%02x\"%str(byte)]\n     retrytime = 6\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n     return False, ret_t\n", "add": 2, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (", "        bus, devno, address, byte)", "        ret, ret_t = rj_os_system(command_line)"], "goodparts": ["    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%02x\"%str(byte)]", "        ret, ret_t = getstatusoutput_noshell(command_line)"]}, {"diff": "\n     data.close()\n \n def rjsysset(location, value):\n-    command_line = \"echo 0x%02x > %s\" % (value, location)\n     retrytime = 6\n-    ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n-        if ret == 0:\n-            return True, ret_t\n-    return False, ret_t\n+        try:\n+            with open(location, 'w') as f:\n+                f.write('0x%02x\\n'%value)\n+        except (IOError, FileNotFoundError) as e:\n+            return False, str(e)\n+    return True, ''\n \n \n def rji2cgetWord(bus, devno, address):\n-    command_line = \"i2cget -f -y %d 0x%02x 0x%02x w\" % (bus, devno, address)\n+    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"w\"]\n     retrytime = 3\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n     return False, ret_t\n \n \n def rji2csetWord(bus, devno, address, byte):\n-    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%x w\" % (\n-        bus, devno, address, byte)\n-    rj_os_system(command_line)\n+    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%x\"%str(byte), \"w\"]\n+    getstatusoutput_noshell(command_line)\n \n \n def fan_setmac():\n", "add": 10, "remove": 11, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    command_line = \"echo 0x%02x > %s\" % (value, location)", "    ret_t = \"\"", "        ret, ret_t = rj_os_system(command_line)", "        if ret == 0:", "            return True, ret_t", "    return False, ret_t", "    command_line = \"i2cget -f -y %d 0x%02x 0x%02x w\" % (bus, devno, address)", "        ret, ret_t = rj_os_system(command_line)", "    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%x w\" % (", "        bus, devno, address, byte)", "    rj_os_system(command_line)"], "goodparts": ["        try:", "            with open(location, 'w') as f:", "                f.write('0x%02x\\n'%value)", "        except (IOError, FileNotFoundError) as e:", "            return False, str(e)", "    return True, ''", "    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"w\"]", "        ret, ret_t = getstatusoutput_noshell(command_line)", "    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%x\"%str(byte), \"w\"]", "    getstatusoutput_noshell(command_line)"]}, {"diff": "\n     elif dealtype == \"io\":\n         io_wr(E2_PROTECT[\"io_addr\"], E2_PROTECT[\"close\"])\n     # deal last drivers\n-    os.system(\"rmmod at24 \")\n-    os.system(\"modprobe at24 \")\n-    os.system(\"rm -f /var/cache/sonic/decode-syseeprom/syseeprom_cache\")\n+    getstatusoutput_noshell([\"rmmod\", \"at24\"])\n+    getstatusoutput_noshell([\"modprobe\", \"at24\"])\n+    getstatusoutput_noshell([\"rm\", \"-f\", \"/var/cache/sonic/decode-syseeprom/syseeprom_cache\"])\n \n \n def get_local_eth0_mac():\n-    cmd = \"ifconfig eth0 |grep HWaddr\"\n-    print(rj_os_system(cmd))\n+    cmd1 = [\"ifconfig\", \"eth0\"]\n+    cmd2 = [\"grep\", \"HWaddr\"]\n+    print(getstatusoutput_noshell_pipe(cmd1, cmd2))\n \n def getonieversion():\n     if not os.path.isfile('/host/machine.conf'):\n", "add": 6, "remove": 5, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    os.system(\"rmmod at24 \")", "    os.system(\"modprobe at24 \")", "    os.system(\"rm -f /var/cache/sonic/decode-syseeprom/syseeprom_cache\")", "    cmd = \"ifconfig eth0 |grep HWaddr\"", "    print(rj_os_system(cmd))"], "goodparts": ["    getstatusoutput_noshell([\"rmmod\", \"at24\"])", "    getstatusoutput_noshell([\"modprobe\", \"at24\"])", "    getstatusoutput_noshell([\"rm\", \"-f\", \"/var/cache/sonic/decode-syseeprom/syseeprom_cache\"])", "    cmd1 = [\"ifconfig\", \"eth0\"]", "    cmd2 = [\"grep\", \"HWaddr\"]", "    print(getstatusoutput_noshell_pipe(cmd1, cmd2))"]}, {"diff": "\n \n def ipmi_set_mac(mac):\n     macs = mac.split(\":\")\n-    cmdinit = \"ipmitool raw 0x0c 0x01 0x01 0xc2 0x00\"\n-    cmdset = \"ipmitool raw 0x0c 0x01 0x01 0x05\"\n+    cmdinit = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0xc2\", \"0x00\"]\n+    cmdset = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0x05\"]\n     for ind in range(len(macs)):\n-        cmdset += \" 0x%02x\" % int(macs[ind], 16)\n-    rj_os_system(cmdinit)\n-    ret, status = rj_os_system(cmdset)\n+        cmdset.append(\"0x%02x\" % int(macs[ind], 16))\n+    getstatusoutput_noshell(cmdinit)\n+    ret, status = getstatusoutput_noshell(cmdset)\n     if ret:\n         RJPRINTERR(\"\\n\\n%s\\n\\n\" % status)\n         return False\n", "add": 5, "remove": 5, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    cmdinit = \"ipmitool raw 0x0c 0x01 0x01 0xc2 0x00\"", "    cmdset = \"ipmitool raw 0x0c 0x01 0x01 0x05\"", "        cmdset += \" 0x%02x\" % int(macs[ind], 16)", "    rj_os_system(cmdinit)", "    ret, status = rj_os_system(cmdset)"], "goodparts": ["    cmdinit = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0xc2\", \"0x00\"]", "    cmdset = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0x05\"]", "        cmdset.append(\"0x%02x\" % int(macs[ind], 16))", "    getstatusoutput_noshell(cmdinit)", "    ret, status = getstatusoutput_noshell(cmdset)"]}, {"diff": "\n     log_info(\"disable LLDP\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n-    rj_os_system(\"systemctl stop lldp.service\")\n+    getstatusoutput_noshell([\"systemctl\", \"stop\", \"lldp.service\"])\n     log_info(\"disable lldp service\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n-    rj_os_system(\"systemctl stop bgp.service\")\n+    getstatusoutput_noshell([\"systemctl\", \"stop\", \"bgp.service\"])\n     log_info(\"disable bgp service\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    rj_os_system(\"systemctl stop lldp.service\")", "    rj_os_system(\"systemctl stop bgp.service\")"], "goodparts": ["    getstatusoutput_noshell([\"systemctl\", \"stop\", \"lldp.service\"])", "    getstatusoutput_noshell([\"systemctl\", \"stop\", \"bgp.service\"])"]}, {"diff": "\n     with open(file_name, \"w\") as f:\n         f.write(file_data)\n     print(\"change SDK memory to 256, reboot required\")\n-    rj_os_system(\"sync\")\n-    rj_os_system(\"reboot\")\n+    getstatusoutput_noshell([\"sync\"])\n+    getstatusoutput_noshell([\"reboot\"])\n \n ##########################################################################\n # receives a character setting\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    rj_os_system(\"sync\")", "    rj_os_system(\"reboot\")"], "goodparts": ["    getstatusoutput_noshell([\"sync\"])", "    getstatusoutput_noshell([\"reboot\"])"]}, {"diff": "\n             return item.get('value',None)\n     return None\n \n-# ====================================\n-# execute shell command\n-# ====================================\n-def rj_os_system(cmd):\n-    status, output = subprocess.getstatusoutput(cmd)\n-    return status, output\n \n ###########################################\n # get memory slot and number via DMI command\n ###########################################\n def getsysmeminfo():\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \"|grep -P -A5 \\\"Memory\\s+Device\\\"|grep Size|grep -v Range\"\n+    cmd1 = [log[0].rstrip('\\n')]\n+    cmd2 = [\"grep\", \"-P\", \"-A5\", \"Memory\\s+Device\"]\n+    cmd3 = [\"grep\", \"Size\"]\n+    cmd4 = [\"grep\", \"-v\", \"Range\"]\n     # get total number first\n     result = []\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3, cmd4)\n     if ret1 == 0 and len(log1):\n         log1 = log1.lstrip()\n         arr = log1.split(\"\\n\")\n", "add": 6, "remove": 9, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["def rj_os_system(cmd):", "    status, output = subprocess.getstatusoutput(cmd)", "    return status, output", "    ret, log = rj_os_system(\"which dmidecode \")", "    cmd = log + \"|grep -P -A5 \\\"Memory\\s+Device\\\"|grep Size|grep -v Range\"", "    ret1, log1 = rj_os_system(cmd)"], "goodparts": ["    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])", "    cmd1 = [log[0].rstrip('\\n')]", "    cmd2 = [\"grep\", \"-P\", \"-A5\", \"Memory\\s+Device\"]", "    cmd3 = [\"grep\", \"Size\"]", "    cmd4 = [\"grep\", \"-v\", \"Range\"]", "    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3, cmd4)"]}, {"diff": "\n # return various arrays\n ###########################################\n def getsysmeminfo_detail():\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \" -t 17 | grep  -A21 \\\"Memory Device\\\"\"  # 17\n+    cmd1 = [log[0].rstrip('\\n')] + [\"-t\", \"17\"]\n+    cmd2 = [\"grep\", \"-A21\", \"Memory Device\"]  # 17\n     # get total number\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)\n     if ret1 != 0 or len(log1) <= 0:\n-        return False, \"command execution error[%s]\" % cmd\n+        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)\n     result_t = log1.split(\"--\")\n     mem_rets = []\n     for item in result_t:\n", "add": 5, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    ret, log = rj_os_system(\"which dmidecode \")", "    cmd = log + \" -t 17 | grep  -A21 \\\"Memory Device\\\"\"  # 17", "    ret1, log1 = rj_os_system(cmd)", "        return False, \"command execution error[%s]\" % cmd"], "goodparts": ["    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])", "    cmd1 = [log[0].rstrip('\\n')] + [\"-t\", \"17\"]", "    cmd2 = [\"grep\", \"-A21\", \"Memory Device\"]  # 17", "    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)", "        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)"]}, {"diff": "\n # get BIOS info via DMI command\n ###########################################\n def getDmiSysByType(type_t):\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \" -t %s\" % type_t\n+    cmd = [log[0].rstrip('\\n')] + [\"-t\", str(type_t)]\n     # get total number\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell(cmd)\n     if ret1 != 0 or len(log1) <= 0:\n         return False, \"command execution error[%s]\" % cmd\n     its = log1.replace(\"\\t\", \"\").strip().split(\"\\n\")\n", "add": 3, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    ret, log = rj_os_system(\"which dmidecode \")", "    cmd = log + \" -t %s\" % type_t", "    ret1, log1 = rj_os_system(cmd)"], "goodparts": ["    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])", "    cmd = [log[0].rstrip('\\n')] + [\"-t\", str(type_t)]", "    ret1, log1 = getstatusoutput_noshell(cmd)"]}, {"diff": "\n         return False, \"Err\"\n \n def get_cpu_info():\n-    cmd = \"cat /proc/cpuinfo |grep processor -A18\"  # 17\n+    cmd1 = [\"cat\", \"/proc/cpuinfo\"]\n+    cmd2 = [\"grep\", \"processor\", \"-A18\"]  # 17\n \n-    ret, log1 = rj_os_system(cmd)\n+    ret, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)\n     if ret != 0 or len(log1) <= 0:\n-        return False, \"command execution error[%s]\" % cmd\n+        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)\n     result_t = log1.split(\"--\")\n     mem_rets = []\n     for item in result_t:\n", "add": 4, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    cmd = \"cat /proc/cpuinfo |grep processor -A18\"  # 17", "    ret, log1 = rj_os_system(cmd)", "        return False, \"command execution error[%s]\" % cmd"], "goodparts": ["    cmd1 = [\"cat\", \"/proc/cpuinfo\"]", "    cmd2 = [\"grep\", \"processor\", \"-A18\"]  # 17", "    ret, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)", "        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)"]}]}}, "msg": "[ruijie] Replace os.system and remove subprocess with shell=True (#12107)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\nDependency: [https://github.com/sonic-net/sonic-buildimage/pull/12065](https://github.com/sonic-net/sonic-buildimage/pull/12065)\r\n#### Why I did it\r\n1. `getstatusoutput` is used without a static string and it uses `shell=True`\r\n2. `subprocess()` - when using with `shell=True` is dangerous. Using subprocess function without a static string can lead to command injection.\r\n3. `os` - not secure against maliciously constructed input and dangerous if used to evaluate dynamic content.\r\n#### How I did it\r\n1. use `getstatusoutput` without shell=True\r\n2. `subprocess()` - use `shell=False` instead. use an array string. Ref: [https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation](https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation)\r\n3. `os` - use with `subprocess`"}, "51a1eb112b8a3e00b4c5857afb470bb0e4d24433": {"url": "https://api.github.com/repos/SaranyaAzhgamuthaiyan/sonic-buildimage/commits/51a1eb112b8a3e00b4c5857afb470bb0e4d24433", "html_url": "https://github.com/SaranyaAzhgamuthaiyan/sonic-buildimage/commit/51a1eb112b8a3e00b4c5857afb470bb0e4d24433", "sha": "51a1eb112b8a3e00b4c5857afb470bb0e4d24433", "keyword": "command injection attack", "diff": "diff --git a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py\nindex 4b081f4e3..35c045dad 100644\n--- a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py\n+++ b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py\n@@ -24,7 +24,6 @@\n RESET_REGISTER = \"0x112\"\n HOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/previous-reboot-cause.txt\"\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n STATUS_LED_PATH = \"/sys/devices/platform/e1031.smc/master_led\"\n \n \ndiff --git a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py\nindex 08e8fc414..7d3b37e36 100644\n--- a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py\n+++ b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py\n@@ -1,8 +1,8 @@\n import os\r\n+import ast\r\n import imp\r\n import yaml\r\n import subprocess\r\n-\r\n from sonic_py_common import device_info\r\n \r\n \r\n@@ -24,7 +24,7 @@ class Common:\n \r\n     SET_METHOD_IPMI = 'ipmitool'\r\n     NULL_VAL = 'N/A'\r\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\r\n+    HOST_CHK_CMD = [\"docker\"]\r\n     REF_KEY = '$ref:'\r\n \r\n     def __init__(self, conf=None):\r\n@@ -46,8 +46,7 @@ def run_command(self, command):\n         status = False\r\n         output = \"\"\r\n         try:\r\n-            p = subprocess.Popen(\r\n-                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n+            p = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n             raw_data, err = p.communicate()\r\n             if p.returncode == 0:\r\n                 status, output = True, raw_data.strip()\r\n@@ -67,7 +66,7 @@ def _clean_input(self, input, config):\n             cleaned_input = input_translator.get(input)\r\n \r\n         elif type(input_translator) is str:\r\n-            cleaned_input = eval(input_translator.format(input))\r\n+            cleaned_input = ast.literal_eval(input_translator.format(input))\r\n \r\n         return cleaned_input\r\n \r\n@@ -77,19 +76,12 @@ def _clean_output(self, index, output, config):\n         if type(output_translator) is dict:\r\n             output = output_translator.get(output)\r\n         elif type(output_translator) is str:\r\n-            output = eval(output_translator.format(output))\r\n+            output = ast.literal_eval(output_translator.format(output))\r\n         elif type(output_translator) is list:\r\n-            output = eval(output_translator[index].format(output))\r\n+            output = ast.literal_eval(output_translator[index].format(output))\r\n \r\n         return output\r\n \r\n-    def _ipmi_get(self, index, config):\r\n-        argument = config.get('argument')\r\n-        cmd = config['command'].format(\r\n-            config['argument'][index]) if argument else config['command']\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n-\r\n     def _sysfs_read(self, index, config):\r\n         sysfs_path = config.get('sysfs_path')\r\n         argument = config.get('argument', '')\r\n@@ -132,10 +124,6 @@ def _sysfs_write(self, index, config, input):\n             return False, output\r\n         return True, output\r\n \r\n-    def _ipmi_set(self, index, config, input):\r\n-        arg = config['argument'][index].format(input)\r\n-        return self.run_command(config['command'].format(arg))\r\n-\r\n     def _hex_ver_decode(self, hver, num_of_bits, num_of_points):\r\n         ver_list = []\r\n         c_bit = 0\r\n@@ -159,14 +147,16 @@ def _get_class(self, config):\n         return class_\r\n \r\n     def get_reg(self, path, reg_addr):\r\n-        cmd = \"echo {1} > {0}; cat {0}\".format(path, reg_addr)\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n+        with open(path, 'w') as file:\r\n+            file.write(reg_addr + '\\n')\r\n+        with open(path, 'r') as file:\r\n+            output = file.readline().strip()\r\n+        return output\r\n \r\n     def set_reg(self, path, reg_addr, value):\r\n-        cmd = \"echo {0} {1} > {2}\".format(reg_addr, value, path)\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n+        with open(path, 'w') as file:\r\n+            file.write(\"{0} {1}\\n\".format(reg_addr, value))\r\n+        return None\r\n \r\n     def read_txt_file(self, path):\r\n         try:\r\n@@ -195,7 +185,11 @@ def write_txt_file(self, file_path, value):\n         return True\r\n \r\n     def is_host(self):\r\n-        return os.system(self.HOST_CHK_CMD) == 0\r\n+        try:\r\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\r\n+        except FileNotFoundError:\r\n+            return False\r\n+        return True\r\n \r\n     def load_json_file(self, path):\r\n         \"\"\"\r\n@@ -221,87 +215,6 @@ def get_config_path(self, config_name):\n         \"\"\"\r\n         return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\r\n \r\n-    def get_output(self, index, config, default):\r\n-        \"\"\"\r\n-        Retrieves the output for each function base on config\r\n-\r\n-        Args:\r\n-            index: An integer containing the index of device.\r\n-            config: A dict object containing the configuration of specified function.\r\n-            default: A string containing the default output of specified function.\r\n-\r\n-        Returns:\r\n-            A string containing the output of specified function in config\r\n-        \"\"\"\r\n-        output_source = config.get('output_source')\r\n-\r\n-        if output_source == self.OUTPUT_SOURCE_IPMI:\r\n-            output = self._ipmi_get(index, config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VALUE:\r\n-            output = config[\"value\"]\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_CLASS:\r\n-            output = self._get_class(config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_LIST:\r\n-            output = config[\"value_list\"][index]\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_SYSFS:\r\n-            output = self._sysfs_read(index, config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_FUNC:\r\n-            func_conf = self._main_conf[config['function'][index]]\r\n-            output = self.get_output(index, func_conf, default)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\r\n-            path = config.get('path')\r\n-            output = self.read_txt_file(path)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\r\n-            path = config.get('path')\r\n-            hex_ver = self.read_txt_file(path)\r\n-            output = self._hex_ver_decode(\r\n-                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\r\n-            path = config.get('path')\r\n-            addr = config.get('reg_addr')\r\n-            hex_ver = self.get_reg(path, addr)\r\n-            output = self._hex_ver_decode(\r\n-                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n-\r\n-        else:\r\n-            output = default\r\n-\r\n-        return self._clean_output(index, output, config) or default\r\n-\r\n-    def set_output(self, index, input, config):\r\n-        \"\"\"\r\n-        Sets the output of specified function on config\r\n-\r\n-        Args:\r\n-            config: A dict object containing the configuration of specified function.\r\n-            index: An integer containing the index of device.\r\n-            input: A string containing the input of specified function.\r\n-\r\n-        Returns:\r\n-            bool: True if set function is successfully, False if not\r\n-        \"\"\"\r\n-        cleaned_input = self._clean_input(input, config)\r\n-        if not cleaned_input:\r\n-            return False\r\n-\r\n-        set_method = config.get('set_method')\r\n-        if set_method == self.SET_METHOD_IPMI:\r\n-            output = self._ipmi_set(index, config, cleaned_input)[0]\r\n-        elif set_method == self.OUTPUT_SOURCE_SYSFS:\r\n-            output = self._sysfs_write(index, config, cleaned_input)[0]\r\n-        else:\r\n-            output = False\r\n-\r\n-        return output\r\n-\r\n     def get_event(self, timeout, config, sfp_list):\r\n         \"\"\"\r\n         Returns a nested dictionary containing all devices which have\r\ndiff --git a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py\nindex 56fae3591..6e33e3340 100644\n--- a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py\n+++ b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py\n@@ -10,7 +10,6 @@\n try:\n     import os.path\n     import shutil\n-    import shlex\n     import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n except ImportError as e:\n@@ -39,8 +38,7 @@ def __init__(self, component_index):\n     def __run_command(self, command):\n         # Run bash command and print output to stdout\n         try:\n-            process = subprocess.Popen(\n-                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n+            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n             while True:\n                 output = process.stdout.readline()\n                 if output == '' and process.poll() is not None:\n@@ -63,12 +61,10 @@ def __get_bios_version(self):\n \n     def get_register_value(self, register):\n         # Retrieves the cpld register value\n-        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n-        p = subprocess.Popen(\n-            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-        raw_data, err = p.communicate()\n-        if err is not '':\n-            return None\n+        with open(GETREG_PATH, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(GETREG_PATH, 'r') as file:\n+            raw_data = file.readline()\n         return raw_data.strip()\n \n     def __get_cpld_version(self):\n@@ -76,11 +72,11 @@ def __get_cpld_version(self):\n         cpld_version = dict()\n         with open(SMC_CPLD_PATH, 'r') as fd:\n             smc_cpld_version = fd.read()\n-        smc_cpld_version = 'None' if smc_cpld_version is 'None' else \"{}.{}\".format(\n+        smc_cpld_version = 'None' if smc_cpld_version == 'None' else \"{}.{}\".format(\n             int(smc_cpld_version[2], 16), int(smc_cpld_version[3], 16))\n \n         mmc_cpld_version = self.get_register_value(MMC_CPLD_ADDR)\n-        mmc_cpld_version = 'None' if mmc_cpld_version is 'None' else \"{}.{}\".format(\n+        mmc_cpld_version = 'None' if mmc_cpld_version == 'None' else \"{}.{}\".format(\n             int(mmc_cpld_version[2], 16), int(mmc_cpld_version[3], 16))\n \n         cpld_version[\"SMC_CPLD\"] = smc_cpld_version\n@@ -159,7 +155,7 @@ def install_firmware(self, image_path):\n             ext = \".vme\" if ext == \"\" else ext\n             new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n             shutil.copy(image_path, new_image_path)\n-            install_command = \"ispvm %s\" % new_image_path\n+            install_command = [\"ispvm\", str(new_image_path)]\n         # elif self.name == \"BIOS\":\n         #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n         return self.__run_command(install_command)\ndiff --git a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py\nindex 75307d291..144fdae21 100644\n--- a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py\n+++ b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py\n@@ -73,6 +73,5 @@ def execute(self, thermal_info_dict):\n         thermal_overload_position = Common().read_txt_file(\r\n             thermal_overload_position_path)\r\n \r\n-        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\r\n-            thermal_overload_position)\r\n+        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', thermal_overload_position]\r\n         Common().run_command(cmd)\r\ndiff --git a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py\nindex 2e379f8c2..28e113fb7 100644\n--- a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py\n+++ b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py\n@@ -6,7 +6,7 @@\n \n \n class ThermalManager(ThermalManagerBase):\n-    FSC_ALGORITHM_CMD = ' supervisorctl {} fancontrol'\n+    FSC_ALGORITHM_CMD = ['supervisorctl', '', 'fancontrol']\n \n     @classmethod\n     def start_thermal_control_algorithm(cls):\n@@ -43,5 +43,5 @@ def _enable_fancontrol_service(cls, enable):\n         Returns:\n             bool: True if set success, False if fail.\n         \"\"\"\n-        cmd = 'start' if enable else 'stop'\n-        return Common().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n+        cls.FSC_ALGORITHM_CMD[1] = 'start' if enable else 'stop'\n+        return Common().run_command(cls.FSC_ALGORITHM_CMD)\ndiff --git a/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py b/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py\nindex 0c93576e1..13c19841e 100644\n--- a/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py\n+++ b/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py\n@@ -6,8 +6,6 @@\n #\n #############################################################################\n \n-import os.path\n-import subprocess\n \n try:\n     from sonic_psu.psu_base import PsuBase\ndiff --git a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py\nindex 8a9ed1713..2fc2c60fd 100644\n--- a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py\n+++ b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py\n@@ -26,7 +26,6 @@\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n GETREG_PATH = \"/sys/devices/platform/dx010_cpld/getreg\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n STATUS_LED_PATH = \"/sys/devices/platform/leds_dx010/leds/dx010:green:stat/brightness\"\n \n \ndiff --git a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py\nindex 782708025..da735d2ac 100644\n--- a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py\n+++ b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py\n@@ -8,7 +8,6 @@\n \n import os.path\n import shutil\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -52,12 +51,10 @@ def __get_bios_version(self):\n \n     def get_register_value(self, register):\n         # Retrieves the cpld register value\n-        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n-        p = subprocess.Popen(\n-            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-        raw_data, err = p.communicate()\n-        if err is not '':\n-            return None\n+        with open(GETREG_PATH, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(GETREG_PATH, 'r') as file:\n+            raw_data = file.readline()\n         return raw_data.strip()\n \n     def __get_cpld_version(self):\n@@ -146,11 +143,11 @@ def install_firmware(self, image_path):\n             ext = \".vme\" if ext == \"\" else ext\n             new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n             shutil.copy(image_path, new_image_path)\n-            install_command = \"ispvm %s\" % new_image_path\n+            install_command = [\"ispvm\", str(new_image_path)]\n         # elif self.name == \"BIOS\":\n         #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n \n-        return self.__run_command(install_command)\n+        return self._api_helper.run_command(install_command)\n \n \n     def update_firmware(self, image_path):\ndiff --git a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py\nindex 140c62c08..a77d27837 100644\n--- a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py\n+++ b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py\n@@ -5,7 +5,7 @@\n \n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -15,7 +15,11 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -35,7 +39,7 @@ def run_command(self, cmd):\n         result = \"\"\n         try:\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = raw_data.strip()\n@@ -43,13 +47,6 @@ def run_command(self, cmd):\n             status = False\n         return status, result\n \n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n@@ -77,57 +74,9 @@ def write_txt_file(self, file_path, value):\n         return True\n \n     def get_cpld_reg_value(self, getreg_path, register):\n-        cmd = \"echo {1} > {0}; cat {0}\".format(getreg_path, register)\n-        status, result = self.run_command(cmd)\n-        return result if status else None\n+        with open(getreg_path, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(getreg_path, 'r') as file:\n+            result = file.readline()\n+        return result\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(\n-                str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status, result\ndiff --git a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py\nindex 545db861f..fc55445d0 100644\n--- a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py\n+++ b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py\n@@ -73,6 +73,5 @@ def execute(self, thermal_info_dict):\n         thermal_overload_position = APIHelper().read_one_line_file(\n             thermal_overload_position_path)\n \n-        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\n-            thermal_overload_position)\n+        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', str(thermal_overload_position)]\n         APIHelper().run_command(cmd)\ndiff --git a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py\nindex 9f057cf1f..dfd4abc40 100644\n--- a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py\n+++ b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py\n@@ -5,7 +5,7 @@\n from .thermal_infos import *\n \n class ThermalManager(ThermalManagerBase):\n-    FSC_ALGORITHM_CMD = 'service fancontrol {}'\n+    FSC_ALGORITHM_CMD = ['service', 'fancontrol', '']\n \n     @classmethod\n     def start_thermal_control_algorithm(cls):\n@@ -42,5 +42,5 @@ def _enable_fancontrol_service(cls, enable):\n         Returns:\n             bool: True if set success, False if fail.\n         \"\"\"\n-        cmd = 'start' if enable else 'stop'\n-        return APIHelper().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n+        cls.FSC_ALGORITHM_CMD[2] = 'start' if enable else 'stop'\n+        return APIHelper().run_command(cls.FSC_ALGORITHM_CMD)\ndiff --git a/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py b/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py\nindex cc5461ccb..2eb92eb91 100644\n--- a/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py\n+++ b/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py\n@@ -1,10 +1,9 @@\n-import os.path\n-import subprocess\n import sys\n import re\n \n try:\n     from sonic_psu.psu_base import PsuBase\n+    from sonic_py_common.general import getstatusoutput_noshell_pipe\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -13,16 +12,16 @@ class PsuUtil(PsuBase):\n     \"\"\"Platform-specific PSUutil class\"\"\"\n \n     def __init__(self):\n-        self.ipmi_sensor = \"ipmitool sensor\"\n+        self.ipmi_sensor = [\"ipmitool\", \"sensor\"]\n         PsuBase.__init__(self)\n \n-    def run_command(self, command):\n-        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n-        (out, err) = proc.communicate()\n-\n-        if proc.returncode != 0:\n-            sys.exit(proc.returncode)\n-\n+    def run_command(self, cmd1, cmd2):\n+        exitcode, out = getstatusoutput_noshell_pipe(cmd1, cmd2)\n+        i = 0\n+        while i < 2:\n+            if exitcode[i] != 0:\n+                sys.exit(exitcode[i])\n+            i += 1\n         return out\n \n     def find_value(self, grep_string):\n@@ -50,7 +49,8 @@ def get_psu_status(self, index):\n             return False\n \n         grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n-        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n+        grep_cmd = [\"grep\", grep_key]\n+        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)\n         status_byte = self.find_value(grep_string)\n \n         if status_byte is None:\n@@ -74,7 +74,8 @@ def get_psu_presence(self, index):\n             return False\n \n         grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n-        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n+        grep_cmd = [\"grep\", grep_key]\n+        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)\n         status_byte = self.find_value(grep_string)\n \n         if status_byte is None:\ndiff --git a/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py b/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py\nindex ca75ad983..46684aae0 100644\n--- a/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py\n+++ b/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py\n@@ -1,4 +1,3 @@\n-import os.path\n import subprocess\n import sys\n import re\n@@ -13,13 +12,13 @@ class PsuUtil(PsuBase):\n     \"\"\"Platform-specific PSUutil class\"\"\"\n \n     def __init__(self):\n-        self.ipmi_raw = \"docker exec -ti pmon ipmitool raw 0x4 0x2d\"\n+        self.ipmi_raw = [\"docker\", \"exec\", \"-ti\", \"pmon\", \"ipmitool\", \"raw\", \"0x4\", \"0x2d\", \"\"]\n         self.psu1_id = \"0x2f\"\n         self.psu2_id = \"0x39\"\n         PsuBase.__init__(self)\n \n     def run_command(self, command):\n-        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n         (out, err) = proc.communicate()\n \n         if proc.returncode != 0:\n@@ -52,7 +51,8 @@ def get_psu_status(self, index):\n             return False\n \n         psu_id = self.psu1_id if index == 1 else self.psu2_id\n-        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n+        self.ipmi_raw[8] = psu_id\n+        res_string = self.run_command(self.ipmi_raw)\n         status_byte = self.find_value(res_string)\n \n         if status_byte is None:\n@@ -76,7 +76,8 @@ def get_psu_presence(self, index):\n             return False\n \n         psu_id = self.psu1_id if index == 1 else self.psu2_id\n-        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n+        self.ipmi_raw[8] = psu_id\n+        res_string = self.run_command(self.ipmi_raw)\n         status_byte = self.find_value(res_string)\n \n         if status_byte is None:\ndiff --git a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py\nindex bbbb9f1d4..ba7742c66 100644\n--- a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py\n+++ b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py\n@@ -6,7 +6,6 @@\n #\n #############################################################################\n \n-import json\n import os.path\n \n try:\n@@ -24,14 +23,18 @@\n ]\n SW_CPLD_VER_PATH = \"/sys/module/switch_cpld/version\"\n BASE_CPLD_VER_PATH = \"/sys/module/baseboard_lpc/version\"\n-CPLD_UPGRADE_OPT = 4\n BIOS_VER_PATH = \"/sys/class/dmi/id/bios_version\"\n-BIOS__UPGRADE_OPT = 2\n-BMC_VER_CMD = \"ipmitool mc info | grep 'Firmware Revision'\"\n-BMC_UPGRADE_OPT = 1\n-CFUFLASH_FW_UPGRADE_CMD = \"CFUFLASH -cd -d {} -mse 3 {}\"\n+BMC_VER_CMD1 = [\"ipmitool\", \"mc\", \"info\"]\n+BMC_VER_CMD2 = [\"grep\", \"Firmware Revision\"]\n+CFUFLASH_FW_UPGRADE_CMD = [\"CFUFLASH\", \"-cd\", \"-d\", \"\", \"-mse\", \"3\", \"\"]\n MEM_PCI_RESOURCE = \"/sys/bus/pci/devices/0000:09:00.0/resource0\"\n FPGA_VER_MEM_OFFSET = 0\n+UPGRADE_OPT = {\n+    'BMC': '1',\n+    'BIOS': '2',\n+    'SWITCH_CPLD': '4',\n+    'BASE_CPLD': '4'\n+}\n \n \n class Component(ComponentBase):\n@@ -47,7 +50,7 @@ def __init__(self, component_index):\n \n     def __get_bmc_ver(self):\n         bmc_ver = \"Unknown\"\n-        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD)\n+        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD1, BMC_VER_CMD2)\n         if status:\n             bmc_ver_data = raw_bmc_data.split(\":\")\n             bmc_ver = bmc_ver_data[-1].strip() if len(\n@@ -104,16 +107,12 @@ def install_firmware(self, image_path):\n         Returns:\n             A boolean, True if install successfully, False if not\n         \"\"\"\n-        install_command = {\n-            \"BMC\": CFUFLASH_FW_UPGRADE_CMD.format(BMC_UPGRADE_OPT, image_path),\n-            \"BIOS\": CFUFLASH_FW_UPGRADE_CMD.format(BIOS__UPGRADE_OPT, image_path),\n-            \"SWITCH_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path),\n-            \"BASE_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path)\n-        }.get(self.name, None)\n-\n-        if not os.path.isfile(image_path) or install_command is None:\n+        CFUFLASH_FW_UPGRADE_CMD[3] = UPGRADE_OPT.get(self.name)\n+        CFUFLASH_FW_UPGRADE_CMD[6] = image_path\n+\n+        if not os.path.isfile(image_path):\n             return False\n \n         # print(install_command)\n-        status = self._api_helper.run_interactive_command(install_command)\n+        status = self._api_helper.run_interactive_command(CFUFLASH_FW_UPGRADE_CMD)\n         return status\ndiff --git a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py\nindex 144d9e154..d53de841e 100644\n--- a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py\n+++ b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py\n@@ -2,8 +2,9 @@\n import struct\n import subprocess\n from mmap import *\n+from sonic_py_common.general import check_output_pipe\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -13,7 +14,11 @@ def __init__(self):\n         pass\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -28,22 +33,18 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n+    def run_command(self, cmd1_args, cmd2_args):\n         status = True\n         result = \"\"\n         try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except:\n+            result = check_output_pipe(cmd1_args, cmd2_args)\n+        except subprocess.CalledProcessError:\n             status = False\n         return status, result\n \n     def run_interactive_command(self, cmd):\n         try:\n-            os.system(cmd)\n+            subprocess.call(cmd)\n         except:\n             return False\n         return True\n@@ -61,9 +62,9 @@ def ipmi_raw(self, netfn, cmd):\n         status = True\n         result = \"\"\n         try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n+            cmd = [\"ipmitool\", \"raw\", str(netfn), str(cmd)]\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = raw_data.strip()\n@@ -76,28 +77,30 @@ def ipmi_raw(self, netfn, cmd):\n     def ipmi_fru_id(self, id, key=None):\n         status = True\n         result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n+        cmd1_args = [\"ipmitool\", \"fru\", \"print\", str(id)]\n+        if not key:\n+            try:\n+                p = subprocess.Popen(\n+                    cmd1_args, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                raw_data, err = p.communicate()\n+                if err == '':\n+                    result = raw_data.strip()\n+                else:\n+                    status = False\n+            except:\n                 status = False\n-        except:\n-            status = False\n+        else:\n+            cmd2_args = [\"grep\", str(key)]\n+            status, result = self.run_command(cmd1_args, cmd2_args)\n         return status, result\n \n     def ipmi_set_ss_thres(self, id, threshold_key, value):\n         status = True\n         result = \"\"\n         try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n+            cmd = [\"ipmitool\", \"sensor\", \"thresh\", str(id), str(threshold_key), str(value)]\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = raw_data.strip()\ndiff --git a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py\nindex 9ad0f1dc9..a6c805d3c 100644\n--- a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py\n+++ b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py\n@@ -33,20 +33,15 @@\n PSU_LED_GREEN_CMD = \"0x01\"\n PSU_LED_AMBER_CMD = \"0x02\"\n \n-PSU1_VOUT_SS_ID = \"0x36\"\n-PSU1_COUT_SS_ID = \"0x37\"\n-PSU1_POUT_SS_ID = \"0x38\"\n-PSU1_STATUS_REG = \"0x39\"\n-\n-PSU2_VOUT_SS_ID = \"0x40\"\n-PSU2_COUT_SS_ID = \"0x41\"\n-PSU2_POUT_SS_ID = \"0x42\"\n-PSU2_STATUS_REG = \"0x2f\"\n-\n PSU1_FRU_ID = 3\n \n SS_READ_OFFSET = 0\n \n+PSU_VOUT_SS_ID = [\"0x36\", \"0x40\"]\n+PSU_COUT_SS_ID = [\"0x37\", \"0x41\"]\n+PSU_POUT_SS_ID = [\"0x38\", \"0x42\"]\n+PSU_STATUS_REG = [\"0x39\", \"0x2f\"]\n+\n \n class Psu(PsuBase):\n     \"\"\"Platform-specific Psu class\"\"\"\n@@ -71,7 +66,7 @@ def get_voltage(self):\n             e.g. 12.1\n         \"\"\"\n         psu_voltage = 0.0\n-        psu_vout_key = globals()['PSU{}_VOUT_SS_ID'.format(self.index+1)]\n+        psu_vout_key = PSU_VOUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_vout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n@@ -87,7 +82,7 @@ def get_current(self):\n             A float number, the electric current in amperes, e.g 15.4\n         \"\"\"\n         psu_current = 0.0\n-        psu_cout_key = globals()['PSU{}_COUT_SS_ID'.format(self.index+1)]\n+        psu_cout_key = PSU_COUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_cout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n@@ -103,7 +98,7 @@ def get_power(self):\n             A float number, the power in watts, e.g. 302.6\n         \"\"\"\n         psu_power = 0.0\n-        psu_pout_key = globals()['PSU{}_POUT_SS_ID'.format(self.index+1)]\n+        psu_pout_key = PSU_POUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n@@ -176,7 +171,7 @@ def get_presence(self):\n             bool: True if PSU is present, False if not\n         \"\"\"\n         psu_presence = False\n-        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n+        psu_pstatus_key = PSU_STATUS_REG[self.index]\n         status, raw_status_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n         status_byte = self.find_value(raw_status_read)\n@@ -228,7 +223,7 @@ def get_status(self):\n             A boolean value, True if device is operating properly, False if not\n         \"\"\"\n         psu_status = False\n-        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n+        psu_pstatus_key = PSU_STATUS_REG[self.index]\n         status, raw_status_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n         status_byte = self.find_value(raw_status_read)\ndiff --git a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py\nindex c22c7a9b7..4ad97b42f 100644\n--- a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py\n+++ b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py\n@@ -6,7 +6,6 @@\n #\n #############################################################################\n \n-import os\n import time\n import subprocess\n from ctypes import create_string_buffer\n@@ -168,7 +167,7 @@ class Sfp(SfpBase):\n     # Path to QSFP sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-cel_silverstone-r0\"\n     HWSKU = \"Silverstone\"\n@@ -270,7 +269,11 @@ def __convert_string_to_num(self, value_str):\n             return 'N/A'\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py b/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py\nindex e4f3e1257..7fee0aee5 100644\n--- a/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py\n+++ b/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py\n@@ -8,19 +8,18 @@\n #\r\n #############################################################################\r\n \r\n-import os.path\r\n import subprocess\r\n-import time\r\n-import os\r\n \r\n try:\r\n     from sonic_platform_base.component_base import ComponentBase\r\n+    from sonic_py_common.general import getstatusoutput_noshell_pipe\r\n     #from helper import APIHelper\r\n except ImportError as e:\r\n     raise ImportError(str(e) + \"- required module not found\")\r\n \r\n-SWCPLD_VERSION_PATH = \"i2cget -y -f 2 0x32 0\"\r\n-BIOS_VERSION_PATH = \"dmidecode -t bios | grep Version\"\r\n+SWCPLD_VERSION_PATH = [\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0\"]\r\n+BIOS_VERSION_PATH_CMD1 = [\"dmidecode\", \"-t\", \"bios\"]\r\n+BIOS_VERSION_PATH_CMD2 = [\"grep\", \"Version\"]\r\n COMPONENT_NAME_LIST = [\"SWCPLD\", \"Main_BIOS\", \"Backup_BIOS\"]\r\n COMPONENT_DES_LIST = [\"Use for boot control and BIOS switch\",\r\n                       \"Main basic Input/Output System\",\r\n@@ -39,15 +38,15 @@ def __init__(self, component_index):\n         self.name = self.get_name()\r\n \r\n     def run_command(self,cmd):\r\n-        responses = os.popen(cmd).read()\r\n+        responses = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()\r\n         return responses\r\n \r\n     def __get_bios_version(self):\r\n         # Retrieves the BIOS firmware version\r\n-        result = self.run_command(\"i2cget -y -f 2 0x32 0x19\")\r\n+        result = self.run_command([\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0x19\"])\r\n         if result.strip() == \"0x01\":\r\n             if self.name == \"Main_BIOS\":\r\n-                version = self.run_command(BIOS_VERSION_PATH)\r\n+                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r\n                 bios_version = version.strip().split(\" \")[1]\r\n                 return str(bios_version)\r\n             elif self.name == \"Backup_BIOS\":\r\n@@ -56,7 +55,7 @@ def __get_bios_version(self):\n                 \r\n         elif result.strip() == \"0x03\":\r\n             if self.name == \"Backup_BIOS\":\r\n-                version = self.run_command(BIOS_VERSION_PATH)\r\n+                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r\n                 bios_version = version.strip().split(\" \")[1]\r\n                 return str(bios_version)\r\n             elif self.name == \"Main_BIOS\":\r\ndiff --git a/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py b/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py\nindex 36e95f2c0..d5ee08049 100644\n--- a/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py\n+++ b/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py\n@@ -1,6 +1,6 @@\n try:\n     from sonic_platform_pddf_base.pddf_fan import PddfFan\n-    import os\n+    import subprocess\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n # ------------------------------------------------------------------\n@@ -47,8 +47,9 @@ def get_direction(self):\n         \"\"\"\n         if self.is_psu_fan:\n             cmd_num = \"58\" if self.fans_psu_index == 1 else \"59\"\n-            cmd = \"i2cget -y -f 4 0x%s 0x80\" % cmd_num\n-            res = os.popen(cmd).read()\n+            cmd = [\"i2cget\", \"-y\", \"-f\", \"4\", \"\", \"0x80\"]\n+            cmd[4] = \"0x\" + cmd_num\n+            res = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()\n             # F2B \n             if res.strip() == \"0x01\":\n                 direction = \"EXHAUST\"\ndiff --git a/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py b/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py\nindex 017a04709..5ce0469a0 100755\n--- a/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py\n@@ -23,13 +23,13 @@\n try:\n     import sys\n     import getopt\n-    import subprocess\n     import logging\n     import logging.config\n     import time  # this is only being used as part of the example\n     import signal\n     import math\n     from sonic_platform import platform\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n@@ -224,7 +224,7 @@ def handler(signum, frame):\n         else:\n             logging.debug('INFO: FAIL. set_fan_duty_cycle (%d)' % DUTY_MAX)\n         # Enable the CPLD Heartbeat back\n-        status, output = subprocess.getstatusoutput('i2cset -f -y 75 0x40 0x22 0x00')\n+        status, output = getstatusoutput_noshell([\"i2cset\", \"-f\", \"-y\", \"75\", \"0x40\", \"0x22\", \"0x00\"])\n         if status == 0:\n             logging.debug('INFO: CPLD Heartbeat check is enabled back')\n     sys.exit(0)\n@@ -258,7 +258,7 @@ def main(argv):\n     signal.signal(signal.SIGINT, handler)\n     signal.signal(signal.SIGTERM, handler)\n     # Disaable the CPLD Heartbeat check to control Fan speed from CPU via ADT7470\n-    subprocess.getstatusoutput('i2cset -f -y 2 0x32 0x30 0x01')\n+    getstatusoutput_noshell(['i2cset', '-f', '-y', '2', '0x32', '0x30', '0x01'])\n \n     monitor = cel_belgite_monitor(log_file, log_level)\n \ndiff --git a/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py b/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py\nindex 697308b8c..2d9683599 100644\n--- a/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py\n+++ b/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py\n@@ -1,4 +1,5 @@\n import os\n+import ast\n import imp\n import yaml\n import subprocess\n@@ -24,7 +25,7 @@ class Common:\n \n     SET_METHOD_IPMI = 'ipmitool'\n     NULL_VAL = 'N/A'\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n     REF_KEY = '$ref:'\n \n     def __init__(self, conf=None):\n@@ -56,7 +57,7 @@ def _clean_input(self, input, config):\n             cleaned_input = input_translator.get(input)\n \n         elif type(input_translator) is str:\n-            cleaned_input = eval(input_translator.format(input))\n+            cleaned_input = ast.literal_eval(input_translator.format(input))\n \n         return cleaned_input\n \n@@ -66,9 +67,9 @@ def _clean_output(self, index, output, config):\n         if type(output_translator) is dict:\n             output = output_translator.get(output)\n         elif type(output_translator) is str:\n-            output = eval(output_translator.format(output))\n+            output = ast.literal_eval(output_translator.format(output))\n         elif type(output_translator) is list:\n-            output = eval(output_translator[index].format(output))\n+            output = ast.literal_eval(output_translator[index].format(output))\n \n         return output\n \n@@ -166,7 +167,11 @@ def write_txt_file(self, file_path, value):\n         return True\n \n     def is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def load_json_file(self, path):\n         \"\"\"\ndiff --git a/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py b/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py\nindex 186ee6c54..1aa1c0719 100755\n--- a/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py\n+++ b/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py\n@@ -12,7 +12,7 @@\n import logging\n import subprocess\n \n-IPMI_SDR_CMD = \"ipmitool sdr elist\"\n+IPMI_SDR_CMD = [\"ipmitool\", \"sdr\", \"elist\"]\n MAX_NUM_FANS = 7\n MAX_NUM_PSUS = 2\n \n@@ -23,7 +23,7 @@ def ipmi_sensor_dump(cmd):\n     '''\n     sensor_dump = ''\n     try:\n-        sensor_dump = subprocess.check_output(cmd, shell=True)\n+        sensor_dump = subprocess.check_output(cmd)\n     except subprocess.CalledProcessError as e:\n         logging.error('Error! Failed to execute: {}'.format(cmd))\n         sys.exit(1)\n", "message": "", "files": {"/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n RESET_REGISTER = \"0x112\"\n HOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/previous-reboot-cause.txt\"\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n STATUS_LED_PATH = \"/sys/devices/platform/e1031.smc/master_led\"\n \n ", "add": 0, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": []}], "source": "\n try: from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper from sonic_platform_base.chassis_base import ChassisBase from sonic_py_common import device_info from.common import Common from.event import SfpEvent except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=3 NUM_PSU=2 NUM_THERMAL=7 NUM_SFP=55 NUM_COMPONENT=3 RESET_REGISTER=\"0x112\" HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/previous-reboot-cause.txt\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/previous-reboot-cause.txt\" HOST_CHK_CMD=\"docker > /dev/null 2>&1\" STATUS_LED_PATH=\"/sys/devices/platform/e1031.smc/master_led\" class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_common=Common() self._is_host=self._api_common.is_host() self.__initialize_eeprom() self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.sfp_module_initialized=False self._reboot_cause_path=HOST_REBOOT_CAUSE_PATH if self._is_host else PMON_REBOOT_CAUSE_PATH def __initialize_sfp(self): sfputil_helper=SfpUtilHelper() port_config_file_path=device_info.get_path_to_port_config_file() sfputil_helper.read_porttab_mappings(port_config_file_path, 0) from.sfp import Sfp for index in range(0, NUM_SFP): sfp=Sfp(index, sfputil_helper.logical[index]) self._sfp_list.append(sfp) self.sfp_module_initialized=True def __initialize_psu(self): from.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_fan(self): from.fan_drawer import FanDrawer for i in range(NUM_FAN_TRAY): fandrawer=FanDrawer(i) self._fan_drawer_list.append(fandrawer) self._fan_list +=fandrawer.get_all_fans() def __initialize_thermals(self): from.thermal import Thermal airflow=self.__get_air_flow() for index in range(0, NUM_THERMAL): thermal=Thermal(index, airflow) self._thermal_list.append(thermal) def __initialize_eeprom(self): from.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __get_air_flow(self): air_flow_path='/usr/share/sonic/device/{}/fan_airflow'.format( self._api_common.get_platform()) if self._is_host else '/usr/share/sonic/platform/fan_airflow' air_flow=self._api_common.read_txt_file(air_flow_path) return air_flow or 'B2F' def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_serial_number(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" description='None' reboot_cause=self.REBOOT_CAUSE_HARDWARE_OTHER hw_reboot_cause=self._component_list[0].get_register_value( RESET_REGISTER) sw_reboot_cause=self._api_common.read_txt_file( self._reboot_cause_path) or \"Unknown\" if hw_reboot_cause==\"0x55\": reboot_cause=self.REBOOT_CAUSE_NON_HARDWARE description=sw_reboot_cause elif hw_reboot_cause==\"0x11\": reboot_cause=self.REBOOT_CAUSE_POWER_LOSS elif hw_reboot_cause==\"0x33\": reboot_cause=self.REBOOT_CAUSE_WATCHDOG elif hw_reboot_cause==\"0x88\": reboot_cause=self.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU elif hw_reboot_cause==\"0x99\": reboot_cause=self.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC else: reboot_cause=self.REBOOT_CAUSE_NON_HARDWARE description='Unknown reason' return(reboot_cause, description) def get_watchdog(self): \"\"\" Retreives hardware watchdog device on this chassis Returns: An object derived from WatchdogBase representing the hardware watchdog device \"\"\" if self._watchdog is None: from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() return self._watchdog def get_change_event(self, timeout=0): \"\"\" Returns a nested dictionary containing all devices which have experienced a change at chassis level Args: timeout: Timeout in milliseconds(optional). If timeout==0, this method will block until a change is detected. Returns: (bool, dict): -True if call successful, False if not; -A nested dictionary where key is a device type, value is a dictionary with key:value pairs in the format of {'device_id':'device_event'}, where device_id is the device ID for this device and device_event, status='1' represents device inserted, status='0' represents device removed. Ex.{'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}} indicates that fan 0 has been removed, fan 2 has been inserted and sfp 11 has been removed. \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() sfp_event=SfpEvent(self._sfp_list).get_sfp_event(timeout) if sfp_event: return True,{'sfp': sfp_event} return False,{'sfp':{}} def get_num_sfps(self): \"\"\" Retrieves the number of sfps available on this chassis Returns: An integer, the number of sfps available on this chassis \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() return len(self._sfp_list) def get_all_sfps(self): \"\"\" Retrieves all sfps available on this chassis Returns: A list of objects derived from SfpBase representing all sfps available on this chassis \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfp_list def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() return super(Chassis, self).get_sfp(index -1) def get_thermal_manager(self): from.thermal_manager import ThermalManager return ThermalManager def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._api_common.get_hwsku() def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return self.get_serial_number() def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def set_status_led(self, color): \"\"\" Sets the state of the PSU status LED Args: color: A string representing the color with which to set the PSU status LED Note: Only support green and off Returns: bool: True if status LED state is set successfully, False if not \"\"\" status_str={ self.STATUS_LED_COLOR_GREEN: 'green', self.STATUS_LED_COLOR_AMBER: 'amber', self.STATUS_LED_COLOR_OFF: 'off' }.get(color, 'off') return self._api_common.write_txt_file(STATUS_LED_PATH, status_str) def get_status_led(self): \"\"\" Gets the state of the PSU status LED Returns: A string, one of the predefined STATUS_LED_COLOR_* strings above \"\"\" status=self._api_common.read_txt_file(STATUS_LED_PATH) status_str={ 'on': self.STATUS_LED_COLOR_GREEN, 'amber': self.STATUS_LED_COLOR_AMBER, 'off': self.STATUS_LED_COLOR_OFF }.get(status, None) return status_str ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\n\ntry:\n    from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper\n    from sonic_platform_base.chassis_base import ChassisBase\n    from sonic_py_common import device_info\n    from .common import Common\n    from .event import SfpEvent\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 3\nNUM_PSU = 2\nNUM_THERMAL = 7\nNUM_SFP = 55\nNUM_COMPONENT = 3\nRESET_REGISTER = \"0x112\"\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/previous-reboot-cause.txt\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nSTATUS_LED_PATH = \"/sys/devices/platform/e1031.smc/master_led\"\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n\n        self._api_common = Common()\n        self._is_host = self._api_common.is_host()\n\n        self.__initialize_eeprom()\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n\n        self.sfp_module_initialized = False\n        self._reboot_cause_path = HOST_REBOOT_CAUSE_PATH if self._is_host else PMON_REBOOT_CAUSE_PATH\n\n    def __initialize_sfp(self):\n        sfputil_helper = SfpUtilHelper()\n        port_config_file_path = device_info.get_path_to_port_config_file()\n        sfputil_helper.read_porttab_mappings(port_config_file_path, 0)\n\n        from .sfp import Sfp\n        for index in range(0, NUM_SFP):\n            sfp = Sfp(index, sfputil_helper.logical[index])\n            self._sfp_list.append(sfp)\n        self.sfp_module_initialized = True\n\n    def __initialize_psu(self):\n        from .psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_fan(self):\n        from .fan_drawer import FanDrawer\n        for i in range(NUM_FAN_TRAY):\n            fandrawer = FanDrawer(i)\n            self._fan_drawer_list.append(fandrawer)\n            self._fan_list += fandrawer.get_all_fans()\n\n    def __initialize_thermals(self):\n        from .thermal import Thermal\n        airflow = self.__get_air_flow()\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index, airflow)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from .eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from .component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __get_air_flow(self):\n        air_flow_path = '/usr/share/sonic/device/{}/fan_airflow'.format(\n            self._api_common.get_platform()) if self._is_host else '/usr/share/sonic/platform/fan_airflow'\n        air_flow = self._api_common.read_txt_file(air_flow_path)\n        return air_flow or 'B2F'\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_serial_number(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        description = 'None'\n        reboot_cause = self.REBOOT_CAUSE_HARDWARE_OTHER\n        hw_reboot_cause = self._component_list[0].get_register_value(\n            RESET_REGISTER)\n        sw_reboot_cause = self._api_common.read_txt_file(\n            self._reboot_cause_path) or \"Unknown\"\n\n        if hw_reboot_cause == \"0x55\":\n            reboot_cause = self.REBOOT_CAUSE_NON_HARDWARE\n            description = sw_reboot_cause\n        elif hw_reboot_cause == \"0x11\":\n            reboot_cause = self.REBOOT_CAUSE_POWER_LOSS\n        elif hw_reboot_cause == \"0x33\":\n            reboot_cause = self.REBOOT_CAUSE_WATCHDOG\n        elif hw_reboot_cause == \"0x88\":\n            reboot_cause = self.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU\n        elif hw_reboot_cause == \"0x99\":\n            reboot_cause = self.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC\n        else:\n            reboot_cause = self.REBOOT_CAUSE_NON_HARDWARE\n            description = 'Unknown reason'\n        return (reboot_cause, description)\n\n    def get_watchdog(self):\n        \"\"\"\n        Retreives hardware watchdog device on this chassis\n        Returns:\n            An object derived from WatchdogBase representing the hardware\n            watchdog device\n        \"\"\"\n        if self._watchdog is None:\n            from sonic_platform.watchdog import Watchdog\n            self._watchdog = Watchdog()\n\n        return self._watchdog\n\n    def get_change_event(self, timeout=0):\n        \"\"\"\n        Returns a nested dictionary containing all devices which have\n        experienced a change at chassis level\n        Args:\n            timeout: Timeout in milliseconds (optional). If timeout == 0,\n                this method will block until a change is detected.\n        Returns:\n            (bool, dict):\n                - True if call successful, False if not;\n                - A nested dictionary where key is a device type,\n                  value is a dictionary with key:value pairs in the format of\n                  {'device_id':'device_event'},\n                  where device_id is the device ID for this device and\n                        device_event,\n                             status='1' represents device inserted,\n                             status='0' represents device removed.\n                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}\n                      indicates that fan 0 has been removed, fan 2\n                      has been inserted and sfp 11 has been removed.\n        \"\"\"\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        sfp_event = SfpEvent(self._sfp_list).get_sfp_event(timeout)\n        if sfp_event:\n            return True, {'sfp': sfp_event}\n\n        return False, {'sfp': {}}\n\n    ##############################################################\n    ######################## SFP methods #########################\n    ##############################################################\n\n    def get_num_sfps(self):\n        \"\"\"\n        Retrieves the number of sfps available on this chassis\n        Returns:\n            An integer, the number of sfps available on this chassis\n        \"\"\"\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return len(self._sfp_list)\n\n    def get_all_sfps(self):\n        \"\"\"\n        Retrieves all sfps available on this chassis\n        Returns:\n            A list of objects derived from SfpBase representing all sfps\n            available on this chassis\n        \"\"\"\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return self._sfp_list\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return super(Chassis, self).get_sfp(index - 1)\n\n    ##############################################################\n    ################## ThermalManager methods ####################\n    ##############################################################\n\n    def get_thermal_manager(self):\n        from .thermal_manager import ThermalManager\n        return ThermalManager\n\n    ##############################################################\n    ###################### Device methods ########################\n    ##############################################################\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return self._api_common.get_hwsku()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return self.get_serial_number()\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the PSU status LED\n        Args:\n            color: A string representing the color with which to set the PSU status LED\n                   Note: Only support green and off\n        Returns:\n            bool: True if status LED state is set successfully, False if not\n        \"\"\"\n\n        status_str = {\n            self.STATUS_LED_COLOR_GREEN: 'green',\n            self.STATUS_LED_COLOR_AMBER: 'amber',\n            self.STATUS_LED_COLOR_OFF: 'off'\n        }.get(color, 'off')\n\n        return self._api_common.write_txt_file(STATUS_LED_PATH, status_str)\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the PSU status LED\n        Returns:\n            A string, one of the predefined STATUS_LED_COLOR_* strings above\n        \"\"\"\n        status = self._api_common.read_txt_file(STATUS_LED_PATH)\n        status_str = {\n            'on': self.STATUS_LED_COLOR_GREEN,\n            'amber': self.STATUS_LED_COLOR_AMBER,\n            'off': self.STATUS_LED_COLOR_OFF\n        }.get(status, None)\n\n        return status_str\n"}, "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py": {"changes": [{"diff": "\n import os\r\n+import ast\r\n import imp\r\n import yaml\r\n import subprocess\r\n-\r\n from sonic_py_common import device_info\r\n \r\n \r\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["\r"], "goodparts": ["import ast\r"]}, {"diff": "\n \r\n     SET_METHOD_IPMI = 'ipmitool'\r\n     NULL_VAL = 'N/A'\r\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\r\n+    HOST_CHK_CMD = [\"docker\"]\r\n     REF_KEY = '$ref:'\r\n \r\n     def __init__(self, conf=None):\r\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\r"], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]\r"]}, {"diff": "\n         status = False\r\n         output = \"\"\r\n         try:\r\n-            p = subprocess.Popen(\r\n-                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n+            p = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n             raw_data, err = p.communicate()\r\n             if p.returncode == 0:\r\n                 status, output = True, raw_data.strip()\r\n", "add": 1, "remove": 2, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["            p = subprocess.Popen(\r", "                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r"], "goodparts": ["            p = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r"]}, {"diff": "\n             cleaned_input = input_translator.get(input)\r\n \r\n         elif type(input_translator) is str:\r\n-            cleaned_input = eval(input_translator.format(input))\r\n+            cleaned_input = ast.literal_eval(input_translator.format(input))\r\n \r\n         return cleaned_input\r\n \r\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["            cleaned_input = eval(input_translator.format(input))\r"], "goodparts": ["            cleaned_input = ast.literal_eval(input_translator.format(input))\r"]}, {"diff": "\n         if type(output_translator) is dict:\r\n             output = output_translator.get(output)\r\n         elif type(output_translator) is str:\r\n-            output = eval(output_translator.format(output))\r\n+            output = ast.literal_eval(output_translator.format(output))\r\n         elif type(output_translator) is list:\r\n-            output = eval(output_translator[index].format(output))\r\n+            output = ast.literal_eval(output_translator[index].format(output))\r\n \r\n         return output\r\n \r\n-    def _ipmi_get(self, index, config):\r\n-        argument = config.get('argument')\r\n-        cmd = config['command'].format(\r\n-            config['argument'][index]) if argument else config['command']\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n-\r\n     def _sysfs_read(self, index, config):\r\n         sysfs_path = config.get('sysfs_path')\r\n         argument = config.get('argument', '')\r\n", "add": 2, "remove": 9, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["            output = eval(output_translator.format(output))\r", "            output = eval(output_translator[index].format(output))\r", "    def _ipmi_get(self, index, config):\r", "        argument = config.get('argument')\r", "        cmd = config['command'].format(\r", "            config['argument'][index]) if argument else config['command']\r", "        status, output = self.run_command(cmd)\r", "        return output if status else None\r", "\r"], "goodparts": ["            output = ast.literal_eval(output_translator.format(output))\r", "            output = ast.literal_eval(output_translator[index].format(output))\r"]}, {"diff": "\n             return False, output\r\n         return True, output\r\n \r\n-    def _ipmi_set(self, index, config, input):\r\n-        arg = config['argument'][index].format(input)\r\n-        return self.run_command(config['command'].format(arg))\r\n-\r\n     def _hex_ver_decode(self, hver, num_of_bits, num_of_points):\r\n         ver_list = []\r\n         c_bit = 0\r\n", "add": 0, "remove": 4, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["    def _ipmi_set(self, index, config, input):\r", "        arg = config['argument'][index].format(input)\r", "        return self.run_command(config['command'].format(arg))\r", "\r"], "goodparts": []}, {"diff": "\n         return class_\r\n \r\n     def get_reg(self, path, reg_addr):\r\n-        cmd = \"echo {1} > {0}; cat {0}\".format(path, reg_addr)\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n+        with open(path, 'w') as file:\r\n+            file.write(reg_addr + '\\n')\r\n+        with open(path, 'r') as file:\r\n+            output = file.readline().strip()\r\n+        return output\r\n \r\n     def set_reg(self, path, reg_addr, value):\r\n-        cmd = \"echo {0} {1} > {2}\".format(reg_addr, value, path)\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n+        with open(path, 'w') as file:\r\n+            file.write(\"{0} {1}\\n\".format(reg_addr, value))\r\n+        return None\r\n \r\n     def read_txt_file(self, path):\r\n         try:\r\n", "add": 8, "remove": 6, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["        cmd = \"echo {1} > {0}; cat {0}\".format(path, reg_addr)\r", "        status, output = self.run_command(cmd)\r", "        return output if status else None\r", "        cmd = \"echo {0} {1} > {2}\".format(reg_addr, value, path)\r", "        status, output = self.run_command(cmd)\r", "        return output if status else None\r"], "goodparts": ["        with open(path, 'w') as file:\r", "            file.write(reg_addr + '\\n')\r", "        with open(path, 'r') as file:\r", "            output = file.readline().strip()\r", "        return output\r", "        with open(path, 'w') as file:\r", "            file.write(\"{0} {1}\\n\".format(reg_addr, value))\r", "        return None\r"]}, {"diff": "\n         return True\r\n \r\n     def is_host(self):\r\n-        return os.system(self.HOST_CHK_CMD) == 0\r\n+        try:\r\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\r\n+        except FileNotFoundError:\r\n+            return False\r\n+        return True\r\n \r\n     def load_json_file(self, path):\r\n         \"\"\"\r\n", "add": 5, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0\r"], "goodparts": ["        try:\r", "            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\r", "        except FileNotFoundError:\r", "            return False\r", "        return True\r"]}, {"diff": "\n         \"\"\"\r\n         return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\r\n \r\n-    def get_output(self, index, config, default):\r\n-        \"\"\"\r\n-        Retrieves the output for each function base on config\r\n-\r\n-        Args:\r\n-            index: An integer containing the index of device.\r\n-            config: A dict object containing the configuration of specified function.\r\n-            default: A string containing the default output of specified function.\r\n-\r\n-        Returns:\r\n-            A string containing the output of specified function in config\r\n-        \"\"\"\r\n-        output_source = config.get('output_source')\r\n-\r\n-        if output_source == self.OUTPUT_SOURCE_IPMI:\r\n-            output = self._ipmi_get(index, config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VALUE:\r\n-            output = config[\"value\"]\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_CLASS:\r\n-            output = self._get_class(config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_LIST:\r\n-            output = config[\"value_list\"][index]\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_SYSFS:\r\n-            output = self._sysfs_read(index, config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_FUNC:\r\n-            func_conf = self._main_conf[config['function'][index]]\r\n-            output = self.get_output(index, func_conf, default)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\r\n-            path = config.get('path')\r\n-            output = self.read_txt_file(path)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\r\n-            path = config.get('path')\r\n-            hex_ver = self.read_txt_file(path)\r\n-            output = self._hex_ver_decode(\r\n-                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\r\n-            path = config.get('path')\r\n-            addr = config.get('reg_addr')\r\n-            hex_ver = self.get_reg(path, addr)\r\n-            output = self._hex_ver_decode(\r\n-                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n-\r\n-        else:\r\n-            output = default\r\n-\r\n-        return self._clean_output(index, output, config) or default\r\n-\r\n-    def set_output(self, index, input, config):\r\n-        \"\"\"\r\n-        Sets the output of specified function on config\r\n-\r\n-        Args:\r\n-            config: A dict object containing the configuration of specified function.\r\n-            index: An integer containing the index of device.\r\n-            input: A string containing the input of specified function.\r\n-\r\n-        Returns:\r\n-            bool: True if set function is successfully, False if not\r\n-        \"\"\"\r\n-        cleaned_input = self._clean_input(input, config)\r\n-        if not cleaned_input:\r\n-            return False\r\n-\r\n-        set_method = config.get('set_method')\r\n-        if set_method == self.SET_METHOD_IPMI:\r\n-            output = self._ipmi_set(index, config, cleaned_input)[0]\r\n-        elif set_method == self.OUTPUT_SOURCE_SYSFS:\r\n-            output = self._sysfs_write(index, config, cleaned_input)[0]\r\n-        else:\r\n-            output = False\r\n-\r\n-        return output\r\n-\r\n     def get_event(self, timeout, config, sfp_list):\r\n         \"\"\"\r\n         Returns a nested dictionary containing all devices which have", "add": 0, "remove": 81, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["    def get_output(self, index, config, default):\r", "        \"\"\"\r", "        Retrieves the output for each function base on config\r", "\r", "        Args:\r", "            index: An integer containing the index of device.\r", "            config: A dict object containing the configuration of specified function.\r", "            default: A string containing the default output of specified function.\r", "\r", "        Returns:\r", "            A string containing the output of specified function in config\r", "        \"\"\"\r", "        output_source = config.get('output_source')\r", "\r", "        if output_source == self.OUTPUT_SOURCE_IPMI:\r", "            output = self._ipmi_get(index, config)\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_VALUE:\r", "            output = config[\"value\"]\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_CLASS:\r", "            output = self._get_class(config)\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_LIST:\r", "            output = config[\"value_list\"][index]\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_SYSFS:\r", "            output = self._sysfs_read(index, config)\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_FUNC:\r", "            func_conf = self._main_conf[config['function'][index]]\r", "            output = self.get_output(index, func_conf, default)\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\r", "            path = config.get('path')\r", "            output = self.read_txt_file(path)\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\r", "            path = config.get('path')\r", "            hex_ver = self.read_txt_file(path)\r", "            output = self._hex_ver_decode(\r", "                hex_ver, config['num_of_bits'], config['num_of_points'])\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\r", "            path = config.get('path')\r", "            addr = config.get('reg_addr')\r", "            hex_ver = self.get_reg(path, addr)\r", "            output = self._hex_ver_decode(\r", "                hex_ver, config['num_of_bits'], config['num_of_points'])\r", "\r", "        else:\r", "            output = default\r", "\r", "        return self._clean_output(index, output, config) or default\r", "\r", "    def set_output(self, index, input, config):\r", "        \"\"\"\r", "        Sets the output of specified function on config\r", "\r", "        Args:\r", "            config: A dict object containing the configuration of specified function.\r", "            index: An integer containing the index of device.\r", "            input: A string containing the input of specified function.\r", "\r", "        Returns:\r", "            bool: True if set function is successfully, False if not\r", "        \"\"\"\r", "        cleaned_input = self._clean_input(input, config)\r", "        if not cleaned_input:\r", "            return False\r", "\r", "        set_method = config.get('set_method')\r", "        if set_method == self.SET_METHOD_IPMI:\r", "            output = self._ipmi_set(index, config, cleaned_input)[0]\r", "        elif set_method == self.OUTPUT_SOURCE_SYSFS:\r", "            output = self._sysfs_write(index, config, cleaned_input)[0]\r", "        else:\r", "            output = False\r", "\r", "        return output\r", "\r"], "goodparts": []}], "source": "\nimport os\r import imp\r import yaml\r import subprocess\r \r from sonic_py_common import device_info\r \r \r class Common:\r \r DEVICE_PATH='/usr/share/sonic/device/'\r PMON_PLATFORM_PATH='/usr/share/sonic/platform/'\r CONFIG_DIR='sonic_platform_config'\r \r OUTPUT_SOURCE_IPMI='ipmitool'\r OUTPUT_SOURCE_GIVEN_LIST='value_list'\r OUTPUT_SOURCE_GIVEN_VALUE='value'\r OUTPUT_SOURCE_GIVEN_CLASS='class'\r OUTPUT_SOURCE_SYSFS='sysfs_value'\r OUTPUT_SOURCE_FUNC='function'\r OUTPUT_SOURCE_GIVEN_TXT_FILE='txt_file'\r OUTPUT_SOURCE_GIVEN_VER_HEX_FILE='hex_version_file'\r OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR='hex_version_getreg'\r \r SET_METHOD_IPMI='ipmitool'\r NULL_VAL='N/A'\r HOST_CHK_CMD=\"docker > /dev/null 2>&1\"\r REF_KEY='$ref:'\r \r def __init__(self, conf=None):\r self._main_conf=conf\r self.platform=None\r self.hwsku=None\r \r def get_platform(self):\r (self.platform, self.hwsku)=device_info.get_platform_and_hwsku(\r ) if not self.platform else(self.platform, self.hwsku)\r return self.platform\r \r def get_hwsku(self):\r (self.platform, self.hwsku)=device_info.get_platform_and_hwsku(\r ) if not self.hwsku else(self.platform, self.hwsku)\r return self.hwsku\r \r def run_command(self, command):\r status=False\r output=\"\"\r try:\r p=subprocess.Popen(\r command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r raw_data, err=p.communicate()\r if p.returncode==0:\r status, output=True, raw_data.strip()\r except Exception:\r pass\r return status, output\r \r def _clean_input(self, input, config):\r cleaned_input=input\r \r ai=config.get('avaliable_input')\r if ai and input not in ai:\r return None\r \r input_translator=config.get('input_translator')\r if type(input_translator) is dict:\r cleaned_input=input_translator.get(input)\r \r elif type(input_translator) is str:\r cleaned_input=eval(input_translator.format(input))\r \r return cleaned_input\r \r def _clean_output(self, index, output, config):\r output_translator=config.get('output_translator')\r \r if type(output_translator) is dict:\r output=output_translator.get(output)\r elif type(output_translator) is str:\r output=eval(output_translator.format(output))\r elif type(output_translator) is list:\r output=eval(output_translator[index].format(output))\r \r return output\r \r def _ipmi_get(self, index, config):\r argument=config.get('argument')\r cmd=config['command'].format(\r config['argument'][index]) if argument else config['command']\r status, output=self.run_command(cmd)\r return output if status else None\r \r def _sysfs_read(self, index, config):\r sysfs_path=config.get('sysfs_path')\r argument=config.get('argument', '')\r \r if self.REF_KEY in argument:\r argument=self._main_conf[argument.split(\":\")[1]]\r \r if type(argument) is list:\r sysfs_path=sysfs_path.format(argument[index])\r \r content=\"\"\r try:\r content=open(sysfs_path)\r content=content.readline().rstrip()\r except IOError as e:\r print(\"Error: unable to open file: %s\" % str(e))\r return False\r \r return content\r \r def _sysfs_write(self, index, config, input):\r sysfs_path=config.get('sysfs_path')\r argument=config.get('argument', '')\r \r if self.REF_KEY in argument:\r argument=self._main_conf[argument.split(\":\")[1]]\r \r if type(argument) is list:\r sysfs_path=sysfs_path.format(argument[index])\r \r write_offset=int(config.get('write_offset', 0))\r output=\"\"\r try:\r open_file=open(sysfs_path, \"r+\")\r open_file.seek(write_offset)\r open_file.write(input)\r open_file.close()\r except IOError as e:\r print(\"Error: unable to open file: %s\" % str(e))\r return False, output\r return True, output\r \r def _ipmi_set(self, index, config, input):\r arg=config['argument'][index].format(input)\r return self.run_command(config['command'].format(arg))\r \r def _hex_ver_decode(self, hver, num_of_bits, num_of_points):\r ver_list=[]\r c_bit=0\r bin_val=bin(int(hver, 16))[2:].zfill(num_of_bits)\r bit_split=num_of_bits /(num_of_points +1)\r for x in range(0, num_of_points+1):\r split_bin=bin_val[c_bit:c_bit+bit_split]\r ver_list.append(str(int(split_bin, 2)))\r c_bit +=bit_split\r return '.'.join(ver_list)\r \r def _get_class(self, config):\r \"\"\"\r Retreives value of expected attribute\r Returns:\r A value of the attribute of object\r \"\"\"\r path=config['host_path'] if self.is_host() else config['pmon_path']\r module=imp.load_source(config['class'], path)\r class_=getattr(module, config['class'])\r return class_\r \r def get_reg(self, path, reg_addr):\r cmd=\"echo{1} >{0}; cat{0}\".format(path, reg_addr)\r status, output=self.run_command(cmd)\r return output if status else None\r \r def set_reg(self, path, reg_addr, value):\r cmd=\"echo{0}{1} >{2}\".format(reg_addr, value, path)\r status, output=self.run_command(cmd)\r return output if status else None\r \r def read_txt_file(self, path):\r try:\r with open(path, 'r') as f:\r output=f.readline()\r return output.strip('\\n')\r except Exception:\r pass\r return ''\r \r def read_one_line_file(self, file_path):\r try:\r with open(file_path, 'r') as fd:\r data=fd.readline()\r return data.strip()\r except IOError:\r pass\r return ''\r \r def write_txt_file(self, file_path, value):\r try:\r with open(file_path, 'w') as fd:\r fd.write(str(value))\r except Exception:\r return False\r return True\r \r def is_host(self):\r return os.system(self.HOST_CHK_CMD)==0\r \r def load_json_file(self, path):\r \"\"\"\r Retrieves the json object from json file path\r \r Returns:\r A json object\r \"\"\"\r with open(path, 'r') as f:\r json_data=yaml.safe_load(f)\r \r return json_data\r \r def get_config_path(self, config_name):\r \"\"\"\r Retrieves the path to platform api config directory\r \r Args:\r config_name: A string containing the name of config file.\r \r Returns:\r A string containing the path to json file\r \"\"\"\r return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\r \r def get_output(self, index, config, default):\r \"\"\"\r Retrieves the output for each function base on config\r \r Args:\r index: An integer containing the index of device.\r config: A dict object containing the configuration of specified function.\r default: A string containing the default output of specified function.\r \r Returns:\r A string containing the output of specified function in config\r \"\"\"\r output_source=config.get('output_source')\r \r if output_source==self.OUTPUT_SOURCE_IPMI:\r output=self._ipmi_get(index, config)\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_VALUE:\r output=config[\"value\"]\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_CLASS:\r output=self._get_class(config)\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_LIST:\r output=config[\"value_list\"][index]\r \r elif output_source==self.OUTPUT_SOURCE_SYSFS:\r output=self._sysfs_read(index, config)\r \r elif output_source==self.OUTPUT_SOURCE_FUNC:\r func_conf=self._main_conf[config['function'][index]]\r output=self.get_output(index, func_conf, default)\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\r path=config.get('path')\r output=self.read_txt_file(path)\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\r path=config.get('path')\r hex_ver=self.read_txt_file(path)\r output=self._hex_ver_decode(\r hex_ver, config['num_of_bits'], config['num_of_points'])\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\r path=config.get('path')\r addr=config.get('reg_addr')\r hex_ver=self.get_reg(path, addr)\r output=self._hex_ver_decode(\r hex_ver, config['num_of_bits'], config['num_of_points'])\r \r else:\r output=default\r \r return self._clean_output(index, output, config) or default\r \r def set_output(self, index, input, config):\r \"\"\"\r Sets the output of specified function on config\r \r Args:\r config: A dict object containing the configuration of specified function.\r index: An integer containing the index of device.\r input: A string containing the input of specified function.\r \r Returns:\r bool: True if set function is successfully, False if not\r \"\"\"\r cleaned_input=self._clean_input(input, config)\r if not cleaned_input:\r return False\r \r set_method=config.get('set_method')\r if set_method==self.SET_METHOD_IPMI:\r output=self._ipmi_set(index, config, cleaned_input)[0]\r elif set_method==self.OUTPUT_SOURCE_SYSFS:\r output=self._sysfs_write(index, config, cleaned_input)[0]\r else:\r output=False\r \r return output\r \r def get_event(self, timeout, config, sfp_list):\r \"\"\"\r Returns a nested dictionary containing all devices which have\r experienced a change at chassis level\r \r \"\"\"\r event_class=self._get_class(config)\r return event_class(sfp_list).get_event(timeout)\r ", "sourceWithComments": "import os\r\nimport imp\r\nimport yaml\r\nimport subprocess\r\n\r\nfrom sonic_py_common import device_info\r\n\r\n\r\nclass Common:\r\n\r\n    DEVICE_PATH = '/usr/share/sonic/device/'\r\n    PMON_PLATFORM_PATH = '/usr/share/sonic/platform/'\r\n    CONFIG_DIR = 'sonic_platform_config'\r\n\r\n    OUTPUT_SOURCE_IPMI = 'ipmitool'\r\n    OUTPUT_SOURCE_GIVEN_LIST = 'value_list'\r\n    OUTPUT_SOURCE_GIVEN_VALUE = 'value'\r\n    OUTPUT_SOURCE_GIVEN_CLASS = 'class'\r\n    OUTPUT_SOURCE_SYSFS = 'sysfs_value'\r\n    OUTPUT_SOURCE_FUNC = 'function'\r\n    OUTPUT_SOURCE_GIVEN_TXT_FILE = 'txt_file'\r\n    OUTPUT_SOURCE_GIVEN_VER_HEX_FILE = 'hex_version_file'\r\n    OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR = 'hex_version_getreg'\r\n\r\n    SET_METHOD_IPMI = 'ipmitool'\r\n    NULL_VAL = 'N/A'\r\n    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\r\n    REF_KEY = '$ref:'\r\n\r\n    def __init__(self, conf=None):\r\n        self._main_conf = conf\r\n        self.platform = None\r\n        self.hwsku = None\r\n\r\n    def get_platform(self):\r\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku(\r\n        ) if not self.platform else (self.platform, self.hwsku)\r\n        return self.platform\r\n\r\n    def get_hwsku(self):\r\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku(\r\n        ) if not self.hwsku else (self.platform, self.hwsku)\r\n        return self.hwsku\r\n\r\n    def run_command(self, command):\r\n        status = False\r\n        output = \"\"\r\n        try:\r\n            p = subprocess.Popen(\r\n                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n            raw_data, err = p.communicate()\r\n            if p.returncode == 0:\r\n                status, output = True, raw_data.strip()\r\n        except Exception:\r\n            pass\r\n        return status, output\r\n\r\n    def _clean_input(self, input, config):\r\n        cleaned_input = input\r\n\r\n        ai = config.get('avaliable_input')\r\n        if ai and input not in ai:\r\n            return None\r\n\r\n        input_translator = config.get('input_translator')\r\n        if type(input_translator) is dict:\r\n            cleaned_input = input_translator.get(input)\r\n\r\n        elif type(input_translator) is str:\r\n            cleaned_input = eval(input_translator.format(input))\r\n\r\n        return cleaned_input\r\n\r\n    def _clean_output(self, index, output, config):\r\n        output_translator = config.get('output_translator')\r\n\r\n        if type(output_translator) is dict:\r\n            output = output_translator.get(output)\r\n        elif type(output_translator) is str:\r\n            output = eval(output_translator.format(output))\r\n        elif type(output_translator) is list:\r\n            output = eval(output_translator[index].format(output))\r\n\r\n        return output\r\n\r\n    def _ipmi_get(self, index, config):\r\n        argument = config.get('argument')\r\n        cmd = config['command'].format(\r\n            config['argument'][index]) if argument else config['command']\r\n        status, output = self.run_command(cmd)\r\n        return output if status else None\r\n\r\n    def _sysfs_read(self, index, config):\r\n        sysfs_path = config.get('sysfs_path')\r\n        argument = config.get('argument', '')\r\n\r\n        if self.REF_KEY in argument:\r\n            argument = self._main_conf[argument.split(\":\")[1]]\r\n\r\n        if type(argument) is list:\r\n            sysfs_path = sysfs_path.format(argument[index])\r\n\r\n        content = \"\"\r\n        try:\r\n            content = open(sysfs_path)\r\n            content = content.readline().rstrip()\r\n        except IOError as e:\r\n            print(\"Error: unable to open file: %s\" % str(e))\r\n            return False\r\n\r\n        return content\r\n\r\n    def _sysfs_write(self, index, config, input):\r\n        sysfs_path = config.get('sysfs_path')\r\n        argument = config.get('argument', '')\r\n\r\n        if self.REF_KEY in argument:\r\n            argument = self._main_conf[argument.split(\":\")[1]]\r\n\r\n        if type(argument) is list:\r\n            sysfs_path = sysfs_path.format(argument[index])\r\n\r\n        write_offset = int(config.get('write_offset', 0))\r\n        output = \"\"\r\n        try:\r\n            open_file = open(sysfs_path, \"r+\")\r\n            open_file.seek(write_offset)\r\n            open_file.write(input)\r\n            open_file.close()\r\n        except IOError as e:\r\n            print(\"Error: unable to open file: %s\" % str(e))\r\n            return False, output\r\n        return True, output\r\n\r\n    def _ipmi_set(self, index, config, input):\r\n        arg = config['argument'][index].format(input)\r\n        return self.run_command(config['command'].format(arg))\r\n\r\n    def _hex_ver_decode(self, hver, num_of_bits, num_of_points):\r\n        ver_list = []\r\n        c_bit = 0\r\n        bin_val = bin(int(hver, 16))[2:].zfill(num_of_bits)\r\n        bit_split = num_of_bits / (num_of_points + 1)\r\n        for x in range(0, num_of_points+1):\r\n            split_bin = bin_val[c_bit:c_bit+bit_split]\r\n            ver_list.append(str(int(split_bin, 2)))\r\n            c_bit += bit_split\r\n        return '.'.join(ver_list)\r\n\r\n    def _get_class(self, config):\r\n        \"\"\"\r\n        Retreives value of expected attribute\r\n        Returns:\r\n            A value of the attribute of object\r\n        \"\"\"\r\n        path = config['host_path'] if self.is_host() else config['pmon_path']\r\n        module = imp.load_source(config['class'], path)\r\n        class_ = getattr(module, config['class'])\r\n        return class_\r\n\r\n    def get_reg(self, path, reg_addr):\r\n        cmd = \"echo {1} > {0}; cat {0}\".format(path, reg_addr)\r\n        status, output = self.run_command(cmd)\r\n        return output if status else None\r\n\r\n    def set_reg(self, path, reg_addr, value):\r\n        cmd = \"echo {0} {1} > {2}\".format(reg_addr, value, path)\r\n        status, output = self.run_command(cmd)\r\n        return output if status else None\r\n\r\n    def read_txt_file(self, path):\r\n        try:\r\n            with open(path, 'r') as f:\r\n                output = f.readline()\r\n            return output.strip('\\n')\r\n        except Exception:\r\n            pass\r\n        return ''\r\n\r\n    def read_one_line_file(self, file_path):\r\n        try:\r\n            with open(file_path, 'r') as fd:\r\n                data = fd.readline()\r\n                return data.strip()\r\n        except IOError:\r\n            pass\r\n        return ''\r\n\r\n    def write_txt_file(self, file_path, value):\r\n        try:\r\n            with open(file_path, 'w') as fd:\r\n                fd.write(str(value))\r\n        except Exception:\r\n            return False\r\n        return True\r\n\r\n    def is_host(self):\r\n        return os.system(self.HOST_CHK_CMD) == 0\r\n\r\n    def load_json_file(self, path):\r\n        \"\"\"\r\n        Retrieves the json object from json file path\r\n\r\n        Returns:\r\n            A json object\r\n        \"\"\"\r\n        with open(path, 'r') as f:\r\n            json_data = yaml.safe_load(f)\r\n\r\n        return json_data\r\n\r\n    def get_config_path(self, config_name):\r\n        \"\"\"\r\n        Retrieves the path to platform api config directory\r\n\r\n        Args:\r\n            config_name: A string containing the name of config file.\r\n\r\n        Returns:\r\n            A string containing the path to json file\r\n        \"\"\"\r\n        return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\r\n\r\n    def get_output(self, index, config, default):\r\n        \"\"\"\r\n        Retrieves the output for each function base on config\r\n\r\n        Args:\r\n            index: An integer containing the index of device.\r\n            config: A dict object containing the configuration of specified function.\r\n            default: A string containing the default output of specified function.\r\n\r\n        Returns:\r\n            A string containing the output of specified function in config\r\n        \"\"\"\r\n        output_source = config.get('output_source')\r\n\r\n        if output_source == self.OUTPUT_SOURCE_IPMI:\r\n            output = self._ipmi_get(index, config)\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VALUE:\r\n            output = config[\"value\"]\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_CLASS:\r\n            output = self._get_class(config)\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_LIST:\r\n            output = config[\"value_list\"][index]\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_SYSFS:\r\n            output = self._sysfs_read(index, config)\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_FUNC:\r\n            func_conf = self._main_conf[config['function'][index]]\r\n            output = self.get_output(index, func_conf, default)\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\r\n            path = config.get('path')\r\n            output = self.read_txt_file(path)\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\r\n            path = config.get('path')\r\n            hex_ver = self.read_txt_file(path)\r\n            output = self._hex_ver_decode(\r\n                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\r\n            path = config.get('path')\r\n            addr = config.get('reg_addr')\r\n            hex_ver = self.get_reg(path, addr)\r\n            output = self._hex_ver_decode(\r\n                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n\r\n        else:\r\n            output = default\r\n\r\n        return self._clean_output(index, output, config) or default\r\n\r\n    def set_output(self, index, input, config):\r\n        \"\"\"\r\n        Sets the output of specified function on config\r\n\r\n        Args:\r\n            config: A dict object containing the configuration of specified function.\r\n            index: An integer containing the index of device.\r\n            input: A string containing the input of specified function.\r\n\r\n        Returns:\r\n            bool: True if set function is successfully, False if not\r\n        \"\"\"\r\n        cleaned_input = self._clean_input(input, config)\r\n        if not cleaned_input:\r\n            return False\r\n\r\n        set_method = config.get('set_method')\r\n        if set_method == self.SET_METHOD_IPMI:\r\n            output = self._ipmi_set(index, config, cleaned_input)[0]\r\n        elif set_method == self.OUTPUT_SOURCE_SYSFS:\r\n            output = self._sysfs_write(index, config, cleaned_input)[0]\r\n        else:\r\n            output = False\r\n\r\n        return output\r\n\r\n    def get_event(self, timeout, config, sfp_list):\r\n        \"\"\"\r\n        Returns a nested dictionary containing all devices which have\r\n        experienced a change at chassis level\r\n\r\n        \"\"\"\r\n        event_class = self._get_class(config)\r\n        return event_class(sfp_list).get_event(timeout)\r\n"}, "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py": {"changes": [{"diff": "\n try:\n     import os.path\n     import shutil\n-    import shlex\n     import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n except ImportError as e:\n", "add": 0, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py", "badparts": ["    import shlex"], "goodparts": []}, {"diff": "\n     def __run_command(self, command):\n         # Run bash command and print output to stdout\n         try:\n-            process = subprocess.Popen(\n-                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n+            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n             while True:\n                 output = process.stdout.readline()\n                 if output == '' and process.poll() is not None:\n", "add": 1, "remove": 2, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py", "badparts": ["            process = subprocess.Popen(", "                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)"], "goodparts": ["            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)"]}, {"diff": "\n \n     def get_register_value(self, register):\n         # Retrieves the cpld register value\n-        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n-        p = subprocess.Popen(\n-            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-        raw_data, err = p.communicate()\n-        if err is not '':\n-            return None\n+        with open(GETREG_PATH, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(GETREG_PATH, 'r') as file:\n+            raw_data = file.readline()\n         return raw_data.strip()\n \n     def __get_cpld_version(self):\n", "add": 4, "remove": 6, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py", "badparts": ["        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)", "        p = subprocess.Popen(", "            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "        raw_data, err = p.communicate()", "        if err is not '':", "            return None"], "goodparts": ["        with open(GETREG_PATH, 'w') as file:", "            file.write(register + '\\n')", "        with open(GETREG_PATH, 'r') as file:", "            raw_data = file.readline()"]}, {"diff": "\n         cpld_version = dict()\n         with open(SMC_CPLD_PATH, 'r') as fd:\n             smc_cpld_version = fd.read()\n-        smc_cpld_version = 'None' if smc_cpld_version is 'None' else \"{}.{}\".format(\n+        smc_cpld_version = 'None' if smc_cpld_version == 'None' else \"{}.{}\".format(\n             int(smc_cpld_version[2], 16), int(smc_cpld_version[3], 16))\n \n         mmc_cpld_version = self.get_register_value(MMC_CPLD_ADDR)\n-        mmc_cpld_version = 'None' if mmc_cpld_version is 'None' else \"{}.{}\".format(\n+        mmc_cpld_version = 'None' if mmc_cpld_version == 'None' else \"{}.{}\".format(\n             int(mmc_cpld_version[2], 16), int(mmc_cpld_version[3], 16))\n \n         cpld_version[\"SMC_CPLD\"] = smc_cpld_version\n", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py", "badparts": ["        smc_cpld_version = 'None' if smc_cpld_version is 'None' else \"{}.{}\".format(", "        mmc_cpld_version = 'None' if mmc_cpld_version is 'None' else \"{}.{}\".format("], "goodparts": ["        smc_cpld_version = 'None' if smc_cpld_version == 'None' else \"{}.{}\".format(", "        mmc_cpld_version = 'None' if mmc_cpld_version == 'None' else \"{}.{}\".format("]}, {"diff": "\n             ext = \".vme\" if ext == \"\" else ext\n             new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n             shutil.copy(image_path, new_image_path)\n-            install_command = \"ispvm %s\" % new_image_path\n+            install_command = [\"ispvm\", str(new_image_path)]\n         # elif self.name == \"BIOS\":\n         #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n         return self.__run_command(install_comman", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py", "badparts": ["            install_command = \"ispvm %s\" % new_image_path"], "goodparts": ["            install_command = [\"ispvm\", str(new_image_path)]"]}], "source": "\n try: import os.path import shutil import shlex import subprocess from sonic_platform_base.component_base import ComponentBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") MMC_CPLD_ADDR='0x100' BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" CONFIG_DB_PATH=\"/etc/sonic/config_db.json\" SMC_CPLD_PATH=\"/sys/devices/platform/e1031.smc/version\" GETREG_PATH=\"/sys/devices/platform/e1031.smc/getreg\" COMPONENT_NAME_LIST=[\"SMC_CPLD\", \"MMC_CPLD\", \"BIOS\"] COMPONENT_DES_LIST=[\"System Management Controller\", \"Module Management CPLD\", \"Basic Input/Output System\"] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index): ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def get_register_value(self, register): cmd=\"echo{1} >{0}; cat{0}\".format(GETREG_PATH, register) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err is not '': return None return raw_data.strip() def __get_cpld_version(self): cpld_version=dict() with open(SMC_CPLD_PATH, 'r') as fd: smc_cpld_version=fd.read() smc_cpld_version='None' if smc_cpld_version is 'None' else \"{}.{}\".format( int(smc_cpld_version[2], 16), int(smc_cpld_version[3], 16)) mmc_cpld_version=self.get_register_value(MMC_CPLD_ADDR) mmc_cpld_version='None' if mmc_cpld_version is 'None' else \"{}.{}\".format( int(mmc_cpld_version[2], 16), int(mmc_cpld_version[3], 16)) cpld_version[\"SMC_CPLD\"]=smc_cpld_version cpld_version[\"MMC_CPLD\"]=mmc_cpld_version return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_NAME_LIST[self.index] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_DES_LIST[self.index] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def get_available_firmware_version(self, image_path): \"\"\" Retrieves the available firmware version of the component Note: the firmware version will be read from image Args: image_path: A string, path to firmware image Returns: A string containing the available firmware version of the component \"\"\" return \"N/A\" def get_firmware_update_notification(self, image_path): \"\"\" Retrieves a notification on what should be done in order to complete the component firmware update Args: image_path: A string, path to firmware image Returns: A string containing the component firmware update notification if required. By default 'None' value will be used, which indicates that no actions are required \"\"\" return \"None\" def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" if not os.path.isfile(image_path): return False if \"CPLD\" in self.name: img_name=os.path.basename(image_path) root, ext=os.path.splitext(img_name) ext=\".vme\" if ext==\"\" else ext new_image_path=os.path.join(\"/tmp\",(root.lower() +ext)) shutil.copy(image_path, new_image_path) install_command=\"ispvm %s\" % new_image_path return self.__run_command(install_command) def update_firmware(self, image_path): \"\"\" Updates firmware of the component This API performs firmware update: it assumes firmware installation and loading in a single call. In case platform component requires some extra steps(apart from calling Low Level Utility) to load the installed firmware(e.g, reboot, power cycle, etc.) -this will be done automatically by API Args: image_path: A string, path to firmware image Raises: RuntimeError: update failed \"\"\" return False def get_presence(self): \"\"\" Retrieves the presence of the FAN Returns: bool: True if FAN is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return 'N/A' def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return 'N/A' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is'0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\n\ntry:\n    import os.path\n    import shutil\n    import shlex\n    import subprocess\n    from sonic_platform_base.component_base import ComponentBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nMMC_CPLD_ADDR = '0x100'\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCONFIG_DB_PATH = \"/etc/sonic/config_db.json\"\nSMC_CPLD_PATH = \"/sys/devices/platform/e1031.smc/version\"\nGETREG_PATH = \"/sys/devices/platform/e1031.smc/getreg\"\nCOMPONENT_NAME_LIST = [\"SMC_CPLD\", \"MMC_CPLD\", \"BIOS\"]\nCOMPONENT_DES_LIST = [\"System Management Controller\",\n                      \"Module Management CPLD\", \"Basic Input/Output System\"]\n\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index):\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def get_register_value(self, register):\n        # Retrieves the cpld register value\n        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n        p = subprocess.Popen(\n            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        raw_data, err = p.communicate()\n        if err is not '':\n            return None\n        return raw_data.strip()\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        with open(SMC_CPLD_PATH, 'r') as fd:\n            smc_cpld_version = fd.read()\n        smc_cpld_version = 'None' if smc_cpld_version is 'None' else \"{}.{}\".format(\n            int(smc_cpld_version[2], 16), int(smc_cpld_version[3], 16))\n\n        mmc_cpld_version = self.get_register_value(MMC_CPLD_ADDR)\n        mmc_cpld_version = 'None' if mmc_cpld_version is 'None' else \"{}.{}\".format(\n            int(mmc_cpld_version[2], 16), int(mmc_cpld_version[3], 16))\n\n        cpld_version[\"SMC_CPLD\"] = smc_cpld_version\n        cpld_version[\"MMC_CPLD\"] = mmc_cpld_version\n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_NAME_LIST[self.index]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_DES_LIST[self.index]\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def get_available_firmware_version(self, image_path):\n        \"\"\"\n        Retrieves the available firmware version of the component\n        Note: the firmware version will be read from image\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A string containing the available firmware version of the component\n        \"\"\"\n        return \"N/A\"\n\n    def get_firmware_update_notification(self, image_path):\n        \"\"\"\n        Retrieves a notification on what should be done in order to complete\n        the component firmware update\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A string containing the component firmware update notification if required.\n            By default 'None' value will be used, which indicates that no actions are required\n        \"\"\"\n        return \"None\"\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        if not os.path.isfile(image_path):\n            return False\n\n        if \"CPLD\" in self.name:\n            img_name = os.path.basename(image_path)\n            root, ext = os.path.splitext(img_name)\n            ext = \".vme\" if ext == \"\" else ext\n            new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n            shutil.copy(image_path, new_image_path)\n            install_command = \"ispvm %s\" % new_image_path\n        # elif self.name == \"BIOS\":\n        #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n        return self.__run_command(install_command)\n\n    def update_firmware(self, image_path):\n        \"\"\"\n        Updates firmware of the component\n        This API performs firmware update: it assumes firmware installation and loading in a single call.\n        In case platform component requires some extra steps (apart from calling Low Level Utility)\n        to load the installed firmware (e.g, reboot, power cycle, etc.) - this will be done automatically by API\n        Args:\n            image_path: A string, path to firmware image\n        Raises:\n            RuntimeError: update failed\n        \"\"\"\n        return False\n\n    ##############################################################\n    ###################### Device methods ########################\n    ##############################################################\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the FAN\n        Returns:\n            bool: True if FAN is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of\n        entPhysicalContainedIn is'0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device\n            or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py": {"changes": [{"diff": "\n         thermal_overload_position = Common().read_txt_file(\r\n             thermal_overload_position_path)\r\n \r\n-        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\r\n-            thermal_overload_position)\r\n+        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', thermal_overload_position]\r\n         Common().run_command(cm", "add": 1, "remove": 2, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py", "badparts": ["        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\r", "            thermal_overload_position)\r"], "goodparts": ["        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', thermal_overload_position]\r"]}], "source": "\nfrom sonic_platform_base.sonic_thermal_control.thermal_action_base import ThermalPolicyActionBase\r from sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object\r from.thermal_infos import ChassisInfo\r from.common import Common\r \r \r @thermal_json_object('thermal_control.control')\r class ControlThermalAlgoAction(ThermalPolicyActionBase):\r \"\"\"\r Action to control the thermal control algorithm\r \"\"\"\r JSON_FIELD_STATUS='status'\r \r def __init__(self):\r self.status=True\r \r def load_from_json(self, json_obj):\r \"\"\"\r Construct ControlThermalAlgoAction via JSON. JSON example:\r {\r \"type\": \"thermal_control.control\"\r \"status\": \"true\"\r }\r :param json_obj: A JSON object representing a ControlThermalAlgoAction action.\r :return:\r \"\"\"\r if ControlThermalAlgoAction.JSON_FIELD_STATUS in json_obj:\r status_str=json_obj[ControlThermalAlgoAction.JSON_FIELD_STATUS].lower(\r )\r if status_str=='true':\r self.status=True\r elif status_str=='false':\r self.status=False\r else:\r raise ValueError('Invalid{} field value, please specify true of false'.\r format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\r else:\r raise ValueError('ControlThermalAlgoAction '\r 'missing mandatory field{} in JSON policy file'.\r format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\r \r def execute(self, thermal_info_dict):\r \"\"\"\r Disable thermal control algorithm\r :param thermal_info_dict: A dictionary stores all thermal information.\r :return:\r \"\"\"\r if ChassisInfo.INFO_NAME in thermal_info_dict:\r chassis_info_obj=thermal_info_dict[ChassisInfo.INFO_NAME]\r chassis=chassis_info_obj.get_chassis()\r thermal_manager=chassis.get_thermal_manager()\r if self.status:\r thermal_manager.start_thermal_control_algorithm()\r else:\r thermal_manager.stop_thermal_control_algorithm()\r \r \r @thermal_json_object('switch.power_cycling')\r class SwitchPolicyAction(ThermalPolicyActionBase):\r \"\"\"\r Base class for thermal action. Once all thermal conditions in a thermal policy are matched,\r all predefined thermal action will be executed.\r \"\"\"\r \r def execute(self, thermal_info_dict):\r \"\"\"\r Take action when thermal condition matches. For example, power cycle the switch.\r :param thermal_info_dict: A dictionary stores all thermal information.\r :return:\r \"\"\"\r thermal_overload_position_path='/tmp/thermal_overload_position'\r thermal_overload_position=Common().read_txt_file(\r thermal_overload_position_path)\r \r cmd='bash /usr/share/sonic/platform/thermal_overload_control.sh{}'.format(\r thermal_overload_position)\r Common().run_command(cmd)\r ", "sourceWithComments": "from sonic_platform_base.sonic_thermal_control.thermal_action_base import ThermalPolicyActionBase\r\nfrom sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object\r\nfrom .thermal_infos import ChassisInfo\r\nfrom .common import Common\r\n\r\n\r\n@thermal_json_object('thermal_control.control')\r\nclass ControlThermalAlgoAction(ThermalPolicyActionBase):\r\n    \"\"\"\r\n    Action to control the thermal control algorithm\r\n    \"\"\"\r\n    # JSON field definition\r\n    JSON_FIELD_STATUS = 'status'\r\n\r\n    def __init__(self):\r\n        self.status = True\r\n\r\n    def load_from_json(self, json_obj):\r\n        \"\"\"\r\n        Construct ControlThermalAlgoAction via JSON. JSON example:\r\n            {\r\n                \"type\": \"thermal_control.control\"\r\n                \"status\": \"true\"\r\n            }\r\n        :param json_obj: A JSON object representing a ControlThermalAlgoAction action.\r\n        :return:\r\n        \"\"\"\r\n        if ControlThermalAlgoAction.JSON_FIELD_STATUS in json_obj:\r\n            status_str = json_obj[ControlThermalAlgoAction.JSON_FIELD_STATUS].lower(\r\n            )\r\n            if status_str == 'true':\r\n                self.status = True\r\n            elif status_str == 'false':\r\n                self.status = False\r\n            else:\r\n                raise ValueError('Invalid {} field value, please specify true of false'.\r\n                                 format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\r\n        else:\r\n            raise ValueError('ControlThermalAlgoAction '\r\n                             'missing mandatory field {} in JSON policy file'.\r\n                             format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\r\n\r\n    def execute(self, thermal_info_dict):\r\n        \"\"\"\r\n        Disable thermal control algorithm\r\n        :param thermal_info_dict: A dictionary stores all thermal information.\r\n        :return:\r\n        \"\"\"\r\n        if ChassisInfo.INFO_NAME in thermal_info_dict:\r\n            chassis_info_obj = thermal_info_dict[ChassisInfo.INFO_NAME]\r\n            chassis = chassis_info_obj.get_chassis()\r\n            thermal_manager = chassis.get_thermal_manager()\r\n            if self.status:\r\n                thermal_manager.start_thermal_control_algorithm()\r\n            else:\r\n                thermal_manager.stop_thermal_control_algorithm()\r\n\r\n\r\n@thermal_json_object('switch.power_cycling')\r\nclass SwitchPolicyAction(ThermalPolicyActionBase):\r\n    \"\"\"\r\n    Base class for thermal action. Once all thermal conditions in a thermal policy are matched,\r\n    all predefined thermal action will be executed.\r\n    \"\"\"\r\n\r\n    def execute(self, thermal_info_dict):\r\n        \"\"\"\r\n        Take action when thermal condition matches. For example, power cycle the switch.\r\n        :param thermal_info_dict: A dictionary stores all thermal information.\r\n        :return:\r\n        \"\"\"\r\n        thermal_overload_position_path = '/tmp/thermal_overload_position'\r\n        thermal_overload_position = Common().read_txt_file(\r\n            thermal_overload_position_path)\r\n\r\n        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\r\n            thermal_overload_position)\r\n        Common().run_command(cmd)\r\n"}, "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py": {"changes": [{"diff": "\n \n \n class ThermalManager(ThermalManagerBase):\n-    FSC_ALGORITHM_CMD = ' supervisorctl {} fancontrol'\n+    FSC_ALGORITHM_CMD = ['supervisorctl', '', 'fancontrol']\n \n     @classmethod\n     def start_thermal_control_algorithm(cls):\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py", "badparts": ["    FSC_ALGORITHM_CMD = ' supervisorctl {} fancontrol'"], "goodparts": ["    FSC_ALGORITHM_CMD = ['supervisorctl', '', 'fancontrol']"]}, {"diff": "\n         Returns:\n             bool: True if set success, False if fail.\n         \"\"\"\n-        cmd = 'start' if enable else 'stop'\n-        return Common().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n+        cls.FSC_ALGORITHM_CMD[1] = 'start' if enable else 'stop'\n+        return Common().run_command(cls.FSC_ALGORITHM_", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py", "badparts": ["        cmd = 'start' if enable else 'stop'", "        return Common().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))"], "goodparts": ["        cls.FSC_ALGORITHM_CMD[1] = 'start' if enable else 'stop'", "        return Common().run_command(cls.FSC_ALGORITHM_"]}], "source": "\nfrom sonic_platform_base.sonic_thermal_control.thermal_manager_base import ThermalManagerBase from.common import Common from.thermal_actions import * from.thermal_conditions import * from.thermal_infos import * class ThermalManager(ThermalManagerBase): FSC_ALGORITHM_CMD=' supervisorctl{} fancontrol' @classmethod def start_thermal_control_algorithm(cls): \"\"\" Start vendor specific thermal control algorithm. The default behavior of this function is a no-op. :return: \"\"\" return cls._enable_fancontrol_service(True) @classmethod def stop_thermal_control_algorithm(cls): \"\"\" Stop thermal control algorithm Returns: bool: True if set success, False if fail. \"\"\" return cls._enable_fancontrol_service(False) @classmethod def deinitialize(cls): \"\"\" Destroy thermal manager, including any vendor specific cleanup. The default behavior of this function is a no-op. :return: \"\"\" return cls._enable_fancontrol_service(True) @classmethod def _enable_fancontrol_service(cls, enable): \"\"\" Control thermal by fcs algorithm Args: enable: Bool, indicate enable the algorithm or not Returns: bool: True if set success, False if fail. \"\"\" cmd='start' if enable else 'stop' return Common().run_command(cls.FSC_ALGORITHM_CMD.format(cmd)) ", "sourceWithComments": "from sonic_platform_base.sonic_thermal_control.thermal_manager_base import ThermalManagerBase\nfrom .common import Common\nfrom .thermal_actions import *\nfrom .thermal_conditions import *\nfrom .thermal_infos import *\n\n\nclass ThermalManager(ThermalManagerBase):\n    FSC_ALGORITHM_CMD = ' supervisorctl {} fancontrol'\n\n    @classmethod\n    def start_thermal_control_algorithm(cls):\n        \"\"\"\n        Start vendor specific thermal control algorithm. The default behavior of this function is a no-op.\n        :return:\n        \"\"\"\n        return cls._enable_fancontrol_service(True)\n\n    @classmethod\n    def stop_thermal_control_algorithm(cls):\n        \"\"\"\n        Stop thermal control algorithm\n        Returns:\n            bool: True if set success, False if fail.\n        \"\"\"\n        return cls._enable_fancontrol_service(False)\n\n    @classmethod\n    def deinitialize(cls):\n        \"\"\"\n        Destroy thermal manager, including any vendor specific cleanup. The default behavior of this function\n        is a no-op.\n        :return:\n        \"\"\"\n        return cls._enable_fancontrol_service(True)\n\n    @classmethod\n    def _enable_fancontrol_service(cls, enable):\n        \"\"\"\n        Control thermal by fcs algorithm\n        Args:\n            enable: Bool, indicate enable the algorithm or not\n        Returns:\n            bool: True if set success, False if fail.\n        \"\"\"\n        cmd = 'start' if enable else 'stop'\n        return Common().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n"}, "/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import os.path\n-import subprocess\n \n try:\n     from sonic_psu.psu_base import Ps", "add": 0, "remove": 2, "filename": "/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py", "badparts": ["import subprocess"], "goodparts": []}], "source": "\n import os.path import subprocess try: from sonic_psu.psu_base import PsuBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class PsuUtil(PsuBase): \"\"\"Platform-specific PSUutil class\"\"\" def __init__(self): PsuBase.__init__(self) def get_num_psus(self): \"\"\" Retrieves the number of PSUs available on the device :return: An integer, the number of PSUs available on the device \"\"\" return 2 def get_psu_status(self, index): \"\"\" Retrieves the oprational status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is operating properly, False if PSU is faulty \"\"\" if index is None: return False status=1 return status==1 def get_psu_presence(self, index): \"\"\" Retrieves the presence status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is plugged, False if not \"\"\" if index is None: return False status=1 return status==1 ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Module contains an implementation of SONiC PSU Base API and\n# provides the PSUs status which are available in the platform\n#\n#############################################################################\n\nimport os.path\nimport subprocess\n\ntry:\n    from sonic_psu.psu_base import PsuBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass PsuUtil(PsuBase):\n    \"\"\"Platform-specific PSUutil class\"\"\"\n\n    def __init__(self):\n        PsuBase.__init__(self)\n\n    def get_num_psus(self):\n        \"\"\"\n        Retrieves the number of PSUs available on the device\n\n        :return: An integer, the number of PSUs available on the device\n        \"\"\"\n        return 2\n\n    def get_psu_status(self, index):\n        \"\"\"\n        Retrieves the oprational status of power supply unit (PSU) defined\n                by 1-based index <index>\n\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is operating properly, False if PSU is faulty\n        \"\"\"\n        if index is None:\n            return False\n\n        status = 1\n        return status == 1\n\n    def get_psu_presence(self, index):\n        \"\"\"\n        Retrieves the presence status of power supply unit (PSU) defined\n                by 1-based index <index>\n\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is plugged, False if not\n        \"\"\"\n        if index is None:\n            return False\n\n        status = 1\n        return status == 1\n"}, "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n GETREG_PATH = \"/sys/devices/platform/dx010_cpld/getreg\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n STATUS_LED_PATH = \"/sys/devices/platform/leds_dx010/leds/dx010:green:stat/brightnes", "add": 0, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": []}], "source": "\n try: import sys from sonic_platform_base.chassis_base import ChassisBase from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper from sonic_py_common import device_info from.event import SfpEvent from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=5 NUM_PSU=2 NUM_THERMAL=5 NUM_SFP=32 NUM_COMPONENT=5 RESET_REGISTER=\"0x103\" HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" GETREG_PATH=\"/sys/devices/platform/dx010_cpld/getreg\" HOST_CHK_CMD=\"docker > /dev/null 2>&1\" STATUS_LED_PATH=\"/sys/devices/platform/leds_dx010/leds/dx010:green:stat/brightness\" class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self.sfp_module_initialized=False self.__initialize_eeprom() self.is_host=self._api_helper.is_host() self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() def __initialize_sfp(self): sfputil_helper=SfpUtilHelper() port_config_file_path=device_info.get_path_to_port_config_file() sfputil_helper.read_porttab_mappings(port_config_file_path, 0) from sonic_platform.sfp import Sfp for index in range(0, NUM_SFP): sfp=Sfp(index, sfputil_helper.logical[index]) self._sfp_list.append(sfp) self.sfp_module_initialized=True def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for i in range(NUM_FAN_TRAY): fandrawer=FanDrawer(i) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_thermals(self): from sonic_platform.thermal import Thermal airflow=self.__get_air_flow() for index in range(0, NUM_THERMAL): thermal=Thermal(index, airflow) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __get_air_flow(self): air_flow_path='/usr/share/sonic/device/{}/fan_airflow'.format( self._api_helper.platform) \\ if self.is_host else '/usr/share/sonic/platform/fan_airflow' air_flow=self._api_helper.read_one_line_file(air_flow_path) return air_flow or 'B2F' def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. REBOOT_CAUSE_POWER_LOSS=\"Power Loss\" REBOOT_CAUSE_THERMAL_OVERLOAD_CPU=\"Thermal Overload: CPU\" REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC=\"Thermal Overload: ASIC\" REBOOT_CAUSE_THERMAL_OVERLOAD_OTHER=\"Thermal Overload: Other\" REBOOT_CAUSE_INSUFFICIENT_FAN_SPEED=\"Insufficient Fan Speed\" REBOOT_CAUSE_WATCHDOG=\"Watchdog\" REBOOT_CAUSE_HARDWARE_OTHER=\"Hardware -Other\" REBOOT_CAUSE_NON_HARDWARE=\"Non-Hardware\" \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" hw_reboot_cause=self._api_helper.get_cpld_reg_value( GETREG_PATH, RESET_REGISTER) prev_reboot_cause={ '0x11':(self.REBOOT_CAUSE_POWER_LOSS, 'Power on reset'), '0x22':(self.REBOOT_CAUSE_HARDWARE_OTHER, 'CPLD_WD_RESET'), '0x33':(self.REBOOT_CAUSE_HARDWARE_OTHER, 'Power cycle reset triggered by CPU'), '0x44':(self.REBOOT_CAUSE_HARDWARE_OTHER, 'Power cycle reset triggered by reset button'), '0x55':(self.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU, ''), '0x66':(self.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC, ''), '0x77':(self.REBOOT_CAUSE_WATCHDOG, '') }.get(hw_reboot_cause,(self.REBOOT_CAUSE_HARDWARE_OTHER, 'Unknown reason')) if sw_reboot_cause !='Unknown' and hw_reboot_cause=='0x11': prev_reboot_cause=( self.REBOOT_CAUSE_NON_HARDWARE, sw_reboot_cause) return prev_reboot_cause def get_change_event(self, timeout=0): \"\"\" Returns a nested dictionary containing all devices which have experienced a change at chassis level Args: timeout: Timeout in milliseconds(optional). If timeout==0, this method will block until a change is detected. Returns: (bool, dict): -True if call successful, False if not; -A nested dictionary where key is a device type, value is a dictionary with key:value pairs in the format of {'device_id':'device_event'}, where device_id is the device ID for this device and device_event, status='1' represents device inserted, status='0' represents device removed. Ex.{'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}} indicates that fan 0 has been removed, fan 2 has been inserted and sfp 11 has been removed. \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() sfp_event=SfpEvent(self._sfp_list).get_sfp_event(timeout) if sfp_event: return True,{'sfp': sfp_event} return False,{'sfp':{}} def get_num_sfps(self): \"\"\" Retrieves the number of sfps available on this chassis Returns: An integer, the number of sfps available on this chassis \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() return len(self._sfp_list) def get_all_sfps(self): \"\"\" Retrieves all sfps available on this chassis Returns: A list of objects derived from SfpBase representing all sfps available on this chassis \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfp_list def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index -1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_watchdog(self): \"\"\" Retreives hardware watchdog device on this chassis Returns: An object derived from WatchdogBase representing the hardware watchdog device \"\"\" if self._watchdog is None: from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() return self._watchdog def get_thermal_manager(self): from.thermal_manager import ThermalManager return ThermalManager def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._api_helper.hwsku def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return self._eeprom.get_serial() def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def set_status_led(self, color): \"\"\" Sets the state of the PSU status LED Args: color: A string representing the color with which to set the PSU status LED Note: Only support green and off Returns: bool: True if status LED state is set successfully, False if not \"\"\" set_status_str={ self.STATUS_LED_COLOR_GREEN: '1', self.STATUS_LED_COLOR_OFF: '0' }.get(color, None) if not set_status_str: return False return self._api_helper.write_txt_file(STATUS_LED_PATH, set_status_str) def get_status_led(self): \"\"\" Gets the state of the PSU status LED Returns: A string, one of the predefined STATUS_LED_COLOR_* strings above \"\"\" status=self._api_helper.read_txt_file(STATUS_LED_PATH) status_str={ '255': self.STATUS_LED_COLOR_GREEN, '0': self.STATUS_LED_COLOR_OFF }.get(status, None) return status_str ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\ntry:\n    import sys\n    from sonic_platform_base.chassis_base import ChassisBase\n    from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper\n    from sonic_py_common import device_info\n    from .event import SfpEvent\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 5\nNUM_PSU = 2\nNUM_THERMAL = 5\nNUM_SFP = 32\nNUM_COMPONENT = 5\nRESET_REGISTER = \"0x103\"\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nGETREG_PATH = \"/sys/devices/platform/dx010_cpld/getreg\"\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nSTATUS_LED_PATH = \"/sys/devices/platform/leds_dx010/leds/dx010:green:stat/brightness\"\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self.sfp_module_initialized = False\n        self.__initialize_eeprom()\n        self.is_host = self._api_helper.is_host()\n\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n\n    def __initialize_sfp(self):\n        sfputil_helper = SfpUtilHelper()\n        port_config_file_path = device_info.get_path_to_port_config_file()\n        sfputil_helper.read_porttab_mappings(port_config_file_path, 0)\n\n        from sonic_platform.sfp import Sfp\n        for index in range(0, NUM_SFP):\n            sfp = Sfp(index, sfputil_helper.logical[index])\n            self._sfp_list.append(sfp)\n        self.sfp_module_initialized = True\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_fan(self):\n        from sonic_platform.fan_drawer import FanDrawer\n        for i in range(NUM_FAN_TRAY):\n            fandrawer = FanDrawer(i)\n            self._fan_drawer_list.append(fandrawer)\n            self._fan_list.extend(fandrawer._fan_list)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        airflow = self.__get_air_flow()\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index, airflow)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __get_air_flow(self):\n        air_flow_path = '/usr/share/sonic/device/{}/fan_airflow'.format(\n            self._api_helper.platform) \\\n            if self.is_host else '/usr/share/sonic/platform/fan_airflow'\n        air_flow = self._api_helper.read_one_line_file(air_flow_path)\n        return air_flow or 'B2F'\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n\n            REBOOT_CAUSE_POWER_LOSS = \"Power Loss\"\n            REBOOT_CAUSE_THERMAL_OVERLOAD_CPU = \"Thermal Overload: CPU\"\n            REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC = \"Thermal Overload: ASIC\"\n            REBOOT_CAUSE_THERMAL_OVERLOAD_OTHER = \"Thermal Overload: Other\"\n            REBOOT_CAUSE_INSUFFICIENT_FAN_SPEED = \"Insufficient Fan Speed\"\n            REBOOT_CAUSE_WATCHDOG = \"Watchdog\"\n            REBOOT_CAUSE_HARDWARE_OTHER = \"Hardware - Other\"\n            REBOOT_CAUSE_NON_HARDWARE = \"Non-Hardware\"\n\n        \"\"\"\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n        hw_reboot_cause = self._api_helper.get_cpld_reg_value(\n            GETREG_PATH, RESET_REGISTER)\n\n        prev_reboot_cause = {\n            '0x11': (self.REBOOT_CAUSE_POWER_LOSS, 'Power on reset'),\n            '0x22': (self.REBOOT_CAUSE_HARDWARE_OTHER, 'CPLD_WD_RESET'),\n            '0x33': (self.REBOOT_CAUSE_HARDWARE_OTHER, 'Power cycle reset triggered by CPU'),\n            '0x44': (self.REBOOT_CAUSE_HARDWARE_OTHER, 'Power cycle reset triggered by reset button'),\n            '0x55': (self.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU, ''),\n            '0x66': (self.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC, ''),\n            '0x77': (self.REBOOT_CAUSE_WATCHDOG, '')\n        }.get(hw_reboot_cause, (self.REBOOT_CAUSE_HARDWARE_OTHER, 'Unknown reason'))\n\n        if sw_reboot_cause != 'Unknown' and hw_reboot_cause == '0x11':\n            prev_reboot_cause = (\n                self.REBOOT_CAUSE_NON_HARDWARE, sw_reboot_cause)\n\n        return prev_reboot_cause\n\n    def get_change_event(self, timeout=0):\n        \"\"\"\n        Returns a nested dictionary containing all devices which have\n        experienced a change at chassis level\n        Args:\n            timeout: Timeout in milliseconds (optional). If timeout == 0,\n                this method will block until a change is detected.\n        Returns:\n            (bool, dict):\n                - True if call successful, False if not;\n                - A nested dictionary where key is a device type,\n                  value is a dictionary with key:value pairs in the format of\n                  {'device_id':'device_event'},\n                  where device_id is the device ID for this device and\n                        device_event,\n                             status='1' represents device inserted,\n                             status='0' represents device removed.\n                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}\n                      indicates that fan 0 has been removed, fan 2\n                      has been inserted and sfp 11 has been removed.\n        \"\"\"\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        sfp_event = SfpEvent(self._sfp_list).get_sfp_event(timeout)\n        if sfp_event:\n            return True, {'sfp': sfp_event}\n\n        return False, {'sfp': {}}\n\n    ##############################################################\n    ######################## SFP methods #########################\n    ##############################################################\n\n    def get_num_sfps(self):\n        \"\"\"\n        Retrieves the number of sfps available on this chassis\n        Returns:\n            An integer, the number of sfps available on this chassis\n        \"\"\"\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return len(self._sfp_list)\n\n    def get_all_sfps(self):\n        \"\"\"\n        Retrieves all sfps available on this chassis\n        Returns:\n            A list of objects derived from SfpBase representing all sfps\n            available on this chassis\n        \"\"\"\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return self._sfp_list\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index - 1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    ##############################################################\n    ####################### Other methods ########################\n    ##############################################################\n\n    def get_watchdog(self):\n        \"\"\"\n        Retreives hardware watchdog device on this chassis\n        Returns:\n            An object derived from WatchdogBase representing the hardware\n            watchdog device\n        \"\"\"\n        if self._watchdog is None:\n            from sonic_platform.watchdog import Watchdog\n            self._watchdog = Watchdog()\n\n        return self._watchdog\n\n    def get_thermal_manager(self):\n        from .thermal_manager import ThermalManager\n        return ThermalManager\n\n    ##############################################################\n    ###################### Device methods ########################\n    ##############################################################\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return self._api_helper.hwsku\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the PSU status LED\n        Args:\n            color: A string representing the color with which to set the PSU status LED\n                   Note: Only support green and off\n        Returns:\n            bool: True if status LED state is set successfully, False if not\n        \"\"\"\n\n        set_status_str = {\n            self.STATUS_LED_COLOR_GREEN: '1',\n            self.STATUS_LED_COLOR_OFF: '0'\n        }.get(color, None)\n\n        if not set_status_str:\n            return False\n\n        return self._api_helper.write_txt_file(STATUS_LED_PATH, set_status_str)\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the PSU status LED\n        Returns:\n            A string, one of the predefined STATUS_LED_COLOR_* strings above\n        \"\"\"\n        status = self._api_helper.read_txt_file(STATUS_LED_PATH)\n        status_str = {\n            '255': self.STATUS_LED_COLOR_GREEN,\n            '0': self.STATUS_LED_COLOR_OFF\n        }.get(status, None)\n\n        return status_str\n"}, "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py": {"changes": [{"diff": "\n \n import os.path\n import shutil\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py", "badparts": ["import subprocess"], "goodparts": []}, {"diff": "\n \n     def get_register_value(self, register):\n         # Retrieves the cpld register value\n-        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n-        p = subprocess.Popen(\n-            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-        raw_data, err = p.communicate()\n-        if err is not '':\n-            return None\n+        with open(GETREG_PATH, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(GETREG_PATH, 'r') as file:\n+            raw_data = file.readline()\n         return raw_data.strip()\n \n     def __get_cpld_version(self):\n", "add": 4, "remove": 6, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py", "badparts": ["        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)", "        p = subprocess.Popen(", "            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "        raw_data, err = p.communicate()", "        if err is not '':", "            return None"], "goodparts": ["        with open(GETREG_PATH, 'w') as file:", "            file.write(register + '\\n')", "        with open(GETREG_PATH, 'r') as file:", "            raw_data = file.readline()"]}, {"diff": "\n             ext = \".vme\" if ext == \"\" else ext\n             new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n             shutil.copy(image_path, new_image_path)\n-            install_command = \"ispvm %s\" % new_image_path\n+            install_command = [\"ispvm\", str(new_image_path)]\n         # elif self.name == \"BIOS\":\n         #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n \n-        return self.__run_command(install_command)\n+        return self._api_helper.run_command(install_command)\n \n \n     def update_firmware(self, image", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py", "badparts": ["            install_command = \"ispvm %s\" % new_image_path", "        return self.__run_command(install_command)"], "goodparts": ["            install_command = [\"ispvm\", str(new_image_path)]", "        return self._api_helper.run_command(install_command)"]}], "source": "\n import os.path import shutil import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"0x100\", \"CPLD2\": \"0x200\", \"CPLD3\": \"0x280\", \"CPLD4\": \"0x300\", \"CPLD5\": \"0x380\" } GETREG_PATH=\"/sys/devices/platform/dx010_cpld/getreg\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_NAME_LIST=[\"CPLD1\", \"CPLD2\", \"CPLD3\", \"CPLD4\", \"BIOS\"] COMPONENT_DES_LIST=[\"Used for managing the CPU\", \"Used for managing QSFP+ports(1-10)\", \"Used for managing QSFP+ports(11-20)\", \"Used for managing QSFP+ports(22-32)\", \"Basic Input/Output System\"] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index): ComponentBase.__init__(self) self.index=component_index self._api_helper=APIHelper() self.name=self.get_name() def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def get_register_value(self, register): cmd=\"echo{1} >{0}; cat{0}\".format(GETREG_PATH, register) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err is not '': return None return raw_data.strip() def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_addr=CPLD_ADDR_MAPPING[cpld_name] cpld_version_raw=self.get_register_value(cpld_addr) cpld_version_str=\"{}.{}\".format(int(cpld_version_raw[2], 16), int( cpld_version_raw[3], 16)) if cpld_version_raw is not None else 'None' cpld_version[cpld_name]=cpld_version_str except Exception as e: cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_NAME_LIST[self.index] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_DES_LIST[self.index] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def get_available_firmware_version(self, image_path): \"\"\" Retrieves the available firmware version of the component Note: the firmware version will be read from image Args: image_path: A string, path to firmware image Returns: A string containing the available firmware version of the component \"\"\" return \"N/A\" def get_firmware_update_notification(self, image_path): \"\"\" Retrieves a notification on what should be done in order to complete the component firmware update Args: image_path: A string, path to firmware image Returns: A string containing the component firmware update notification if required. By default 'None' value will be used, which indicates that no actions are required \"\"\" return \"None\" def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" if not os.path.isfile(image_path): return False if \"CPLD\" in self.name: img_name=os.path.basename(image_path) root, ext=os.path.splitext(img_name) ext=\".vme\" if ext==\"\" else ext new_image_path=os.path.join(\"/tmp\",(root.lower() +ext)) shutil.copy(image_path, new_image_path) install_command=\"ispvm %s\" % new_image_path return self.__run_command(install_command) def update_firmware(self, image_path): \"\"\" Updates firmware of the component This API performs firmware update: it assumes firmware installation and loading in a single call. In case platform component requires some extra steps(apart from calling Low Level Utility) to load the installed firmware(e.g, reboot, power cycle, etc.) -this will be done automatically by API Args: image_path: A string, path to firmware image Raises: RuntimeError: update failed \"\"\" return False def get_presence(self): \"\"\" Retrieves the presence of the FAN Returns: bool: True if FAN is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return 'N/A' def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return 'N/A' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is'0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport os.path\nimport shutil\nimport subprocess\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"0x100\",\n    \"CPLD2\": \"0x200\",\n    \"CPLD3\": \"0x280\",\n    \"CPLD4\": \"0x300\",\n    \"CPLD5\": \"0x380\"\n}\nGETREG_PATH = \"/sys/devices/platform/dx010_cpld/getreg\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_NAME_LIST = [\"CPLD1\", \"CPLD2\", \"CPLD3\", \"CPLD4\", \"BIOS\"]\nCOMPONENT_DES_LIST = [\"Used for managing the CPU\",\n                      \"Used for managing QSFP+ ports (1-10)\", \"Used for managing QSFP+ ports (11-20)\", \"Used for managing QSFP+ ports (22-32)\", \"Basic Input/Output System\"]\n\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index):\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self._api_helper = APIHelper()\n        self.name = self.get_name()\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def get_register_value(self, register):\n        # Retrieves the cpld register value\n        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n        p = subprocess.Popen(\n            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        raw_data, err = p.communicate()\n        if err is not '':\n            return None\n        return raw_data.strip()\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_addr = CPLD_ADDR_MAPPING[cpld_name]\n                cpld_version_raw = self.get_register_value(cpld_addr)\n                cpld_version_str = \"{}.{}\".format(int(cpld_version_raw[2], 16), int(\n                    cpld_version_raw[3], 16)) if cpld_version_raw is not None else 'None'\n                cpld_version[cpld_name] = cpld_version_str\n            except Exception as e:\n                cpld_version[cpld_name] = 'None'\n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_NAME_LIST[self.index]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_DES_LIST[self.index]\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def get_available_firmware_version(self, image_path):\n        \"\"\"\n        Retrieves the available firmware version of the component\n        Note: the firmware version will be read from image\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A string containing the available firmware version of the component\n        \"\"\"\n        return \"N/A\"\n\n    def get_firmware_update_notification(self, image_path):\n        \"\"\"\n        Retrieves a notification on what should be done in order to complete\n        the component firmware update\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A string containing the component firmware update notification if required.\n            By default 'None' value will be used, which indicates that no actions are required\n        \"\"\"\n        return \"None\"\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        if not os.path.isfile(image_path):\n            return False\n\n        if \"CPLD\" in self.name:\n            img_name = os.path.basename(image_path)\n            root, ext = os.path.splitext(img_name)\n            ext = \".vme\" if ext == \"\" else ext\n            new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n            shutil.copy(image_path, new_image_path)\n            install_command = \"ispvm %s\" % new_image_path\n        # elif self.name == \"BIOS\":\n        #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n\n        return self.__run_command(install_command)\n\n\n    def update_firmware(self, image_path):\n        \"\"\"\n        Updates firmware of the component\n        This API performs firmware update: it assumes firmware installation and loading in a single call.\n        In case platform component requires some extra steps (apart from calling Low Level Utility)\n        to load the installed firmware (e.g, reboot, power cycle, etc.) - this will be done automatically by API\n        Args:\n            image_path: A string, path to firmware image\n        Raises:\n            RuntimeError: update failed\n        \"\"\"\n        return False\n\n\n    ##############################################################\n    ###################### Device methods ########################\n    ##############################################################\n\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the FAN\n        Returns:\n            bool: True if FAN is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of\n        entPhysicalContainedIn is'0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device\n            or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n \n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 5, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        try:", "            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)", "        except FileNotFoundError:", "            return False", "        return True"]}, {"diff": "\n         result = \"\"\n         try:\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = raw_data.strip()\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py", "badparts": ["                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"], "goodparts": ["                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n", "add": 0, "remove": 7, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py", "badparts": ["    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n         return True\n \n     def get_cpld_reg_value(self, getreg_path, register):\n-        cmd = \"echo {1} > {0}; cat {0}\".format(getreg_path, register)\n-        status, result = self.run_command(cmd)\n-        return result if status else None\n+        with open(getreg_path, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(getreg_path, 'r') as file:\n+            result = file.readline()\n+        return result\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(\n-                str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status", "add": 5, "remove": 53, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py", "badparts": ["        cmd = \"echo {1} > {0}; cat {0}\".format(getreg_path, register)", "        status, result = self.run_command(cmd)", "        return result if status else None", "    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(", "                str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except:", "            status = False", "        return status"], "goodparts": ["        with open(getreg_path, 'w') as file:", "            file.write(register + '\\n')", "        with open(getreg_path, 'r') as file:", "            result = file.readline()", "        return result"]}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def read_one_line_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.readline() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except Exception: return False return True def get_cpld_reg_value(self, getreg_path, register): cmd=\"echo{1} >{0}; cat{0}\".format(getreg_path, register) status, result=self.run_command(cmd) return result if status else None def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format( str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\n\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def read_one_line_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.readline()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except Exception:\n            return False\n        return True\n\n    def get_cpld_reg_value(self, getreg_path, register):\n        cmd = \"echo {1} > {0}; cat {0}\".format(getreg_path, register)\n        status, result = self.run_command(cmd)\n        return result if status else None\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(\n                str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n"}, "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py": {"changes": [{"diff": "\n         thermal_overload_position = APIHelper().read_one_line_file(\n             thermal_overload_position_path)\n \n-        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\n-            thermal_overload_position)\n+        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', str(thermal_overload_position)]\n         APIHelper().run_com", "add": 1, "remove": 2, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py", "badparts": ["        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(", "            thermal_overload_position)"], "goodparts": ["        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', str(thermal_overload_position)]"]}], "source": "\n\nfrom sonic_platform_base.sonic_thermal_control.thermal_action_base import ThermalPolicyActionBase from sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object from.thermal_infos import ChassisInfo from.helper import APIHelper @thermal_json_object('thermal_control.control') class ControlThermalAlgoAction(ThermalPolicyActionBase): \"\"\" Action to control the thermal control algorithm \"\"\" JSON_FIELD_STATUS='status' def __init__(self): self.status=True def load_from_json(self, json_obj): \"\"\" Construct ControlThermalAlgoAction via JSON. JSON example: { \"type\": \"thermal_control.control\" \"status\": \"true\" } :param json_obj: A JSON object representing a ControlThermalAlgoAction action. :return: \"\"\" if ControlThermalAlgoAction.JSON_FIELD_STATUS in json_obj: status_str=json_obj[ControlThermalAlgoAction.JSON_FIELD_STATUS].lower() if status_str=='true': self.status=True elif status_str=='false': self.status=False else: raise ValueError('Invalid{} field value, please specify true of false'. format(ControlThermalAlgoAction.JSON_FIELD_STATUS)) else: raise ValueError('ControlThermalAlgoAction ' 'missing mandatory field{} in JSON policy file'. format(ControlThermalAlgoAction.JSON_FIELD_STATUS)) def execute(self, thermal_info_dict): \"\"\" Disable thermal control algorithm :param thermal_info_dict: A dictionary stores all thermal information. :return: \"\"\" if ChassisInfo.INFO_NAME in thermal_info_dict: chassis_info_obj=thermal_info_dict[ChassisInfo.INFO_NAME] chassis=chassis_info_obj.get_chassis() thermal_manager=chassis.get_thermal_manager() if self.status: thermal_manager.start_thermal_control_algorithm() else: thermal_manager.stop_thermal_control_algorithm() @thermal_json_object('switch.power_cycling') class SwitchPolicyAction(ThermalPolicyActionBase): \"\"\" Base class for thermal action. Once all thermal conditions in a thermal policy are matched, all predefined thermal action will be executed. \"\"\" def execute(self, thermal_info_dict): \"\"\" Take action when thermal condition matches. For example, power cycle the switch. :param thermal_info_dict: A dictionary stores all thermal information. :return: \"\"\" thermal_overload_position_path='/tmp/thermal_overload_position' thermal_overload_position=APIHelper().read_one_line_file( thermal_overload_position_path) cmd='bash /usr/share/sonic/platform/thermal_overload_control.sh{}'.format( thermal_overload_position) APIHelper().run_command(cmd) ", "sourceWithComments": "\nfrom sonic_platform_base.sonic_thermal_control.thermal_action_base import ThermalPolicyActionBase\nfrom sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object\nfrom .thermal_infos import ChassisInfo\nfrom .helper import APIHelper\n\n\n@thermal_json_object('thermal_control.control')\nclass ControlThermalAlgoAction(ThermalPolicyActionBase):\n    \"\"\"\n    Action to control the thermal control algorithm\n    \"\"\"\n    # JSON field definition\n    JSON_FIELD_STATUS = 'status'\n\n    def __init__(self):\n        self.status = True\n\n    def load_from_json(self, json_obj):\n        \"\"\"\n        Construct ControlThermalAlgoAction via JSON. JSON example:\n            {\n                \"type\": \"thermal_control.control\"\n                \"status\": \"true\"\n            }\n        :param json_obj: A JSON object representing a ControlThermalAlgoAction action.\n        :return:\n        \"\"\"\n        if ControlThermalAlgoAction.JSON_FIELD_STATUS in json_obj:\n            status_str = json_obj[ControlThermalAlgoAction.JSON_FIELD_STATUS].lower()\n            if status_str == 'true':\n                self.status = True\n            elif status_str == 'false':\n                self.status = False\n            else:\n                raise ValueError('Invalid {} field value, please specify true of false'.\n                                 format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\n        else:\n            raise ValueError('ControlThermalAlgoAction '\n                             'missing mandatory field {} in JSON policy file'.\n                             format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\n\n    def execute(self, thermal_info_dict):\n        \"\"\"\n        Disable thermal control algorithm\n        :param thermal_info_dict: A dictionary stores all thermal information.\n        :return:\n        \"\"\"\n        if ChassisInfo.INFO_NAME in thermal_info_dict:\n            chassis_info_obj = thermal_info_dict[ChassisInfo.INFO_NAME]\n            chassis = chassis_info_obj.get_chassis()\n            thermal_manager = chassis.get_thermal_manager()\n            if self.status:\n                thermal_manager.start_thermal_control_algorithm()\n            else:\n                thermal_manager.stop_thermal_control_algorithm()\n\n\n@thermal_json_object('switch.power_cycling')\nclass SwitchPolicyAction(ThermalPolicyActionBase):\n    \"\"\"\n    Base class for thermal action. Once all thermal conditions in a thermal policy are matched,\n    all predefined thermal action will be executed.\n    \"\"\"\n\n    def execute(self, thermal_info_dict):\n        \"\"\"\n        Take action when thermal condition matches. For example, power cycle the switch.\n        :param thermal_info_dict: A dictionary stores all thermal information.\n        :return:\n        \"\"\"\n        thermal_overload_position_path = '/tmp/thermal_overload_position'\n        thermal_overload_position = APIHelper().read_one_line_file(\n            thermal_overload_position_path)\n\n        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\n            thermal_overload_position)\n        APIHelper().run_command(cmd)\n"}, "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py": {"changes": [{"diff": "\n from .thermal_infos import *\n \n class ThermalManager(ThermalManagerBase):\n-    FSC_ALGORITHM_CMD = 'service fancontrol {}'\n+    FSC_ALGORITHM_CMD = ['service', 'fancontrol', '']\n \n     @classmethod\n     def start_thermal_control_algorithm(cls):\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py", "badparts": ["    FSC_ALGORITHM_CMD = 'service fancontrol {}'"], "goodparts": ["    FSC_ALGORITHM_CMD = ['service', 'fancontrol', '']"]}, {"diff": "\n         Returns:\n             bool: True if set success, False if fail.\n         \"\"\"\n-        cmd = 'start' if enable else 'stop'\n-        return APIHelper().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n+        cls.FSC_ALGORITHM_CMD[2] = 'start' if enable else 'stop'\n+        return APIHelper().run_command(cls.FSC_ALGO", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py", "badparts": ["        cmd = 'start' if enable else 'stop'", "        return APIHelper().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))"], "goodparts": ["        cls.FSC_ALGORITHM_CMD[2] = 'start' if enable else 'stop'", "        return APIHelper().run_command(cls.FSC_ALGO"]}], "source": "\nfrom sonic_platform_base.sonic_thermal_control.thermal_manager_base import ThermalManagerBase from.helper import APIHelper from.thermal_actions import * from.thermal_conditions import * from.thermal_infos import * class ThermalManager(ThermalManagerBase): FSC_ALGORITHM_CMD='service fancontrol{}' @classmethod def start_thermal_control_algorithm(cls): \"\"\" Start vendor specific thermal control algorithm. The default behavior of this function is a no-op. :return: \"\"\" return cls._enable_fancontrol_service(True) @classmethod def stop_thermal_control_algorithm(cls): \"\"\" Stop thermal control algorithm Returns: bool: True if set success, False if fail. \"\"\" return cls._enable_fancontrol_service(False) @classmethod def deinitialize(cls): \"\"\" Destroy thermal manager, including any vendor specific cleanup. The default behavior of this function is a no-op. :return: \"\"\" return cls._enable_fancontrol_service(True) @classmethod def _enable_fancontrol_service(cls, enable): \"\"\" Control thermal by fcs algorithm Args: enable: Bool, indicate enable the algorithm or not Returns: bool: True if set success, False if fail. \"\"\" cmd='start' if enable else 'stop' return APIHelper().run_command(cls.FSC_ALGORITHM_CMD.format(cmd)) ", "sourceWithComments": "from sonic_platform_base.sonic_thermal_control.thermal_manager_base import ThermalManagerBase\nfrom .helper import APIHelper\nfrom .thermal_actions import *\nfrom .thermal_conditions import *\nfrom .thermal_infos import *\n\nclass ThermalManager(ThermalManagerBase):\n    FSC_ALGORITHM_CMD = 'service fancontrol {}'\n\n    @classmethod\n    def start_thermal_control_algorithm(cls):\n        \"\"\"\n        Start vendor specific thermal control algorithm. The default behavior of this function is a no-op.\n        :return:\n        \"\"\"\n        return cls._enable_fancontrol_service(True)\n\n    @classmethod\n    def stop_thermal_control_algorithm(cls):\n        \"\"\"\n        Stop thermal control algorithm\n        Returns:\n            bool: True if set success, False if fail.\n        \"\"\"\n        return cls._enable_fancontrol_service(False)\n\n    @classmethod\n    def deinitialize(cls):\n        \"\"\"\n        Destroy thermal manager, including any vendor specific cleanup. The default behavior of this function\n        is a no-op.\n        :return:\n        \"\"\"\n        return cls._enable_fancontrol_service(True)\n\n    @classmethod\n    def _enable_fancontrol_service(cls, enable):\n        \"\"\"\n        Control thermal by fcs algorithm\n        Args:\n            enable: Bool, indicate enable the algorithm or not\n        Returns:\n            bool: True if set success, False if fail.\n        \"\"\"\n        cmd = 'start' if enable else 'stop'\n        return APIHelper().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n"}, "/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py": {"changes": [{"diff": "\n-import os.path\n-import subprocess\n import sys\n import re\n \n try:\n     from sonic_psu.psu_base import PsuBase\n+    from sonic_py_common.general import getstatusoutput_noshell_pipe\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n", "add": 1, "remove": 2, "filename": "/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py", "badparts": ["import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell_pipe"]}, {"diff": "\n     \"\"\"Platform-specific PSUutil class\"\"\"\n \n     def __init__(self):\n-        self.ipmi_sensor = \"ipmitool sensor\"\n+        self.ipmi_sensor = [\"ipmitool\", \"sensor\"]\n         PsuBase.__init__(self)\n \n-    def run_command(self, command):\n-        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n-        (out, err) = proc.communicate()\n-\n-        if proc.returncode != 0:\n-            sys.exit(proc.returncode)\n-\n+    def run_command(self, cmd1, cmd2):\n+        exitcode, out = getstatusoutput_noshell_pipe(cmd1, cmd2)\n+        i = 0\n+        while i < 2:\n+            if exitcode[i] != 0:\n+                sys.exit(exitcode[i])\n+            i += 1\n         return out\n \n     def find_value(self, grep_string):\n", "add": 8, "remove": 8, "filename": "/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py", "badparts": ["        self.ipmi_sensor = \"ipmitool sensor\"", "    def run_command(self, command):", "        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)", "        (out, err) = proc.communicate()", "        if proc.returncode != 0:", "            sys.exit(proc.returncode)"], "goodparts": ["        self.ipmi_sensor = [\"ipmitool\", \"sensor\"]", "    def run_command(self, cmd1, cmd2):", "        exitcode, out = getstatusoutput_noshell_pipe(cmd1, cmd2)", "        i = 0", "        while i < 2:", "            if exitcode[i] != 0:", "                sys.exit(exitcode[i])", "            i += 1"]}, {"diff": "\n             return False\n \n         grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n-        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n+        grep_cmd = [\"grep\", grep_key]\n+        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)\n         status_byte = self.find_value(grep_string)\n \n         if status_byte is None:\n", "add": 2, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py", "badparts": ["        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)"], "goodparts": ["        grep_cmd = [\"grep\", grep_key]", "        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)"]}, {"diff": "\n             return False\n \n         grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n-        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n+        grep_cmd = [\"grep\", grep_key]\n+        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)\n         status_byte = self.find_value(grep_string)\n \n         if status_by", "add": 2, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py", "badparts": ["        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)"], "goodparts": ["        grep_cmd = [\"grep\", grep_key]", "        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)"]}], "source": "\nimport os.path import subprocess import sys import re try: from sonic_psu.psu_base import PsuBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class PsuUtil(PsuBase): \"\"\"Platform-specific PSUutil class\"\"\" def __init__(self): self.ipmi_sensor=\"ipmitool sensor\" PsuBase.__init__(self) def run_command(self, command): proc=subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE) (out, err)=proc.communicate() if proc.returncode !=0: sys.exit(proc.returncode) return out def find_value(self, grep_string): result=re.search(\".+\\|(0x\\d{2})\\d{2}\\|.+\", grep_string) if result: return result.group(1) else: return result def get_num_psus(self): \"\"\" Retrieves the number of PSUs available on the device :return: An integer, the number of PSUs available on the device \"\"\" return 2 def get_psu_status(self, index): \"\"\" Retrieves the oprational status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is operating properly, False if PSU is faulty \"\"\" if index is None: return False grep_key=\"PSUL_Status\" if index==1 else \"PSUR_Status\" grep_string=self.run_command(self.ipmi_sensor +' | grep ' +grep_key) status_byte=self.find_value(grep_string) if status_byte is None: return False failure_detected=(int(status_byte, 16) >> 1) & 1 input_lost=(int(status_byte, 16) >> 3) & 1 if failure_detected or input_lost: return False else: return True def get_psu_presence(self, index): \"\"\" Retrieves the presence status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is plugged, False if not \"\"\" if index is None: return False grep_key=\"PSUL_Status\" if index==1 else \"PSUR_Status\" grep_string=self.run_command(self.ipmi_sensor +' | grep ' +grep_key) status_byte=self.find_value(grep_string) if status_byte is None: return False presence=(int(status_byte, 16) >> 0) & 1 if presence: return True else: return False ", "sourceWithComments": "import os.path\nimport subprocess\nimport sys\nimport re\n\ntry:\n    from sonic_psu.psu_base import PsuBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass PsuUtil(PsuBase):\n    \"\"\"Platform-specific PSUutil class\"\"\"\n\n    def __init__(self):\n        self.ipmi_sensor = \"ipmitool sensor\"\n        PsuBase.__init__(self)\n\n    def run_command(self, command):\n        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n        (out, err) = proc.communicate()\n\n        if proc.returncode != 0:\n            sys.exit(proc.returncode)\n\n        return out\n\n    def find_value(self, grep_string):\n        result = re.search(\".+\\| (0x\\d{2})\\d{2}\\|.+\", grep_string)\n        if result:\n            return result.group(1)\n        else:\n            return result\n\n    def get_num_psus(self):\n        \"\"\"\n        Retrieves the number of PSUs available on the device\n        :return: An integer, the number of PSUs available on the device\n        \"\"\"\n        return 2\n\n    def get_psu_status(self, index):\n        \"\"\"\n        Retrieves the oprational status of power supply unit (PSU) defined\n                by 1-based index <index>\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is operating properly, False if PSU is faulty\n        \"\"\"\n        if index is None:\n            return False\n\n        grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n        status_byte = self.find_value(grep_string)\n\n        if status_byte is None:\n            return False\n\n        failure_detected = (int(status_byte, 16) >> 1) & 1\n        input_lost = (int(status_byte, 16) >> 3) & 1\n        if failure_detected or input_lost:\n            return False\n        else:\n            return True\n\n    def get_psu_presence(self, index):\n        \"\"\"\n        Retrieves the presence status of power supply unit (PSU) defined\n                by 1-based index <index>\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is plugged, False if not\n        \"\"\"\n        if index is None:\n            return False\n\n        grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n        status_byte = self.find_value(grep_string)\n\n        if status_byte is None:\n            return False\n\n        presence = (int(status_byte, 16) >> 0) & 1\n        if presence:\n            return True\n        else:\n            return False\n"}, "/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py": {"changes": [{"diff": "\n     \"\"\"Platform-specific PSUutil class\"\"\"\n \n     def __init__(self):\n-        self.ipmi_raw = \"docker exec -ti pmon ipmitool raw 0x4 0x2d\"\n+        self.ipmi_raw = [\"docker\", \"exec\", \"-ti\", \"pmon\", \"ipmitool\", \"raw\", \"0x4\", \"0x2d\", \"\"]\n         self.psu1_id = \"0x2f\"\n         self.psu2_id = \"0x39\"\n         PsuBase.__init__(self)\n \n     def run_command(self, command):\n-        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n         (out, err) = proc.communicate()\n \n         if proc.returncode != 0:\n", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py", "badparts": ["        self.ipmi_raw = \"docker exec -ti pmon ipmitool raw 0x4 0x2d\"", "        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)"], "goodparts": ["        self.ipmi_raw = [\"docker\", \"exec\", \"-ti\", \"pmon\", \"ipmitool\", \"raw\", \"0x4\", \"0x2d\", \"\"]", "        proc = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)"]}, {"diff": "\n             return False\n \n         psu_id = self.psu1_id if index == 1 else self.psu2_id\n-        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n+        self.ipmi_raw[8] = psu_id\n+        res_string = self.run_command(self.ipmi_raw)\n         status_byte = self.find_value(res_string)\n \n         if status_byte is None:\n", "add": 2, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py", "badparts": ["        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)"], "goodparts": ["        self.ipmi_raw[8] = psu_id", "        res_string = self.run_command(self.ipmi_raw)"]}, {"diff": "\n             return False\n \n         psu_id = self.psu1_id if index == 1 else self.psu2_id\n-        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n+        self.ipmi_raw[8] = psu_id\n+        res_string = self.run_command(self.ipmi_raw)\n         status_byte = self.find_value(res_string)\n \n         if status_b", "add": 2, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py", "badparts": ["        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)"], "goodparts": ["        self.ipmi_raw[8] = psu_id", "        res_string = self.run_command(self.ipmi_raw)"]}], "source": "\nimport os.path import subprocess import sys import re try: from sonic_psu.psu_base import PsuBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class PsuUtil(PsuBase): \"\"\"Platform-specific PSUutil class\"\"\" def __init__(self): self.ipmi_raw=\"docker exec -ti pmon ipmitool raw 0x4 0x2d\" self.psu1_id=\"0x2f\" self.psu2_id=\"0x39\" PsuBase.__init__(self) def run_command(self, command): proc=subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE) (out, err)=proc.communicate() if proc.returncode !=0: sys.exit(proc.returncode) return out def find_value(self, in_string): result=re.search(\"^.+([0-9a-f]{2}).+$\", in_string) if result: return result.group(1) else: return result def get_num_psus(self): \"\"\" Retrieves the number of PSUs available on the device :return: An integer, the number of PSUs available on the device \"\"\" return 2 def get_psu_status(self, index): \"\"\" Retrieves the oprational status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is operating properly, False if PSU is faulty \"\"\" if index is None: return False psu_id=self.psu1_id if index==1 else self.psu2_id res_string=self.run_command(self.ipmi_raw +' ' +psu_id) status_byte=self.find_value(res_string) if status_byte is None: return False failure_detected=(int(status_byte, 16) >> 1) & 1 input_lost=(int(status_byte, 16) >> 3) & 1 if failure_detected or input_lost: return False else: return True def get_psu_presence(self, index): \"\"\" Retrieves the presence status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is plugged, False if not \"\"\" if index is None: return False psu_id=self.psu1_id if index==1 else self.psu2_id res_string=self.run_command(self.ipmi_raw +' ' +psu_id) status_byte=self.find_value(res_string) if status_byte is None: return False presence=(int(status_byte, 16) >> 0) & 1 if presence: return True else: return False ", "sourceWithComments": "import os.path\nimport subprocess\nimport sys\nimport re\n\ntry:\n    from sonic_psu.psu_base import PsuBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass PsuUtil(PsuBase):\n    \"\"\"Platform-specific PSUutil class\"\"\"\n\n    def __init__(self):\n        self.ipmi_raw = \"docker exec -ti pmon ipmitool raw 0x4 0x2d\"\n        self.psu1_id = \"0x2f\"\n        self.psu2_id = \"0x39\"\n        PsuBase.__init__(self)\n\n    def run_command(self, command):\n        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n        (out, err) = proc.communicate()\n\n        if proc.returncode != 0:\n            sys.exit(proc.returncode)\n\n        return out\n\n    def find_value(self, in_string):\n        result = re.search(\"^.+ ([0-9a-f]{2}) .+$\", in_string)\n        if result:\n            return result.group(1)\n        else:\n            return result\n\n    def get_num_psus(self):\n        \"\"\"\n        Retrieves the number of PSUs available on the device\n        :return: An integer, the number of PSUs available on the device\n        \"\"\"\n        return 2\n\n    def get_psu_status(self, index):\n        \"\"\"\n        Retrieves the oprational status of power supply unit (PSU) defined\n                by 1-based index <index>\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is operating properly, False if PSU is faulty\n        \"\"\"\n        if index is None:\n            return False\n\n        psu_id = self.psu1_id if index == 1 else self.psu2_id\n        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n        status_byte = self.find_value(res_string)\n\n        if status_byte is None:\n            return False\n\n        failure_detected = (int(status_byte, 16) >> 1) & 1\n        input_lost = (int(status_byte, 16) >> 3) & 1\n        if failure_detected or input_lost:\n            return False\n        else:\n            return True\n\n    def get_psu_presence(self, index):\n        \"\"\"\n        Retrieves the presence status of power supply unit (PSU) defined\n                by 1-based index <index>\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is plugged, False if not\n        \"\"\"\n        if index is None:\n            return False\n\n        psu_id = self.psu1_id if index == 1 else self.psu2_id\n        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n        status_byte = self.find_value(res_string)\n\n        if status_byte is None:\n            return False\n\n        presence = (int(status_byte, 16) >> 0) & 1\n        if presence:\n            return True\n        else:\n            return False\n"}, "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import json\n import os.path\n \n try:\n", "add": 0, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py", "badparts": ["import json"], "goodparts": []}, {"diff": "\n SW_CPLD_VER_PATH = \"/sys/module/switch_cpld/version\"\n BASE_CPLD_VER_PATH = \"/sys/module/baseboard_lpc/version\"\n-CPLD_UPGRADE_OPT = 4\n BIOS_VER_PATH = \"/sys/class/dmi/id/bios_version\"\n-BIOS__UPGRADE_OPT = 2\n-BMC_VER_CMD = \"ipmitool mc info | grep 'Firmware Revision'\"\n-BMC_UPGRADE_OPT = 1\n-CFUFLASH_FW_UPGRADE_CMD = \"CFUFLASH -cd -d {} -mse 3 {}\"\n+BMC_VER_CMD1 = [\"ipmitool\", \"mc\", \"info\"]\n+BMC_VER_CMD2 = [\"grep\", \"Firmware Revision\"]\n+CFUFLASH_FW_UPGRADE_CMD = [\"CFUFLASH\", \"-cd\", \"-d\", \"\", \"-mse\", \"3\", \"\"]\n MEM_PCI_RESOURCE = \"/sys/bus/pci/devices/0000:09:00.0/resource0\"\n FPGA_VER_MEM_OFFSET = 0\n+UPGRADE_OPT = {\n+    'BMC': '1',\n+    'BIOS': '2',\n+    'SWITCH_CPLD': '4',\n+    'BASE_CPLD': '4'\n+}\n \n \n class Component(ComponentBase):\n", "add": 9, "remove": 5, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py", "badparts": ["CPLD_UPGRADE_OPT = 4", "BIOS__UPGRADE_OPT = 2", "BMC_VER_CMD = \"ipmitool mc info | grep 'Firmware Revision'\"", "BMC_UPGRADE_OPT = 1", "CFUFLASH_FW_UPGRADE_CMD = \"CFUFLASH -cd -d {} -mse 3 {}\""], "goodparts": ["BMC_VER_CMD1 = [\"ipmitool\", \"mc\", \"info\"]", "BMC_VER_CMD2 = [\"grep\", \"Firmware Revision\"]", "CFUFLASH_FW_UPGRADE_CMD = [\"CFUFLASH\", \"-cd\", \"-d\", \"\", \"-mse\", \"3\", \"\"]", "UPGRADE_OPT = {", "    'BMC': '1',", "    'BIOS': '2',", "    'SWITCH_CPLD': '4',", "    'BASE_CPLD': '4'", "}"]}, {"diff": "\n \n     def __get_bmc_ver(self):\n         bmc_ver = \"Unknown\"\n-        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD)\n+        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD1, BMC_VER_CMD2)\n         if status:\n             bmc_ver_data = raw_bmc_data.split(\":\")\n             bmc_ver = bmc_ver_data[-1].strip() if len(\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py", "badparts": ["        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD)"], "goodparts": ["        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD1, BMC_VER_CMD2)"]}, {"diff": "\n         Returns:\n             A boolean, True if install successfully, False if not\n         \"\"\"\n-        install_command = {\n-            \"BMC\": CFUFLASH_FW_UPGRADE_CMD.format(BMC_UPGRADE_OPT, image_path),\n-            \"BIOS\": CFUFLASH_FW_UPGRADE_CMD.format(BIOS__UPGRADE_OPT, image_path),\n-            \"SWITCH_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path),\n-            \"BASE_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path)\n-        }.get(self.name, None)\n-\n-        if not os.path.isfile(image_path) or install_command is None:\n+        CFUFLASH_FW_UPGRADE_CMD[3] = UPGRADE_OPT.get(self.name)\n+        CFUFLASH_FW_UPGRADE_CMD[6] = image_path\n+\n+        if not os.path.isfile(image_path):\n             return False\n \n         # print(install_command)\n-        status = self._api_helper.run_interactive_command(install_command)\n+        status = self._api_helper.run_interactive_command(CFUFLASH_FW_UPGRADE_CMD)\n         ", "add": 5, "remove": 9, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py", "badparts": ["        install_command = {", "            \"BMC\": CFUFLASH_FW_UPGRADE_CMD.format(BMC_UPGRADE_OPT, image_path),", "            \"BIOS\": CFUFLASH_FW_UPGRADE_CMD.format(BIOS__UPGRADE_OPT, image_path),", "            \"SWITCH_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path),", "            \"BASE_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path)", "        }.get(self.name, None)", "        if not os.path.isfile(image_path) or install_command is None:", "        status = self._api_helper.run_interactive_command(install_command)"], "goodparts": ["        CFUFLASH_FW_UPGRADE_CMD[3] = UPGRADE_OPT.get(self.name)", "        CFUFLASH_FW_UPGRADE_CMD[6] = image_path", "        if not os.path.isfile(image_path):", "        status = self._api_helper.run_interactive_command(CFUFLASH_FW_UPGRADE_CMD)"]}], "source": "\n import json import os.path try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") COMPONENT_LIST=[ (\"BIOS\", \"Basic Input/Output System\"), (\"BMC\", \"Baseboard Management Controller\"), (\"SWITCH_CPLD\", \"Switch board CPLD\"), (\"BASE_CPLD\", \"Base board CPLD\"), (\"FPGA\", \"Field-programmable gate array\") ] SW_CPLD_VER_PATH=\"/sys/module/switch_cpld/version\" BASE_CPLD_VER_PATH=\"/sys/module/baseboard_lpc/version\" CPLD_UPGRADE_OPT=4 BIOS_VER_PATH=\"/sys/class/dmi/id/bios_version\" BIOS__UPGRADE_OPT=2 BMC_VER_CMD=\"ipmitool mc info | grep 'Firmware Revision'\" BMC_UPGRADE_OPT=1 CFUFLASH_FW_UPGRADE_CMD=\"CFUFLASH -cd -d{} -mse 3{}\" MEM_PCI_RESOURCE=\"/sys/bus/pci/devices/0000:09:00.0/resource0\" FPGA_VER_MEM_OFFSET=0 class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index): ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() self._api_helper=APIHelper() def __get_bmc_ver(self): bmc_ver=\"Unknown\" status, raw_bmc_data=self._api_helper.run_command(BMC_VER_CMD) if status: bmc_ver_data=raw_bmc_data.split(\":\") bmc_ver=bmc_ver_data[-1].strip() if len( bmc_ver_data) > 1 else bmc_ver return bmc_ver def __get_fpga_ver(self): fpga_ver=\"Unknown\" status, reg_val=self._api_helper.pci_get_value( MEM_PCI_RESOURCE, FPGA_VER_MEM_OFFSET) if status: major=reg_val[0] >> 16 minor=int(bin(reg_val[0])[16:32], 2) fpga_ver='{}.{}'.format(major, minor) return fpga_ver def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version={ \"BIOS\": self._api_helper.read_txt_file(BIOS_VER_PATH), \"BMC\": self.__get_bmc_ver(), \"FPGA\": self.__get_fpga_ver(), \"SWITCH_CPLD\": self._api_helper.read_txt_file(SW_CPLD_VER_PATH), \"BASE_CPLD\": self._api_helper.read_txt_file(BASE_CPLD_VER_PATH), }.get(self.name, \"Unknown\") return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" install_command={ \"BMC\": CFUFLASH_FW_UPGRADE_CMD.format(BMC_UPGRADE_OPT, image_path), \"BIOS\": CFUFLASH_FW_UPGRADE_CMD.format(BIOS__UPGRADE_OPT, image_path), \"SWITCH_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path), \"BASE_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path) }.get(self.name, None) if not os.path.isfile(image_path) or install_command is None: return False status=self._api_helper.run_interactive_command(install_command) return status ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport json\nimport os.path\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCOMPONENT_LIST = [\n    (\"BIOS\",        \"Basic Input/Output System\"),\n    (\"BMC\",         \"Baseboard Management Controller\"),\n    (\"SWITCH_CPLD\", \"Switch board CPLD\"),\n    (\"BASE_CPLD\",   \"Base board CPLD\"),\n    (\"FPGA\",        \"Field-programmable gate array\")\n]\nSW_CPLD_VER_PATH = \"/sys/module/switch_cpld/version\"\nBASE_CPLD_VER_PATH = \"/sys/module/baseboard_lpc/version\"\nCPLD_UPGRADE_OPT = 4\nBIOS_VER_PATH = \"/sys/class/dmi/id/bios_version\"\nBIOS__UPGRADE_OPT = 2\nBMC_VER_CMD = \"ipmitool mc info | grep 'Firmware Revision'\"\nBMC_UPGRADE_OPT = 1\nCFUFLASH_FW_UPGRADE_CMD = \"CFUFLASH -cd -d {} -mse 3 {}\"\nMEM_PCI_RESOURCE = \"/sys/bus/pci/devices/0000:09:00.0/resource0\"\nFPGA_VER_MEM_OFFSET = 0\n\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index):\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n        self._api_helper = APIHelper()\n\n    def __get_bmc_ver(self):\n        bmc_ver = \"Unknown\"\n        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD)\n        if status:\n            bmc_ver_data = raw_bmc_data.split(\":\")\n            bmc_ver = bmc_ver_data[-1].strip() if len(\n                bmc_ver_data) > 1 else bmc_ver\n        return bmc_ver\n\n    def __get_fpga_ver(self):\n        fpga_ver = \"Unknown\"\n        status, reg_val = self._api_helper.pci_get_value(\n            MEM_PCI_RESOURCE, FPGA_VER_MEM_OFFSET)\n        if status:\n            major = reg_val[0] >> 16\n            minor = int(bin(reg_val[0])[16:32], 2)\n            fpga_ver = '{}.{}'.format(major, minor)\n        return fpga_ver\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = {\n            \"BIOS\": self._api_helper.read_txt_file(BIOS_VER_PATH),\n            \"BMC\": self.__get_bmc_ver(),\n            \"FPGA\": self.__get_fpga_ver(),\n            \"SWITCH_CPLD\": self._api_helper.read_txt_file(SW_CPLD_VER_PATH),\n            \"BASE_CPLD\": self._api_helper.read_txt_file(BASE_CPLD_VER_PATH),\n        }.get(self.name, \"Unknown\")\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        install_command = {\n            \"BMC\": CFUFLASH_FW_UPGRADE_CMD.format(BMC_UPGRADE_OPT, image_path),\n            \"BIOS\": CFUFLASH_FW_UPGRADE_CMD.format(BIOS__UPGRADE_OPT, image_path),\n            \"SWITCH_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path),\n            \"BASE_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path)\n        }.get(self.name, None)\n\n        if not os.path.isfile(image_path) or install_command is None:\n            return False\n\n        # print(install_command)\n        status = self._api_helper.run_interactive_command(install_command)\n        return status\n"}, "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n import struct\n import subprocess\n from mmap import *\n+from sonic_py_common.general import check_output_pipe\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 2, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["from sonic_py_common.general import check_output_pipe", "HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         pass\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 5, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        try:", "            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)", "        except FileNotFoundError:", "            return False", "        return True"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n+    def run_command(self, cmd1_args, cmd2_args):\n         status = True\n         result = \"\"\n         try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except:\n+            result = check_output_pipe(cmd1_args, cmd2_args)\n+        except subprocess.CalledProcessError:\n             status = False\n         return status, result\n \n     def run_interactive_command(self, cmd):\n         try:\n-            os.system(cmd)\n+            subprocess.call(cmd)\n         except:\n             return False\n         return True\n", "add": 4, "remove": 8, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "            p = subprocess.Popen(", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except:", "            os.system(cmd)"], "goodparts": ["    def run_command(self, cmd1_args, cmd2_args):", "            result = check_output_pipe(cmd1_args, cmd2_args)", "        except subprocess.CalledProcessError:", "            subprocess.call(cmd)"]}, {"diff": "\n         status = True\n         result = \"\"\n         try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n+            cmd = [\"ipmitool\", \"raw\", str(netfn), str(cmd)]\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = raw_data.strip()\n", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py", "badparts": ["            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"], "goodparts": ["            cmd = [\"ipmitool\", \"raw\", str(netfn), str(cmd)]", "                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"]}, {"diff": "\n     def ipmi_fru_id(self, id, key=None):\n         status = True\n         result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n+        cmd1_args = [\"ipmitool\", \"fru\", \"print\", str(id)]\n+        if not key:\n+            try:\n+                p = subprocess.Popen(\n+                    cmd1_args, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                raw_data, err = p.communicate()\n+                if err == '':\n+                    result = raw_data.strip()\n+                else:\n+                    status = False\n+            except:\n                 status = False\n-        except:\n-            status = False\n+        else:\n+            cmd2_args = [\"grep\", str(key)]\n+            status, result = self.run_command(cmd1_args, cmd2_args)\n         return status, result\n \n     def ipmi_set_ss_thres(self, id, threshold_key, value):\n         status = True\n         result = \"\"\n         try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n+            cmd = [\"ipmitool\", \"sensor\", \"thresh\", str(id), str(threshold_key), str(value)]\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = ra", "add": 16, "remove": 14, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py", "badparts": ["        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "        except:", "            status = False", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"], "goodparts": ["        cmd1_args = [\"ipmitool\", \"fru\", \"print\", str(id)]", "        if not key:", "            try:", "                p = subprocess.Popen(", "                    cmd1_args, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "                raw_data, err = p.communicate()", "                if err == '':", "                    result = raw_data.strip()", "                else:", "                    status = False", "            except:", "        else:", "            cmd2_args = [\"grep\", str(key)]", "            status, result = self.run_command(cmd1_args, cmd2_args)", "            cmd = [\"ipmitool\", \"sensor\", \"thresh\", str(id), str(threshold_key), str(value)]", "                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"]}], "source": "\nimport os import struct import subprocess from mmap import * HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): pass def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        pass\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n"}, "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py": {"changes": [{"diff": "\n PSU_LED_GREEN_CMD = \"0x01\"\n PSU_LED_AMBER_CMD = \"0x02\"\n \n-PSU1_VOUT_SS_ID = \"0x36\"\n-PSU1_COUT_SS_ID = \"0x37\"\n-PSU1_POUT_SS_ID = \"0x38\"\n-PSU1_STATUS_REG = \"0x39\"\n-\n-PSU2_VOUT_SS_ID = \"0x40\"\n-PSU2_COUT_SS_ID = \"0x41\"\n-PSU2_POUT_SS_ID = \"0x42\"\n-PSU2_STATUS_REG = \"0x2f\"\n-\n PSU1_FRU_ID = 3\n \n SS_READ_OFFSET = 0\n \n+PSU_VOUT_SS_ID = [\"0x36\", \"0x40\"]\n+PSU_COUT_SS_ID = [\"0x37\", \"0x41\"]\n+PSU_POUT_SS_ID = [\"0x38\", \"0x42\"]\n+PSU_STATUS_REG = [\"0x39\", \"0x2f\"]\n+\n \n class Psu(PsuBase):\n     \"\"\"Platform-specific Psu class\"\"\"\n", "add": 5, "remove": 10, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["PSU1_VOUT_SS_ID = \"0x36\"", "PSU1_COUT_SS_ID = \"0x37\"", "PSU1_POUT_SS_ID = \"0x38\"", "PSU1_STATUS_REG = \"0x39\"", "PSU2_VOUT_SS_ID = \"0x40\"", "PSU2_COUT_SS_ID = \"0x41\"", "PSU2_POUT_SS_ID = \"0x42\"", "PSU2_STATUS_REG = \"0x2f\""], "goodparts": ["PSU_VOUT_SS_ID = [\"0x36\", \"0x40\"]", "PSU_COUT_SS_ID = [\"0x37\", \"0x41\"]", "PSU_POUT_SS_ID = [\"0x38\", \"0x42\"]", "PSU_STATUS_REG = [\"0x39\", \"0x2f\"]"]}, {"diff": "\n             e.g. 12.1\n         \"\"\"\n         psu_voltage = 0.0\n-        psu_vout_key = globals()['PSU{}_VOUT_SS_ID'.format(self.index+1)]\n+        psu_vout_key = PSU_VOUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_vout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["        psu_vout_key = globals()['PSU{}_VOUT_SS_ID'.format(self.index+1)]"], "goodparts": ["        psu_vout_key = PSU_VOUT_SS_ID[self.index]"]}, {"diff": "\n             A float number, the electric current in amperes, e.g 15.4\n         \"\"\"\n         psu_current = 0.0\n-        psu_cout_key = globals()['PSU{}_COUT_SS_ID'.format(self.index+1)]\n+        psu_cout_key = PSU_COUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_cout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["        psu_cout_key = globals()['PSU{}_COUT_SS_ID'.format(self.index+1)]"], "goodparts": ["        psu_cout_key = PSU_COUT_SS_ID[self.index]"]}, {"diff": "\n             A float number, the power in watts, e.g. 302.6\n         \"\"\"\n         psu_power = 0.0\n-        psu_pout_key = globals()['PSU{}_POUT_SS_ID'.format(self.index+1)]\n+        psu_pout_key = PSU_POUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["        psu_pout_key = globals()['PSU{}_POUT_SS_ID'.format(self.index+1)]"], "goodparts": ["        psu_pout_key = PSU_POUT_SS_ID[self.index]"]}, {"diff": "\n             bool: True if PSU is present, False if not\n         \"\"\"\n         psu_presence = False\n-        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n+        psu_pstatus_key = PSU_STATUS_REG[self.index]\n         status, raw_status_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n         status_byte = self.find_value(raw_status_read)\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]"], "goodparts": ["        psu_pstatus_key = PSU_STATUS_REG[self.index]"]}, {"diff": "\n             A boolean value, True if device is operating properly, False if not\n         \"\"\"\n         psu_status = False\n-        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n+        psu_pstatus_key = PSU_STATUS_REG[self.index]\n         status, raw_status_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n         status_byte = self.find_value(r", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]"], "goodparts": ["        psu_pstatus_key = PSU_STATUS_REG[self.index]"]}], "source": "\n import os import re import math import sonic_platform try: from sonic_platform_base.psu_base import PsuBase from.helper import APIHelper from sonic_platform.fan import Fan except ImportError as e: raise ImportError(str(e) +\"-required module not found\") PSU_NAME_LIST=[\"PSU-1\", \"PSU-2\"] PSU_NUM_FAN=[1, 1] IPMI_SENSOR_NETFN=\"0x04\" IPMI_OEM_NETFN=\"0x3A\" IPMI_SS_READ_CMD=\"0x2D{}\" IPMI_SET_PSU_LED_CMD=\"0x07 0x02{}\" IPMI_GET_PSU_LED_CMD=\"0x08 0x02\" IPMI_FRU_MODEL_KEY=\"Board Part Number\" IPMI_FRU_SERIAL_KEY=\"Board Serial\" PSU_LED_OFF_CMD=\"0x00\" PSU_LED_GREEN_CMD=\"0x01\" PSU_LED_AMBER_CMD=\"0x02\" PSU1_VOUT_SS_ID=\"0x36\" PSU1_COUT_SS_ID=\"0x37\" PSU1_POUT_SS_ID=\"0x38\" PSU1_STATUS_REG=\"0x39\" PSU2_VOUT_SS_ID=\"0x40\" PSU2_COUT_SS_ID=\"0x41\" PSU2_POUT_SS_ID=\"0x42\" PSU2_STATUS_REG=\"0x2f\" PSU1_FRU_ID=3 SS_READ_OFFSET=0 class Psu(PsuBase): \"\"\"Platform-specific Psu class\"\"\" def __init__(self, psu_index): PsuBase.__init__(self) self.index=psu_index for fan_index in range(0, PSU_NUM_FAN[self.index]): fan=Fan(fan_index, 0, is_psu_fan=True, psu_index=self.index) self._fan_list.append(fan) self._api_helper=APIHelper() def find_value(self, in_string): result=re.search(\"^.+([0-9a-f]{2}).+$\", in_string) return result.group(1) if result else result def get_voltage(self): \"\"\" Retrieves current PSU voltage output Returns: A float number, the output voltage in volts, e.g. 12.1 \"\"\" psu_voltage=0.0 psu_vout_key=globals()['PSU{}_VOUT_SS_ID'.format(self.index+1)] status, raw_ss_read=self._api_helper.ipmi_raw( IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_vout_key)) ss_read=raw_ss_read.split()[SS_READ_OFFSET] psu_voltage=int(ss_read, 16) * math.pow(10, -1) return psu_voltage def get_current(self): \"\"\" Retrieves present electric current supplied by PSU Returns: A float number, the electric current in amperes, e.g 15.4 \"\"\" psu_current=0.0 psu_cout_key=globals()['PSU{}_COUT_SS_ID'.format(self.index+1)] status, raw_ss_read=self._api_helper.ipmi_raw( IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_cout_key)) ss_read=raw_ss_read.split()[SS_READ_OFFSET] psu_current=int(ss_read, 16) * 5 * math.pow(10, -1) return psu_current def get_power(self): \"\"\" Retrieves current energy supplied by PSU Returns: A float number, the power in watts, e.g. 302.6 \"\"\" psu_power=0.0 psu_pout_key=globals()['PSU{}_POUT_SS_ID'.format(self.index+1)] status, raw_ss_read=self._api_helper.ipmi_raw( IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pout_key)) ss_read=raw_ss_read.split()[SS_READ_OFFSET] psu_power=int(ss_read, 16) * 6 return psu_power def get_powergood_status(self): \"\"\" Retrieves the powergood status of PSU Returns: A boolean, True if PSU has stablized its output voltages and passed all its internal self-tests, False if not. \"\"\" return self.get_status() def set_status_led(self, color): \"\"\" Sets the state of the PSU status LED Args: color: A string representing the color with which to set the PSU status LED Note: Only support green and off Returns: bool: True if status LED state is set successfully, False if not Note Set manual ipmitool raw 0x3a 0x09 0x2 0x0 \"\"\" led_cmd={ self.STATUS_LED_COLOR_GREEN: PSU_LED_GREEN_CMD, self.STATUS_LED_COLOR_AMBER: PSU_LED_AMBER_CMD, self.STATUS_LED_COLOR_OFF: PSU_LED_OFF_CMD }.get(color) status, set_led=self._api_helper.ipmi_raw( IPMI_OEM_NETFN, IPMI_SET_PSU_LED_CMD.format(led_cmd)) set_status_led=False if not status else True return set_status_led def get_status_led(self): \"\"\" Gets the state of the PSU status LED Returns: A string, one of the predefined STATUS_LED_COLOR_* strings above \"\"\" status, hx_color=self._api_helper.ipmi_raw( IPMI_OEM_NETFN, IPMI_GET_PSU_LED_CMD) status_led={ \"00\": self.STATUS_LED_COLOR_OFF, \"01\": self.STATUS_LED_COLOR_GREEN, \"02\": self.STATUS_LED_COLOR_AMBER, }.get(hx_color, self.STATUS_LED_COLOR_OFF) return status_led def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return PSU_NAME_LIST[self.index] def get_presence(self): \"\"\" Retrieves the presence of the PSU Returns: bool: True if PSU is present, False if not \"\"\" psu_presence=False psu_pstatus_key=globals()['PSU{}_STATUS_REG'.format(self.index+1)] status, raw_status_read=self._api_helper.ipmi_raw( IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key)) status_byte=self.find_value(raw_status_read) if status: presence_int=(int(status_byte, 16) >> 0) & 1 psu_presence=True if presence_int else False return psu_presence def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" model=\"Unknown\" ipmi_fru_idx=self.index +PSU1_FRU_ID status, raw_model=self._api_helper.ipmi_fru_id( ipmi_fru_idx, IPMI_FRU_MODEL_KEY) fru_pn_list=raw_model.split() if len(fru_pn_list) > 4: model=fru_pn_list[4] return model def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" serial=\"Unknown\" ipmi_fru_idx=self.index +PSU1_FRU_ID status, raw_model=self._api_helper.ipmi_fru_id( ipmi_fru_idx, IPMI_FRU_SERIAL_KEY) fru_sr_list=raw_model.split() if len(fru_sr_list) > 3: serial=fru_sr_list[3] return serial def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" psu_status=False psu_pstatus_key=globals()['PSU{}_STATUS_REG'.format(self.index+1)] status, raw_status_read=self._api_helper.ipmi_raw( IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key)) status_byte=self.find_value(raw_status_read) if status: failure_detected=(int(status_byte, 16) >> 1) & 1 input_lost=(int(status_byte, 16) >> 3) & 1 psu_status=False if(input_lost or failure_detected) else True return psu_status ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the PSUs status which are available in the platform\n#\n#############################################################################\n\nimport os\nimport re\nimport math\nimport sonic_platform\n\ntry:\n    from sonic_platform_base.psu_base import PsuBase\n    from .helper import APIHelper\n    from sonic_platform.fan import Fan\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nPSU_NAME_LIST = [\"PSU-1\", \"PSU-2\"]\nPSU_NUM_FAN = [1, 1]\n\nIPMI_SENSOR_NETFN = \"0x04\"\nIPMI_OEM_NETFN = \"0x3A\"\nIPMI_SS_READ_CMD = \"0x2D {}\"\nIPMI_SET_PSU_LED_CMD = \"0x07 0x02 {}\"\nIPMI_GET_PSU_LED_CMD = \"0x08 0x02\"\nIPMI_FRU_MODEL_KEY = \"Board Part Number\"\nIPMI_FRU_SERIAL_KEY = \"Board Serial\"\n\nPSU_LED_OFF_CMD = \"0x00\"\nPSU_LED_GREEN_CMD = \"0x01\"\nPSU_LED_AMBER_CMD = \"0x02\"\n\nPSU1_VOUT_SS_ID = \"0x36\"\nPSU1_COUT_SS_ID = \"0x37\"\nPSU1_POUT_SS_ID = \"0x38\"\nPSU1_STATUS_REG = \"0x39\"\n\nPSU2_VOUT_SS_ID = \"0x40\"\nPSU2_COUT_SS_ID = \"0x41\"\nPSU2_POUT_SS_ID = \"0x42\"\nPSU2_STATUS_REG = \"0x2f\"\n\nPSU1_FRU_ID = 3\n\nSS_READ_OFFSET = 0\n\n\nclass Psu(PsuBase):\n    \"\"\"Platform-specific Psu class\"\"\"\n\n    def __init__(self, psu_index):\n        PsuBase.__init__(self)\n        self.index = psu_index\n        for fan_index in range(0, PSU_NUM_FAN[self.index]):\n            fan = Fan(fan_index, 0, is_psu_fan=True, psu_index=self.index)\n            self._fan_list.append(fan)\n        self._api_helper = APIHelper()\n\n    def find_value(self, in_string):\n        result = re.search(\"^.+ ([0-9a-f]{2}) .+$\", in_string)\n        return result.group(1) if result else result\n\n    def get_voltage(self):\n        \"\"\"\n        Retrieves current PSU voltage output\n        Returns:\n            A float number, the output voltage in volts,\n            e.g. 12.1\n        \"\"\"\n        psu_voltage = 0.0\n        psu_vout_key = globals()['PSU{}_VOUT_SS_ID'.format(self.index+1)]\n        status, raw_ss_read = self._api_helper.ipmi_raw(\n            IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_vout_key))\n        ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n        # Formula: Rx1x10^-1\n        psu_voltage = int(ss_read, 16) * math.pow(10, -1)\n\n        return psu_voltage\n\n    def get_current(self):\n        \"\"\"\n        Retrieves present electric current supplied by PSU\n        Returns:\n            A float number, the electric current in amperes, e.g 15.4\n        \"\"\"\n        psu_current = 0.0\n        psu_cout_key = globals()['PSU{}_COUT_SS_ID'.format(self.index+1)]\n        status, raw_ss_read = self._api_helper.ipmi_raw(\n            IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_cout_key))\n        ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n        # Formula: Rx5x10^-1\n        psu_current = int(ss_read, 16) * 5 * math.pow(10, -1)\n\n        return psu_current\n\n    def get_power(self):\n        \"\"\"\n        Retrieves current energy supplied by PSU\n        Returns:\n            A float number, the power in watts, e.g. 302.6\n        \"\"\"\n        psu_power = 0.0\n        psu_pout_key = globals()['PSU{}_POUT_SS_ID'.format(self.index+1)]\n        status, raw_ss_read = self._api_helper.ipmi_raw(\n            IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pout_key))\n        ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n        # Formula: Rx6x10^0\n        psu_power = int(ss_read, 16) * 6\n        return psu_power\n\n    def get_powergood_status(self):\n        \"\"\"\n        Retrieves the powergood status of PSU\n        Returns:\n            A boolean, True if PSU has stablized its output voltages and passed all\n            its internal self-tests, False if not.\n        \"\"\"\n        return self.get_status()\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the PSU status LED\n        Args:\n            color: A string representing the color with which to set the PSU status LED\n                   Note: Only support green and off\n        Returns:\n            bool: True if status LED state is set successfully, False if not\n        Note\n            Set manual\n            ipmitool raw 0x3a 0x09 0x2 0x0\n        \"\"\"\n        led_cmd = {\n            self.STATUS_LED_COLOR_GREEN: PSU_LED_GREEN_CMD,\n            self.STATUS_LED_COLOR_AMBER: PSU_LED_AMBER_CMD,\n            self.STATUS_LED_COLOR_OFF: PSU_LED_OFF_CMD\n        }.get(color)\n\n        status, set_led = self._api_helper.ipmi_raw(\n            IPMI_OEM_NETFN, IPMI_SET_PSU_LED_CMD.format(led_cmd))\n        set_status_led = False if not status else True\n\n        return set_status_led\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the PSU status LED\n        Returns:\n            A string, one of the predefined STATUS_LED_COLOR_* strings above\n        \"\"\"\n        status, hx_color = self._api_helper.ipmi_raw(\n            IPMI_OEM_NETFN, IPMI_GET_PSU_LED_CMD)\n\n        status_led = {\n            \"00\": self.STATUS_LED_COLOR_OFF,\n            \"01\": self.STATUS_LED_COLOR_GREEN,\n            \"02\": self.STATUS_LED_COLOR_AMBER,\n        }.get(hx_color, self.STATUS_LED_COLOR_OFF)\n\n        return status_led\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return PSU_NAME_LIST[self.index]\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the PSU\n        Returns:\n            bool: True if PSU is present, False if not\n        \"\"\"\n        psu_presence = False\n        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n        status, raw_status_read = self._api_helper.ipmi_raw(\n            IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n        status_byte = self.find_value(raw_status_read)\n\n        if status:\n            presence_int = (int(status_byte, 16) >> 0) & 1\n            psu_presence = True if presence_int else False\n\n        return psu_presence\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        model = \"Unknown\"\n        ipmi_fru_idx = self.index + PSU1_FRU_ID\n        status, raw_model = self._api_helper.ipmi_fru_id(\n            ipmi_fru_idx, IPMI_FRU_MODEL_KEY)\n\n        fru_pn_list = raw_model.split()\n        if len(fru_pn_list) > 4:\n            model = fru_pn_list[4]\n\n        return model\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        serial = \"Unknown\"\n        ipmi_fru_idx = self.index + PSU1_FRU_ID\n        status, raw_model = self._api_helper.ipmi_fru_id(\n            ipmi_fru_idx, IPMI_FRU_SERIAL_KEY)\n\n        fru_sr_list = raw_model.split()\n        if len(fru_sr_list) > 3:\n            serial = fru_sr_list[3]\n\n        return serial\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        psu_status = False\n        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n        status, raw_status_read = self._api_helper.ipmi_raw(\n            IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n        status_byte = self.find_value(raw_status_read)\n\n        if status:\n            failure_detected = (int(status_byte, 16) >> 1) & 1\n            input_lost = (int(status_byte, 16) >> 3) & 1\n            psu_status = False if (input_lost or failure_detected) else True\n\n        return psu_status\n"}, "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to QSFP sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-cel_silverstone-r0\"\n     HWSKU = \"Silverstone\"\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n             return 'N/A'\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH,", "add": 5, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        try:", "            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)", "        except FileNotFoundError:", "            return False", "        return True"]}]}, "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py": {"changes": [{"diff": "\n #\r\n #############################################################################\r\n \r\n-import os.path\r\n import subprocess\r\n-import time\r\n-import os\r\n \r\n try:\r\n     from sonic_platform_base.component_base import ComponentBase\r\n+    from sonic_py_common.general import getstatusoutput_noshell_pipe\r\n     #from helper import APIHelper\r\n except ImportError as e:\r\n     raise ImportError(str(e) + \"- required module not found\")\r\n \r\n-SWCPLD_VERSION_PATH = \"i2cget -y -f 2 0x32 0\"\r\n-BIOS_VERSION_PATH = \"dmidecode -t bios | grep Version\"\r\n+SWCPLD_VERSION_PATH = [\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0\"]\r\n+BIOS_VERSION_PATH_CMD1 = [\"dmidecode\", \"-t\", \"bios\"]\r\n+BIOS_VERSION_PATH_CMD2 = [\"grep\", \"Version\"]\r\n COMPONENT_NAME_LIST = [\"SWCPLD\", \"Main_BIOS\", \"Backup_BIOS\"]\r\n COMPONENT_DES_LIST = [\"Use for boot control and BIOS switch\",\r\n                       \"Main basic Input/Output System\",\r\n", "add": 4, "remove": 5, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py", "badparts": ["import time\r", "SWCPLD_VERSION_PATH = \"i2cget -y -f 2 0x32 0\"\r", "BIOS_VERSION_PATH = \"dmidecode -t bios | grep Version\"\r"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell_pipe\r", "SWCPLD_VERSION_PATH = [\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0\"]\r", "BIOS_VERSION_PATH_CMD1 = [\"dmidecode\", \"-t\", \"bios\"]\r", "BIOS_VERSION_PATH_CMD2 = [\"grep\", \"Version\"]\r"]}, {"diff": "\n         self.name = self.get_name()\r\n \r\n     def run_command(self,cmd):\r\n-        responses = os.popen(cmd).read()\r\n+        responses = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()\r\n         return responses\r\n \r\n     def __get_bios_version(self):\r\n         # Retrieves the BIOS firmware version\r\n-        result = self.run_command(\"i2cget -y -f 2 0x32 0x19\")\r\n+        result = self.run_command([\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0x19\"])\r\n         if result.strip() == \"0x01\":\r\n             if self.name == \"Main_BIOS\":\r\n-                version = self.run_command(BIOS_VERSION_PATH)\r\n+                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r\n                 bios_version = version.strip().split(\" \")[1]\r\n                 return str(bios_version)\r\n             elif self.name == \"Backup_BIOS\":\r\n", "add": 3, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py", "badparts": ["        responses = os.popen(cmd).read()\r", "        result = self.run_command(\"i2cget -y -f 2 0x32 0x19\")\r", "                version = self.run_command(BIOS_VERSION_PATH)\r"], "goodparts": ["        responses = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()\r", "        result = self.run_command([\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0x19\"])\r", "                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r"]}, {"diff": "\n                 \r\n         elif result.strip() == \"0x03\":\r\n             if self.name == \"Backup_BIOS\":\r\n-                version = self.run_command(BIOS_VERSION_PATH)\r\n+                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r\n                 bios_version = version.strip().split(\" \")[1]\r\n                 return str(bios_version)\r\n             elif self.name", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py", "badparts": ["                version = self.run_command(BIOS_VERSION_PATH)\r"], "goodparts": ["                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r"]}], "source": "\n\n\r \r import os.path\r import subprocess\r import time\r import os\r \r try:\r from sonic_platform_base.component_base import ComponentBase\r except ImportError as e:\r raise ImportError(str(e) +\"-required module not found\")\r \r SWCPLD_VERSION_PATH=\"i2cget -y -f 2 0x32 0\"\r BIOS_VERSION_PATH=\"dmidecode -t bios | grep Version\"\r COMPONENT_NAME_LIST=[\"SWCPLD\", \"Main_BIOS\", \"Backup_BIOS\"]\r COMPONENT_DES_LIST=[\"Use for boot control and BIOS switch\",\r \"Main basic Input/Output System\",\r \"Backup basic Input/Output System\"]\r \r \r class Component(ComponentBase):\r \"\"\"Platform-specific Component class\"\"\"\r \r DEVICE_TYPE=\"component\"\r \r def __init__(self, component_index):\r ComponentBase.__init__(self)\r self.index=component_index\r self.name=self.get_name()\r \r def run_command(self,cmd):\r responses=os.popen(cmd).read()\r return responses\r \r def __get_bios_version(self):\r result=self.run_command(\"i2cget -y -f 2 0x32 0x19\")\r if result.strip()==\"0x01\":\r if self.name==\"Main_BIOS\":\r version=self.run_command(BIOS_VERSION_PATH)\r bios_version=version.strip().split(\" \")[1]\r return str(bios_version)\r elif self.name==\"Backup_BIOS\":\r bios_version=\"na\"\r return bios_version\r \r elif result.strip()==\"0x03\":\r if self.name==\"Backup_BIOS\":\r version=self.run_command(BIOS_VERSION_PATH)\r bios_version=version.strip().split(\" \")[1]\r return str(bios_version)\r elif self.name==\"Main_BIOS\":\r bios_version=\"na\"\r return bios_version\r \r def __get_cpld_version(self):\r if self.name==\"SWCPLD\":\r ver=self.run_command(SWCPLD_VERSION_PATH)\r print(\"ver is %s\" % ver)\r ver=ver.strip().split(\"x\")[1]\r print(\"ver2 is %s\" % ver)\r version=int(ver.strip()) / 10\r return str(version)\r \r \r def get_name(self):\r \"\"\"\r Retrieves the name of the component\r Returns:\r A string containing the name of the component\r \"\"\"\r return COMPONENT_NAME_LIST[self.index]\r \r def get_description(self):\r \"\"\"\r Retrieves the description of the component\r Returns:\r A string containing the description of the component\r \"\"\"\r return COMPONENT_DES_LIST[self.index]\r \r def get_firmware_version(self):\r \"\"\"\r Retrieves the firmware version of module\r Returns:\r string: The firmware versions of the module\r \"\"\"\r fw_version=None\r \r if \"BIOS\" in self.name:\r fw_version=self.__get_bios_version()\r elif \"CPLD\" in self.name:\r fw_version=self.__get_cpld_version()\r \r return fw_version\r \r def install_firmware(self, image_path):\r \"\"\"\r Install firmware to module\r Args:\r image_path: A string, path to firmware image\r Returns:\r A boolean, True if install successfully, False if not\r \"\"\"\r return False\r \r def update_firmware(self, image_path):\r return False\r \r def get_available_firmware_version(self, image_path):\r return 'N/A'\r \r def get_firmware_update_notification(self, image_path):\r return \"None\"\r \r def get_model(self):\r return 'N/A'\r \r def get_position_in_parent(self):\r return -1\r \r def get_presence(self):\r return True\r \r def get_serial(self):\r return 'N/A'\r \r def get_status(self):\r return True\r \r def is_replaceable(self):\r return False\r ", "sourceWithComments": "#!/usr/bin/env python\r\n\r\n#############################################################################\r\n# Celestica\r\n#\r\n# Component contains an implementation of SONiC Platform Base API and\r\n# provides the components firmware management function\r\n#\r\n#############################################################################\r\n\r\nimport os.path\r\nimport subprocess\r\nimport time\r\nimport os\r\n\r\ntry:\r\n    from sonic_platform_base.component_base import ComponentBase\r\n    #from helper import APIHelper\r\nexcept ImportError as e:\r\n    raise ImportError(str(e) + \"- required module not found\")\r\n\r\nSWCPLD_VERSION_PATH = \"i2cget -y -f 2 0x32 0\"\r\nBIOS_VERSION_PATH = \"dmidecode -t bios | grep Version\"\r\nCOMPONENT_NAME_LIST = [\"SWCPLD\", \"Main_BIOS\", \"Backup_BIOS\"]\r\nCOMPONENT_DES_LIST = [\"Use for boot control and BIOS switch\",\r\n                      \"Main basic Input/Output System\",\r\n                      \"Backup basic Input/Output System\"]\r\n\r\n\r\nclass Component(ComponentBase):\r\n    \"\"\"Platform-specific Component class\"\"\"\r\n\r\n    DEVICE_TYPE = \"component\"\r\n\r\n    def __init__(self, component_index):\r\n        ComponentBase.__init__(self)\r\n        self.index = component_index\r\n        #self._api_helper = APIHelper()\r\n        self.name = self.get_name()\r\n\r\n    def run_command(self,cmd):\r\n        responses = os.popen(cmd).read()\r\n        return responses\r\n\r\n    def __get_bios_version(self):\r\n        # Retrieves the BIOS firmware version\r\n        result = self.run_command(\"i2cget -y -f 2 0x32 0x19\")\r\n        if result.strip() == \"0x01\":\r\n            if self.name == \"Main_BIOS\":\r\n                version = self.run_command(BIOS_VERSION_PATH)\r\n                bios_version = version.strip().split(\" \")[1]\r\n                return str(bios_version)\r\n            elif self.name == \"Backup_BIOS\":\r\n                bios_version = \"na\"\r\n                return bios_version\r\n                \r\n        elif result.strip() == \"0x03\":\r\n            if self.name == \"Backup_BIOS\":\r\n                version = self.run_command(BIOS_VERSION_PATH)\r\n                bios_version = version.strip().split(\" \")[1]\r\n                return str(bios_version)\r\n            elif self.name == \"Main_BIOS\":\r\n                bios_version = \"na\"\r\n                return bios_version\r\n\r\n    def __get_cpld_version(self):\r\n        if self.name == \"SWCPLD\":\r\n            ver = self.run_command(SWCPLD_VERSION_PATH)\r\n            print(\"ver is %s\" % ver)\r\n            ver = ver.strip().split(\"x\")[1]\r\n            print(\"ver2 is %s\" % ver)\r\n            version = int(ver.strip()) / 10\r\n            return str(version)\r\n\r\n                \r\n    def get_name(self):\r\n        \"\"\"\r\n        Retrieves the name of the component\r\n         Returns:\r\n            A string containing the name of the component\r\n        \"\"\"\r\n        return COMPONENT_NAME_LIST[self.index]\r\n\r\n    def get_description(self):\r\n        \"\"\"\r\n        Retrieves the description of the component\r\n            Returns:\r\n            A string containing the description of the component\r\n        \"\"\"\r\n        return COMPONENT_DES_LIST[self.index]\r\n\r\n    def get_firmware_version(self):\r\n        \"\"\"\r\n        Retrieves the firmware version of module\r\n        Returns:\r\n            string: The firmware versions of the module\r\n        \"\"\"\r\n        fw_version = None\r\n        \r\n        if \"BIOS\" in self.name:\r\n            fw_version = self.__get_bios_version()\r\n        elif \"CPLD\" in self.name:\r\n            fw_version = self.__get_cpld_version()\r\n            \r\n        return fw_version\r\n\r\n    def install_firmware(self, image_path):\r\n        \"\"\"\r\n        Install firmware to module\r\n        Args:\r\n            image_path: A string, path to firmware image\r\n        Returns:\r\n            A boolean, True if install successfully, False if not\r\n        \"\"\"\r\n        return False\r\n\r\n    def update_firmware(self, image_path):\r\n        return False\r\n\r\n    def get_available_firmware_version(self, image_path):\r\n        return 'N/A'\r\n\r\n    def get_firmware_update_notification(self, image_path):\r\n        return \"None\"\r\n\r\n    def get_model(self):\r\n        return 'N/A'\r\n\r\n    def get_position_in_parent(self):\r\n        return -1\r\n\r\n    def get_presence(self):\r\n        return True\r\n \r\n    def get_serial(self):\r\n        return 'N/A'\r\n\r\n    def get_status(self):\r\n        return True\r\n\r\n    def is_replaceable(self):\r\n        return False\r\n"}, "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py": {"changes": [{"diff": "\n         \"\"\"\n         if self.is_psu_fan:\n             cmd_num = \"58\" if self.fans_psu_index == 1 else \"59\"\n-            cmd = \"i2cget -y -f 4 0x%s 0x80\" % cmd_num\n-            res = os.popen(cmd).read()\n+            cmd = [\"i2cget\", \"-y\", \"-f\", \"4\", \"\", \"0x80\"]\n+            cmd[4] = \"0x\" + cmd_num\n+            res = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()\n             # F2B \n             if res.strip() == \"0x01\":\n                 dir", "add": 3, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py", "badparts": ["            cmd = \"i2cget -y -f 4 0x%s 0x80\" % cmd_num", "            res = os.popen(cmd).read()"], "goodparts": ["            cmd = [\"i2cget\", \"-y\", \"-f\", \"4\", \"\", \"0x80\"]", "            cmd[4] = \"0x\" + cmd_num", "            res = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()"]}], "source": "\ntry: from sonic_platform_pddf_base.pddf_fan import PddfFan import os except ImportError as e: raise ImportError(str(e) +\"-required module not found\") FAN_DIRECTION_FILE_PATH=\"/var/fan_direction\" class Fan(PddfFan): \"\"\"PDDF Platform-Specific Fan class\"\"\" def __init__(self, tray_idx, fan_idx=0, pddf_data=None, pddf_plugin_data=None, is_psu_fan=False, psu_index=0): PddfFan.__init__(self, tray_idx, fan_idx, pddf_data, pddf_plugin_data, is_psu_fan, psu_index) def get_speed_tolerance(self): \"\"\" Retrieves the speed tolerance of the fan Returns: An integer, the percentage of variance from target speed which is considered tolerable \"\"\" return 20 def get_presence(self): return True def get_direction(self): \"\"\" Retrieves the direction of fan Returns: A string, either FAN_DIRECTION_INTAKE or FAN_DIRECTION_EXHAUST depending on fan direction \"\"\" if self.is_psu_fan: cmd_num=\"58\" if self.fans_psu_index==1 else \"59\" cmd=\"i2cget -y -f 4 0x%s 0x80\" % cmd_num res=os.popen(cmd).read() if res.strip()==\"0x01\": direction=\"EXHAUST\" else: direction=\"INTAKE\" else: direction=\"INTAKE\" with open(FAN_DIRECTION_FILE_PATH, \"r\") as f: fan_direction=f.read() if fan_direction.strip()==\"FB\": direction=\"EXHAUST\" return direction def get_status(self): speed=self.get_speed_rpm() status=True if(speed !=0) else False return status def get_target_speed(self): \"\"\" Retrieves the target(expected) speed of the fan Returns: An integer, the percentage of full fan speed, in the range 0(off) to 100(full speed) \"\"\" target_speed=0 if self.is_psu_fan: target_speed=\"N/A\" else: idx=(self.fantray_index -1) * 1 +self.fan_index attr=\"fan\" +str(idx) +\"_pwm\" pwm_path=\"/sys/devices/pci0000:00/0000:00:12.0/i2c-0/i2c-2/2-0066/\" +attr pwm=0 with open(pwm_path, \"r\") as f: pwm=f.read() percentage=int(pwm.strip()) speed_percentage=int(round(percentage / 255 * 100)) target_speed=speed_percentage return target_speed def set_status_led(self, color): color_dict={\"green\": \"STATUS_LED_COLOR_GREEN\", \"red\": \"STATUS_LED_COLOR_AMBER\"} color=color_dict.get(color, \"off\") index=str(self.fantray_index -1) led_device_name=\"FANTRAY{}\".format(self.fantray_index) +\"_LED\" result, msg=self.pddf_obj.is_supported_sysled_state(led_device_name, color) if result is False: return False device_name=self.pddf_obj.data[led_device_name]['dev_info']['device_name'] self.pddf_obj.create_attr('device_name', device_name, self.pddf_obj.get_led_path()) self.pddf_obj.create_attr('index', index, self.pddf_obj.get_led_path()) self.pddf_obj.create_attr('color', color, self.pddf_obj.get_led_cur_state_path()) self.pddf_obj.create_attr('dev_ops', 'set_status', self.pddf_obj.get_led_path()) return True @staticmethod def get_model(): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" model=\"Unknown\" return model @staticmethod def get_serial(): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" serial=\"Unknown\" return serial def get_position_in_parent(self): \"\"\" Retrieves the fan/psu fan index number \"\"\" return self.fantray_index if not self.is_psu_fan else self.fans_psu_index +4 \t\t @staticmethod def is_replaceable(): \"\"\" Retrieves whether the device is replaceable \"\"\" return False ", "sourceWithComments": "try:\n    from sonic_platform_pddf_base.pddf_fan import PddfFan\n    import os\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n# ------------------------------------------------------------------\n# HISTORY:\n#    5/1/2022 (A.D.)\n#    add function:set_status_led,\n#    Solve the problem that when a fan is pulled out, the Fan LED on the front panel is still green Issue-#11525\n# ------------------------------------------------------------------\nFAN_DIRECTION_FILE_PATH = \"/var/fan_direction\"\n\n\nclass Fan(PddfFan):\n    \"\"\"PDDF Platform-Specific Fan class\"\"\"\n\n    def __init__(self, tray_idx, fan_idx=0, pddf_data=None, pddf_plugin_data=None, is_psu_fan=False, psu_index=0):\n        # idx is 0-based\n        PddfFan.__init__(self, tray_idx, fan_idx, pddf_data, pddf_plugin_data, is_psu_fan, psu_index)\n\n\n    def get_speed_tolerance(self):\n        \"\"\"\n        Retrieves the speed tolerance of the fan\n\n        Returns:\n            An integer, the percentage of variance from target speed which is\n                 considered tolerable\n        \"\"\"\n        # Fix the speed vairance to 10 percent. If it changes based on platforms, overwrite\n        # this value in derived pddf fan class\n        return 20\n    \n    \n    def get_presence(self):\n        #Overwirte the PDDF Common since the FANs on Belgite are all Fixed and present\n        return True \n\n    def get_direction(self):\n        \"\"\"\n        Retrieves the direction of fan\n\n        Returns:\n            A string, either FAN_DIRECTION_INTAKE or FAN_DIRECTION_EXHAUST\n            depending on fan direction\n        \"\"\"\n        if self.is_psu_fan:\n            cmd_num = \"58\" if self.fans_psu_index == 1 else \"59\"\n            cmd = \"i2cget -y -f 4 0x%s 0x80\" % cmd_num\n            res = os.popen(cmd).read()\n            # F2B \n            if res.strip() == \"0x01\":\n                direction = \"EXHAUST\"\n            else:\n                direction = \"INTAKE\"\n        else:\n            direction = \"INTAKE\"\n            with open(FAN_DIRECTION_FILE_PATH, \"r\") as f:\n                fan_direction = f.read()\n                if fan_direction.strip() == \"FB\":\n                    direction = \"EXHAUST\"\n        return direction\n    \n\n    def get_status(self):\n        speed = self.get_speed_rpm()\n        status = True if (speed != 0) else False\n        return status\n\n    def get_target_speed(self):\n        \"\"\"\n        Retrieves the target (expected) speed of the fan\n\n        Returns:\n            An integer, the percentage of full fan speed, in the range 0 (off)\n                 to 100 (full speed)\n        \"\"\"\n        target_speed = 0\n        if self.is_psu_fan:\n            # Target speed not usually supported for PSU fans\n            target_speed = \"N/A\"\n        else:\n            idx = (self.fantray_index - 1) * 1 + self.fan_index\n            attr = \"fan\" + str(idx) + \"_pwm\"\n            pwm_path = \"/sys/devices/pci0000:00/0000:00:12.0/i2c-0/i2c-2/2-0066/\" + attr\n            pwm = 0\n            with open(pwm_path, \"r\") as f:\n                pwm = f.read()\n\n            percentage = int(pwm.strip())\n            speed_percentage = int(round(percentage / 255 * 100))\n            target_speed = speed_percentage\n\n        return target_speed\n\n    def set_status_led(self, color):\n        color_dict = {\"green\": \"STATUS_LED_COLOR_GREEN\",\n                      \"red\": \"STATUS_LED_COLOR_AMBER\"}\n        color = color_dict.get(color, \"off\")\n        index = str(self.fantray_index - 1)\n        led_device_name = \"FANTRAY{}\".format(self.fantray_index) + \"_LED\"\n\n        result, msg = self.pddf_obj.is_supported_sysled_state(led_device_name, color)\n        if result is False:\n            return False\n        device_name = self.pddf_obj.data[led_device_name]['dev_info']['device_name']\n        self.pddf_obj.create_attr('device_name', device_name, self.pddf_obj.get_led_path())\n        self.pddf_obj.create_attr('index', index, self.pddf_obj.get_led_path())\n        self.pddf_obj.create_attr('color', color, self.pddf_obj.get_led_cur_state_path())\n\n        self.pddf_obj.create_attr('dev_ops', 'set_status', self.pddf_obj.get_led_path())\n        return True\n\n    @staticmethod\n    def get_model():\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        model = \"Unknown\"\n        return model\n\n    @staticmethod\n    def get_serial():\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        serial = \"Unknown\"\n        return serial\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves the fan/psu fan index number\n        \"\"\"\n        return self.fantray_index if not self.is_psu_fan else self.fans_psu_index + 4\n\t\t\n    @staticmethod\n    def is_replaceable():\n        \"\"\"\n        Retrieves whether the device is replaceable\n        \"\"\"\n        return False\n"}, "/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py": {"changes": [{"diff": "\n try:\n     import sys\n     import getopt\n-    import subprocess\n     import logging\n     import logging.config\n     import time  # this is only being used as part of the example\n     import signal\n     import math\n     from sonic_platform import platform\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py", "badparts": ["    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         else:\n             logging.debug('INFO: FAIL. set_fan_duty_cycle (%d)' % DUTY_MAX)\n         # Enable the CPLD Heartbeat back\n-        status, output = subprocess.getstatusoutput('i2cset -f -y 75 0x40 0x22 0x00')\n+        status, output = getstatusoutput_noshell([\"i2cset\", \"-f\", \"-y\", \"75\", \"0x40\", \"0x22\", \"0x00\"])\n         if status == 0:\n             logging.debug('INFO: CPLD Heartbeat check is enabled back')\n     sys.exit(0)\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py", "badparts": ["        status, output = subprocess.getstatusoutput('i2cset -f -y 75 0x40 0x22 0x00')"], "goodparts": ["        status, output = getstatusoutput_noshell([\"i2cset\", \"-f\", \"-y\", \"75\", \"0x40\", \"0x22\", \"0x00\"])"]}, {"diff": "\n     signal.signal(signal.SIGINT, handler)\n     signal.signal(signal.SIGTERM, handler)\n     # Disaable the CPLD Heartbeat check to control Fan speed from CPU via ADT7470\n-    subprocess.getstatusoutput('i2cset -f -y 2 0x32 0x30 0x01')\n+    getstatusoutput_noshell(['i2cset', '-f', '-y', '2', '0x32', '0x30', '0x01'])\n \n     monitor = cel_belgite_monitor(log", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py", "badparts": ["    subprocess.getstatusoutput('i2cset -f -y 2 0x32 0x30 0x01')"], "goodparts": ["    getstatusoutput_noshell(['i2cset', '-f', '-y', '2', '0x32', '0x30', '0x01'])"]}], "source": "\n try: import sys import getopt import subprocess import logging import logging.config import time import signal import math from sonic_platform import platform except ImportError as e: raise ImportError('%s -required module not found' % str(e)) FUNCTION_NAME='cel_belgite_monitor' DUTY_MAX=100 FAN_NUMBER=3 SENSOR_NUMBER=4 CPU_CORE_TEMP=r\"/sys/devices/platform/coretemp.0/hwmon/hwmon1/temp1_input\" class cel_belgite_monitor(object): \"\"\" Make a class we can use to capture stdout and sterr in the log \"\"\" _ori_temp=0 _new_perc=DUTY_MAX / 2 syslog=logging.getLogger(\"[\" +FUNCTION_NAME +\"]\") init_fan_temperature=[0, 0, 0, 0] def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" formatter=logging.Formatter('%(name)s %(message)s') sys_handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setFormatter(formatter) sys_handler.ident='common' self.syslog.setLevel(logging.WARNING) self.syslog.addHandler(sys_handler) self.platform_chassis_obj=platform.Platform().get_chassis() logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) logging.debug('SET. logfile:%s / loglevel:%d' %(log_file, log_level)) def get_all_temperature(self): \"\"\" return: all temperature \"\"\" all_temperature_list=list() for sensor_index in range(SENSOR_NUMBER): temp=self.platform_chassis_obj.get_thermal(sensor_index).get_temperature() if temp is None or str(temp).strip()==\"\": return False temp=temp*1000 all_temperature_list.append(temp) u4_temperature=all_temperature_list[0] u7_temperature=all_temperature_list[1] cpu_temperature=70000 try: with open(CPU_CORE_TEMP, \"r\") as f: cpu_temperature=float(f.read().strip()) except Exception as E: logging.debug('Error: %s' % E) u60_temperature=all_temperature_list[3] return[u4_temperature, u7_temperature, cpu_temperature, u60_temperature] def get_fan_speed_by_temperature(self, temp_list): fan1_direction=self.platform_chassis_obj.get_fan(0).get_direction() logging.debug('INFO: fan direction: %s' % str(fan1_direction)) all_temp=self.get_all_temperature() logging.debug('INFO: all_temp: %s' % str(all_temp)) a=1 if fan1_direction.lower()==\"intake\" else 0 sensor_temp=all_temp[a] cup_temp=all_temp[2] u60_temp=all_temp[3] logging.debug('sensor_temp:%d cup_temp:%d u60_temp:%d' %(sensor_temp, cup_temp, u60_temp)) update_temp_sensor, update_temp_cpu, update_temp_u60=True, True, True if all_temp[a] -temp_list[a] < 0: update_temp_sensor=False if cup_temp -temp_list[2] < 0: update_temp_cpu=False if u60_temp -temp_list[3] < 0: update_temp_u60=False if not update_temp_sensor: b=math.trunc(1400/13) if sensor_temp <=32000: sensor_temp_speed=40 elif sensor_temp >=45000: sensor_temp_speed=100 else: sensor_temp_speed=int(math.trunc(60 / 13) * math.trunc(sensor_temp / 1000) -b) else: b=math.trunc(1580 / 13) if sensor_temp <=35000: sensor_temp_speed=40 elif sensor_temp >=48000: sensor_temp_speed=100 else: sensor_temp_speed=int(math.trunc(60/13) * math.trunc(sensor_temp/1000) -b) if not update_temp_cpu: b=228 if cup_temp <=67000: cpu_temp_speed=40 elif cup_temp >=82000: cpu_temp_speed=100 else: cpu_temp_speed=int(4 *(cup_temp / 1000) -b) else: b=240 if cup_temp <=70000: cpu_temp_speed=40 elif cup_temp >=85000: cpu_temp_speed=100 else: cpu_temp_speed=int(4 *(cup_temp / 1000) -b) if not update_temp_u60: b=168 if u60_temp <=52000: u60_temp_speed=40 elif u60_temp >=67000: u60_temp_speed=100 else: u60_temp_speed=int(4 *(u60_temp / 1000) -b) else: b=180 if u60_temp <=55000: u60_temp_speed=40 elif u60_temp >=70000: u60_temp_speed=100 else: u60_temp_speed=int(4 *(u60_temp / 1000) -b) return max([sensor_temp_speed, cpu_temp_speed, u60_temp_speed]) def manage_fans(self): fan_presence_list=[True, True, True] for fan_index in range(FAN_NUMBER): if not self.platform_chassis_obj.get_fan(fan_index).get_presence() or not \\ self.platform_chassis_obj.get_fan(fan_index).get_status(): fan_presence_list[fan_index]=False logging.debug('self.platform_chassis_obj.get_fan(fan_index).get_presence():%s' % str(self.platform_chassis_obj.get_fan(fan_index).get_presence())) logging.debug('self.platform_chassis_obj.get_fan(fan_index).get_status():%s' % str(self.platform_chassis_obj.get_fan(fan_index).get_status())) else: fan_presence_list[fan_index]=True fans_inserted_num=FAN_NUMBER -fan_presence_list.count(False) if fans_inserted_num==0: self.syslog.critical(\"No fans inserted. Severe overheating hazard. \" \"Please insert Fans immediately or power off the device\\n\") elif fans_inserted_num in[1, 2]: self._new_perc=DUTY_MAX else: self._new_perc=self.get_fan_speed_by_temperature(self.init_fan_temperature) logging.debug('INFO: 3 fans inserted: self._new_perc: %s' % str(self._new_perc)) self.init_fan_temperature=self.get_all_temperature() for i in range(FAN_NUMBER): aa=self.platform_chassis_obj.get_fan(i).get_speed() logging.debug(\"INFO: Get before setting fan speed: %s\" % aa) if self._new_perc < 40: self._new_perc=40 if self._new_perc > 100: self._new_perc=100 set_stat=self.platform_chassis_obj.get_fan(i).set_speed(self._new_perc) if set_stat is True: logging.debug('INFO: PASS. set_fan%d_duty_cycle(%d)' %(i, self._new_perc)) else: logging.debug('INFO: FAIL. set_fan%d_duty_cycle(%d)' %(i, self._new_perc)) def handler(signum, frame): platform_chassis=platform.Platform().get_chassis() for _ in range(FAN_NUMBER): set_stat=platform_chassis.get_fan(_).set_speed(DUTY_MAX) if set_stat is True: logging.debug('INFO:Cause signal %d, set fan speed max.' % signum) else: logging.debug('INFO: FAIL. set_fan_duty_cycle(%d)' % DUTY_MAX) status, output=subprocess.getstatusoutput('i2cset -f -y 75 0x40 0x22 0x00') if status==0: logging.debug('INFO: CPLD Heartbeat check is enabled back') sys.exit(0) def main(argv): global test_temp log_file='/home/admin/%s.log' % FUNCTION_NAME log_level=logging.INFO if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv, 'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv) !=6: print(\"temp test, need input 4 temp\") return 0 signal.signal(signal.SIGINT, handler) signal.signal(signal.SIGTERM, handler) subprocess.getstatusoutput('i2cset -f -y 2 0x32 0x30 0x01') monitor=cel_belgite_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(10) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# Copyright (C) Celestica Technology Corporation\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    9/16/2021 (A.D.)\n# ------------------------------------------------------------------\n\ntry:\n    import sys\n    import getopt\n    import subprocess\n    import logging\n    import logging.config\n    import time  # this is only being used as part of the example\n    import signal\n    import math\n    from sonic_platform import platform\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nFUNCTION_NAME = 'cel_belgite_monitor'\nDUTY_MAX = 100\nFAN_NUMBER = 3\nSENSOR_NUMBER = 4\nCPU_CORE_TEMP = r\"/sys/devices/platform/coretemp.0/hwmon/hwmon1/temp1_input\"\n\n\nclass cel_belgite_monitor(object):\n    \"\"\"\n    Make a class we can use to capture stdout and sterr in the log\n    \"\"\"\n    # static temp var\n    _ori_temp = 0\n    _new_perc = DUTY_MAX / 2\n    syslog = logging.getLogger(\"[\" + FUNCTION_NAME + \"]\")\n    init_fan_temperature = [0, 0, 0, 0]\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        formatter = logging.Formatter('%(name)s %(message)s')\n        sys_handler = logging.handlers.SysLogHandler(address='/dev/log')\n        sys_handler.setFormatter(formatter)\n        sys_handler.ident = 'common'\n        self.syslog.setLevel(logging.WARNING)\n        self.syslog.addHandler(sys_handler)\n        self.platform_chassis_obj = platform.Platform().get_chassis()\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format='[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n        logging.debug('SET. logfile:%s / loglevel:%d' % (log_file, log_level))\n\n    def get_all_temperature(self):\n        \"\"\"\n        return: all temperature\n        \"\"\"\n        all_temperature_list = list()\n        for sensor_index in range(SENSOR_NUMBER):\n            temp = self.platform_chassis_obj.get_thermal(sensor_index).get_temperature()\n            if temp is None or str(temp).strip() == \"\":\n                return False\n            temp = temp*1000\n            all_temperature_list.append(temp)\n        u4_temperature = all_temperature_list[0]\n        u7_temperature = all_temperature_list[1]\n        # default CPU temperature 70\n        cpu_temperature = 70000\n        try:\n            with open(CPU_CORE_TEMP, \"r\") as f:\n                cpu_temperature = float(f.read().strip())\n        except Exception as E:\n            logging.debug('Error: %s' % E)\n        u60_temperature = all_temperature_list[3]   \n        return [u4_temperature, u7_temperature, cpu_temperature, u60_temperature]\n\n    def get_fan_speed_by_temperature(self, temp_list):\n        fan1_direction = self.platform_chassis_obj.get_fan(0).get_direction()\n        logging.debug('INFO: fan direction: %s' % str(fan1_direction))\n        all_temp = self.get_all_temperature()\n        logging.debug('INFO: all_temp: %s' % str(all_temp))\n        # B2F=intake: U7 temperature\uff0c F2B-EXHAUST: U4 temperature\n        a = 1 if fan1_direction.lower() == \"intake\" else 0\n        sensor_temp = all_temp[a]\n        cup_temp = all_temp[2]\n        u60_temp = all_temp[3]\n        logging.debug('sensor_temp:%d cup_temp:%d u60_temp:%d' % (sensor_temp, cup_temp, u60_temp))\n        update_temp_sensor, update_temp_cpu, update_temp_u60 = True, True, True\n        if all_temp[a] - temp_list[a] < 0:\n            update_temp_sensor = False\n        if cup_temp - temp_list[2] < 0:\n            update_temp_cpu = False\n        if u60_temp - temp_list[3] < 0:\n            update_temp_u60 = False\n\n        # U4 U7\n        if not update_temp_sensor:  # temperature down\n            b = math.trunc(1400/13)\n            if sensor_temp <= 32000:\n                sensor_temp_speed = 40\n            elif sensor_temp >= 45000:\n                sensor_temp_speed = 100\n            else:\n                sensor_temp_speed = int(math.trunc(60 / 13) * math.trunc(sensor_temp / 1000) - b)\n        else:   # temperature up\n            b = math.trunc(1580 / 13)\n            if sensor_temp <= 35000:\n                sensor_temp_speed = 40\n            elif sensor_temp >= 48000:\n                sensor_temp_speed = 100\n            else:\n                sensor_temp_speed = int(math.trunc(60/13) * math.trunc(sensor_temp/1000) - b)\n\n        # CPU\n        if not update_temp_cpu:  # temperature down\n            b = 228\n            if cup_temp <= 67000:\n                cpu_temp_speed = 40\n            elif cup_temp >= 82000:\n                cpu_temp_speed = 100\n            else:\n                cpu_temp_speed = int(4 * (cup_temp / 1000) - b)\n        else:   # temperature up\n            b = 240\n            if cup_temp <= 70000:\n                cpu_temp_speed = 40\n            elif cup_temp >= 85000:\n                cpu_temp_speed = 100\n            else:\n                cpu_temp_speed = int(4 * (cup_temp / 1000) - b)\n\n        # U60\n        if not update_temp_u60:  # temperature down\n            b = 168\n            if u60_temp <= 52000:\n                u60_temp_speed = 40\n            elif u60_temp >= 67000:\n                u60_temp_speed = 100\n            else:\n                u60_temp_speed = int(4 * (u60_temp / 1000) - b)\n        else:   # temperature up\n            b = 180\n            if u60_temp <= 55000:\n                u60_temp_speed = 40\n            elif u60_temp >= 70000:\n                u60_temp_speed = 100\n            else:\n                u60_temp_speed = int(4 * (u60_temp / 1000) - b)\n        return max([sensor_temp_speed, cpu_temp_speed, u60_temp_speed])\n\n    def manage_fans(self):\n        fan_presence_list = [True, True, True]  # whether fan is absent or not \n        for fan_index in range(FAN_NUMBER):\n            if not self.platform_chassis_obj.get_fan(fan_index).get_presence() or not \\\n                    self.platform_chassis_obj.get_fan(fan_index).get_status():\n                fan_presence_list[fan_index] = False\n                logging.debug('self.platform_chassis_obj.get_fan(fan_index).get_presence():%s'\n                              % str(self.platform_chassis_obj.get_fan(fan_index).get_presence()))\n                logging.debug('self.platform_chassis_obj.get_fan(fan_index).get_status():%s'\n                              % str(self.platform_chassis_obj.get_fan(fan_index).get_status()))\n            else:\n                fan_presence_list[fan_index] = True\n\n        fans_inserted_num = FAN_NUMBER - fan_presence_list.count(False)\n        if fans_inserted_num == 0:  # all fans broken, power off \n            self.syslog.critical(\"No fans inserted. Severe overheating hazard. \"\n                                 \"Please insert Fans immediately or power off the device\\n\")\n\n            # power off \n        elif fans_inserted_num in [1, 2]:   # 1 or 2 present, full speed \n            self._new_perc = DUTY_MAX\n        else:   # 3 fans normal, manage the fans follow thermal policy \n            self._new_perc = self.get_fan_speed_by_temperature(self.init_fan_temperature)\n            logging.debug('INFO: 3 fans inserted: self._new_perc: %s' % str(self._new_perc))\n            self.init_fan_temperature = self.get_all_temperature()\n\n        for i in range(FAN_NUMBER):\n            aa = self.platform_chassis_obj.get_fan(i).get_speed()\n            logging.debug(\"INFO: Get before setting fan speed: %s\" % aa)\n            if self._new_perc < 40:\n                self._new_perc = 40\n            if self._new_perc > 100:\n                self._new_perc = 100\n            set_stat = self.platform_chassis_obj.get_fan(i).set_speed(self._new_perc)\n            if set_stat is True:\n                logging.debug('INFO: PASS. set_fan%d_duty_cycle (%d)' % (i, self._new_perc))\n            else:\n                logging.debug('INFO: FAIL. set_fan%d_duty_cycle (%d)' % (i, self._new_perc))\n\n\ndef handler(signum, frame):\n    platform_chassis = platform.Platform().get_chassis()\n    for _ in range(FAN_NUMBER):\n        set_stat = platform_chassis.get_fan(_).set_speed(DUTY_MAX)\n        if set_stat is True:\n            logging.debug('INFO:Cause signal %d, set fan speed max.' % signum)\n        else:\n            logging.debug('INFO: FAIL. set_fan_duty_cycle (%d)' % DUTY_MAX)\n        # Enable the CPLD Heartbeat back\n        status, output = subprocess.getstatusoutput('i2cset -f -y 75 0x40 0x22 0x00')\n        if status == 0:\n            logging.debug('INFO: CPLD Heartbeat check is enabled back')\n    sys.exit(0)\n\n\ndef main(argv):\n    global test_temp\n\n    log_file = '/home/admin/%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv, 'hdlt:', ['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg\n\n        if sys.argv[1] == '-t':\n            if len(sys.argv) != 6:\n                print(\"temp test, need input 4 temp\")\n                return 0\n\n    signal.signal(signal.SIGINT, handler)\n    signal.signal(signal.SIGTERM, handler)\n    # Disaable the CPLD Heartbeat check to control Fan speed from CPU via ADT7470\n    subprocess.getstatusoutput('i2cset -f -y 2 0x32 0x30 0x01')\n\n    monitor = cel_belgite_monitor(log_file, log_level)\n\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(10)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n"}, "/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py": {"changes": [{"diff": "\n \n     SET_METHOD_IPMI = 'ipmitool'\n     NULL_VAL = 'N/A'\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n     REF_KEY = '$ref:'\n \n     def __init__(self, conf=None):\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n             cleaned_input = input_translator.get(input)\n \n         elif type(input_translator) is str:\n-            cleaned_input = eval(input_translator.format(input))\n+            cleaned_input = ast.literal_eval(input_translator.format(input))\n \n         return cleaned_input\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py", "badparts": ["            cleaned_input = eval(input_translator.format(input))"], "goodparts": ["            cleaned_input = ast.literal_eval(input_translator.format(input))"]}, {"diff": "\n         if type(output_translator) is dict:\n             output = output_translator.get(output)\n         elif type(output_translator) is str:\n-            output = eval(output_translator.format(output))\n+            output = ast.literal_eval(output_translator.format(output))\n         elif type(output_translator) is list:\n-            output = eval(output_translator[index].format(output))\n+            output = ast.literal_eval(output_translator[index].format(output))\n \n         return output\n \n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py", "badparts": ["            output = eval(output_translator.format(output))", "            output = eval(output_translator[index].format(output))"], "goodparts": ["            output = ast.literal_eval(output_translator.format(output))", "            output = ast.literal_eval(output_translator[index].format(output))"]}, {"diff": "\n         return True\n \n     def is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def load_json_file(self,", "add": 5, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        try:", "            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)", "        except FileNotFoundError:", "            return False", "        return True"]}], "source": "\nimport os import imp import yaml import subprocess from sonic_py_common import device_info class Common: DEVICE_PATH='/usr/share/sonic/device/' PMON_PLATFORM_PATH='/usr/share/sonic/platform/' CONFIG_DIR='sonic_platform_config' OUTPUT_SOURCE_IPMI='ipmitool' OUTPUT_SOURCE_GIVEN_LIST='value_list' OUTPUT_SOURCE_GIVEN_VALUE='value' OUTPUT_SOURCE_GIVEN_CLASS='class' OUTPUT_SOURCE_SYSFS='sysfs_value' OUTPUT_SOURCE_FUNC='function' OUTPUT_SOURCE_GIVEN_TXT_FILE='txt_file' OUTPUT_SOURCE_GIVEN_VER_HEX_FILE='hex_version_file' OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR='hex_version_getreg' SET_METHOD_IPMI='ipmitool' NULL_VAL='N/A' HOST_CHK_CMD=\"docker > /dev/null 2>&1\" REF_KEY='$ref:' def __init__(self, conf=None): self._main_conf=conf (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def _run_command(self, command): status=False output=\"\" try: p=subprocess.Popen( command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': status, output=True, raw_data.strip() except Exception: pass return status, output def _clean_input(self, input, config): cleaned_input=input ai=config.get('avaliable_input') if ai and input not in ai: return None input_translator=config.get('input_translator') if type(input_translator) is dict: cleaned_input=input_translator.get(input) elif type(input_translator) is str: cleaned_input=eval(input_translator.format(input)) return cleaned_input def _clean_output(self, index, output, config): output_translator=config.get('output_translator') if type(output_translator) is dict: output=output_translator.get(output) elif type(output_translator) is str: output=eval(output_translator.format(output)) elif type(output_translator) is list: output=eval(output_translator[index].format(output)) return output def _ipmi_get(self, index, config): argument=config.get('argument') cmd=config['command'].format( config['argument'][index]) if argument else config['command'] status, output=self._run_command(cmd) return output if status else None def _sysfs_read(self, index, config): sysfs_path=config.get('sysfs_path') argument=config.get('argument', '') if self.REF_KEY in argument: argument=self._main_conf[argument.split(\":\")[1]] if type(argument) is list: sysfs_path=sysfs_path.format(argument[index]) content=\"\" try: content=open(sysfs_path) content=content.readline().rstrip() except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False return content def _sysfs_write(self, index, config, input): sysfs_path=config.get('sysfs_path') argument=config.get('argument', '') if self.REF_KEY in argument: argument=self._main_conf[argument.split(\":\")[1]] if type(argument) is list: sysfs_path=sysfs_path.format(argument[index]) write_offset=int(config.get('write_offset', 0)) output=\"\" try: open_file=open(sysfs_path, \"r+\") open_file.seek(write_offset) open_file.write(input) open_file.close() except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False, output return True, output def _ipmi_set(self, index, config, input): arg=config['argument'][index].format(input) return self._run_command(config['command'].format(arg)) def _hex_ver_decode(self, hver, num_of_bits, num_of_points): ver_list=[] c_bit=0 bin_val=bin(int(hver, 16))[2:].zfill(num_of_bits) bit_split=num_of_bits /(num_of_points +1) for x in range(0, num_of_points+1): split_bin=bin_val[c_bit:c_bit+bit_split] ver_list.append(str(int(split_bin, 2))) c_bit +=bit_split return '.'.join(ver_list) def _get_class(self, config): \"\"\" Retreives value of expected attribute Returns: A value of the attribute of object \"\"\" path=config['host_path'] if self.is_host() else config['pmon_path'] module=imp.load_source(config['class'], path) class_=getattr(module, config['class']) return class_ def get_reg(self, path, reg_addr): cmd=\"echo{1} >{0}; cat{0}\".format(path, reg_addr) status, output=self._run_command(cmd) return output if status else None def read_txt_file(self, path): with open(path, 'r') as f: output=f.readline() return output.strip('\\n') def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except Exception: return False return True def is_host(self): return os.system(self.HOST_CHK_CMD)==0 def load_json_file(self, path): \"\"\" Retrieves the json object from json file path Returns: A json object \"\"\" with open(path, 'r') as f: json_data=yaml.safe_load(f) return json_data def get_config_path(self, config_name): \"\"\" Retrieves the path to platform api config directory Args: config_name: A string containing the name of config file. Returns: A string containing the path to json file \"\"\" return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name) def get_output(self, index, config, default): \"\"\" Retrieves the output for each function base on config Args: index: An integer containing the index of device. config: A dict object containing the configuration of specified function. default: A string containing the default output of specified function. Returns: A string containing the output of specified function in config \"\"\" output_source=config.get('output_source') if output_source==self.OUTPUT_SOURCE_IPMI: output=self._ipmi_get(index, config) elif output_source==self.OUTPUT_SOURCE_GIVEN_VALUE: output=config[\"value\"] elif output_source==self.OUTPUT_SOURCE_GIVEN_CLASS: output=self._get_class(config) elif output_source==self.OUTPUT_SOURCE_GIVEN_LIST: output=config[\"value_list\"][index] elif output_source==self.OUTPUT_SOURCE_SYSFS: output=self._sysfs_read(index, config) elif output_source==self.OUTPUT_SOURCE_FUNC: func_conf=self._main_conf[config['function'][index]] output=self.get_output(index, func_conf, default) elif output_source==self.OUTPUT_SOURCE_GIVEN_TXT_FILE: path=config.get('path') output=self.read_txt_file(path) elif output_source==self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE: path=config.get('path') hex_ver=self.read_txt_file(path) output=self._hex_ver_decode( hex_ver, config['num_of_bits'], config['num_of_points']) elif output_source==self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR: path=config.get('path') addr=config.get('reg_addr') hex_ver=self.get_reg(path, addr) output=self._hex_ver_decode( hex_ver, config['num_of_bits'], config['num_of_points']) else: output=default return self._clean_output(index, output, config) or default def set_output(self, index, input, config): \"\"\" Sets the output of specified function on config Args: config: A dict object containing the configuration of specified function. index: An integer containing the index of device. input: A string containing the input of specified function. Returns: bool: True if set function is successfully, False if not \"\"\" cleaned_input=self._clean_input(input, config) if not cleaned_input: return False set_method=config.get('set_method') if set_method==self.SET_METHOD_IPMI: output=self._ipmi_set(index, config, cleaned_input)[0] elif set_method==self.OUTPUT_SOURCE_SYSFS: output=self._sysfs_write(index, config, cleaned_input)[0] else: output=False return output def get_event(self, timeout, config, sfp_list): \"\"\" Returns a nested dictionary containing all devices which have experienced a change at chassis level \"\"\" event_class=self._get_class(config) return event_class(sfp_list).get_event(timeout) ", "sourceWithComments": "import os\nimport imp\nimport yaml\nimport subprocess\n\nfrom sonic_py_common import device_info\n\n\nclass Common:\n\n    DEVICE_PATH = '/usr/share/sonic/device/'\n    PMON_PLATFORM_PATH = '/usr/share/sonic/platform/'\n    CONFIG_DIR = 'sonic_platform_config'\n\n    OUTPUT_SOURCE_IPMI = 'ipmitool'\n    OUTPUT_SOURCE_GIVEN_LIST = 'value_list'\n    OUTPUT_SOURCE_GIVEN_VALUE = 'value'\n    OUTPUT_SOURCE_GIVEN_CLASS = 'class'\n    OUTPUT_SOURCE_SYSFS = 'sysfs_value'\n    OUTPUT_SOURCE_FUNC = 'function'\n    OUTPUT_SOURCE_GIVEN_TXT_FILE = 'txt_file'\n    OUTPUT_SOURCE_GIVEN_VER_HEX_FILE = 'hex_version_file'\n    OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR = 'hex_version_getreg'\n\n    SET_METHOD_IPMI = 'ipmitool'\n    NULL_VAL = 'N/A'\n    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n    REF_KEY = '$ref:'\n\n    def __init__(self, conf=None):\n        self._main_conf = conf\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def _run_command(self, command):\n        status = False\n        output = \"\"\n        try:\n            p = subprocess.Popen(\n                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                status, output = True, raw_data.strip()\n        except Exception:\n            pass\n        return status, output\n\n    def _clean_input(self, input, config):\n        cleaned_input = input\n\n        ai = config.get('avaliable_input')\n        if ai and input not in ai:\n            return None\n\n        input_translator = config.get('input_translator')\n        if type(input_translator) is dict:\n            cleaned_input = input_translator.get(input)\n\n        elif type(input_translator) is str:\n            cleaned_input = eval(input_translator.format(input))\n\n        return cleaned_input\n\n    def _clean_output(self, index, output, config):\n        output_translator = config.get('output_translator')\n\n        if type(output_translator) is dict:\n            output = output_translator.get(output)\n        elif type(output_translator) is str:\n            output = eval(output_translator.format(output))\n        elif type(output_translator) is list:\n            output = eval(output_translator[index].format(output))\n\n        return output\n\n    def _ipmi_get(self, index, config):\n        argument = config.get('argument')\n        cmd = config['command'].format(\n            config['argument'][index]) if argument else config['command']\n        status, output = self._run_command(cmd)\n        return output if status else None\n\n    def _sysfs_read(self, index, config):\n        sysfs_path = config.get('sysfs_path')\n        argument = config.get('argument', '')\n\n        if self.REF_KEY in argument:\n            argument = self._main_conf[argument.split(\":\")[1]]\n\n        if type(argument) is list:\n            sysfs_path = sysfs_path.format(argument[index])\n\n        content = \"\"\n        try:\n            content = open(sysfs_path)\n            content = content.readline().rstrip()\n        except IOError as e:\n            print(\"Error: unable to open file: %s\" % str(e))\n            return False\n\n        return content\n\n    def _sysfs_write(self, index, config, input):\n        sysfs_path = config.get('sysfs_path')\n        argument = config.get('argument', '')\n\n        if self.REF_KEY in argument:\n            argument = self._main_conf[argument.split(\":\")[1]]\n\n        if type(argument) is list:\n            sysfs_path = sysfs_path.format(argument[index])\n\n        write_offset = int(config.get('write_offset', 0))\n        output = \"\"\n        try:\n            open_file = open(sysfs_path, \"r+\")\n            open_file.seek(write_offset)\n            open_file.write(input)\n            open_file.close()\n        except IOError as e:\n            print(\"Error: unable to open file: %s\" % str(e))\n            return False, output\n        return True, output\n\n    def _ipmi_set(self, index, config, input):\n        arg = config['argument'][index].format(input)\n        return self._run_command(config['command'].format(arg))\n\n    def _hex_ver_decode(self, hver, num_of_bits, num_of_points):\n        ver_list = []\n        c_bit = 0\n        bin_val = bin(int(hver, 16))[2:].zfill(num_of_bits)\n        bit_split = num_of_bits / (num_of_points + 1)\n        for x in range(0, num_of_points+1):\n            split_bin = bin_val[c_bit:c_bit+bit_split]\n            ver_list.append(str(int(split_bin, 2)))\n            c_bit += bit_split\n        return '.'.join(ver_list)\n\n    def _get_class(self, config):\n        \"\"\"\n        Retreives value of expected attribute\n        Returns:\n            A value of the attribute of object\n        \"\"\"\n        path = config['host_path'] if self.is_host() else config['pmon_path']\n        module = imp.load_source(config['class'], path)\n        class_ = getattr(module, config['class'])\n        return class_\n\n    def get_reg(self, path, reg_addr):\n        cmd = \"echo {1} > {0}; cat {0}\".format(path, reg_addr)\n        status, output = self._run_command(cmd)\n        return output if status else None\n\n    def read_txt_file(self, path):\n        with open(path, 'r') as f:\n            output = f.readline()\n        return output.strip('\\n')\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except Exception:\n            return False\n        return True\n\n    def is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def load_json_file(self, path):\n        \"\"\"\n        Retrieves the json object from json file path\n\n        Returns:\n            A json object\n        \"\"\"\n        with open(path, 'r') as f:\n            json_data = yaml.safe_load(f)\n\n        return json_data\n\n    def get_config_path(self, config_name):\n        \"\"\"\n        Retrieves the path to platform api config directory\n\n        Args:\n            config_name: A string containing the name of config file.\n\n        Returns:\n            A string containing the path to json file\n        \"\"\"\n        return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\n\n    def get_output(self, index, config, default):\n        \"\"\"\n        Retrieves the output for each function base on config\n\n        Args:\n            index: An integer containing the index of device.\n            config: A dict object containing the configuration of specified function.\n            default: A string containing the default output of specified function.\n\n        Returns:\n            A string containing the output of specified function in config\n        \"\"\"\n        output_source = config.get('output_source')\n\n        if output_source == self.OUTPUT_SOURCE_IPMI:\n            output = self._ipmi_get(index, config)\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VALUE:\n            output = config[\"value\"]\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_CLASS:\n            output = self._get_class(config)\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_LIST:\n            output = config[\"value_list\"][index]\n\n        elif output_source == self.OUTPUT_SOURCE_SYSFS:\n            output = self._sysfs_read(index, config)\n\n        elif output_source == self.OUTPUT_SOURCE_FUNC:\n            func_conf = self._main_conf[config['function'][index]]\n            output = self.get_output(index, func_conf, default)\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\n            path = config.get('path')\n            output = self.read_txt_file(path)\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\n            path = config.get('path')\n            hex_ver = self.read_txt_file(path)\n            output = self._hex_ver_decode(\n                hex_ver, config['num_of_bits'], config['num_of_points'])\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\n            path = config.get('path')\n            addr = config.get('reg_addr')\n            hex_ver = self.get_reg(path, addr)\n            output = self._hex_ver_decode(\n                hex_ver, config['num_of_bits'], config['num_of_points'])\n\n        else:\n            output = default\n\n        return self._clean_output(index, output, config) or default\n\n    def set_output(self, index, input, config):\n        \"\"\"\n        Sets the output of specified function on config\n\n        Args:\n            config: A dict object containing the configuration of specified function.\n            index: An integer containing the index of device.\n            input: A string containing the input of specified function.\n\n        Returns:\n            bool: True if set function is successfully, False if not\n        \"\"\"\n        cleaned_input = self._clean_input(input, config)\n        if not cleaned_input:\n            return False\n\n        set_method = config.get('set_method')\n        if set_method == self.SET_METHOD_IPMI:\n            output = self._ipmi_set(index, config, cleaned_input)[0]\n        elif set_method == self.OUTPUT_SOURCE_SYSFS:\n            output = self._sysfs_write(index, config, cleaned_input)[0]\n        else:\n            output = False\n\n        return output\n\n    def get_event(self, timeout, config, sfp_list):\n        \"\"\"\n        Returns a nested dictionary containing all devices which have\n        experienced a change at chassis level\n\n        \"\"\"\n        event_class = self._get_class(config)\n        return event_class(sfp_list).get_event(timeout)\n"}, "/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py": {"changes": [{"diff": "\n import logging\n import subprocess\n \n-IPMI_SDR_CMD = \"ipmitool sdr elist\"\n+IPMI_SDR_CMD = [\"ipmitool\", \"sdr\", \"elist\"]\n MAX_NUM_FANS = 7\n MAX_NUM_PSUS = 2\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py", "badparts": ["IPMI_SDR_CMD = \"ipmitool sdr elist\""], "goodparts": ["IPMI_SDR_CMD = [\"ipmitool\", \"sdr\", \"elist\"]"]}, {"diff": "\n     '''\n     sensor_dump = ''\n     try:\n-        sensor_dump = subprocess.check_output(cmd, shell=True)\n+        sensor_dump = subprocess.check_output(cmd)\n     except subprocess.CalledProcessError as e:\n         logging.error('Error! Failed to execute: {}'.format(cmd))\n         sys.exit(1)\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py", "badparts": ["        sensor_dump = subprocess.check_output(cmd, shell=True)"], "goodparts": ["        sensor_dump = subprocess.check_output(cmd)"]}], "source": "\n import sys import logging import subprocess IPMI_SDR_CMD=\"ipmitool sdr elist\" MAX_NUM_FANS=7 MAX_NUM_PSUS=2 def ipmi_sensor_dump(cmd): ''' Execute ipmitool command return dump output exit if any error occur. ''' sensor_dump='' try: sensor_dump=subprocess.check_output(cmd, shell=True) except subprocess.CalledProcessError as e: logging.error('Error! Failed to execute:{}'.format(cmd)) sys.exit(1) return sensor_dump def get_reading_by_name(sensor_name, sdr_elist_dump): ''' Search for the match sensor name, return sensor reading value and unit, return object epmtry string if search not match. The output of sensor dump: TEMP_FAN_U52 | 00h | ok | 7.1 | 31 degrees C TEMP_FAN_U17 | 01h | ok | 7.1 | 27 degrees C TEMP_SW_U52 | 02h | ok | 7.1 | 30 degrees C Fan2_Status | 07h | ok | 29.2 | Present Fan2_Front | 0Eh | ok | 29.2 | 12000 RPM Fan2_Rear | 46h | ok | 29.2 | 14700 RPM PSU2_Status | 39h | ok | 10.2 | Presence detected PSU2_Fan | 3Dh | ok | 10.2 | 16000 RPM PSU2_VIn | 3Ah | ok | 10.2 | 234.30 Volts PSU2_CIn | 3Bh | ok | 10.2 | 0.80 Amps ''' found='' for line in sdr_elist_dump.split(\"\\n\"): if sensor_name in line: found=line.strip() break if not found: logging.error('Cannot find sensor name:' +sensor_name) else: try: found=found.split('|')[4] except IndexError: logging.error('Cannot get sensor data of:' +sensor_name) logging.basicConfig(level=logging.DEBUG) return found def read_temperature_sensors(ipmi_sdr_elist): sensor_list=[ ('TEMP_FAN_U52', 'Fan Tray Middle Temp'), ('TEMP_FAN_U17', 'Fan Tray Right Temp'), ('TEMP_SW_U52', 'Switchboard Left Inlet Temp'), ('TEMP_SW_U16', 'Switchboard Right Inlet Temp'), ('TEMP_BB_U3', 'Baseboard Temp'), ('TEMP_CPU', 'CPU Internal Temp'), ('TEMP_SW_Internal', 'ASIC Internal Temp'), ('SW_U04_Temp', 'IR3595 Chip Left Temp'), ('SW_U14_Temp', 'IR3595 Chip Right Temp'), ('SW_U4403_Temp', 'IR3584 Chip Temp'), ] output='' sensor_format='{0:{width}}{1}\\n' max_name_width=max(len(sensor[1]) for sensor in sensor_list) output +=\"Temperature Sensors\\n\" output +=\"Adapter: IPMI adapter\\n\" for sensor in sensor_list: reading=get_reading_by_name(sensor[0],ipmi_sdr_elist) output +=sensor_format.format('{}:'.format(sensor[1]), reading, width=str(max_name_width+1)) output +='\\n' return output def read_fan_sensors(num_fans, ipmi_sdr_elist): sensor_list=[ ('Fan{}_Status', 'Status'), ('Fan{}_Front', 'Fan{} front'), ('Fan{}_Rear', 'Fan{} rear'), ] output='' sensor_format='{0:{width}}{1}\\n' max_name_width=max(len(sensor[1]) for sensor in sensor_list) output +=\"Fan Trays\\n\" output +=\"Adapter: IPMI adapter\\n\" for fan_num in range(1, num_fans+1): for sensor in sensor_list: ipmi_sensor_name=sensor[0].format(fan_num) display_sensor_name=sensor[1].format(fan_num) reading=get_reading_by_name(ipmi_sensor_name, ipmi_sdr_elist) output +=sensor_format.format('{}:'.format(display_sensor_name), reading, width=str(max_name_width+1)) output +='\\n' return output def read_psu_sensors(num_psus, ipmi_sdr_elist): sensor_list=[ ('PSU{}_Status', 'PSU{} Status'), ('PSU{}_Fan', 'PSU{} Fan'), ('PSU{}_VIn', 'PSU{} Input Voltag'), ('PSU{}_CIn', 'PSU{} Input Current'), ('PSU{}_PIn', 'PSU{} Input Power'), ('PSU{}_Temp1', 'PSU{} Temp1'), ('PSU{}_Temp2', 'PSU{} Temp2'), ('PSU{}_VOut', 'PSU{} Output Voltag'), ('PSU{}_COut', 'PSU{} Output Current'), ('PSU{}_POut', 'PSU{} Output Power'), ] output='' sensor_format='{0:{width}}{1}\\n' max_name_width=max(len(sensor[1]) for sensor in sensor_list) output +=\"PSU\\n\" output +=\"Adapter: IPMI adapter\\n\" for psu_num in range(1, num_psus+1): for sensor in sensor_list: ipmi_sensor_name=sensor[0].format(psu_num) display_sensor_name=sensor[1].format(psu_num) reading=get_reading_by_name(ipmi_sensor_name, ipmi_sdr_elist) output +=sensor_format.format('{}:'.format(display_sensor_name), reading, width=str(max_name_width+1)) output +='\\n' return output def main(): output_string='' ipmi_sdr_elist=ipmi_sensor_dump(IPMI_SDR_CMD) output_string +=read_temperature_sensors(ipmi_sdr_elist) output_string +=read_psu_sensors(MAX_NUM_PSUS, ipmi_sdr_elist) output_string +=read_fan_sensors(MAX_NUM_FANS, ipmi_sdr_elist) print(output_string) if __name__=='__main__': main() ", "sourceWithComments": "#!/usr/bin/python\n#\n# Silverstone platform sensors. This script get the sensor data from BMC \n# using ipmitool and display them in lm-sensor alike format.\n#\n# The following data is support:\n#  1. Temperature sensors\n#  2. PSUs\n#  3. Fan trays\n\nimport sys\nimport logging\nimport subprocess\n\nIPMI_SDR_CMD = \"ipmitool sdr elist\"\nMAX_NUM_FANS = 7\nMAX_NUM_PSUS = 2\n\n\ndef ipmi_sensor_dump(cmd):\n    ''' Execute ipmitool command return dump output\n        exit if any error occur.\n    '''\n    sensor_dump = ''\n    try:\n        sensor_dump = subprocess.check_output(cmd, shell=True)\n    except subprocess.CalledProcessError as e:\n        logging.error('Error! Failed to execute: {}'.format(cmd))\n        sys.exit(1)\n    return sensor_dump\n\ndef get_reading_by_name(sensor_name, sdr_elist_dump):\n    '''\n        Search for the match sensor name, return sensor\n        reading value and unit, return object epmtry string \n        if search not match.\n\n        The output of sensor dump:\n        TEMP_FAN_U52     | 00h | ok  |  7.1 | 31 degrees C\n        TEMP_FAN_U17     | 01h | ok  |  7.1 | 27 degrees C\n        TEMP_SW_U52      | 02h | ok  |  7.1 | 30 degrees C\n        Fan2_Status      | 07h | ok  | 29.2 | Present\n        Fan2_Front       | 0Eh | ok  | 29.2 | 12000 RPM\n        Fan2_Rear        | 46h | ok  | 29.2 | 14700 RPM\n        PSU2_Status      | 39h | ok  | 10.2 | Presence detected\n        PSU2_Fan         | 3Dh | ok  | 10.2 | 16000 RPM\n        PSU2_VIn         | 3Ah | ok  | 10.2 | 234.30 Volts\n        PSU2_CIn         | 3Bh | ok  | 10.2 | 0.80 Amps\n    '''\n    found = ''\n\n    for line in sdr_elist_dump.split(\"\\n\"):\n        if sensor_name in line:\n            found = line.strip()\n            break\n\n    if not found:\n        logging.error('Cannot find sensor name:' + sensor_name)\n\n    else:\n        try:\n            found = found.split('|')[4]\n        except IndexError:\n            logging.error('Cannot get sensor data of:' + sensor_name)\n\n    logging.basicConfig(level=logging.DEBUG)\n    return found\n\n\ndef read_temperature_sensors(ipmi_sdr_elist):\n\n    sensor_list = [\n        ('TEMP_FAN_U52',        'Fan Tray Middle Temp'),\n        ('TEMP_FAN_U17',        'Fan Tray Right Temp'),\n        ('TEMP_SW_U52',         'Switchboard Left Inlet Temp'),\n        ('TEMP_SW_U16',         'Switchboard Right Inlet Temp'),\n        ('TEMP_BB_U3',          'Baseboard Temp'),\n        ('TEMP_CPU',            'CPU Internal Temp'),\n        ('TEMP_SW_Internal',    'ASIC Internal Temp'),\n        ('SW_U04_Temp',         'IR3595 Chip Left Temp'),\n        ('SW_U14_Temp',         'IR3595 Chip Right Temp'),\n        ('SW_U4403_Temp',       'IR3584 Chip Temp'),\n    ]\n\n    output = ''\n    sensor_format = '{0:{width}}{1}\\n'\n    # Find max length of sensor calling name\n    max_name_width = max(len(sensor[1]) for sensor in sensor_list)\n\n    output += \"Temperature Sensors\\n\"\n    output += \"Adapter: IPMI adapter\\n\"\n    for sensor in sensor_list:\n        reading = get_reading_by_name(sensor[0],ipmi_sdr_elist)\n        output += sensor_format.format('{}:'.format(sensor[1]),\n                                       reading,\n                                       width=str(max_name_width+1))\n    output += '\\n'\n    return output\n\n\ndef read_fan_sensors(num_fans, ipmi_sdr_elist):\n\n    sensor_list = [\n        ('Fan{}_Status',    'Status'),\n        ('Fan{}_Front',     'Fan {} front'),\n        ('Fan{}_Rear',      'Fan {} rear'),\n    ]\n\n    output = ''\n    sensor_format = '{0:{width}}{1}\\n'\n    # Find max length of sensor calling name\n    max_name_width = max(len(sensor[1]) for sensor in sensor_list)\n\n    output += \"Fan Trays\\n\"\n    output += \"Adapter: IPMI adapter\\n\"\n    for fan_num in range(1, num_fans+1):\n        for sensor in sensor_list:\n            ipmi_sensor_name = sensor[0].format(fan_num)\n            display_sensor_name = sensor[1].format(fan_num)\n            reading = get_reading_by_name(ipmi_sensor_name, ipmi_sdr_elist)\n            output += sensor_format.format('{}:'.format(display_sensor_name),\n                                           reading,\n                                           width=str(max_name_width+1))\n    output += '\\n'\n    return output\n\n\ndef read_psu_sensors(num_psus, ipmi_sdr_elist):\n\n    sensor_list = [\n        ('PSU{}_Status',    'PSU {} Status'),\n        ('PSU{}_Fan',       'PSU {} Fan'),\n        ('PSU{}_VIn',       'PSU {} Input Voltag'),\n        ('PSU{}_CIn',       'PSU {} Input Current'),\n        ('PSU{}_PIn',       'PSU {} Input Power'),\n        ('PSU{}_Temp1',     'PSU {} Temp1'),\n        ('PSU{}_Temp2',     'PSU {} Temp2'),\n        ('PSU{}_VOut',      'PSU {} Output Voltag'),\n        ('PSU{}_COut',      'PSU {} Output Current'),\n        ('PSU{}_POut',      'PSU {} Output Power'),\n    ]\n\n    output = ''\n    sensor_format = '{0:{width}}{1}\\n'\n    # Find max length of sensor calling name\n    max_name_width = max(len(sensor[1]) for sensor in sensor_list)\n\n    output += \"PSU\\n\"\n    output += \"Adapter: IPMI adapter\\n\"\n    for psu_num in range(1, num_psus+1):\n        for sensor in sensor_list:\n            ipmi_sensor_name = sensor[0].format(psu_num)\n            display_sensor_name = sensor[1].format(psu_num)\n            reading = get_reading_by_name(ipmi_sensor_name, ipmi_sdr_elist)\n            output += sensor_format.format('{}:'.format(display_sensor_name),\n                                           reading,\n                                           width=str(max_name_width+1))\n    output += '\\n'\n    return output\n\n\ndef main():\n    output_string = ''\n\n    ipmi_sdr_elist = ipmi_sensor_dump(IPMI_SDR_CMD)\n    output_string += read_temperature_sensors(ipmi_sdr_elist)\n    output_string += read_psu_sensors(MAX_NUM_PSUS, ipmi_sdr_elist)\n    output_string += read_fan_sensors(MAX_NUM_FANS, ipmi_sdr_elist)\n    print(output_string)\n\n\nif __name__ == '__main__':\n    main()\n"}}, "msg": "[device/celestica] Mitigation for command injection vulnerability (#11740)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\nDependency: [PR (#12065)](https://github.com/sonic-net/sonic-buildimage/pull/12065) needs to merge first.\r\n#### Why I did it\r\n1. `eval()` - not secure against maliciously constructed input, can be dangerous if used to evaluate dynamic content. This may be a code injection vulnerability.\r\n2. `subprocess()` - when using with `shell=True` is dangerous. Using subprocess function without a static string can lead to command injection.\r\n3. `os` - not secure against maliciously constructed input and dangerous if used to evaluate dynamic content.\r\n4. `is` operator - string comparison should not be used with reference equality.\r\n5. `globals()` - extremely dangerous because it may allow an attacker to execute arbitrary code on the system\r\n#### How I did it\r\n1. `eval()` - use `literal_eval()`\r\n2. `subprocess()` - use `shell=False` instead. use an array string. Ref: [https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation](https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation)\r\n3. `os` - use with `subprocess`\r\n4. `is` - replace by `==` operator for value equality\r\n5. `globals()` - avoid the use of globals()"}}, "https://github.com/sonic-net/sonic-buildimage": {"92d25be08f3866b4ae37f8eeba7ef53369851803": {"url": "https://api.github.com/repos/sonic-net/sonic-buildimage/commits/92d25be08f3866b4ae37f8eeba7ef53369851803", "html_url": "https://github.com/sonic-net/sonic-buildimage/commit/92d25be08f3866b4ae37f8eeba7ef53369851803", "sha": "92d25be08f3866b4ae37f8eeba7ef53369851803", "keyword": "command injection malicious", "diff": "diff --git a/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py b/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py\nindex bcb05b9cb845..9c994c572dd4 100755\n--- a/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py\n@@ -17,13 +17,11 @@\n \n try:\n     import os\n-    import commands\n-    import sys, getopt\n-    import logging\n     import re\n     import time\n     import syslog\n     from sonic_sfp.bcmshell import bcmshell\n+    from sonic_py_common.general import getstatusoutput_noshell\n     \n except ImportError as e:\n     raise ImportError(\"%s - required module not found\" % str(e))\n@@ -53,10 +51,10 @@ def initialLoop():\n             bcm_obj = BCMUtil()\n             bcm_obj.execute_command(\"echo\")\n             initialNotOK = False\n-            print bcm_obj\n+            print(bcm_obj)\n             log_message( syslog.LOG_INFO, \"BCMUtil Object initialed successfully\" )  \n-        except Exception, e:   \n-            print \"Exception. The warning is {0}\".format(str(e)) \n+        except Exception as e:   \n+            print(\"Exception. The warning is {0}\".format(str(e)))\n             time.sleep(10)\n             \n class BCMUtil(bcmshell):\n@@ -66,7 +64,7 @@ class BCMUtil(bcmshell):\n     \n     def get_platform(self):\n         if self.platform is None:\n-            self.platform = os.popen(\"uname -n\").read().strip()\n+            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"]).strip()\n         return self.platform\n         \n     def get_asic_temperature( self ):\n@@ -102,14 +100,18 @@ def main():\n                         content = readPtr.read().strip()\n                         if bcm_obj.get_platform() == INV_SEQUOIA_PLATFORM :\n                             if content == \"inv_bmc\" and SWITCH_TEMP_FILE_NAME in file_list :\n-                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n+                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)\n+                                with open(file, 'w') as f:\n+                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')\n                                 break\n                         else :\n                             if content == \"inv_psoc\" and SWITCH_TEMP_FILE_NAME in file_list :\n-                                print \"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME )\n-                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n+                                print(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME))\n+                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)\n+                                with open(file, 'w') as f:\n+                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')\n                                 break\n-        except Exception, e:\n+        except Exception as e:\n             log_message( syslog.LOG_WARNING, \"Exception. The warning is {0}\".format(str(e)) )\n             initialLoop()            \n         time.sleep(5)\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py b/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py\nindex bab0e2dafe76..8f4564287dde 100755\n--- a/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py\n@@ -20,6 +20,7 @@\n import syslog\n import re\n from sonic_sfp.bcmshell import bcmshell\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n # =====================================================================\n@@ -120,8 +121,8 @@ def _board_init():\n     global SYNC_S\n     global SYNC_P\n \n-    cmd = \"uname -n\"\n-    platform = os.popen(cmd).read()\n+    cmd = [\"uname\", \"-n\"]\n+    _, platform = getstatusoutput_noshell(cmd)\n \n     if platform.rstrip() == INV_MAGNOLIA:\n         BOARD_TPYE      = \"inventec_d6254qs\"\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py b/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py\nindex f1e7f7fece77..d73687e025ae 100755\n--- a/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py\n@@ -2,6 +2,7 @@\n \n import os\n import socket\n+import subprocess\n from collections import OrderedDict\n \n # Purpose:  Shutdown DUT upon receiving thermaltrip event from kernel (inv_pthread)\n@@ -59,6 +60,6 @@ def next_events(self):\n \n             # Receive thermaltrip event\n             if event['ACTION'] == 'remove' and event['DEVPATH'] == '/kernel/platform_status/fan':\n-                os.system(\"shutdown -h now\")\n+                subprocess.call([\"shutdown\", \"-h\", \"now\"])\n                 \n \ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py b/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py\nindex 9e4a44c167fe..453c33deeaf3 100755\n--- a/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py\n@@ -28,6 +28,7 @@\n     import syslog\n     from sfputil import SfpUtil\n     from sonic_sfp.bcmshell import bcmshell\n+    from sonic_py_common.general import getstatusoutput_noshell\n     \n except ImportError as e:\n     raise ImportError(\"%s - required module not found\" % str(e))\n@@ -127,7 +128,7 @@ class BCMUtil(bcmshell):\n     \n     def get_platform(self):\n         if self.platform is None:\n-            self.platform = os.popen(\"uname -n\").read().strip()\n+            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"])\n         return self.platform\n     \n     def get_port_to_bcm_mapping(self):  \ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py b/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py\nindex b1f8799ab593..f71a19d00e62 100644\n--- a/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py\n@@ -8,6 +8,7 @@\n try:\n     import os\n     import logging\n+    import subprocess\n     from ctypes import create_string_buffer\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8436 import sff8436Dom\n@@ -120,7 +121,7 @@ def __set_attr_value(self, attr_path, value):\n         return True\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/device'\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py b/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py\nindex a468a323d6fc..d467fd8fb5df 100755\n--- a/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py\n@@ -33,6 +33,7 @@\n import logging\n import syslog\n import time\n+from sonic_py_common.general import getstatusoutput_noshell_pipe\n \n DEBUG = False\n args = []\n@@ -236,8 +237,9 @@ def system_install(boot_option):\n \t      return status\n     for addr_offset in range (0,FAN_NUM):\n         addr=FAN_VPD_ADDR_BASE+addr_offset\n-        cmd = \"i2cdetect -y \"+str(FAN_VPD_CHANNEL)+\" \"+str(addr)+\" \"+str(addr)+\" | grep \"+str(hex(addr)).replace('0x','')\n-        result=os.system(cmd)\n+        cmd1 = [\"i2cdetect\", \"-y\", str(FAN_VPD_CHANNEL), str(addr), str(addr)]\n+        cmd2 = [\"grep\", f'{addr:x}']\n+        result, _ = getstatusoutput_noshell_pipe(cmd1, cmd2)\n         if( result==0 ):\n             cmd=\"echo inv_eeprom \"+str(addr)+\" > /sys/bus/i2c/devices/i2c-\"+FAN_VPD_CHANNEL\n             status, output = exec_cmd(cmd,1)\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py b/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py\nindex fccde46df4c5..22eae317f8ce 100644\n--- a/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py\n@@ -9,6 +9,7 @@\n     import os\n     import sys\n     import time\n+    import subprocess\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8436 import sff8436Dom\n     from sonic_platform_base.sonic_sfp.sff8436 import sff8436InterfaceId\n@@ -108,7 +109,7 @@ def __get_attr_value(self, attr_path):\n         return retval\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/device'\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py b/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py\nindex 5c75a8749a46..de8d50b7abda 100644\n--- a/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py\n@@ -7,7 +7,7 @@\n \n try:\n     import os\n-    import sys\n+    import subprocess\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472InterfaceId\n@@ -95,7 +95,7 @@ def __get_attr_value(self, attr_path):\n         return retval\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/device'\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py b/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py\nindex 9d6337195d5d..ee5768a640f7 100644\n--- a/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py\n@@ -153,7 +153,7 @@ class Sfp(SfpBase):\n     # Path to QSFP sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-inventec_d7054q28b-r0\"\n     HWSKU  = \"INVENTEC-D7054Q28B-S48-Q6\"\n@@ -285,7 +285,7 @@ def __read_txt_file(self, file_path):\n         return \"\"\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n", "message": "", "files": {"/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py": {"changes": [{"diff": "\n \n try:\n     import os\n-    import commands\n-    import sys, getopt\n-    import logging\n     import re\n     import time\n     import syslog\n     from sonic_sfp.bcmshell import bcmshell\n+    from sonic_py_common.general import getstatusoutput_noshell\n     \n except ImportError as e:\n     raise ImportError(\"%s - required module not found\" % str(e))\n", "add": 1, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py", "badparts": ["    import commands", "    import sys, getopt", "    import logging"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n             bcm_obj = BCMUtil()\n             bcm_obj.execute_command(\"echo\")\n             initialNotOK = False\n-            print bcm_obj\n+            print(bcm_obj)\n             log_message( syslog.LOG_INFO, \"BCMUtil Object initialed successfully\" )  \n-        except Exception, e:   \n-            print \"Exception. The warning is {0}\".format(str(e)) \n+        except Exception as e:   \n+            print(\"Exception. The warning is {0}\".format(str(e)))\n             time.sleep(10)\n             \n class BCMUtil(bcmshell):\n", "add": 3, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py", "badparts": ["            print bcm_obj", "        except Exception, e:   ", "            print \"Exception. The warning is {0}\".format(str(e)) "], "goodparts": ["            print(bcm_obj)", "        except Exception as e:   ", "            print(\"Exception. The warning is {0}\".format(str(e)))"]}, {"diff": "\n     \n     def get_platform(self):\n         if self.platform is None:\n-            self.platform = os.popen(\"uname -n\").read().strip()\n+            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"]).strip()\n         return self.platform\n         \n     def get_asic_temperature( self ):\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py", "badparts": ["            self.platform = os.popen(\"uname -n\").read().strip()"], "goodparts": ["            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"]).strip()"]}, {"diff": "\n                         content = readPtr.read().strip()\n                         if bcm_obj.get_platform() == INV_SEQUOIA_PLATFORM :\n                             if content == \"inv_bmc\" and SWITCH_TEMP_FILE_NAME in file_list :\n-                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n+                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)\n+                                with open(file, 'w') as f:\n+                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')\n                                 break\n                         else :\n                             if content == \"inv_psoc\" and SWITCH_TEMP_FILE_NAME in file_list :\n-                                print \"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME )\n-                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n+                                print(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME))\n+                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)\n+                                with open(file, 'w') as f:\n+                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')\n                                 break\n-        except Exception, e:\n+        except Exception as e:\n             log_message( syslog.LOG_WARNING, \"Exception. The warning is {0}\".format(str(e)) )\n             initialLoop()            \n         time.sleep(5)", "add": 8, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py", "badparts": ["                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))", "                                print \"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME )", "                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))", "        except Exception, e:"], "goodparts": ["                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)", "                                with open(file, 'w') as f:", "                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')", "                                print(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME))", "                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)", "                                with open(file, 'w') as f:", "                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')", "        except Exception as e:"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object Auto detecting the Chipset temperature and update options: -h | --help : this help message -d | --debug : run with debug mode \"\"\" try: import os import commands import sys, getopt import logging import re import time import syslog from sonic_sfp.bcmshell import bcmshell except ImportError as e: raise ImportError(\"%s -required module not found\" % str(e)) args=[] INV_REDWOOD_PLATFORM=\"SONiC-Inventec-d7032-100\" INV_CYPRESS_PLATFORM=\"SONiC-Inventec-d7054\" INV_SEQUOIA_PLATFORM=\"SONiC-Inventec-d7264\" INV_MAPLE_PLATFORM=\"SONiC-Inventec-d6556\" INV_MAGNOLIA_PLATFORM=\"SONiC-Inventec-d6254qs\" PSOC_NAME=\"name\" HWMON_PATH=\"/sys/class/hwmon/\" SWITCH_TEMP_FILE_NAME=\"switch_tmp\" def log_message( level, string): syslog.openlog(\"asic_monitor\", syslog.LOG_PID, facility=syslog.LOG_DAEMON) syslog.syslog( level, string) def initialLoop(): global bcm_obj initialNotOK=True while initialNotOK: try: bcm_obj=BCMUtil() bcm_obj.execute_command(\"echo\") initialNotOK=False print bcm_obj log_message( syslog.LOG_INFO, \"BCMUtil Object initialed successfully\") except Exception, e: print \"Exception. The warning is{0}\".format(str(e)) time.sleep(10) class BCMUtil(bcmshell): asic_temperature=0 platform=None def get_platform(self): if self.platform is None: self.platform=os.popen(\"uname -n\").read().strip() return self.platform def get_asic_temperature( self): return self.asic_temperature def set_asic_temperature( self, temp): self.asic_temperature=temp def parsing_asic_temp(self): content=self.run(\"show temp\") for line in content.split(\"\\n\"): TempObject=re.search(r\"(average current temperature is)\\s+(?P<temperature_high>\\d+)\\.(?P<temperature_low>\\d+)\",line) if TempObject is not None: self.set_asic_temperature( int( TempObject.group(\"temperature_high\"))) def execute_command(self, cmd): return self.run(cmd) def main(): global bcm_obj initialLoop() log_message( syslog.LOG_INFO, \"Object initialed successfully\") while 1: try: bcm_obj.parsing_asic_temp() for index in os.listdir(HWMON_PATH): file_list=os.listdir(\"{0}/{1}/device/\".format(HWMON_PATH,index)) if PSOC_NAME in file_list: with open( \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, PSOC_NAME), 'rb') as readPtr: content=readPtr.read().strip() if bcm_obj.get_platform()==INV_SEQUOIA_PLATFORM: if content==\"inv_bmc\" and SWITCH_TEMP_FILE_NAME in file_list: os.system(\"echo{0} >{1}/{2}/device/{3}\".format(( bcm_obj.get_asic_temperature() * 1000), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)) break else: if content==\"inv_psoc\" and SWITCH_TEMP_FILE_NAME in file_list: print \"echo{0} >{1}/{2}/device/{3}\".format(( bcm_obj.get_asic_temperature() * 1000), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME) os.system(\"echo{0} >{1}/{2}/device/{3}\".format(( bcm_obj.get_asic_temperature() * 1000), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)) break except Exception, e: log_message( syslog.LOG_WARNING, \"Exception. The warning is{0}\".format(str(e))) initialLoop() time.sleep(5) syslog.closelog() del bcm_obj if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2018 Inventec, Inc.\n# \n# Editor: James Huang ( Huang.James@inventec.com )\n#  \n\"\"\"\nUsage: %(scriptName)s [options] command object\n\nAuto detecting the Chipset temperature and update\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n   \n\"\"\"\n\ntry:\n    import os\n    import commands\n    import sys, getopt\n    import logging\n    import re\n    import time\n    import syslog\n    from sonic_sfp.bcmshell import bcmshell\n    \nexcept ImportError as e:\n    raise ImportError(\"%s - required module not found\" % str(e))\n\nargs = []\nINV_REDWOOD_PLATFORM = \"SONiC-Inventec-d7032-100\"\nINV_CYPRESS_PLATFORM = \"SONiC-Inventec-d7054\"\nINV_SEQUOIA_PLATFORM = \"SONiC-Inventec-d7264\"\nINV_MAPLE_PLATFORM = \"SONiC-Inventec-d6556\"\nINV_MAGNOLIA_PLATFORM = \"SONiC-Inventec-d6254qs\"\n\nPSOC_NAME = \"name\"\nHWMON_PATH = \"/sys/class/hwmon/\"\nSWITCH_TEMP_FILE_NAME = \"switch_tmp\"\n\ndef log_message( level, string ):\n    syslog.openlog(\"asic_monitor\", syslog.LOG_PID, facility=syslog.LOG_DAEMON)\n    syslog.syslog( level, string )\n\ndef initialLoop():\n\n    global bcm_obj\n    initialNotOK = True\n    \n    while initialNotOK :        \n        try:                \n            bcm_obj = BCMUtil()\n            bcm_obj.execute_command(\"echo\")\n            initialNotOK = False\n            print bcm_obj\n            log_message( syslog.LOG_INFO, \"BCMUtil Object initialed successfully\" )  \n        except Exception, e:   \n            print \"Exception. The warning is {0}\".format(str(e)) \n            time.sleep(10)\n            \nclass BCMUtil(bcmshell):\n\n    asic_temperature = 0\n    platform = None\n    \n    def get_platform(self):\n        if self.platform is None:\n            self.platform = os.popen(\"uname -n\").read().strip()\n        return self.platform\n        \n    def get_asic_temperature( self ):\n        return self.asic_temperature\n        \n    def set_asic_temperature( self, temp ):\n        self.asic_temperature = temp\n                \n    def parsing_asic_temp(self):\n        content = self.run(\"show temp\")\n        for line in content.split(\"\\n\"):\n            TempObject = re.search(r\"(average current temperature is)\\s+(?P<temperature_high>\\d+)\\.(?P<temperature_low>\\d+)\",line)\n            if TempObject is not None:\n                self.set_asic_temperature( int( TempObject.group(\"temperature_high\") ) )\n        \n    def execute_command(self, cmd):\n        return self.run(cmd)\n     \n        \ndef main():\n\n    global bcm_obj\n    initialLoop()\n    log_message( syslog.LOG_INFO, \"Object initialed successfully\" )\n\n    while 1 :\n        try:\n            bcm_obj.parsing_asic_temp()\n            for index in os.listdir(HWMON_PATH):\n                file_list = os.listdir(\"{0}/{1}/device/\".format(HWMON_PATH,index))\n                if PSOC_NAME in file_list :\n                    with open( \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, PSOC_NAME), 'rb') as readPtr:\n                        content = readPtr.read().strip()\n                        if bcm_obj.get_platform() == INV_SEQUOIA_PLATFORM :\n                            if content == \"inv_bmc\" and SWITCH_TEMP_FILE_NAME in file_list :\n                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n                                break\n                        else :\n                            if content == \"inv_psoc\" and SWITCH_TEMP_FILE_NAME in file_list :\n                                print \"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME )\n                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n                                break\n        except Exception, e:\n            log_message( syslog.LOG_WARNING, \"Exception. The warning is {0}\".format(str(e)) )\n            initialLoop()            \n        time.sleep(5)\n\n    syslog.closelog()\n    del bcm_obj\n\nif __name__ == \"__main__\":\n    main()\n\n\n\n\n\n"}, "/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py": {"changes": [{"diff": "\n     global SYNC_S\n     global SYNC_P\n \n-    cmd = \"uname -n\"\n-    platform = os.popen(cmd).read()\n+    cmd = [\"uname\", \"-n\"]\n+    _, platform = getstatusoutput_noshell(cmd)\n \n     if platform.rstrip() == INV_MAGNOLIA:\n         BOARD_TPYE      = \"inventec_d6254qs", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py", "badparts": ["    cmd = \"uname -n\"", "    platform = os.popen(cmd).read()"], "goodparts": ["    cmd = [\"uname\", \"-n\"]", "    _, platform = getstatusoutput_noshell(cmd)"]}], "source": "\n import os import time import syslog import re from sonic_sfp.bcmshell import bcmshell PORT_LIST =[] BCM_SHELL =None SHELL_READY=False STATUS_RX =1<<0 STATUS_TX =1<<1 PORT_DATA_OFFSET_ADDR =0xA0 INV_MAGNOLIA =\"SONiC-Inventec-d6254qs\" INV_REDWOOD =\"SONiC-Inventec-d7032-100\" INV_CYPRESS =\"SONiC-Inventec-d7054\" INV_MAPLE =\"SONiC-Inventec-d6556\" INV_SEQUOIA =\"\" BOARD_TPYE =\"\" EAGLE_CORE =[] BIT_LINK =None BIT_FAULT =None BIT_TX =None BIT_RX =None BIT_SPEED0 =None BIT_SPEED1 =None SPEED_100G =100 SPEED_40G =40 SPEED_25G =25 SPEED_10G =10 class Port(): port_num =None name =None bcm_id =None led_up =None s_addr =None write2_up =None led_index =None link_status =None speed =None def write_data_ram(self, data): BCM_SHELL.cmd(\"setreg CMIC_LEDUP{0}_DATA_RAM({1}){2}\".format(self.write2_up, self.led_index, data)) def read_data_ram(self): r_string=BCM_SHELL.run(\"getreg CMIC_LEDUP{0}_DATA_RAM({1})\".format(self.led_up, self.s_addr)) for line in r_string.split(\"\\n\"): re_obj=re.search(r\"\\<DATA\\=(?P<data>.+)\\>\", line) if re_obj is not None: return int(re_obj.group(\"data\"), 16) def _remap_registers(fp): content=fp.readlines() fp.close() err=False for line in content: try: BCM_SHELL.cmd(line.rstrip()) except Exception, e: err=True syslog.syslog(syslog.LOG_ERR, \"remap register abnormal:{0}\".format(str(e))) if not err: syslog.syslog(syslog.LOG_INFO, \"remap Led registers successfully\") def _board_init(): global BOARD_TPYE global BIT_LINK global BIT_FAULT global BIT_TX global BIT_RX global BIT_SPEED0 global BIT_SPEED1 global EAGLE_CORE global TOTAL_SCAN_BITS global SYNC_S global SYNC_P cmd=\"uname -n\" platform=os.popen(cmd).read() if platform.rstrip()==INV_MAGNOLIA: BOARD_TPYE =\"inventec_d6254qs\" BIT_RX =1<<0 BIT_TX =1<<1 BIT_SPEED1 =1<<4 BIT_LINK =1<<7 fp=open('/usr/share/sonic/device/x86_64-inventec_d6254qs-r0/led_proc_init.soc', \"r\") _remap_registers(fp) elif platform.rstrip()==INV_REDWOOD: BOARD_TPYE =\"inventec_d7032q28b\" BIT_RX =1<<0 BIT_TX =1<<1 BIT_SPEED0 =1<<3 BIT_SPEED1 =1<<4 BIT_FAULT =1<<6 BIT_LINK =1<<7 EAGLE_CORE =[66, 100] fp=open('/usr/share/sonic/device/x86_64-inventec_d7032q28b-r0/led_proc_init.soc', \"r\") _remap_registers(fp) elif platform.rstrip()==INV_CYPRESS: BOARD_TPYE =\"inventec_d7054q28b\" BIT_LINK =1<<0 BIT_FAULT =1<<1 BIT_SPEED0 =1<<2 EAGLE_CORE =[66, 100] elif platform.rstrip()==INV_SEQUOIA: BOARD_TPYE=\"inventec_d7264q28b\" elif platform.rstrip()==INV_MAPLE: BOARD_TPYE=\"inventec_d6556\" fp=open('/usr/share/sonic/device/x86_64-inventec_d6556-r0/led_proc_init.soc', \"r\") _remap_registers(fp) syslog.syslog(syslog.LOG_INFO, \"Found device:{0}\".format(BOARD_TPYE)) exit(0) else: BOARD_TPYE=\"not found\" syslog.syslog(syslog.LOG_ERR, \"Found device:{0}\".format(BOARD_TPYE)) exit(0) syslog.syslog(syslog.LOG_INFO, \"Found device:{0}\".format(BOARD_TPYE)) def _lookup_led_index(p): index=0 if BOARD_TPYE==\"inventec_d6254qs\": if 0 <=p.port_num <=47: index=p.port_num +(p.port_num / 4) p.write2_up=0 elif 48 <=p.port_num <=71: index=p.port_num -48 p.write2_up=1 if p.led_up==0: p.s_addr=p.port_num * 2 elif p.led_up==1: p.s_addr=(p.port_num -36) * 2 elif BOARD_TPYE==\"inventec_d7032q28b\": p.write2_up=0 index=p.port_num if 0 <=p.port_num <=7: p.s_addr=p.port_num * 8 elif 8 <=p.port_num <=23: p.s_addr=(p.port_num -8) * 8 elif 24 <=p.port_num <=31: p.s_addr=(p.port_num -16) * 8 else: p.write2_up=p.led_up for port in PORT_LIST: if p.bcm_id==port.bcm_id: break if p.led_up==port.led_up: index +=1 return PORT_DATA_OFFSET_ADDR +index def _update_port_list(only_update): global PORT_LIST number =0 count =0 content=BCM_SHELL.run(\"ps\") for line in content.split(\"\\n\"): re_obj=re.search(r\"(?P<port_name>(xe|ce)\\d+)\\(\\s*(?P<bcm_id>\\d+)\\)\\s+(?P<link>(up|down|!ena)).+\\s+(?P<speed>\\d+)G\", line) if re_obj is not None: if int(re_obj.group(\"bcm_id\")) not in EAGLE_CORE: if only_update: PORT_LIST[number].link_status=re_obj.group(\"link\") else: port_obj=Port() port_obj.port_num=number port_obj.name=re_obj.group(\"port_name\") port_obj.bcm_id=int(re_obj.group(\"bcm_id\")) port_obj.link_status=re_obj.group(\"link\") port_obj.speed=int(re_obj.group(\"speed\")) PORT_LIST.append(port_obj) number +=1 if not only_update: content=BCM_SHELL.run(\"led status\") for line in content.split(\"\\n\"): re_obj=re.search(r\"(?P<bcm_id>\\d+).+(?P<led_up>\\d)\\:\", line) if re_obj is not None: if int(re_obj.group(\"bcm_id\")) not in EAGLE_CORE: PORT_LIST[count].led_up=int(re_obj.group(\"led_up\")) PORT_LIST[count].led_index=_lookup_led_index(PORT_LIST[count]) count +=1 if number is not count: PORT_LIST=[] syslog.syslog(syslog.LOG_ERR, \"The amount of port is not match\") def sync_bcmsh_socket(): global BCM_SHELL global SHELL_READY waitSyncd =True retryCount =0 while waitSyncd: time.sleep(10) try: BCM_SHELL=bcmshell() BCM_SHELL.run(\"Echo\") waitSyncd=False except Exception, e: print \"{0}, Retry times({1})\".format(str(e),retryCount) retryCount +=1 syslog.syslog(syslog.LOG_INFO, \"bcmshell socket create successfully\") if SHELL_READY is False: SHELL_READY=True return elif SHELL_READY is True: update_led_status() def update_led_status(): led_thread =True reset_sec =2 count_down =0 queue_active =[] port_data =None s_byte =None while led_thread: try: if count_down==0: queue_active=[] _update_port_list(1) for port in PORT_LIST: if port.link_status==\"up\": queue_active.append(port) else: port_data=0 port.write_data_ram(port_data) count_down=reset_sec else: for port in queue_active: port_data=0 if BOARD_TPYE==\"inventec_d6254qs\": s_byte=port.read_data_ram() if s_byte&STATUS_RX: port_data |=BIT_RX if s_byte&STATUS_TX: port_data |=BIT_TX port_data |=BIT_LINK elif BOARD_TPYE==\"inventec_d7032q28b\": s_byte=port.read_data_ram() if s_byte&STATUS_RX: port_data |=BIT_RX if s_byte&STATUS_TX: port_data |=BIT_TX if port.speed==SPEED_100G: port_data |=BIT_SPEED0 port_data |=BIT_SPEED1 elif port.speed==SPEED_40G: port_data |=BIT_SPEED1 elif port.speed==SPEED_25G: port_data |=BIT_SPEED0 else: pass port_data |=BIT_LINK elif BOARD_TPYE==\"inventec_d7054q28b\": if port.speed !=SPEED_100G and port.speed !=SPEED_25G: port_data |=BIT_SPEED0 port.write_data_ram(port_data) time.sleep(0.5) count_down -=1 except Exception, e: syslog.syslog(syslog.LOG_WARNING, \"{0}\".format(str(e))) sync_bcmsh_socket() def debug_print(): for port in PORT_LIST: output=\"\" output +=\"name:{0} | \".format(port.name) output +=\"port_num:{0} | \".format(port.port_num) output +=\"bcm_id:{0} | \".format(port.bcm_id) output +=\"link_status:{0} | \".format(port.link_status) output +=\"speed:{0} | \".format(port.speed) output +=\"led_up:{0} | \".format(port.led_up) output +=\"s_addr:{0} | \".format(port.s_addr) output +=\"write2_up:{0} | \".format(port.write2_up) output +=\"led_index:{0} | \".format(port.led_index) print output if __name__==\"__main__\": syslog.openlog(\"led_proc\", syslog.LOG_PID, facility=syslog.LOG_DAEMON) sync_bcmsh_socket() _board_init() _update_port_list(0) update_led_status() syslog.closelog() ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2018 Inventec, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport time\nimport syslog\nimport re\nfrom sonic_sfp.bcmshell import bcmshell\n\n\n# =====================================================================\n#  global variable init\n# =====================================================================\n# port object\nPORT_LIST               = []\n# object is to execute bcm shell command\nBCM_SHELL   = None\nSHELL_READY = False\n# port status that is auto update by chip in data ram\nSTATUS_RX               = 1<<0\nSTATUS_TX               = 1<<1\n# define data ram address\nPORT_DATA_OFFSET_ADDR   = 0xA0\n# define board type\nINV_MAGNOLIA            = \"SONiC-Inventec-d6254qs\"\nINV_REDWOOD             = \"SONiC-Inventec-d7032-100\"\nINV_CYPRESS             = \"SONiC-Inventec-d7054\"\nINV_MAPLE               = \"SONiC-Inventec-d6556\"\nINV_SEQUOIA             = \"\"\nBOARD_TPYE              = \"\"\nEAGLE_CORE              = []\n# define port data for bit streaming\nBIT_LINK                = None\nBIT_FAULT               = None\nBIT_TX                  = None\nBIT_RX                  = None\nBIT_SPEED0              = None\nBIT_SPEED1              = None\n# define port speed\nSPEED_100G              = 100\nSPEED_40G               = 40\nSPEED_25G               = 25\nSPEED_10G               = 10\n\n\n# =====================================================================\n#  class object\n# =====================================================================\nclass Port():\n\n    port_num        = None\n    name            = None\n    bcm_id          = None\n    led_up          = None\n    s_addr          = None\n    write2_up       = None\n    led_index       = None\n    link_status     = None\n    speed           = None\n\n    def write_data_ram(self, data):\n        BCM_SHELL.cmd(\"setreg CMIC_LEDUP{0}_DATA_RAM({1}) {2}\".format(self.write2_up, self.led_index, data))\n\n    def read_data_ram(self):\n        r_string = BCM_SHELL.run(\"getreg CMIC_LEDUP{0}_DATA_RAM({1})\".format(self.led_up, self.s_addr))\n        for line in r_string.split(\"\\n\"):\n            re_obj = re.search(r\"\\<DATA\\=(?P<data>.+)\\>\", line)\n            if re_obj is not None:\n                #syslog.syslog(syslog.LOG_DEBUG, \"Read Led({0}) data_ram({1}): {2}\".format(self.up, addr, re_obj.group(\"data\")))\n                return int(re_obj.group(\"data\"), 16)\n\n\n\n# =====================================================================\n#  Function\n# =====================================================================\ndef _remap_registers(fp):\n\n    content = fp.readlines()\n    fp.close()\n    err = False\n\n    for line in content:\n        try:\n            BCM_SHELL.cmd(line.rstrip())\n        except Exception, e:\n            err = True\n            syslog.syslog(syslog.LOG_ERR, \"remap register abnormal: {0}\".format(str(e)))\n\n    if not err:\n        syslog.syslog(syslog.LOG_INFO, \"remap Led registers successfully\")\n\n\n\ndef _board_init():\n\n    global BOARD_TPYE\n    global BIT_LINK\n    global BIT_FAULT\n    global BIT_TX\n    global BIT_RX\n    global BIT_SPEED0\n    global BIT_SPEED1\n    global EAGLE_CORE\n    global TOTAL_SCAN_BITS\n    global SYNC_S\n    global SYNC_P\n\n    cmd = \"uname -n\"\n    platform = os.popen(cmd).read()\n\n    if platform.rstrip() == INV_MAGNOLIA:\n        BOARD_TPYE      = \"inventec_d6254qs\"\n        BIT_RX          = 1<<0  #0x01\n        BIT_TX          = 1<<1  #0x02\n        BIT_SPEED1      = 1<<4  #0x10\n        BIT_LINK        = 1<<7  #0x80\n        fp = open('/usr/share/sonic/device/x86_64-inventec_d6254qs-r0/led_proc_init.soc', \"r\")\n        _remap_registers(fp)\n\n    elif platform.rstrip() == INV_REDWOOD:\n        BOARD_TPYE      = \"inventec_d7032q28b\"\n        BIT_RX          = 1<<0  #0x01\n        BIT_TX          = 1<<1  #0x02\n        BIT_SPEED0      = 1<<3  #0x08\n        BIT_SPEED1      = 1<<4  #0x10\n        BIT_FAULT       = 1<<6  #0x40\n        BIT_LINK        = 1<<7  #0x80\n        EAGLE_CORE      = [66, 100]\n        fp = open('/usr/share/sonic/device/x86_64-inventec_d7032q28b-r0/led_proc_init.soc', \"r\")\n        _remap_registers(fp)\n\n    elif platform.rstrip() == INV_CYPRESS:\n        BOARD_TPYE      = \"inventec_d7054q28b\"\n        BIT_LINK        = 1<<0  #0x01\n        BIT_FAULT       = 1<<1  #0x02\n        BIT_SPEED0      = 1<<2  #0x04\n        EAGLE_CORE      = [66, 100]\n\n    elif platform.rstrip() == INV_SEQUOIA:\n        BOARD_TPYE = \"inventec_d7264q28b\"\n\n    elif platform.rstrip() == INV_MAPLE:\n        BOARD_TPYE = \"inventec_d6556\"\n        fp = open('/usr/share/sonic/device/x86_64-inventec_d6556-r0/led_proc_init.soc', \"r\")\n        _remap_registers(fp)\n        #led process: m0 led process that is controlled by linkscan_led_fw.bin and custom_led.bin\n        syslog.syslog(syslog.LOG_INFO, \"Found device: {0}\".format(BOARD_TPYE))\n        exit(0)\n\n    else:\n        BOARD_TPYE = \"not found\"\n        syslog.syslog(syslog.LOG_ERR, \"Found device: {0}\".format(BOARD_TPYE))\n        exit(0)\n\n    syslog.syslog(syslog.LOG_INFO, \"Found device: {0}\".format(BOARD_TPYE))\n\n\n\ndef _lookup_led_index(p):\n\n    index = 0\n    if BOARD_TPYE == \"inventec_d6254qs\":\n        if 0 <= p.port_num <= 47:\n            index = p.port_num + (p.port_num / 4)\n            p.write2_up = 0\n        elif 48 <= p.port_num <= 71:\n            index = p.port_num - 48\n            p.write2_up = 1\n        if p.led_up == 0:\n            p.s_addr = p.port_num * 2\n        elif p.led_up == 1:\n            p.s_addr = (p.port_num - 36) * 2\n\n    elif BOARD_TPYE == \"inventec_d7032q28b\":\n        p.write2_up = 0\n        index = p.port_num\n        if 0 <= p.port_num <= 7:\n            p.s_addr = p.port_num * 8\n        elif 8 <= p.port_num <= 23:\n            p.s_addr = (p.port_num - 8) * 8\n        elif 24 <= p.port_num <= 31:\n            p.s_addr = (p.port_num - 16) * 8\n\n    else:\n        p.write2_up = p.led_up\n        for port in PORT_LIST:\n            if p.bcm_id == port.bcm_id:\n                break\n            if p.led_up == port.led_up:\n                index += 1\n\n    return PORT_DATA_OFFSET_ADDR + index\n\n\ndef _update_port_list(only_update):\n\n    global PORT_LIST\n    number      = 0\n    count       = 0\n\n    content = BCM_SHELL.run(\"ps\")\n    for line in content.split(\"\\n\"):\n        re_obj = re.search(r\"(?P<port_name>(xe|ce)\\d+)\\(\\s*(?P<bcm_id>\\d+)\\)\\s+(?P<link>(up|down|!ena)).+\\s+(?P<speed>\\d+)G\", line)\n        if re_obj is not None:\n            if int(re_obj.group(\"bcm_id\")) not in EAGLE_CORE:\n                if only_update:\n                    PORT_LIST[number].link_status = re_obj.group(\"link\")\n                else:\n                    # create port object while first time\n                    port_obj = Port()\n                    port_obj.port_num = number\n                    port_obj.name = re_obj.group(\"port_name\")\n                    port_obj.bcm_id = int(re_obj.group(\"bcm_id\"))\n                    port_obj.link_status = re_obj.group(\"link\")\n                    port_obj.speed = int(re_obj.group(\"speed\"))\n                    PORT_LIST.append(port_obj)\n                number += 1\n\n    if not only_update:\n        content = BCM_SHELL.run(\"led status\")\n        for line in content.split(\"\\n\"):\n            re_obj = re.search(r\"(?P<bcm_id>\\d+).+(?P<led_up>\\d)\\:\", line)\n            if re_obj is not None:\n                if int(re_obj.group(\"bcm_id\")) not in EAGLE_CORE:\n                    PORT_LIST[count].led_up = int(re_obj.group(\"led_up\"))\n                    PORT_LIST[count].led_index = _lookup_led_index(PORT_LIST[count])\n                    count += 1\n\n        if number is not count:\n            PORT_LIST = []\n            syslog.syslog(syslog.LOG_ERR, \"The amount of port is not match\")\n\n\n\ndef sync_bcmsh_socket():\n\n    global BCM_SHELL\n    global SHELL_READY\n    waitSyncd   = True\n    retryCount  = 0\n\n    while waitSyncd:\n        time.sleep(10)\n        try:\n            BCM_SHELL = bcmshell()\n            BCM_SHELL.run(\"Echo\")\n            waitSyncd = False\n        except Exception, e:\n            print \"{0}, Retry times({1})\".format(str(e),retryCount)\n            #syslog.syslog(syslog.LOG_DEBUG, \"{0}, Retry times({1})\".format(str(e),retryCount))\n            retryCount += 1\n\n    syslog.syslog(syslog.LOG_INFO, \"bcmshell socket create successfully\")\n\n    if SHELL_READY is False:\n        SHELL_READY = True\n        return\n    elif SHELL_READY is True:\n        update_led_status()\n\n\n\ndef update_led_status():\n\n    led_thread      = True  # True/False (gate to turn on/off)\n    reset_sec       = 2\n    count_down      = 0\n    queue_active    = []\n    port_data       = None\n    s_byte          = None\n\n\n    # thread for keeping update port status in data ram\n    while led_thread:\n        try:\n            if count_down == 0:\n                queue_active = []\n                _update_port_list(1)\n                for port in PORT_LIST:\n                    if port.link_status == \"up\":\n                        queue_active.append(port)\n                    else:\n                        port_data = 0\n                        port.write_data_ram(port_data)\n                count_down = reset_sec\n            else:\n                for port in queue_active:\n                    port_data = 0\n\n                    if BOARD_TPYE == \"inventec_d6254qs\":\n                        s_byte = port.read_data_ram()\n                        if s_byte&STATUS_RX:\n                            port_data |= BIT_RX\n                        if s_byte&STATUS_TX:\n                            port_data |= BIT_TX\n                        port_data |= BIT_LINK\n\n                    elif BOARD_TPYE == \"inventec_d7032q28b\":\n                        s_byte = port.read_data_ram()\n                        if s_byte&STATUS_RX:\n                            port_data |= BIT_RX\n                        if s_byte&STATUS_TX:\n                            port_data |= BIT_TX\n                        if port.speed == SPEED_100G:\n                            port_data |= BIT_SPEED0\n                            port_data |= BIT_SPEED1\n                        elif port.speed == SPEED_40G:\n                            port_data |= BIT_SPEED1\n                        elif port.speed == SPEED_25G:\n                            port_data |= BIT_SPEED0\n                        else:\n                            pass\n                        port_data |= BIT_LINK\n\n                    elif BOARD_TPYE == \"inventec_d7054q28b\":\n                        if port.speed != SPEED_100G and port.speed != SPEED_25G:\n                            port_data |= BIT_SPEED0\n\n                    # write data to update data ram for specific port\n                    port.write_data_ram(port_data)\n\n                time.sleep(0.5)\n                count_down -= 1\n\n        except Exception, e:\n            syslog.syslog(syslog.LOG_WARNING, \"{0}\".format(str(e)))\n            sync_bcmsh_socket()\n\n\n\ndef debug_print():\n\n    for port in PORT_LIST:\n        output = \"\"\n        output += \"name:{0} | \".format(port.name)\n        output += \"port_num:{0} | \".format(port.port_num)\n        output += \"bcm_id:{0} | \".format(port.bcm_id)\n        output += \"link_status:{0} | \".format(port.link_status)\n        output += \"speed:{0} | \".format(port.speed)\n        output += \"led_up:{0} | \".format(port.led_up)\n        output += \"s_addr:{0} | \".format(port.s_addr)\n        output += \"write2_up:{0} | \".format(port.write2_up)\n        output += \"led_index:{0} | \".format(port.led_index)\n        print output\n\n\nif __name__ == \"__main__\":\n\n    syslog.openlog(\"led_proc\", syslog.LOG_PID, facility=syslog.LOG_DAEMON)\n\n    sync_bcmsh_socket()\n    _board_init()\n    _update_port_list(0)\n    #debug_print()\n    update_led_status()\n\n    syslog.closelog()\n"}, "/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py": {"changes": [{"diff": "\n \n             # Receive thermaltrip event\n             if event['ACTION'] == 'remove' and event['DEVPATH'] == '/kernel/platform_status/fan':\n-                os.system(\"shutdown -h now\")\n+                subprocess.call([\"shutdown\", \"-h\", \"now\"])\n                 ", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py", "badparts": ["                os.system(\"shutdown -h now\")"], "goodparts": ["                subprocess.call([\"shutdown\", \"-h\", \"now\"])"]}], "source": "\n import os import socket from collections import OrderedDict NETLINK_KOBJECT_UEVENT=15 class KernelEventMonitor(object): def __init__(self): self.received_events=OrderedDict() self.socket=socket.socket(socket.AF_NETLINK, socket.SOCK_DGRAM, NETLINK_KOBJECT_UEVENT) def start(self): self.socket.bind((os.getpid(), -1)) def stop(self): self.socket.close() def __enter__(self): self.start() return self def __exit__(self, exc_type, exc_value, traceback): self.stop() def __iter__(self): while True: for item in monitor.next_events(): yield item def next_events(self): data=self.socket.recv(16384) event={} for item in data.split(b'\\x00'): if not item: if event and event['SEQNUM'] not in self.received_events: self.received_events[event['SEQNUM']]=None if(len(self.received_events) > 100): self.received_events.popitem(last=False) yield event event={} else: try: k, v=item.split(b'=', 1) event[k.decode('ascii')]=v.decode('ascii') except ValueError: pass if __name__=='__main__': with KernelEventMonitor() as monitor: for event in monitor: if event['SUBSYSTEM']=='platform_status': print('subsystem is platform_status') if event['ACTION']=='remove' and event['DEVPATH']=='/kernel/platform_status/fan': os.system(\"shutdown -h now\") ", "sourceWithComments": "#!/usr/bin/env python\n\nimport os\nimport socket\nfrom collections import OrderedDict\n\n# Purpose:  Shutdown DUT upon receiving thermaltrip event from kernel (inv_pthread)\n\nNETLINK_KOBJECT_UEVENT = 15\n\nclass KernelEventMonitor(object):\n\n    def __init__(self):\n        self.received_events = OrderedDict()\n        self.socket = socket.socket(socket.AF_NETLINK, socket.SOCK_DGRAM, NETLINK_KOBJECT_UEVENT)\n\n    def start(self):\n        self.socket.bind((os.getpid(), -1))\n\n    def stop(self):\n        self.socket.close()\n\n    def __enter__(self):\n        self.start()\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.stop()\n\n    def __iter__(self):\n        while True:\n          for item in monitor.next_events():\n              yield item\n\n    def next_events(self):\n        data = self.socket.recv(16384)\n        event = {}\n        for item in data.split(b'\\x00'):\n            if not item:        \n                #check if we have an event and if we already received it\n                if event and event['SEQNUM'] not in self.received_events:\n                    self.received_events[event['SEQNUM']] = None\n                    if (len(self.received_events) > 100):\n                        self.received_events.popitem(last=False)\n                    yield event\n                event = {}\n            else:\n                try:\n                    k, v = item.split(b'=', 1)\n                    event[k.decode('ascii')] = v.decode('ascii')\n                except ValueError:\n                    pass\n\nif __name__ == '__main__':\n    with KernelEventMonitor() as monitor:\n        for event in monitor:\n            if event['SUBSYSTEM'] == 'platform_status':\n                print('subsystem is platform_status')\n\n            # Receive thermaltrip event\n            if event['ACTION'] == 'remove' and event['DEVPATH'] == '/kernel/platform_status/fan':\n                os.system(\"shutdown -h now\")\n                \n\n"}, "/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py": {"changes": [{"diff": "\n     \n     def get_platform(self):\n         if self.platform is None:\n-            self.platform = os.popen(\"uname -n\").read().strip()\n+            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"])\n         return self.platform\n     \n     def get_port_to_bcm_mapping(self)", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py", "badparts": ["            self.platform = os.popen(\"uname -n\").read().strip()"], "goodparts": ["            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"])"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object Auto detecting the transceiver and set the correct if_type value options: -h | --help : this help message -d | --debug : run with debug mode \"\"\" try: import os import commands import sys, getopt import logging import re import time import datetime import syslog from sfputil import SfpUtil from sonic_sfp.bcmshell import bcmshell except ImportError as e: raise ImportError(\"%s -required module not found\" % str(e)) DEBUG=False args=[] INV_REDWOOD_PLATFORM=\"SONiC-Inventec-d7032-100\" INV_CYPRESS_PLATFORM=\"SONiC-Inventec-d7054\" INV_SEQUOIA_PLATFORM=\"SONiC-Inventec-d7264\" INV_MAPLE_PLATFORM=\"SONiC-Inventec-d6556\" INV_MAGNOLIA_PLATFORM=\"SONiC-Inventec-d6254qs\" transceiver_type_dict={ \"FCBG110SD1C03\": \"SR\", \"FCBG110SD1C05\": \"SR\", \"FTLX8571D3BCL\": \"SR\", \"FTLX8574D3BCL\": \"SR\", \"AFBR-709DMZ\": \"SR\", \"AFBR-709SMZ\": \"SR\", \"FTLX8571D3BCV\": \"SR\", \"FTLX1471D3BCL\": \"SR\", \"FTLX1871M3BCL\": \"SR\", \"FTLF8536P4BCL\": \"SR\", \"FCBG125SD1C05\": \"SR\", \"FCBG125SD1C30\": \"SR\", \"FCBG125SD1C03\": \"SR\", \"FCBG410QB1C03-1E\": \"SR4\", \"FCBG4100QB1C030-1E\": \"SR4\", \"885350163\": \"SR4\", \"88535017\": \"SR4\", \"FTL410QE2C\": \"SR4\", \"FTL410QD3C\": \"SR4\", \"FTL410QD2C\": \"SR4\", \"AFBR-79E3PZ\": \"SR4\", \"AFBR-79Q4Z\": \"SR4\", \"FTL4C1QE1C\": \"SR4\", \"FTLC9551REPM\": \"SR4\", \"FTLC1151RDPL\": \"SR4\", \"DAC-010SS-X50\": \"KR\", \"DAC-010QQ-X50\": \"KR4\", \"DAC-040QS-007\": \"KR4\", \"DAC-040QQ-007\": \"KR4\", \"DAC-040QQ-005\": \"KR4\", \"DAC-040QS-005\": \"KR4\", \"NDAAFF-0001\": \"KR4\", \"L0HQF001-SD-R\": \"KR4\", \"DAC-Q28/Q28-28-01\": \"KR4\", \"NDAAFF-0003\": \"KR4\", \"NDAQGF0001\": \"KR4\", \"L0HQF003-SD-R\": \"KR4\", \"NDAQGJ-0003\": \"KR4\", \"L0HQF004-SD-R\": \"KR4\", \"L0HSF006-SD-R\": \"KR\", \"L0HSF007-SD-R\": \"KR\", \"L0HSF008-SD-R\": \"KR\", \"L0HQF009-SD-R\": \"KR4\", \"FSPP-H7-M85-X3D\": \"SR\", \"PT0-M3-4D33K-C2\": \"SR\", \"RTXM228-551\": \"SR\", \"RTXM330-003\": \"SR\", \"RTXM330-030\": \"SR\", \"MFA2P10-A005\": \"SR\", \"QAB-OA03MC\": \"SR4\", \"QAB-OA05MC\": \"SR4\", \"RTXM320-571\": \"SR4\", \"AFBR-89CDDZ\": \"SR4\", \"RTXM420-550\": \"SR4\", \"MMA1B00-C100D\": \"SR4\", \"RTXM420-551\": \"SR4\", \"E04025QTXA000\": \"SR4\", \"LQ210PR-Oxxx\": \"SR4\", \"TR-FC13L-N00\": \"SR4\", \"SPQ-CE-LR-CDFL\": \"SR4\", \"FIM37700/170\": \"SR4\", \"FCBN425QE1C03\": \"SR4\", \"TQS-Q14H8-XCAXX\": \"SR4\", \"FPD-203R008-10/3\": \"SR4\", \"LTA8531-PC+\": \"SR4\" } initial_command=[] def show_help(): print __doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]} sys.exit(0) def log_message( string): syslog.openlog(\"transceiver_monitor\", syslog.LOG_PID, facility=syslog.LOG_DAEMON) syslog.syslog(syslog.LOG_NOTICE, string) class BCMUtil(bcmshell): port_to_bcm_mapping=dict() sal_config_list=dict() eagle_list=[] platform=None def get_platform(self): if self.platform is None: self.platform=os.popen(\"uname -n\").read().strip() return self.platform def get_port_to_bcm_mapping(self): if self.port_to_bcm_mapping is None: return dict() else: return self.port_to_bcm_mapping def show_port_to_bcm_mapping(self): for key,value in self.port_to_bcm_mapping.iteritems(): print \"{0}---{1}\".format(key, value) def get_eagle_port(self): return self.eagle_list def parsing_eagle_port(self): name=self.get_platform() if name is not None: if name==INV_REDWOOD_PLATFORM: self.eagle_list=[66,100] elif name==INV_CYPRESS_PLATFORM: self.eagle_list=[66,100] elif name==INV_SEQUOIA_PLATFORM: self.eagle_list=[66,100] elif name==INV_MAPLE_PLATFORM: self.eagle_list=[66,130] else: self.eagle_list=[] def get_sal_config_list(self): return self.sal_config_list def show_sal_config_list(self): for key,value in self.sal_config_list.iteritems(): print \"{0}---{1}\".format(key, value) def initial_sal_config_list( self): content=self.run(\"config\") for line in content.split(\"\\n\"): ConfigObject=re.search(r\"portmap\\_(?P<bcm_id>\\d+)\\=(?P<lane_id>\\d+)\\:\\d+\",line) if ConfigObject is not None: if int(ConfigObject.group(\"bcm_id\")) not in self.get_eagle_port(): self.get_sal_config_list()[int(ConfigObject.group(\"bcm_id\"))]={\"lane\": int(ConfigObject.group(\"lane_id\")), \"speed\": None, \"portname\": None} def parsing_port_list(self): content=self.run(\"ps\") count=0 for line in content.split(\"\\n\"): PSObject=re.search(r\"(?P<port_name>(xe|ce)\\d+)\\(\\s*(?P<bcm_id>\\d+)\\).+\\s+(?P<speed>\\d+)G\",line) if PSObject is not None: if int(PSObject.group(\"bcm_id\")) not in self.get_eagle_port(): if self.get_sal_config_list().has_key(int(PSObject.group(\"bcm_id\"))): self.get_sal_config_list()[int(PSObject.group(\"bcm_id\"))][\"portname\"]=PSObject.group(\"port_name\") self.get_sal_config_list()[int(PSObject.group(\"bcm_id\"))][\"speed\"]=int(PSObject.group(\"speed\"))*1000 self.port_to_bcm_mapping[count]=int(PSObject.group(\"bcm_id\")) count=count +1 def execute_command(self, cmd): self.cmd(cmd) class TransceiverUtil(SfpUtil): transceiver_port_mapping=dict() def get_transceiver_port_mapping(self): return self.transceiver_port_mapping def show_transceiver_port_mapping(self): for key,value in self.transceiver_port_mapping.iteritems(): print \"{0}---{1}\".format(key, value) def get_bcm_port_name(self, index): if self.transceiver_port_mapping.has_key(index) and bcm_obj.get_sal_config_list().has_key(self.transceiver_port_mapping[index][\"bcm\"]): return bcm_obj.get_sal_config_list()[self.transceiver_port_mapping[index][\"bcm\"]][\"portname\"] else: return \"\" def get_port_to_i2c_mapping(self): if self.port_to_i2c_mapping is None: return dict() else: return self.port_to_i2c_mapping def show_port_to_i2c_mapping(self): for key,value in self.port_to_i2c_mapping.iteritems(): print \"{0}---{1}\".format(key, value) def get_eeprom_partNum(self, portNum): tempdict=dict() tempdict=self.get_eeprom_dict(portNum) self.get_eeprom_partNum_from_parser_eeprom_dict(tempdict) def get_eeprom_dict_info(self, portNum): return self.get_eeprom_dict(portNum) def get_eeprom_partNum_from_parser_eeprom_dict(self, tempdict): if tempdict is not None: if tempdict[\"interface\"][\"data\"].has_key(\"VendorPN\"): return tempdict[\"interface\"][\"data\"][\"VendorPN\"] elif tempdict[\"interface\"][\"data\"].has_key(\"Vendor PN\"): return tempdict[\"interface\"][\"data\"][\"Vendor PN\"] else: return None else: return None def get_transceiver_type(self, pn): if pn is not None: if transceiver_type_dict.has_key(pn.upper()): return transceiver_type_dict[pn.upper()] else: return None def set_transceiver_type( self, portNum, pn): type=self.get_transceiver_type( pn) if type is not None: if bcm_obj.get_platform()==INV_SEQUOIA_PLATFORM or bcm_obj.get_platform()==INV_MAPLE_PLATFORM: speed=bcm_obj.get_sal_config_list()[self.transceiver_port_mapping[portNum][\"bcm\"]][\"speed\"] bcm_obj.execute_command( \"port %s if=%s speed=%d\" %( self.get_bcm_port_name(portNum), type, speed)) else: bcm_obj.execute_command( \"port %s if=%s\" %( self.get_bcm_port_name(portNum), type)) print \"Detecting port{0}({1}) need to change interface type{2}({3})\".format( self.get_bcm_port_name(portNum), portNum, type, self.get_transceiver_port_mapping()[portNum][\"pn\"]) log_message(\"Detecting port{0} need to change interface type{1}({2})\".format(self.get_bcm_port_name(portNum), type, self.get_transceiver_port_mapping()[portNum][\"pn\"])) def initial_transceiver_port_mapping(self): for index in self.get_port_to_i2c_mapping().keys(): if self.transceiver_port_mapping.has_key(index) is False: i2cValue=self.get_port_to_i2c_mapping()[index] bcmValue=bcm_obj.get_port_to_bcm_mapping()[index] self.transceiver_port_mapping[index]={\"i2c\": i2cValue, \"bcm\": bcmValue, \"pn\": None} def set_power_mode_for_QSFP(self): for index in self.get_port_to_i2c_mapping().keys(): if index >=self.qsfp_port_start and index <=self.qsfp_port_end: self.set_low_power_mode(index, False) else: self.set_tx_disable(index) def set_tx_disable(self, port_num): if port_num >=self.qsfp_port_start and port_num <=self.qsfp_port_end: pass else: try: tx_file=open(\"/sys/class/swps/port\"+str(port_num)+\"/tx_disable\", \"r+\") except IOError as e: print \"Error: unable to open file: %s\" % str(e) return False reg_value=int(tx_file.readline().rstrip()) if reg_value==1: reg_value=0 tx_file.write(hex(reg_value)) tx_file.close() def main(): global DEBUG global transceiver_obj global bcm_obj initalNotOK=True retestCount=0 while initalNotOK: try: transceiver_obj=TransceiverUtil() bcm_obj=BCMUtil() initalNotOK=False except Exception, e: log_message(\"Exception. The warning is{0}, Retry again({1})\".format(str(e),retestCount)) retestCount=retestCount +1 time.sleep(5) log_message( \"Object initialed successfully\") options, args=getopt.getopt(sys.argv[1:], 'hd',['help', 'debug' ]) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) else: logging.info(\"no option\") initalNotOK=True while initalNotOK: try: for cmd_index in initial_command: bcm_obj.execute_command(cmd_index) bcm_obj.parsing_eagle_port() bcm_obj.initial_sal_config_list() bcm_obj.parsing_port_list() transceiver_obj.initial_transceiver_port_mapping() initalNotOK=False except Exception, e: log_message(\"Exception. The warning is{0}\".format(str(e))) time.sleep(5) transceiver_obj.set_power_mode_for_QSFP() while 1: try: if bcm_obj.get_platform()==INV_SEQUOIA_PLATFORM: bcm_obj.parsing_port_list() for index in transceiver_obj.get_port_to_i2c_mapping().keys(): info=transceiver_obj.get_eeprom_dict_info(index) value=transceiver_obj.get_eeprom_partNum_from_parser_eeprom_dict(info) if transceiver_obj.get_transceiver_port_mapping().has_key(index) is not False and transceiver_obj.get_transceiver_port_mapping()[index][\"pn\"] <> value: transceiver_obj.get_transceiver_port_mapping()[index][\"pn\"]=value transceiver_obj.set_transceiver_type(index,value) transceiver_obj.set_tx_disable(index) except Exception, e: log_message(\"Exception. The warning is{0}\".format(str(e))) time.sleep(1) syslog.closelog() del transceiver_obj del bcm_obj if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2018 Inventec, Inc.\n# \n# Editor: James Huang ( Huang.James@inventec.com )\n#  \n# \n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\nAuto detecting the transceiver and set the correct if_type value\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n   \n\"\"\"\n\ntry:\n    import os\n    import commands\n    import sys, getopt\n    import logging\n    import re\n    import time\n    import datetime\n    import syslog\n    from sfputil import SfpUtil\n    from sonic_sfp.bcmshell import bcmshell\n    \nexcept ImportError as e:\n    raise ImportError(\"%s - required module not found\" % str(e))\n\nDEBUG = False\nargs = []\nINV_REDWOOD_PLATFORM = \"SONiC-Inventec-d7032-100\"\nINV_CYPRESS_PLATFORM = \"SONiC-Inventec-d7054\"\nINV_SEQUOIA_PLATFORM = \"SONiC-Inventec-d7264\"\nINV_MAPLE_PLATFORM = \"SONiC-Inventec-d6556\"\nINV_MAGNOLIA_PLATFORM = \"SONiC-Inventec-d6254qs\"\n\ntransceiver_type_dict = { \n                          \"FCBG110SD1C03\": \"SR\",\n                          \"FCBG110SD1C05\": \"SR\",\n                          \"FTLX8571D3BCL\": \"SR\",\n                          \"FTLX8574D3BCL\": \"SR\",\n                          \"AFBR-709DMZ\": \"SR\",\n                          \"AFBR-709SMZ\": \"SR\",\n                          \"FTLX8571D3BCV\": \"SR\",\n                          \"FTLX1471D3BCL\": \"SR\",\n                          \"FTLX1871M3BCL\": \"SR\",\n                          \"FTLF8536P4BCL\": \"SR\",\n                          \"FCBG125SD1C05\": \"SR\",\n                          \"FCBG125SD1C30\": \"SR\",\n                          \"FCBG125SD1C03\": \"SR\",\n                          \"FCBG410QB1C03-1E\": \"SR4\",\n                          \"FCBG4100QB1C030-1E\": \"SR4\",\n                          \"885350163\": \"SR4\",\n                          \"88535017\": \"SR4\",\n                          \"FTL410QE2C\": \"SR4\",\n                          \"FTL410QD3C\": \"SR4\",\n                          \"FTL410QD2C\": \"SR4\",\n                          \"AFBR-79E3PZ\": \"SR4\",\n                          \"AFBR-79Q4Z\": \"SR4\",\n                          \"FTL4C1QE1C\": \"SR4\",\n                          \"FTLC9551REPM\": \"SR4\",\n                          \"FTLC1151RDPL\": \"SR4\",\n                          \"DAC-010SS-X50\" : \"KR\",\n                          \"DAC-010QQ-X50\": \"KR4\",\n                          \"DAC-040QS-007\": \"KR4\",\n                          \"DAC-040QQ-007\": \"KR4\",\n                          \"DAC-040QQ-005\": \"KR4\",\n                          \"DAC-040QS-005\": \"KR4\",\n                          \"NDAAFF-0001\": \"KR4\",\n                          \"L0HQF001-SD-R\": \"KR4\",\n                          \"DAC-Q28/Q28-28-01\": \"KR4\",\n                          \"NDAAFF-0003\": \"KR4\",\n                          \"NDAQGF0001\": \"KR4\",\n                          \"L0HQF003-SD-R\": \"KR4\",\n                          \"NDAQGJ-0003\": \"KR4\",\n                          \"L0HQF004-SD-R\": \"KR4\",\n                          \"L0HSF006-SD-R\": \"KR\",\n                          \"L0HSF007-SD-R\": \"KR\",\n                          \"L0HSF008-SD-R\": \"KR\",\n                          \"L0HQF009-SD-R\": \"KR4\",\n                          \"FSPP-H7-M85-X3D\": \"SR\",   \n                          \"PT0-M3-4D33K-C2\": \"SR\",\n                          \"RTXM228-551\": \"SR\",\n                          \"RTXM330-003\": \"SR\",\n                          \"RTXM330-030\": \"SR\",   \n                          \"MFA2P10-A005\": \"SR\",\n                          \"QAB-OA03MC\": \"SR4\",\n                          \"QAB-OA05MC\": \"SR4\",\n                          \"RTXM320-571\": \"SR4\",\n                          \"AFBR-89CDDZ\": \"SR4\",\n                          \"RTXM420-550\": \"SR4\",\n                          \"MMA1B00-C100D\": \"SR4\",\n                          \"RTXM420-551\": \"SR4\",\n                          \"E04025QTXA000\": \"SR4\",\n                          \"LQ210PR-Oxxx\": \"SR4\",\n                          \"TR-FC13L-N00\": \"SR4\",  \n                          \"SPQ-CE-LR-CDFL\": \"SR4\",\n                          \"FIM37700/170\": \"SR4\",\n                          \"FCBN425QE1C03\": \"SR4\",\n                          \"TQS-Q14H8-XCAXX\": \"SR4\",\n                          \"FPD-203R008-10/3\": \"SR4\",\n                          \"LTA8531-PC+\": \"SR4\"                       \n                        }\n \ninitial_command = []\n\ndef show_help():\n    print __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]}\n    sys.exit(0)\n\ndef log_message( string ):\n    syslog.openlog(\"transceiver_monitor\", syslog.LOG_PID, facility=syslog.LOG_DAEMON)\n    syslog.syslog(syslog.LOG_NOTICE, string)\n\nclass BCMUtil(bcmshell):\n\n    port_to_bcm_mapping = dict()         \n    sal_config_list = dict()\n    eagle_list = []\n    platform = None\n    \n    def get_platform(self):\n        if self.platform is None:\n            self.platform = os.popen(\"uname -n\").read().strip()\n        return self.platform\n    \n    def get_port_to_bcm_mapping(self):  \n        if self.port_to_bcm_mapping is None:\n            return dict()\n        else:\n            return self.port_to_bcm_mapping     \n    \n    def show_port_to_bcm_mapping(self): \n        for key,value in self.port_to_bcm_mapping.iteritems():\n            print \"{0}---{1}\".format(key, value)    \n    \n    def get_eagle_port(self):\n        return self.eagle_list\n        \n    def parsing_eagle_port(self):\n        name = self.get_platform()\n        if name is not None:\n            if name == INV_REDWOOD_PLATFORM:\n                self.eagle_list = [66,100]\n            elif name == INV_CYPRESS_PLATFORM:\n                self.eagle_list = [66,100]\n            elif name == INV_SEQUOIA_PLATFORM:\n                self.eagle_list = [66,100]\n            elif name == INV_MAPLE_PLATFORM:\n                self.eagle_list = [66,130]\n            else:\n                self.eagle_list = []\n                \n    def get_sal_config_list(self):\n        return self.sal_config_list\n\n    def show_sal_config_list(self):\n        for key,value in self.sal_config_list.iteritems():\n            print \"{0}---{1}\".format(key, value)\n        \n    def initial_sal_config_list( self ):\n        content = self.run(\"config\")  \n        for line in content.split(\"\\n\"):\n            ConfigObject = re.search(r\"portmap\\_(?P<bcm_id>\\d+)\\=(?P<lane_id>\\d+)\\:\\d+\",line)\n            if ConfigObject is not None:   \n                if int(ConfigObject.group(\"bcm_id\")) not in self.get_eagle_port():\n                    self.get_sal_config_list()[int(ConfigObject.group(\"bcm_id\"))]={\"lane\": int(ConfigObject.group(\"lane_id\")), \"speed\": None, \"portname\": None} \n                \n    def parsing_port_list(self):\n        content = self.run(\"ps\")\n        count = 0\n        for line in content.split(\"\\n\"):\n            PSObject = re.search(r\"(?P<port_name>(xe|ce)\\d+)\\(\\s*(?P<bcm_id>\\d+)\\).+\\s+(?P<speed>\\d+)G\",line)\n            if PSObject is not None:\n                if int(PSObject.group(\"bcm_id\")) not in self.get_eagle_port():                    \n                    if self.get_sal_config_list().has_key(int(PSObject.group(\"bcm_id\"))):\n                        self.get_sal_config_list()[int(PSObject.group(\"bcm_id\"))][\"portname\"] = PSObject.group(\"port_name\")\n                        self.get_sal_config_list()[int(PSObject.group(\"bcm_id\"))][\"speed\"] = int(PSObject.group(\"speed\"))*1000\n                        self.port_to_bcm_mapping[count] = int(PSObject.group(\"bcm_id\"))\n                        count = count +1\n                \n    \n    def execute_command(self, cmd):\n        self.cmd(cmd)\n\nclass TransceiverUtil(SfpUtil):     \n    \n    transceiver_port_mapping = dict()\n    \n    def get_transceiver_port_mapping(self):\n        return self.transceiver_port_mapping\n        \n    def show_transceiver_port_mapping(self):\n        for key,value in self.transceiver_port_mapping.iteritems():\n            print \"{0}---{1}\".format(key, value)     \n       \n    def get_bcm_port_name(self, index):\n        if self.transceiver_port_mapping.has_key(index) and bcm_obj.get_sal_config_list().has_key(self.transceiver_port_mapping[index][\"bcm\"]):\n            return bcm_obj.get_sal_config_list()[self.transceiver_port_mapping[index][\"bcm\"]][\"portname\"]            \n        else:\n            return \"\"\n                \n    def get_port_to_i2c_mapping(self):\n        if self.port_to_i2c_mapping is None:\n            return dict()\n        else:\n            return self.port_to_i2c_mapping\n    \n    def show_port_to_i2c_mapping(self):\n        for key,value in self.port_to_i2c_mapping.iteritems():\n            print \"{0}---{1}\".format(key, value)\n        \n    def get_eeprom_partNum(self, portNum):\n        tempdict = dict()\n        tempdict = self.get_eeprom_dict(portNum)\n        self.get_eeprom_partNum_from_parser_eeprom_dict(tempdict)\n    \n    def get_eeprom_dict_info(self, portNum): \n        return self.get_eeprom_dict(portNum) \n                \n    def get_eeprom_partNum_from_parser_eeprom_dict(self, tempdict ):\n        if tempdict is not None:\n            if tempdict[\"interface\"][\"data\"].has_key(\"VendorPN\"):\n               return tempdict[\"interface\"][\"data\"][\"VendorPN\"]\n            elif tempdict[\"interface\"][\"data\"].has_key(\"Vendor PN\"):\n                return tempdict[\"interface\"][\"data\"][\"Vendor PN\"]\n            else:\n                return None\n        else:\n            return None\n            \n    def get_transceiver_type(self, pn ):\n        if pn is not None:\n            if transceiver_type_dict.has_key(pn.upper()):\n                return transceiver_type_dict[pn.upper()]\n            else:\n                return None    \n\n    def set_transceiver_type( self, portNum, pn ):\n        type = self.get_transceiver_type( pn )\n        if type is not None:             \n            if bcm_obj.get_platform() == INV_SEQUOIA_PLATFORM or bcm_obj.get_platform() == INV_MAPLE_PLATFORM :\n                speed = bcm_obj.get_sal_config_list()[self.transceiver_port_mapping[portNum][\"bcm\"]][\"speed\"]\n                bcm_obj.execute_command( \"port %s if=%s speed=%d\" % ( self.get_bcm_port_name(portNum), type, speed ) )\n            else:\n                bcm_obj.execute_command( \"port %s if=%s\" % ( self.get_bcm_port_name(portNum), type ) )\n            print \"Detecting port {0}({1})  need to change interface type {2} ({3})\".format( self.get_bcm_port_name(portNum), portNum, type, self.get_transceiver_port_mapping()[portNum][\"pn\"])\n            log_message(\"Detecting port {0} need to change interface type {1} ({2})\".format(self.get_bcm_port_name(portNum), type, self.get_transceiver_port_mapping()[portNum][\"pn\"]) )\n    \n    def initial_transceiver_port_mapping(self):\n        for index in self.get_port_to_i2c_mapping().keys():\n            if self.transceiver_port_mapping.has_key(index) is False :\n                i2cValue = self.get_port_to_i2c_mapping()[index]\n                bcmValue = bcm_obj.get_port_to_bcm_mapping()[index]\n                self.transceiver_port_mapping[index]={\"i2c\": i2cValue, \"bcm\": bcmValue , \"pn\": None}\n            \n    def set_power_mode_for_QSFP(self):\n        for index in self.get_port_to_i2c_mapping().keys():\n            if index >= self.qsfp_port_start and index <= self.qsfp_port_end :\n                self.set_low_power_mode(index, False)\n            else:\n                # To set tx_disable\n                self.set_tx_disable(index)\n\n    def set_tx_disable(self, port_num):\n        if port_num >= self.qsfp_port_start and port_num <= self.qsfp_port_end :\n            pass\n        else:\n            try:\n                tx_file = open(\"/sys/class/swps/port\"+str(port_num)+\"/tx_disable\", \"r+\")\n            except IOError as e:\n                print \"Error: unable to open file: %s\" % str(e)\n                return False\n\n            reg_value = int(tx_file.readline().rstrip())\n\n            # always set 0 to tx_disable field\n            if reg_value == 1 :\n                reg_value = 0        \n                tx_file.write(hex(reg_value))\n                tx_file.close()\n\n        \ndef main():\n\n    global DEBUG  \n    global transceiver_obj\n    global bcm_obj\n    \n    initalNotOK = True\n    retestCount = 0 \n    while initalNotOK :\n        try:                \n            transceiver_obj = TransceiverUtil()\n            bcm_obj = BCMUtil()\n            initalNotOK = False\n        except Exception, e:               \n            log_message(\"Exception. The warning is {0}, Retry again ({1})\".format(str(e),retestCount) )                    \n            retestCount = retestCount + 1\n        time.sleep(5)\n     \n    log_message( \"Object initialed successfully\" )  \n    options, args = getopt.getopt(sys.argv[1:], 'hd', ['help',\n                                                       'debug'\n                                                          ])\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):            \n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        else:\n            logging.info(\"no option\")\n    \n    initalNotOK = True\n    while initalNotOK :\n        try :\n            # Before loop, You could execute specific command to initial chip\n            for cmd_index in initial_command :\n                bcm_obj.execute_command(cmd_index)\n            \n            # Initial the sal config list\n            bcm_obj.parsing_eagle_port()\n            bcm_obj.initial_sal_config_list()\n            # bcm_obj.show_sal_config_list()\n            bcm_obj.parsing_port_list()                 \n            #bcm_obj.show_port_to_bcm_mapping()                 \n            #bcm_obj.show_sal_config_list()\n            # transceiver_obj.show_port_to_i2c_mapping()\n            \n            # Initial the transceiver_obj \n            transceiver_obj.initial_transceiver_port_mapping()       \n            # transceiver_obj.show_transceiver_port_mapping()\n             \n            initalNotOK = False\n        except Exception, e:               \n            log_message(\"Exception. The warning is {0}\".format(str(e)) )\n        time.sleep(5)            \n    \n    # Improve the power mode for QSFP ports\n    transceiver_obj.set_power_mode_for_QSFP()\n\n    while 1 :\n        try:\n            if bcm_obj.get_platform() == INV_SEQUOIA_PLATFORM:\n                bcm_obj.parsing_port_list()  \n            for index in transceiver_obj.get_port_to_i2c_mapping().keys():\n                info = transceiver_obj.get_eeprom_dict_info(index)\n                value = transceiver_obj.get_eeprom_partNum_from_parser_eeprom_dict(info)\n                if transceiver_obj.get_transceiver_port_mapping().has_key(index) is not False and transceiver_obj.get_transceiver_port_mapping()[index][\"pn\"] <> value:\n                    transceiver_obj.get_transceiver_port_mapping()[index][\"pn\"] = value\n                    transceiver_obj.set_transceiver_type(index,value) \n                    transceiver_obj.set_tx_disable(index)\n                    #transceiver_obj.show_transceiver_port_mapping()     \n            # transceiver_obj.show_transceiver_port_mapping()       \n        except Exception, e:\n            log_message(\"Exception. The warning is {0}\".format(str(e)) )            \n        time.sleep(1)\n\n    syslog.closelog()\n    del transceiver_obj\n    del bcm_obj\n\nif __name__ == \"__main__\":\n    main()\n\n\n\n\n\n\n\n"}, "/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py": {"changes": [{"diff": "\n         return True\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/dev", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py", "badparts": ["        return os.system(\"docker > /dev/null 2>&1\") == 0"], "goodparts": ["        return subprocess.call([\"docker\"]) == 0"]}]}, "/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py": {"changes": [{"diff": "\n \t      return status\n     for addr_offset in range (0,FAN_NUM):\n         addr=FAN_VPD_ADDR_BASE+addr_offset\n-        cmd = \"i2cdetect -y \"+str(FAN_VPD_CHANNEL)+\" \"+str(addr)+\" \"+str(addr)+\" | grep \"+str(hex(addr)).replace('0x','')\n-        result=os.system(cmd)\n+        cmd1 = [\"i2cdetect\", \"-y\", str(FAN_VPD_CHANNEL), str(addr), str(addr)]\n+        cmd2 = [\"grep\", f'{addr:x}']\n+        result, _ = getstatusoutput_noshell_pipe(cmd1, cmd2)\n         if( result==0 ):\n             cmd=\"echo inv_eeprom \"+str(addr)+\" > /sys/bus/i2c/devices/i2c-\"+FAN_VPD_CHANNEL\n             status, output = exec_cmd(c", "add": 3, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py", "badparts": ["        cmd = \"i2cdetect -y \"+str(FAN_VPD_CHANNEL)+\" \"+str(addr)+\" \"+str(addr)+\" | grep \"+str(hex(addr)).replace('0x','')", "        result=os.system(cmd)"], "goodparts": ["        cmd1 = [\"i2cdetect\", \"-y\", str(FAN_VPD_CHANNEL), str(addr), str(addr)]", "        cmd2 = [\"grep\", f'{addr:x}']", "        result, _ = getstatusoutput_noshell_pipe(cmd1, cmd2)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes \"\"\" import os import commands import sys, getopt import logging import syslog import time DEBUG=False args=[] FORCE=0 FAN_VPD_CHANNEL=1 FAN_VPD_ADDR_BASE=0x52 FAN_NUM=5 RETRY_LIMIT=5 i2c_prefix='/sys/bus/i2c/devices/' if DEBUG==True: print sys.argv[0] print 'ARGV: ', sys.argv[1:] def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print options print args print len(sys.argv) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': install() elif arg=='clean': uninstall() else: show_help() return 0 def show_help(): print __doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]} sys.exit(0) def show_log(txt): if DEBUG==True: print \"[D6332]\"+txt return def exec_cmd(cmd, show): logging.info('Run:'+cmd) status, output=commands.getstatusoutput(cmd) show_log(cmd +\" with result:\" +str(status)) show_log(\" output:\"+output) if status: logging.info('Failed:'+cmd) if show: print('Failed:'+cmd) return status, output def link_dir(prefix,dst): retry=0 ret=False while(ret==False and retry<RETRY_LIMIT): ret=os.path.isdir(prefix) if ret==True: break time.sleep(0.5) retry+=1 if ret==True: dirs=os.listdir(prefix) ret=False for i in dirs: if i.startswith('hwmon'): src=prefix+i os.symlink(src,dst) ret=True break if ret==False: syslog.syslog(syslog.LOG_ERR, \"Can't find proper dir to link under %s\" % prefix) else: syslog.syslog(syslog.LOG_ERR,\"Path %s is not a dir\" % prefix) _path_prefix_list=[ \"/sys/bus/i2c/devices/i2c-pmbus-1/hwmon/\", \"/sys/bus/i2c/devices/i2c-pmbus-2/hwmon/\", \"/sys/devices/platform/coretemp.0/hwmon/\", \"/sys/bus/i2c/devices/i2c-tmp75-1/hwmon/\", \"/sys/bus/i2c/devices/i2c-tmp75-2/hwmon/\", \"/sys/bus/i2c/devices/i2c-tmp75-3/hwmon/\", \"/sys/bus/i2c/devices/i2c-tmp75-4/hwmon/\" ] _path_dst_list=[ \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/psu1\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/psu2\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/coretemp\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_1\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_2\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_3\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_4\", ] instantiate=[ 'echo inv_eeprom 0x55 > /sys/bus/i2c/devices/i2c-0/new_device' ] drivers=[ 'gpio_ich', 'lpc_ich', 'i2c-i801', 'i2c-mux', 'i2c-mux-pca954x', 'i2c-mux-pca9541', 'i2c-dev', 'ucd9000', 'inv_eeprom', 'inv_cpld', 'lm75', 'inv_platform', 'swps'] def system_install(boot_option): global FORCE status, output=exec_cmd(\"rmmod i2c_ismt \", 1) if status: print output if FORCE==0: return status status, output=exec_cmd(\"rmmod i2c-i801 \", 1) if status: print output if FORCE==0: return status status, output=exec_cmd(\"rmmod gpio_ich \", 1) if status: print output if FORCE==0: return status status, output=exec_cmd(\"rmmod lpc_ich \", 1) if status: print output if FORCE==0: return status ''' boot_option: 0 -normal, 1 -fast-reboot''' for i in range(0,len(drivers)): if drivers[i]==\"swps\": if boot_option==1: status, output=exec_cmd(\"modprobe swps io_no_init=1\", 1) else: status, output=exec_cmd(\"modprobe \"+drivers[i], 1) else: status, output=exec_cmd(\"modprobe \"+drivers[i], 1) if status: \t print output \t if FORCE==0: \t return status for i in range(0,len(instantiate)): status, output=exec_cmd(instantiate[i], 1) if status: \t print output \t if FORCE==0: \t return status for addr_offset in range(0,FAN_NUM): addr=FAN_VPD_ADDR_BASE+addr_offset cmd=\"i2cdetect -y \"+str(FAN_VPD_CHANNEL)+\" \"+str(addr)+\" \"+str(addr)+\" | grep \"+str(hex(addr)).replace('0x','') result=os.system(cmd) if( result==0): cmd=\"echo inv_eeprom \"+str(addr)+\" > /sys/bus/i2c/devices/i2c-\"+FAN_VPD_CHANNEL status, output=exec_cmd(cmd,1) if status: print output if FORCE==0: return status for i in range(12,20): cmd=\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-4/i2c-\"+str(i)+\"/new_device\" status, output=exec_cmd(cmd,1) if status: print output if FORCE==0: return status for i in range(20,28): status, output=exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-5/i2c-\"+str(i)+\"/new_device\", 1) if status: print output if FORCE==0: return status for i in range(28,36): status, output=exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-6/i2c-\"+str(i)+\"/new_device\", 1) if status: print output if FORCE==0: return status for i in range(36,44): status, output=exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-7/i2c-\"+str(i)+\"/new_device\", 1) if status: print output if FORCE==0: return status for i in range(0,len(_path_prefix_list)): if( os.path.islink(_path_dst_list[i])): os.unlink(_path_dst_list[i]) syslog.syslog(syslog.LOG_WARNING, \"Path %s exists, remove before link again\" % _path_dst_list[i]) link_dir(_path_prefix_list[i],_path_dst_list[i]) return def system_ready(): if not device_found(): return False return True def install(boot_option=0): ''' boot_option: 0 -normal, 1 -fast-reboot ''' if not device_found(): print \"No device, installing....\" status=system_install(boot_option) if status: if FORCE==0: return status else: print \"D6332 devices detected....\" return def uninstall(): global FORCE for i in range(len(drivers)-1,-1,-1): status, output=exec_cmd(\"rmmod \"+drivers[i], 1) if status: \t print output \t if FORCE==0: \t return status return def device_found(): ret1, log=exec_cmd(\"ls \"+i2c_prefix+\"*0072\", 0) ret2, log=exec_cmd(\"ls \"+i2c_prefix+\"i2c-5\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2017 Inventec, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean \ncommand:\n    install         : install drivers and generate related sysfs nodes\n    clean           : uninstall drivers and remove related sysfs nodes\n\"\"\"\n\nimport os\nimport commands\nimport sys, getopt\nimport logging\nimport syslog\nimport time\n\nDEBUG = False\nargs = []\nFORCE = 0\nFAN_VPD_CHANNEL= 1\nFAN_VPD_ADDR_BASE=0x52\nFAN_NUM=5\nRETRY_LIMIT = 5\ni2c_prefix = '/sys/bus/i2c/devices/'\n\n\nif DEBUG == True:\n    print sys.argv[0]\n    print 'ARGV: ', sys.argv[1:]\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n\n\n    if len(sys.argv)<2:\n        show_help()\n\n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:\n        print options\n        print args\n        print len(sys.argv)\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n            install()\n        elif arg == 'clean':\n            uninstall()\n        else:\n            show_help()\n\n\n    return 0\n\ndef show_help():\n    print __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]}\n    sys.exit(0)\n\ndef show_log(txt):\n    if DEBUG == True:\n        print \"[D6332]\"+txt\n    return\n\ndef exec_cmd(cmd, show):\n    logging.info('Run :'+cmd)\n    status, output = commands.getstatusoutput(cmd)\n    show_log (cmd +\" with result:\" + str(status))\n    show_log (\"      output:\"+output)\n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print('Failed :'+cmd)\n    return  status, output\n\ndef link_dir(prefix,dst):\n    retry=0\n    ret=False\n    while(ret==False and retry<RETRY_LIMIT):\n        ret=os.path.isdir(prefix)\n        if ret==True:\n            break\n        time.sleep(0.5)\n        retry+=1\n\n    if ret==True:\n        dirs=os.listdir(prefix)\n        ret=False\n        for i in dirs:\n            if i.startswith('hwmon'):\n                src=prefix+i\n                os.symlink(src,dst)\n                ret=True\n                break\n        if ret==False:\n            syslog.syslog(syslog.LOG_ERR, \"Can't find proper dir to link under %s\" % prefix)\n    else:\n        syslog.syslog(syslog.LOG_ERR,\"Path %s is not a dir\" % prefix)\n\n_path_prefix_list=[\n    \"/sys/bus/i2c/devices/i2c-pmbus-1/hwmon/\",\n    \"/sys/bus/i2c/devices/i2c-pmbus-2/hwmon/\",\n    \"/sys/devices/platform/coretemp.0/hwmon/\",\n    \"/sys/bus/i2c/devices/i2c-tmp75-1/hwmon/\",\n    \"/sys/bus/i2c/devices/i2c-tmp75-2/hwmon/\",\n    \"/sys/bus/i2c/devices/i2c-tmp75-3/hwmon/\",\n    \"/sys/bus/i2c/devices/i2c-tmp75-4/hwmon/\"\n]\n\n_path_dst_list=[\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/psu1\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/psu2\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/coretemp\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_1\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_2\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_3\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_4\",\n]\n\ninstantiate = [\n'echo inv_eeprom 0x55 > /sys/bus/i2c/devices/i2c-0/new_device'\n#'echo inv_cpld 0x33 > /sys/bus/i2c/devices/i2c-0/i2c-2/new_device',\n#'echo inv_cpld 0x77 > /sys/bus/i2c/devices/i2c-0/i2c-2/new_device'\n]\n\n\ndrivers =[\n#kernel-dirvers\n'gpio_ich',\n'lpc_ich',\n'i2c-i801',\n'i2c-mux',\n'i2c-mux-pca954x',\n'i2c-mux-pca9541',\n'i2c-dev',\n'ucd9000',\n#inv-modules\n'inv_eeprom',\n'inv_cpld',\n'lm75',\n'inv_platform',\n#'monitor',\n'swps']\n\n\n# Modify for fast-reboot\ndef system_install(boot_option):\n    global FORCE\n\n    #remove default drivers to avoid modprobe order conflicts\n    status, output = exec_cmd(\"rmmod i2c_ismt \", 1)\n    if status:\n       print output\n       if FORCE == 0:\n          return status\n\n    status, output = exec_cmd(\"rmmod i2c-i801 \", 1)\n    if status:\n       print output\n       if FORCE == 0:\n          return status\n\n    status, output = exec_cmd(\"rmmod gpio_ich \", 1)\n    if status:\n       print output\n       if FORCE == 0:\n          return status\n\n    status, output = exec_cmd(\"rmmod lpc_ich \", 1)\n    if status:\n       print output\n       if FORCE == 0:\n          return status\n\n    #insert extra module\n    #status, output = exec_cmd(\"insmod /lib/modules/4.9.0-9-2-amd64/kernel/drivers/gpio/gpio-ich.ko gpiobase=0\",1)\n\n    #install drivers\n    ''' boot_option: 0 - normal, 1 - fast-reboot'''\n    for i in range(0,len(drivers)):\n       if drivers[i] == \"swps\":\n           if boot_option == 1:\n               status, output = exec_cmd(\"modprobe swps io_no_init=1\", 1)\n           else:\n               status, output = exec_cmd(\"modprobe \"+drivers[i], 1)\n       else:\n           status, output = exec_cmd(\"modprobe \"+drivers[i], 1)\n\n    if status:\n\t   print output\n\t   if FORCE == 0:\n\t      return status\n\n    #instantiate devices\n    for i in range(0,len(instantiate)):\n       #time.sleep(1)\n       status, output = exec_cmd(instantiate[i], 1)\n    if status:\n\t   print output\n\t   if FORCE == 0:                \n\t      return status\n    for addr_offset in range (0,FAN_NUM):\n        addr=FAN_VPD_ADDR_BASE+addr_offset\n        cmd = \"i2cdetect -y \"+str(FAN_VPD_CHANNEL)+\" \"+str(addr)+\" \"+str(addr)+\" | grep \"+str(hex(addr)).replace('0x','')\n        result=os.system(cmd)\n        if( result==0 ):\n            cmd=\"echo inv_eeprom \"+str(addr)+\" > /sys/bus/i2c/devices/i2c-\"+FAN_VPD_CHANNEL\n            status, output = exec_cmd(cmd,1)\n            if status:\n               print output\n               if FORCE == 0:                \n                  return status\n#\n# INV_FIX-4037\n# It replaces the original sff8436 driver with the optoe driver\n#\n    #optoe map to i2c-bus\\\n    for i in range(12,20):\n        cmd=\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-4/i2c-\"+str(i)+\"/new_device\"\n        status, output =exec_cmd(cmd,1)\n        if status:\n            print output\n            if FORCE == 0:\n                return status\n    for i in range(20,28):\n        status, output =exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-5/i2c-\"+str(i)+\"/new_device\", 1)\n        if status:\n            print output\n            if FORCE == 0:\n                return status\n    for i in range(28,36):\n        status, output =exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-6/i2c-\"+str(i)+\"/new_device\", 1)\n        if status:\n            print output\n            if FORCE == 0:\n                return status\n    for i in range(36,44):\n        status, output =exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-7/i2c-\"+str(i)+\"/new_device\", 1)\n        if status:\n            print output\n            if FORCE == 0:\n                return status\n                \n    #make softlink for device info\n    for i in range(0,len(_path_prefix_list)):\n        if( os.path.islink(_path_dst_list[i]) ):\n            os.unlink(_path_dst_list[i])\n            syslog.syslog(syslog.LOG_WARNING, \"Path %s exists, remove before link again\" % _path_dst_list[i] )\n        link_dir(_path_prefix_list[i],_path_dst_list[i])\n\n    return\n\n\ndef system_ready():\n    if not device_found():\n        return False\n    return True\n\ndef install(boot_option=0):\n    ''' boot_option: 0 - normal, 1 - fast-reboot '''\n    if not device_found():\n        print \"No device, installing....\"\n        status = system_install(boot_option)\n        if status:\n            if FORCE == 0:\n                return status\n    else:\n        print \"D6332 devices detected....\"\n    return\n\ndef uninstall():\n    global FORCE\n    #uninstall drivers\n    for i in range(len(drivers)-1,-1,-1):\n       status, output = exec_cmd(\"rmmod \"+drivers[i], 1)\n    if status:\n\t   print output\n\t   if FORCE == 0:\n\t      return status\n    return\n\ndef device_found():\n    ret1, log = exec_cmd(\"ls \"+i2c_prefix+\"*0072\", 0)\n    ret2, log = exec_cmd(\"ls \"+i2c_prefix+\"i2c-5\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"}, "/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py": {"changes": [{"diff": "\n         return retval\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/d", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py", "badparts": ["        return os.system(\"docker > /dev/null 2>&1\") == 0"], "goodparts": ["        return subprocess.call([\"docker\"]) == 0"]}]}, "/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py": {"changes": [{"diff": "\n \n try:\n     import os\n-    import sys\n+    import subprocess\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472InterfaceId\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py", "badparts": ["    import sys"], "goodparts": ["    import subprocess"]}, {"diff": "\n         return retval\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py", "badparts": ["        return os.system(\"docker > /dev/null 2>&1\") == 0"], "goodparts": ["        return subprocess.call([\"docker\"]) == 0"]}]}, "/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to QSFP sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-inventec_d7054q28b-r0\"\n     HWSKU  = \"INVENTEC-D7054Q28B-S48-Q6\"\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         return \"\"\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}]}}, "msg": "[inventec] Replace os.system and remove subprocess with shell=True (#12108)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\nDependency: [https://github.com/sonic-net/sonic-buildimage/pull/12065](https://github.com/sonic-net/sonic-buildimage/pull/12065)\r\n#### Why I did it\r\n1. `getstatusoutput` is used without a static string and it uses `shell=True`\r\n2. `subprocess()` - when using with `shell=True` is dangerous. Using subprocess function without a static string can lead to command injection.\r\n3. `os` - not secure against maliciously constructed input and dangerous if used to evaluate dynamic content.\r\n#### How I did it\r\n1. use `getstatusoutput` without shell=True\r\n2. `subprocess()` - use `shell=False` instead. use an array string. Ref: [https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation](https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation)\r\n3. `os` - use with `subprocess`"}, "35c4e9912de88dcc821ac5c8aebcc994ddcb9838": {"url": "https://api.github.com/repos/sonic-net/sonic-buildimage/commits/35c4e9912de88dcc821ac5c8aebcc994ddcb9838", "html_url": "https://github.com/sonic-net/sonic-buildimage/commit/35c4e9912de88dcc821ac5c8aebcc994ddcb9838", "sha": "35c4e9912de88dcc821ac5c8aebcc994ddcb9838", "keyword": "command injection malicious", "diff": "diff --git a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py\nindex 56e9d8664a23..12f1cc8ed7b9 100644\n--- a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py\n@@ -37,14 +37,14 @@ def get_pcie_device(self):\n         pciList = []\n         p1 = \"^(\\w+):(\\w+)\\.(\\w)\\s(.*)\\s*\\(*.*\\)*\"\n         p2 = \"^.*:.*:.*:(\\w+)\\s*\\(*.*\\)*\"\n-        command1 = \"sudo lspci\"\n-        command2 = \"sudo lspci -n\"\n+        command1 = [\"sudo\", \"lspci\"]\n+        command2 = [\"sudo\", \"lspci\", \"-n\"]\n         # run command 1\n-        proc1 = subprocess.Popen(command1, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc1 = subprocess.Popen(command1, universal_newlines=True, stdout=subprocess.PIPE)\n         output1 = proc1.stdout.readlines()\n         proc1.communicate()\n         # run command 2\n-        proc2 = subprocess.Popen(command2, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc2 = subprocess.Popen(command2, universal_newlines=True, stdout=subprocess.PIPE)\n         output2 = proc2.stdout.readlines()\n         proc2.communicate()\n \ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py\nindex ea4048e19f6e..18ca047cbab4 100644\n--- a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py\n@@ -10,13 +10,13 @@\n \n try:\n     import time\n-    import subprocess\n     from sonic_platform_base.chassis_base import ChassisBase\n     from sonic_platform.common import Common\n     from sonic_platform.sfp import Sfp\n     from sonic_platform.sfp import PORT_START\n     from sonic_platform.sfp import PORTS_IN_BLOCK\n     from sonic_platform.logger import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -36,17 +36,17 @@ def __init__(self):\n         self.SFP_STATUS_INSERTED = \"1\"\n         self.SFP_STATUS_REMOVED = \"0\"\n         self.port_dict = {}\n-        self.enable_read= \"i2cset -f -y 2 0x35 0x2a 0x01\"\n-        self.disable_read = \"i2cset -f -y 2 0x35 0x2a 0x00\"\n-        self.enable_write = \"i2cset -f -y 2 0x35 0x2b 0x00\"\n-        self.disable_write = \"i2cset -f -y 2 0x35 0x2b 0x01\"\n-        self.enable_erase = \"i2cset -f -y 2 0x35 0x2c 0x01\"\n-        self.disable_erase = \"i2cset -f -y 2 0x35 0x2c 0x00\"\n-        self.read_value = \"i2cget -f -y 2 0x35 0x25\"\n-        self.write_value = \"i2cset -f -y 2 0x35 0x21 0x0a\"\n-        self.set_sys_led_cmd = \"i2cset -f -y 2 0x33 0xb2 \"\n-        self.get_sys_led_cmd = \"i2cget -f -y 2 0x33 0xb2\"\n-        self.led_status = \"red\"\n+        self.enable_read= [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x01\"]\n+        self.disable_read = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x00\"]\n+        self.enable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x00\"]\n+        self.disable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x01\"]\n+        self.enable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x01\"]\n+        self.disable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x00\"]\n+        self.read_value = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x25\"]\n+        self.write_value = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x21\", \"0x0a\"]\n+        self.set_sys_led_cmd = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]\n+        self.get_sys_led_cmd = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]\n+        self.led_status = \"red\" \n         # Initialize SFP list\n         # sfp.py will read eeprom contents and retrive the eeprom data.\n         # It will also provide support sfp controls like reset and setting\n@@ -210,25 +210,25 @@ def get_reboot_cause(self):\n         try:\n             is_power_loss = False\n             # enable read\n-            subprocess.getstatusoutput(self.disable_write)\n-            subprocess.getstatusoutput(self.enable_read)\n-            ret , log = subprocess.getstatusoutput(self.read_value)\n+            getstatusoutput_noshell(self.disable_write)\n+            getstatusoutput_noshell(self.enable_read)\n+            ret , log = getstatusoutput_noshell(self.read_value)\n             if ret == 0 and \"0x0a\" in log:\n                 is_power_loss = True\n \n             # erase i2c and e2\n-            subprocess.getstatusoutput(self.enable_erase)\n+            getstatusoutput_noshell(self.enable_erase)\n             time.sleep(1)\n-            subprocess.getstatusoutput(self.disable_erase)\n+            getstatusoutput_noshell(self.disable_erase)\n             # clear data\n-            subprocess.getstatusoutput(self.enable_write)\n-            subprocess.getstatusoutput(self.disable_read)\n-            subprocess.getstatusoutput(self.disable_write)\n-            subprocess.getstatusoutput(self.enable_read)\n+            getstatusoutput_noshell(self.enable_write)\n+            getstatusoutput_noshell(self.disable_read)\n+            getstatusoutput_noshell(self.disable_write)\n+            getstatusoutput_noshell(self.enable_read)\n             # enable write and set data\n-            subprocess.getstatusoutput(self.enable_write)\n-            subprocess.getstatusoutput(self.disable_read)\n-            subprocess.getstatusoutput(self.write_value)\n+            getstatusoutput_noshell(self.enable_write)\n+            getstatusoutput_noshell(self.disable_read)\n+            getstatusoutput_noshell(self.write_value)\n             if is_power_loss:\n                 return(self.REBOOT_CAUSE_POWER_LOSS, None)\n         except Exception as e:\n@@ -417,7 +417,8 @@ def set_status_led(self, color):\n         if regval is None:\n             print(\"Invaild color input.\")\n             return False\n-        ret , log = subprocess.getstatusoutput(self.set_sys_led_cmd + regval)\n+        cmd = self.set_sys_led_cmd + [regval]\n+        ret, log = getstatusoutput_noshell(cmd)\n         if ret != 0:\n             print(\"Cannot execute %s\" % self.set_sys_led_cmd + regval)\n             return False\n@@ -431,7 +432,7 @@ def get_status_led(self):\n             A string, one of the valid LED color strings which could be vendor\n             specified.\n         \"\"\"\n-        ret , log = subprocess.getstatusoutput(self.get_sys_led_cmd)\n+        ret , log = getstatusoutput_noshell(self.get_sys_led_cmd)\n         if ret != 0:\n             print(\"Cannot execute %s\" % self.get_sys_led_cmd)\n             return False\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py\nindex c1a85f618609..e1bef19c24d7 100644\n--- a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py\n@@ -1,6 +1,6 @@\n import os\n import yaml\n-\n+import subprocess\n from sonic_py_common import device_info\n \n \n@@ -10,13 +10,13 @@ class Common:\n     PMON_PLATFORM_PATH = '/usr/share/sonic/platform/'\n     CONFIG_DIR = 'sonic_platform_config'\n \n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def load_json_file(self, path):\n         \"\"\"\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py\nindex 33ff6ef8b35d..26e83fb1919c 100644\n--- a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py\n@@ -8,10 +8,10 @@\n ########################################################################\n \n try:\n-    import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n     from sonic_platform.regutil import Reg\n     from sonic_platform.logger import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -70,12 +70,12 @@ def install_firmware(self, image_path):\n         \"\"\"\n         try:\n             successtips = \"CPLD Upgrade succeeded!\"\n-            status, output = subprocess.getstatusoutput(\"which firmware_upgrade\")\n+            status, output = getstatusoutput_noshell([\"which\", \"firmware_upgrade\"])\n             if status or len(output) <= 0:\n                 logger.error(\"no upgrade tool.\")\n                 return False\n-            cmdstr = \"%s %s cpld %d cpld\"%(output,image_path,self.slot)\n-            ret, log = subprocess.getstatusoutput(cmdstr)\n+            cmdstr = [output, image_path, \"cpld\", self.slot, \"cpld\"]\n+            ret, log = getstatusoutput_noshell(cmdstr)\n             if ret == 0 and successtips in log:\n                 return True\n             logger.error(\"upgrade failed. ret:%d, log:\\n%s\" % (ret, log))\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py b/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py\nindex 46f3089bbdbf..88453c9e916e 100644\n--- a/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py\n@@ -6,7 +6,6 @@\n #\n #######################################################\n \n-import subprocess\n import time\n import glob\n import re\n@@ -14,6 +13,7 @@\n from rjutil.smbus import SMBus\n import time\n from  functools import wraps\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n def retry(maxretry =6, delay = 0.01):\n@@ -80,13 +80,13 @@ def rji2csetword_python(bus, addr, reg, value):\n \n     @staticmethod\n     def command(cmdstr):\n-        retcode, output = subprocess.getstatusoutput(cmdstr)\n+        retcode, output = getstatusoutput_noshell(cmdstr)\n         return retcode, output\n \n \n     @staticmethod\n     def geti2cword_i2ctool(bus, addr, offset):\n-        command_line = \"i2cget -f -y %d 0x%02x 0x%02x  wp\" % (bus, addr, offset)\n+        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%02x\"%offset, \"wp\"]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n@@ -99,7 +99,7 @@ def geti2cword_i2ctool(bus, addr, offset):\n \n     @staticmethod\n     def seti2cword_i2ctool(bus, addr, offset, val):\n-        command_line = \"i2cset -f -y %d 0x%02x 0x%0x 0x%04x wp\" % (bus, addr, offset, val)\n+        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%0x\"%offset, \"0x%04x\"%val, \"wp\"]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n@@ -111,7 +111,7 @@ def seti2cword_i2ctool(bus, addr, offset, val):\n \n     @staticmethod\n     def rji2cget_i2ctool(bus, devno, address):\n-        command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)\n+        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n@@ -123,8 +123,7 @@ def rji2cget_i2ctool(bus, devno, address):\n \n     @staticmethod\n     def rji2cset_i2ctool(bus, devno, address, byte):\n-        command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (\n-            bus, devno, address, byte)\n+        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address, \"0x%02x\"%byte]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n@@ -166,7 +165,7 @@ def readsysfs(location):\n \n     @staticmethod\n     def getdevmem(addr, digit, mask):\n-        command_line = \"devmem 0x%02x %d\" %(addr, digit)\n+        command_line = [\"devmem\", \"0x%02x\"%addr, str(digit)]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n@@ -179,13 +178,13 @@ def getdevmem(addr, digit, mask):\n \n     @staticmethod\n     def rj_os_system(cmd):\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         return status, output\n \n     @staticmethod\n     def getsdkreg(reg):\n         try:\n-            cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg\n+            cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]\n             ret, result = osutil.rj_os_system(cmd)\n             result_t = result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n             if ret != 0 or \"Error:\" in result_t:\n@@ -203,8 +202,8 @@ def getmactemp():\n             result = {}\n             #waitForDocker()\n             #need to exec twice\n-            osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n-            ret, log = osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n+            osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n+            ret, log = osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n             if ret:\n                 return False, result\n             else:\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py b/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py\nindex 35bca09c0206..c812ba2958ca 100755\n--- a/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py\n@@ -6,7 +6,7 @@\n import subprocess\n import time\n from  ruijieconfig import GLOBALCONFIG, GLOBALINITPARAM, GLOBALINITCOMMAND, MAC_LED_RESET, STARTMODULE, i2ccheck_params\n-\n+from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe\n from  ruijieutil   import rjpciwr\n \n CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])\n@@ -46,7 +46,7 @@ def write_sysfs_value(reg_name, value):\n \n def check_driver():\n     u'''whether there is driver start with rg'''\n-    status, output = log_os_system(\"lsmod | grep rg | wc -l\")\n+    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", \"rg\"], [\"wc\", \"-l\"])\n     #System execution error\n     if status: \n         return False\n@@ -70,61 +70,59 @@ def i2c_getPid(name):\n     return ret\n \n def startAvscontrol():\n-    cmd = \"nohup avscontrol.py start >/dev/null 2>&1 &\"\n+    cmd = [\"avscontrol.py\", \"start\"]\n     rets = i2c_getPid(\"avscontrol.py\")\n     if len(rets) == 0:\n-        os.system(cmd)\n+        subprocess.Popen(cmd)\n \n def startFanctrol():\n     if STARTMODULE['fancontrol'] == 1:\n-        cmd = \"nohup fancontrol.py start >/dev/null 2>&1 &\"\n+        cmd = [\"fancontrol.py\", \"start\"]\n         rets = i2c_getPid(\"fancontrol.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def starthal_fanctrl():\n     if STARTMODULE.get('hal_fanctrl',0) == 1:\n-        cmd = \"nohup hal_fanctrl.py start >/dev/null 2>&1 &\"\n+        cmd = [\"hal_fanctrl.py\", \"start\"]\n         rets = i2c_getPid(\"hal_fanctrl.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def starthal_ledctrl():\n     if STARTMODULE.get('hal_ledctrl',0) == 1:\n-        cmd = \"nohup hal_ledctrl.py start >/dev/null 2>&1 &\"\n+        cmd = [\"hal_ledctrl.py\", \"start\"]\n         rets = i2c_getPid(\"hal_ledctrl.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n-\n+            subprocess.Popen(cmd)\n def startDevmonitor():\n     if STARTMODULE.get('dev_monitor',0) == 1:\n-        cmd = \"nohup dev_monitor.py start >/dev/null 2>&1 &\"\n+        cmd = [\"dev_monitor.py\", \"start\"]\n         rets = i2c_getPid(\"dev_monitor.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n-\n+            subprocess.Popen(cmd)\n def startSlotmonitor():\n     if STARTMODULE.get('slot_monitor',0) == 1:\n-        cmd = \"nohup slot_monitor.py start >/dev/null 2>&1 &\"\n+        cmd = [\"slot_monitor.py\", \"start\"]\n         rets = i2c_getPid(\"slot_monitor.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def stopFanctrol():\n     u'''disable fan timer service'''\n     if STARTMODULE['fancontrol'] == 1:\n         rets = i2c_getPid(\"fancontrol.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def stophal_ledctrl():\n     if STARTMODULE.get('hal_ledctrl',0) == 1:\n         rets = i2c_getPid(\"hal_ledctrl.py\")\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n \n@@ -133,8 +131,8 @@ def stopDevmonitor():\n     if STARTMODULE.get('dev_monitor',0) == 1:\n         rets = i2c_getPid(\"dev_monitor.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def stopSlotmonitor():\n@@ -142,15 +140,16 @@ def stopSlotmonitor():\n     if STARTMODULE.get('slot_monitor',0) == 1:\n         rets = i2c_getPid(\"slot_monitor.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def removeDev(bus, loc):\n-    cmd = \"echo  0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device\" % (loc, bus)\n     devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n     if os.path.exists(devpath):\n-        log_os_system(cmd)\n+        file = \"/sys/bus/i2c/devices/i2c-%d/delete_device\" % bus\n+        with open(file, 'w') as f:\n+            f.write('0x%02x\\n'%str(bus))\n         \n def addDev(name, bus, loc):\n     if name == \"lm75\":\n@@ -163,10 +162,11 @@ def addDev(name, bus, loc):\n         if i % 10 == 0:\n             click.echo(\"%%DEVICE_I2C-INIT: %s not found, wait 0.1 second ! i %d \" % (pdevpath,i))\n             \n-    cmd = \"echo  %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device\" % (name, loc, bus)\n     devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n     if os.path.exists(devpath) == False:\n-        os.system(cmd)\n+        file = \"/sys/bus/i2c/devices/i2c-%d/new_device\" % bus\n+        with open(file, 'w') as f:\n+            f.write('%s 0x%02x\\n' % (name, loc))\n \n def removedevs():\n     devs = GLOBALCONFIG[\"DEVS\"]\n@@ -179,8 +179,7 @@ def adddevs():\n         addDev(devs[dev][\"name\"], devs[dev][\"bus\"] , devs[dev][\"loc\"])\n \n def checksignaldriver(name):\n-    modisexistcmd = \"lsmod | grep %s | wc -l\" % name\n-    status, output = log_os_system(modisexistcmd)\n+    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", name], [\"wc\", \"-l\"])\n     #System execution error\n     if status: \n         return False\n@@ -190,17 +189,17 @@ def checksignaldriver(name):\n         return False\n \n def adddriver(name, delay):\n-    cmd = \"modprobe %s\" % name\n+    cmd = [\"modprobe\", name]\n     if delay != 0:\n         time.sleep(delay)\n     if checksignaldriver(name) != True:\n-        log_os_system(cmd)\n+        getstatusoutput_noshell(cmd)\n \n def removedriver(name, delay):\n     realname = name.lstrip().split(\" \")[0];\n-    cmd = \"rmmod -f %s\" % realname\n+    cmd = [\"rmmod\", \"-f\", realname]\n     if checksignaldriver(realname):\n-        log_os_system(cmd)\n+        getstatusoutput_noshell(cmd)\n \n def removedrivers():\n     u'''remove all drivers'''\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py b/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py\nindex 87fb01e5f6ac..e12bb25d7fb7 100755\n--- a/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py\n@@ -4,6 +4,7 @@\n import os\n import time\n import syslog\n+import subprocess\n from ruijieconfig import MONITOR_CONST, FANCTROLDEBUG, MONITOR_FANS_LED, DEV_LEDS, MONITOR_PSU_STATUS, \\\n         MONITOR_SYS_PSU_LED, MONITOR_DEV_STATUS, MONITOR_FAN_STATUS, MONITOR_DEV_STATUS_DECODE, \\\n         MONITOR_SYS_FAN_LED, MONITOR_SYS_LED, fanloc\n@@ -766,7 +767,7 @@ def checkCrit(self):\n                     self.fanSpeedSetMax()  # fan full speed\n                     self.critnum += 1 # anti-shake\n                     if self.critnum >= MONITOR_CONST.CRITICAL_NUM:\n-                       os.system(\"reboot\")\n+                        subprocess.call([\"reboot\"])\n                     fanwarningdebuglog(DEBUG_FANCONTROL,\"crit\u6b21\u6570:%d\" % self.critnum)\n                 else:\n                     self.critnum = 0\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py b/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py\nindex ff594b72e342..9d1930ec08d1 100755\n--- a/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py\n@@ -11,7 +11,6 @@\n import sys\n import os\n import re\n-import subprocess\n import syslog\n import time\n import binascii\n@@ -20,6 +19,7 @@\n import threading\n import click\n import mmap\n+from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe\n from ruijieconfig import rg_eeprom, FRULISTS, MAC_DEFAULT_PARAM, MAC_AVS_PARAM, FANS_DEF, \\\n         FAN_PROTECT, E2_LOC, E2_PROTECT, RUIJIE_SERVICE_TAG, RUIJIE_DIAG_VERSION, \\\n         STARTMODULE, RUIJIE_CARDID, RUIJIE_PRODUCTNAME, RUIJIE_PART_NUMBER, \\\n@@ -538,8 +538,8 @@ def __new__(cls, *args, **kwargs):\n \n def getSdkReg(reg):\n     try:\n-        cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg\n-        ret, result = rj_os_system(cmd)\n+        cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]\n+        ret, result = getstatusoutput_noshell(cmd)\n         result_t = result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n         if ret != 0 or \"Error:\" in result_t:\n             return False, result\n@@ -632,8 +632,8 @@ def getMacTemp():\n     result = {}\n     #waitForDocker()\n     # exec twice, get the second result\n-    rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n-    ret, log = rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n+    getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n+    ret, log = getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n     if ret:\n         return False, result\n     else:\n@@ -689,21 +689,21 @@ def getMacTemp_sysfs(mactempconf):\n \n def restartDockerService(force=False):\n     container_name = [\"database\",\"snmp\",\"syncd\",\"swss\",\"dhcp_relay\",\"radv\",\"teamd\",\"pmon\"]\n-    ret, status = rj_os_system(\"docker ps\")\n+    ret, status = getstatusoutput_noshell([\"docker\", \"ps\"])\n     if ret == 0 :\n         for tmpname in container_name:\n             if (tmpname not in status):\n                 if (force == True):\n-                    rj_os_system(\"docker restart %s\"%tmpname)\n+                    getstatusoutput_noshell([\"docker\", \"restart\", tmpname])\n                 else:\n-                    rj_os_system(\"systemctl restart %s\"%tmpname)\n+                    getstatusoutput_noshell([\"systemctl\", \"restart\", tmpname])\n \n \n def waitForDhcp(timeout):\n     time_cnt = 0\n     while True:\n         try:\n-            ret, status = rj_os_system(\"systemctl status dhcp_relay.service\")\n+            ret, status = getstatusoutput_noshell([\"systemctl\", \"status\", \"dhcp_relay.service\"])\n             if (ret == 0 and \"running\" in status)  or \"SUCCESS\" in status:\n                 break\n             else:\n@@ -839,8 +839,10 @@ def util_setmac(eth, mac):\n     rulefile = \"/etc/udev/rules.d/70-persistent-net.rules\"\n     if isValidMac(mac) == False:\n         return False, \"MAC invaild\"\n-    cmd = \"ethtool -e %s | grep 0x0010 | awk '{print \\\"0x\\\"$13$12$15$14}'\" % eth\n-    ret, log = rj_os_system(cmd)\n+    cmd1 = [\"ethtool\", \"-e\", eth] \n+    cmd2 = [\"grep\", \"0x0010\"]\n+    cmd3 = [\"awk\", '{print \\\"0x\\\"$13$12$15$14}']\n+    ret, log = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)\n     log_debug(log)\n     magic = \"\"\n     if ret == 0 and len(log):\n@@ -848,23 +850,22 @@ def util_setmac(eth, mac):\n     macs = mac.upper().split(\":\")\n \n     # chage ETH0 to value after setmac\n-    ifconfigcmd = \"ifconfig eth0 hw ether %s\" % mac\n-    log_debug(ifconfigcmd)\n-    ret, status = rj_os_system(ifconfigcmd)\n+    ifconfigcmd = [\"ifconfig\", \"eth0\", \"hw\", \"ether\", mac]\n+    log_debug(' '.join(ifconfigcmd))\n+    ret, status = getstatusoutput_noshell(ifconfigcmd)\n     if ret:\n         raise SETMACException(\"software set  Internet cardMAC error\")\n     index = 0\n     for item in macs:\n-        cmd = \"ethtool -E %s magic %s offset %d value 0x%s\" % (\n-            eth, magic, index, item)\n+        cmd = [\"ethtool\", \"-E\", eht, \"magic\", magic, \"offset\", str(index), \"value\", \"0x\"+item]\n         log_debug(cmd)\n         index += 1\n-        ret, log = rj_os_system(cmd)\n+        ret, log = getstatusoutput_noshell(cmd)\n         if ret != 0:\n             raise SETMACException(\" set hardware Internet card MAC error\")\n     # get value after setting \n-    cmd_t = \"ethtool -e eth0 offset 0 length 6\"\n-    ret, log = rj_os_system(cmd_t)\n+    cmd_t = [\"ethtool\", \"-e\", \"eth0\", \"offset\", \"0\", \"length\", \"6\"]\n+    ret, log = getstatusoutput_noshell(cmd_t)\n     m = re.split(':', log)[-1].strip().upper()\n     mac_result = m.upper().split(\" \")\n \n@@ -979,11 +980,11 @@ def generate_ext(cardid):\n \n \n def rji2cget(bus, devno, address):\n-    command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)\n+    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address)]\n     retrytime = 6\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n         time.sleep(0.1)\n@@ -991,12 +992,11 @@ def rji2cget(bus, devno, address):\n \n \n def rji2cset(bus, devno, address, byte):\n-    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (\n-        bus, devno, address, byte)\n+    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%02x\"%str(byte)]\n     retrytime = 6\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n     return False, ret_t\n@@ -1033,31 +1033,30 @@ def rjpciwr(pcibus , slot ,fn, bar, offset, data):\n     data.close()\n \n def rjsysset(location, value):\n-    command_line = \"echo 0x%02x > %s\" % (value, location)\n     retrytime = 6\n-    ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n-        if ret == 0:\n-            return True, ret_t\n-    return False, ret_t\n+        try:\n+            with open(location, 'w') as f:\n+                f.write('0x%02x\\n'%value)\n+        except (IOError, FileNotFoundError) as e:\n+            return False, str(e)\n+    return True, ''\n \n \n def rji2cgetWord(bus, devno, address):\n-    command_line = \"i2cget -f -y %d 0x%02x 0x%02x w\" % (bus, devno, address)\n+    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"w\"]\n     retrytime = 3\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n     return False, ret_t\n \n \n def rji2csetWord(bus, devno, address, byte):\n-    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%x w\" % (\n-        bus, devno, address, byte)\n-    rj_os_system(command_line)\n+    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%x\"%str(byte), \"w\"]\n+    getstatusoutput_noshell(command_line)\n \n \n def fan_setmac():\n@@ -1264,14 +1263,15 @@ def writeToEEprom(rst_arr):\n     elif dealtype == \"io\":\n         io_wr(E2_PROTECT[\"io_addr\"], E2_PROTECT[\"close\"])\n     # deal last drivers\n-    os.system(\"rmmod at24 \")\n-    os.system(\"modprobe at24 \")\n-    os.system(\"rm -f /var/cache/sonic/decode-syseeprom/syseeprom_cache\")\n+    getstatusoutput_noshell([\"rmmod\", \"at24\"])\n+    getstatusoutput_noshell([\"modprobe\", \"at24\"])\n+    getstatusoutput_noshell([\"rm\", \"-f\", \"/var/cache/sonic/decode-syseeprom/syseeprom_cache\"])\n \n \n def get_local_eth0_mac():\n-    cmd = \"ifconfig eth0 |grep HWaddr\"\n-    print(rj_os_system(cmd))\n+    cmd1 = [\"ifconfig\", \"eth0\"]\n+    cmd2 = [\"grep\", \"HWaddr\"]\n+    print(getstatusoutput_noshell_pipe(cmd1, cmd2))\n \n def getonieversion():\n     if not os.path.isfile('/host/machine.conf'):\n@@ -1348,12 +1348,12 @@ def fac_board_setmac():\n \n def ipmi_set_mac(mac):\n     macs = mac.split(\":\")\n-    cmdinit = \"ipmitool raw 0x0c 0x01 0x01 0xc2 0x00\"\n-    cmdset = \"ipmitool raw 0x0c 0x01 0x01 0x05\"\n+    cmdinit = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0xc2\", \"0x00\"]\n+    cmdset = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0x05\"]\n     for ind in range(len(macs)):\n-        cmdset += \" 0x%02x\" % int(macs[ind], 16)\n-    rj_os_system(cmdinit)\n-    ret, status = rj_os_system(cmdset)\n+        cmdset.append(\"0x%02x\" % int(macs[ind], 16))\n+    getstatusoutput_noshell(cmdinit)\n+    ret, status = getstatusoutput_noshell(cmdset)\n     if ret:\n         RJPRINTERR(\"\\n\\n%s\\n\\n\" % status)\n         return False\n@@ -1393,11 +1393,11 @@ def closeProtocol():\n     log_info(\"disable LLDP\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n-    rj_os_system(\"systemctl stop lldp.service\")\n+    getstatusoutput_noshell([\"systemctl\", \"stop\", \"lldp.service\"])\n     log_info(\"disable lldp service\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n-    rj_os_system(\"systemctl stop bgp.service\")\n+    getstatusoutput_noshell([\"systemctl\", \"stop\", \"bgp.service\"])\n     log_info(\"disable bgp service\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n@@ -1420,8 +1420,8 @@ def checkSdkMem():\n     with open(file_name, \"w\") as f:\n         f.write(file_data)\n     print(\"change SDK memory to 256, reboot required\")\n-    rj_os_system(\"sync\")\n-    rj_os_system(\"reboot\")\n+    getstatusoutput_noshell([\"sync\"])\n+    getstatusoutput_noshell([\"reboot\"])\n \n ##########################################################################\n # receives a character setting\n@@ -1604,25 +1604,22 @@ def getCardId():\n             return item.get('value',None)\n     return None\n \n-# ====================================\n-# execute shell command\n-# ====================================\n-def rj_os_system(cmd):\n-    status, output = subprocess.getstatusoutput(cmd)\n-    return status, output\n \n ###########################################\n # get memory slot and number via DMI command\n ###########################################\n def getsysmeminfo():\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \"|grep -P -A5 \\\"Memory\\s+Device\\\"|grep Size|grep -v Range\"\n+    cmd1 = [log[0].rstrip('\\n')]\n+    cmd2 = [\"grep\", \"-P\", \"-A5\", \"Memory\\s+Device\"]\n+    cmd3 = [\"grep\", \"Size\"]\n+    cmd4 = [\"grep\", \"-v\", \"Range\"]\n     # get total number first\n     result = []\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3, cmd4)\n     if ret1 == 0 and len(log1):\n         log1 = log1.lstrip()\n         arr = log1.split(\"\\n\")\n@@ -1642,15 +1639,16 @@ def getsysmeminfo():\n # return various arrays\n ###########################################\n def getsysmeminfo_detail():\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \" -t 17 | grep  -A21 \\\"Memory Device\\\"\"  # 17\n+    cmd1 = [log[0].rstrip('\\n')] + [\"-t\", \"17\"]\n+    cmd2 = [\"grep\", \"-A21\", \"Memory Device\"]  # 17\n     # get total number\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)\n     if ret1 != 0 or len(log1) <= 0:\n-        return False, \"command execution error[%s]\" % cmd\n+        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)\n     result_t = log1.split(\"--\")\n     mem_rets = []\n     for item in result_t:\n@@ -1669,13 +1667,13 @@ def getsysmeminfo_detail():\n # get BIOS info via DMI command\n ###########################################\n def getDmiSysByType(type_t):\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \" -t %s\" % type_t\n+    cmd = [log[0].rstrip('\\n')] + [\"-t\", str(type_t)]\n     # get total number\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell(cmd)\n     if ret1 != 0 or len(log1) <= 0:\n         return False, \"command execution error[%s]\" % cmd\n     its = log1.replace(\"\\t\", \"\").strip().split(\"\\n\")\n@@ -1742,11 +1740,12 @@ def getusbinfo():\n         return False, \"Err\"\n \n def get_cpu_info():\n-    cmd = \"cat /proc/cpuinfo |grep processor -A18\"  # 17\n+    cmd1 = [\"cat\", \"/proc/cpuinfo\"]\n+    cmd2 = [\"grep\", \"processor\", \"-A18\"]  # 17\n \n-    ret, log1 = rj_os_system(cmd)\n+    ret, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)\n     if ret != 0 or len(log1) <= 0:\n-        return False, \"command execution error[%s]\" % cmd\n+        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)\n     result_t = log1.split(\"--\")\n     mem_rets = []\n     for item in result_t:\n", "message": "", "files": {"/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py": {"changes": [{"diff": "\n         pciList = []\n         p1 = \"^(\\w+):(\\w+)\\.(\\w)\\s(.*)\\s*\\(*.*\\)*\"\n         p2 = \"^.*:.*:.*:(\\w+)\\s*\\(*.*\\)*\"\n-        command1 = \"sudo lspci\"\n-        command2 = \"sudo lspci -n\"\n+        command1 = [\"sudo\", \"lspci\"]\n+        command2 = [\"sudo\", \"lspci\", \"-n\"]\n         # run command 1\n-        proc1 = subprocess.Popen(command1, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc1 = subprocess.Popen(command1, universal_newlines=True, stdout=subprocess.PIPE)\n         output1 = proc1.stdout.readlines()\n         proc1.communicate()\n         # run command 2\n-        proc2 = subprocess.Popen(command2, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc2 = subprocess.Popen(command2, universal_newlines=True, stdout=subprocess.PIPE)\n         output2 = proc2.stdout.readlines()\n         proc2.communicate()\n ", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py", "badparts": ["        command1 = \"sudo lspci\"", "        command2 = \"sudo lspci -n\"", "        proc1 = subprocess.Popen(command1, shell=True, universal_newlines=True, stdout=subprocess.PIPE)", "        proc2 = subprocess.Popen(command2, shell=True, universal_newlines=True, stdout=subprocess.PIPE)"], "goodparts": ["        command1 = [\"sudo\", \"lspci\"]", "        command2 = [\"sudo\", \"lspci\", \"-n\"]", "        proc1 = subprocess.Popen(command1, universal_newlines=True, stdout=subprocess.PIPE)", "        proc2 = subprocess.Popen(command2, universal_newlines=True, stdout=subprocess.PIPE)"]}], "source": "\n import os import yaml import subprocess import re import sys from copy import deepcopy try: from.pcie import PcieBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class PcieUtil(PcieBase): \"\"\"Platform-specific PCIEutil class\"\"\" def __init__(self, path): self.config_path=path def load_config_file(self): config_file=self.config_path +\"/\" +\"pcie.yaml\" try: with open(config_file) as conf_file: self.confInfo=yaml.load(conf_file) except IOError as e: print(\"Error:{}\".format(str(e))) print(\"Not found config file, please add a config file manually, or generate it by running[pcieutil pcie_generate]\") sys.exit() def get_pcie_device(self): pciDict={} pciList=[] p1=\"^(\\w+):(\\w+)\\.(\\w)\\s(.*)\\s*\\(*.*\\)*\" p2=\"^.*:.*:.*:(\\w+)\\s*\\(*.*\\)*\" command1=\"sudo lspci\" command2=\"sudo lspci -n\" proc1=subprocess.Popen(command1, shell=True, universal_newlines=True, stdout=subprocess.PIPE) output1=proc1.stdout.readlines() proc1.communicate() proc2=subprocess.Popen(command2, shell=True, universal_newlines=True, stdout=subprocess.PIPE) output2=proc2.stdout.readlines() proc2.communicate() if proc1.returncode > 0: for line1 in output1: print(line1.strip()) return elif proc2.returncode > 0: for line2 in output2: print(line2.strip()) return else: for(line1, line2) in zip(output1, output2): pciDict.clear() match1=re.search(p1, line1.strip()) match2=re.search(p2, line2.strip()) if match1 and match2: Bus=match1.group(1) Dev=match1.group(2) Fn=match1.group(3) Name=match1.group(4) Id=match2.group(1) pciDict[\"name\"]=Name pciDict[\"bus\"]=Bus pciDict[\"dev\"]=Dev pciDict[\"fn\"]=Fn pciDict[\"id\"]=Id pciList.append(pciDict) pciDict=deepcopy(pciDict) else: print(\"CAN NOT MATCH PCIe DEVICE\") return pciList def check_pcie_sysfs(self, domain=0, bus=0, device=0, func=0): dev_path=os.path.join('/sys/bus/pci/devices', '%04x:%02x:%02x.%d' %(domain, bus, device, func)) if os.path.exists(dev_path): return True return False def get_pcie_check(self): self.load_config_file() for item_conf in self.confInfo: bus_conf=item_conf[\"bus\"] dev_conf=item_conf[\"dev\"] fn_conf=item_conf[\"fn\"] if self.check_pcie_sysfs(bus=int(bus_conf, base=16), device=int(dev_conf, base=16), func=int(fn_conf, base=16)): item_conf[\"result\"]=\"Passed\" else: item_conf[\"result\"]=\"Failed\" return self.confInfo def dump_conf_yaml(self): curInfo=self.get_pcie_device() with open(self.config_path +\"/\" +\"pcie.yaml\", \"w\") as conf_file: yaml.dump(curInfo, conf_file, default_flow_style=False) return ", "sourceWithComments": "# pcie_common.py\n# Common PCIE check interfaces for SONIC\n#\n\nimport os\nimport yaml\nimport subprocess\nimport re\nimport sys\nfrom copy import deepcopy\ntry:\n    from .pcie import PcieBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass PcieUtil(PcieBase):\n    \"\"\"Platform-specific PCIEutil class\"\"\"\n    # got the config file path\n    def __init__(self, path):\n        self.config_path = path\n\n    # load the config file\n    def load_config_file(self):\n        config_file = self.config_path + \"/\" + \"pcie.yaml\"\n        try:\n            with open(config_file) as conf_file:\n                self.confInfo = yaml.load(conf_file)\n        except IOError as e:\n            print(\"Error: {}\".format(str(e)))\n            print(\"Not found config file, please add a config file manually, or generate it by running [pcieutil pcie_generate]\")\n            sys.exit()\n\n    # load current PCIe device\n    def get_pcie_device(self):\n        pciDict = {}\n        pciList = []\n        p1 = \"^(\\w+):(\\w+)\\.(\\w)\\s(.*)\\s*\\(*.*\\)*\"\n        p2 = \"^.*:.*:.*:(\\w+)\\s*\\(*.*\\)*\"\n        command1 = \"sudo lspci\"\n        command2 = \"sudo lspci -n\"\n        # run command 1\n        proc1 = subprocess.Popen(command1, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n        output1 = proc1.stdout.readlines()\n        proc1.communicate()\n        # run command 2\n        proc2 = subprocess.Popen(command2, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n        output2 = proc2.stdout.readlines()\n        proc2.communicate()\n\n        if proc1.returncode > 0:\n            for line1 in output1:\n                print(line1.strip())\n            return\n        elif proc2.returncode > 0:\n            for line2 in output2:\n                print(line2.strip())\n            return\n        else:\n            for (line1, line2) in zip(output1, output2):\n                pciDict.clear()\n                match1 = re.search(p1, line1.strip())\n                match2 = re.search(p2, line2.strip())\n                if match1 and match2:\n                    Bus = match1.group(1)\n                    Dev = match1.group(2)\n                    Fn = match1.group(3)\n                    Name = match1.group(4)\n                    Id = match2.group(1)\n                    pciDict[\"name\"] = Name\n                    pciDict[\"bus\"] = Bus\n                    pciDict[\"dev\"] = Dev\n                    pciDict[\"fn\"] = Fn\n                    pciDict[\"id\"] = Id\n                    pciList.append(pciDict)\n                    pciDict = deepcopy(pciDict)\n                else:\n                    print(\"CAN NOT MATCH PCIe DEVICE\")\n        return pciList\n\n    # check the sysfs tree for each PCIe device\n    def check_pcie_sysfs(self, domain=0, bus=0, device=0, func=0):\n        dev_path = os.path.join('/sys/bus/pci/devices', '%04x:%02x:%02x.%d' % (domain, bus, device, func))\n        if os.path.exists(dev_path):\n            return True\n        return False\n\n    # check the current PCIe device with config file and return the result\n    def get_pcie_check(self):\n        self.load_config_file()\n        for item_conf in self.confInfo:\n            bus_conf = item_conf[\"bus\"]\n            dev_conf = item_conf[\"dev\"]\n            fn_conf = item_conf[\"fn\"]\n            if self.check_pcie_sysfs(bus=int(bus_conf, base=16), device=int(dev_conf, base=16), func=int(fn_conf, base=16)):\n                item_conf[\"result\"] = \"Passed\"\n            else:\n                item_conf[\"result\"] = \"Failed\"\n        return self.confInfo\n\n    # generate the config file with current pci device\n    def dump_conf_yaml(self):\n        curInfo = self.get_pcie_device()\n        with open(self.config_path + \"/\" + \"pcie.yaml\", \"w\") as conf_file:\n            yaml.dump(curInfo, conf_file, default_flow_style=False)\n        return\n\n"}, "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py": {"changes": [{"diff": "\n \n try:\n     import time\n-    import subprocess\n     from sonic_platform_base.chassis_base import ChassisBase\n     from sonic_platform.common import Common\n     from sonic_platform.sfp import Sfp\n     from sonic_platform.sfp import PORT_START\n     from sonic_platform.sfp import PORTS_IN_BLOCK\n     from sonic_platform.logger import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py", "badparts": ["    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         self.SFP_STATUS_INSERTED = \"1\"\n         self.SFP_STATUS_REMOVED = \"0\"\n         self.port_dict = {}\n-        self.enable_read= \"i2cset -f -y 2 0x35 0x2a 0x01\"\n-        self.disable_read = \"i2cset -f -y 2 0x35 0x2a 0x00\"\n-        self.enable_write = \"i2cset -f -y 2 0x35 0x2b 0x00\"\n-        self.disable_write = \"i2cset -f -y 2 0x35 0x2b 0x01\"\n-        self.enable_erase = \"i2cset -f -y 2 0x35 0x2c 0x01\"\n-        self.disable_erase = \"i2cset -f -y 2 0x35 0x2c 0x00\"\n-        self.read_value = \"i2cget -f -y 2 0x35 0x25\"\n-        self.write_value = \"i2cset -f -y 2 0x35 0x21 0x0a\"\n-        self.set_sys_led_cmd = \"i2cset -f -y 2 0x33 0xb2 \"\n-        self.get_sys_led_cmd = \"i2cget -f -y 2 0x33 0xb2\"\n-        self.led_status = \"red\"\n+        self.enable_read= [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x01\"]\n+        self.disable_read = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x00\"]\n+        self.enable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x00\"]\n+        self.disable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x01\"]\n+        self.enable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x01\"]\n+        self.disable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x00\"]\n+        self.read_value = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x25\"]\n+        self.write_value = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x21\", \"0x0a\"]\n+        self.set_sys_led_cmd = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]\n+        self.get_sys_led_cmd = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]\n+        self.led_status = \"red\" \n         # Initialize SFP list\n         # sfp.py will read eeprom contents and retrive the eeprom data.\n         # It will also provide support sfp controls like reset and setting\n", "add": 11, "remove": 11, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py", "badparts": ["        self.enable_read= \"i2cset -f -y 2 0x35 0x2a 0x01\"", "        self.disable_read = \"i2cset -f -y 2 0x35 0x2a 0x00\"", "        self.enable_write = \"i2cset -f -y 2 0x35 0x2b 0x00\"", "        self.disable_write = \"i2cset -f -y 2 0x35 0x2b 0x01\"", "        self.enable_erase = \"i2cset -f -y 2 0x35 0x2c 0x01\"", "        self.disable_erase = \"i2cset -f -y 2 0x35 0x2c 0x00\"", "        self.read_value = \"i2cget -f -y 2 0x35 0x25\"", "        self.write_value = \"i2cset -f -y 2 0x35 0x21 0x0a\"", "        self.set_sys_led_cmd = \"i2cset -f -y 2 0x33 0xb2 \"", "        self.get_sys_led_cmd = \"i2cget -f -y 2 0x33 0xb2\"", "        self.led_status = \"red\""], "goodparts": ["        self.enable_read= [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x01\"]", "        self.disable_read = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x00\"]", "        self.enable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x00\"]", "        self.disable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x01\"]", "        self.enable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x01\"]", "        self.disable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x00\"]", "        self.read_value = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x25\"]", "        self.write_value = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x21\", \"0x0a\"]", "        self.set_sys_led_cmd = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]", "        self.get_sys_led_cmd = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]", "        self.led_status = \"red\" "]}, {"diff": "\n         try:\n             is_power_loss = False\n             # enable read\n-            subprocess.getstatusoutput(self.disable_write)\n-            subprocess.getstatusoutput(self.enable_read)\n-            ret , log = subprocess.getstatusoutput(self.read_value)\n+            getstatusoutput_noshell(self.disable_write)\n+            getstatusoutput_noshell(self.enable_read)\n+            ret , log = getstatusoutput_noshell(self.read_value)\n             if ret == 0 and \"0x0a\" in log:\n                 is_power_loss = True\n \n             # erase i2c and e2\n-            subprocess.getstatusoutput(self.enable_erase)\n+            getstatusoutput_noshell(self.enable_erase)\n             time.sleep(1)\n-            subprocess.getstatusoutput(self.disable_erase)\n+            getstatusoutput_noshell(self.disable_erase)\n             # clear data\n-            subprocess.getstatusoutput(self.enable_write)\n-            subprocess.getstatusoutput(self.disable_read)\n-            subprocess.getstatusoutput(self.disable_write)\n-            subprocess.getstatusoutput(self.enable_read)\n+            getstatusoutput_noshell(self.enable_write)\n+            getstatusoutput_noshell(self.disable_read)\n+            getstatusoutput_noshell(self.disable_write)\n+            getstatusoutput_noshell(self.enable_read)\n             # enable write and set data\n-            subprocess.getstatusoutput(self.enable_write)\n-            subprocess.getstatusoutput(self.disable_read)\n-            subprocess.getstatusoutput(self.write_value)\n+            getstatusoutput_noshell(self.enable_write)\n+            getstatusoutput_noshell(self.disable_read)\n+            getstatusoutput_noshell(self.write_value)\n             if is_power_loss:\n                 return(self.REBOOT_CAUSE_POWER_LOSS, None)\n         except Exception as e:\n", "add": 12, "remove": 12, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py", "badparts": ["            subprocess.getstatusoutput(self.disable_write)", "            subprocess.getstatusoutput(self.enable_read)", "            ret , log = subprocess.getstatusoutput(self.read_value)", "            subprocess.getstatusoutput(self.enable_erase)", "            subprocess.getstatusoutput(self.disable_erase)", "            subprocess.getstatusoutput(self.enable_write)", "            subprocess.getstatusoutput(self.disable_read)", "            subprocess.getstatusoutput(self.disable_write)", "            subprocess.getstatusoutput(self.enable_read)", "            subprocess.getstatusoutput(self.enable_write)", "            subprocess.getstatusoutput(self.disable_read)", "            subprocess.getstatusoutput(self.write_value)"], "goodparts": ["            getstatusoutput_noshell(self.disable_write)", "            getstatusoutput_noshell(self.enable_read)", "            ret , log = getstatusoutput_noshell(self.read_value)", "            getstatusoutput_noshell(self.enable_erase)", "            getstatusoutput_noshell(self.disable_erase)", "            getstatusoutput_noshell(self.enable_write)", "            getstatusoutput_noshell(self.disable_read)", "            getstatusoutput_noshell(self.disable_write)", "            getstatusoutput_noshell(self.enable_read)", "            getstatusoutput_noshell(self.enable_write)", "            getstatusoutput_noshell(self.disable_read)", "            getstatusoutput_noshell(self.write_value)"]}, {"diff": "\n         if regval is None:\n             print(\"Invaild color input.\")\n             return False\n-        ret , log = subprocess.getstatusoutput(self.set_sys_led_cmd + regval)\n+        cmd = self.set_sys_led_cmd + [regval]\n+        ret, log = getstatusoutput_noshell(cmd)\n         if ret != 0:\n             print(\"Cannot execute %s\" % self.set_sys_led_cmd + regval)\n             return False\n", "add": 2, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py", "badparts": ["        ret , log = subprocess.getstatusoutput(self.set_sys_led_cmd + regval)"], "goodparts": ["        cmd = self.set_sys_led_cmd + [regval]", "        ret, log = getstatusoutput_noshell(cmd)"]}, {"diff": "\n             A string, one of the valid LED color strings which could be vendor\n             specified.\n         \"\"\"\n-        ret , log = subprocess.getstatusoutput(self.get_sys_led_cmd)\n+        ret , log = getstatusoutput_noshell(self.get_sys_led_cmd)\n         if ret != 0:\n             print(\"Cannot execute %s\" % self.get_sys_led_cmd)\n             return Fals", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py", "badparts": ["        ret , log = subprocess.getstatusoutput(self.get_sys_led_cmd)"], "goodparts": ["        ret , log = getstatusoutput_noshell(self.get_sys_led_cmd)"]}], "source": "\n try: import time import subprocess from sonic_platform_base.chassis_base import ChassisBase from sonic_platform.common import Common from sonic_platform.sfp import Sfp from sonic_platform.sfp import PORT_START from sonic_platform.sfp import PORTS_IN_BLOCK from sonic_platform.logger import logger except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class Chassis(ChassisBase): \"\"\" Ruijie B6510-48VS8CQ Platform-specific Chassis class \"\"\" def __init__(self): ChassisBase.__init__(self) self.CHASSIS_CONFIG='chassis.json' self.THERMAL_CONFIG='thermal.json' self.SFP_CONFIG='sfp.json' self.PSU_CONFIG='psu.json' self.FAN_CONFIG='fan.json' self.COMPONENT_CONFIG='component.json' self.SFP_STATUS_INSERTED=\"1\" self.SFP_STATUS_REMOVED=\"0\" self.port_dict={} self.enable_read=\"i2cset -f -y 2 0x35 0x2a 0x01\" self.disable_read=\"i2cset -f -y 2 0x35 0x2a 0x00\" self.enable_write=\"i2cset -f -y 2 0x35 0x2b 0x00\" self.disable_write=\"i2cset -f -y 2 0x35 0x2b 0x01\" self.enable_erase=\"i2cset -f -y 2 0x35 0x2c 0x01\" self.disable_erase=\"i2cset -f -y 2 0x35 0x2c 0x00\" self.read_value=\"i2cget -f -y 2 0x35 0x25\" self.write_value=\"i2cset -f -y 2 0x35 0x21 0x0a\" self.set_sys_led_cmd=\"i2cset -f -y 2 0x33 0xb2 \" self.get_sys_led_cmd=\"i2cget -f -y 2 0x33 0xb2\" self.led_status=\"red\" for index in range(PORT_START, PORTS_IN_BLOCK): sfp_node=Sfp(index) self._sfp_list.append(sfp_node) if sfp_node.get_presence(): self.port_dict[index]=self.SFP_STATUS_INSERTED else: self.port_dict[index]=self.SFP_STATUS_REMOVED self._api_common=Common() config_path=self._api_common.get_config_path(self.CHASSIS_CONFIG) self._config=self._api_common.load_json_file(config_path) self.__initialize_eeprom() if self._api_common.is_host(): self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() else: self.__initialize_components() def __initialize_fan(self): from sonic_platform.fan import Fan from sonic_platform.fan_drawer import FanDrawer fan_config_path=self._api_common.get_config_path(self.FAN_CONFIG) self.fan_config=self._api_common.load_json_file(fan_config_path)[\"fans\"] if self.fan_config: drawer_fan_list=[] for index in range(0, len(self.fan_config)): fan=Fan(index, config=self.fan_config[index]) self._fan_list.append(fan) drawer_fan_list.append(fan) fan_drawer=FanDrawer(0, fan_list=drawer_fan_list) self._fan_drawer_list.append(fan_drawer) def __initialize_psu(self): from sonic_platform.psu import Psu psu_config_path=self._api_common.get_config_path(self.PSU_CONFIG) self.psu_config=self._api_common.load_json_file(psu_config_path)[\"psus\"] if self.psu_config: for index in range(0, len(self.psu_config)): psu=Psu(index, config=self.psu_config[index]) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal thermal_config_path=self._api_common.get_config_path(self.THERMAL_CONFIG) self.thermal_config=self._api_common.load_json_file(thermal_config_path)['thermals'] if self.thermal_config: for index in range(0, len(self.thermal_config)): thermal=Thermal(index, config=self.thermal_config[index]) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Eeprom self._eeprom=Eeprom(config=self._config[\"eeprom\"]) def __initialize_components(self): from sonic_platform.component import Component component_config_path=self._api_common.get_config_path(self.COMPONENT_CONFIG) self.component_config=self._api_common.load_json_file(component_config_path)['components'] if self.component_config: for index in range(0, len(self.component_config)): component=Component(index, config=self.component_config[index]) self._component_list.append(component) def _init_standard_config(self, conflist, class_name, objlist): for conf in conflist: obj=globals()[class_name](conf.get(\"name\"), config=conf) objlist.append(obj) def _init_by_hal(self, hal_interface): self.hal_interface=hal_interface self.hal_interface.get_fans() def get_name(self): \"\"\" Retrieves the name of the chassis Returns: string: The name of the chassis \"\"\" return self._eeprom.modelstr() def get_presence(self): \"\"\" Retrieves the presence of the chassis Returns: bool: True if chassis is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the chassis Returns: string: Model/part number of chassis \"\"\" return self._eeprom.part_number_str() def get_serial(self): \"\"\" Retrieves the serial number of the chassis(Service tag) Returns: string: Serial number of chassis \"\"\" return self._eeprom.serial_str() def get_status(self): \"\"\" Retrieves the operational status of the chassis Returns: bool: A boolean value, True if chassis is operating properly False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.base_mac_addr() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.system_eeprom_info() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" try: is_power_loss=False subprocess.getstatusoutput(self.disable_write) subprocess.getstatusoutput(self.enable_read) ret, log=subprocess.getstatusoutput(self.read_value) if ret==0 and \"0x0a\" in log: is_power_loss=True subprocess.getstatusoutput(self.enable_erase) time.sleep(1) subprocess.getstatusoutput(self.disable_erase) subprocess.getstatusoutput(self.enable_write) subprocess.getstatusoutput(self.disable_read) subprocess.getstatusoutput(self.disable_write) subprocess.getstatusoutput(self.enable_read) subprocess.getstatusoutput(self.enable_write) subprocess.getstatusoutput(self.disable_read) subprocess.getstatusoutput(self.write_value) if is_power_loss: return(self.REBOOT_CAUSE_POWER_LOSS, None) except Exception as e: logger.error(str(e)) return(self.REBOOT_CAUSE_NON_HARDWARE, None) def get_change_event(self, timeout=0): \"\"\" Returns a nested dictionary containing all devices which have experienced a change at chassis level Args: timeout: Timeout in milliseconds(optional). If timeout==0, this method will block until a change is detected. Returns: (bool, dict): -True if call successful, False if not; -A nested dictionary where key is a device type, value is a dictionary with key:value pairs in the format of {'device_id':'device_event'}, where device_id is the device ID for this device and device_event, status='1' represents device inserted, status='0' represents device removed. Ex.{'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}} indicates that fan 0 has been removed, fan 2 has been inserted and sfp 11 has been removed. Specifically for SFP event, besides SFP plug in and plug out, there are some other error event could be raised from SFP, when these error happened, SFP eeprom will not be avalaible, XCVRD shall stop to read eeprom before SFP recovered from error status. status='2' I2C bus stuck, status='3' Bad eeprom, status='4' Unsupported cable, status='5' High Temperature, status='6' Bad cable. \"\"\" change_event_dict={\"fan\":{}, \"sfp\":{}} sfp_status, sfp_change_dict=self.get_transceiver_change_event(timeout) change_event_dict[\"sfp\"]=sfp_change_dict if sfp_status is True: return True, change_event_dict return False,{} def get_transceiver_change_event(self, timeout=0): start_time=time.time() currernt_port_dict={} forever=False if timeout==0: forever=True elif timeout > 0: timeout=timeout / float(1000) else: print(\"get_transceiver_change_event:Invalid timeout value\", timeout) return False,{} end_time=start_time +timeout if start_time > end_time: print( \"get_transceiver_change_event:\" \"time wrap / invalid timeout value\", timeout, ) return False,{} while timeout >=0: for index in range(PORT_START, PORTS_IN_BLOCK): if self._sfp_list[index].get_presence(): currernt_port_dict[index]=self.SFP_STATUS_INSERTED else: currernt_port_dict[index]=self.SFP_STATUS_REMOVED if currernt_port_dict==self.port_dict: if forever: time.sleep(1) else: timeout=end_time -time.time() if timeout >=1: time.sleep(1) else: if timeout > 0: time.sleep(timeout) return True,{} else: self.port_dict=currernt_port_dict print(self.port_dict) return True, self.port_dict print(\"get_transceiver_change_event: Should not reach here.\") return False,{} def get_all_components(self): return self._component_list def get_all_fans(self): return self._fan_list def get_all_psus(self): return self._psu_list def get_all_thermals(self): return self._thermal_list def get_supervisor_slot(self): \"\"\" Retrieves the physical-slot of the supervisor-module in the modular chassis. On the supervisor or line-card modules, it will return the physical-slot of the supervisor-module. On the fixed-platforms, the API can be ignored. Users of the API can catch the exception and return a default ModuleBase.MODULE_INVALID_SLOT and bypass code for fixed-platforms. Returns: An integer, the vendor specific physical slot identifier of the supervisor module in the modular-chassis. \"\"\" return 0 def get_my_slot(self): \"\"\" Retrieves the physical-slot of this module in the modular chassis. On the supervisor, it will return the physical-slot of the supervisor module. On the linecard, it will return the physical-slot of the linecard module where this instance of SONiC is running. On the fixed-platforms, the API can be ignored. Users of the API can catch the exception and return a default ModuleBase.MODULE_INVALID_SLOT and bypass code for fixed-platforms. Returns: An integer, the vendor specific physical slot identifier of this module in the modular-chassis. \"\"\" return 0 def is_modular_chassis(self): \"\"\" Retrieves whether the sonic instance is part of modular chassis Returns: A bool value, should return False by default or for fixed-platforms. Should return True for supervisor-cards, line-cards etc running as part of modular-chassis. \"\"\" return True def init_midplane_switch(self): \"\"\" Initializes the midplane functionality of the modular chassis. For example, any validation of midplane, populating any lookup tables etc can be done here. The expectation is that the required kernel modules, ip-address assignment etc are done before the pmon, database dockers are up. Returns: A bool value, should return True if the midplane initialized successfully. \"\"\" return True def get_module_index(self, module_name): \"\"\" Retrieves module index from the module name Args: module_name: A string, prefixed by SUPERVISOR, LINE-CARD or FABRIC-CARD Ex. SUPERVISOR0, LINE-CARD1, FABRIC-CARD5 Returns: An integer, the index of the ModuleBase object in the module_list \"\"\" return 0 def set_status_led(self, color): \"\"\" Sets the state of the system LED Args: color: A string representing the color with which to set the system LED Returns: bool: True if system LED state is set successfully, False if not \"\"\" colors={ \"amber\": \"0x00\", \"red\": \"0x02\", \"green\": \"0x04\" } regval=colors.get(color, None) if regval is None: print(\"Invaild color input.\") return False ret, log=subprocess.getstatusoutput(self.set_sys_led_cmd +regval) if ret !=0: print(\"Cannot execute %s\" % self.set_sys_led_cmd +regval) return False self.led_status=color return True def get_status_led(self): \"\"\" Gets the state of the system LED Returns: A string, one of the valid LED color strings which could be vendor specified. \"\"\" ret, log=subprocess.getstatusoutput(self.get_sys_led_cmd) if ret !=0: print(\"Cannot execute %s\" % self.get_sys_led_cmd) return False colors={ \"0x00\": \"amber\", \"0x02\": \"red\", \"0x04\": \"green\" } color=colors.get(log, None) if color is None: return \"Unknown color status\" self.led_status=color return self.led_status ", "sourceWithComments": "# -*- coding: utf-8 -*-\n\n#############################################################################\n# Ruijie B6510-48VS8CQ\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the platform information\n#\n#############################################################################\n\ntry:\n    import time\n    import subprocess\n    from sonic_platform_base.chassis_base import ChassisBase\n    from sonic_platform.common import Common\n    from sonic_platform.sfp import Sfp\n    from sonic_platform.sfp import PORT_START\n    from sonic_platform.sfp import PORTS_IN_BLOCK\n    from sonic_platform.logger import logger\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nclass Chassis(ChassisBase):\n    \"\"\"\n    Ruijie B6510-48VS8CQ Platform-specific Chassis class\n    \"\"\"\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self.CHASSIS_CONFIG = 'chassis.json'\n        self.THERMAL_CONFIG = 'thermal.json'\n        self.SFP_CONFIG = 'sfp.json'\n        self.PSU_CONFIG = 'psu.json'\n        self.FAN_CONFIG = 'fan.json'\n        self.COMPONENT_CONFIG = 'component.json'\n\n        self.SFP_STATUS_INSERTED = \"1\"\n        self.SFP_STATUS_REMOVED = \"0\"\n        self.port_dict = {}\n        self.enable_read= \"i2cset -f -y 2 0x35 0x2a 0x01\"\n        self.disable_read = \"i2cset -f -y 2 0x35 0x2a 0x00\"\n        self.enable_write = \"i2cset -f -y 2 0x35 0x2b 0x00\"\n        self.disable_write = \"i2cset -f -y 2 0x35 0x2b 0x01\"\n        self.enable_erase = \"i2cset -f -y 2 0x35 0x2c 0x01\"\n        self.disable_erase = \"i2cset -f -y 2 0x35 0x2c 0x00\"\n        self.read_value = \"i2cget -f -y 2 0x35 0x25\"\n        self.write_value = \"i2cset -f -y 2 0x35 0x21 0x0a\"\n        self.set_sys_led_cmd = \"i2cset -f -y 2 0x33 0xb2 \"\n        self.get_sys_led_cmd = \"i2cget -f -y 2 0x33 0xb2\"\n        self.led_status = \"red\"\n        # Initialize SFP list\n        # sfp.py will read eeprom contents and retrive the eeprom data.\n        # It will also provide support sfp controls like reset and setting\n        # low power mode.\n        # We pass the eeprom path and sfp control path from chassis.py\n        # So that sfp.py implementation can be generic to all platforms\n        for index in range(PORT_START, PORTS_IN_BLOCK):\n            sfp_node = Sfp(index)\n            self._sfp_list.append(sfp_node)\n            if sfp_node.get_presence():\n                self.port_dict[index] = self.SFP_STATUS_INSERTED\n            else:\n                self.port_dict[index] = self.SFP_STATUS_REMOVED\n\n        self._api_common = Common()\n        config_path = self._api_common.get_config_path(self.CHASSIS_CONFIG)\n        self._config = self._api_common.load_json_file(config_path)\n        self.__initialize_eeprom()\n\n        if self._api_common.is_host():\n            self.__initialize_fan()\n            self.__initialize_psu()\n            self.__initialize_thermals()\n        else:\n            self.__initialize_components()\n\n    def __initialize_fan(self):\n        from sonic_platform.fan import Fan\n        from sonic_platform.fan_drawer import FanDrawer\n\n        fan_config_path = self._api_common.get_config_path(self.FAN_CONFIG)\n        self.fan_config = self._api_common.load_json_file(fan_config_path)[\"fans\"]\n\n        if self.fan_config:\n            drawer_fan_list = []\n            for index in range(0, len(self.fan_config)):\n                fan = Fan(index, config=self.fan_config[index])\n                self._fan_list.append(fan)\n                drawer_fan_list.append(fan)\n            fan_drawer = FanDrawer(0, fan_list=drawer_fan_list)\n            self._fan_drawer_list.append(fan_drawer)\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n\n        psu_config_path = self._api_common.get_config_path(self.PSU_CONFIG)\n        self.psu_config = self._api_common.load_json_file(psu_config_path)[\"psus\"]\n\n        if self.psu_config:\n            for index in range(0, len(self.psu_config)):\n                psu = Psu(index, config=self.psu_config[index])\n                self._psu_list.append(psu)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n\n        thermal_config_path = self._api_common.get_config_path(self.THERMAL_CONFIG)\n        self.thermal_config = self._api_common.load_json_file(thermal_config_path)['thermals']\n\n        if self.thermal_config:\n            for index in range(0, len(self.thermal_config)):\n                thermal = Thermal(index, config=self.thermal_config[index])\n                self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Eeprom\n        self._eeprom = Eeprom(config=self._config[\"eeprom\"])\n\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n\n        component_config_path = self._api_common.get_config_path(self.COMPONENT_CONFIG)\n        self.component_config = self._api_common.load_json_file(component_config_path)['components']\n\n        if self.component_config:\n            for index in range(0, len(self.component_config)):\n                component = Component(index, config=self.component_config[index])\n                self._component_list.append(component)\n\n    def _init_standard_config(self, conflist, class_name, objlist):\n        for conf in conflist:\n            obj = globals()[class_name](conf.get(\"name\"), config=conf)\n            objlist.append(obj)\n\n    def _init_by_hal(self, hal_interface):\n        self.hal_interface = hal_interface\n        self.hal_interface.get_fans()\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the chassis\n        Returns:\n            string: The name of the chassis\n        \"\"\"\n        return self._eeprom.modelstr()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the chassis\n        Returns:\n            bool: True if chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the chassis\n        Returns:\n            string: Model/part number of chassis\n        \"\"\"\n        return self._eeprom.part_number_str()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the chassis (Service tag)\n        Returns:\n            string: Serial number of chassis\n        \"\"\"\n        return self._eeprom.serial_str()\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the chassis\n        Returns:\n            bool: A boolean value, True if chassis is operating properly\n            False if not\n        \"\"\"\n        return True\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.base_mac_addr()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.system_eeprom_info()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        try:\n            is_power_loss = False\n            # enable read\n            subprocess.getstatusoutput(self.disable_write)\n            subprocess.getstatusoutput(self.enable_read)\n            ret , log = subprocess.getstatusoutput(self.read_value)\n            if ret == 0 and \"0x0a\" in log:\n                is_power_loss = True\n\n            # erase i2c and e2\n            subprocess.getstatusoutput(self.enable_erase)\n            time.sleep(1)\n            subprocess.getstatusoutput(self.disable_erase)\n            # clear data\n            subprocess.getstatusoutput(self.enable_write)\n            subprocess.getstatusoutput(self.disable_read)\n            subprocess.getstatusoutput(self.disable_write)\n            subprocess.getstatusoutput(self.enable_read)\n            # enable write and set data\n            subprocess.getstatusoutput(self.enable_write)\n            subprocess.getstatusoutput(self.disable_read)\n            subprocess.getstatusoutput(self.write_value)\n            if is_power_loss:\n                return(self.REBOOT_CAUSE_POWER_LOSS, None)\n        except Exception as e:\n            logger.error(str(e))\n\n        return (self.REBOOT_CAUSE_NON_HARDWARE, None)\n\n    def get_change_event(self, timeout=0):\n        \"\"\"\n        Returns a nested dictionary containing all devices which have\n        experienced a change at chassis level\n\n        Args:\n            timeout: Timeout in milliseconds (optional). If timeout == 0,\n                this method will block until a change is detected.\n\n        Returns:\n            (bool, dict):\n                - True if call successful, False if not;\n                - A nested dictionary where key is a device type,\n                  value is a dictionary with key:value pairs in the format of\n                  {'device_id':'device_event'},\n                  where device_id is the device ID for this device and\n                        device_event,\n                             status='1' represents device inserted,\n                             status='0' represents device removed.\n                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}\n                      indicates that fan 0 has been removed, fan 2\n                      has been inserted and sfp 11 has been removed.\n                  Specifically for SFP event, besides SFP plug in and plug out,\n                  there are some other error event could be raised from SFP, when\n                  these error happened, SFP eeprom will not be avalaible, XCVRD shall\n                  stop to read eeprom before SFP recovered from error status.\n                      status='2' I2C bus stuck,\n                      status='3' Bad eeprom,\n                      status='4' Unsupported cable,\n                      status='5' High Temperature,\n                      status='6' Bad cable.\n        \"\"\"\n        change_event_dict = {\"fan\": {}, \"sfp\": {}}\n        sfp_status, sfp_change_dict = self.get_transceiver_change_event(timeout)\n        change_event_dict[\"sfp\"] = sfp_change_dict\n        if sfp_status is True:\n            return True, change_event_dict\n\n        return False, {}\n\n    def get_transceiver_change_event(self, timeout=0):\n\n        start_time = time.time()\n        currernt_port_dict = {}\n        forever = False\n\n        if timeout == 0:\n            forever = True\n        elif timeout > 0:\n            timeout = timeout / float(1000)  # Convert to secs\n        else:\n            print(\"get_transceiver_change_event:Invalid timeout value\", timeout)\n            return False, {}\n\n        end_time = start_time + timeout\n        if start_time > end_time:\n            print(\n                \"get_transceiver_change_event:\" \"time wrap / invalid timeout value\",\n                timeout,\n            )\n            return False, {}  # Time wrap or possibly incorrect timeout\n\n        while timeout >= 0:\n            # Check for OIR events and return updated port_dict\n            for index in range(PORT_START, PORTS_IN_BLOCK):\n                if self._sfp_list[index].get_presence():\n                    currernt_port_dict[index] = self.SFP_STATUS_INSERTED\n                else:\n                    currernt_port_dict[index] = self.SFP_STATUS_REMOVED\n            if currernt_port_dict == self.port_dict:\n                if forever:\n                    time.sleep(1)\n                else:\n                    timeout = end_time - time.time()\n                    if timeout >= 1:\n                        time.sleep(1)  # We poll at 1 second granularity\n                    else:\n                        if timeout > 0:\n                            time.sleep(timeout)\n                        return True, {}\n            else:\n                # Update reg value\n                self.port_dict = currernt_port_dict\n                print(self.port_dict)\n                return True, self.port_dict\n        print(\"get_transceiver_change_event: Should not reach here.\")\n        return False, {}\n\n    def get_all_components(self):\n        return self._component_list\n\n    def get_all_fans(self):\n        return self._fan_list\n\n    def get_all_psus(self):\n        return self._psu_list\n\n    def get_all_thermals(self):\n        return self._thermal_list\n\n    def get_supervisor_slot(self):\n        \"\"\"\n        Retrieves the physical-slot of the supervisor-module in the modular\n        chassis. On the supervisor or line-card modules, it will return the\n        physical-slot of the supervisor-module.\n        On the fixed-platforms, the API can be ignored.\n        Users of the API can catch the exception and return a default\n        ModuleBase.MODULE_INVALID_SLOT and bypass code for fixed-platforms.\n        Returns:\n            An integer, the vendor specific physical slot identifier of the\n            supervisor module in the modular-chassis.\n        \"\"\"\n        return 0\n\n    def get_my_slot(self):\n        \"\"\"\n        Retrieves the physical-slot of this module in the modular chassis.\n        On the supervisor, it will return the physical-slot of the supervisor\n        module. On the linecard, it will return the physical-slot of the\n        linecard module where this instance of SONiC is running.\n        On the fixed-platforms, the API can be ignored.\n        Users of the API can catch the exception and return a default\n        ModuleBase.MODULE_INVALID_SLOT and bypass code for fixed-platforms.\n        Returns:\n            An integer, the vendor specific physical slot identifier of this\n            module in the modular-chassis.\n        \"\"\"\n        return 0\n\n    def is_modular_chassis(self):\n        \"\"\"\n        Retrieves whether the sonic instance is part of modular chassis\n        Returns:\n            A bool value, should return False by default or for fixed-platforms.\n            Should return True for supervisor-cards, line-cards etc running as part\n            of modular-chassis.\n        \"\"\"\n        return True\n\n    def init_midplane_switch(self):\n        \"\"\"\n        Initializes the midplane functionality of the modular chassis. For\n        example, any validation of midplane, populating any lookup tables etc\n        can be done here. The expectation is that the required kernel modules,\n        ip-address assignment etc are done before the pmon, database dockers\n        are up.\n        Returns:\n            A bool value, should return True if the midplane initialized\n            successfully.\n        \"\"\"\n        return True\n\n    def get_module_index(self, module_name):\n        \"\"\"\n        Retrieves module index from the module name\n        Args:\n            module_name: A string, prefixed by SUPERVISOR, LINE-CARD or FABRIC-CARD\n            Ex. SUPERVISOR0, LINE-CARD1, FABRIC-CARD5\n        Returns:\n            An integer, the index of the ModuleBase object in the module_list\n        \"\"\"\n        return 0\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the system LED\n        Args:\n            color: A string representing the color with which to set the\n                   system LED\n        Returns:\n            bool: True if system LED state is set successfully, False if not\n        \"\"\"\n        colors = {\n            \"amber\" : \"0x00\",\n            \"red\" : \"0x02\",\n            \"green\" : \"0x04\"\n        }\n        regval = colors.get(color, None)\n        if regval is None:\n            print(\"Invaild color input.\")\n            return False\n        ret , log = subprocess.getstatusoutput(self.set_sys_led_cmd + regval)\n        if ret != 0:\n            print(\"Cannot execute %s\" % self.set_sys_led_cmd + regval)\n            return False\n        self.led_status = color\n        return True\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the system LED\n        Returns:\n            A string, one of the valid LED color strings which could be vendor\n            specified.\n        \"\"\"\n        ret , log = subprocess.getstatusoutput(self.get_sys_led_cmd)\n        if ret != 0:\n            print(\"Cannot execute %s\" % self.get_sys_led_cmd)\n            return False\n        colors = {\n            \"0x00\" : \"amber\",\n            \"0x02\" : \"red\",\n            \"0x04\" : \"green\"\n        }\n        color = colors.get(log, None)\n        if color is None:\n            return \"Unknown color status\"\n        self.led_status = color\n        return self.led_status\n\n"}, "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py": {"changes": [{"diff": "\n     PMON_PLATFORM_PATH = '/usr/share/sonic/platform/'\n     CONFIG_DIR = 'sonic_platform_config'\n \n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def load_json_file(self, path):\n         \"", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"", "        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]", "        return subprocess.call(self.HOST_CHK_CMD) == 0"]}], "source": "\nimport os import yaml from sonic_py_common import device_info class Common: DEVICE_PATH='/usr/share/sonic/device/' PMON_PLATFORM_PATH='/usr/share/sonic/platform/' CONFIG_DIR='sonic_platform_config' HOST_CHK_CMD=\"docker > /dev/null 2>&1\" def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(self.HOST_CHK_CMD)==0 def load_json_file(self, path): \"\"\" Retrieves the json object from json file path Returns: A json object \"\"\" with open(path, 'r') as f: json_data=yaml.safe_load(f) return json_data def get_config_path(self, config_name): \"\"\" Retrieves the path to platform api config directory Args: config_name: A string containing the name of config file. Returns: A string containing the path to json file \"\"\" return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name) ", "sourceWithComments": "import os\nimport yaml\n\nfrom sonic_py_common import device_info\n\n\nclass Common:\n\n    DEVICE_PATH = '/usr/share/sonic/device/'\n    PMON_PLATFORM_PATH = '/usr/share/sonic/platform/'\n    CONFIG_DIR = 'sonic_platform_config'\n\n    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def load_json_file(self, path):\n        \"\"\"\n        Retrieves the json object from json file path\n\n        Returns:\n            A json object\n        \"\"\"\n        with open(path, 'r') as f:\n            json_data = yaml.safe_load(f)\n\n        return json_data\n\n    def get_config_path(self, config_name):\n        \"\"\"\n        Retrieves the path to platform api config directory\n\n        Args:\n            config_name: A string containing the name of config file.\n\n        Returns:\n            A string containing the path to json file\n        \"\"\"\n        return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\n\n"}, "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py": {"changes": [{"diff": "\n ########################################################################\n \n try:\n-    import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n     from sonic_platform.regutil import Reg\n     from sonic_platform.logger import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py", "badparts": ["    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         \"\"\"\n         try:\n             successtips = \"CPLD Upgrade succeeded!\"\n-            status, output = subprocess.getstatusoutput(\"which firmware_upgrade\")\n+            status, output = getstatusoutput_noshell([\"which\", \"firmware_upgrade\"])\n             if status or len(output) <= 0:\n                 logger.error(\"no upgrade tool.\")\n                 return False\n-            cmdstr = \"%s %s cpld %d cpld\"%(output,image_path,self.slot)\n-            ret, log = subprocess.getstatusoutput(cmdstr)\n+            cmdstr = [output, image_path, \"cpld\", self.slot, \"cpld\"]\n+            ret, log = getstatusoutput_noshell(cmdstr)\n             if ret == 0 and successtips in log:\n                 return True\n             logger.error(\"upgrade failed. ret:%d, log:\\n%s\" % (ret, lo", "add": 3, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py", "badparts": ["            status, output = subprocess.getstatusoutput(\"which firmware_upgrade\")", "            cmdstr = \"%s %s cpld %d cpld\"%(output,image_path,self.slot)", "            ret, log = subprocess.getstatusoutput(cmdstr)"], "goodparts": ["            status, output = getstatusoutput_noshell([\"which\", \"firmware_upgrade\"])", "            cmdstr = [output, image_path, \"cpld\", self.slot, \"cpld\"]", "            ret, log = getstatusoutput_noshell(cmdstr)"]}], "source": "\n try: import subprocess from sonic_platform_base.component_base import ComponentBase from sonic_platform.regutil import Reg from sonic_platform.logger import logger except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class Component(ComponentBase): \"\"\"Ruijie Platform-specific Component class\"\"\" def __init__(self, index, config=None): self.index=index self.name=config.get(\"name\") self._reg_fm_ver=Reg(config.get(\"firmware_version\")) self.description=config.get(\"desc\") self.slot=config.get(\"slot\") def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return self.name def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return self.description def get_firmware_version(self): \"\"\" Retrieves the firmware version of the component Returns: A string containing the firmware version of the component \"\"\" try: return self._reg_fm_ver.decode() except Exception as e: logger.error(str(e)) return \"\" def install_firmware(self, image_path): \"\"\" Installs firmware to the component Args: image_path: A string, path to firmware image Returns: A boolean, True if install was successful, False if not \"\"\" try: successtips=\"CPLD Upgrade succeeded!\" status, output=subprocess.getstatusoutput(\"which firmware_upgrade\") if status or len(output) <=0: logger.error(\"no upgrade tool.\") return False cmdstr=\"%s %s cpld %d cpld\"%(output,image_path,self.slot) ret, log=subprocess.getstatusoutput(cmdstr) if ret==0 and successtips in log: return True logger.error(\"upgrade failed. ret:%d, log:\\n%s\" %(ret, log)) except Exception as e: logger.error(str(e)) return False ", "sourceWithComments": "########################################################################\n# Ruijie B6510-48VS8CQ\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Components' (e.g., BIOS, CPLD, FPGA, etc.) available in\n# the platform\n#\n########################################################################\n\ntry:\n    import subprocess\n    from sonic_platform_base.component_base import ComponentBase\n    from sonic_platform.regutil import Reg\n    from sonic_platform.logger import logger\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass Component(ComponentBase):\n    \"\"\"Ruijie Platform-specific Component class\"\"\"\n\n    def __init__(self, index, config=None):\n        self.index = index\n        self.name = config.get(\"name\")\n        self._reg_fm_ver = Reg(config.get(\"firmware_version\"))\n        self.description = config.get(\"desc\")\n        self.slot = config.get(\"slot\")\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n\n        Returns:\n            A string containing the name of the component\n        \"\"\"\n        return self.name\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n\n        Returns:\n            A string containing the description of the component\n        \"\"\"\n        return self.description\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of the component\n\n        Returns:\n            A string containing the firmware version of the component\n        \"\"\"\n        try:\n            return self._reg_fm_ver.decode()\n        except Exception as e:\n            logger.error(str(e))\n\n        return \"\"\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Installs firmware to the component\n\n        Args:\n            image_path: A string, path to firmware image\n\n        Returns:\n            A boolean, True if install was successful, False if not\n        \"\"\"\n        try:\n            successtips = \"CPLD Upgrade succeeded!\"\n            status, output = subprocess.getstatusoutput(\"which firmware_upgrade\")\n            if status or len(output) <= 0:\n                logger.error(\"no upgrade tool.\")\n                return False\n            cmdstr = \"%s %s cpld %d cpld\"%(output,image_path,self.slot)\n            ret, log = subprocess.getstatusoutput(cmdstr)\n            if ret == 0 and successtips in log:\n                return True\n            logger.error(\"upgrade failed. ret:%d, log:\\n%s\" % (ret, log))\n        except Exception as e:\n            logger.error(str(e))\n        return False\n        \n"}, "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py": {"changes": [{"diff": "\n #\n #######################################################\n \n-import subprocess\n import time\n import glob\n import re\n", "add": 0, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["import subprocess"], "goodparts": []}, {"diff": "\n \n     @staticmethod\n     def command(cmdstr):\n-        retcode, output = subprocess.getstatusoutput(cmdstr)\n+        retcode, output = getstatusoutput_noshell(cmdstr)\n         return retcode, output\n \n \n     @staticmethod\n     def geti2cword_i2ctool(bus, addr, offset):\n-        command_line = \"i2cget -f -y %d 0x%02x 0x%02x  wp\" % (bus, addr, offset)\n+        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%02x\"%offset, \"wp\"]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        retcode, output = subprocess.getstatusoutput(cmdstr)", "        command_line = \"i2cget -f -y %d 0x%02x 0x%02x  wp\" % (bus, addr, offset)"], "goodparts": ["        retcode, output = getstatusoutput_noshell(cmdstr)", "        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%02x\"%offset, \"wp\"]"]}, {"diff": "\n \n     @staticmethod\n     def seti2cword_i2ctool(bus, addr, offset, val):\n-        command_line = \"i2cset -f -y %d 0x%02x 0x%0x 0x%04x wp\" % (bus, addr, offset, val)\n+        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%0x\"%offset, \"0x%04x\"%val, \"wp\"]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        command_line = \"i2cset -f -y %d 0x%02x 0x%0x 0x%04x wp\" % (bus, addr, offset, val)"], "goodparts": ["        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%0x\"%offset, \"0x%04x\"%val, \"wp\"]"]}, {"diff": "\n \n     @staticmethod\n     def rji2cget_i2ctool(bus, devno, address):\n-        command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)\n+        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)"], "goodparts": ["        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address]"]}, {"diff": "\n \n     @staticmethod\n     def rji2cset_i2ctool(bus, devno, address, byte):\n-        command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (\n-            bus, devno, address, byte)\n+        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address, \"0x%02x\"%byte]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n", "add": 1, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (", "            bus, devno, address, byte)"], "goodparts": ["        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address, \"0x%02x\"%byte]"]}, {"diff": "\n \n     @staticmethod\n     def getdevmem(addr, digit, mask):\n-        command_line = \"devmem 0x%02x %d\" %(addr, digit)\n+        command_line = [\"devmem\", \"0x%02x\"%addr, str(digit)]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        command_line = \"devmem 0x%02x %d\" %(addr, digit)"], "goodparts": ["        command_line = [\"devmem\", \"0x%02x\"%addr, str(digit)]"]}, {"diff": "\n \n     @staticmethod\n     def rj_os_system(cmd):\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         return status, output\n \n     @staticmethod\n     def getsdkreg(reg):\n         try:\n-            cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg\n+            cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]\n             ret, result = osutil.rj_os_system(cmd)\n             result_t = result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n             if ret != 0 or \"Error:\" in result_t:\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        status, output = subprocess.getstatusoutput(cmd)", "            cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg"], "goodparts": ["        status, output = getstatusoutput_noshell(cmd)", "            cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]"]}, {"diff": "\n             result = {}\n             #waitForDocker()\n             #need to exec twice\n-            osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n-            ret, log = osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n+            osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n+            ret, log = osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n             if ret:\n                 return False, result\n             e", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["            osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")", "            ret, log = osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")"], "goodparts": ["            osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])", "            ret, log = osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])"]}], "source": "\n import subprocess import time import glob import re from rjutil.smbus import SMBus import time from functools import wraps def retry(maxretry=6, delay=0.01): ''' maxretry: max retry times delay : interval after last retry ''' def decorator(f): @wraps(f) def wrapper(*args, **kwargs): time_retry=maxretry time_delay=delay result_msg=\"\" while time_retry: try: val, result_msg=f(*args, **kwargs) if val is False: time_retry -=1 time.sleep(time_delay) continue else: return val, result_msg except Exception as e: time_retry -=1 result_msg=str(e) time.sleep(time_delay) return False, \"max time retry last errmsg is{}\".format(result_msg) return wrapper return decorator class osutil(object): \"\"\" osutil \"\"\" @staticmethod @retry(maxretry=6) def rji2cget_python(bus, addr, reg): with SMBus(bus) as y: val, ind =y.read_byte_data(addr, reg, True) return val, ind @staticmethod @retry(maxretry=6) def rji2cset_python(bus, addr, reg, value): with SMBus(bus) as y: val, ind =y.write_byte_data(addr, reg, value, True) return val, ind @staticmethod @retry(maxretry=6) def rji2cgetword_python(bus, addr, reg): with SMBus(bus) as y: val, ind =y.read_word_data(addr, reg, True) return val, ind @staticmethod @retry(maxretry=6) def rji2csetword_python(bus, addr, reg, value): with SMBus(bus) as y: val, ind =y.write_word_data(addr, reg, value, True) return val, ind @staticmethod def command(cmdstr): retcode, output=subprocess.getstatusoutput(cmdstr) return retcode, output @staticmethod def geti2cword_i2ctool(bus, addr, offset): command_line=\"i2cget -f -y %d 0x%02x 0x%02x wp\" %(bus, addr, offset) retrytime=6 ret_t=\"\" for i in range(retrytime): ret, ret_t=osutil.command(command_line) if ret==0: return True, int(ret_t, 16) time.sleep(0.1) return False, ret_t @staticmethod def seti2cword_i2ctool(bus, addr, offset, val): command_line=\"i2cset -f -y %d 0x%02x 0x%0x 0x%04x wp\" %(bus, addr, offset, val) retrytime=6 ret_t=\"\" for i in range(retrytime): ret, ret_t=osutil.command(command_line) if ret==0: return True, ret_t time.sleep(0.1) return False, ret_t @staticmethod def rji2cget_i2ctool(bus, devno, address): command_line=\"i2cget -f -y %d 0x%02x 0x%02x \" %(bus, devno, address) retrytime=6 ret_t=\"\" for i in range(retrytime): ret, ret_t=osutil.command(command_line) if ret==0: return True, int(ret_t, 16) time.sleep(0.1) return False, ret_t @staticmethod def rji2cset_i2ctool(bus, devno, address, byte): command_line=\"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" %( bus, devno, address, byte) retrytime=6 ret_t=\"\" for i in range(retrytime): ret, ret_t=osutil.command(command_line) if ret==0: return True, ret_t return False, ret_t @staticmethod def geti2cword(bus, addr, offset): return osutil.rji2cgetword_python(bus, addr, offset) @staticmethod def seti2cword(bus, addr, offset, val): return osutil.rji2csetword_python(bus, addr, offset, val) @staticmethod def rji2cget(bus, devno, address): return osutil.rji2cget_python(bus, devno, address) @staticmethod def rji2cset(bus, devno, address, byte): return osutil.rji2cset_python(bus, devno, address, byte) @staticmethod def byteTostr(val): strtmp='' for i in range(len(val)): strtmp +=chr(val[i]) return strtmp @staticmethod def readsysfs(location): try: locations=glob.glob(location) with open(locations[0], 'rb') as fd1: retval=fd1.read() retval=retval.strip() except Exception as e: return False,(str(e)+\" location[%s]\" % location) return True, retval.decode(\"utf-8\", \"ignore\") @staticmethod def getdevmem(addr, digit, mask): command_line=\"devmem 0x%02x %d\" %(addr, digit) retrytime=6 ret_t=\"\" for i in range(retrytime): ret, ret_t=osutil.command(command_line) if ret==0: if mask !=None: ret_t=str(int(ret_t, 16) & mask) return True, ret_t return False, ret_t @staticmethod def rj_os_system(cmd): status, output=subprocess.getstatusoutput(cmd) return status, output @staticmethod def getsdkreg(reg): try: cmd=\"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg ret, result=osutil.rj_os_system(cmd) result_t=result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\") if ret !=0 or \"Error:\" in result_t: return False, result patt=r\"%s.(.*):(.*)>drivshell\" % reg rt=re.findall(patt, result_t, re.S) test=re.findall(\"=(.*)\", rt[0][0])[0] except Exception as e: return False, 'get sdk register error' return True, test @staticmethod def getmactemp(): try: result={} osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\") ret, log=osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\") if ret: return False, result else: logs=log.splitlines() for line in logs: if \"average\" in line: b=re.findall(r'\\d+.\\d+', line) result[\"average\"]=b[0] elif \"maximum\" in line: b=re.findall(r'\\d+.\\d+', line) result[\"maximum\"]=b[0] except Exception as e: return False, str(e) return True, result ", "sourceWithComments": "#######################################################\n#\n# osutil.py\n# Python implementation of the Class osutil\n# Original author: sonic_rd@ruijie.com.cn\n#\n#######################################################\n\nimport subprocess\nimport time\nimport glob\nimport re\n#import chardet\nfrom rjutil.smbus import SMBus\nimport time\nfrom  functools import wraps\n\n\ndef retry(maxretry =6, delay = 0.01):\n    '''\n        maxretry:  max retry times\n        delay   :  interval after last retry\n    '''\n    def decorator(f):\n        @wraps(f)\n        def wrapper(*args, **kwargs):\n            time_retry = maxretry\n            time_delay = delay\n            result_msg = \"\"\n            while time_retry:\n                try:\n                    val , result_msg = f(*args, **kwargs)\n                    if val is False:\n                        time_retry -=1\n                        time.sleep(time_delay)\n                        continue\n                    else:\n                        return val, result_msg\n                except Exception as e:\n                    time_retry -= 1\n                    result_msg = str(e)\n                    time.sleep(time_delay)\n            return False, \"max time retry last errmsg is {}\".format(result_msg)\n        return wrapper\n    return decorator\n\nclass osutil(object):\n    \"\"\"\n       osutil\n    \"\"\"\n\n    @staticmethod\n    @retry(maxretry = 6)\n    def rji2cget_python(bus, addr, reg):\n        with SMBus(bus) as y:\n            val , ind  = y.read_byte_data(addr, reg, True)\n        return val , ind\n\n\n    @staticmethod\n    @retry(maxretry = 6)\n    def rji2cset_python(bus, addr, reg, value):\n        with SMBus(bus) as y:\n            val , ind  = y.write_byte_data(addr, reg, value, True)\n        return val , ind\n\n    @staticmethod\n    @retry(maxretry = 6)\n    def rji2cgetword_python(bus, addr, reg):\n        with SMBus(bus) as y:\n            val , ind  = y.read_word_data(addr, reg, True)\n        return val , ind\n\n    @staticmethod\n    @retry(maxretry = 6)\n    def rji2csetword_python(bus, addr, reg, value):\n        with SMBus(bus) as y:\n            val , ind  = y.write_word_data(addr, reg, value, True)\n        return val , ind\n\n    @staticmethod\n    def command(cmdstr):\n        retcode, output = subprocess.getstatusoutput(cmdstr)\n        return retcode, output\n\n\n    @staticmethod\n    def geti2cword_i2ctool(bus, addr, offset):\n        command_line = \"i2cget -f -y %d 0x%02x 0x%02x  wp\" % (bus, addr, offset)\n        retrytime = 6\n        ret_t = \"\"\n        for i in range(retrytime):\n            ret, ret_t = osutil.command(command_line)\n            if ret == 0:\n                return True, int(ret_t, 16)\n            time.sleep(0.1)\n        return False, ret_t\n\n\n    @staticmethod\n    def seti2cword_i2ctool(bus, addr, offset, val):\n        command_line = \"i2cset -f -y %d 0x%02x 0x%0x 0x%04x wp\" % (bus, addr, offset, val)\n        retrytime = 6\n        ret_t = \"\"\n        for i in range(retrytime):\n            ret, ret_t = osutil.command(command_line)\n            if ret == 0:\n                return True, ret_t\n            time.sleep(0.1)\n        return False, ret_t\n\n    @staticmethod\n    def rji2cget_i2ctool(bus, devno, address):\n        command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)\n        retrytime = 6\n        ret_t = \"\"\n        for i in range(retrytime):\n            ret, ret_t = osutil.command(command_line)\n            if ret == 0:\n                return True, int(ret_t, 16)\n            time.sleep(0.1)\n        return False, ret_t\n\n    @staticmethod\n    def rji2cset_i2ctool(bus, devno, address, byte):\n        command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (\n            bus, devno, address, byte)\n        retrytime = 6\n        ret_t = \"\"\n        for i in range(retrytime):\n            ret, ret_t = osutil.command(command_line)\n            if ret == 0:\n                return True, ret_t\n        return False, ret_t\n\n    @staticmethod\n    def geti2cword(bus, addr, offset):\n        return osutil.rji2cgetword_python(bus, addr, offset)\n    @staticmethod\n    def seti2cword(bus, addr, offset, val):\n        return osutil.rji2csetword_python(bus, addr, offset, val)\n    @staticmethod\n    def rji2cget(bus, devno, address):\n        return osutil.rji2cget_python(bus, devno, address)\n    @staticmethod\n    def rji2cset(bus, devno, address, byte):\n        return osutil.rji2cset_python(bus, devno, address, byte)\n\n    @staticmethod\n    def byteTostr(val):\n        strtmp = ''\n        for i in range(len(val)):\n            strtmp += chr(val[i])\n        return strtmp\n\n    @staticmethod\n    def readsysfs(location):\n        try:\n            locations = glob.glob(location)\n            with open(locations[0], 'rb') as fd1:\n                retval = fd1.read()\n            retval = retval.strip()\n        except Exception as e:\n            return False, (str(e)+\" location[%s]\" % location)\n        return True, retval.decode(\"utf-8\", \"ignore\")\n\n    @staticmethod\n    def getdevmem(addr, digit, mask):\n        command_line = \"devmem 0x%02x %d\" %(addr, digit)\n        retrytime = 6\n        ret_t = \"\"\n        for i in range(retrytime):\n            ret, ret_t = osutil.command(command_line)\n            if ret == 0:\n                if mask != None:\n                    ret_t = str(int(ret_t, 16) & mask)\n            return True, ret_t\n        return False, ret_t\n\n    @staticmethod\n    def rj_os_system(cmd):\n        status, output = subprocess.getstatusoutput(cmd)\n        return status, output\n\n    @staticmethod\n    def getsdkreg(reg):\n        try:\n            cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg\n            ret, result = osutil.rj_os_system(cmd)\n            result_t = result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n            if ret != 0 or \"Error:\" in result_t:\n                return False, result\n            patt = r\"%s.(.*):(.*)>drivshell\" % reg\n            rt = re.findall(patt, result_t, re.S)\n            test = re.findall(\"=(.*)\", rt[0][0])[0]\n        except Exception as e:\n            return False, 'get sdk register error'\n        return True, test\n\n    @staticmethod\n    def getmactemp():\n        try:\n            result = {}\n            #waitForDocker()\n            #need to exec twice\n            osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n            ret, log = osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n            if ret:\n                return False, result\n            else:\n                logs = log.splitlines()\n                for line in logs:\n                    if \"average\" in line:\n                        b = re.findall(r'\\d+.\\d+', line)\n                        result[\"average\"] = b[0]\n                    elif \"maximum\" in line:\n                        b = re.findall(r'\\d+.\\d+', line)\n                        result[\"maximum\"] = b[0]\n        except Exception as e:\n            return False, str(e)\n        return True, result\n\n"}, "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py": {"changes": [{"diff": "\n \n def check_driver():\n     u'''whether there is driver start with rg'''\n-    status, output = log_os_system(\"lsmod | grep rg | wc -l\")\n+    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", \"rg\"], [\"wc\", \"-l\"])\n     #System execution error\n     if status: \n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["    status, output = log_os_system(\"lsmod | grep rg | wc -l\")"], "goodparts": ["    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", \"rg\"], [\"wc\", \"-l\"])"]}, {"diff": "\n     return ret\n \n def startAvscontrol():\n-    cmd = \"nohup avscontrol.py start >/dev/null 2>&1 &\"\n+    cmd = [\"avscontrol.py\", \"start\"]\n     rets = i2c_getPid(\"avscontrol.py\")\n     if len(rets) == 0:\n-        os.system(cmd)\n+        subprocess.Popen(cmd)\n \n def startFanctrol():\n     if STARTMODULE['fancontrol'] == 1:\n-        cmd = \"nohup fancontrol.py start >/dev/null 2>&1 &\"\n+        cmd = [\"fancontrol.py\", \"start\"]\n         rets = i2c_getPid(\"fancontrol.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def starthal_fanctrl():\n     if STARTMODULE.get('hal_fanctrl',0) == 1:\n-        cmd = \"nohup hal_fanctrl.py start >/dev/null 2>&1 &\"\n+        cmd = [\"hal_fanctrl.py\", \"start\"]\n         rets = i2c_getPid(\"hal_fanctrl.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def starthal_ledctrl():\n     if STARTMODULE.get('hal_ledctrl',0) == 1:\n-        cmd = \"nohup hal_ledctrl.py start >/dev/null 2>&1 &\"\n+        cmd = [\"hal_ledctrl.py\", \"start\"]\n         rets = i2c_getPid(\"hal_ledctrl.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n-\n+            subprocess.Popen(cmd)\n def startDevmonitor():\n     if STARTMODULE.get('dev_monitor',0) == 1:\n-        cmd = \"nohup dev_monitor.py start >/dev/null 2>&1 &\"\n+        cmd = [\"dev_monitor.py\", \"start\"]\n         rets = i2c_getPid(\"dev_monitor.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n-\n+            subprocess.Popen(cmd)\n def startSlotmonitor():\n     if STARTMODULE.get('slot_monitor',0) == 1:\n-        cmd = \"nohup slot_monitor.py start >/dev/null 2>&1 &\"\n+        cmd = [\"slot_monitor.py\", \"start\"]\n         rets = i2c_getPid(\"slot_monitor.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def stopFanctrol():\n     u'''disable fan timer service'''\n     if STARTMODULE['fancontrol'] == 1:\n         rets = i2c_getPid(\"fancontrol.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def stophal_ledctrl():\n     if STARTMODULE.get('hal_ledctrl',0) == 1:\n         rets = i2c_getPid(\"hal_ledctrl.py\")\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n \n", "add": 16, "remove": 18, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["    cmd = \"nohup avscontrol.py start >/dev/null 2>&1 &\"", "        os.system(cmd)", "        cmd = \"nohup fancontrol.py start >/dev/null 2>&1 &\"", "            os.system(cmd)", "        cmd = \"nohup hal_fanctrl.py start >/dev/null 2>&1 &\"", "            os.system(cmd)", "        cmd = \"nohup hal_ledctrl.py start >/dev/null 2>&1 &\"", "            os.system(cmd)", "        cmd = \"nohup dev_monitor.py start >/dev/null 2>&1 &\"", "            os.system(cmd)", "        cmd = \"nohup slot_monitor.py start >/dev/null 2>&1 &\"", "            os.system(cmd)", "            cmd = \"kill \"+ ret", "            os.system(cmd)", "            cmd = \"kill \"+ ret", "            os.system(cmd)"], "goodparts": ["    cmd = [\"avscontrol.py\", \"start\"]", "        subprocess.Popen(cmd)", "        cmd = [\"fancontrol.py\", \"start\"]", "            subprocess.Popen(cmd)", "        cmd = [\"hal_fanctrl.py\", \"start\"]", "            subprocess.Popen(cmd)", "        cmd = [\"hal_ledctrl.py\", \"start\"]", "            subprocess.Popen(cmd)", "        cmd = [\"dev_monitor.py\", \"start\"]", "            subprocess.Popen(cmd)", "        cmd = [\"slot_monitor.py\", \"start\"]", "            subprocess.Popen(cmd)", "            cmd = [\"kill\", ret]", "            subprocess.call(cmd)", "            cmd = [\"kill\", ret]", "            subprocess.call(cmd)"]}, {"diff": "\n     if STARTMODULE.get('dev_monitor',0) == 1:\n         rets = i2c_getPid(\"dev_monitor.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def stopSlotmonitor():\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["            cmd = \"kill \"+ ret", "            os.system(cmd)"], "goodparts": ["            cmd = [\"kill\", ret]", "            subprocess.call(cmd)"]}, {"diff": "\n     if STARTMODULE.get('slot_monitor',0) == 1:\n         rets = i2c_getPid(\"slot_monitor.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def removeDev(bus, loc):\n-    cmd = \"echo  0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device\" % (loc, bus)\n     devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n     if os.path.exists(devpath):\n-        log_os_system(cmd)\n+        file = \"/sys/bus/i2c/devices/i2c-%d/delete_device\" % bus\n+        with open(file, 'w') as f:\n+            f.write('0x%02x\\n'%str(bus))\n         \n def addDev(name, bus, loc):\n     if name == \"lm75\":\n", "add": 5, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["            cmd = \"kill \"+ ret", "            os.system(cmd)", "    cmd = \"echo  0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device\" % (loc, bus)", "        log_os_system(cmd)"], "goodparts": ["            cmd = [\"kill\", ret]", "            subprocess.call(cmd)", "        file = \"/sys/bus/i2c/devices/i2c-%d/delete_device\" % bus", "        with open(file, 'w') as f:", "            f.write('0x%02x\\n'%str(bus))"]}, {"diff": "\n         if i % 10 == 0:\n             click.echo(\"%%DEVICE_I2C-INIT: %s not found, wait 0.1 second ! i %d \" % (pdevpath,i))\n             \n-    cmd = \"echo  %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device\" % (name, loc, bus)\n     devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n     if os.path.exists(devpath) == False:\n-        os.system(cmd)\n+        file = \"/sys/bus/i2c/devices/i2c-%d/new_device\" % bus\n+        with open(file, 'w') as f:\n+            f.write('%s 0x%02x\\n' % (name, loc))\n \n def removedevs():\n     devs = GLOBALCONFIG[\"DEVS\"]\n", "add": 3, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["    cmd = \"echo  %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device\" % (name, loc, bus)", "        os.system(cmd)"], "goodparts": ["        file = \"/sys/bus/i2c/devices/i2c-%d/new_device\" % bus", "        with open(file, 'w') as f:", "            f.write('%s 0x%02x\\n' % (name, loc))"]}, {"diff": "\n         addDev(devs[dev][\"name\"], devs[dev][\"bus\"] , devs[dev][\"loc\"])\n \n def checksignaldriver(name):\n-    modisexistcmd = \"lsmod | grep %s | wc -l\" % name\n-    status, output = log_os_system(modisexistcmd)\n+    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", name], [\"wc\", \"-l\"])\n     #System execution error\n     if status: \n         return False\n", "add": 1, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["    modisexistcmd = \"lsmod | grep %s | wc -l\" % name", "    status, output = log_os_system(modisexistcmd)"], "goodparts": ["    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", name], [\"wc\", \"-l\"])"]}, {"diff": "\n         return False\n \n def adddriver(name, delay):\n-    cmd = \"modprobe %s\" % name\n+    cmd = [\"modprobe\", name]\n     if delay != 0:\n         time.sleep(delay)\n     if checksignaldriver(name) != True:\n-        log_os_system(cmd)\n+        getstatusoutput_noshell(cmd)\n \n def removedriver(name, delay):\n     realname = name.lstrip().split(\" \")[0];\n-    cmd = \"rmmod -f %s\" % realname\n+    cmd = [\"rmmod\", \"-f\", realname]\n     if checksignaldriver(realname):\n-        log_os_system(cmd)\n+        getstatusoutput_noshell(cmd)\n \n def removedrivers():\n     u'''remove all drive", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["    cmd = \"modprobe %s\" % name", "        log_os_system(cmd)", "    cmd = \"rmmod -f %s\" % realname", "        log_os_system(cmd)"], "goodparts": ["    cmd = [\"modprobe\", name]", "        getstatusoutput_noshell(cmd)", "    cmd = [\"rmmod\", \"-f\", realname]", "        getstatusoutput_noshell(cmd)"]}], "source": "\n import click import os import subprocess import time from ruijieconfig import GLOBALCONFIG, GLOBALINITPARAM, GLOBALINITCOMMAND, MAC_LED_RESET, STARTMODULE, i2ccheck_params from ruijieutil import rjpciwr CONTEXT_SETTINGS=dict(help_option_names=['-h', '--help']) class AliasedGroup(click.Group): def get_command(self, ctx, cmd_name): rv=click.Group.get_command(self, ctx, cmd_name) if rv is not None: return rv matches=[x for x in self.list_commands(ctx) if x.startswith(cmd_name)] if not matches: return None elif len(matches)==1: return click.Group.get_command(self, ctx, matches[0]) ctx.fail('Too many matches: %s' % ', '.join(sorted(matches))) def log_os_system(cmd): u'''execute shell command''' status, output=subprocess.getstatusoutput(cmd) if status: print(output) return status, output def write_sysfs_value(reg_name, value): u'''write sysfs file''' mb_reg_file=\"/sys/bus/i2c/devices/\" +reg_name if(not os.path.isfile(mb_reg_file)): print(mb_reg_file, 'not found !') return False try: with open(mb_reg_file, 'w') as fd: fd.write(value) except Exception as error: return False return True def check_driver(): u'''whether there is driver start with rg''' status, output=log_os_system(\"lsmod | grep rg | wc -l\") if status: return False if output.isdigit() and int(output) > 0: return True else: return False def i2c_getPid(name): ret=[] for dirname in os.listdir('/proc'): if dirname=='curproc': continue try: with open('/proc/{}/cmdline'.format(dirname), mode='r') as fd: content=fd.read() except Exception: continue if name in content: ret.append(dirname) return ret def startAvscontrol(): cmd=\"nohup avscontrol.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"avscontrol.py\") if len(rets)==0: os.system(cmd) def startFanctrol(): if STARTMODULE['fancontrol']==1: cmd=\"nohup fancontrol.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"fancontrol.py\") if len(rets)==0: os.system(cmd) def starthal_fanctrl(): if STARTMODULE.get('hal_fanctrl',0)==1: cmd=\"nohup hal_fanctrl.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"hal_fanctrl.py\") if len(rets)==0: os.system(cmd) def starthal_ledctrl(): if STARTMODULE.get('hal_ledctrl',0)==1: cmd=\"nohup hal_ledctrl.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"hal_ledctrl.py\") if len(rets)==0: os.system(cmd) def startDevmonitor(): if STARTMODULE.get('dev_monitor',0)==1: cmd=\"nohup dev_monitor.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"dev_monitor.py\") if len(rets)==0: os.system(cmd) def startSlotmonitor(): if STARTMODULE.get('slot_monitor',0)==1: cmd=\"nohup slot_monitor.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"slot_monitor.py\") if len(rets)==0: os.system(cmd) def stopFanctrol(): u'''disable fan timer service''' if STARTMODULE['fancontrol']==1: rets=i2c_getPid(\"fancontrol.py\") for ret in rets: cmd=\"kill \"+ret os.system(cmd) return True def stophal_ledctrl(): if STARTMODULE.get('hal_ledctrl',0)==1: rets=i2c_getPid(\"hal_ledctrl.py\") for ret in rets: cmd=\"kill \"+ret os.system(cmd) return True def stopDevmonitor(): u'''disable the fan timer service''' if STARTMODULE.get('dev_monitor',0)==1: rets=i2c_getPid(\"dev_monitor.py\") for ret in rets: cmd=\"kill \"+ret os.system(cmd) return True def stopSlotmonitor(): u'''disable slot timer service''' if STARTMODULE.get('slot_monitor',0)==1: rets=i2c_getPid(\"slot_monitor.py\") for ret in rets: cmd=\"kill \"+ret os.system(cmd) return True def removeDev(bus, loc): cmd=\"echo 0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device\" %(loc, bus) devpath=\"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc) if os.path.exists(devpath): log_os_system(cmd) def addDev(name, bus, loc): if name==\"lm75\": time.sleep(0.1) pdevpath=\"/sys/bus/i2c/devices/i2c-%d/\" %(bus) for i in range(1, 100): if os.path.exists(pdevpath)==True: break time.sleep(0.1) if i % 10==0: click.echo(\"%%DEVICE_I2C-INIT: %s not found, wait 0.1 second ! i %d \" %(pdevpath,i)) cmd=\"echo %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device\" %(name, loc, bus) devpath=\"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc) if os.path.exists(devpath)==False: os.system(cmd) def removedevs(): devs=GLOBALCONFIG[\"DEVS\"] for index in range(len(devs)-1, -1, -1): removeDev(devs[index][\"bus\"], devs[index][\"loc\"]) def adddevs(): devs=GLOBALCONFIG[\"DEVS\"] for dev in range(0, devs.__len__()): addDev(devs[dev][\"name\"], devs[dev][\"bus\"], devs[dev][\"loc\"]) def checksignaldriver(name): modisexistcmd=\"lsmod | grep %s | wc -l\" % name status, output=log_os_system(modisexistcmd) if status: return False if output.isdigit() and int(output) > 0: return True else: return False def adddriver(name, delay): cmd=\"modprobe %s\" % name if delay !=0: time.sleep(delay) if checksignaldriver(name) !=True: log_os_system(cmd) def removedriver(name, delay): realname=name.lstrip().split(\" \")[0]; cmd=\"rmmod -f %s\" % realname if checksignaldriver(realname): log_os_system(cmd) def removedrivers(): u'''remove all drivers''' if GLOBALCONFIG is None: click.echo(\"%%DEVICE_I2C-INIT: load global config failed.\") return drivers=GLOBALCONFIG.get(\"DRIVERLISTS\", None) if drivers is None: click.echo(\"%%DEVICE_I2C-INIT: load driver list failed.\") return for index in range(len(drivers)-1, -1, -1): delay=0 name=\"\" if type(drivers[index])==dict and \"delay\" in drivers[index]: name=drivers[index].get(\"name\") delay=drivers[index][\"delay\"] else: name=drivers[index] removedriver(name, delay) def adddrivers(): u'''add drivers''' if GLOBALCONFIG is None: click.echo(\"%%DEVICE_I2C-INIT: load global config failed.\") return drivers=GLOBALCONFIG.get(\"DRIVERLISTS\", None) if drivers is None: click.echo(\"%%DEVICE_I2C-INIT: load driver list failed.\") return for index in range(0,len(drivers)): delay=0 name=\"\" if type(drivers[index])==dict and \"delay\" in drivers[index]: name=drivers[index].get(\"name\") delay=drivers[index][\"delay\"] else: name=drivers[index] adddriver(name, delay) def otherinit(): for index in GLOBALINITPARAM: write_sysfs_value(index[\"loc\"], index[\"value\"]) for index in GLOBALINITCOMMAND: log_os_system(index) def unload_driver(): u'''remove devices and drivers''' stopDevmonitor() stopFanctrol() removedevs() removedrivers() def reload_driver(): u'''reload devices and drivers''' removedevs() removedrivers() time.sleep(1) adddrivers() adddevs() def i2c_check(bus,retrytime=6): try: i2cpath=\"/sys/bus/i2c/devices/\" +bus while retrytime and not os.path.exists(i2cpath): click.echo(\"%%DEVICE_I2C-HA: i2c bus abnormal, last bus %s is not exist.\" % i2cpath) reload_driver() retrytime -=1 time.sleep(1) except Exception as e: click.echo(\"%%DEVICE_I2C-HA: %s\" % str(e)) return def MacLedSet(data): '''write pci register''' pcibus=MAC_LED_RESET.get(\"pcibus\") slot=MAC_LED_RESET.get(\"slot\") fn=MAC_LED_RESET.get(\"fn\") bar=MAC_LED_RESET.get(\"bar\") offset=MAC_LED_RESET.get(\"offset\") val=MAC_LED_RESET.get(data, None) if val is None: click.echo(\"%%DEVICE_I2C-INIT: MacLedSet wrong input\") return rjpciwr(pcibus, slot, fn, bar, offset, val) def load_driver(): u'''load devices and drivers''' adddrivers() adddevs() if STARTMODULE.get(\"i2ccheck\",0)==1: busend=i2ccheck_params.get(\"busend\") retrytime=i2ccheck_params.get(\"retrytime\") i2c_check(busend,retrytime) startFanctrol() starthal_fanctrl() starthal_ledctrl() if STARTMODULE['avscontrol']==1: startAvscontrol() startDevmonitor() startSlotmonitor() otherinit(); if STARTMODULE.get(\"macledreset\",0)==1: MacLedSet(\"reset\") @click.group(cls=AliasedGroup, context_settings=CONTEXT_SETTINGS) def main(): '''device operator''' pass @main.command() def start(): '''load device ''' if check_driver(): unload_driver() load_driver() @main.command() def stop(): '''stop device ''' unload_driver() @main.command() def restart(): '''restart device''' unload_driver() load_driver() if __name__=='__main__': u'''device_i2c operation''' main() ", "sourceWithComments": "#!/usr/bin/env python3\n# -*- coding: UTF-8 -*-\n\nimport click\nimport os\nimport subprocess\nimport time\nfrom  ruijieconfig import GLOBALCONFIG, GLOBALINITPARAM, GLOBALINITCOMMAND, MAC_LED_RESET, STARTMODULE, i2ccheck_params\n\nfrom  ruijieutil   import rjpciwr\n\nCONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])\n\nclass AliasedGroup(click.Group):\n    def get_command(self, ctx, cmd_name):\n        rv = click.Group.get_command(self, ctx, cmd_name)\n        if rv is not None:\n            return rv\n        matches = [x for x in self.list_commands(ctx)\n                   if x.startswith(cmd_name)]\n        if not matches:\n            return None\n        elif len(matches) == 1:\n            return click.Group.get_command(self, ctx, matches[0])\n        ctx.fail('Too many matches: %s' % ', '.join(sorted(matches)))\n   \ndef log_os_system(cmd):\n    u'''execute shell command'''\n    status, output = subprocess.getstatusoutput(cmd)\n    if status:\n        print(output)\n    return  status, output\n\ndef write_sysfs_value(reg_name, value):\n    u'''write sysfs file'''\n    mb_reg_file = \"/sys/bus/i2c/devices/\" + reg_name\n    if (not os.path.isfile(mb_reg_file)):\n        print(mb_reg_file,  'not found !')\n        return False\n    try:\n        with open(mb_reg_file, 'w') as fd:\n            fd.write(value)\n    except Exception as error:\n        return False\n    return True\n\ndef check_driver():\n    u'''whether there is driver start with rg'''\n    status, output = log_os_system(\"lsmod | grep rg | wc -l\")\n    #System execution error\n    if status: \n        return False\n    if output.isdigit() and int(output) > 0:\n        return True\n    else:\n        return False\n\ndef i2c_getPid(name):\n    ret = []\n    for dirname in os.listdir('/proc'):\n        if dirname == 'curproc':\n            continue\n        try:\n            with open('/proc/{}/cmdline'.format(dirname), mode='r') as fd:\n                content = fd.read()\n        except Exception:\n            continue\n        if name in content:\n            ret.append(dirname)\n    return ret\n\ndef startAvscontrol():\n    cmd = \"nohup avscontrol.py start >/dev/null 2>&1 &\"\n    rets = i2c_getPid(\"avscontrol.py\")\n    if len(rets) == 0:\n        os.system(cmd)\n\ndef startFanctrol():\n    if STARTMODULE['fancontrol'] == 1:\n        cmd = \"nohup fancontrol.py start >/dev/null 2>&1 &\"\n        rets = i2c_getPid(\"fancontrol.py\")\n        if len(rets) == 0:\n            os.system(cmd)\n\ndef starthal_fanctrl():\n    if STARTMODULE.get('hal_fanctrl',0) == 1:\n        cmd = \"nohup hal_fanctrl.py start >/dev/null 2>&1 &\"\n        rets = i2c_getPid(\"hal_fanctrl.py\")\n        if len(rets) == 0:\n            os.system(cmd)\n\ndef starthal_ledctrl():\n    if STARTMODULE.get('hal_ledctrl',0) == 1:\n        cmd = \"nohup hal_ledctrl.py start >/dev/null 2>&1 &\"\n        rets = i2c_getPid(\"hal_ledctrl.py\")\n        if len(rets) == 0:\n            os.system(cmd)\n\ndef startDevmonitor():\n    if STARTMODULE.get('dev_monitor',0) == 1:\n        cmd = \"nohup dev_monitor.py start >/dev/null 2>&1 &\"\n        rets = i2c_getPid(\"dev_monitor.py\")\n        if len(rets) == 0:\n            os.system(cmd)\n\ndef startSlotmonitor():\n    if STARTMODULE.get('slot_monitor',0) == 1:\n        cmd = \"nohup slot_monitor.py start >/dev/null 2>&1 &\"\n        rets = i2c_getPid(\"slot_monitor.py\")\n        if len(rets) == 0:\n            os.system(cmd)\n\ndef stopFanctrol():\n    u'''disable fan timer service'''\n    if STARTMODULE['fancontrol'] == 1:\n        rets = i2c_getPid(\"fancontrol.py\")  #\n        for ret in rets:\n            cmd = \"kill \"+ ret\n            os.system(cmd)\n        return True\n\ndef stophal_ledctrl():\n    if STARTMODULE.get('hal_ledctrl',0) == 1:\n        rets = i2c_getPid(\"hal_ledctrl.py\")\n        for ret in rets:\n            cmd = \"kill \"+ ret\n            os.system(cmd)\n        return True\n\n\ndef stopDevmonitor():\n    u'''disable the fan timer service'''\n    if STARTMODULE.get('dev_monitor',0) == 1:\n        rets = i2c_getPid(\"dev_monitor.py\")  #\n        for ret in rets:\n            cmd = \"kill \"+ ret\n            os.system(cmd)\n        return True\n\ndef stopSlotmonitor():\n    u'''disable slot timer service'''\n    if STARTMODULE.get('slot_monitor',0) == 1:\n        rets = i2c_getPid(\"slot_monitor.py\")  #\n        for ret in rets:\n            cmd = \"kill \"+ ret\n            os.system(cmd)\n        return True\n\ndef removeDev(bus, loc):\n    cmd = \"echo  0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device\" % (loc, bus)\n    devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n    if os.path.exists(devpath):\n        log_os_system(cmd)\n        \ndef addDev(name, bus, loc):\n    if name == \"lm75\":\n        time.sleep(0.1)\n    pdevpath = \"/sys/bus/i2c/devices/i2c-%d/\" % (bus)\n    for i in range(1, 100):#wait for mother-bus generation\uff0cmaximum wait time is 10s\n        if os.path.exists(pdevpath) == True: \n            break\n        time.sleep(0.1)\n        if i % 10 == 0:\n            click.echo(\"%%DEVICE_I2C-INIT: %s not found, wait 0.1 second ! i %d \" % (pdevpath,i))\n            \n    cmd = \"echo  %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device\" % (name, loc, bus)\n    devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n    if os.path.exists(devpath) == False:\n        os.system(cmd)\n\ndef removedevs():\n    devs = GLOBALCONFIG[\"DEVS\"]\n    for index in range(len(devs)-1, -1, -1 ):\n        removeDev(devs[index][\"bus\"] , devs[index][\"loc\"])\n        \ndef adddevs():\n    devs = GLOBALCONFIG[\"DEVS\"]\n    for dev in range(0, devs.__len__()):\n        addDev(devs[dev][\"name\"], devs[dev][\"bus\"] , devs[dev][\"loc\"])\n\ndef checksignaldriver(name):\n    modisexistcmd = \"lsmod | grep %s | wc -l\" % name\n    status, output = log_os_system(modisexistcmd)\n    #System execution error\n    if status: \n        return False\n    if output.isdigit() and int(output) > 0:\n        return True\n    else:\n        return False\n\ndef adddriver(name, delay):\n    cmd = \"modprobe %s\" % name\n    if delay != 0:\n        time.sleep(delay)\n    if checksignaldriver(name) != True:\n        log_os_system(cmd)\n\ndef removedriver(name, delay):\n    realname = name.lstrip().split(\" \")[0];\n    cmd = \"rmmod -f %s\" % realname\n    if checksignaldriver(realname):\n        log_os_system(cmd)\n\ndef removedrivers():\n    u'''remove all drivers'''\n    if GLOBALCONFIG is None:\n        click.echo(\"%%DEVICE_I2C-INIT: load global config failed.\")\n        return\n    drivers = GLOBALCONFIG.get(\"DRIVERLISTS\", None)\n    if drivers is None:\n        click.echo(\"%%DEVICE_I2C-INIT: load driver list failed.\")\n        return \n    for index in range(len(drivers)-1, -1, -1 ):\n        delay = 0\n        name = \"\"\n        if type(drivers[index]) == dict and \"delay\" in drivers[index]:\n            name = drivers[index].get(\"name\")\n            delay = drivers[index][\"delay\"]\n        else:\n            name = drivers[index]\n        removedriver(name, delay)\n\ndef adddrivers():\n    u'''add drivers'''\n    if GLOBALCONFIG is None:\n        click.echo(\"%%DEVICE_I2C-INIT: load global config failed.\")\n        return\n    drivers = GLOBALCONFIG.get(\"DRIVERLISTS\", None)\n    if drivers is None:\n        click.echo(\"%%DEVICE_I2C-INIT: load driver list failed.\")\n        return \n    for index in range(0 ,len(drivers)):\n        delay = 0\n        name = \"\"\n        if type(drivers[index]) == dict and \"delay\" in drivers[index]:\n            name = drivers[index].get(\"name\")\n            delay = drivers[index][\"delay\"]\n        else:\n            name = drivers[index]\n        adddriver(name, delay)\n\ndef otherinit():\n    for index in GLOBALINITPARAM:\n        write_sysfs_value(index[\"loc\"], index[\"value\"])\n\n    for index in GLOBALINITCOMMAND:\n        log_os_system(index)\n    \ndef unload_driver():\n    u'''remove devices and drivers'''\n    stopDevmonitor() # disable removable device driver monitors\n    stopFanctrol()  # disable fan-control service\n    removedevs()    # remove other devices\n    removedrivers() # remove drivers\n\ndef reload_driver():\n    u'''reload devices and drivers'''\n    removedevs()    # remove other devices\n    removedrivers() # remove drivers\n    time.sleep(1)\n    adddrivers()\n    adddevs()\n\n\ndef i2c_check(bus,retrytime = 6):\n    try:\n        i2cpath = \"/sys/bus/i2c/devices/\" + bus\n        while retrytime and not os.path.exists(i2cpath):\n            click.echo(\"%%DEVICE_I2C-HA: i2c bus abnormal, last bus %s is not exist.\" % i2cpath)\n            reload_driver()\n            retrytime -= 1\n            time.sleep(1)\n    except Exception as e:\n        click.echo(\"%%DEVICE_I2C-HA: %s\" % str(e))\n    return \n\ndef MacLedSet(data):\n    '''write pci register'''\n    pcibus = MAC_LED_RESET.get(\"pcibus\")\n    slot = MAC_LED_RESET.get(\"slot\")\n    fn = MAC_LED_RESET.get(\"fn\")\n    bar = MAC_LED_RESET.get(\"bar\")\n    offset = MAC_LED_RESET.get(\"offset\")\n    val = MAC_LED_RESET.get(data, None)\n    if val is None:\n        click.echo(\"%%DEVICE_I2C-INIT: MacLedSet wrong input\")\n        return\n    rjpciwr(pcibus, slot, fn, bar, offset, val)\n\ndef load_driver():\n    u'''load devices and drivers'''\n    adddrivers()\n    adddevs()\n    if STARTMODULE.get(\"i2ccheck\",0) == 1: #i2c HA\n        busend = i2ccheck_params.get(\"busend\")\n        retrytime = i2ccheck_params.get(\"retrytime\")\n        i2c_check(busend,retrytime)\n    startFanctrol() # enable fan\n    starthal_fanctrl() # enable fan control\n    starthal_ledctrl() # enable LED control\n    if STARTMODULE['avscontrol'] == 1:\n        startAvscontrol() # avs voltage-adjustment\n    startDevmonitor() # enable removable device driver monitors\n    startSlotmonitor() # slot insertion and removal initialization monitor\n    otherinit();    # other initialization, QSFP initialization\n    if STARTMODULE.get(\"macledreset\",0) == 1:\n        MacLedSet(\"reset\")\n    \n@click.group(cls=AliasedGroup, context_settings=CONTEXT_SETTINGS)\ndef main():\n    '''device operator'''\n    pass\n\n\n@main.command()\ndef start():\n    '''load device '''\n    if check_driver():\n        unload_driver()\n    load_driver()\n\n@main.command()\ndef stop():\n    '''stop device '''\n    unload_driver()\n\n@main.command()\ndef restart():\n    '''restart device'''\n    unload_driver()\n    load_driver()\n\nif __name__ == '__main__':\n    u'''device_i2c operation'''\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py": {"changes": [{"diff": "\n                     self.fanSpeedSetMax()  # fan full speed\n                     self.critnum += 1 # anti-shake\n                     if self.critnum >= MONITOR_CONST.CRITICAL_NUM:\n-                       os.system(\"reboot\")\n+                        subprocess.call([\"reboot\"])\n                     fanwarningdebuglog(DEBUG_FANCONTROL,\"crit\u6b21\u6570:%d\" % self.critnum)\n                 else:\n                     self.critn", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py", "badparts": ["                       os.system(\"reboot\")"], "goodparts": ["                        subprocess.call([\"reboot\"])"]}]}, "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py": {"changes": [{"diff": "\n import sys\n import os\n import re\n-import subprocess\n import syslog\n import time\n import binascii\n", "add": 0, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["import subprocess"], "goodparts": []}, {"diff": "\n \n def getSdkReg(reg):\n     try:\n-        cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg\n-        ret, result = rj_os_system(cmd)\n+        cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]\n+        ret, result = getstatusoutput_noshell(cmd)\n         result_t = result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n         if ret != 0 or \"Error:\" in result_t:\n             return False, result\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["        cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg", "        ret, result = rj_os_system(cmd)"], "goodparts": ["        cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]", "        ret, result = getstatusoutput_noshell(cmd)"]}, {"diff": "\n     result = {}\n     #waitForDocker()\n     # exec twice, get the second result\n-    rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n-    ret, log = rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n+    getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n+    ret, log = getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n     if ret:\n         return False, result\n     else:\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")", "    ret, log = rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")"], "goodparts": ["    getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])", "    ret, log = getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])"]}, {"diff": "\n \n def restartDockerService(force=False):\n     container_name = [\"database\",\"snmp\",\"syncd\",\"swss\",\"dhcp_relay\",\"radv\",\"teamd\",\"pmon\"]\n-    ret, status = rj_os_system(\"docker ps\")\n+    ret, status = getstatusoutput_noshell([\"docker\", \"ps\"])\n     if ret == 0 :\n         for tmpname in container_name:\n             if (tmpname not in status):\n                 if (force == True):\n-                    rj_os_system(\"docker restart %s\"%tmpname)\n+                    getstatusoutput_noshell([\"docker\", \"restart\", tmpname])\n                 else:\n-                    rj_os_system(\"systemctl restart %s\"%tmpname)\n+                    getstatusoutput_noshell([\"systemctl\", \"restart\", tmpname])\n \n \n def waitForDhcp(timeout):\n     time_cnt = 0\n     while True:\n         try:\n-            ret, status = rj_os_system(\"systemctl status dhcp_relay.service\")\n+            ret, status = getstatusoutput_noshell([\"systemctl\", \"status\", \"dhcp_relay.service\"])\n             if (ret == 0 and \"running\" in status)  or \"SUCCESS\" in status:\n                 break\n             else:\n", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    ret, status = rj_os_system(\"docker ps\")", "                    rj_os_system(\"docker restart %s\"%tmpname)", "                    rj_os_system(\"systemctl restart %s\"%tmpname)", "            ret, status = rj_os_system(\"systemctl status dhcp_relay.service\")"], "goodparts": ["    ret, status = getstatusoutput_noshell([\"docker\", \"ps\"])", "                    getstatusoutput_noshell([\"docker\", \"restart\", tmpname])", "                    getstatusoutput_noshell([\"systemctl\", \"restart\", tmpname])", "            ret, status = getstatusoutput_noshell([\"systemctl\", \"status\", \"dhcp_relay.service\"])"]}, {"diff": "\n     rulefile = \"/etc/udev/rules.d/70-persistent-net.rules\"\n     if isValidMac(mac) == False:\n         return False, \"MAC invaild\"\n-    cmd = \"ethtool -e %s | grep 0x0010 | awk '{print \\\"0x\\\"$13$12$15$14}'\" % eth\n-    ret, log = rj_os_system(cmd)\n+    cmd1 = [\"ethtool\", \"-e\", eth] \n+    cmd2 = [\"grep\", \"0x0010\"]\n+    cmd3 = [\"awk\", '{print \\\"0x\\\"$13$12$15$14}']\n+    ret, log = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)\n     log_debug(log)\n     magic = \"\"\n     if ret == 0 and len(log):\n", "add": 4, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    cmd = \"ethtool -e %s | grep 0x0010 | awk '{print \\\"0x\\\"$13$12$15$14}'\" % eth", "    ret, log = rj_os_system(cmd)"], "goodparts": ["    cmd1 = [\"ethtool\", \"-e\", eth] ", "    cmd2 = [\"grep\", \"0x0010\"]", "    cmd3 = [\"awk\", '{print \\\"0x\\\"$13$12$15$14}']", "    ret, log = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)"]}, {"diff": "\n     macs = mac.upper().split(\":\")\n \n     # chage ETH0 to value after setmac\n-    ifconfigcmd = \"ifconfig eth0 hw ether %s\" % mac\n-    log_debug(ifconfigcmd)\n-    ret, status = rj_os_system(ifconfigcmd)\n+    ifconfigcmd = [\"ifconfig\", \"eth0\", \"hw\", \"ether\", mac]\n+    log_debug(' '.join(ifconfigcmd))\n+    ret, status = getstatusoutput_noshell(ifconfigcmd)\n     if ret:\n         raise SETMACException(\"software set  Internet cardMAC error\")\n     index = 0\n     for item in macs:\n-        cmd = \"ethtool -E %s magic %s offset %d value 0x%s\" % (\n-            eth, magic, index, item)\n+        cmd = [\"ethtool\", \"-E\", eht, \"magic\", magic, \"offset\", str(index), \"value\", \"0x\"+item]\n         log_debug(cmd)\n         index += 1\n-        ret, log = rj_os_system(cmd)\n+        ret, log = getstatusoutput_noshell(cmd)\n         if ret != 0:\n             raise SETMACException(\" set hardware Internet card MAC error\")\n     # get value after setting \n-    cmd_t = \"ethtool -e eth0 offset 0 length 6\"\n-    ret, log = rj_os_system(cmd_t)\n+    cmd_t = [\"ethtool\", \"-e\", \"eth0\", \"offset\", \"0\", \"length\", \"6\"]\n+    ret, log = getstatusoutput_noshell(cmd_t)\n     m = re.split(':', log)[-1].strip().upper()\n     mac_result = m.upper().split(\" \")\n \n", "add": 7, "remove": 8, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    ifconfigcmd = \"ifconfig eth0 hw ether %s\" % mac", "    log_debug(ifconfigcmd)", "    ret, status = rj_os_system(ifconfigcmd)", "        cmd = \"ethtool -E %s magic %s offset %d value 0x%s\" % (", "            eth, magic, index, item)", "        ret, log = rj_os_system(cmd)", "    cmd_t = \"ethtool -e eth0 offset 0 length 6\"", "    ret, log = rj_os_system(cmd_t)"], "goodparts": ["    ifconfigcmd = [\"ifconfig\", \"eth0\", \"hw\", \"ether\", mac]", "    log_debug(' '.join(ifconfigcmd))", "    ret, status = getstatusoutput_noshell(ifconfigcmd)", "        cmd = [\"ethtool\", \"-E\", eht, \"magic\", magic, \"offset\", str(index), \"value\", \"0x\"+item]", "        ret, log = getstatusoutput_noshell(cmd)", "    cmd_t = [\"ethtool\", \"-e\", \"eth0\", \"offset\", \"0\", \"length\", \"6\"]", "    ret, log = getstatusoutput_noshell(cmd_t)"]}, {"diff": "\n \n \n def rji2cget(bus, devno, address):\n-    command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)\n+    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address)]\n     retrytime = 6\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n         time.sleep(0.1)\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)", "        ret, ret_t = rj_os_system(command_line)"], "goodparts": ["    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address)]", "        ret, ret_t = getstatusoutput_noshell(command_line)"]}, {"diff": "\n \n \n def rji2cset(bus, devno, address, byte):\n-    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (\n-        bus, devno, address, byte)\n+    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%02x\"%str(byte)]\n     retrytime = 6\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n     return False, ret_t\n", "add": 2, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (", "        bus, devno, address, byte)", "        ret, ret_t = rj_os_system(command_line)"], "goodparts": ["    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%02x\"%str(byte)]", "        ret, ret_t = getstatusoutput_noshell(command_line)"]}, {"diff": "\n     data.close()\n \n def rjsysset(location, value):\n-    command_line = \"echo 0x%02x > %s\" % (value, location)\n     retrytime = 6\n-    ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n-        if ret == 0:\n-            return True, ret_t\n-    return False, ret_t\n+        try:\n+            with open(location, 'w') as f:\n+                f.write('0x%02x\\n'%value)\n+        except (IOError, FileNotFoundError) as e:\n+            return False, str(e)\n+    return True, ''\n \n \n def rji2cgetWord(bus, devno, address):\n-    command_line = \"i2cget -f -y %d 0x%02x 0x%02x w\" % (bus, devno, address)\n+    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"w\"]\n     retrytime = 3\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n     return False, ret_t\n \n \n def rji2csetWord(bus, devno, address, byte):\n-    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%x w\" % (\n-        bus, devno, address, byte)\n-    rj_os_system(command_line)\n+    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%x\"%str(byte), \"w\"]\n+    getstatusoutput_noshell(command_line)\n \n \n def fan_setmac():\n", "add": 10, "remove": 11, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    command_line = \"echo 0x%02x > %s\" % (value, location)", "    ret_t = \"\"", "        ret, ret_t = rj_os_system(command_line)", "        if ret == 0:", "            return True, ret_t", "    return False, ret_t", "    command_line = \"i2cget -f -y %d 0x%02x 0x%02x w\" % (bus, devno, address)", "        ret, ret_t = rj_os_system(command_line)", "    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%x w\" % (", "        bus, devno, address, byte)", "    rj_os_system(command_line)"], "goodparts": ["        try:", "            with open(location, 'w') as f:", "                f.write('0x%02x\\n'%value)", "        except (IOError, FileNotFoundError) as e:", "            return False, str(e)", "    return True, ''", "    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"w\"]", "        ret, ret_t = getstatusoutput_noshell(command_line)", "    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%x\"%str(byte), \"w\"]", "    getstatusoutput_noshell(command_line)"]}, {"diff": "\n     elif dealtype == \"io\":\n         io_wr(E2_PROTECT[\"io_addr\"], E2_PROTECT[\"close\"])\n     # deal last drivers\n-    os.system(\"rmmod at24 \")\n-    os.system(\"modprobe at24 \")\n-    os.system(\"rm -f /var/cache/sonic/decode-syseeprom/syseeprom_cache\")\n+    getstatusoutput_noshell([\"rmmod\", \"at24\"])\n+    getstatusoutput_noshell([\"modprobe\", \"at24\"])\n+    getstatusoutput_noshell([\"rm\", \"-f\", \"/var/cache/sonic/decode-syseeprom/syseeprom_cache\"])\n \n \n def get_local_eth0_mac():\n-    cmd = \"ifconfig eth0 |grep HWaddr\"\n-    print(rj_os_system(cmd))\n+    cmd1 = [\"ifconfig\", \"eth0\"]\n+    cmd2 = [\"grep\", \"HWaddr\"]\n+    print(getstatusoutput_noshell_pipe(cmd1, cmd2))\n \n def getonieversion():\n     if not os.path.isfile('/host/machine.conf'):\n", "add": 6, "remove": 5, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    os.system(\"rmmod at24 \")", "    os.system(\"modprobe at24 \")", "    os.system(\"rm -f /var/cache/sonic/decode-syseeprom/syseeprom_cache\")", "    cmd = \"ifconfig eth0 |grep HWaddr\"", "    print(rj_os_system(cmd))"], "goodparts": ["    getstatusoutput_noshell([\"rmmod\", \"at24\"])", "    getstatusoutput_noshell([\"modprobe\", \"at24\"])", "    getstatusoutput_noshell([\"rm\", \"-f\", \"/var/cache/sonic/decode-syseeprom/syseeprom_cache\"])", "    cmd1 = [\"ifconfig\", \"eth0\"]", "    cmd2 = [\"grep\", \"HWaddr\"]", "    print(getstatusoutput_noshell_pipe(cmd1, cmd2))"]}, {"diff": "\n \n def ipmi_set_mac(mac):\n     macs = mac.split(\":\")\n-    cmdinit = \"ipmitool raw 0x0c 0x01 0x01 0xc2 0x00\"\n-    cmdset = \"ipmitool raw 0x0c 0x01 0x01 0x05\"\n+    cmdinit = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0xc2\", \"0x00\"]\n+    cmdset = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0x05\"]\n     for ind in range(len(macs)):\n-        cmdset += \" 0x%02x\" % int(macs[ind], 16)\n-    rj_os_system(cmdinit)\n-    ret, status = rj_os_system(cmdset)\n+        cmdset.append(\"0x%02x\" % int(macs[ind], 16))\n+    getstatusoutput_noshell(cmdinit)\n+    ret, status = getstatusoutput_noshell(cmdset)\n     if ret:\n         RJPRINTERR(\"\\n\\n%s\\n\\n\" % status)\n         return False\n", "add": 5, "remove": 5, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    cmdinit = \"ipmitool raw 0x0c 0x01 0x01 0xc2 0x00\"", "    cmdset = \"ipmitool raw 0x0c 0x01 0x01 0x05\"", "        cmdset += \" 0x%02x\" % int(macs[ind], 16)", "    rj_os_system(cmdinit)", "    ret, status = rj_os_system(cmdset)"], "goodparts": ["    cmdinit = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0xc2\", \"0x00\"]", "    cmdset = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0x05\"]", "        cmdset.append(\"0x%02x\" % int(macs[ind], 16))", "    getstatusoutput_noshell(cmdinit)", "    ret, status = getstatusoutput_noshell(cmdset)"]}, {"diff": "\n     log_info(\"disable LLDP\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n-    rj_os_system(\"systemctl stop lldp.service\")\n+    getstatusoutput_noshell([\"systemctl\", \"stop\", \"lldp.service\"])\n     log_info(\"disable lldp service\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n-    rj_os_system(\"systemctl stop bgp.service\")\n+    getstatusoutput_noshell([\"systemctl\", \"stop\", \"bgp.service\"])\n     log_info(\"disable bgp service\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    rj_os_system(\"systemctl stop lldp.service\")", "    rj_os_system(\"systemctl stop bgp.service\")"], "goodparts": ["    getstatusoutput_noshell([\"systemctl\", \"stop\", \"lldp.service\"])", "    getstatusoutput_noshell([\"systemctl\", \"stop\", \"bgp.service\"])"]}, {"diff": "\n     with open(file_name, \"w\") as f:\n         f.write(file_data)\n     print(\"change SDK memory to 256, reboot required\")\n-    rj_os_system(\"sync\")\n-    rj_os_system(\"reboot\")\n+    getstatusoutput_noshell([\"sync\"])\n+    getstatusoutput_noshell([\"reboot\"])\n \n ##########################################################################\n # receives a character setting\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    rj_os_system(\"sync\")", "    rj_os_system(\"reboot\")"], "goodparts": ["    getstatusoutput_noshell([\"sync\"])", "    getstatusoutput_noshell([\"reboot\"])"]}, {"diff": "\n             return item.get('value',None)\n     return None\n \n-# ====================================\n-# execute shell command\n-# ====================================\n-def rj_os_system(cmd):\n-    status, output = subprocess.getstatusoutput(cmd)\n-    return status, output\n \n ###########################################\n # get memory slot and number via DMI command\n ###########################################\n def getsysmeminfo():\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \"|grep -P -A5 \\\"Memory\\s+Device\\\"|grep Size|grep -v Range\"\n+    cmd1 = [log[0].rstrip('\\n')]\n+    cmd2 = [\"grep\", \"-P\", \"-A5\", \"Memory\\s+Device\"]\n+    cmd3 = [\"grep\", \"Size\"]\n+    cmd4 = [\"grep\", \"-v\", \"Range\"]\n     # get total number first\n     result = []\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3, cmd4)\n     if ret1 == 0 and len(log1):\n         log1 = log1.lstrip()\n         arr = log1.split(\"\\n\")\n", "add": 6, "remove": 9, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["def rj_os_system(cmd):", "    status, output = subprocess.getstatusoutput(cmd)", "    return status, output", "    ret, log = rj_os_system(\"which dmidecode \")", "    cmd = log + \"|grep -P -A5 \\\"Memory\\s+Device\\\"|grep Size|grep -v Range\"", "    ret1, log1 = rj_os_system(cmd)"], "goodparts": ["    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])", "    cmd1 = [log[0].rstrip('\\n')]", "    cmd2 = [\"grep\", \"-P\", \"-A5\", \"Memory\\s+Device\"]", "    cmd3 = [\"grep\", \"Size\"]", "    cmd4 = [\"grep\", \"-v\", \"Range\"]", "    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3, cmd4)"]}, {"diff": "\n # return various arrays\n ###########################################\n def getsysmeminfo_detail():\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \" -t 17 | grep  -A21 \\\"Memory Device\\\"\"  # 17\n+    cmd1 = [log[0].rstrip('\\n')] + [\"-t\", \"17\"]\n+    cmd2 = [\"grep\", \"-A21\", \"Memory Device\"]  # 17\n     # get total number\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)\n     if ret1 != 0 or len(log1) <= 0:\n-        return False, \"command execution error[%s]\" % cmd\n+        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)\n     result_t = log1.split(\"--\")\n     mem_rets = []\n     for item in result_t:\n", "add": 5, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    ret, log = rj_os_system(\"which dmidecode \")", "    cmd = log + \" -t 17 | grep  -A21 \\\"Memory Device\\\"\"  # 17", "    ret1, log1 = rj_os_system(cmd)", "        return False, \"command execution error[%s]\" % cmd"], "goodparts": ["    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])", "    cmd1 = [log[0].rstrip('\\n')] + [\"-t\", \"17\"]", "    cmd2 = [\"grep\", \"-A21\", \"Memory Device\"]  # 17", "    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)", "        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)"]}, {"diff": "\n # get BIOS info via DMI command\n ###########################################\n def getDmiSysByType(type_t):\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \" -t %s\" % type_t\n+    cmd = [log[0].rstrip('\\n')] + [\"-t\", str(type_t)]\n     # get total number\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell(cmd)\n     if ret1 != 0 or len(log1) <= 0:\n         return False, \"command execution error[%s]\" % cmd\n     its = log1.replace(\"\\t\", \"\").strip().split(\"\\n\")\n", "add": 3, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    ret, log = rj_os_system(\"which dmidecode \")", "    cmd = log + \" -t %s\" % type_t", "    ret1, log1 = rj_os_system(cmd)"], "goodparts": ["    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])", "    cmd = [log[0].rstrip('\\n')] + [\"-t\", str(type_t)]", "    ret1, log1 = getstatusoutput_noshell(cmd)"]}, {"diff": "\n         return False, \"Err\"\n \n def get_cpu_info():\n-    cmd = \"cat /proc/cpuinfo |grep processor -A18\"  # 17\n+    cmd1 = [\"cat\", \"/proc/cpuinfo\"]\n+    cmd2 = [\"grep\", \"processor\", \"-A18\"]  # 17\n \n-    ret, log1 = rj_os_system(cmd)\n+    ret, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)\n     if ret != 0 or len(log1) <= 0:\n-        return False, \"command execution error[%s]\" % cmd\n+        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)\n     result_t = log1.split(\"--\")\n     mem_rets = []\n     for item in result_t:\n", "add": 4, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    cmd = \"cat /proc/cpuinfo |grep processor -A18\"  # 17", "    ret, log1 = rj_os_system(cmd)", "        return False, \"command execution error[%s]\" % cmd"], "goodparts": ["    cmd1 = [\"cat\", \"/proc/cpuinfo\"]", "    cmd2 = [\"grep\", \"processor\", \"-A18\"]  # 17", "    ret, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)", "        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)"]}]}}, "msg": "[ruijie] Replace os.system and remove subprocess with shell=True (#12107)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\nDependency: [https://github.com/sonic-net/sonic-buildimage/pull/12065](https://github.com/sonic-net/sonic-buildimage/pull/12065)\r\n#### Why I did it\r\n1. `getstatusoutput` is used without a static string and it uses `shell=True`\r\n2. `subprocess()` - when using with `shell=True` is dangerous. Using subprocess function without a static string can lead to command injection.\r\n3. `os` - not secure against maliciously constructed input and dangerous if used to evaluate dynamic content.\r\n#### How I did it\r\n1. use `getstatusoutput` without shell=True\r\n2. `subprocess()` - use `shell=False` instead. use an array string. Ref: [https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation](https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation)\r\n3. `os` - use with `subprocess`"}, "51a1eb112b8a3e00b4c5857afb470bb0e4d24433": {"url": "https://api.github.com/repos/sonic-net/sonic-buildimage/commits/51a1eb112b8a3e00b4c5857afb470bb0e4d24433", "html_url": "https://github.com/sonic-net/sonic-buildimage/commit/51a1eb112b8a3e00b4c5857afb470bb0e4d24433", "sha": "51a1eb112b8a3e00b4c5857afb470bb0e4d24433", "keyword": "command injection attack", "diff": "diff --git a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py\nindex 4b081f4e3ceb..35c045dad384 100644\n--- a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py\n+++ b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py\n@@ -24,7 +24,6 @@\n RESET_REGISTER = \"0x112\"\n HOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/previous-reboot-cause.txt\"\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n STATUS_LED_PATH = \"/sys/devices/platform/e1031.smc/master_led\"\n \n \ndiff --git a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py\nindex 08e8fc41475c..7d3b37e36597 100644\n--- a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py\n+++ b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py\n@@ -1,8 +1,8 @@\n import os\r\n+import ast\r\n import imp\r\n import yaml\r\n import subprocess\r\n-\r\n from sonic_py_common import device_info\r\n \r\n \r\n@@ -24,7 +24,7 @@ class Common:\n \r\n     SET_METHOD_IPMI = 'ipmitool'\r\n     NULL_VAL = 'N/A'\r\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\r\n+    HOST_CHK_CMD = [\"docker\"]\r\n     REF_KEY = '$ref:'\r\n \r\n     def __init__(self, conf=None):\r\n@@ -46,8 +46,7 @@ def run_command(self, command):\n         status = False\r\n         output = \"\"\r\n         try:\r\n-            p = subprocess.Popen(\r\n-                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n+            p = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n             raw_data, err = p.communicate()\r\n             if p.returncode == 0:\r\n                 status, output = True, raw_data.strip()\r\n@@ -67,7 +66,7 @@ def _clean_input(self, input, config):\n             cleaned_input = input_translator.get(input)\r\n \r\n         elif type(input_translator) is str:\r\n-            cleaned_input = eval(input_translator.format(input))\r\n+            cleaned_input = ast.literal_eval(input_translator.format(input))\r\n \r\n         return cleaned_input\r\n \r\n@@ -77,19 +76,12 @@ def _clean_output(self, index, output, config):\n         if type(output_translator) is dict:\r\n             output = output_translator.get(output)\r\n         elif type(output_translator) is str:\r\n-            output = eval(output_translator.format(output))\r\n+            output = ast.literal_eval(output_translator.format(output))\r\n         elif type(output_translator) is list:\r\n-            output = eval(output_translator[index].format(output))\r\n+            output = ast.literal_eval(output_translator[index].format(output))\r\n \r\n         return output\r\n \r\n-    def _ipmi_get(self, index, config):\r\n-        argument = config.get('argument')\r\n-        cmd = config['command'].format(\r\n-            config['argument'][index]) if argument else config['command']\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n-\r\n     def _sysfs_read(self, index, config):\r\n         sysfs_path = config.get('sysfs_path')\r\n         argument = config.get('argument', '')\r\n@@ -132,10 +124,6 @@ def _sysfs_write(self, index, config, input):\n             return False, output\r\n         return True, output\r\n \r\n-    def _ipmi_set(self, index, config, input):\r\n-        arg = config['argument'][index].format(input)\r\n-        return self.run_command(config['command'].format(arg))\r\n-\r\n     def _hex_ver_decode(self, hver, num_of_bits, num_of_points):\r\n         ver_list = []\r\n         c_bit = 0\r\n@@ -159,14 +147,16 @@ def _get_class(self, config):\n         return class_\r\n \r\n     def get_reg(self, path, reg_addr):\r\n-        cmd = \"echo {1} > {0}; cat {0}\".format(path, reg_addr)\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n+        with open(path, 'w') as file:\r\n+            file.write(reg_addr + '\\n')\r\n+        with open(path, 'r') as file:\r\n+            output = file.readline().strip()\r\n+        return output\r\n \r\n     def set_reg(self, path, reg_addr, value):\r\n-        cmd = \"echo {0} {1} > {2}\".format(reg_addr, value, path)\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n+        with open(path, 'w') as file:\r\n+            file.write(\"{0} {1}\\n\".format(reg_addr, value))\r\n+        return None\r\n \r\n     def read_txt_file(self, path):\r\n         try:\r\n@@ -195,7 +185,11 @@ def write_txt_file(self, file_path, value):\n         return True\r\n \r\n     def is_host(self):\r\n-        return os.system(self.HOST_CHK_CMD) == 0\r\n+        try:\r\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\r\n+        except FileNotFoundError:\r\n+            return False\r\n+        return True\r\n \r\n     def load_json_file(self, path):\r\n         \"\"\"\r\n@@ -221,87 +215,6 @@ def get_config_path(self, config_name):\n         \"\"\"\r\n         return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\r\n \r\n-    def get_output(self, index, config, default):\r\n-        \"\"\"\r\n-        Retrieves the output for each function base on config\r\n-\r\n-        Args:\r\n-            index: An integer containing the index of device.\r\n-            config: A dict object containing the configuration of specified function.\r\n-            default: A string containing the default output of specified function.\r\n-\r\n-        Returns:\r\n-            A string containing the output of specified function in config\r\n-        \"\"\"\r\n-        output_source = config.get('output_source')\r\n-\r\n-        if output_source == self.OUTPUT_SOURCE_IPMI:\r\n-            output = self._ipmi_get(index, config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VALUE:\r\n-            output = config[\"value\"]\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_CLASS:\r\n-            output = self._get_class(config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_LIST:\r\n-            output = config[\"value_list\"][index]\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_SYSFS:\r\n-            output = self._sysfs_read(index, config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_FUNC:\r\n-            func_conf = self._main_conf[config['function'][index]]\r\n-            output = self.get_output(index, func_conf, default)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\r\n-            path = config.get('path')\r\n-            output = self.read_txt_file(path)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\r\n-            path = config.get('path')\r\n-            hex_ver = self.read_txt_file(path)\r\n-            output = self._hex_ver_decode(\r\n-                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\r\n-            path = config.get('path')\r\n-            addr = config.get('reg_addr')\r\n-            hex_ver = self.get_reg(path, addr)\r\n-            output = self._hex_ver_decode(\r\n-                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n-\r\n-        else:\r\n-            output = default\r\n-\r\n-        return self._clean_output(index, output, config) or default\r\n-\r\n-    def set_output(self, index, input, config):\r\n-        \"\"\"\r\n-        Sets the output of specified function on config\r\n-\r\n-        Args:\r\n-            config: A dict object containing the configuration of specified function.\r\n-            index: An integer containing the index of device.\r\n-            input: A string containing the input of specified function.\r\n-\r\n-        Returns:\r\n-            bool: True if set function is successfully, False if not\r\n-        \"\"\"\r\n-        cleaned_input = self._clean_input(input, config)\r\n-        if not cleaned_input:\r\n-            return False\r\n-\r\n-        set_method = config.get('set_method')\r\n-        if set_method == self.SET_METHOD_IPMI:\r\n-            output = self._ipmi_set(index, config, cleaned_input)[0]\r\n-        elif set_method == self.OUTPUT_SOURCE_SYSFS:\r\n-            output = self._sysfs_write(index, config, cleaned_input)[0]\r\n-        else:\r\n-            output = False\r\n-\r\n-        return output\r\n-\r\n     def get_event(self, timeout, config, sfp_list):\r\n         \"\"\"\r\n         Returns a nested dictionary containing all devices which have\r\ndiff --git a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py\nindex 56fae35914ab..6e33e334018d 100644\n--- a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py\n+++ b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py\n@@ -10,7 +10,6 @@\n try:\n     import os.path\n     import shutil\n-    import shlex\n     import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n except ImportError as e:\n@@ -39,8 +38,7 @@ def __init__(self, component_index):\n     def __run_command(self, command):\n         # Run bash command and print output to stdout\n         try:\n-            process = subprocess.Popen(\n-                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n+            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n             while True:\n                 output = process.stdout.readline()\n                 if output == '' and process.poll() is not None:\n@@ -63,12 +61,10 @@ def __get_bios_version(self):\n \n     def get_register_value(self, register):\n         # Retrieves the cpld register value\n-        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n-        p = subprocess.Popen(\n-            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-        raw_data, err = p.communicate()\n-        if err is not '':\n-            return None\n+        with open(GETREG_PATH, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(GETREG_PATH, 'r') as file:\n+            raw_data = file.readline()\n         return raw_data.strip()\n \n     def __get_cpld_version(self):\n@@ -76,11 +72,11 @@ def __get_cpld_version(self):\n         cpld_version = dict()\n         with open(SMC_CPLD_PATH, 'r') as fd:\n             smc_cpld_version = fd.read()\n-        smc_cpld_version = 'None' if smc_cpld_version is 'None' else \"{}.{}\".format(\n+        smc_cpld_version = 'None' if smc_cpld_version == 'None' else \"{}.{}\".format(\n             int(smc_cpld_version[2], 16), int(smc_cpld_version[3], 16))\n \n         mmc_cpld_version = self.get_register_value(MMC_CPLD_ADDR)\n-        mmc_cpld_version = 'None' if mmc_cpld_version is 'None' else \"{}.{}\".format(\n+        mmc_cpld_version = 'None' if mmc_cpld_version == 'None' else \"{}.{}\".format(\n             int(mmc_cpld_version[2], 16), int(mmc_cpld_version[3], 16))\n \n         cpld_version[\"SMC_CPLD\"] = smc_cpld_version\n@@ -159,7 +155,7 @@ def install_firmware(self, image_path):\n             ext = \".vme\" if ext == \"\" else ext\n             new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n             shutil.copy(image_path, new_image_path)\n-            install_command = \"ispvm %s\" % new_image_path\n+            install_command = [\"ispvm\", str(new_image_path)]\n         # elif self.name == \"BIOS\":\n         #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n         return self.__run_command(install_command)\ndiff --git a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py\nindex 75307d291496..144fdae2156d 100644\n--- a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py\n+++ b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py\n@@ -73,6 +73,5 @@ def execute(self, thermal_info_dict):\n         thermal_overload_position = Common().read_txt_file(\r\n             thermal_overload_position_path)\r\n \r\n-        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\r\n-            thermal_overload_position)\r\n+        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', thermal_overload_position]\r\n         Common().run_command(cmd)\r\ndiff --git a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py\nindex 2e379f8c2a2d..28e113fb7e35 100644\n--- a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py\n+++ b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py\n@@ -6,7 +6,7 @@\n \n \n class ThermalManager(ThermalManagerBase):\n-    FSC_ALGORITHM_CMD = ' supervisorctl {} fancontrol'\n+    FSC_ALGORITHM_CMD = ['supervisorctl', '', 'fancontrol']\n \n     @classmethod\n     def start_thermal_control_algorithm(cls):\n@@ -43,5 +43,5 @@ def _enable_fancontrol_service(cls, enable):\n         Returns:\n             bool: True if set success, False if fail.\n         \"\"\"\n-        cmd = 'start' if enable else 'stop'\n-        return Common().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n+        cls.FSC_ALGORITHM_CMD[1] = 'start' if enable else 'stop'\n+        return Common().run_command(cls.FSC_ALGORITHM_CMD)\ndiff --git a/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py b/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py\nindex 0c93576e1fba..13c19841eda9 100644\n--- a/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py\n+++ b/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py\n@@ -6,8 +6,6 @@\n #\n #############################################################################\n \n-import os.path\n-import subprocess\n \n try:\n     from sonic_psu.psu_base import PsuBase\ndiff --git a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py\nindex 8a9ed17139df..2fc2c60fdc34 100644\n--- a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py\n+++ b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py\n@@ -26,7 +26,6 @@\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n GETREG_PATH = \"/sys/devices/platform/dx010_cpld/getreg\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n STATUS_LED_PATH = \"/sys/devices/platform/leds_dx010/leds/dx010:green:stat/brightness\"\n \n \ndiff --git a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py\nindex 782708025ab6..da735d2ac097 100644\n--- a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py\n+++ b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py\n@@ -8,7 +8,6 @@\n \n import os.path\n import shutil\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -52,12 +51,10 @@ def __get_bios_version(self):\n \n     def get_register_value(self, register):\n         # Retrieves the cpld register value\n-        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n-        p = subprocess.Popen(\n-            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-        raw_data, err = p.communicate()\n-        if err is not '':\n-            return None\n+        with open(GETREG_PATH, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(GETREG_PATH, 'r') as file:\n+            raw_data = file.readline()\n         return raw_data.strip()\n \n     def __get_cpld_version(self):\n@@ -146,11 +143,11 @@ def install_firmware(self, image_path):\n             ext = \".vme\" if ext == \"\" else ext\n             new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n             shutil.copy(image_path, new_image_path)\n-            install_command = \"ispvm %s\" % new_image_path\n+            install_command = [\"ispvm\", str(new_image_path)]\n         # elif self.name == \"BIOS\":\n         #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n \n-        return self.__run_command(install_command)\n+        return self._api_helper.run_command(install_command)\n \n \n     def update_firmware(self, image_path):\ndiff --git a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py\nindex 140c62c08666..a77d27837e7a 100644\n--- a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py\n+++ b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py\n@@ -5,7 +5,7 @@\n \n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -15,7 +15,11 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -35,7 +39,7 @@ def run_command(self, cmd):\n         result = \"\"\n         try:\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = raw_data.strip()\n@@ -43,13 +47,6 @@ def run_command(self, cmd):\n             status = False\n         return status, result\n \n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n@@ -77,57 +74,9 @@ def write_txt_file(self, file_path, value):\n         return True\n \n     def get_cpld_reg_value(self, getreg_path, register):\n-        cmd = \"echo {1} > {0}; cat {0}\".format(getreg_path, register)\n-        status, result = self.run_command(cmd)\n-        return result if status else None\n+        with open(getreg_path, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(getreg_path, 'r') as file:\n+            result = file.readline()\n+        return result\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(\n-                str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status, result\ndiff --git a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py\nindex 545db861f683..fc55445d0eb1 100644\n--- a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py\n+++ b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py\n@@ -73,6 +73,5 @@ def execute(self, thermal_info_dict):\n         thermal_overload_position = APIHelper().read_one_line_file(\n             thermal_overload_position_path)\n \n-        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\n-            thermal_overload_position)\n+        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', str(thermal_overload_position)]\n         APIHelper().run_command(cmd)\ndiff --git a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py\nindex 9f057cf1f37f..dfd4abc40b32 100644\n--- a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py\n+++ b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py\n@@ -5,7 +5,7 @@\n from .thermal_infos import *\n \n class ThermalManager(ThermalManagerBase):\n-    FSC_ALGORITHM_CMD = 'service fancontrol {}'\n+    FSC_ALGORITHM_CMD = ['service', 'fancontrol', '']\n \n     @classmethod\n     def start_thermal_control_algorithm(cls):\n@@ -42,5 +42,5 @@ def _enable_fancontrol_service(cls, enable):\n         Returns:\n             bool: True if set success, False if fail.\n         \"\"\"\n-        cmd = 'start' if enable else 'stop'\n-        return APIHelper().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n+        cls.FSC_ALGORITHM_CMD[2] = 'start' if enable else 'stop'\n+        return APIHelper().run_command(cls.FSC_ALGORITHM_CMD)\ndiff --git a/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py b/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py\nindex cc5461ccb5d4..2eb92eb919e6 100644\n--- a/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py\n+++ b/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py\n@@ -1,10 +1,9 @@\n-import os.path\n-import subprocess\n import sys\n import re\n \n try:\n     from sonic_psu.psu_base import PsuBase\n+    from sonic_py_common.general import getstatusoutput_noshell_pipe\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -13,16 +12,16 @@ class PsuUtil(PsuBase):\n     \"\"\"Platform-specific PSUutil class\"\"\"\n \n     def __init__(self):\n-        self.ipmi_sensor = \"ipmitool sensor\"\n+        self.ipmi_sensor = [\"ipmitool\", \"sensor\"]\n         PsuBase.__init__(self)\n \n-    def run_command(self, command):\n-        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n-        (out, err) = proc.communicate()\n-\n-        if proc.returncode != 0:\n-            sys.exit(proc.returncode)\n-\n+    def run_command(self, cmd1, cmd2):\n+        exitcode, out = getstatusoutput_noshell_pipe(cmd1, cmd2)\n+        i = 0\n+        while i < 2:\n+            if exitcode[i] != 0:\n+                sys.exit(exitcode[i])\n+            i += 1\n         return out\n \n     def find_value(self, grep_string):\n@@ -50,7 +49,8 @@ def get_psu_status(self, index):\n             return False\n \n         grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n-        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n+        grep_cmd = [\"grep\", grep_key]\n+        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)\n         status_byte = self.find_value(grep_string)\n \n         if status_byte is None:\n@@ -74,7 +74,8 @@ def get_psu_presence(self, index):\n             return False\n \n         grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n-        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n+        grep_cmd = [\"grep\", grep_key]\n+        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)\n         status_byte = self.find_value(grep_string)\n \n         if status_byte is None:\ndiff --git a/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py b/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py\nindex ca75ad98334c..46684aae0f22 100644\n--- a/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py\n+++ b/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py\n@@ -1,4 +1,3 @@\n-import os.path\n import subprocess\n import sys\n import re\n@@ -13,13 +12,13 @@ class PsuUtil(PsuBase):\n     \"\"\"Platform-specific PSUutil class\"\"\"\n \n     def __init__(self):\n-        self.ipmi_raw = \"docker exec -ti pmon ipmitool raw 0x4 0x2d\"\n+        self.ipmi_raw = [\"docker\", \"exec\", \"-ti\", \"pmon\", \"ipmitool\", \"raw\", \"0x4\", \"0x2d\", \"\"]\n         self.psu1_id = \"0x2f\"\n         self.psu2_id = \"0x39\"\n         PsuBase.__init__(self)\n \n     def run_command(self, command):\n-        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n         (out, err) = proc.communicate()\n \n         if proc.returncode != 0:\n@@ -52,7 +51,8 @@ def get_psu_status(self, index):\n             return False\n \n         psu_id = self.psu1_id if index == 1 else self.psu2_id\n-        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n+        self.ipmi_raw[8] = psu_id\n+        res_string = self.run_command(self.ipmi_raw)\n         status_byte = self.find_value(res_string)\n \n         if status_byte is None:\n@@ -76,7 +76,8 @@ def get_psu_presence(self, index):\n             return False\n \n         psu_id = self.psu1_id if index == 1 else self.psu2_id\n-        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n+        self.ipmi_raw[8] = psu_id\n+        res_string = self.run_command(self.ipmi_raw)\n         status_byte = self.find_value(res_string)\n \n         if status_byte is None:\ndiff --git a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py\nindex bbbb9f1d458d..ba7742c66b60 100644\n--- a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py\n+++ b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py\n@@ -6,7 +6,6 @@\n #\n #############################################################################\n \n-import json\n import os.path\n \n try:\n@@ -24,14 +23,18 @@\n ]\n SW_CPLD_VER_PATH = \"/sys/module/switch_cpld/version\"\n BASE_CPLD_VER_PATH = \"/sys/module/baseboard_lpc/version\"\n-CPLD_UPGRADE_OPT = 4\n BIOS_VER_PATH = \"/sys/class/dmi/id/bios_version\"\n-BIOS__UPGRADE_OPT = 2\n-BMC_VER_CMD = \"ipmitool mc info | grep 'Firmware Revision'\"\n-BMC_UPGRADE_OPT = 1\n-CFUFLASH_FW_UPGRADE_CMD = \"CFUFLASH -cd -d {} -mse 3 {}\"\n+BMC_VER_CMD1 = [\"ipmitool\", \"mc\", \"info\"]\n+BMC_VER_CMD2 = [\"grep\", \"Firmware Revision\"]\n+CFUFLASH_FW_UPGRADE_CMD = [\"CFUFLASH\", \"-cd\", \"-d\", \"\", \"-mse\", \"3\", \"\"]\n MEM_PCI_RESOURCE = \"/sys/bus/pci/devices/0000:09:00.0/resource0\"\n FPGA_VER_MEM_OFFSET = 0\n+UPGRADE_OPT = {\n+    'BMC': '1',\n+    'BIOS': '2',\n+    'SWITCH_CPLD': '4',\n+    'BASE_CPLD': '4'\n+}\n \n \n class Component(ComponentBase):\n@@ -47,7 +50,7 @@ def __init__(self, component_index):\n \n     def __get_bmc_ver(self):\n         bmc_ver = \"Unknown\"\n-        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD)\n+        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD1, BMC_VER_CMD2)\n         if status:\n             bmc_ver_data = raw_bmc_data.split(\":\")\n             bmc_ver = bmc_ver_data[-1].strip() if len(\n@@ -104,16 +107,12 @@ def install_firmware(self, image_path):\n         Returns:\n             A boolean, True if install successfully, False if not\n         \"\"\"\n-        install_command = {\n-            \"BMC\": CFUFLASH_FW_UPGRADE_CMD.format(BMC_UPGRADE_OPT, image_path),\n-            \"BIOS\": CFUFLASH_FW_UPGRADE_CMD.format(BIOS__UPGRADE_OPT, image_path),\n-            \"SWITCH_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path),\n-            \"BASE_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path)\n-        }.get(self.name, None)\n-\n-        if not os.path.isfile(image_path) or install_command is None:\n+        CFUFLASH_FW_UPGRADE_CMD[3] = UPGRADE_OPT.get(self.name)\n+        CFUFLASH_FW_UPGRADE_CMD[6] = image_path\n+\n+        if not os.path.isfile(image_path):\n             return False\n \n         # print(install_command)\n-        status = self._api_helper.run_interactive_command(install_command)\n+        status = self._api_helper.run_interactive_command(CFUFLASH_FW_UPGRADE_CMD)\n         return status\ndiff --git a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py\nindex 144d9e154348..d53de841eeee 100644\n--- a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py\n+++ b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py\n@@ -2,8 +2,9 @@\n import struct\n import subprocess\n from mmap import *\n+from sonic_py_common.general import check_output_pipe\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -13,7 +14,11 @@ def __init__(self):\n         pass\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -28,22 +33,18 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n+    def run_command(self, cmd1_args, cmd2_args):\n         status = True\n         result = \"\"\n         try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except:\n+            result = check_output_pipe(cmd1_args, cmd2_args)\n+        except subprocess.CalledProcessError:\n             status = False\n         return status, result\n \n     def run_interactive_command(self, cmd):\n         try:\n-            os.system(cmd)\n+            subprocess.call(cmd)\n         except:\n             return False\n         return True\n@@ -61,9 +62,9 @@ def ipmi_raw(self, netfn, cmd):\n         status = True\n         result = \"\"\n         try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n+            cmd = [\"ipmitool\", \"raw\", str(netfn), str(cmd)]\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = raw_data.strip()\n@@ -76,28 +77,30 @@ def ipmi_raw(self, netfn, cmd):\n     def ipmi_fru_id(self, id, key=None):\n         status = True\n         result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n+        cmd1_args = [\"ipmitool\", \"fru\", \"print\", str(id)]\n+        if not key:\n+            try:\n+                p = subprocess.Popen(\n+                    cmd1_args, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                raw_data, err = p.communicate()\n+                if err == '':\n+                    result = raw_data.strip()\n+                else:\n+                    status = False\n+            except:\n                 status = False\n-        except:\n-            status = False\n+        else:\n+            cmd2_args = [\"grep\", str(key)]\n+            status, result = self.run_command(cmd1_args, cmd2_args)\n         return status, result\n \n     def ipmi_set_ss_thres(self, id, threshold_key, value):\n         status = True\n         result = \"\"\n         try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n+            cmd = [\"ipmitool\", \"sensor\", \"thresh\", str(id), str(threshold_key), str(value)]\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = raw_data.strip()\ndiff --git a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py\nindex 9ad0f1dc9392..a6c805d3ca4f 100644\n--- a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py\n+++ b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py\n@@ -33,20 +33,15 @@\n PSU_LED_GREEN_CMD = \"0x01\"\n PSU_LED_AMBER_CMD = \"0x02\"\n \n-PSU1_VOUT_SS_ID = \"0x36\"\n-PSU1_COUT_SS_ID = \"0x37\"\n-PSU1_POUT_SS_ID = \"0x38\"\n-PSU1_STATUS_REG = \"0x39\"\n-\n-PSU2_VOUT_SS_ID = \"0x40\"\n-PSU2_COUT_SS_ID = \"0x41\"\n-PSU2_POUT_SS_ID = \"0x42\"\n-PSU2_STATUS_REG = \"0x2f\"\n-\n PSU1_FRU_ID = 3\n \n SS_READ_OFFSET = 0\n \n+PSU_VOUT_SS_ID = [\"0x36\", \"0x40\"]\n+PSU_COUT_SS_ID = [\"0x37\", \"0x41\"]\n+PSU_POUT_SS_ID = [\"0x38\", \"0x42\"]\n+PSU_STATUS_REG = [\"0x39\", \"0x2f\"]\n+\n \n class Psu(PsuBase):\n     \"\"\"Platform-specific Psu class\"\"\"\n@@ -71,7 +66,7 @@ def get_voltage(self):\n             e.g. 12.1\n         \"\"\"\n         psu_voltage = 0.0\n-        psu_vout_key = globals()['PSU{}_VOUT_SS_ID'.format(self.index+1)]\n+        psu_vout_key = PSU_VOUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_vout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n@@ -87,7 +82,7 @@ def get_current(self):\n             A float number, the electric current in amperes, e.g 15.4\n         \"\"\"\n         psu_current = 0.0\n-        psu_cout_key = globals()['PSU{}_COUT_SS_ID'.format(self.index+1)]\n+        psu_cout_key = PSU_COUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_cout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n@@ -103,7 +98,7 @@ def get_power(self):\n             A float number, the power in watts, e.g. 302.6\n         \"\"\"\n         psu_power = 0.0\n-        psu_pout_key = globals()['PSU{}_POUT_SS_ID'.format(self.index+1)]\n+        psu_pout_key = PSU_POUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n@@ -176,7 +171,7 @@ def get_presence(self):\n             bool: True if PSU is present, False if not\n         \"\"\"\n         psu_presence = False\n-        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n+        psu_pstatus_key = PSU_STATUS_REG[self.index]\n         status, raw_status_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n         status_byte = self.find_value(raw_status_read)\n@@ -228,7 +223,7 @@ def get_status(self):\n             A boolean value, True if device is operating properly, False if not\n         \"\"\"\n         psu_status = False\n-        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n+        psu_pstatus_key = PSU_STATUS_REG[self.index]\n         status, raw_status_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n         status_byte = self.find_value(raw_status_read)\ndiff --git a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py\nindex c22c7a9b7585..4ad97b42fff3 100644\n--- a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py\n+++ b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py\n@@ -6,7 +6,6 @@\n #\n #############################################################################\n \n-import os\n import time\n import subprocess\n from ctypes import create_string_buffer\n@@ -168,7 +167,7 @@ class Sfp(SfpBase):\n     # Path to QSFP sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-cel_silverstone-r0\"\n     HWSKU = \"Silverstone\"\n@@ -270,7 +269,11 @@ def __convert_string_to_num(self, value_str):\n             return 'N/A'\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py b/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py\nindex e4f3e1257da8..7fee0aee58c1 100644\n--- a/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py\n+++ b/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py\n@@ -8,19 +8,18 @@\n #\r\n #############################################################################\r\n \r\n-import os.path\r\n import subprocess\r\n-import time\r\n-import os\r\n \r\n try:\r\n     from sonic_platform_base.component_base import ComponentBase\r\n+    from sonic_py_common.general import getstatusoutput_noshell_pipe\r\n     #from helper import APIHelper\r\n except ImportError as e:\r\n     raise ImportError(str(e) + \"- required module not found\")\r\n \r\n-SWCPLD_VERSION_PATH = \"i2cget -y -f 2 0x32 0\"\r\n-BIOS_VERSION_PATH = \"dmidecode -t bios | grep Version\"\r\n+SWCPLD_VERSION_PATH = [\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0\"]\r\n+BIOS_VERSION_PATH_CMD1 = [\"dmidecode\", \"-t\", \"bios\"]\r\n+BIOS_VERSION_PATH_CMD2 = [\"grep\", \"Version\"]\r\n COMPONENT_NAME_LIST = [\"SWCPLD\", \"Main_BIOS\", \"Backup_BIOS\"]\r\n COMPONENT_DES_LIST = [\"Use for boot control and BIOS switch\",\r\n                       \"Main basic Input/Output System\",\r\n@@ -39,15 +38,15 @@ def __init__(self, component_index):\n         self.name = self.get_name()\r\n \r\n     def run_command(self,cmd):\r\n-        responses = os.popen(cmd).read()\r\n+        responses = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()\r\n         return responses\r\n \r\n     def __get_bios_version(self):\r\n         # Retrieves the BIOS firmware version\r\n-        result = self.run_command(\"i2cget -y -f 2 0x32 0x19\")\r\n+        result = self.run_command([\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0x19\"])\r\n         if result.strip() == \"0x01\":\r\n             if self.name == \"Main_BIOS\":\r\n-                version = self.run_command(BIOS_VERSION_PATH)\r\n+                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r\n                 bios_version = version.strip().split(\" \")[1]\r\n                 return str(bios_version)\r\n             elif self.name == \"Backup_BIOS\":\r\n@@ -56,7 +55,7 @@ def __get_bios_version(self):\n                 \r\n         elif result.strip() == \"0x03\":\r\n             if self.name == \"Backup_BIOS\":\r\n-                version = self.run_command(BIOS_VERSION_PATH)\r\n+                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r\n                 bios_version = version.strip().split(\" \")[1]\r\n                 return str(bios_version)\r\n             elif self.name == \"Main_BIOS\":\r\ndiff --git a/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py b/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py\nindex 36e95f2c0c08..d5ee08049d78 100644\n--- a/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py\n+++ b/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py\n@@ -1,6 +1,6 @@\n try:\n     from sonic_platform_pddf_base.pddf_fan import PddfFan\n-    import os\n+    import subprocess\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n # ------------------------------------------------------------------\n@@ -47,8 +47,9 @@ def get_direction(self):\n         \"\"\"\n         if self.is_psu_fan:\n             cmd_num = \"58\" if self.fans_psu_index == 1 else \"59\"\n-            cmd = \"i2cget -y -f 4 0x%s 0x80\" % cmd_num\n-            res = os.popen(cmd).read()\n+            cmd = [\"i2cget\", \"-y\", \"-f\", \"4\", \"\", \"0x80\"]\n+            cmd[4] = \"0x\" + cmd_num\n+            res = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()\n             # F2B \n             if res.strip() == \"0x01\":\n                 direction = \"EXHAUST\"\ndiff --git a/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py b/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py\nindex 017a04709f3c..5ce0469a0ddf 100755\n--- a/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py\n@@ -23,13 +23,13 @@\n try:\n     import sys\n     import getopt\n-    import subprocess\n     import logging\n     import logging.config\n     import time  # this is only being used as part of the example\n     import signal\n     import math\n     from sonic_platform import platform\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n@@ -224,7 +224,7 @@ def handler(signum, frame):\n         else:\n             logging.debug('INFO: FAIL. set_fan_duty_cycle (%d)' % DUTY_MAX)\n         # Enable the CPLD Heartbeat back\n-        status, output = subprocess.getstatusoutput('i2cset -f -y 75 0x40 0x22 0x00')\n+        status, output = getstatusoutput_noshell([\"i2cset\", \"-f\", \"-y\", \"75\", \"0x40\", \"0x22\", \"0x00\"])\n         if status == 0:\n             logging.debug('INFO: CPLD Heartbeat check is enabled back')\n     sys.exit(0)\n@@ -258,7 +258,7 @@ def main(argv):\n     signal.signal(signal.SIGINT, handler)\n     signal.signal(signal.SIGTERM, handler)\n     # Disaable the CPLD Heartbeat check to control Fan speed from CPU via ADT7470\n-    subprocess.getstatusoutput('i2cset -f -y 2 0x32 0x30 0x01')\n+    getstatusoutput_noshell(['i2cset', '-f', '-y', '2', '0x32', '0x30', '0x01'])\n \n     monitor = cel_belgite_monitor(log_file, log_level)\n \ndiff --git a/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py b/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py\nindex 697308b8c3cf..2d968359971c 100644\n--- a/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py\n+++ b/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py\n@@ -1,4 +1,5 @@\n import os\n+import ast\n import imp\n import yaml\n import subprocess\n@@ -24,7 +25,7 @@ class Common:\n \n     SET_METHOD_IPMI = 'ipmitool'\n     NULL_VAL = 'N/A'\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n     REF_KEY = '$ref:'\n \n     def __init__(self, conf=None):\n@@ -56,7 +57,7 @@ def _clean_input(self, input, config):\n             cleaned_input = input_translator.get(input)\n \n         elif type(input_translator) is str:\n-            cleaned_input = eval(input_translator.format(input))\n+            cleaned_input = ast.literal_eval(input_translator.format(input))\n \n         return cleaned_input\n \n@@ -66,9 +67,9 @@ def _clean_output(self, index, output, config):\n         if type(output_translator) is dict:\n             output = output_translator.get(output)\n         elif type(output_translator) is str:\n-            output = eval(output_translator.format(output))\n+            output = ast.literal_eval(output_translator.format(output))\n         elif type(output_translator) is list:\n-            output = eval(output_translator[index].format(output))\n+            output = ast.literal_eval(output_translator[index].format(output))\n \n         return output\n \n@@ -166,7 +167,11 @@ def write_txt_file(self, file_path, value):\n         return True\n \n     def is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def load_json_file(self, path):\n         \"\"\"\ndiff --git a/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py b/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py\nindex 186ee6c5450e..1aa1c0719825 100755\n--- a/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py\n+++ b/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py\n@@ -12,7 +12,7 @@\n import logging\n import subprocess\n \n-IPMI_SDR_CMD = \"ipmitool sdr elist\"\n+IPMI_SDR_CMD = [\"ipmitool\", \"sdr\", \"elist\"]\n MAX_NUM_FANS = 7\n MAX_NUM_PSUS = 2\n \n@@ -23,7 +23,7 @@ def ipmi_sensor_dump(cmd):\n     '''\n     sensor_dump = ''\n     try:\n-        sensor_dump = subprocess.check_output(cmd, shell=True)\n+        sensor_dump = subprocess.check_output(cmd)\n     except subprocess.CalledProcessError as e:\n         logging.error('Error! Failed to execute: {}'.format(cmd))\n         sys.exit(1)\n", "message": "", "files": {"/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n RESET_REGISTER = \"0x112\"\n HOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/previous-reboot-cause.txt\"\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n STATUS_LED_PATH = \"/sys/devices/platform/e1031.smc/master_led\"\n \n ", "add": 0, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": []}], "source": "\n try: from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper from sonic_platform_base.chassis_base import ChassisBase from sonic_py_common import device_info from.common import Common from.event import SfpEvent except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=3 NUM_PSU=2 NUM_THERMAL=7 NUM_SFP=55 NUM_COMPONENT=3 RESET_REGISTER=\"0x112\" HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/previous-reboot-cause.txt\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/previous-reboot-cause.txt\" HOST_CHK_CMD=\"docker > /dev/null 2>&1\" STATUS_LED_PATH=\"/sys/devices/platform/e1031.smc/master_led\" class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_common=Common() self._is_host=self._api_common.is_host() self.__initialize_eeprom() self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.sfp_module_initialized=False self._reboot_cause_path=HOST_REBOOT_CAUSE_PATH if self._is_host else PMON_REBOOT_CAUSE_PATH def __initialize_sfp(self): sfputil_helper=SfpUtilHelper() port_config_file_path=device_info.get_path_to_port_config_file() sfputil_helper.read_porttab_mappings(port_config_file_path, 0) from.sfp import Sfp for index in range(0, NUM_SFP): sfp=Sfp(index, sfputil_helper.logical[index]) self._sfp_list.append(sfp) self.sfp_module_initialized=True def __initialize_psu(self): from.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_fan(self): from.fan_drawer import FanDrawer for i in range(NUM_FAN_TRAY): fandrawer=FanDrawer(i) self._fan_drawer_list.append(fandrawer) self._fan_list +=fandrawer.get_all_fans() def __initialize_thermals(self): from.thermal import Thermal airflow=self.__get_air_flow() for index in range(0, NUM_THERMAL): thermal=Thermal(index, airflow) self._thermal_list.append(thermal) def __initialize_eeprom(self): from.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __get_air_flow(self): air_flow_path='/usr/share/sonic/device/{}/fan_airflow'.format( self._api_common.get_platform()) if self._is_host else '/usr/share/sonic/platform/fan_airflow' air_flow=self._api_common.read_txt_file(air_flow_path) return air_flow or 'B2F' def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_serial_number(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" description='None' reboot_cause=self.REBOOT_CAUSE_HARDWARE_OTHER hw_reboot_cause=self._component_list[0].get_register_value( RESET_REGISTER) sw_reboot_cause=self._api_common.read_txt_file( self._reboot_cause_path) or \"Unknown\" if hw_reboot_cause==\"0x55\": reboot_cause=self.REBOOT_CAUSE_NON_HARDWARE description=sw_reboot_cause elif hw_reboot_cause==\"0x11\": reboot_cause=self.REBOOT_CAUSE_POWER_LOSS elif hw_reboot_cause==\"0x33\": reboot_cause=self.REBOOT_CAUSE_WATCHDOG elif hw_reboot_cause==\"0x88\": reboot_cause=self.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU elif hw_reboot_cause==\"0x99\": reboot_cause=self.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC else: reboot_cause=self.REBOOT_CAUSE_NON_HARDWARE description='Unknown reason' return(reboot_cause, description) def get_watchdog(self): \"\"\" Retreives hardware watchdog device on this chassis Returns: An object derived from WatchdogBase representing the hardware watchdog device \"\"\" if self._watchdog is None: from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() return self._watchdog def get_change_event(self, timeout=0): \"\"\" Returns a nested dictionary containing all devices which have experienced a change at chassis level Args: timeout: Timeout in milliseconds(optional). If timeout==0, this method will block until a change is detected. Returns: (bool, dict): -True if call successful, False if not; -A nested dictionary where key is a device type, value is a dictionary with key:value pairs in the format of {'device_id':'device_event'}, where device_id is the device ID for this device and device_event, status='1' represents device inserted, status='0' represents device removed. Ex.{'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}} indicates that fan 0 has been removed, fan 2 has been inserted and sfp 11 has been removed. \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() sfp_event=SfpEvent(self._sfp_list).get_sfp_event(timeout) if sfp_event: return True,{'sfp': sfp_event} return False,{'sfp':{}} def get_num_sfps(self): \"\"\" Retrieves the number of sfps available on this chassis Returns: An integer, the number of sfps available on this chassis \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() return len(self._sfp_list) def get_all_sfps(self): \"\"\" Retrieves all sfps available on this chassis Returns: A list of objects derived from SfpBase representing all sfps available on this chassis \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfp_list def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() return super(Chassis, self).get_sfp(index -1) def get_thermal_manager(self): from.thermal_manager import ThermalManager return ThermalManager def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._api_common.get_hwsku() def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return self.get_serial_number() def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def set_status_led(self, color): \"\"\" Sets the state of the PSU status LED Args: color: A string representing the color with which to set the PSU status LED Note: Only support green and off Returns: bool: True if status LED state is set successfully, False if not \"\"\" status_str={ self.STATUS_LED_COLOR_GREEN: 'green', self.STATUS_LED_COLOR_AMBER: 'amber', self.STATUS_LED_COLOR_OFF: 'off' }.get(color, 'off') return self._api_common.write_txt_file(STATUS_LED_PATH, status_str) def get_status_led(self): \"\"\" Gets the state of the PSU status LED Returns: A string, one of the predefined STATUS_LED_COLOR_* strings above \"\"\" status=self._api_common.read_txt_file(STATUS_LED_PATH) status_str={ 'on': self.STATUS_LED_COLOR_GREEN, 'amber': self.STATUS_LED_COLOR_AMBER, 'off': self.STATUS_LED_COLOR_OFF }.get(status, None) return status_str ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\n\ntry:\n    from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper\n    from sonic_platform_base.chassis_base import ChassisBase\n    from sonic_py_common import device_info\n    from .common import Common\n    from .event import SfpEvent\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 3\nNUM_PSU = 2\nNUM_THERMAL = 7\nNUM_SFP = 55\nNUM_COMPONENT = 3\nRESET_REGISTER = \"0x112\"\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/previous-reboot-cause.txt\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nSTATUS_LED_PATH = \"/sys/devices/platform/e1031.smc/master_led\"\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n\n        self._api_common = Common()\n        self._is_host = self._api_common.is_host()\n\n        self.__initialize_eeprom()\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n\n        self.sfp_module_initialized = False\n        self._reboot_cause_path = HOST_REBOOT_CAUSE_PATH if self._is_host else PMON_REBOOT_CAUSE_PATH\n\n    def __initialize_sfp(self):\n        sfputil_helper = SfpUtilHelper()\n        port_config_file_path = device_info.get_path_to_port_config_file()\n        sfputil_helper.read_porttab_mappings(port_config_file_path, 0)\n\n        from .sfp import Sfp\n        for index in range(0, NUM_SFP):\n            sfp = Sfp(index, sfputil_helper.logical[index])\n            self._sfp_list.append(sfp)\n        self.sfp_module_initialized = True\n\n    def __initialize_psu(self):\n        from .psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_fan(self):\n        from .fan_drawer import FanDrawer\n        for i in range(NUM_FAN_TRAY):\n            fandrawer = FanDrawer(i)\n            self._fan_drawer_list.append(fandrawer)\n            self._fan_list += fandrawer.get_all_fans()\n\n    def __initialize_thermals(self):\n        from .thermal import Thermal\n        airflow = self.__get_air_flow()\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index, airflow)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from .eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from .component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __get_air_flow(self):\n        air_flow_path = '/usr/share/sonic/device/{}/fan_airflow'.format(\n            self._api_common.get_platform()) if self._is_host else '/usr/share/sonic/platform/fan_airflow'\n        air_flow = self._api_common.read_txt_file(air_flow_path)\n        return air_flow or 'B2F'\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_serial_number(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        description = 'None'\n        reboot_cause = self.REBOOT_CAUSE_HARDWARE_OTHER\n        hw_reboot_cause = self._component_list[0].get_register_value(\n            RESET_REGISTER)\n        sw_reboot_cause = self._api_common.read_txt_file(\n            self._reboot_cause_path) or \"Unknown\"\n\n        if hw_reboot_cause == \"0x55\":\n            reboot_cause = self.REBOOT_CAUSE_NON_HARDWARE\n            description = sw_reboot_cause\n        elif hw_reboot_cause == \"0x11\":\n            reboot_cause = self.REBOOT_CAUSE_POWER_LOSS\n        elif hw_reboot_cause == \"0x33\":\n            reboot_cause = self.REBOOT_CAUSE_WATCHDOG\n        elif hw_reboot_cause == \"0x88\":\n            reboot_cause = self.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU\n        elif hw_reboot_cause == \"0x99\":\n            reboot_cause = self.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC\n        else:\n            reboot_cause = self.REBOOT_CAUSE_NON_HARDWARE\n            description = 'Unknown reason'\n        return (reboot_cause, description)\n\n    def get_watchdog(self):\n        \"\"\"\n        Retreives hardware watchdog device on this chassis\n        Returns:\n            An object derived from WatchdogBase representing the hardware\n            watchdog device\n        \"\"\"\n        if self._watchdog is None:\n            from sonic_platform.watchdog import Watchdog\n            self._watchdog = Watchdog()\n\n        return self._watchdog\n\n    def get_change_event(self, timeout=0):\n        \"\"\"\n        Returns a nested dictionary containing all devices which have\n        experienced a change at chassis level\n        Args:\n            timeout: Timeout in milliseconds (optional). If timeout == 0,\n                this method will block until a change is detected.\n        Returns:\n            (bool, dict):\n                - True if call successful, False if not;\n                - A nested dictionary where key is a device type,\n                  value is a dictionary with key:value pairs in the format of\n                  {'device_id':'device_event'},\n                  where device_id is the device ID for this device and\n                        device_event,\n                             status='1' represents device inserted,\n                             status='0' represents device removed.\n                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}\n                      indicates that fan 0 has been removed, fan 2\n                      has been inserted and sfp 11 has been removed.\n        \"\"\"\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        sfp_event = SfpEvent(self._sfp_list).get_sfp_event(timeout)\n        if sfp_event:\n            return True, {'sfp': sfp_event}\n\n        return False, {'sfp': {}}\n\n    ##############################################################\n    ######################## SFP methods #########################\n    ##############################################################\n\n    def get_num_sfps(self):\n        \"\"\"\n        Retrieves the number of sfps available on this chassis\n        Returns:\n            An integer, the number of sfps available on this chassis\n        \"\"\"\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return len(self._sfp_list)\n\n    def get_all_sfps(self):\n        \"\"\"\n        Retrieves all sfps available on this chassis\n        Returns:\n            A list of objects derived from SfpBase representing all sfps\n            available on this chassis\n        \"\"\"\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return self._sfp_list\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return super(Chassis, self).get_sfp(index - 1)\n\n    ##############################################################\n    ################## ThermalManager methods ####################\n    ##############################################################\n\n    def get_thermal_manager(self):\n        from .thermal_manager import ThermalManager\n        return ThermalManager\n\n    ##############################################################\n    ###################### Device methods ########################\n    ##############################################################\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return self._api_common.get_hwsku()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return self.get_serial_number()\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the PSU status LED\n        Args:\n            color: A string representing the color with which to set the PSU status LED\n                   Note: Only support green and off\n        Returns:\n            bool: True if status LED state is set successfully, False if not\n        \"\"\"\n\n        status_str = {\n            self.STATUS_LED_COLOR_GREEN: 'green',\n            self.STATUS_LED_COLOR_AMBER: 'amber',\n            self.STATUS_LED_COLOR_OFF: 'off'\n        }.get(color, 'off')\n\n        return self._api_common.write_txt_file(STATUS_LED_PATH, status_str)\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the PSU status LED\n        Returns:\n            A string, one of the predefined STATUS_LED_COLOR_* strings above\n        \"\"\"\n        status = self._api_common.read_txt_file(STATUS_LED_PATH)\n        status_str = {\n            'on': self.STATUS_LED_COLOR_GREEN,\n            'amber': self.STATUS_LED_COLOR_AMBER,\n            'off': self.STATUS_LED_COLOR_OFF\n        }.get(status, None)\n\n        return status_str\n"}, "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py": {"changes": [{"diff": "\n import os\r\n+import ast\r\n import imp\r\n import yaml\r\n import subprocess\r\n-\r\n from sonic_py_common import device_info\r\n \r\n \r\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["\r"], "goodparts": ["import ast\r"]}, {"diff": "\n \r\n     SET_METHOD_IPMI = 'ipmitool'\r\n     NULL_VAL = 'N/A'\r\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\r\n+    HOST_CHK_CMD = [\"docker\"]\r\n     REF_KEY = '$ref:'\r\n \r\n     def __init__(self, conf=None):\r\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\r"], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]\r"]}, {"diff": "\n         status = False\r\n         output = \"\"\r\n         try:\r\n-            p = subprocess.Popen(\r\n-                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n+            p = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n             raw_data, err = p.communicate()\r\n             if p.returncode == 0:\r\n                 status, output = True, raw_data.strip()\r\n", "add": 1, "remove": 2, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["            p = subprocess.Popen(\r", "                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r"], "goodparts": ["            p = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r"]}, {"diff": "\n             cleaned_input = input_translator.get(input)\r\n \r\n         elif type(input_translator) is str:\r\n-            cleaned_input = eval(input_translator.format(input))\r\n+            cleaned_input = ast.literal_eval(input_translator.format(input))\r\n \r\n         return cleaned_input\r\n \r\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["            cleaned_input = eval(input_translator.format(input))\r"], "goodparts": ["            cleaned_input = ast.literal_eval(input_translator.format(input))\r"]}, {"diff": "\n         if type(output_translator) is dict:\r\n             output = output_translator.get(output)\r\n         elif type(output_translator) is str:\r\n-            output = eval(output_translator.format(output))\r\n+            output = ast.literal_eval(output_translator.format(output))\r\n         elif type(output_translator) is list:\r\n-            output = eval(output_translator[index].format(output))\r\n+            output = ast.literal_eval(output_translator[index].format(output))\r\n \r\n         return output\r\n \r\n-    def _ipmi_get(self, index, config):\r\n-        argument = config.get('argument')\r\n-        cmd = config['command'].format(\r\n-            config['argument'][index]) if argument else config['command']\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n-\r\n     def _sysfs_read(self, index, config):\r\n         sysfs_path = config.get('sysfs_path')\r\n         argument = config.get('argument', '')\r\n", "add": 2, "remove": 9, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["            output = eval(output_translator.format(output))\r", "            output = eval(output_translator[index].format(output))\r", "    def _ipmi_get(self, index, config):\r", "        argument = config.get('argument')\r", "        cmd = config['command'].format(\r", "            config['argument'][index]) if argument else config['command']\r", "        status, output = self.run_command(cmd)\r", "        return output if status else None\r", "\r"], "goodparts": ["            output = ast.literal_eval(output_translator.format(output))\r", "            output = ast.literal_eval(output_translator[index].format(output))\r"]}, {"diff": "\n             return False, output\r\n         return True, output\r\n \r\n-    def _ipmi_set(self, index, config, input):\r\n-        arg = config['argument'][index].format(input)\r\n-        return self.run_command(config['command'].format(arg))\r\n-\r\n     def _hex_ver_decode(self, hver, num_of_bits, num_of_points):\r\n         ver_list = []\r\n         c_bit = 0\r\n", "add": 0, "remove": 4, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["    def _ipmi_set(self, index, config, input):\r", "        arg = config['argument'][index].format(input)\r", "        return self.run_command(config['command'].format(arg))\r", "\r"], "goodparts": []}, {"diff": "\n         return class_\r\n \r\n     def get_reg(self, path, reg_addr):\r\n-        cmd = \"echo {1} > {0}; cat {0}\".format(path, reg_addr)\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n+        with open(path, 'w') as file:\r\n+            file.write(reg_addr + '\\n')\r\n+        with open(path, 'r') as file:\r\n+            output = file.readline().strip()\r\n+        return output\r\n \r\n     def set_reg(self, path, reg_addr, value):\r\n-        cmd = \"echo {0} {1} > {2}\".format(reg_addr, value, path)\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n+        with open(path, 'w') as file:\r\n+            file.write(\"{0} {1}\\n\".format(reg_addr, value))\r\n+        return None\r\n \r\n     def read_txt_file(self, path):\r\n         try:\r\n", "add": 8, "remove": 6, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["        cmd = \"echo {1} > {0}; cat {0}\".format(path, reg_addr)\r", "        status, output = self.run_command(cmd)\r", "        return output if status else None\r", "        cmd = \"echo {0} {1} > {2}\".format(reg_addr, value, path)\r", "        status, output = self.run_command(cmd)\r", "        return output if status else None\r"], "goodparts": ["        with open(path, 'w') as file:\r", "            file.write(reg_addr + '\\n')\r", "        with open(path, 'r') as file:\r", "            output = file.readline().strip()\r", "        return output\r", "        with open(path, 'w') as file:\r", "            file.write(\"{0} {1}\\n\".format(reg_addr, value))\r", "        return None\r"]}, {"diff": "\n         return True\r\n \r\n     def is_host(self):\r\n-        return os.system(self.HOST_CHK_CMD) == 0\r\n+        try:\r\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\r\n+        except FileNotFoundError:\r\n+            return False\r\n+        return True\r\n \r\n     def load_json_file(self, path):\r\n         \"\"\"\r\n", "add": 5, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0\r"], "goodparts": ["        try:\r", "            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\r", "        except FileNotFoundError:\r", "            return False\r", "        return True\r"]}, {"diff": "\n         \"\"\"\r\n         return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\r\n \r\n-    def get_output(self, index, config, default):\r\n-        \"\"\"\r\n-        Retrieves the output for each function base on config\r\n-\r\n-        Args:\r\n-            index: An integer containing the index of device.\r\n-            config: A dict object containing the configuration of specified function.\r\n-            default: A string containing the default output of specified function.\r\n-\r\n-        Returns:\r\n-            A string containing the output of specified function in config\r\n-        \"\"\"\r\n-        output_source = config.get('output_source')\r\n-\r\n-        if output_source == self.OUTPUT_SOURCE_IPMI:\r\n-            output = self._ipmi_get(index, config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VALUE:\r\n-            output = config[\"value\"]\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_CLASS:\r\n-            output = self._get_class(config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_LIST:\r\n-            output = config[\"value_list\"][index]\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_SYSFS:\r\n-            output = self._sysfs_read(index, config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_FUNC:\r\n-            func_conf = self._main_conf[config['function'][index]]\r\n-            output = self.get_output(index, func_conf, default)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\r\n-            path = config.get('path')\r\n-            output = self.read_txt_file(path)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\r\n-            path = config.get('path')\r\n-            hex_ver = self.read_txt_file(path)\r\n-            output = self._hex_ver_decode(\r\n-                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\r\n-            path = config.get('path')\r\n-            addr = config.get('reg_addr')\r\n-            hex_ver = self.get_reg(path, addr)\r\n-            output = self._hex_ver_decode(\r\n-                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n-\r\n-        else:\r\n-            output = default\r\n-\r\n-        return self._clean_output(index, output, config) or default\r\n-\r\n-    def set_output(self, index, input, config):\r\n-        \"\"\"\r\n-        Sets the output of specified function on config\r\n-\r\n-        Args:\r\n-            config: A dict object containing the configuration of specified function.\r\n-            index: An integer containing the index of device.\r\n-            input: A string containing the input of specified function.\r\n-\r\n-        Returns:\r\n-            bool: True if set function is successfully, False if not\r\n-        \"\"\"\r\n-        cleaned_input = self._clean_input(input, config)\r\n-        if not cleaned_input:\r\n-            return False\r\n-\r\n-        set_method = config.get('set_method')\r\n-        if set_method == self.SET_METHOD_IPMI:\r\n-            output = self._ipmi_set(index, config, cleaned_input)[0]\r\n-        elif set_method == self.OUTPUT_SOURCE_SYSFS:\r\n-            output = self._sysfs_write(index, config, cleaned_input)[0]\r\n-        else:\r\n-            output = False\r\n-\r\n-        return output\r\n-\r\n     def get_event(self, timeout, config, sfp_list):\r\n         \"\"\"\r\n         Returns a nested dictionary containing all devices which have", "add": 0, "remove": 81, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["    def get_output(self, index, config, default):\r", "        \"\"\"\r", "        Retrieves the output for each function base on config\r", "\r", "        Args:\r", "            index: An integer containing the index of device.\r", "            config: A dict object containing the configuration of specified function.\r", "            default: A string containing the default output of specified function.\r", "\r", "        Returns:\r", "            A string containing the output of specified function in config\r", "        \"\"\"\r", "        output_source = config.get('output_source')\r", "\r", "        if output_source == self.OUTPUT_SOURCE_IPMI:\r", "            output = self._ipmi_get(index, config)\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_VALUE:\r", "            output = config[\"value\"]\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_CLASS:\r", "            output = self._get_class(config)\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_LIST:\r", "            output = config[\"value_list\"][index]\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_SYSFS:\r", "            output = self._sysfs_read(index, config)\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_FUNC:\r", "            func_conf = self._main_conf[config['function'][index]]\r", "            output = self.get_output(index, func_conf, default)\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\r", "            path = config.get('path')\r", "            output = self.read_txt_file(path)\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\r", "            path = config.get('path')\r", "            hex_ver = self.read_txt_file(path)\r", "            output = self._hex_ver_decode(\r", "                hex_ver, config['num_of_bits'], config['num_of_points'])\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\r", "            path = config.get('path')\r", "            addr = config.get('reg_addr')\r", "            hex_ver = self.get_reg(path, addr)\r", "            output = self._hex_ver_decode(\r", "                hex_ver, config['num_of_bits'], config['num_of_points'])\r", "\r", "        else:\r", "            output = default\r", "\r", "        return self._clean_output(index, output, config) or default\r", "\r", "    def set_output(self, index, input, config):\r", "        \"\"\"\r", "        Sets the output of specified function on config\r", "\r", "        Args:\r", "            config: A dict object containing the configuration of specified function.\r", "            index: An integer containing the index of device.\r", "            input: A string containing the input of specified function.\r", "\r", "        Returns:\r", "            bool: True if set function is successfully, False if not\r", "        \"\"\"\r", "        cleaned_input = self._clean_input(input, config)\r", "        if not cleaned_input:\r", "            return False\r", "\r", "        set_method = config.get('set_method')\r", "        if set_method == self.SET_METHOD_IPMI:\r", "            output = self._ipmi_set(index, config, cleaned_input)[0]\r", "        elif set_method == self.OUTPUT_SOURCE_SYSFS:\r", "            output = self._sysfs_write(index, config, cleaned_input)[0]\r", "        else:\r", "            output = False\r", "\r", "        return output\r", "\r"], "goodparts": []}], "source": "\nimport os\r import imp\r import yaml\r import subprocess\r \r from sonic_py_common import device_info\r \r \r class Common:\r \r DEVICE_PATH='/usr/share/sonic/device/'\r PMON_PLATFORM_PATH='/usr/share/sonic/platform/'\r CONFIG_DIR='sonic_platform_config'\r \r OUTPUT_SOURCE_IPMI='ipmitool'\r OUTPUT_SOURCE_GIVEN_LIST='value_list'\r OUTPUT_SOURCE_GIVEN_VALUE='value'\r OUTPUT_SOURCE_GIVEN_CLASS='class'\r OUTPUT_SOURCE_SYSFS='sysfs_value'\r OUTPUT_SOURCE_FUNC='function'\r OUTPUT_SOURCE_GIVEN_TXT_FILE='txt_file'\r OUTPUT_SOURCE_GIVEN_VER_HEX_FILE='hex_version_file'\r OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR='hex_version_getreg'\r \r SET_METHOD_IPMI='ipmitool'\r NULL_VAL='N/A'\r HOST_CHK_CMD=\"docker > /dev/null 2>&1\"\r REF_KEY='$ref:'\r \r def __init__(self, conf=None):\r self._main_conf=conf\r self.platform=None\r self.hwsku=None\r \r def get_platform(self):\r (self.platform, self.hwsku)=device_info.get_platform_and_hwsku(\r ) if not self.platform else(self.platform, self.hwsku)\r return self.platform\r \r def get_hwsku(self):\r (self.platform, self.hwsku)=device_info.get_platform_and_hwsku(\r ) if not self.hwsku else(self.platform, self.hwsku)\r return self.hwsku\r \r def run_command(self, command):\r status=False\r output=\"\"\r try:\r p=subprocess.Popen(\r command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r raw_data, err=p.communicate()\r if p.returncode==0:\r status, output=True, raw_data.strip()\r except Exception:\r pass\r return status, output\r \r def _clean_input(self, input, config):\r cleaned_input=input\r \r ai=config.get('avaliable_input')\r if ai and input not in ai:\r return None\r \r input_translator=config.get('input_translator')\r if type(input_translator) is dict:\r cleaned_input=input_translator.get(input)\r \r elif type(input_translator) is str:\r cleaned_input=eval(input_translator.format(input))\r \r return cleaned_input\r \r def _clean_output(self, index, output, config):\r output_translator=config.get('output_translator')\r \r if type(output_translator) is dict:\r output=output_translator.get(output)\r elif type(output_translator) is str:\r output=eval(output_translator.format(output))\r elif type(output_translator) is list:\r output=eval(output_translator[index].format(output))\r \r return output\r \r def _ipmi_get(self, index, config):\r argument=config.get('argument')\r cmd=config['command'].format(\r config['argument'][index]) if argument else config['command']\r status, output=self.run_command(cmd)\r return output if status else None\r \r def _sysfs_read(self, index, config):\r sysfs_path=config.get('sysfs_path')\r argument=config.get('argument', '')\r \r if self.REF_KEY in argument:\r argument=self._main_conf[argument.split(\":\")[1]]\r \r if type(argument) is list:\r sysfs_path=sysfs_path.format(argument[index])\r \r content=\"\"\r try:\r content=open(sysfs_path)\r content=content.readline().rstrip()\r except IOError as e:\r print(\"Error: unable to open file: %s\" % str(e))\r return False\r \r return content\r \r def _sysfs_write(self, index, config, input):\r sysfs_path=config.get('sysfs_path')\r argument=config.get('argument', '')\r \r if self.REF_KEY in argument:\r argument=self._main_conf[argument.split(\":\")[1]]\r \r if type(argument) is list:\r sysfs_path=sysfs_path.format(argument[index])\r \r write_offset=int(config.get('write_offset', 0))\r output=\"\"\r try:\r open_file=open(sysfs_path, \"r+\")\r open_file.seek(write_offset)\r open_file.write(input)\r open_file.close()\r except IOError as e:\r print(\"Error: unable to open file: %s\" % str(e))\r return False, output\r return True, output\r \r def _ipmi_set(self, index, config, input):\r arg=config['argument'][index].format(input)\r return self.run_command(config['command'].format(arg))\r \r def _hex_ver_decode(self, hver, num_of_bits, num_of_points):\r ver_list=[]\r c_bit=0\r bin_val=bin(int(hver, 16))[2:].zfill(num_of_bits)\r bit_split=num_of_bits /(num_of_points +1)\r for x in range(0, num_of_points+1):\r split_bin=bin_val[c_bit:c_bit+bit_split]\r ver_list.append(str(int(split_bin, 2)))\r c_bit +=bit_split\r return '.'.join(ver_list)\r \r def _get_class(self, config):\r \"\"\"\r Retreives value of expected attribute\r Returns:\r A value of the attribute of object\r \"\"\"\r path=config['host_path'] if self.is_host() else config['pmon_path']\r module=imp.load_source(config['class'], path)\r class_=getattr(module, config['class'])\r return class_\r \r def get_reg(self, path, reg_addr):\r cmd=\"echo{1} >{0}; cat{0}\".format(path, reg_addr)\r status, output=self.run_command(cmd)\r return output if status else None\r \r def set_reg(self, path, reg_addr, value):\r cmd=\"echo{0}{1} >{2}\".format(reg_addr, value, path)\r status, output=self.run_command(cmd)\r return output if status else None\r \r def read_txt_file(self, path):\r try:\r with open(path, 'r') as f:\r output=f.readline()\r return output.strip('\\n')\r except Exception:\r pass\r return ''\r \r def read_one_line_file(self, file_path):\r try:\r with open(file_path, 'r') as fd:\r data=fd.readline()\r return data.strip()\r except IOError:\r pass\r return ''\r \r def write_txt_file(self, file_path, value):\r try:\r with open(file_path, 'w') as fd:\r fd.write(str(value))\r except Exception:\r return False\r return True\r \r def is_host(self):\r return os.system(self.HOST_CHK_CMD)==0\r \r def load_json_file(self, path):\r \"\"\"\r Retrieves the json object from json file path\r \r Returns:\r A json object\r \"\"\"\r with open(path, 'r') as f:\r json_data=yaml.safe_load(f)\r \r return json_data\r \r def get_config_path(self, config_name):\r \"\"\"\r Retrieves the path to platform api config directory\r \r Args:\r config_name: A string containing the name of config file.\r \r Returns:\r A string containing the path to json file\r \"\"\"\r return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\r \r def get_output(self, index, config, default):\r \"\"\"\r Retrieves the output for each function base on config\r \r Args:\r index: An integer containing the index of device.\r config: A dict object containing the configuration of specified function.\r default: A string containing the default output of specified function.\r \r Returns:\r A string containing the output of specified function in config\r \"\"\"\r output_source=config.get('output_source')\r \r if output_source==self.OUTPUT_SOURCE_IPMI:\r output=self._ipmi_get(index, config)\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_VALUE:\r output=config[\"value\"]\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_CLASS:\r output=self._get_class(config)\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_LIST:\r output=config[\"value_list\"][index]\r \r elif output_source==self.OUTPUT_SOURCE_SYSFS:\r output=self._sysfs_read(index, config)\r \r elif output_source==self.OUTPUT_SOURCE_FUNC:\r func_conf=self._main_conf[config['function'][index]]\r output=self.get_output(index, func_conf, default)\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\r path=config.get('path')\r output=self.read_txt_file(path)\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\r path=config.get('path')\r hex_ver=self.read_txt_file(path)\r output=self._hex_ver_decode(\r hex_ver, config['num_of_bits'], config['num_of_points'])\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\r path=config.get('path')\r addr=config.get('reg_addr')\r hex_ver=self.get_reg(path, addr)\r output=self._hex_ver_decode(\r hex_ver, config['num_of_bits'], config['num_of_points'])\r \r else:\r output=default\r \r return self._clean_output(index, output, config) or default\r \r def set_output(self, index, input, config):\r \"\"\"\r Sets the output of specified function on config\r \r Args:\r config: A dict object containing the configuration of specified function.\r index: An integer containing the index of device.\r input: A string containing the input of specified function.\r \r Returns:\r bool: True if set function is successfully, False if not\r \"\"\"\r cleaned_input=self._clean_input(input, config)\r if not cleaned_input:\r return False\r \r set_method=config.get('set_method')\r if set_method==self.SET_METHOD_IPMI:\r output=self._ipmi_set(index, config, cleaned_input)[0]\r elif set_method==self.OUTPUT_SOURCE_SYSFS:\r output=self._sysfs_write(index, config, cleaned_input)[0]\r else:\r output=False\r \r return output\r \r def get_event(self, timeout, config, sfp_list):\r \"\"\"\r Returns a nested dictionary containing all devices which have\r experienced a change at chassis level\r \r \"\"\"\r event_class=self._get_class(config)\r return event_class(sfp_list).get_event(timeout)\r ", "sourceWithComments": "import os\r\nimport imp\r\nimport yaml\r\nimport subprocess\r\n\r\nfrom sonic_py_common import device_info\r\n\r\n\r\nclass Common:\r\n\r\n    DEVICE_PATH = '/usr/share/sonic/device/'\r\n    PMON_PLATFORM_PATH = '/usr/share/sonic/platform/'\r\n    CONFIG_DIR = 'sonic_platform_config'\r\n\r\n    OUTPUT_SOURCE_IPMI = 'ipmitool'\r\n    OUTPUT_SOURCE_GIVEN_LIST = 'value_list'\r\n    OUTPUT_SOURCE_GIVEN_VALUE = 'value'\r\n    OUTPUT_SOURCE_GIVEN_CLASS = 'class'\r\n    OUTPUT_SOURCE_SYSFS = 'sysfs_value'\r\n    OUTPUT_SOURCE_FUNC = 'function'\r\n    OUTPUT_SOURCE_GIVEN_TXT_FILE = 'txt_file'\r\n    OUTPUT_SOURCE_GIVEN_VER_HEX_FILE = 'hex_version_file'\r\n    OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR = 'hex_version_getreg'\r\n\r\n    SET_METHOD_IPMI = 'ipmitool'\r\n    NULL_VAL = 'N/A'\r\n    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\r\n    REF_KEY = '$ref:'\r\n\r\n    def __init__(self, conf=None):\r\n        self._main_conf = conf\r\n        self.platform = None\r\n        self.hwsku = None\r\n\r\n    def get_platform(self):\r\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku(\r\n        ) if not self.platform else (self.platform, self.hwsku)\r\n        return self.platform\r\n\r\n    def get_hwsku(self):\r\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku(\r\n        ) if not self.hwsku else (self.platform, self.hwsku)\r\n        return self.hwsku\r\n\r\n    def run_command(self, command):\r\n        status = False\r\n        output = \"\"\r\n        try:\r\n            p = subprocess.Popen(\r\n                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n            raw_data, err = p.communicate()\r\n            if p.returncode == 0:\r\n                status, output = True, raw_data.strip()\r\n        except Exception:\r\n            pass\r\n        return status, output\r\n\r\n    def _clean_input(self, input, config):\r\n        cleaned_input = input\r\n\r\n        ai = config.get('avaliable_input')\r\n        if ai and input not in ai:\r\n            return None\r\n\r\n        input_translator = config.get('input_translator')\r\n        if type(input_translator) is dict:\r\n            cleaned_input = input_translator.get(input)\r\n\r\n        elif type(input_translator) is str:\r\n            cleaned_input = eval(input_translator.format(input))\r\n\r\n        return cleaned_input\r\n\r\n    def _clean_output(self, index, output, config):\r\n        output_translator = config.get('output_translator')\r\n\r\n        if type(output_translator) is dict:\r\n            output = output_translator.get(output)\r\n        elif type(output_translator) is str:\r\n            output = eval(output_translator.format(output))\r\n        elif type(output_translator) is list:\r\n            output = eval(output_translator[index].format(output))\r\n\r\n        return output\r\n\r\n    def _ipmi_get(self, index, config):\r\n        argument = config.get('argument')\r\n        cmd = config['command'].format(\r\n            config['argument'][index]) if argument else config['command']\r\n        status, output = self.run_command(cmd)\r\n        return output if status else None\r\n\r\n    def _sysfs_read(self, index, config):\r\n        sysfs_path = config.get('sysfs_path')\r\n        argument = config.get('argument', '')\r\n\r\n        if self.REF_KEY in argument:\r\n            argument = self._main_conf[argument.split(\":\")[1]]\r\n\r\n        if type(argument) is list:\r\n            sysfs_path = sysfs_path.format(argument[index])\r\n\r\n        content = \"\"\r\n        try:\r\n            content = open(sysfs_path)\r\n            content = content.readline().rstrip()\r\n        except IOError as e:\r\n            print(\"Error: unable to open file: %s\" % str(e))\r\n            return False\r\n\r\n        return content\r\n\r\n    def _sysfs_write(self, index, config, input):\r\n        sysfs_path = config.get('sysfs_path')\r\n        argument = config.get('argument', '')\r\n\r\n        if self.REF_KEY in argument:\r\n            argument = self._main_conf[argument.split(\":\")[1]]\r\n\r\n        if type(argument) is list:\r\n            sysfs_path = sysfs_path.format(argument[index])\r\n\r\n        write_offset = int(config.get('write_offset', 0))\r\n        output = \"\"\r\n        try:\r\n            open_file = open(sysfs_path, \"r+\")\r\n            open_file.seek(write_offset)\r\n            open_file.write(input)\r\n            open_file.close()\r\n        except IOError as e:\r\n            print(\"Error: unable to open file: %s\" % str(e))\r\n            return False, output\r\n        return True, output\r\n\r\n    def _ipmi_set(self, index, config, input):\r\n        arg = config['argument'][index].format(input)\r\n        return self.run_command(config['command'].format(arg))\r\n\r\n    def _hex_ver_decode(self, hver, num_of_bits, num_of_points):\r\n        ver_list = []\r\n        c_bit = 0\r\n        bin_val = bin(int(hver, 16))[2:].zfill(num_of_bits)\r\n        bit_split = num_of_bits / (num_of_points + 1)\r\n        for x in range(0, num_of_points+1):\r\n            split_bin = bin_val[c_bit:c_bit+bit_split]\r\n            ver_list.append(str(int(split_bin, 2)))\r\n            c_bit += bit_split\r\n        return '.'.join(ver_list)\r\n\r\n    def _get_class(self, config):\r\n        \"\"\"\r\n        Retreives value of expected attribute\r\n        Returns:\r\n            A value of the attribute of object\r\n        \"\"\"\r\n        path = config['host_path'] if self.is_host() else config['pmon_path']\r\n        module = imp.load_source(config['class'], path)\r\n        class_ = getattr(module, config['class'])\r\n        return class_\r\n\r\n    def get_reg(self, path, reg_addr):\r\n        cmd = \"echo {1} > {0}; cat {0}\".format(path, reg_addr)\r\n        status, output = self.run_command(cmd)\r\n        return output if status else None\r\n\r\n    def set_reg(self, path, reg_addr, value):\r\n        cmd = \"echo {0} {1} > {2}\".format(reg_addr, value, path)\r\n        status, output = self.run_command(cmd)\r\n        return output if status else None\r\n\r\n    def read_txt_file(self, path):\r\n        try:\r\n            with open(path, 'r') as f:\r\n                output = f.readline()\r\n            return output.strip('\\n')\r\n        except Exception:\r\n            pass\r\n        return ''\r\n\r\n    def read_one_line_file(self, file_path):\r\n        try:\r\n            with open(file_path, 'r') as fd:\r\n                data = fd.readline()\r\n                return data.strip()\r\n        except IOError:\r\n            pass\r\n        return ''\r\n\r\n    def write_txt_file(self, file_path, value):\r\n        try:\r\n            with open(file_path, 'w') as fd:\r\n                fd.write(str(value))\r\n        except Exception:\r\n            return False\r\n        return True\r\n\r\n    def is_host(self):\r\n        return os.system(self.HOST_CHK_CMD) == 0\r\n\r\n    def load_json_file(self, path):\r\n        \"\"\"\r\n        Retrieves the json object from json file path\r\n\r\n        Returns:\r\n            A json object\r\n        \"\"\"\r\n        with open(path, 'r') as f:\r\n            json_data = yaml.safe_load(f)\r\n\r\n        return json_data\r\n\r\n    def get_config_path(self, config_name):\r\n        \"\"\"\r\n        Retrieves the path to platform api config directory\r\n\r\n        Args:\r\n            config_name: A string containing the name of config file.\r\n\r\n        Returns:\r\n            A string containing the path to json file\r\n        \"\"\"\r\n        return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\r\n\r\n    def get_output(self, index, config, default):\r\n        \"\"\"\r\n        Retrieves the output for each function base on config\r\n\r\n        Args:\r\n            index: An integer containing the index of device.\r\n            config: A dict object containing the configuration of specified function.\r\n            default: A string containing the default output of specified function.\r\n\r\n        Returns:\r\n            A string containing the output of specified function in config\r\n        \"\"\"\r\n        output_source = config.get('output_source')\r\n\r\n        if output_source == self.OUTPUT_SOURCE_IPMI:\r\n            output = self._ipmi_get(index, config)\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VALUE:\r\n            output = config[\"value\"]\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_CLASS:\r\n            output = self._get_class(config)\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_LIST:\r\n            output = config[\"value_list\"][index]\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_SYSFS:\r\n            output = self._sysfs_read(index, config)\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_FUNC:\r\n            func_conf = self._main_conf[config['function'][index]]\r\n            output = self.get_output(index, func_conf, default)\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\r\n            path = config.get('path')\r\n            output = self.read_txt_file(path)\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\r\n            path = config.get('path')\r\n            hex_ver = self.read_txt_file(path)\r\n            output = self._hex_ver_decode(\r\n                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\r\n            path = config.get('path')\r\n            addr = config.get('reg_addr')\r\n            hex_ver = self.get_reg(path, addr)\r\n            output = self._hex_ver_decode(\r\n                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n\r\n        else:\r\n            output = default\r\n\r\n        return self._clean_output(index, output, config) or default\r\n\r\n    def set_output(self, index, input, config):\r\n        \"\"\"\r\n        Sets the output of specified function on config\r\n\r\n        Args:\r\n            config: A dict object containing the configuration of specified function.\r\n            index: An integer containing the index of device.\r\n            input: A string containing the input of specified function.\r\n\r\n        Returns:\r\n            bool: True if set function is successfully, False if not\r\n        \"\"\"\r\n        cleaned_input = self._clean_input(input, config)\r\n        if not cleaned_input:\r\n            return False\r\n\r\n        set_method = config.get('set_method')\r\n        if set_method == self.SET_METHOD_IPMI:\r\n            output = self._ipmi_set(index, config, cleaned_input)[0]\r\n        elif set_method == self.OUTPUT_SOURCE_SYSFS:\r\n            output = self._sysfs_write(index, config, cleaned_input)[0]\r\n        else:\r\n            output = False\r\n\r\n        return output\r\n\r\n    def get_event(self, timeout, config, sfp_list):\r\n        \"\"\"\r\n        Returns a nested dictionary containing all devices which have\r\n        experienced a change at chassis level\r\n\r\n        \"\"\"\r\n        event_class = self._get_class(config)\r\n        return event_class(sfp_list).get_event(timeout)\r\n"}, "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py": {"changes": [{"diff": "\n try:\n     import os.path\n     import shutil\n-    import shlex\n     import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n except ImportError as e:\n", "add": 0, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py", "badparts": ["    import shlex"], "goodparts": []}, {"diff": "\n     def __run_command(self, command):\n         # Run bash command and print output to stdout\n         try:\n-            process = subprocess.Popen(\n-                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n+            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n             while True:\n                 output = process.stdout.readline()\n                 if output == '' and process.poll() is not None:\n", "add": 1, "remove": 2, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py", "badparts": ["            process = subprocess.Popen(", "                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)"], "goodparts": ["            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)"]}, {"diff": "\n \n     def get_register_value(self, register):\n         # Retrieves the cpld register value\n-        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n-        p = subprocess.Popen(\n-            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-        raw_data, err = p.communicate()\n-        if err is not '':\n-            return None\n+        with open(GETREG_PATH, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(GETREG_PATH, 'r') as file:\n+            raw_data = file.readline()\n         return raw_data.strip()\n \n     def __get_cpld_version(self):\n", "add": 4, "remove": 6, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py", "badparts": ["        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)", "        p = subprocess.Popen(", "            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "        raw_data, err = p.communicate()", "        if err is not '':", "            return None"], "goodparts": ["        with open(GETREG_PATH, 'w') as file:", "            file.write(register + '\\n')", "        with open(GETREG_PATH, 'r') as file:", "            raw_data = file.readline()"]}, {"diff": "\n         cpld_version = dict()\n         with open(SMC_CPLD_PATH, 'r') as fd:\n             smc_cpld_version = fd.read()\n-        smc_cpld_version = 'None' if smc_cpld_version is 'None' else \"{}.{}\".format(\n+        smc_cpld_version = 'None' if smc_cpld_version == 'None' else \"{}.{}\".format(\n             int(smc_cpld_version[2], 16), int(smc_cpld_version[3], 16))\n \n         mmc_cpld_version = self.get_register_value(MMC_CPLD_ADDR)\n-        mmc_cpld_version = 'None' if mmc_cpld_version is 'None' else \"{}.{}\".format(\n+        mmc_cpld_version = 'None' if mmc_cpld_version == 'None' else \"{}.{}\".format(\n             int(mmc_cpld_version[2], 16), int(mmc_cpld_version[3], 16))\n \n         cpld_version[\"SMC_CPLD\"] = smc_cpld_version\n", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py", "badparts": ["        smc_cpld_version = 'None' if smc_cpld_version is 'None' else \"{}.{}\".format(", "        mmc_cpld_version = 'None' if mmc_cpld_version is 'None' else \"{}.{}\".format("], "goodparts": ["        smc_cpld_version = 'None' if smc_cpld_version == 'None' else \"{}.{}\".format(", "        mmc_cpld_version = 'None' if mmc_cpld_version == 'None' else \"{}.{}\".format("]}, {"diff": "\n             ext = \".vme\" if ext == \"\" else ext\n             new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n             shutil.copy(image_path, new_image_path)\n-            install_command = \"ispvm %s\" % new_image_path\n+            install_command = [\"ispvm\", str(new_image_path)]\n         # elif self.name == \"BIOS\":\n         #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n         return self.__run_command(install_comman", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py", "badparts": ["            install_command = \"ispvm %s\" % new_image_path"], "goodparts": ["            install_command = [\"ispvm\", str(new_image_path)]"]}], "source": "\n try: import os.path import shutil import shlex import subprocess from sonic_platform_base.component_base import ComponentBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") MMC_CPLD_ADDR='0x100' BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" CONFIG_DB_PATH=\"/etc/sonic/config_db.json\" SMC_CPLD_PATH=\"/sys/devices/platform/e1031.smc/version\" GETREG_PATH=\"/sys/devices/platform/e1031.smc/getreg\" COMPONENT_NAME_LIST=[\"SMC_CPLD\", \"MMC_CPLD\", \"BIOS\"] COMPONENT_DES_LIST=[\"System Management Controller\", \"Module Management CPLD\", \"Basic Input/Output System\"] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index): ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def get_register_value(self, register): cmd=\"echo{1} >{0}; cat{0}\".format(GETREG_PATH, register) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err is not '': return None return raw_data.strip() def __get_cpld_version(self): cpld_version=dict() with open(SMC_CPLD_PATH, 'r') as fd: smc_cpld_version=fd.read() smc_cpld_version='None' if smc_cpld_version is 'None' else \"{}.{}\".format( int(smc_cpld_version[2], 16), int(smc_cpld_version[3], 16)) mmc_cpld_version=self.get_register_value(MMC_CPLD_ADDR) mmc_cpld_version='None' if mmc_cpld_version is 'None' else \"{}.{}\".format( int(mmc_cpld_version[2], 16), int(mmc_cpld_version[3], 16)) cpld_version[\"SMC_CPLD\"]=smc_cpld_version cpld_version[\"MMC_CPLD\"]=mmc_cpld_version return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_NAME_LIST[self.index] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_DES_LIST[self.index] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def get_available_firmware_version(self, image_path): \"\"\" Retrieves the available firmware version of the component Note: the firmware version will be read from image Args: image_path: A string, path to firmware image Returns: A string containing the available firmware version of the component \"\"\" return \"N/A\" def get_firmware_update_notification(self, image_path): \"\"\" Retrieves a notification on what should be done in order to complete the component firmware update Args: image_path: A string, path to firmware image Returns: A string containing the component firmware update notification if required. By default 'None' value will be used, which indicates that no actions are required \"\"\" return \"None\" def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" if not os.path.isfile(image_path): return False if \"CPLD\" in self.name: img_name=os.path.basename(image_path) root, ext=os.path.splitext(img_name) ext=\".vme\" if ext==\"\" else ext new_image_path=os.path.join(\"/tmp\",(root.lower() +ext)) shutil.copy(image_path, new_image_path) install_command=\"ispvm %s\" % new_image_path return self.__run_command(install_command) def update_firmware(self, image_path): \"\"\" Updates firmware of the component This API performs firmware update: it assumes firmware installation and loading in a single call. In case platform component requires some extra steps(apart from calling Low Level Utility) to load the installed firmware(e.g, reboot, power cycle, etc.) -this will be done automatically by API Args: image_path: A string, path to firmware image Raises: RuntimeError: update failed \"\"\" return False def get_presence(self): \"\"\" Retrieves the presence of the FAN Returns: bool: True if FAN is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return 'N/A' def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return 'N/A' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is'0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\n\ntry:\n    import os.path\n    import shutil\n    import shlex\n    import subprocess\n    from sonic_platform_base.component_base import ComponentBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nMMC_CPLD_ADDR = '0x100'\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCONFIG_DB_PATH = \"/etc/sonic/config_db.json\"\nSMC_CPLD_PATH = \"/sys/devices/platform/e1031.smc/version\"\nGETREG_PATH = \"/sys/devices/platform/e1031.smc/getreg\"\nCOMPONENT_NAME_LIST = [\"SMC_CPLD\", \"MMC_CPLD\", \"BIOS\"]\nCOMPONENT_DES_LIST = [\"System Management Controller\",\n                      \"Module Management CPLD\", \"Basic Input/Output System\"]\n\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index):\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def get_register_value(self, register):\n        # Retrieves the cpld register value\n        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n        p = subprocess.Popen(\n            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        raw_data, err = p.communicate()\n        if err is not '':\n            return None\n        return raw_data.strip()\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        with open(SMC_CPLD_PATH, 'r') as fd:\n            smc_cpld_version = fd.read()\n        smc_cpld_version = 'None' if smc_cpld_version is 'None' else \"{}.{}\".format(\n            int(smc_cpld_version[2], 16), int(smc_cpld_version[3], 16))\n\n        mmc_cpld_version = self.get_register_value(MMC_CPLD_ADDR)\n        mmc_cpld_version = 'None' if mmc_cpld_version is 'None' else \"{}.{}\".format(\n            int(mmc_cpld_version[2], 16), int(mmc_cpld_version[3], 16))\n\n        cpld_version[\"SMC_CPLD\"] = smc_cpld_version\n        cpld_version[\"MMC_CPLD\"] = mmc_cpld_version\n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_NAME_LIST[self.index]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_DES_LIST[self.index]\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def get_available_firmware_version(self, image_path):\n        \"\"\"\n        Retrieves the available firmware version of the component\n        Note: the firmware version will be read from image\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A string containing the available firmware version of the component\n        \"\"\"\n        return \"N/A\"\n\n    def get_firmware_update_notification(self, image_path):\n        \"\"\"\n        Retrieves a notification on what should be done in order to complete\n        the component firmware update\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A string containing the component firmware update notification if required.\n            By default 'None' value will be used, which indicates that no actions are required\n        \"\"\"\n        return \"None\"\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        if not os.path.isfile(image_path):\n            return False\n\n        if \"CPLD\" in self.name:\n            img_name = os.path.basename(image_path)\n            root, ext = os.path.splitext(img_name)\n            ext = \".vme\" if ext == \"\" else ext\n            new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n            shutil.copy(image_path, new_image_path)\n            install_command = \"ispvm %s\" % new_image_path\n        # elif self.name == \"BIOS\":\n        #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n        return self.__run_command(install_command)\n\n    def update_firmware(self, image_path):\n        \"\"\"\n        Updates firmware of the component\n        This API performs firmware update: it assumes firmware installation and loading in a single call.\n        In case platform component requires some extra steps (apart from calling Low Level Utility)\n        to load the installed firmware (e.g, reboot, power cycle, etc.) - this will be done automatically by API\n        Args:\n            image_path: A string, path to firmware image\n        Raises:\n            RuntimeError: update failed\n        \"\"\"\n        return False\n\n    ##############################################################\n    ###################### Device methods ########################\n    ##############################################################\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the FAN\n        Returns:\n            bool: True if FAN is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of\n        entPhysicalContainedIn is'0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device\n            or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py": {"changes": [{"diff": "\n         thermal_overload_position = Common().read_txt_file(\r\n             thermal_overload_position_path)\r\n \r\n-        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\r\n-            thermal_overload_position)\r\n+        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', thermal_overload_position]\r\n         Common().run_command(cm", "add": 1, "remove": 2, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py", "badparts": ["        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\r", "            thermal_overload_position)\r"], "goodparts": ["        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', thermal_overload_position]\r"]}], "source": "\nfrom sonic_platform_base.sonic_thermal_control.thermal_action_base import ThermalPolicyActionBase\r from sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object\r from.thermal_infos import ChassisInfo\r from.common import Common\r \r \r @thermal_json_object('thermal_control.control')\r class ControlThermalAlgoAction(ThermalPolicyActionBase):\r \"\"\"\r Action to control the thermal control algorithm\r \"\"\"\r JSON_FIELD_STATUS='status'\r \r def __init__(self):\r self.status=True\r \r def load_from_json(self, json_obj):\r \"\"\"\r Construct ControlThermalAlgoAction via JSON. JSON example:\r {\r \"type\": \"thermal_control.control\"\r \"status\": \"true\"\r }\r :param json_obj: A JSON object representing a ControlThermalAlgoAction action.\r :return:\r \"\"\"\r if ControlThermalAlgoAction.JSON_FIELD_STATUS in json_obj:\r status_str=json_obj[ControlThermalAlgoAction.JSON_FIELD_STATUS].lower(\r )\r if status_str=='true':\r self.status=True\r elif status_str=='false':\r self.status=False\r else:\r raise ValueError('Invalid{} field value, please specify true of false'.\r format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\r else:\r raise ValueError('ControlThermalAlgoAction '\r 'missing mandatory field{} in JSON policy file'.\r format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\r \r def execute(self, thermal_info_dict):\r \"\"\"\r Disable thermal control algorithm\r :param thermal_info_dict: A dictionary stores all thermal information.\r :return:\r \"\"\"\r if ChassisInfo.INFO_NAME in thermal_info_dict:\r chassis_info_obj=thermal_info_dict[ChassisInfo.INFO_NAME]\r chassis=chassis_info_obj.get_chassis()\r thermal_manager=chassis.get_thermal_manager()\r if self.status:\r thermal_manager.start_thermal_control_algorithm()\r else:\r thermal_manager.stop_thermal_control_algorithm()\r \r \r @thermal_json_object('switch.power_cycling')\r class SwitchPolicyAction(ThermalPolicyActionBase):\r \"\"\"\r Base class for thermal action. Once all thermal conditions in a thermal policy are matched,\r all predefined thermal action will be executed.\r \"\"\"\r \r def execute(self, thermal_info_dict):\r \"\"\"\r Take action when thermal condition matches. For example, power cycle the switch.\r :param thermal_info_dict: A dictionary stores all thermal information.\r :return:\r \"\"\"\r thermal_overload_position_path='/tmp/thermal_overload_position'\r thermal_overload_position=Common().read_txt_file(\r thermal_overload_position_path)\r \r cmd='bash /usr/share/sonic/platform/thermal_overload_control.sh{}'.format(\r thermal_overload_position)\r Common().run_command(cmd)\r ", "sourceWithComments": "from sonic_platform_base.sonic_thermal_control.thermal_action_base import ThermalPolicyActionBase\r\nfrom sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object\r\nfrom .thermal_infos import ChassisInfo\r\nfrom .common import Common\r\n\r\n\r\n@thermal_json_object('thermal_control.control')\r\nclass ControlThermalAlgoAction(ThermalPolicyActionBase):\r\n    \"\"\"\r\n    Action to control the thermal control algorithm\r\n    \"\"\"\r\n    # JSON field definition\r\n    JSON_FIELD_STATUS = 'status'\r\n\r\n    def __init__(self):\r\n        self.status = True\r\n\r\n    def load_from_json(self, json_obj):\r\n        \"\"\"\r\n        Construct ControlThermalAlgoAction via JSON. JSON example:\r\n            {\r\n                \"type\": \"thermal_control.control\"\r\n                \"status\": \"true\"\r\n            }\r\n        :param json_obj: A JSON object representing a ControlThermalAlgoAction action.\r\n        :return:\r\n        \"\"\"\r\n        if ControlThermalAlgoAction.JSON_FIELD_STATUS in json_obj:\r\n            status_str = json_obj[ControlThermalAlgoAction.JSON_FIELD_STATUS].lower(\r\n            )\r\n            if status_str == 'true':\r\n                self.status = True\r\n            elif status_str == 'false':\r\n                self.status = False\r\n            else:\r\n                raise ValueError('Invalid {} field value, please specify true of false'.\r\n                                 format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\r\n        else:\r\n            raise ValueError('ControlThermalAlgoAction '\r\n                             'missing mandatory field {} in JSON policy file'.\r\n                             format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\r\n\r\n    def execute(self, thermal_info_dict):\r\n        \"\"\"\r\n        Disable thermal control algorithm\r\n        :param thermal_info_dict: A dictionary stores all thermal information.\r\n        :return:\r\n        \"\"\"\r\n        if ChassisInfo.INFO_NAME in thermal_info_dict:\r\n            chassis_info_obj = thermal_info_dict[ChassisInfo.INFO_NAME]\r\n            chassis = chassis_info_obj.get_chassis()\r\n            thermal_manager = chassis.get_thermal_manager()\r\n            if self.status:\r\n                thermal_manager.start_thermal_control_algorithm()\r\n            else:\r\n                thermal_manager.stop_thermal_control_algorithm()\r\n\r\n\r\n@thermal_json_object('switch.power_cycling')\r\nclass SwitchPolicyAction(ThermalPolicyActionBase):\r\n    \"\"\"\r\n    Base class for thermal action. Once all thermal conditions in a thermal policy are matched,\r\n    all predefined thermal action will be executed.\r\n    \"\"\"\r\n\r\n    def execute(self, thermal_info_dict):\r\n        \"\"\"\r\n        Take action when thermal condition matches. For example, power cycle the switch.\r\n        :param thermal_info_dict: A dictionary stores all thermal information.\r\n        :return:\r\n        \"\"\"\r\n        thermal_overload_position_path = '/tmp/thermal_overload_position'\r\n        thermal_overload_position = Common().read_txt_file(\r\n            thermal_overload_position_path)\r\n\r\n        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\r\n            thermal_overload_position)\r\n        Common().run_command(cmd)\r\n"}, "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py": {"changes": [{"diff": "\n \n \n class ThermalManager(ThermalManagerBase):\n-    FSC_ALGORITHM_CMD = ' supervisorctl {} fancontrol'\n+    FSC_ALGORITHM_CMD = ['supervisorctl', '', 'fancontrol']\n \n     @classmethod\n     def start_thermal_control_algorithm(cls):\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py", "badparts": ["    FSC_ALGORITHM_CMD = ' supervisorctl {} fancontrol'"], "goodparts": ["    FSC_ALGORITHM_CMD = ['supervisorctl', '', 'fancontrol']"]}, {"diff": "\n         Returns:\n             bool: True if set success, False if fail.\n         \"\"\"\n-        cmd = 'start' if enable else 'stop'\n-        return Common().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n+        cls.FSC_ALGORITHM_CMD[1] = 'start' if enable else 'stop'\n+        return Common().run_command(cls.FSC_ALGORITHM_", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py", "badparts": ["        cmd = 'start' if enable else 'stop'", "        return Common().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))"], "goodparts": ["        cls.FSC_ALGORITHM_CMD[1] = 'start' if enable else 'stop'", "        return Common().run_command(cls.FSC_ALGORITHM_"]}], "source": "\nfrom sonic_platform_base.sonic_thermal_control.thermal_manager_base import ThermalManagerBase from.common import Common from.thermal_actions import * from.thermal_conditions import * from.thermal_infos import * class ThermalManager(ThermalManagerBase): FSC_ALGORITHM_CMD=' supervisorctl{} fancontrol' @classmethod def start_thermal_control_algorithm(cls): \"\"\" Start vendor specific thermal control algorithm. The default behavior of this function is a no-op. :return: \"\"\" return cls._enable_fancontrol_service(True) @classmethod def stop_thermal_control_algorithm(cls): \"\"\" Stop thermal control algorithm Returns: bool: True if set success, False if fail. \"\"\" return cls._enable_fancontrol_service(False) @classmethod def deinitialize(cls): \"\"\" Destroy thermal manager, including any vendor specific cleanup. The default behavior of this function is a no-op. :return: \"\"\" return cls._enable_fancontrol_service(True) @classmethod def _enable_fancontrol_service(cls, enable): \"\"\" Control thermal by fcs algorithm Args: enable: Bool, indicate enable the algorithm or not Returns: bool: True if set success, False if fail. \"\"\" cmd='start' if enable else 'stop' return Common().run_command(cls.FSC_ALGORITHM_CMD.format(cmd)) ", "sourceWithComments": "from sonic_platform_base.sonic_thermal_control.thermal_manager_base import ThermalManagerBase\nfrom .common import Common\nfrom .thermal_actions import *\nfrom .thermal_conditions import *\nfrom .thermal_infos import *\n\n\nclass ThermalManager(ThermalManagerBase):\n    FSC_ALGORITHM_CMD = ' supervisorctl {} fancontrol'\n\n    @classmethod\n    def start_thermal_control_algorithm(cls):\n        \"\"\"\n        Start vendor specific thermal control algorithm. The default behavior of this function is a no-op.\n        :return:\n        \"\"\"\n        return cls._enable_fancontrol_service(True)\n\n    @classmethod\n    def stop_thermal_control_algorithm(cls):\n        \"\"\"\n        Stop thermal control algorithm\n        Returns:\n            bool: True if set success, False if fail.\n        \"\"\"\n        return cls._enable_fancontrol_service(False)\n\n    @classmethod\n    def deinitialize(cls):\n        \"\"\"\n        Destroy thermal manager, including any vendor specific cleanup. The default behavior of this function\n        is a no-op.\n        :return:\n        \"\"\"\n        return cls._enable_fancontrol_service(True)\n\n    @classmethod\n    def _enable_fancontrol_service(cls, enable):\n        \"\"\"\n        Control thermal by fcs algorithm\n        Args:\n            enable: Bool, indicate enable the algorithm or not\n        Returns:\n            bool: True if set success, False if fail.\n        \"\"\"\n        cmd = 'start' if enable else 'stop'\n        return Common().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n"}, "/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import os.path\n-import subprocess\n \n try:\n     from sonic_psu.psu_base import Ps", "add": 0, "remove": 2, "filename": "/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py", "badparts": ["import subprocess"], "goodparts": []}], "source": "\n import os.path import subprocess try: from sonic_psu.psu_base import PsuBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class PsuUtil(PsuBase): \"\"\"Platform-specific PSUutil class\"\"\" def __init__(self): PsuBase.__init__(self) def get_num_psus(self): \"\"\" Retrieves the number of PSUs available on the device :return: An integer, the number of PSUs available on the device \"\"\" return 2 def get_psu_status(self, index): \"\"\" Retrieves the oprational status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is operating properly, False if PSU is faulty \"\"\" if index is None: return False status=1 return status==1 def get_psu_presence(self, index): \"\"\" Retrieves the presence status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is plugged, False if not \"\"\" if index is None: return False status=1 return status==1 ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Module contains an implementation of SONiC PSU Base API and\n# provides the PSUs status which are available in the platform\n#\n#############################################################################\n\nimport os.path\nimport subprocess\n\ntry:\n    from sonic_psu.psu_base import PsuBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass PsuUtil(PsuBase):\n    \"\"\"Platform-specific PSUutil class\"\"\"\n\n    def __init__(self):\n        PsuBase.__init__(self)\n\n    def get_num_psus(self):\n        \"\"\"\n        Retrieves the number of PSUs available on the device\n\n        :return: An integer, the number of PSUs available on the device\n        \"\"\"\n        return 2\n\n    def get_psu_status(self, index):\n        \"\"\"\n        Retrieves the oprational status of power supply unit (PSU) defined\n                by 1-based index <index>\n\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is operating properly, False if PSU is faulty\n        \"\"\"\n        if index is None:\n            return False\n\n        status = 1\n        return status == 1\n\n    def get_psu_presence(self, index):\n        \"\"\"\n        Retrieves the presence status of power supply unit (PSU) defined\n                by 1-based index <index>\n\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is plugged, False if not\n        \"\"\"\n        if index is None:\n            return False\n\n        status = 1\n        return status == 1\n"}, "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n GETREG_PATH = \"/sys/devices/platform/dx010_cpld/getreg\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n STATUS_LED_PATH = \"/sys/devices/platform/leds_dx010/leds/dx010:green:stat/brightnes", "add": 0, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": []}], "source": "\n try: import sys from sonic_platform_base.chassis_base import ChassisBase from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper from sonic_py_common import device_info from.event import SfpEvent from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=5 NUM_PSU=2 NUM_THERMAL=5 NUM_SFP=32 NUM_COMPONENT=5 RESET_REGISTER=\"0x103\" HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" GETREG_PATH=\"/sys/devices/platform/dx010_cpld/getreg\" HOST_CHK_CMD=\"docker > /dev/null 2>&1\" STATUS_LED_PATH=\"/sys/devices/platform/leds_dx010/leds/dx010:green:stat/brightness\" class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self.sfp_module_initialized=False self.__initialize_eeprom() self.is_host=self._api_helper.is_host() self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() def __initialize_sfp(self): sfputil_helper=SfpUtilHelper() port_config_file_path=device_info.get_path_to_port_config_file() sfputil_helper.read_porttab_mappings(port_config_file_path, 0) from sonic_platform.sfp import Sfp for index in range(0, NUM_SFP): sfp=Sfp(index, sfputil_helper.logical[index]) self._sfp_list.append(sfp) self.sfp_module_initialized=True def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for i in range(NUM_FAN_TRAY): fandrawer=FanDrawer(i) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_thermals(self): from sonic_platform.thermal import Thermal airflow=self.__get_air_flow() for index in range(0, NUM_THERMAL): thermal=Thermal(index, airflow) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __get_air_flow(self): air_flow_path='/usr/share/sonic/device/{}/fan_airflow'.format( self._api_helper.platform) \\ if self.is_host else '/usr/share/sonic/platform/fan_airflow' air_flow=self._api_helper.read_one_line_file(air_flow_path) return air_flow or 'B2F' def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. REBOOT_CAUSE_POWER_LOSS=\"Power Loss\" REBOOT_CAUSE_THERMAL_OVERLOAD_CPU=\"Thermal Overload: CPU\" REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC=\"Thermal Overload: ASIC\" REBOOT_CAUSE_THERMAL_OVERLOAD_OTHER=\"Thermal Overload: Other\" REBOOT_CAUSE_INSUFFICIENT_FAN_SPEED=\"Insufficient Fan Speed\" REBOOT_CAUSE_WATCHDOG=\"Watchdog\" REBOOT_CAUSE_HARDWARE_OTHER=\"Hardware -Other\" REBOOT_CAUSE_NON_HARDWARE=\"Non-Hardware\" \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" hw_reboot_cause=self._api_helper.get_cpld_reg_value( GETREG_PATH, RESET_REGISTER) prev_reboot_cause={ '0x11':(self.REBOOT_CAUSE_POWER_LOSS, 'Power on reset'), '0x22':(self.REBOOT_CAUSE_HARDWARE_OTHER, 'CPLD_WD_RESET'), '0x33':(self.REBOOT_CAUSE_HARDWARE_OTHER, 'Power cycle reset triggered by CPU'), '0x44':(self.REBOOT_CAUSE_HARDWARE_OTHER, 'Power cycle reset triggered by reset button'), '0x55':(self.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU, ''), '0x66':(self.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC, ''), '0x77':(self.REBOOT_CAUSE_WATCHDOG, '') }.get(hw_reboot_cause,(self.REBOOT_CAUSE_HARDWARE_OTHER, 'Unknown reason')) if sw_reboot_cause !='Unknown' and hw_reboot_cause=='0x11': prev_reboot_cause=( self.REBOOT_CAUSE_NON_HARDWARE, sw_reboot_cause) return prev_reboot_cause def get_change_event(self, timeout=0): \"\"\" Returns a nested dictionary containing all devices which have experienced a change at chassis level Args: timeout: Timeout in milliseconds(optional). If timeout==0, this method will block until a change is detected. Returns: (bool, dict): -True if call successful, False if not; -A nested dictionary where key is a device type, value is a dictionary with key:value pairs in the format of {'device_id':'device_event'}, where device_id is the device ID for this device and device_event, status='1' represents device inserted, status='0' represents device removed. Ex.{'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}} indicates that fan 0 has been removed, fan 2 has been inserted and sfp 11 has been removed. \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() sfp_event=SfpEvent(self._sfp_list).get_sfp_event(timeout) if sfp_event: return True,{'sfp': sfp_event} return False,{'sfp':{}} def get_num_sfps(self): \"\"\" Retrieves the number of sfps available on this chassis Returns: An integer, the number of sfps available on this chassis \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() return len(self._sfp_list) def get_all_sfps(self): \"\"\" Retrieves all sfps available on this chassis Returns: A list of objects derived from SfpBase representing all sfps available on this chassis \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfp_list def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index -1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_watchdog(self): \"\"\" Retreives hardware watchdog device on this chassis Returns: An object derived from WatchdogBase representing the hardware watchdog device \"\"\" if self._watchdog is None: from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() return self._watchdog def get_thermal_manager(self): from.thermal_manager import ThermalManager return ThermalManager def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._api_helper.hwsku def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return self._eeprom.get_serial() def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def set_status_led(self, color): \"\"\" Sets the state of the PSU status LED Args: color: A string representing the color with which to set the PSU status LED Note: Only support green and off Returns: bool: True if status LED state is set successfully, False if not \"\"\" set_status_str={ self.STATUS_LED_COLOR_GREEN: '1', self.STATUS_LED_COLOR_OFF: '0' }.get(color, None) if not set_status_str: return False return self._api_helper.write_txt_file(STATUS_LED_PATH, set_status_str) def get_status_led(self): \"\"\" Gets the state of the PSU status LED Returns: A string, one of the predefined STATUS_LED_COLOR_* strings above \"\"\" status=self._api_helper.read_txt_file(STATUS_LED_PATH) status_str={ '255': self.STATUS_LED_COLOR_GREEN, '0': self.STATUS_LED_COLOR_OFF }.get(status, None) return status_str ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\ntry:\n    import sys\n    from sonic_platform_base.chassis_base import ChassisBase\n    from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper\n    from sonic_py_common import device_info\n    from .event import SfpEvent\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 5\nNUM_PSU = 2\nNUM_THERMAL = 5\nNUM_SFP = 32\nNUM_COMPONENT = 5\nRESET_REGISTER = \"0x103\"\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nGETREG_PATH = \"/sys/devices/platform/dx010_cpld/getreg\"\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nSTATUS_LED_PATH = \"/sys/devices/platform/leds_dx010/leds/dx010:green:stat/brightness\"\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self.sfp_module_initialized = False\n        self.__initialize_eeprom()\n        self.is_host = self._api_helper.is_host()\n\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n\n    def __initialize_sfp(self):\n        sfputil_helper = SfpUtilHelper()\n        port_config_file_path = device_info.get_path_to_port_config_file()\n        sfputil_helper.read_porttab_mappings(port_config_file_path, 0)\n\n        from sonic_platform.sfp import Sfp\n        for index in range(0, NUM_SFP):\n            sfp = Sfp(index, sfputil_helper.logical[index])\n            self._sfp_list.append(sfp)\n        self.sfp_module_initialized = True\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_fan(self):\n        from sonic_platform.fan_drawer import FanDrawer\n        for i in range(NUM_FAN_TRAY):\n            fandrawer = FanDrawer(i)\n            self._fan_drawer_list.append(fandrawer)\n            self._fan_list.extend(fandrawer._fan_list)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        airflow = self.__get_air_flow()\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index, airflow)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __get_air_flow(self):\n        air_flow_path = '/usr/share/sonic/device/{}/fan_airflow'.format(\n            self._api_helper.platform) \\\n            if self.is_host else '/usr/share/sonic/platform/fan_airflow'\n        air_flow = self._api_helper.read_one_line_file(air_flow_path)\n        return air_flow or 'B2F'\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n\n            REBOOT_CAUSE_POWER_LOSS = \"Power Loss\"\n            REBOOT_CAUSE_THERMAL_OVERLOAD_CPU = \"Thermal Overload: CPU\"\n            REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC = \"Thermal Overload: ASIC\"\n            REBOOT_CAUSE_THERMAL_OVERLOAD_OTHER = \"Thermal Overload: Other\"\n            REBOOT_CAUSE_INSUFFICIENT_FAN_SPEED = \"Insufficient Fan Speed\"\n            REBOOT_CAUSE_WATCHDOG = \"Watchdog\"\n            REBOOT_CAUSE_HARDWARE_OTHER = \"Hardware - Other\"\n            REBOOT_CAUSE_NON_HARDWARE = \"Non-Hardware\"\n\n        \"\"\"\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n        hw_reboot_cause = self._api_helper.get_cpld_reg_value(\n            GETREG_PATH, RESET_REGISTER)\n\n        prev_reboot_cause = {\n            '0x11': (self.REBOOT_CAUSE_POWER_LOSS, 'Power on reset'),\n            '0x22': (self.REBOOT_CAUSE_HARDWARE_OTHER, 'CPLD_WD_RESET'),\n            '0x33': (self.REBOOT_CAUSE_HARDWARE_OTHER, 'Power cycle reset triggered by CPU'),\n            '0x44': (self.REBOOT_CAUSE_HARDWARE_OTHER, 'Power cycle reset triggered by reset button'),\n            '0x55': (self.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU, ''),\n            '0x66': (self.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC, ''),\n            '0x77': (self.REBOOT_CAUSE_WATCHDOG, '')\n        }.get(hw_reboot_cause, (self.REBOOT_CAUSE_HARDWARE_OTHER, 'Unknown reason'))\n\n        if sw_reboot_cause != 'Unknown' and hw_reboot_cause == '0x11':\n            prev_reboot_cause = (\n                self.REBOOT_CAUSE_NON_HARDWARE, sw_reboot_cause)\n\n        return prev_reboot_cause\n\n    def get_change_event(self, timeout=0):\n        \"\"\"\n        Returns a nested dictionary containing all devices which have\n        experienced a change at chassis level\n        Args:\n            timeout: Timeout in milliseconds (optional). If timeout == 0,\n                this method will block until a change is detected.\n        Returns:\n            (bool, dict):\n                - True if call successful, False if not;\n                - A nested dictionary where key is a device type,\n                  value is a dictionary with key:value pairs in the format of\n                  {'device_id':'device_event'},\n                  where device_id is the device ID for this device and\n                        device_event,\n                             status='1' represents device inserted,\n                             status='0' represents device removed.\n                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}\n                      indicates that fan 0 has been removed, fan 2\n                      has been inserted and sfp 11 has been removed.\n        \"\"\"\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        sfp_event = SfpEvent(self._sfp_list).get_sfp_event(timeout)\n        if sfp_event:\n            return True, {'sfp': sfp_event}\n\n        return False, {'sfp': {}}\n\n    ##############################################################\n    ######################## SFP methods #########################\n    ##############################################################\n\n    def get_num_sfps(self):\n        \"\"\"\n        Retrieves the number of sfps available on this chassis\n        Returns:\n            An integer, the number of sfps available on this chassis\n        \"\"\"\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return len(self._sfp_list)\n\n    def get_all_sfps(self):\n        \"\"\"\n        Retrieves all sfps available on this chassis\n        Returns:\n            A list of objects derived from SfpBase representing all sfps\n            available on this chassis\n        \"\"\"\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return self._sfp_list\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index - 1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    ##############################################################\n    ####################### Other methods ########################\n    ##############################################################\n\n    def get_watchdog(self):\n        \"\"\"\n        Retreives hardware watchdog device on this chassis\n        Returns:\n            An object derived from WatchdogBase representing the hardware\n            watchdog device\n        \"\"\"\n        if self._watchdog is None:\n            from sonic_platform.watchdog import Watchdog\n            self._watchdog = Watchdog()\n\n        return self._watchdog\n\n    def get_thermal_manager(self):\n        from .thermal_manager import ThermalManager\n        return ThermalManager\n\n    ##############################################################\n    ###################### Device methods ########################\n    ##############################################################\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return self._api_helper.hwsku\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the PSU status LED\n        Args:\n            color: A string representing the color with which to set the PSU status LED\n                   Note: Only support green and off\n        Returns:\n            bool: True if status LED state is set successfully, False if not\n        \"\"\"\n\n        set_status_str = {\n            self.STATUS_LED_COLOR_GREEN: '1',\n            self.STATUS_LED_COLOR_OFF: '0'\n        }.get(color, None)\n\n        if not set_status_str:\n            return False\n\n        return self._api_helper.write_txt_file(STATUS_LED_PATH, set_status_str)\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the PSU status LED\n        Returns:\n            A string, one of the predefined STATUS_LED_COLOR_* strings above\n        \"\"\"\n        status = self._api_helper.read_txt_file(STATUS_LED_PATH)\n        status_str = {\n            '255': self.STATUS_LED_COLOR_GREEN,\n            '0': self.STATUS_LED_COLOR_OFF\n        }.get(status, None)\n\n        return status_str\n"}, "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py": {"changes": [{"diff": "\n \n import os.path\n import shutil\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py", "badparts": ["import subprocess"], "goodparts": []}, {"diff": "\n \n     def get_register_value(self, register):\n         # Retrieves the cpld register value\n-        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n-        p = subprocess.Popen(\n-            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-        raw_data, err = p.communicate()\n-        if err is not '':\n-            return None\n+        with open(GETREG_PATH, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(GETREG_PATH, 'r') as file:\n+            raw_data = file.readline()\n         return raw_data.strip()\n \n     def __get_cpld_version(self):\n", "add": 4, "remove": 6, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py", "badparts": ["        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)", "        p = subprocess.Popen(", "            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "        raw_data, err = p.communicate()", "        if err is not '':", "            return None"], "goodparts": ["        with open(GETREG_PATH, 'w') as file:", "            file.write(register + '\\n')", "        with open(GETREG_PATH, 'r') as file:", "            raw_data = file.readline()"]}, {"diff": "\n             ext = \".vme\" if ext == \"\" else ext\n             new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n             shutil.copy(image_path, new_image_path)\n-            install_command = \"ispvm %s\" % new_image_path\n+            install_command = [\"ispvm\", str(new_image_path)]\n         # elif self.name == \"BIOS\":\n         #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n \n-        return self.__run_command(install_command)\n+        return self._api_helper.run_command(install_command)\n \n \n     def update_firmware(self, image", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py", "badparts": ["            install_command = \"ispvm %s\" % new_image_path", "        return self.__run_command(install_command)"], "goodparts": ["            install_command = [\"ispvm\", str(new_image_path)]", "        return self._api_helper.run_command(install_command)"]}], "source": "\n import os.path import shutil import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"0x100\", \"CPLD2\": \"0x200\", \"CPLD3\": \"0x280\", \"CPLD4\": \"0x300\", \"CPLD5\": \"0x380\" } GETREG_PATH=\"/sys/devices/platform/dx010_cpld/getreg\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_NAME_LIST=[\"CPLD1\", \"CPLD2\", \"CPLD3\", \"CPLD4\", \"BIOS\"] COMPONENT_DES_LIST=[\"Used for managing the CPU\", \"Used for managing QSFP+ports(1-10)\", \"Used for managing QSFP+ports(11-20)\", \"Used for managing QSFP+ports(22-32)\", \"Basic Input/Output System\"] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index): ComponentBase.__init__(self) self.index=component_index self._api_helper=APIHelper() self.name=self.get_name() def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def get_register_value(self, register): cmd=\"echo{1} >{0}; cat{0}\".format(GETREG_PATH, register) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err is not '': return None return raw_data.strip() def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_addr=CPLD_ADDR_MAPPING[cpld_name] cpld_version_raw=self.get_register_value(cpld_addr) cpld_version_str=\"{}.{}\".format(int(cpld_version_raw[2], 16), int( cpld_version_raw[3], 16)) if cpld_version_raw is not None else 'None' cpld_version[cpld_name]=cpld_version_str except Exception as e: cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_NAME_LIST[self.index] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_DES_LIST[self.index] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def get_available_firmware_version(self, image_path): \"\"\" Retrieves the available firmware version of the component Note: the firmware version will be read from image Args: image_path: A string, path to firmware image Returns: A string containing the available firmware version of the component \"\"\" return \"N/A\" def get_firmware_update_notification(self, image_path): \"\"\" Retrieves a notification on what should be done in order to complete the component firmware update Args: image_path: A string, path to firmware image Returns: A string containing the component firmware update notification if required. By default 'None' value will be used, which indicates that no actions are required \"\"\" return \"None\" def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" if not os.path.isfile(image_path): return False if \"CPLD\" in self.name: img_name=os.path.basename(image_path) root, ext=os.path.splitext(img_name) ext=\".vme\" if ext==\"\" else ext new_image_path=os.path.join(\"/tmp\",(root.lower() +ext)) shutil.copy(image_path, new_image_path) install_command=\"ispvm %s\" % new_image_path return self.__run_command(install_command) def update_firmware(self, image_path): \"\"\" Updates firmware of the component This API performs firmware update: it assumes firmware installation and loading in a single call. In case platform component requires some extra steps(apart from calling Low Level Utility) to load the installed firmware(e.g, reboot, power cycle, etc.) -this will be done automatically by API Args: image_path: A string, path to firmware image Raises: RuntimeError: update failed \"\"\" return False def get_presence(self): \"\"\" Retrieves the presence of the FAN Returns: bool: True if FAN is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return 'N/A' def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return 'N/A' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is'0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport os.path\nimport shutil\nimport subprocess\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"0x100\",\n    \"CPLD2\": \"0x200\",\n    \"CPLD3\": \"0x280\",\n    \"CPLD4\": \"0x300\",\n    \"CPLD5\": \"0x380\"\n}\nGETREG_PATH = \"/sys/devices/platform/dx010_cpld/getreg\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_NAME_LIST = [\"CPLD1\", \"CPLD2\", \"CPLD3\", \"CPLD4\", \"BIOS\"]\nCOMPONENT_DES_LIST = [\"Used for managing the CPU\",\n                      \"Used for managing QSFP+ ports (1-10)\", \"Used for managing QSFP+ ports (11-20)\", \"Used for managing QSFP+ ports (22-32)\", \"Basic Input/Output System\"]\n\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index):\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self._api_helper = APIHelper()\n        self.name = self.get_name()\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def get_register_value(self, register):\n        # Retrieves the cpld register value\n        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n        p = subprocess.Popen(\n            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        raw_data, err = p.communicate()\n        if err is not '':\n            return None\n        return raw_data.strip()\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_addr = CPLD_ADDR_MAPPING[cpld_name]\n                cpld_version_raw = self.get_register_value(cpld_addr)\n                cpld_version_str = \"{}.{}\".format(int(cpld_version_raw[2], 16), int(\n                    cpld_version_raw[3], 16)) if cpld_version_raw is not None else 'None'\n                cpld_version[cpld_name] = cpld_version_str\n            except Exception as e:\n                cpld_version[cpld_name] = 'None'\n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_NAME_LIST[self.index]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_DES_LIST[self.index]\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def get_available_firmware_version(self, image_path):\n        \"\"\"\n        Retrieves the available firmware version of the component\n        Note: the firmware version will be read from image\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A string containing the available firmware version of the component\n        \"\"\"\n        return \"N/A\"\n\n    def get_firmware_update_notification(self, image_path):\n        \"\"\"\n        Retrieves a notification on what should be done in order to complete\n        the component firmware update\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A string containing the component firmware update notification if required.\n            By default 'None' value will be used, which indicates that no actions are required\n        \"\"\"\n        return \"None\"\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        if not os.path.isfile(image_path):\n            return False\n\n        if \"CPLD\" in self.name:\n            img_name = os.path.basename(image_path)\n            root, ext = os.path.splitext(img_name)\n            ext = \".vme\" if ext == \"\" else ext\n            new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n            shutil.copy(image_path, new_image_path)\n            install_command = \"ispvm %s\" % new_image_path\n        # elif self.name == \"BIOS\":\n        #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n\n        return self.__run_command(install_command)\n\n\n    def update_firmware(self, image_path):\n        \"\"\"\n        Updates firmware of the component\n        This API performs firmware update: it assumes firmware installation and loading in a single call.\n        In case platform component requires some extra steps (apart from calling Low Level Utility)\n        to load the installed firmware (e.g, reboot, power cycle, etc.) - this will be done automatically by API\n        Args:\n            image_path: A string, path to firmware image\n        Raises:\n            RuntimeError: update failed\n        \"\"\"\n        return False\n\n\n    ##############################################################\n    ###################### Device methods ########################\n    ##############################################################\n\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the FAN\n        Returns:\n            bool: True if FAN is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of\n        entPhysicalContainedIn is'0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device\n            or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n \n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 5, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        try:", "            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)", "        except FileNotFoundError:", "            return False", "        return True"]}, {"diff": "\n         result = \"\"\n         try:\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = raw_data.strip()\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py", "badparts": ["                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"], "goodparts": ["                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n", "add": 0, "remove": 7, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py", "badparts": ["    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n         return True\n \n     def get_cpld_reg_value(self, getreg_path, register):\n-        cmd = \"echo {1} > {0}; cat {0}\".format(getreg_path, register)\n-        status, result = self.run_command(cmd)\n-        return result if status else None\n+        with open(getreg_path, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(getreg_path, 'r') as file:\n+            result = file.readline()\n+        return result\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(\n-                str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status", "add": 5, "remove": 53, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py", "badparts": ["        cmd = \"echo {1} > {0}; cat {0}\".format(getreg_path, register)", "        status, result = self.run_command(cmd)", "        return result if status else None", "    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(", "                str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except:", "            status = False", "        return status"], "goodparts": ["        with open(getreg_path, 'w') as file:", "            file.write(register + '\\n')", "        with open(getreg_path, 'r') as file:", "            result = file.readline()", "        return result"]}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def read_one_line_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.readline() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except Exception: return False return True def get_cpld_reg_value(self, getreg_path, register): cmd=\"echo{1} >{0}; cat{0}\".format(getreg_path, register) status, result=self.run_command(cmd) return result if status else None def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format( str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\n\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def read_one_line_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.readline()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except Exception:\n            return False\n        return True\n\n    def get_cpld_reg_value(self, getreg_path, register):\n        cmd = \"echo {1} > {0}; cat {0}\".format(getreg_path, register)\n        status, result = self.run_command(cmd)\n        return result if status else None\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(\n                str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n"}, "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py": {"changes": [{"diff": "\n         thermal_overload_position = APIHelper().read_one_line_file(\n             thermal_overload_position_path)\n \n-        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\n-            thermal_overload_position)\n+        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', str(thermal_overload_position)]\n         APIHelper().run_com", "add": 1, "remove": 2, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py", "badparts": ["        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(", "            thermal_overload_position)"], "goodparts": ["        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', str(thermal_overload_position)]"]}], "source": "\n\nfrom sonic_platform_base.sonic_thermal_control.thermal_action_base import ThermalPolicyActionBase from sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object from.thermal_infos import ChassisInfo from.helper import APIHelper @thermal_json_object('thermal_control.control') class ControlThermalAlgoAction(ThermalPolicyActionBase): \"\"\" Action to control the thermal control algorithm \"\"\" JSON_FIELD_STATUS='status' def __init__(self): self.status=True def load_from_json(self, json_obj): \"\"\" Construct ControlThermalAlgoAction via JSON. JSON example: { \"type\": \"thermal_control.control\" \"status\": \"true\" } :param json_obj: A JSON object representing a ControlThermalAlgoAction action. :return: \"\"\" if ControlThermalAlgoAction.JSON_FIELD_STATUS in json_obj: status_str=json_obj[ControlThermalAlgoAction.JSON_FIELD_STATUS].lower() if status_str=='true': self.status=True elif status_str=='false': self.status=False else: raise ValueError('Invalid{} field value, please specify true of false'. format(ControlThermalAlgoAction.JSON_FIELD_STATUS)) else: raise ValueError('ControlThermalAlgoAction ' 'missing mandatory field{} in JSON policy file'. format(ControlThermalAlgoAction.JSON_FIELD_STATUS)) def execute(self, thermal_info_dict): \"\"\" Disable thermal control algorithm :param thermal_info_dict: A dictionary stores all thermal information. :return: \"\"\" if ChassisInfo.INFO_NAME in thermal_info_dict: chassis_info_obj=thermal_info_dict[ChassisInfo.INFO_NAME] chassis=chassis_info_obj.get_chassis() thermal_manager=chassis.get_thermal_manager() if self.status: thermal_manager.start_thermal_control_algorithm() else: thermal_manager.stop_thermal_control_algorithm() @thermal_json_object('switch.power_cycling') class SwitchPolicyAction(ThermalPolicyActionBase): \"\"\" Base class for thermal action. Once all thermal conditions in a thermal policy are matched, all predefined thermal action will be executed. \"\"\" def execute(self, thermal_info_dict): \"\"\" Take action when thermal condition matches. For example, power cycle the switch. :param thermal_info_dict: A dictionary stores all thermal information. :return: \"\"\" thermal_overload_position_path='/tmp/thermal_overload_position' thermal_overload_position=APIHelper().read_one_line_file( thermal_overload_position_path) cmd='bash /usr/share/sonic/platform/thermal_overload_control.sh{}'.format( thermal_overload_position) APIHelper().run_command(cmd) ", "sourceWithComments": "\nfrom sonic_platform_base.sonic_thermal_control.thermal_action_base import ThermalPolicyActionBase\nfrom sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object\nfrom .thermal_infos import ChassisInfo\nfrom .helper import APIHelper\n\n\n@thermal_json_object('thermal_control.control')\nclass ControlThermalAlgoAction(ThermalPolicyActionBase):\n    \"\"\"\n    Action to control the thermal control algorithm\n    \"\"\"\n    # JSON field definition\n    JSON_FIELD_STATUS = 'status'\n\n    def __init__(self):\n        self.status = True\n\n    def load_from_json(self, json_obj):\n        \"\"\"\n        Construct ControlThermalAlgoAction via JSON. JSON example:\n            {\n                \"type\": \"thermal_control.control\"\n                \"status\": \"true\"\n            }\n        :param json_obj: A JSON object representing a ControlThermalAlgoAction action.\n        :return:\n        \"\"\"\n        if ControlThermalAlgoAction.JSON_FIELD_STATUS in json_obj:\n            status_str = json_obj[ControlThermalAlgoAction.JSON_FIELD_STATUS].lower()\n            if status_str == 'true':\n                self.status = True\n            elif status_str == 'false':\n                self.status = False\n            else:\n                raise ValueError('Invalid {} field value, please specify true of false'.\n                                 format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\n        else:\n            raise ValueError('ControlThermalAlgoAction '\n                             'missing mandatory field {} in JSON policy file'.\n                             format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\n\n    def execute(self, thermal_info_dict):\n        \"\"\"\n        Disable thermal control algorithm\n        :param thermal_info_dict: A dictionary stores all thermal information.\n        :return:\n        \"\"\"\n        if ChassisInfo.INFO_NAME in thermal_info_dict:\n            chassis_info_obj = thermal_info_dict[ChassisInfo.INFO_NAME]\n            chassis = chassis_info_obj.get_chassis()\n            thermal_manager = chassis.get_thermal_manager()\n            if self.status:\n                thermal_manager.start_thermal_control_algorithm()\n            else:\n                thermal_manager.stop_thermal_control_algorithm()\n\n\n@thermal_json_object('switch.power_cycling')\nclass SwitchPolicyAction(ThermalPolicyActionBase):\n    \"\"\"\n    Base class for thermal action. Once all thermal conditions in a thermal policy are matched,\n    all predefined thermal action will be executed.\n    \"\"\"\n\n    def execute(self, thermal_info_dict):\n        \"\"\"\n        Take action when thermal condition matches. For example, power cycle the switch.\n        :param thermal_info_dict: A dictionary stores all thermal information.\n        :return:\n        \"\"\"\n        thermal_overload_position_path = '/tmp/thermal_overload_position'\n        thermal_overload_position = APIHelper().read_one_line_file(\n            thermal_overload_position_path)\n\n        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\n            thermal_overload_position)\n        APIHelper().run_command(cmd)\n"}, "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py": {"changes": [{"diff": "\n from .thermal_infos import *\n \n class ThermalManager(ThermalManagerBase):\n-    FSC_ALGORITHM_CMD = 'service fancontrol {}'\n+    FSC_ALGORITHM_CMD = ['service', 'fancontrol', '']\n \n     @classmethod\n     def start_thermal_control_algorithm(cls):\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py", "badparts": ["    FSC_ALGORITHM_CMD = 'service fancontrol {}'"], "goodparts": ["    FSC_ALGORITHM_CMD = ['service', 'fancontrol', '']"]}, {"diff": "\n         Returns:\n             bool: True if set success, False if fail.\n         \"\"\"\n-        cmd = 'start' if enable else 'stop'\n-        return APIHelper().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n+        cls.FSC_ALGORITHM_CMD[2] = 'start' if enable else 'stop'\n+        return APIHelper().run_command(cls.FSC_ALGO", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py", "badparts": ["        cmd = 'start' if enable else 'stop'", "        return APIHelper().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))"], "goodparts": ["        cls.FSC_ALGORITHM_CMD[2] = 'start' if enable else 'stop'", "        return APIHelper().run_command(cls.FSC_ALGO"]}], "source": "\nfrom sonic_platform_base.sonic_thermal_control.thermal_manager_base import ThermalManagerBase from.helper import APIHelper from.thermal_actions import * from.thermal_conditions import * from.thermal_infos import * class ThermalManager(ThermalManagerBase): FSC_ALGORITHM_CMD='service fancontrol{}' @classmethod def start_thermal_control_algorithm(cls): \"\"\" Start vendor specific thermal control algorithm. The default behavior of this function is a no-op. :return: \"\"\" return cls._enable_fancontrol_service(True) @classmethod def stop_thermal_control_algorithm(cls): \"\"\" Stop thermal control algorithm Returns: bool: True if set success, False if fail. \"\"\" return cls._enable_fancontrol_service(False) @classmethod def deinitialize(cls): \"\"\" Destroy thermal manager, including any vendor specific cleanup. The default behavior of this function is a no-op. :return: \"\"\" return cls._enable_fancontrol_service(True) @classmethod def _enable_fancontrol_service(cls, enable): \"\"\" Control thermal by fcs algorithm Args: enable: Bool, indicate enable the algorithm or not Returns: bool: True if set success, False if fail. \"\"\" cmd='start' if enable else 'stop' return APIHelper().run_command(cls.FSC_ALGORITHM_CMD.format(cmd)) ", "sourceWithComments": "from sonic_platform_base.sonic_thermal_control.thermal_manager_base import ThermalManagerBase\nfrom .helper import APIHelper\nfrom .thermal_actions import *\nfrom .thermal_conditions import *\nfrom .thermal_infos import *\n\nclass ThermalManager(ThermalManagerBase):\n    FSC_ALGORITHM_CMD = 'service fancontrol {}'\n\n    @classmethod\n    def start_thermal_control_algorithm(cls):\n        \"\"\"\n        Start vendor specific thermal control algorithm. The default behavior of this function is a no-op.\n        :return:\n        \"\"\"\n        return cls._enable_fancontrol_service(True)\n\n    @classmethod\n    def stop_thermal_control_algorithm(cls):\n        \"\"\"\n        Stop thermal control algorithm\n        Returns:\n            bool: True if set success, False if fail.\n        \"\"\"\n        return cls._enable_fancontrol_service(False)\n\n    @classmethod\n    def deinitialize(cls):\n        \"\"\"\n        Destroy thermal manager, including any vendor specific cleanup. The default behavior of this function\n        is a no-op.\n        :return:\n        \"\"\"\n        return cls._enable_fancontrol_service(True)\n\n    @classmethod\n    def _enable_fancontrol_service(cls, enable):\n        \"\"\"\n        Control thermal by fcs algorithm\n        Args:\n            enable: Bool, indicate enable the algorithm or not\n        Returns:\n            bool: True if set success, False if fail.\n        \"\"\"\n        cmd = 'start' if enable else 'stop'\n        return APIHelper().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n"}, "/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py": {"changes": [{"diff": "\n-import os.path\n-import subprocess\n import sys\n import re\n \n try:\n     from sonic_psu.psu_base import PsuBase\n+    from sonic_py_common.general import getstatusoutput_noshell_pipe\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n", "add": 1, "remove": 2, "filename": "/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py", "badparts": ["import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell_pipe"]}, {"diff": "\n     \"\"\"Platform-specific PSUutil class\"\"\"\n \n     def __init__(self):\n-        self.ipmi_sensor = \"ipmitool sensor\"\n+        self.ipmi_sensor = [\"ipmitool\", \"sensor\"]\n         PsuBase.__init__(self)\n \n-    def run_command(self, command):\n-        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n-        (out, err) = proc.communicate()\n-\n-        if proc.returncode != 0:\n-            sys.exit(proc.returncode)\n-\n+    def run_command(self, cmd1, cmd2):\n+        exitcode, out = getstatusoutput_noshell_pipe(cmd1, cmd2)\n+        i = 0\n+        while i < 2:\n+            if exitcode[i] != 0:\n+                sys.exit(exitcode[i])\n+            i += 1\n         return out\n \n     def find_value(self, grep_string):\n", "add": 8, "remove": 8, "filename": "/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py", "badparts": ["        self.ipmi_sensor = \"ipmitool sensor\"", "    def run_command(self, command):", "        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)", "        (out, err) = proc.communicate()", "        if proc.returncode != 0:", "            sys.exit(proc.returncode)"], "goodparts": ["        self.ipmi_sensor = [\"ipmitool\", \"sensor\"]", "    def run_command(self, cmd1, cmd2):", "        exitcode, out = getstatusoutput_noshell_pipe(cmd1, cmd2)", "        i = 0", "        while i < 2:", "            if exitcode[i] != 0:", "                sys.exit(exitcode[i])", "            i += 1"]}, {"diff": "\n             return False\n \n         grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n-        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n+        grep_cmd = [\"grep\", grep_key]\n+        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)\n         status_byte = self.find_value(grep_string)\n \n         if status_byte is None:\n", "add": 2, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py", "badparts": ["        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)"], "goodparts": ["        grep_cmd = [\"grep\", grep_key]", "        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)"]}, {"diff": "\n             return False\n \n         grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n-        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n+        grep_cmd = [\"grep\", grep_key]\n+        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)\n         status_byte = self.find_value(grep_string)\n \n         if status_by", "add": 2, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py", "badparts": ["        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)"], "goodparts": ["        grep_cmd = [\"grep\", grep_key]", "        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)"]}], "source": "\nimport os.path import subprocess import sys import re try: from sonic_psu.psu_base import PsuBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class PsuUtil(PsuBase): \"\"\"Platform-specific PSUutil class\"\"\" def __init__(self): self.ipmi_sensor=\"ipmitool sensor\" PsuBase.__init__(self) def run_command(self, command): proc=subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE) (out, err)=proc.communicate() if proc.returncode !=0: sys.exit(proc.returncode) return out def find_value(self, grep_string): result=re.search(\".+\\|(0x\\d{2})\\d{2}\\|.+\", grep_string) if result: return result.group(1) else: return result def get_num_psus(self): \"\"\" Retrieves the number of PSUs available on the device :return: An integer, the number of PSUs available on the device \"\"\" return 2 def get_psu_status(self, index): \"\"\" Retrieves the oprational status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is operating properly, False if PSU is faulty \"\"\" if index is None: return False grep_key=\"PSUL_Status\" if index==1 else \"PSUR_Status\" grep_string=self.run_command(self.ipmi_sensor +' | grep ' +grep_key) status_byte=self.find_value(grep_string) if status_byte is None: return False failure_detected=(int(status_byte, 16) >> 1) & 1 input_lost=(int(status_byte, 16) >> 3) & 1 if failure_detected or input_lost: return False else: return True def get_psu_presence(self, index): \"\"\" Retrieves the presence status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is plugged, False if not \"\"\" if index is None: return False grep_key=\"PSUL_Status\" if index==1 else \"PSUR_Status\" grep_string=self.run_command(self.ipmi_sensor +' | grep ' +grep_key) status_byte=self.find_value(grep_string) if status_byte is None: return False presence=(int(status_byte, 16) >> 0) & 1 if presence: return True else: return False ", "sourceWithComments": "import os.path\nimport subprocess\nimport sys\nimport re\n\ntry:\n    from sonic_psu.psu_base import PsuBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass PsuUtil(PsuBase):\n    \"\"\"Platform-specific PSUutil class\"\"\"\n\n    def __init__(self):\n        self.ipmi_sensor = \"ipmitool sensor\"\n        PsuBase.__init__(self)\n\n    def run_command(self, command):\n        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n        (out, err) = proc.communicate()\n\n        if proc.returncode != 0:\n            sys.exit(proc.returncode)\n\n        return out\n\n    def find_value(self, grep_string):\n        result = re.search(\".+\\| (0x\\d{2})\\d{2}\\|.+\", grep_string)\n        if result:\n            return result.group(1)\n        else:\n            return result\n\n    def get_num_psus(self):\n        \"\"\"\n        Retrieves the number of PSUs available on the device\n        :return: An integer, the number of PSUs available on the device\n        \"\"\"\n        return 2\n\n    def get_psu_status(self, index):\n        \"\"\"\n        Retrieves the oprational status of power supply unit (PSU) defined\n                by 1-based index <index>\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is operating properly, False if PSU is faulty\n        \"\"\"\n        if index is None:\n            return False\n\n        grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n        status_byte = self.find_value(grep_string)\n\n        if status_byte is None:\n            return False\n\n        failure_detected = (int(status_byte, 16) >> 1) & 1\n        input_lost = (int(status_byte, 16) >> 3) & 1\n        if failure_detected or input_lost:\n            return False\n        else:\n            return True\n\n    def get_psu_presence(self, index):\n        \"\"\"\n        Retrieves the presence status of power supply unit (PSU) defined\n                by 1-based index <index>\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is plugged, False if not\n        \"\"\"\n        if index is None:\n            return False\n\n        grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n        status_byte = self.find_value(grep_string)\n\n        if status_byte is None:\n            return False\n\n        presence = (int(status_byte, 16) >> 0) & 1\n        if presence:\n            return True\n        else:\n            return False\n"}, "/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py": {"changes": [{"diff": "\n     \"\"\"Platform-specific PSUutil class\"\"\"\n \n     def __init__(self):\n-        self.ipmi_raw = \"docker exec -ti pmon ipmitool raw 0x4 0x2d\"\n+        self.ipmi_raw = [\"docker\", \"exec\", \"-ti\", \"pmon\", \"ipmitool\", \"raw\", \"0x4\", \"0x2d\", \"\"]\n         self.psu1_id = \"0x2f\"\n         self.psu2_id = \"0x39\"\n         PsuBase.__init__(self)\n \n     def run_command(self, command):\n-        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n         (out, err) = proc.communicate()\n \n         if proc.returncode != 0:\n", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py", "badparts": ["        self.ipmi_raw = \"docker exec -ti pmon ipmitool raw 0x4 0x2d\"", "        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)"], "goodparts": ["        self.ipmi_raw = [\"docker\", \"exec\", \"-ti\", \"pmon\", \"ipmitool\", \"raw\", \"0x4\", \"0x2d\", \"\"]", "        proc = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)"]}, {"diff": "\n             return False\n \n         psu_id = self.psu1_id if index == 1 else self.psu2_id\n-        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n+        self.ipmi_raw[8] = psu_id\n+        res_string = self.run_command(self.ipmi_raw)\n         status_byte = self.find_value(res_string)\n \n         if status_byte is None:\n", "add": 2, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py", "badparts": ["        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)"], "goodparts": ["        self.ipmi_raw[8] = psu_id", "        res_string = self.run_command(self.ipmi_raw)"]}, {"diff": "\n             return False\n \n         psu_id = self.psu1_id if index == 1 else self.psu2_id\n-        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n+        self.ipmi_raw[8] = psu_id\n+        res_string = self.run_command(self.ipmi_raw)\n         status_byte = self.find_value(res_string)\n \n         if status_b", "add": 2, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py", "badparts": ["        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)"], "goodparts": ["        self.ipmi_raw[8] = psu_id", "        res_string = self.run_command(self.ipmi_raw)"]}], "source": "\nimport os.path import subprocess import sys import re try: from sonic_psu.psu_base import PsuBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class PsuUtil(PsuBase): \"\"\"Platform-specific PSUutil class\"\"\" def __init__(self): self.ipmi_raw=\"docker exec -ti pmon ipmitool raw 0x4 0x2d\" self.psu1_id=\"0x2f\" self.psu2_id=\"0x39\" PsuBase.__init__(self) def run_command(self, command): proc=subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE) (out, err)=proc.communicate() if proc.returncode !=0: sys.exit(proc.returncode) return out def find_value(self, in_string): result=re.search(\"^.+([0-9a-f]{2}).+$\", in_string) if result: return result.group(1) else: return result def get_num_psus(self): \"\"\" Retrieves the number of PSUs available on the device :return: An integer, the number of PSUs available on the device \"\"\" return 2 def get_psu_status(self, index): \"\"\" Retrieves the oprational status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is operating properly, False if PSU is faulty \"\"\" if index is None: return False psu_id=self.psu1_id if index==1 else self.psu2_id res_string=self.run_command(self.ipmi_raw +' ' +psu_id) status_byte=self.find_value(res_string) if status_byte is None: return False failure_detected=(int(status_byte, 16) >> 1) & 1 input_lost=(int(status_byte, 16) >> 3) & 1 if failure_detected or input_lost: return False else: return True def get_psu_presence(self, index): \"\"\" Retrieves the presence status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is plugged, False if not \"\"\" if index is None: return False psu_id=self.psu1_id if index==1 else self.psu2_id res_string=self.run_command(self.ipmi_raw +' ' +psu_id) status_byte=self.find_value(res_string) if status_byte is None: return False presence=(int(status_byte, 16) >> 0) & 1 if presence: return True else: return False ", "sourceWithComments": "import os.path\nimport subprocess\nimport sys\nimport re\n\ntry:\n    from sonic_psu.psu_base import PsuBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass PsuUtil(PsuBase):\n    \"\"\"Platform-specific PSUutil class\"\"\"\n\n    def __init__(self):\n        self.ipmi_raw = \"docker exec -ti pmon ipmitool raw 0x4 0x2d\"\n        self.psu1_id = \"0x2f\"\n        self.psu2_id = \"0x39\"\n        PsuBase.__init__(self)\n\n    def run_command(self, command):\n        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n        (out, err) = proc.communicate()\n\n        if proc.returncode != 0:\n            sys.exit(proc.returncode)\n\n        return out\n\n    def find_value(self, in_string):\n        result = re.search(\"^.+ ([0-9a-f]{2}) .+$\", in_string)\n        if result:\n            return result.group(1)\n        else:\n            return result\n\n    def get_num_psus(self):\n        \"\"\"\n        Retrieves the number of PSUs available on the device\n        :return: An integer, the number of PSUs available on the device\n        \"\"\"\n        return 2\n\n    def get_psu_status(self, index):\n        \"\"\"\n        Retrieves the oprational status of power supply unit (PSU) defined\n                by 1-based index <index>\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is operating properly, False if PSU is faulty\n        \"\"\"\n        if index is None:\n            return False\n\n        psu_id = self.psu1_id if index == 1 else self.psu2_id\n        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n        status_byte = self.find_value(res_string)\n\n        if status_byte is None:\n            return False\n\n        failure_detected = (int(status_byte, 16) >> 1) & 1\n        input_lost = (int(status_byte, 16) >> 3) & 1\n        if failure_detected or input_lost:\n            return False\n        else:\n            return True\n\n    def get_psu_presence(self, index):\n        \"\"\"\n        Retrieves the presence status of power supply unit (PSU) defined\n                by 1-based index <index>\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is plugged, False if not\n        \"\"\"\n        if index is None:\n            return False\n\n        psu_id = self.psu1_id if index == 1 else self.psu2_id\n        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n        status_byte = self.find_value(res_string)\n\n        if status_byte is None:\n            return False\n\n        presence = (int(status_byte, 16) >> 0) & 1\n        if presence:\n            return True\n        else:\n            return False\n"}, "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import json\n import os.path\n \n try:\n", "add": 0, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py", "badparts": ["import json"], "goodparts": []}, {"diff": "\n SW_CPLD_VER_PATH = \"/sys/module/switch_cpld/version\"\n BASE_CPLD_VER_PATH = \"/sys/module/baseboard_lpc/version\"\n-CPLD_UPGRADE_OPT = 4\n BIOS_VER_PATH = \"/sys/class/dmi/id/bios_version\"\n-BIOS__UPGRADE_OPT = 2\n-BMC_VER_CMD = \"ipmitool mc info | grep 'Firmware Revision'\"\n-BMC_UPGRADE_OPT = 1\n-CFUFLASH_FW_UPGRADE_CMD = \"CFUFLASH -cd -d {} -mse 3 {}\"\n+BMC_VER_CMD1 = [\"ipmitool\", \"mc\", \"info\"]\n+BMC_VER_CMD2 = [\"grep\", \"Firmware Revision\"]\n+CFUFLASH_FW_UPGRADE_CMD = [\"CFUFLASH\", \"-cd\", \"-d\", \"\", \"-mse\", \"3\", \"\"]\n MEM_PCI_RESOURCE = \"/sys/bus/pci/devices/0000:09:00.0/resource0\"\n FPGA_VER_MEM_OFFSET = 0\n+UPGRADE_OPT = {\n+    'BMC': '1',\n+    'BIOS': '2',\n+    'SWITCH_CPLD': '4',\n+    'BASE_CPLD': '4'\n+}\n \n \n class Component(ComponentBase):\n", "add": 9, "remove": 5, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py", "badparts": ["CPLD_UPGRADE_OPT = 4", "BIOS__UPGRADE_OPT = 2", "BMC_VER_CMD = \"ipmitool mc info | grep 'Firmware Revision'\"", "BMC_UPGRADE_OPT = 1", "CFUFLASH_FW_UPGRADE_CMD = \"CFUFLASH -cd -d {} -mse 3 {}\""], "goodparts": ["BMC_VER_CMD1 = [\"ipmitool\", \"mc\", \"info\"]", "BMC_VER_CMD2 = [\"grep\", \"Firmware Revision\"]", "CFUFLASH_FW_UPGRADE_CMD = [\"CFUFLASH\", \"-cd\", \"-d\", \"\", \"-mse\", \"3\", \"\"]", "UPGRADE_OPT = {", "    'BMC': '1',", "    'BIOS': '2',", "    'SWITCH_CPLD': '4',", "    'BASE_CPLD': '4'", "}"]}, {"diff": "\n \n     def __get_bmc_ver(self):\n         bmc_ver = \"Unknown\"\n-        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD)\n+        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD1, BMC_VER_CMD2)\n         if status:\n             bmc_ver_data = raw_bmc_data.split(\":\")\n             bmc_ver = bmc_ver_data[-1].strip() if len(\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py", "badparts": ["        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD)"], "goodparts": ["        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD1, BMC_VER_CMD2)"]}, {"diff": "\n         Returns:\n             A boolean, True if install successfully, False if not\n         \"\"\"\n-        install_command = {\n-            \"BMC\": CFUFLASH_FW_UPGRADE_CMD.format(BMC_UPGRADE_OPT, image_path),\n-            \"BIOS\": CFUFLASH_FW_UPGRADE_CMD.format(BIOS__UPGRADE_OPT, image_path),\n-            \"SWITCH_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path),\n-            \"BASE_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path)\n-        }.get(self.name, None)\n-\n-        if not os.path.isfile(image_path) or install_command is None:\n+        CFUFLASH_FW_UPGRADE_CMD[3] = UPGRADE_OPT.get(self.name)\n+        CFUFLASH_FW_UPGRADE_CMD[6] = image_path\n+\n+        if not os.path.isfile(image_path):\n             return False\n \n         # print(install_command)\n-        status = self._api_helper.run_interactive_command(install_command)\n+        status = self._api_helper.run_interactive_command(CFUFLASH_FW_UPGRADE_CMD)\n         ", "add": 5, "remove": 9, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py", "badparts": ["        install_command = {", "            \"BMC\": CFUFLASH_FW_UPGRADE_CMD.format(BMC_UPGRADE_OPT, image_path),", "            \"BIOS\": CFUFLASH_FW_UPGRADE_CMD.format(BIOS__UPGRADE_OPT, image_path),", "            \"SWITCH_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path),", "            \"BASE_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path)", "        }.get(self.name, None)", "        if not os.path.isfile(image_path) or install_command is None:", "        status = self._api_helper.run_interactive_command(install_command)"], "goodparts": ["        CFUFLASH_FW_UPGRADE_CMD[3] = UPGRADE_OPT.get(self.name)", "        CFUFLASH_FW_UPGRADE_CMD[6] = image_path", "        if not os.path.isfile(image_path):", "        status = self._api_helper.run_interactive_command(CFUFLASH_FW_UPGRADE_CMD)"]}], "source": "\n import json import os.path try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") COMPONENT_LIST=[ (\"BIOS\", \"Basic Input/Output System\"), (\"BMC\", \"Baseboard Management Controller\"), (\"SWITCH_CPLD\", \"Switch board CPLD\"), (\"BASE_CPLD\", \"Base board CPLD\"), (\"FPGA\", \"Field-programmable gate array\") ] SW_CPLD_VER_PATH=\"/sys/module/switch_cpld/version\" BASE_CPLD_VER_PATH=\"/sys/module/baseboard_lpc/version\" CPLD_UPGRADE_OPT=4 BIOS_VER_PATH=\"/sys/class/dmi/id/bios_version\" BIOS__UPGRADE_OPT=2 BMC_VER_CMD=\"ipmitool mc info | grep 'Firmware Revision'\" BMC_UPGRADE_OPT=1 CFUFLASH_FW_UPGRADE_CMD=\"CFUFLASH -cd -d{} -mse 3{}\" MEM_PCI_RESOURCE=\"/sys/bus/pci/devices/0000:09:00.0/resource0\" FPGA_VER_MEM_OFFSET=0 class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index): ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() self._api_helper=APIHelper() def __get_bmc_ver(self): bmc_ver=\"Unknown\" status, raw_bmc_data=self._api_helper.run_command(BMC_VER_CMD) if status: bmc_ver_data=raw_bmc_data.split(\":\") bmc_ver=bmc_ver_data[-1].strip() if len( bmc_ver_data) > 1 else bmc_ver return bmc_ver def __get_fpga_ver(self): fpga_ver=\"Unknown\" status, reg_val=self._api_helper.pci_get_value( MEM_PCI_RESOURCE, FPGA_VER_MEM_OFFSET) if status: major=reg_val[0] >> 16 minor=int(bin(reg_val[0])[16:32], 2) fpga_ver='{}.{}'.format(major, minor) return fpga_ver def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version={ \"BIOS\": self._api_helper.read_txt_file(BIOS_VER_PATH), \"BMC\": self.__get_bmc_ver(), \"FPGA\": self.__get_fpga_ver(), \"SWITCH_CPLD\": self._api_helper.read_txt_file(SW_CPLD_VER_PATH), \"BASE_CPLD\": self._api_helper.read_txt_file(BASE_CPLD_VER_PATH), }.get(self.name, \"Unknown\") return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" install_command={ \"BMC\": CFUFLASH_FW_UPGRADE_CMD.format(BMC_UPGRADE_OPT, image_path), \"BIOS\": CFUFLASH_FW_UPGRADE_CMD.format(BIOS__UPGRADE_OPT, image_path), \"SWITCH_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path), \"BASE_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path) }.get(self.name, None) if not os.path.isfile(image_path) or install_command is None: return False status=self._api_helper.run_interactive_command(install_command) return status ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport json\nimport os.path\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCOMPONENT_LIST = [\n    (\"BIOS\",        \"Basic Input/Output System\"),\n    (\"BMC\",         \"Baseboard Management Controller\"),\n    (\"SWITCH_CPLD\", \"Switch board CPLD\"),\n    (\"BASE_CPLD\",   \"Base board CPLD\"),\n    (\"FPGA\",        \"Field-programmable gate array\")\n]\nSW_CPLD_VER_PATH = \"/sys/module/switch_cpld/version\"\nBASE_CPLD_VER_PATH = \"/sys/module/baseboard_lpc/version\"\nCPLD_UPGRADE_OPT = 4\nBIOS_VER_PATH = \"/sys/class/dmi/id/bios_version\"\nBIOS__UPGRADE_OPT = 2\nBMC_VER_CMD = \"ipmitool mc info | grep 'Firmware Revision'\"\nBMC_UPGRADE_OPT = 1\nCFUFLASH_FW_UPGRADE_CMD = \"CFUFLASH -cd -d {} -mse 3 {}\"\nMEM_PCI_RESOURCE = \"/sys/bus/pci/devices/0000:09:00.0/resource0\"\nFPGA_VER_MEM_OFFSET = 0\n\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index):\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n        self._api_helper = APIHelper()\n\n    def __get_bmc_ver(self):\n        bmc_ver = \"Unknown\"\n        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD)\n        if status:\n            bmc_ver_data = raw_bmc_data.split(\":\")\n            bmc_ver = bmc_ver_data[-1].strip() if len(\n                bmc_ver_data) > 1 else bmc_ver\n        return bmc_ver\n\n    def __get_fpga_ver(self):\n        fpga_ver = \"Unknown\"\n        status, reg_val = self._api_helper.pci_get_value(\n            MEM_PCI_RESOURCE, FPGA_VER_MEM_OFFSET)\n        if status:\n            major = reg_val[0] >> 16\n            minor = int(bin(reg_val[0])[16:32], 2)\n            fpga_ver = '{}.{}'.format(major, minor)\n        return fpga_ver\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = {\n            \"BIOS\": self._api_helper.read_txt_file(BIOS_VER_PATH),\n            \"BMC\": self.__get_bmc_ver(),\n            \"FPGA\": self.__get_fpga_ver(),\n            \"SWITCH_CPLD\": self._api_helper.read_txt_file(SW_CPLD_VER_PATH),\n            \"BASE_CPLD\": self._api_helper.read_txt_file(BASE_CPLD_VER_PATH),\n        }.get(self.name, \"Unknown\")\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        install_command = {\n            \"BMC\": CFUFLASH_FW_UPGRADE_CMD.format(BMC_UPGRADE_OPT, image_path),\n            \"BIOS\": CFUFLASH_FW_UPGRADE_CMD.format(BIOS__UPGRADE_OPT, image_path),\n            \"SWITCH_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path),\n            \"BASE_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path)\n        }.get(self.name, None)\n\n        if not os.path.isfile(image_path) or install_command is None:\n            return False\n\n        # print(install_command)\n        status = self._api_helper.run_interactive_command(install_command)\n        return status\n"}, "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n import struct\n import subprocess\n from mmap import *\n+from sonic_py_common.general import check_output_pipe\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 2, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["from sonic_py_common.general import check_output_pipe", "HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         pass\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 5, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        try:", "            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)", "        except FileNotFoundError:", "            return False", "        return True"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n+    def run_command(self, cmd1_args, cmd2_args):\n         status = True\n         result = \"\"\n         try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except:\n+            result = check_output_pipe(cmd1_args, cmd2_args)\n+        except subprocess.CalledProcessError:\n             status = False\n         return status, result\n \n     def run_interactive_command(self, cmd):\n         try:\n-            os.system(cmd)\n+            subprocess.call(cmd)\n         except:\n             return False\n         return True\n", "add": 4, "remove": 8, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "            p = subprocess.Popen(", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except:", "            os.system(cmd)"], "goodparts": ["    def run_command(self, cmd1_args, cmd2_args):", "            result = check_output_pipe(cmd1_args, cmd2_args)", "        except subprocess.CalledProcessError:", "            subprocess.call(cmd)"]}, {"diff": "\n         status = True\n         result = \"\"\n         try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n+            cmd = [\"ipmitool\", \"raw\", str(netfn), str(cmd)]\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = raw_data.strip()\n", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py", "badparts": ["            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"], "goodparts": ["            cmd = [\"ipmitool\", \"raw\", str(netfn), str(cmd)]", "                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"]}, {"diff": "\n     def ipmi_fru_id(self, id, key=None):\n         status = True\n         result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n+        cmd1_args = [\"ipmitool\", \"fru\", \"print\", str(id)]\n+        if not key:\n+            try:\n+                p = subprocess.Popen(\n+                    cmd1_args, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                raw_data, err = p.communicate()\n+                if err == '':\n+                    result = raw_data.strip()\n+                else:\n+                    status = False\n+            except:\n                 status = False\n-        except:\n-            status = False\n+        else:\n+            cmd2_args = [\"grep\", str(key)]\n+            status, result = self.run_command(cmd1_args, cmd2_args)\n         return status, result\n \n     def ipmi_set_ss_thres(self, id, threshold_key, value):\n         status = True\n         result = \"\"\n         try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n+            cmd = [\"ipmitool\", \"sensor\", \"thresh\", str(id), str(threshold_key), str(value)]\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = ra", "add": 16, "remove": 14, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py", "badparts": ["        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "        except:", "            status = False", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"], "goodparts": ["        cmd1_args = [\"ipmitool\", \"fru\", \"print\", str(id)]", "        if not key:", "            try:", "                p = subprocess.Popen(", "                    cmd1_args, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "                raw_data, err = p.communicate()", "                if err == '':", "                    result = raw_data.strip()", "                else:", "                    status = False", "            except:", "        else:", "            cmd2_args = [\"grep\", str(key)]", "            status, result = self.run_command(cmd1_args, cmd2_args)", "            cmd = [\"ipmitool\", \"sensor\", \"thresh\", str(id), str(threshold_key), str(value)]", "                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"]}], "source": "\nimport os import struct import subprocess from mmap import * HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): pass def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        pass\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n"}, "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py": {"changes": [{"diff": "\n PSU_LED_GREEN_CMD = \"0x01\"\n PSU_LED_AMBER_CMD = \"0x02\"\n \n-PSU1_VOUT_SS_ID = \"0x36\"\n-PSU1_COUT_SS_ID = \"0x37\"\n-PSU1_POUT_SS_ID = \"0x38\"\n-PSU1_STATUS_REG = \"0x39\"\n-\n-PSU2_VOUT_SS_ID = \"0x40\"\n-PSU2_COUT_SS_ID = \"0x41\"\n-PSU2_POUT_SS_ID = \"0x42\"\n-PSU2_STATUS_REG = \"0x2f\"\n-\n PSU1_FRU_ID = 3\n \n SS_READ_OFFSET = 0\n \n+PSU_VOUT_SS_ID = [\"0x36\", \"0x40\"]\n+PSU_COUT_SS_ID = [\"0x37\", \"0x41\"]\n+PSU_POUT_SS_ID = [\"0x38\", \"0x42\"]\n+PSU_STATUS_REG = [\"0x39\", \"0x2f\"]\n+\n \n class Psu(PsuBase):\n     \"\"\"Platform-specific Psu class\"\"\"\n", "add": 5, "remove": 10, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["PSU1_VOUT_SS_ID = \"0x36\"", "PSU1_COUT_SS_ID = \"0x37\"", "PSU1_POUT_SS_ID = \"0x38\"", "PSU1_STATUS_REG = \"0x39\"", "PSU2_VOUT_SS_ID = \"0x40\"", "PSU2_COUT_SS_ID = \"0x41\"", "PSU2_POUT_SS_ID = \"0x42\"", "PSU2_STATUS_REG = \"0x2f\""], "goodparts": ["PSU_VOUT_SS_ID = [\"0x36\", \"0x40\"]", "PSU_COUT_SS_ID = [\"0x37\", \"0x41\"]", "PSU_POUT_SS_ID = [\"0x38\", \"0x42\"]", "PSU_STATUS_REG = [\"0x39\", \"0x2f\"]"]}, {"diff": "\n             e.g. 12.1\n         \"\"\"\n         psu_voltage = 0.0\n-        psu_vout_key = globals()['PSU{}_VOUT_SS_ID'.format(self.index+1)]\n+        psu_vout_key = PSU_VOUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_vout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["        psu_vout_key = globals()['PSU{}_VOUT_SS_ID'.format(self.index+1)]"], "goodparts": ["        psu_vout_key = PSU_VOUT_SS_ID[self.index]"]}, {"diff": "\n             A float number, the electric current in amperes, e.g 15.4\n         \"\"\"\n         psu_current = 0.0\n-        psu_cout_key = globals()['PSU{}_COUT_SS_ID'.format(self.index+1)]\n+        psu_cout_key = PSU_COUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_cout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["        psu_cout_key = globals()['PSU{}_COUT_SS_ID'.format(self.index+1)]"], "goodparts": ["        psu_cout_key = PSU_COUT_SS_ID[self.index]"]}, {"diff": "\n             A float number, the power in watts, e.g. 302.6\n         \"\"\"\n         psu_power = 0.0\n-        psu_pout_key = globals()['PSU{}_POUT_SS_ID'.format(self.index+1)]\n+        psu_pout_key = PSU_POUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["        psu_pout_key = globals()['PSU{}_POUT_SS_ID'.format(self.index+1)]"], "goodparts": ["        psu_pout_key = PSU_POUT_SS_ID[self.index]"]}, {"diff": "\n             bool: True if PSU is present, False if not\n         \"\"\"\n         psu_presence = False\n-        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n+        psu_pstatus_key = PSU_STATUS_REG[self.index]\n         status, raw_status_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n         status_byte = self.find_value(raw_status_read)\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]"], "goodparts": ["        psu_pstatus_key = PSU_STATUS_REG[self.index]"]}, {"diff": "\n             A boolean value, True if device is operating properly, False if not\n         \"\"\"\n         psu_status = False\n-        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n+        psu_pstatus_key = PSU_STATUS_REG[self.index]\n         status, raw_status_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n         status_byte = self.find_value(r", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]"], "goodparts": ["        psu_pstatus_key = PSU_STATUS_REG[self.index]"]}], "source": "\n import os import re import math import sonic_platform try: from sonic_platform_base.psu_base import PsuBase from.helper import APIHelper from sonic_platform.fan import Fan except ImportError as e: raise ImportError(str(e) +\"-required module not found\") PSU_NAME_LIST=[\"PSU-1\", \"PSU-2\"] PSU_NUM_FAN=[1, 1] IPMI_SENSOR_NETFN=\"0x04\" IPMI_OEM_NETFN=\"0x3A\" IPMI_SS_READ_CMD=\"0x2D{}\" IPMI_SET_PSU_LED_CMD=\"0x07 0x02{}\" IPMI_GET_PSU_LED_CMD=\"0x08 0x02\" IPMI_FRU_MODEL_KEY=\"Board Part Number\" IPMI_FRU_SERIAL_KEY=\"Board Serial\" PSU_LED_OFF_CMD=\"0x00\" PSU_LED_GREEN_CMD=\"0x01\" PSU_LED_AMBER_CMD=\"0x02\" PSU1_VOUT_SS_ID=\"0x36\" PSU1_COUT_SS_ID=\"0x37\" PSU1_POUT_SS_ID=\"0x38\" PSU1_STATUS_REG=\"0x39\" PSU2_VOUT_SS_ID=\"0x40\" PSU2_COUT_SS_ID=\"0x41\" PSU2_POUT_SS_ID=\"0x42\" PSU2_STATUS_REG=\"0x2f\" PSU1_FRU_ID=3 SS_READ_OFFSET=0 class Psu(PsuBase): \"\"\"Platform-specific Psu class\"\"\" def __init__(self, psu_index): PsuBase.__init__(self) self.index=psu_index for fan_index in range(0, PSU_NUM_FAN[self.index]): fan=Fan(fan_index, 0, is_psu_fan=True, psu_index=self.index) self._fan_list.append(fan) self._api_helper=APIHelper() def find_value(self, in_string): result=re.search(\"^.+([0-9a-f]{2}).+$\", in_string) return result.group(1) if result else result def get_voltage(self): \"\"\" Retrieves current PSU voltage output Returns: A float number, the output voltage in volts, e.g. 12.1 \"\"\" psu_voltage=0.0 psu_vout_key=globals()['PSU{}_VOUT_SS_ID'.format(self.index+1)] status, raw_ss_read=self._api_helper.ipmi_raw( IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_vout_key)) ss_read=raw_ss_read.split()[SS_READ_OFFSET] psu_voltage=int(ss_read, 16) * math.pow(10, -1) return psu_voltage def get_current(self): \"\"\" Retrieves present electric current supplied by PSU Returns: A float number, the electric current in amperes, e.g 15.4 \"\"\" psu_current=0.0 psu_cout_key=globals()['PSU{}_COUT_SS_ID'.format(self.index+1)] status, raw_ss_read=self._api_helper.ipmi_raw( IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_cout_key)) ss_read=raw_ss_read.split()[SS_READ_OFFSET] psu_current=int(ss_read, 16) * 5 * math.pow(10, -1) return psu_current def get_power(self): \"\"\" Retrieves current energy supplied by PSU Returns: A float number, the power in watts, e.g. 302.6 \"\"\" psu_power=0.0 psu_pout_key=globals()['PSU{}_POUT_SS_ID'.format(self.index+1)] status, raw_ss_read=self._api_helper.ipmi_raw( IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pout_key)) ss_read=raw_ss_read.split()[SS_READ_OFFSET] psu_power=int(ss_read, 16) * 6 return psu_power def get_powergood_status(self): \"\"\" Retrieves the powergood status of PSU Returns: A boolean, True if PSU has stablized its output voltages and passed all its internal self-tests, False if not. \"\"\" return self.get_status() def set_status_led(self, color): \"\"\" Sets the state of the PSU status LED Args: color: A string representing the color with which to set the PSU status LED Note: Only support green and off Returns: bool: True if status LED state is set successfully, False if not Note Set manual ipmitool raw 0x3a 0x09 0x2 0x0 \"\"\" led_cmd={ self.STATUS_LED_COLOR_GREEN: PSU_LED_GREEN_CMD, self.STATUS_LED_COLOR_AMBER: PSU_LED_AMBER_CMD, self.STATUS_LED_COLOR_OFF: PSU_LED_OFF_CMD }.get(color) status, set_led=self._api_helper.ipmi_raw( IPMI_OEM_NETFN, IPMI_SET_PSU_LED_CMD.format(led_cmd)) set_status_led=False if not status else True return set_status_led def get_status_led(self): \"\"\" Gets the state of the PSU status LED Returns: A string, one of the predefined STATUS_LED_COLOR_* strings above \"\"\" status, hx_color=self._api_helper.ipmi_raw( IPMI_OEM_NETFN, IPMI_GET_PSU_LED_CMD) status_led={ \"00\": self.STATUS_LED_COLOR_OFF, \"01\": self.STATUS_LED_COLOR_GREEN, \"02\": self.STATUS_LED_COLOR_AMBER, }.get(hx_color, self.STATUS_LED_COLOR_OFF) return status_led def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return PSU_NAME_LIST[self.index] def get_presence(self): \"\"\" Retrieves the presence of the PSU Returns: bool: True if PSU is present, False if not \"\"\" psu_presence=False psu_pstatus_key=globals()['PSU{}_STATUS_REG'.format(self.index+1)] status, raw_status_read=self._api_helper.ipmi_raw( IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key)) status_byte=self.find_value(raw_status_read) if status: presence_int=(int(status_byte, 16) >> 0) & 1 psu_presence=True if presence_int else False return psu_presence def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" model=\"Unknown\" ipmi_fru_idx=self.index +PSU1_FRU_ID status, raw_model=self._api_helper.ipmi_fru_id( ipmi_fru_idx, IPMI_FRU_MODEL_KEY) fru_pn_list=raw_model.split() if len(fru_pn_list) > 4: model=fru_pn_list[4] return model def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" serial=\"Unknown\" ipmi_fru_idx=self.index +PSU1_FRU_ID status, raw_model=self._api_helper.ipmi_fru_id( ipmi_fru_idx, IPMI_FRU_SERIAL_KEY) fru_sr_list=raw_model.split() if len(fru_sr_list) > 3: serial=fru_sr_list[3] return serial def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" psu_status=False psu_pstatus_key=globals()['PSU{}_STATUS_REG'.format(self.index+1)] status, raw_status_read=self._api_helper.ipmi_raw( IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key)) status_byte=self.find_value(raw_status_read) if status: failure_detected=(int(status_byte, 16) >> 1) & 1 input_lost=(int(status_byte, 16) >> 3) & 1 psu_status=False if(input_lost or failure_detected) else True return psu_status ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the PSUs status which are available in the platform\n#\n#############################################################################\n\nimport os\nimport re\nimport math\nimport sonic_platform\n\ntry:\n    from sonic_platform_base.psu_base import PsuBase\n    from .helper import APIHelper\n    from sonic_platform.fan import Fan\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nPSU_NAME_LIST = [\"PSU-1\", \"PSU-2\"]\nPSU_NUM_FAN = [1, 1]\n\nIPMI_SENSOR_NETFN = \"0x04\"\nIPMI_OEM_NETFN = \"0x3A\"\nIPMI_SS_READ_CMD = \"0x2D {}\"\nIPMI_SET_PSU_LED_CMD = \"0x07 0x02 {}\"\nIPMI_GET_PSU_LED_CMD = \"0x08 0x02\"\nIPMI_FRU_MODEL_KEY = \"Board Part Number\"\nIPMI_FRU_SERIAL_KEY = \"Board Serial\"\n\nPSU_LED_OFF_CMD = \"0x00\"\nPSU_LED_GREEN_CMD = \"0x01\"\nPSU_LED_AMBER_CMD = \"0x02\"\n\nPSU1_VOUT_SS_ID = \"0x36\"\nPSU1_COUT_SS_ID = \"0x37\"\nPSU1_POUT_SS_ID = \"0x38\"\nPSU1_STATUS_REG = \"0x39\"\n\nPSU2_VOUT_SS_ID = \"0x40\"\nPSU2_COUT_SS_ID = \"0x41\"\nPSU2_POUT_SS_ID = \"0x42\"\nPSU2_STATUS_REG = \"0x2f\"\n\nPSU1_FRU_ID = 3\n\nSS_READ_OFFSET = 0\n\n\nclass Psu(PsuBase):\n    \"\"\"Platform-specific Psu class\"\"\"\n\n    def __init__(self, psu_index):\n        PsuBase.__init__(self)\n        self.index = psu_index\n        for fan_index in range(0, PSU_NUM_FAN[self.index]):\n            fan = Fan(fan_index, 0, is_psu_fan=True, psu_index=self.index)\n            self._fan_list.append(fan)\n        self._api_helper = APIHelper()\n\n    def find_value(self, in_string):\n        result = re.search(\"^.+ ([0-9a-f]{2}) .+$\", in_string)\n        return result.group(1) if result else result\n\n    def get_voltage(self):\n        \"\"\"\n        Retrieves current PSU voltage output\n        Returns:\n            A float number, the output voltage in volts,\n            e.g. 12.1\n        \"\"\"\n        psu_voltage = 0.0\n        psu_vout_key = globals()['PSU{}_VOUT_SS_ID'.format(self.index+1)]\n        status, raw_ss_read = self._api_helper.ipmi_raw(\n            IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_vout_key))\n        ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n        # Formula: Rx1x10^-1\n        psu_voltage = int(ss_read, 16) * math.pow(10, -1)\n\n        return psu_voltage\n\n    def get_current(self):\n        \"\"\"\n        Retrieves present electric current supplied by PSU\n        Returns:\n            A float number, the electric current in amperes, e.g 15.4\n        \"\"\"\n        psu_current = 0.0\n        psu_cout_key = globals()['PSU{}_COUT_SS_ID'.format(self.index+1)]\n        status, raw_ss_read = self._api_helper.ipmi_raw(\n            IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_cout_key))\n        ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n        # Formula: Rx5x10^-1\n        psu_current = int(ss_read, 16) * 5 * math.pow(10, -1)\n\n        return psu_current\n\n    def get_power(self):\n        \"\"\"\n        Retrieves current energy supplied by PSU\n        Returns:\n            A float number, the power in watts, e.g. 302.6\n        \"\"\"\n        psu_power = 0.0\n        psu_pout_key = globals()['PSU{}_POUT_SS_ID'.format(self.index+1)]\n        status, raw_ss_read = self._api_helper.ipmi_raw(\n            IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pout_key))\n        ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n        # Formula: Rx6x10^0\n        psu_power = int(ss_read, 16) * 6\n        return psu_power\n\n    def get_powergood_status(self):\n        \"\"\"\n        Retrieves the powergood status of PSU\n        Returns:\n            A boolean, True if PSU has stablized its output voltages and passed all\n            its internal self-tests, False if not.\n        \"\"\"\n        return self.get_status()\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the PSU status LED\n        Args:\n            color: A string representing the color with which to set the PSU status LED\n                   Note: Only support green and off\n        Returns:\n            bool: True if status LED state is set successfully, False if not\n        Note\n            Set manual\n            ipmitool raw 0x3a 0x09 0x2 0x0\n        \"\"\"\n        led_cmd = {\n            self.STATUS_LED_COLOR_GREEN: PSU_LED_GREEN_CMD,\n            self.STATUS_LED_COLOR_AMBER: PSU_LED_AMBER_CMD,\n            self.STATUS_LED_COLOR_OFF: PSU_LED_OFF_CMD\n        }.get(color)\n\n        status, set_led = self._api_helper.ipmi_raw(\n            IPMI_OEM_NETFN, IPMI_SET_PSU_LED_CMD.format(led_cmd))\n        set_status_led = False if not status else True\n\n        return set_status_led\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the PSU status LED\n        Returns:\n            A string, one of the predefined STATUS_LED_COLOR_* strings above\n        \"\"\"\n        status, hx_color = self._api_helper.ipmi_raw(\n            IPMI_OEM_NETFN, IPMI_GET_PSU_LED_CMD)\n\n        status_led = {\n            \"00\": self.STATUS_LED_COLOR_OFF,\n            \"01\": self.STATUS_LED_COLOR_GREEN,\n            \"02\": self.STATUS_LED_COLOR_AMBER,\n        }.get(hx_color, self.STATUS_LED_COLOR_OFF)\n\n        return status_led\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return PSU_NAME_LIST[self.index]\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the PSU\n        Returns:\n            bool: True if PSU is present, False if not\n        \"\"\"\n        psu_presence = False\n        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n        status, raw_status_read = self._api_helper.ipmi_raw(\n            IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n        status_byte = self.find_value(raw_status_read)\n\n        if status:\n            presence_int = (int(status_byte, 16) >> 0) & 1\n            psu_presence = True if presence_int else False\n\n        return psu_presence\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        model = \"Unknown\"\n        ipmi_fru_idx = self.index + PSU1_FRU_ID\n        status, raw_model = self._api_helper.ipmi_fru_id(\n            ipmi_fru_idx, IPMI_FRU_MODEL_KEY)\n\n        fru_pn_list = raw_model.split()\n        if len(fru_pn_list) > 4:\n            model = fru_pn_list[4]\n\n        return model\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        serial = \"Unknown\"\n        ipmi_fru_idx = self.index + PSU1_FRU_ID\n        status, raw_model = self._api_helper.ipmi_fru_id(\n            ipmi_fru_idx, IPMI_FRU_SERIAL_KEY)\n\n        fru_sr_list = raw_model.split()\n        if len(fru_sr_list) > 3:\n            serial = fru_sr_list[3]\n\n        return serial\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        psu_status = False\n        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n        status, raw_status_read = self._api_helper.ipmi_raw(\n            IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n        status_byte = self.find_value(raw_status_read)\n\n        if status:\n            failure_detected = (int(status_byte, 16) >> 1) & 1\n            input_lost = (int(status_byte, 16) >> 3) & 1\n            psu_status = False if (input_lost or failure_detected) else True\n\n        return psu_status\n"}, "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to QSFP sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-cel_silverstone-r0\"\n     HWSKU = \"Silverstone\"\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n             return 'N/A'\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH,", "add": 5, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        try:", "            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)", "        except FileNotFoundError:", "            return False", "        return True"]}]}, "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py": {"changes": [{"diff": "\n #\r\n #############################################################################\r\n \r\n-import os.path\r\n import subprocess\r\n-import time\r\n-import os\r\n \r\n try:\r\n     from sonic_platform_base.component_base import ComponentBase\r\n+    from sonic_py_common.general import getstatusoutput_noshell_pipe\r\n     #from helper import APIHelper\r\n except ImportError as e:\r\n     raise ImportError(str(e) + \"- required module not found\")\r\n \r\n-SWCPLD_VERSION_PATH = \"i2cget -y -f 2 0x32 0\"\r\n-BIOS_VERSION_PATH = \"dmidecode -t bios | grep Version\"\r\n+SWCPLD_VERSION_PATH = [\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0\"]\r\n+BIOS_VERSION_PATH_CMD1 = [\"dmidecode\", \"-t\", \"bios\"]\r\n+BIOS_VERSION_PATH_CMD2 = [\"grep\", \"Version\"]\r\n COMPONENT_NAME_LIST = [\"SWCPLD\", \"Main_BIOS\", \"Backup_BIOS\"]\r\n COMPONENT_DES_LIST = [\"Use for boot control and BIOS switch\",\r\n                       \"Main basic Input/Output System\",\r\n", "add": 4, "remove": 5, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py", "badparts": ["import time\r", "SWCPLD_VERSION_PATH = \"i2cget -y -f 2 0x32 0\"\r", "BIOS_VERSION_PATH = \"dmidecode -t bios | grep Version\"\r"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell_pipe\r", "SWCPLD_VERSION_PATH = [\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0\"]\r", "BIOS_VERSION_PATH_CMD1 = [\"dmidecode\", \"-t\", \"bios\"]\r", "BIOS_VERSION_PATH_CMD2 = [\"grep\", \"Version\"]\r"]}, {"diff": "\n         self.name = self.get_name()\r\n \r\n     def run_command(self,cmd):\r\n-        responses = os.popen(cmd).read()\r\n+        responses = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()\r\n         return responses\r\n \r\n     def __get_bios_version(self):\r\n         # Retrieves the BIOS firmware version\r\n-        result = self.run_command(\"i2cget -y -f 2 0x32 0x19\")\r\n+        result = self.run_command([\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0x19\"])\r\n         if result.strip() == \"0x01\":\r\n             if self.name == \"Main_BIOS\":\r\n-                version = self.run_command(BIOS_VERSION_PATH)\r\n+                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r\n                 bios_version = version.strip().split(\" \")[1]\r\n                 return str(bios_version)\r\n             elif self.name == \"Backup_BIOS\":\r\n", "add": 3, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py", "badparts": ["        responses = os.popen(cmd).read()\r", "        result = self.run_command(\"i2cget -y -f 2 0x32 0x19\")\r", "                version = self.run_command(BIOS_VERSION_PATH)\r"], "goodparts": ["        responses = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()\r", "        result = self.run_command([\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0x19\"])\r", "                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r"]}, {"diff": "\n                 \r\n         elif result.strip() == \"0x03\":\r\n             if self.name == \"Backup_BIOS\":\r\n-                version = self.run_command(BIOS_VERSION_PATH)\r\n+                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r\n                 bios_version = version.strip().split(\" \")[1]\r\n                 return str(bios_version)\r\n             elif self.name", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py", "badparts": ["                version = self.run_command(BIOS_VERSION_PATH)\r"], "goodparts": ["                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r"]}], "source": "\n\n\r \r import os.path\r import subprocess\r import time\r import os\r \r try:\r from sonic_platform_base.component_base import ComponentBase\r except ImportError as e:\r raise ImportError(str(e) +\"-required module not found\")\r \r SWCPLD_VERSION_PATH=\"i2cget -y -f 2 0x32 0\"\r BIOS_VERSION_PATH=\"dmidecode -t bios | grep Version\"\r COMPONENT_NAME_LIST=[\"SWCPLD\", \"Main_BIOS\", \"Backup_BIOS\"]\r COMPONENT_DES_LIST=[\"Use for boot control and BIOS switch\",\r \"Main basic Input/Output System\",\r \"Backup basic Input/Output System\"]\r \r \r class Component(ComponentBase):\r \"\"\"Platform-specific Component class\"\"\"\r \r DEVICE_TYPE=\"component\"\r \r def __init__(self, component_index):\r ComponentBase.__init__(self)\r self.index=component_index\r self.name=self.get_name()\r \r def run_command(self,cmd):\r responses=os.popen(cmd).read()\r return responses\r \r def __get_bios_version(self):\r result=self.run_command(\"i2cget -y -f 2 0x32 0x19\")\r if result.strip()==\"0x01\":\r if self.name==\"Main_BIOS\":\r version=self.run_command(BIOS_VERSION_PATH)\r bios_version=version.strip().split(\" \")[1]\r return str(bios_version)\r elif self.name==\"Backup_BIOS\":\r bios_version=\"na\"\r return bios_version\r \r elif result.strip()==\"0x03\":\r if self.name==\"Backup_BIOS\":\r version=self.run_command(BIOS_VERSION_PATH)\r bios_version=version.strip().split(\" \")[1]\r return str(bios_version)\r elif self.name==\"Main_BIOS\":\r bios_version=\"na\"\r return bios_version\r \r def __get_cpld_version(self):\r if self.name==\"SWCPLD\":\r ver=self.run_command(SWCPLD_VERSION_PATH)\r print(\"ver is %s\" % ver)\r ver=ver.strip().split(\"x\")[1]\r print(\"ver2 is %s\" % ver)\r version=int(ver.strip()) / 10\r return str(version)\r \r \r def get_name(self):\r \"\"\"\r Retrieves the name of the component\r Returns:\r A string containing the name of the component\r \"\"\"\r return COMPONENT_NAME_LIST[self.index]\r \r def get_description(self):\r \"\"\"\r Retrieves the description of the component\r Returns:\r A string containing the description of the component\r \"\"\"\r return COMPONENT_DES_LIST[self.index]\r \r def get_firmware_version(self):\r \"\"\"\r Retrieves the firmware version of module\r Returns:\r string: The firmware versions of the module\r \"\"\"\r fw_version=None\r \r if \"BIOS\" in self.name:\r fw_version=self.__get_bios_version()\r elif \"CPLD\" in self.name:\r fw_version=self.__get_cpld_version()\r \r return fw_version\r \r def install_firmware(self, image_path):\r \"\"\"\r Install firmware to module\r Args:\r image_path: A string, path to firmware image\r Returns:\r A boolean, True if install successfully, False if not\r \"\"\"\r return False\r \r def update_firmware(self, image_path):\r return False\r \r def get_available_firmware_version(self, image_path):\r return 'N/A'\r \r def get_firmware_update_notification(self, image_path):\r return \"None\"\r \r def get_model(self):\r return 'N/A'\r \r def get_position_in_parent(self):\r return -1\r \r def get_presence(self):\r return True\r \r def get_serial(self):\r return 'N/A'\r \r def get_status(self):\r return True\r \r def is_replaceable(self):\r return False\r ", "sourceWithComments": "#!/usr/bin/env python\r\n\r\n#############################################################################\r\n# Celestica\r\n#\r\n# Component contains an implementation of SONiC Platform Base API and\r\n# provides the components firmware management function\r\n#\r\n#############################################################################\r\n\r\nimport os.path\r\nimport subprocess\r\nimport time\r\nimport os\r\n\r\ntry:\r\n    from sonic_platform_base.component_base import ComponentBase\r\n    #from helper import APIHelper\r\nexcept ImportError as e:\r\n    raise ImportError(str(e) + \"- required module not found\")\r\n\r\nSWCPLD_VERSION_PATH = \"i2cget -y -f 2 0x32 0\"\r\nBIOS_VERSION_PATH = \"dmidecode -t bios | grep Version\"\r\nCOMPONENT_NAME_LIST = [\"SWCPLD\", \"Main_BIOS\", \"Backup_BIOS\"]\r\nCOMPONENT_DES_LIST = [\"Use for boot control and BIOS switch\",\r\n                      \"Main basic Input/Output System\",\r\n                      \"Backup basic Input/Output System\"]\r\n\r\n\r\nclass Component(ComponentBase):\r\n    \"\"\"Platform-specific Component class\"\"\"\r\n\r\n    DEVICE_TYPE = \"component\"\r\n\r\n    def __init__(self, component_index):\r\n        ComponentBase.__init__(self)\r\n        self.index = component_index\r\n        #self._api_helper = APIHelper()\r\n        self.name = self.get_name()\r\n\r\n    def run_command(self,cmd):\r\n        responses = os.popen(cmd).read()\r\n        return responses\r\n\r\n    def __get_bios_version(self):\r\n        # Retrieves the BIOS firmware version\r\n        result = self.run_command(\"i2cget -y -f 2 0x32 0x19\")\r\n        if result.strip() == \"0x01\":\r\n            if self.name == \"Main_BIOS\":\r\n                version = self.run_command(BIOS_VERSION_PATH)\r\n                bios_version = version.strip().split(\" \")[1]\r\n                return str(bios_version)\r\n            elif self.name == \"Backup_BIOS\":\r\n                bios_version = \"na\"\r\n                return bios_version\r\n                \r\n        elif result.strip() == \"0x03\":\r\n            if self.name == \"Backup_BIOS\":\r\n                version = self.run_command(BIOS_VERSION_PATH)\r\n                bios_version = version.strip().split(\" \")[1]\r\n                return str(bios_version)\r\n            elif self.name == \"Main_BIOS\":\r\n                bios_version = \"na\"\r\n                return bios_version\r\n\r\n    def __get_cpld_version(self):\r\n        if self.name == \"SWCPLD\":\r\n            ver = self.run_command(SWCPLD_VERSION_PATH)\r\n            print(\"ver is %s\" % ver)\r\n            ver = ver.strip().split(\"x\")[1]\r\n            print(\"ver2 is %s\" % ver)\r\n            version = int(ver.strip()) / 10\r\n            return str(version)\r\n\r\n                \r\n    def get_name(self):\r\n        \"\"\"\r\n        Retrieves the name of the component\r\n         Returns:\r\n            A string containing the name of the component\r\n        \"\"\"\r\n        return COMPONENT_NAME_LIST[self.index]\r\n\r\n    def get_description(self):\r\n        \"\"\"\r\n        Retrieves the description of the component\r\n            Returns:\r\n            A string containing the description of the component\r\n        \"\"\"\r\n        return COMPONENT_DES_LIST[self.index]\r\n\r\n    def get_firmware_version(self):\r\n        \"\"\"\r\n        Retrieves the firmware version of module\r\n        Returns:\r\n            string: The firmware versions of the module\r\n        \"\"\"\r\n        fw_version = None\r\n        \r\n        if \"BIOS\" in self.name:\r\n            fw_version = self.__get_bios_version()\r\n        elif \"CPLD\" in self.name:\r\n            fw_version = self.__get_cpld_version()\r\n            \r\n        return fw_version\r\n\r\n    def install_firmware(self, image_path):\r\n        \"\"\"\r\n        Install firmware to module\r\n        Args:\r\n            image_path: A string, path to firmware image\r\n        Returns:\r\n            A boolean, True if install successfully, False if not\r\n        \"\"\"\r\n        return False\r\n\r\n    def update_firmware(self, image_path):\r\n        return False\r\n\r\n    def get_available_firmware_version(self, image_path):\r\n        return 'N/A'\r\n\r\n    def get_firmware_update_notification(self, image_path):\r\n        return \"None\"\r\n\r\n    def get_model(self):\r\n        return 'N/A'\r\n\r\n    def get_position_in_parent(self):\r\n        return -1\r\n\r\n    def get_presence(self):\r\n        return True\r\n \r\n    def get_serial(self):\r\n        return 'N/A'\r\n\r\n    def get_status(self):\r\n        return True\r\n\r\n    def is_replaceable(self):\r\n        return False\r\n"}, "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py": {"changes": [{"diff": "\n         \"\"\"\n         if self.is_psu_fan:\n             cmd_num = \"58\" if self.fans_psu_index == 1 else \"59\"\n-            cmd = \"i2cget -y -f 4 0x%s 0x80\" % cmd_num\n-            res = os.popen(cmd).read()\n+            cmd = [\"i2cget\", \"-y\", \"-f\", \"4\", \"\", \"0x80\"]\n+            cmd[4] = \"0x\" + cmd_num\n+            res = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()\n             # F2B \n             if res.strip() == \"0x01\":\n                 dir", "add": 3, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py", "badparts": ["            cmd = \"i2cget -y -f 4 0x%s 0x80\" % cmd_num", "            res = os.popen(cmd).read()"], "goodparts": ["            cmd = [\"i2cget\", \"-y\", \"-f\", \"4\", \"\", \"0x80\"]", "            cmd[4] = \"0x\" + cmd_num", "            res = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()"]}], "source": "\ntry: from sonic_platform_pddf_base.pddf_fan import PddfFan import os except ImportError as e: raise ImportError(str(e) +\"-required module not found\") FAN_DIRECTION_FILE_PATH=\"/var/fan_direction\" class Fan(PddfFan): \"\"\"PDDF Platform-Specific Fan class\"\"\" def __init__(self, tray_idx, fan_idx=0, pddf_data=None, pddf_plugin_data=None, is_psu_fan=False, psu_index=0): PddfFan.__init__(self, tray_idx, fan_idx, pddf_data, pddf_plugin_data, is_psu_fan, psu_index) def get_speed_tolerance(self): \"\"\" Retrieves the speed tolerance of the fan Returns: An integer, the percentage of variance from target speed which is considered tolerable \"\"\" return 20 def get_presence(self): return True def get_direction(self): \"\"\" Retrieves the direction of fan Returns: A string, either FAN_DIRECTION_INTAKE or FAN_DIRECTION_EXHAUST depending on fan direction \"\"\" if self.is_psu_fan: cmd_num=\"58\" if self.fans_psu_index==1 else \"59\" cmd=\"i2cget -y -f 4 0x%s 0x80\" % cmd_num res=os.popen(cmd).read() if res.strip()==\"0x01\": direction=\"EXHAUST\" else: direction=\"INTAKE\" else: direction=\"INTAKE\" with open(FAN_DIRECTION_FILE_PATH, \"r\") as f: fan_direction=f.read() if fan_direction.strip()==\"FB\": direction=\"EXHAUST\" return direction def get_status(self): speed=self.get_speed_rpm() status=True if(speed !=0) else False return status def get_target_speed(self): \"\"\" Retrieves the target(expected) speed of the fan Returns: An integer, the percentage of full fan speed, in the range 0(off) to 100(full speed) \"\"\" target_speed=0 if self.is_psu_fan: target_speed=\"N/A\" else: idx=(self.fantray_index -1) * 1 +self.fan_index attr=\"fan\" +str(idx) +\"_pwm\" pwm_path=\"/sys/devices/pci0000:00/0000:00:12.0/i2c-0/i2c-2/2-0066/\" +attr pwm=0 with open(pwm_path, \"r\") as f: pwm=f.read() percentage=int(pwm.strip()) speed_percentage=int(round(percentage / 255 * 100)) target_speed=speed_percentage return target_speed def set_status_led(self, color): color_dict={\"green\": \"STATUS_LED_COLOR_GREEN\", \"red\": \"STATUS_LED_COLOR_AMBER\"} color=color_dict.get(color, \"off\") index=str(self.fantray_index -1) led_device_name=\"FANTRAY{}\".format(self.fantray_index) +\"_LED\" result, msg=self.pddf_obj.is_supported_sysled_state(led_device_name, color) if result is False: return False device_name=self.pddf_obj.data[led_device_name]['dev_info']['device_name'] self.pddf_obj.create_attr('device_name', device_name, self.pddf_obj.get_led_path()) self.pddf_obj.create_attr('index', index, self.pddf_obj.get_led_path()) self.pddf_obj.create_attr('color', color, self.pddf_obj.get_led_cur_state_path()) self.pddf_obj.create_attr('dev_ops', 'set_status', self.pddf_obj.get_led_path()) return True @staticmethod def get_model(): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" model=\"Unknown\" return model @staticmethod def get_serial(): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" serial=\"Unknown\" return serial def get_position_in_parent(self): \"\"\" Retrieves the fan/psu fan index number \"\"\" return self.fantray_index if not self.is_psu_fan else self.fans_psu_index +4 \t\t @staticmethod def is_replaceable(): \"\"\" Retrieves whether the device is replaceable \"\"\" return False ", "sourceWithComments": "try:\n    from sonic_platform_pddf_base.pddf_fan import PddfFan\n    import os\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n# ------------------------------------------------------------------\n# HISTORY:\n#    5/1/2022 (A.D.)\n#    add function:set_status_led,\n#    Solve the problem that when a fan is pulled out, the Fan LED on the front panel is still green Issue-#11525\n# ------------------------------------------------------------------\nFAN_DIRECTION_FILE_PATH = \"/var/fan_direction\"\n\n\nclass Fan(PddfFan):\n    \"\"\"PDDF Platform-Specific Fan class\"\"\"\n\n    def __init__(self, tray_idx, fan_idx=0, pddf_data=None, pddf_plugin_data=None, is_psu_fan=False, psu_index=0):\n        # idx is 0-based\n        PddfFan.__init__(self, tray_idx, fan_idx, pddf_data, pddf_plugin_data, is_psu_fan, psu_index)\n\n\n    def get_speed_tolerance(self):\n        \"\"\"\n        Retrieves the speed tolerance of the fan\n\n        Returns:\n            An integer, the percentage of variance from target speed which is\n                 considered tolerable\n        \"\"\"\n        # Fix the speed vairance to 10 percent. If it changes based on platforms, overwrite\n        # this value in derived pddf fan class\n        return 20\n    \n    \n    def get_presence(self):\n        #Overwirte the PDDF Common since the FANs on Belgite are all Fixed and present\n        return True \n\n    def get_direction(self):\n        \"\"\"\n        Retrieves the direction of fan\n\n        Returns:\n            A string, either FAN_DIRECTION_INTAKE or FAN_DIRECTION_EXHAUST\n            depending on fan direction\n        \"\"\"\n        if self.is_psu_fan:\n            cmd_num = \"58\" if self.fans_psu_index == 1 else \"59\"\n            cmd = \"i2cget -y -f 4 0x%s 0x80\" % cmd_num\n            res = os.popen(cmd).read()\n            # F2B \n            if res.strip() == \"0x01\":\n                direction = \"EXHAUST\"\n            else:\n                direction = \"INTAKE\"\n        else:\n            direction = \"INTAKE\"\n            with open(FAN_DIRECTION_FILE_PATH, \"r\") as f:\n                fan_direction = f.read()\n                if fan_direction.strip() == \"FB\":\n                    direction = \"EXHAUST\"\n        return direction\n    \n\n    def get_status(self):\n        speed = self.get_speed_rpm()\n        status = True if (speed != 0) else False\n        return status\n\n    def get_target_speed(self):\n        \"\"\"\n        Retrieves the target (expected) speed of the fan\n\n        Returns:\n            An integer, the percentage of full fan speed, in the range 0 (off)\n                 to 100 (full speed)\n        \"\"\"\n        target_speed = 0\n        if self.is_psu_fan:\n            # Target speed not usually supported for PSU fans\n            target_speed = \"N/A\"\n        else:\n            idx = (self.fantray_index - 1) * 1 + self.fan_index\n            attr = \"fan\" + str(idx) + \"_pwm\"\n            pwm_path = \"/sys/devices/pci0000:00/0000:00:12.0/i2c-0/i2c-2/2-0066/\" + attr\n            pwm = 0\n            with open(pwm_path, \"r\") as f:\n                pwm = f.read()\n\n            percentage = int(pwm.strip())\n            speed_percentage = int(round(percentage / 255 * 100))\n            target_speed = speed_percentage\n\n        return target_speed\n\n    def set_status_led(self, color):\n        color_dict = {\"green\": \"STATUS_LED_COLOR_GREEN\",\n                      \"red\": \"STATUS_LED_COLOR_AMBER\"}\n        color = color_dict.get(color, \"off\")\n        index = str(self.fantray_index - 1)\n        led_device_name = \"FANTRAY{}\".format(self.fantray_index) + \"_LED\"\n\n        result, msg = self.pddf_obj.is_supported_sysled_state(led_device_name, color)\n        if result is False:\n            return False\n        device_name = self.pddf_obj.data[led_device_name]['dev_info']['device_name']\n        self.pddf_obj.create_attr('device_name', device_name, self.pddf_obj.get_led_path())\n        self.pddf_obj.create_attr('index', index, self.pddf_obj.get_led_path())\n        self.pddf_obj.create_attr('color', color, self.pddf_obj.get_led_cur_state_path())\n\n        self.pddf_obj.create_attr('dev_ops', 'set_status', self.pddf_obj.get_led_path())\n        return True\n\n    @staticmethod\n    def get_model():\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        model = \"Unknown\"\n        return model\n\n    @staticmethod\n    def get_serial():\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        serial = \"Unknown\"\n        return serial\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves the fan/psu fan index number\n        \"\"\"\n        return self.fantray_index if not self.is_psu_fan else self.fans_psu_index + 4\n\t\t\n    @staticmethod\n    def is_replaceable():\n        \"\"\"\n        Retrieves whether the device is replaceable\n        \"\"\"\n        return False\n"}, "/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py": {"changes": [{"diff": "\n try:\n     import sys\n     import getopt\n-    import subprocess\n     import logging\n     import logging.config\n     import time  # this is only being used as part of the example\n     import signal\n     import math\n     from sonic_platform import platform\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py", "badparts": ["    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         else:\n             logging.debug('INFO: FAIL. set_fan_duty_cycle (%d)' % DUTY_MAX)\n         # Enable the CPLD Heartbeat back\n-        status, output = subprocess.getstatusoutput('i2cset -f -y 75 0x40 0x22 0x00')\n+        status, output = getstatusoutput_noshell([\"i2cset\", \"-f\", \"-y\", \"75\", \"0x40\", \"0x22\", \"0x00\"])\n         if status == 0:\n             logging.debug('INFO: CPLD Heartbeat check is enabled back')\n     sys.exit(0)\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py", "badparts": ["        status, output = subprocess.getstatusoutput('i2cset -f -y 75 0x40 0x22 0x00')"], "goodparts": ["        status, output = getstatusoutput_noshell([\"i2cset\", \"-f\", \"-y\", \"75\", \"0x40\", \"0x22\", \"0x00\"])"]}, {"diff": "\n     signal.signal(signal.SIGINT, handler)\n     signal.signal(signal.SIGTERM, handler)\n     # Disaable the CPLD Heartbeat check to control Fan speed from CPU via ADT7470\n-    subprocess.getstatusoutput('i2cset -f -y 2 0x32 0x30 0x01')\n+    getstatusoutput_noshell(['i2cset', '-f', '-y', '2', '0x32', '0x30', '0x01'])\n \n     monitor = cel_belgite_monitor(log", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py", "badparts": ["    subprocess.getstatusoutput('i2cset -f -y 2 0x32 0x30 0x01')"], "goodparts": ["    getstatusoutput_noshell(['i2cset', '-f', '-y', '2', '0x32', '0x30', '0x01'])"]}], "source": "\n try: import sys import getopt import subprocess import logging import logging.config import time import signal import math from sonic_platform import platform except ImportError as e: raise ImportError('%s -required module not found' % str(e)) FUNCTION_NAME='cel_belgite_monitor' DUTY_MAX=100 FAN_NUMBER=3 SENSOR_NUMBER=4 CPU_CORE_TEMP=r\"/sys/devices/platform/coretemp.0/hwmon/hwmon1/temp1_input\" class cel_belgite_monitor(object): \"\"\" Make a class we can use to capture stdout and sterr in the log \"\"\" _ori_temp=0 _new_perc=DUTY_MAX / 2 syslog=logging.getLogger(\"[\" +FUNCTION_NAME +\"]\") init_fan_temperature=[0, 0, 0, 0] def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" formatter=logging.Formatter('%(name)s %(message)s') sys_handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setFormatter(formatter) sys_handler.ident='common' self.syslog.setLevel(logging.WARNING) self.syslog.addHandler(sys_handler) self.platform_chassis_obj=platform.Platform().get_chassis() logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) logging.debug('SET. logfile:%s / loglevel:%d' %(log_file, log_level)) def get_all_temperature(self): \"\"\" return: all temperature \"\"\" all_temperature_list=list() for sensor_index in range(SENSOR_NUMBER): temp=self.platform_chassis_obj.get_thermal(sensor_index).get_temperature() if temp is None or str(temp).strip()==\"\": return False temp=temp*1000 all_temperature_list.append(temp) u4_temperature=all_temperature_list[0] u7_temperature=all_temperature_list[1] cpu_temperature=70000 try: with open(CPU_CORE_TEMP, \"r\") as f: cpu_temperature=float(f.read().strip()) except Exception as E: logging.debug('Error: %s' % E) u60_temperature=all_temperature_list[3] return[u4_temperature, u7_temperature, cpu_temperature, u60_temperature] def get_fan_speed_by_temperature(self, temp_list): fan1_direction=self.platform_chassis_obj.get_fan(0).get_direction() logging.debug('INFO: fan direction: %s' % str(fan1_direction)) all_temp=self.get_all_temperature() logging.debug('INFO: all_temp: %s' % str(all_temp)) a=1 if fan1_direction.lower()==\"intake\" else 0 sensor_temp=all_temp[a] cup_temp=all_temp[2] u60_temp=all_temp[3] logging.debug('sensor_temp:%d cup_temp:%d u60_temp:%d' %(sensor_temp, cup_temp, u60_temp)) update_temp_sensor, update_temp_cpu, update_temp_u60=True, True, True if all_temp[a] -temp_list[a] < 0: update_temp_sensor=False if cup_temp -temp_list[2] < 0: update_temp_cpu=False if u60_temp -temp_list[3] < 0: update_temp_u60=False if not update_temp_sensor: b=math.trunc(1400/13) if sensor_temp <=32000: sensor_temp_speed=40 elif sensor_temp >=45000: sensor_temp_speed=100 else: sensor_temp_speed=int(math.trunc(60 / 13) * math.trunc(sensor_temp / 1000) -b) else: b=math.trunc(1580 / 13) if sensor_temp <=35000: sensor_temp_speed=40 elif sensor_temp >=48000: sensor_temp_speed=100 else: sensor_temp_speed=int(math.trunc(60/13) * math.trunc(sensor_temp/1000) -b) if not update_temp_cpu: b=228 if cup_temp <=67000: cpu_temp_speed=40 elif cup_temp >=82000: cpu_temp_speed=100 else: cpu_temp_speed=int(4 *(cup_temp / 1000) -b) else: b=240 if cup_temp <=70000: cpu_temp_speed=40 elif cup_temp >=85000: cpu_temp_speed=100 else: cpu_temp_speed=int(4 *(cup_temp / 1000) -b) if not update_temp_u60: b=168 if u60_temp <=52000: u60_temp_speed=40 elif u60_temp >=67000: u60_temp_speed=100 else: u60_temp_speed=int(4 *(u60_temp / 1000) -b) else: b=180 if u60_temp <=55000: u60_temp_speed=40 elif u60_temp >=70000: u60_temp_speed=100 else: u60_temp_speed=int(4 *(u60_temp / 1000) -b) return max([sensor_temp_speed, cpu_temp_speed, u60_temp_speed]) def manage_fans(self): fan_presence_list=[True, True, True] for fan_index in range(FAN_NUMBER): if not self.platform_chassis_obj.get_fan(fan_index).get_presence() or not \\ self.platform_chassis_obj.get_fan(fan_index).get_status(): fan_presence_list[fan_index]=False logging.debug('self.platform_chassis_obj.get_fan(fan_index).get_presence():%s' % str(self.platform_chassis_obj.get_fan(fan_index).get_presence())) logging.debug('self.platform_chassis_obj.get_fan(fan_index).get_status():%s' % str(self.platform_chassis_obj.get_fan(fan_index).get_status())) else: fan_presence_list[fan_index]=True fans_inserted_num=FAN_NUMBER -fan_presence_list.count(False) if fans_inserted_num==0: self.syslog.critical(\"No fans inserted. Severe overheating hazard. \" \"Please insert Fans immediately or power off the device\\n\") elif fans_inserted_num in[1, 2]: self._new_perc=DUTY_MAX else: self._new_perc=self.get_fan_speed_by_temperature(self.init_fan_temperature) logging.debug('INFO: 3 fans inserted: self._new_perc: %s' % str(self._new_perc)) self.init_fan_temperature=self.get_all_temperature() for i in range(FAN_NUMBER): aa=self.platform_chassis_obj.get_fan(i).get_speed() logging.debug(\"INFO: Get before setting fan speed: %s\" % aa) if self._new_perc < 40: self._new_perc=40 if self._new_perc > 100: self._new_perc=100 set_stat=self.platform_chassis_obj.get_fan(i).set_speed(self._new_perc) if set_stat is True: logging.debug('INFO: PASS. set_fan%d_duty_cycle(%d)' %(i, self._new_perc)) else: logging.debug('INFO: FAIL. set_fan%d_duty_cycle(%d)' %(i, self._new_perc)) def handler(signum, frame): platform_chassis=platform.Platform().get_chassis() for _ in range(FAN_NUMBER): set_stat=platform_chassis.get_fan(_).set_speed(DUTY_MAX) if set_stat is True: logging.debug('INFO:Cause signal %d, set fan speed max.' % signum) else: logging.debug('INFO: FAIL. set_fan_duty_cycle(%d)' % DUTY_MAX) status, output=subprocess.getstatusoutput('i2cset -f -y 75 0x40 0x22 0x00') if status==0: logging.debug('INFO: CPLD Heartbeat check is enabled back') sys.exit(0) def main(argv): global test_temp log_file='/home/admin/%s.log' % FUNCTION_NAME log_level=logging.INFO if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv, 'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv) !=6: print(\"temp test, need input 4 temp\") return 0 signal.signal(signal.SIGINT, handler) signal.signal(signal.SIGTERM, handler) subprocess.getstatusoutput('i2cset -f -y 2 0x32 0x30 0x01') monitor=cel_belgite_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(10) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# Copyright (C) Celestica Technology Corporation\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    9/16/2021 (A.D.)\n# ------------------------------------------------------------------\n\ntry:\n    import sys\n    import getopt\n    import subprocess\n    import logging\n    import logging.config\n    import time  # this is only being used as part of the example\n    import signal\n    import math\n    from sonic_platform import platform\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nFUNCTION_NAME = 'cel_belgite_monitor'\nDUTY_MAX = 100\nFAN_NUMBER = 3\nSENSOR_NUMBER = 4\nCPU_CORE_TEMP = r\"/sys/devices/platform/coretemp.0/hwmon/hwmon1/temp1_input\"\n\n\nclass cel_belgite_monitor(object):\n    \"\"\"\n    Make a class we can use to capture stdout and sterr in the log\n    \"\"\"\n    # static temp var\n    _ori_temp = 0\n    _new_perc = DUTY_MAX / 2\n    syslog = logging.getLogger(\"[\" + FUNCTION_NAME + \"]\")\n    init_fan_temperature = [0, 0, 0, 0]\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        formatter = logging.Formatter('%(name)s %(message)s')\n        sys_handler = logging.handlers.SysLogHandler(address='/dev/log')\n        sys_handler.setFormatter(formatter)\n        sys_handler.ident = 'common'\n        self.syslog.setLevel(logging.WARNING)\n        self.syslog.addHandler(sys_handler)\n        self.platform_chassis_obj = platform.Platform().get_chassis()\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format='[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n        logging.debug('SET. logfile:%s / loglevel:%d' % (log_file, log_level))\n\n    def get_all_temperature(self):\n        \"\"\"\n        return: all temperature\n        \"\"\"\n        all_temperature_list = list()\n        for sensor_index in range(SENSOR_NUMBER):\n            temp = self.platform_chassis_obj.get_thermal(sensor_index).get_temperature()\n            if temp is None or str(temp).strip() == \"\":\n                return False\n            temp = temp*1000\n            all_temperature_list.append(temp)\n        u4_temperature = all_temperature_list[0]\n        u7_temperature = all_temperature_list[1]\n        # default CPU temperature 70\n        cpu_temperature = 70000\n        try:\n            with open(CPU_CORE_TEMP, \"r\") as f:\n                cpu_temperature = float(f.read().strip())\n        except Exception as E:\n            logging.debug('Error: %s' % E)\n        u60_temperature = all_temperature_list[3]   \n        return [u4_temperature, u7_temperature, cpu_temperature, u60_temperature]\n\n    def get_fan_speed_by_temperature(self, temp_list):\n        fan1_direction = self.platform_chassis_obj.get_fan(0).get_direction()\n        logging.debug('INFO: fan direction: %s' % str(fan1_direction))\n        all_temp = self.get_all_temperature()\n        logging.debug('INFO: all_temp: %s' % str(all_temp))\n        # B2F=intake: U7 temperature\uff0c F2B-EXHAUST: U4 temperature\n        a = 1 if fan1_direction.lower() == \"intake\" else 0\n        sensor_temp = all_temp[a]\n        cup_temp = all_temp[2]\n        u60_temp = all_temp[3]\n        logging.debug('sensor_temp:%d cup_temp:%d u60_temp:%d' % (sensor_temp, cup_temp, u60_temp))\n        update_temp_sensor, update_temp_cpu, update_temp_u60 = True, True, True\n        if all_temp[a] - temp_list[a] < 0:\n            update_temp_sensor = False\n        if cup_temp - temp_list[2] < 0:\n            update_temp_cpu = False\n        if u60_temp - temp_list[3] < 0:\n            update_temp_u60 = False\n\n        # U4 U7\n        if not update_temp_sensor:  # temperature down\n            b = math.trunc(1400/13)\n            if sensor_temp <= 32000:\n                sensor_temp_speed = 40\n            elif sensor_temp >= 45000:\n                sensor_temp_speed = 100\n            else:\n                sensor_temp_speed = int(math.trunc(60 / 13) * math.trunc(sensor_temp / 1000) - b)\n        else:   # temperature up\n            b = math.trunc(1580 / 13)\n            if sensor_temp <= 35000:\n                sensor_temp_speed = 40\n            elif sensor_temp >= 48000:\n                sensor_temp_speed = 100\n            else:\n                sensor_temp_speed = int(math.trunc(60/13) * math.trunc(sensor_temp/1000) - b)\n\n        # CPU\n        if not update_temp_cpu:  # temperature down\n            b = 228\n            if cup_temp <= 67000:\n                cpu_temp_speed = 40\n            elif cup_temp >= 82000:\n                cpu_temp_speed = 100\n            else:\n                cpu_temp_speed = int(4 * (cup_temp / 1000) - b)\n        else:   # temperature up\n            b = 240\n            if cup_temp <= 70000:\n                cpu_temp_speed = 40\n            elif cup_temp >= 85000:\n                cpu_temp_speed = 100\n            else:\n                cpu_temp_speed = int(4 * (cup_temp / 1000) - b)\n\n        # U60\n        if not update_temp_u60:  # temperature down\n            b = 168\n            if u60_temp <= 52000:\n                u60_temp_speed = 40\n            elif u60_temp >= 67000:\n                u60_temp_speed = 100\n            else:\n                u60_temp_speed = int(4 * (u60_temp / 1000) - b)\n        else:   # temperature up\n            b = 180\n            if u60_temp <= 55000:\n                u60_temp_speed = 40\n            elif u60_temp >= 70000:\n                u60_temp_speed = 100\n            else:\n                u60_temp_speed = int(4 * (u60_temp / 1000) - b)\n        return max([sensor_temp_speed, cpu_temp_speed, u60_temp_speed])\n\n    def manage_fans(self):\n        fan_presence_list = [True, True, True]  # whether fan is absent or not \n        for fan_index in range(FAN_NUMBER):\n            if not self.platform_chassis_obj.get_fan(fan_index).get_presence() or not \\\n                    self.platform_chassis_obj.get_fan(fan_index).get_status():\n                fan_presence_list[fan_index] = False\n                logging.debug('self.platform_chassis_obj.get_fan(fan_index).get_presence():%s'\n                              % str(self.platform_chassis_obj.get_fan(fan_index).get_presence()))\n                logging.debug('self.platform_chassis_obj.get_fan(fan_index).get_status():%s'\n                              % str(self.platform_chassis_obj.get_fan(fan_index).get_status()))\n            else:\n                fan_presence_list[fan_index] = True\n\n        fans_inserted_num = FAN_NUMBER - fan_presence_list.count(False)\n        if fans_inserted_num == 0:  # all fans broken, power off \n            self.syslog.critical(\"No fans inserted. Severe overheating hazard. \"\n                                 \"Please insert Fans immediately or power off the device\\n\")\n\n            # power off \n        elif fans_inserted_num in [1, 2]:   # 1 or 2 present, full speed \n            self._new_perc = DUTY_MAX\n        else:   # 3 fans normal, manage the fans follow thermal policy \n            self._new_perc = self.get_fan_speed_by_temperature(self.init_fan_temperature)\n            logging.debug('INFO: 3 fans inserted: self._new_perc: %s' % str(self._new_perc))\n            self.init_fan_temperature = self.get_all_temperature()\n\n        for i in range(FAN_NUMBER):\n            aa = self.platform_chassis_obj.get_fan(i).get_speed()\n            logging.debug(\"INFO: Get before setting fan speed: %s\" % aa)\n            if self._new_perc < 40:\n                self._new_perc = 40\n            if self._new_perc > 100:\n                self._new_perc = 100\n            set_stat = self.platform_chassis_obj.get_fan(i).set_speed(self._new_perc)\n            if set_stat is True:\n                logging.debug('INFO: PASS. set_fan%d_duty_cycle (%d)' % (i, self._new_perc))\n            else:\n                logging.debug('INFO: FAIL. set_fan%d_duty_cycle (%d)' % (i, self._new_perc))\n\n\ndef handler(signum, frame):\n    platform_chassis = platform.Platform().get_chassis()\n    for _ in range(FAN_NUMBER):\n        set_stat = platform_chassis.get_fan(_).set_speed(DUTY_MAX)\n        if set_stat is True:\n            logging.debug('INFO:Cause signal %d, set fan speed max.' % signum)\n        else:\n            logging.debug('INFO: FAIL. set_fan_duty_cycle (%d)' % DUTY_MAX)\n        # Enable the CPLD Heartbeat back\n        status, output = subprocess.getstatusoutput('i2cset -f -y 75 0x40 0x22 0x00')\n        if status == 0:\n            logging.debug('INFO: CPLD Heartbeat check is enabled back')\n    sys.exit(0)\n\n\ndef main(argv):\n    global test_temp\n\n    log_file = '/home/admin/%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv, 'hdlt:', ['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg\n\n        if sys.argv[1] == '-t':\n            if len(sys.argv) != 6:\n                print(\"temp test, need input 4 temp\")\n                return 0\n\n    signal.signal(signal.SIGINT, handler)\n    signal.signal(signal.SIGTERM, handler)\n    # Disaable the CPLD Heartbeat check to control Fan speed from CPU via ADT7470\n    subprocess.getstatusoutput('i2cset -f -y 2 0x32 0x30 0x01')\n\n    monitor = cel_belgite_monitor(log_file, log_level)\n\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(10)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n"}, "/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py": {"changes": [{"diff": "\n \n     SET_METHOD_IPMI = 'ipmitool'\n     NULL_VAL = 'N/A'\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n     REF_KEY = '$ref:'\n \n     def __init__(self, conf=None):\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n             cleaned_input = input_translator.get(input)\n \n         elif type(input_translator) is str:\n-            cleaned_input = eval(input_translator.format(input))\n+            cleaned_input = ast.literal_eval(input_translator.format(input))\n \n         return cleaned_input\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py", "badparts": ["            cleaned_input = eval(input_translator.format(input))"], "goodparts": ["            cleaned_input = ast.literal_eval(input_translator.format(input))"]}, {"diff": "\n         if type(output_translator) is dict:\n             output = output_translator.get(output)\n         elif type(output_translator) is str:\n-            output = eval(output_translator.format(output))\n+            output = ast.literal_eval(output_translator.format(output))\n         elif type(output_translator) is list:\n-            output = eval(output_translator[index].format(output))\n+            output = ast.literal_eval(output_translator[index].format(output))\n \n         return output\n \n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py", "badparts": ["            output = eval(output_translator.format(output))", "            output = eval(output_translator[index].format(output))"], "goodparts": ["            output = ast.literal_eval(output_translator.format(output))", "            output = ast.literal_eval(output_translator[index].format(output))"]}, {"diff": "\n         return True\n \n     def is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def load_json_file(self,", "add": 5, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        try:", "            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)", "        except FileNotFoundError:", "            return False", "        return True"]}], "source": "\nimport os import imp import yaml import subprocess from sonic_py_common import device_info class Common: DEVICE_PATH='/usr/share/sonic/device/' PMON_PLATFORM_PATH='/usr/share/sonic/platform/' CONFIG_DIR='sonic_platform_config' OUTPUT_SOURCE_IPMI='ipmitool' OUTPUT_SOURCE_GIVEN_LIST='value_list' OUTPUT_SOURCE_GIVEN_VALUE='value' OUTPUT_SOURCE_GIVEN_CLASS='class' OUTPUT_SOURCE_SYSFS='sysfs_value' OUTPUT_SOURCE_FUNC='function' OUTPUT_SOURCE_GIVEN_TXT_FILE='txt_file' OUTPUT_SOURCE_GIVEN_VER_HEX_FILE='hex_version_file' OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR='hex_version_getreg' SET_METHOD_IPMI='ipmitool' NULL_VAL='N/A' HOST_CHK_CMD=\"docker > /dev/null 2>&1\" REF_KEY='$ref:' def __init__(self, conf=None): self._main_conf=conf (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def _run_command(self, command): status=False output=\"\" try: p=subprocess.Popen( command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': status, output=True, raw_data.strip() except Exception: pass return status, output def _clean_input(self, input, config): cleaned_input=input ai=config.get('avaliable_input') if ai and input not in ai: return None input_translator=config.get('input_translator') if type(input_translator) is dict: cleaned_input=input_translator.get(input) elif type(input_translator) is str: cleaned_input=eval(input_translator.format(input)) return cleaned_input def _clean_output(self, index, output, config): output_translator=config.get('output_translator') if type(output_translator) is dict: output=output_translator.get(output) elif type(output_translator) is str: output=eval(output_translator.format(output)) elif type(output_translator) is list: output=eval(output_translator[index].format(output)) return output def _ipmi_get(self, index, config): argument=config.get('argument') cmd=config['command'].format( config['argument'][index]) if argument else config['command'] status, output=self._run_command(cmd) return output if status else None def _sysfs_read(self, index, config): sysfs_path=config.get('sysfs_path') argument=config.get('argument', '') if self.REF_KEY in argument: argument=self._main_conf[argument.split(\":\")[1]] if type(argument) is list: sysfs_path=sysfs_path.format(argument[index]) content=\"\" try: content=open(sysfs_path) content=content.readline().rstrip() except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False return content def _sysfs_write(self, index, config, input): sysfs_path=config.get('sysfs_path') argument=config.get('argument', '') if self.REF_KEY in argument: argument=self._main_conf[argument.split(\":\")[1]] if type(argument) is list: sysfs_path=sysfs_path.format(argument[index]) write_offset=int(config.get('write_offset', 0)) output=\"\" try: open_file=open(sysfs_path, \"r+\") open_file.seek(write_offset) open_file.write(input) open_file.close() except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False, output return True, output def _ipmi_set(self, index, config, input): arg=config['argument'][index].format(input) return self._run_command(config['command'].format(arg)) def _hex_ver_decode(self, hver, num_of_bits, num_of_points): ver_list=[] c_bit=0 bin_val=bin(int(hver, 16))[2:].zfill(num_of_bits) bit_split=num_of_bits /(num_of_points +1) for x in range(0, num_of_points+1): split_bin=bin_val[c_bit:c_bit+bit_split] ver_list.append(str(int(split_bin, 2))) c_bit +=bit_split return '.'.join(ver_list) def _get_class(self, config): \"\"\" Retreives value of expected attribute Returns: A value of the attribute of object \"\"\" path=config['host_path'] if self.is_host() else config['pmon_path'] module=imp.load_source(config['class'], path) class_=getattr(module, config['class']) return class_ def get_reg(self, path, reg_addr): cmd=\"echo{1} >{0}; cat{0}\".format(path, reg_addr) status, output=self._run_command(cmd) return output if status else None def read_txt_file(self, path): with open(path, 'r') as f: output=f.readline() return output.strip('\\n') def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except Exception: return False return True def is_host(self): return os.system(self.HOST_CHK_CMD)==0 def load_json_file(self, path): \"\"\" Retrieves the json object from json file path Returns: A json object \"\"\" with open(path, 'r') as f: json_data=yaml.safe_load(f) return json_data def get_config_path(self, config_name): \"\"\" Retrieves the path to platform api config directory Args: config_name: A string containing the name of config file. Returns: A string containing the path to json file \"\"\" return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name) def get_output(self, index, config, default): \"\"\" Retrieves the output for each function base on config Args: index: An integer containing the index of device. config: A dict object containing the configuration of specified function. default: A string containing the default output of specified function. Returns: A string containing the output of specified function in config \"\"\" output_source=config.get('output_source') if output_source==self.OUTPUT_SOURCE_IPMI: output=self._ipmi_get(index, config) elif output_source==self.OUTPUT_SOURCE_GIVEN_VALUE: output=config[\"value\"] elif output_source==self.OUTPUT_SOURCE_GIVEN_CLASS: output=self._get_class(config) elif output_source==self.OUTPUT_SOURCE_GIVEN_LIST: output=config[\"value_list\"][index] elif output_source==self.OUTPUT_SOURCE_SYSFS: output=self._sysfs_read(index, config) elif output_source==self.OUTPUT_SOURCE_FUNC: func_conf=self._main_conf[config['function'][index]] output=self.get_output(index, func_conf, default) elif output_source==self.OUTPUT_SOURCE_GIVEN_TXT_FILE: path=config.get('path') output=self.read_txt_file(path) elif output_source==self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE: path=config.get('path') hex_ver=self.read_txt_file(path) output=self._hex_ver_decode( hex_ver, config['num_of_bits'], config['num_of_points']) elif output_source==self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR: path=config.get('path') addr=config.get('reg_addr') hex_ver=self.get_reg(path, addr) output=self._hex_ver_decode( hex_ver, config['num_of_bits'], config['num_of_points']) else: output=default return self._clean_output(index, output, config) or default def set_output(self, index, input, config): \"\"\" Sets the output of specified function on config Args: config: A dict object containing the configuration of specified function. index: An integer containing the index of device. input: A string containing the input of specified function. Returns: bool: True if set function is successfully, False if not \"\"\" cleaned_input=self._clean_input(input, config) if not cleaned_input: return False set_method=config.get('set_method') if set_method==self.SET_METHOD_IPMI: output=self._ipmi_set(index, config, cleaned_input)[0] elif set_method==self.OUTPUT_SOURCE_SYSFS: output=self._sysfs_write(index, config, cleaned_input)[0] else: output=False return output def get_event(self, timeout, config, sfp_list): \"\"\" Returns a nested dictionary containing all devices which have experienced a change at chassis level \"\"\" event_class=self._get_class(config) return event_class(sfp_list).get_event(timeout) ", "sourceWithComments": "import os\nimport imp\nimport yaml\nimport subprocess\n\nfrom sonic_py_common import device_info\n\n\nclass Common:\n\n    DEVICE_PATH = '/usr/share/sonic/device/'\n    PMON_PLATFORM_PATH = '/usr/share/sonic/platform/'\n    CONFIG_DIR = 'sonic_platform_config'\n\n    OUTPUT_SOURCE_IPMI = 'ipmitool'\n    OUTPUT_SOURCE_GIVEN_LIST = 'value_list'\n    OUTPUT_SOURCE_GIVEN_VALUE = 'value'\n    OUTPUT_SOURCE_GIVEN_CLASS = 'class'\n    OUTPUT_SOURCE_SYSFS = 'sysfs_value'\n    OUTPUT_SOURCE_FUNC = 'function'\n    OUTPUT_SOURCE_GIVEN_TXT_FILE = 'txt_file'\n    OUTPUT_SOURCE_GIVEN_VER_HEX_FILE = 'hex_version_file'\n    OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR = 'hex_version_getreg'\n\n    SET_METHOD_IPMI = 'ipmitool'\n    NULL_VAL = 'N/A'\n    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n    REF_KEY = '$ref:'\n\n    def __init__(self, conf=None):\n        self._main_conf = conf\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def _run_command(self, command):\n        status = False\n        output = \"\"\n        try:\n            p = subprocess.Popen(\n                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                status, output = True, raw_data.strip()\n        except Exception:\n            pass\n        return status, output\n\n    def _clean_input(self, input, config):\n        cleaned_input = input\n\n        ai = config.get('avaliable_input')\n        if ai and input not in ai:\n            return None\n\n        input_translator = config.get('input_translator')\n        if type(input_translator) is dict:\n            cleaned_input = input_translator.get(input)\n\n        elif type(input_translator) is str:\n            cleaned_input = eval(input_translator.format(input))\n\n        return cleaned_input\n\n    def _clean_output(self, index, output, config):\n        output_translator = config.get('output_translator')\n\n        if type(output_translator) is dict:\n            output = output_translator.get(output)\n        elif type(output_translator) is str:\n            output = eval(output_translator.format(output))\n        elif type(output_translator) is list:\n            output = eval(output_translator[index].format(output))\n\n        return output\n\n    def _ipmi_get(self, index, config):\n        argument = config.get('argument')\n        cmd = config['command'].format(\n            config['argument'][index]) if argument else config['command']\n        status, output = self._run_command(cmd)\n        return output if status else None\n\n    def _sysfs_read(self, index, config):\n        sysfs_path = config.get('sysfs_path')\n        argument = config.get('argument', '')\n\n        if self.REF_KEY in argument:\n            argument = self._main_conf[argument.split(\":\")[1]]\n\n        if type(argument) is list:\n            sysfs_path = sysfs_path.format(argument[index])\n\n        content = \"\"\n        try:\n            content = open(sysfs_path)\n            content = content.readline().rstrip()\n        except IOError as e:\n            print(\"Error: unable to open file: %s\" % str(e))\n            return False\n\n        return content\n\n    def _sysfs_write(self, index, config, input):\n        sysfs_path = config.get('sysfs_path')\n        argument = config.get('argument', '')\n\n        if self.REF_KEY in argument:\n            argument = self._main_conf[argument.split(\":\")[1]]\n\n        if type(argument) is list:\n            sysfs_path = sysfs_path.format(argument[index])\n\n        write_offset = int(config.get('write_offset', 0))\n        output = \"\"\n        try:\n            open_file = open(sysfs_path, \"r+\")\n            open_file.seek(write_offset)\n            open_file.write(input)\n            open_file.close()\n        except IOError as e:\n            print(\"Error: unable to open file: %s\" % str(e))\n            return False, output\n        return True, output\n\n    def _ipmi_set(self, index, config, input):\n        arg = config['argument'][index].format(input)\n        return self._run_command(config['command'].format(arg))\n\n    def _hex_ver_decode(self, hver, num_of_bits, num_of_points):\n        ver_list = []\n        c_bit = 0\n        bin_val = bin(int(hver, 16))[2:].zfill(num_of_bits)\n        bit_split = num_of_bits / (num_of_points + 1)\n        for x in range(0, num_of_points+1):\n            split_bin = bin_val[c_bit:c_bit+bit_split]\n            ver_list.append(str(int(split_bin, 2)))\n            c_bit += bit_split\n        return '.'.join(ver_list)\n\n    def _get_class(self, config):\n        \"\"\"\n        Retreives value of expected attribute\n        Returns:\n            A value of the attribute of object\n        \"\"\"\n        path = config['host_path'] if self.is_host() else config['pmon_path']\n        module = imp.load_source(config['class'], path)\n        class_ = getattr(module, config['class'])\n        return class_\n\n    def get_reg(self, path, reg_addr):\n        cmd = \"echo {1} > {0}; cat {0}\".format(path, reg_addr)\n        status, output = self._run_command(cmd)\n        return output if status else None\n\n    def read_txt_file(self, path):\n        with open(path, 'r') as f:\n            output = f.readline()\n        return output.strip('\\n')\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except Exception:\n            return False\n        return True\n\n    def is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def load_json_file(self, path):\n        \"\"\"\n        Retrieves the json object from json file path\n\n        Returns:\n            A json object\n        \"\"\"\n        with open(path, 'r') as f:\n            json_data = yaml.safe_load(f)\n\n        return json_data\n\n    def get_config_path(self, config_name):\n        \"\"\"\n        Retrieves the path to platform api config directory\n\n        Args:\n            config_name: A string containing the name of config file.\n\n        Returns:\n            A string containing the path to json file\n        \"\"\"\n        return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\n\n    def get_output(self, index, config, default):\n        \"\"\"\n        Retrieves the output for each function base on config\n\n        Args:\n            index: An integer containing the index of device.\n            config: A dict object containing the configuration of specified function.\n            default: A string containing the default output of specified function.\n\n        Returns:\n            A string containing the output of specified function in config\n        \"\"\"\n        output_source = config.get('output_source')\n\n        if output_source == self.OUTPUT_SOURCE_IPMI:\n            output = self._ipmi_get(index, config)\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VALUE:\n            output = config[\"value\"]\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_CLASS:\n            output = self._get_class(config)\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_LIST:\n            output = config[\"value_list\"][index]\n\n        elif output_source == self.OUTPUT_SOURCE_SYSFS:\n            output = self._sysfs_read(index, config)\n\n        elif output_source == self.OUTPUT_SOURCE_FUNC:\n            func_conf = self._main_conf[config['function'][index]]\n            output = self.get_output(index, func_conf, default)\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\n            path = config.get('path')\n            output = self.read_txt_file(path)\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\n            path = config.get('path')\n            hex_ver = self.read_txt_file(path)\n            output = self._hex_ver_decode(\n                hex_ver, config['num_of_bits'], config['num_of_points'])\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\n            path = config.get('path')\n            addr = config.get('reg_addr')\n            hex_ver = self.get_reg(path, addr)\n            output = self._hex_ver_decode(\n                hex_ver, config['num_of_bits'], config['num_of_points'])\n\n        else:\n            output = default\n\n        return self._clean_output(index, output, config) or default\n\n    def set_output(self, index, input, config):\n        \"\"\"\n        Sets the output of specified function on config\n\n        Args:\n            config: A dict object containing the configuration of specified function.\n            index: An integer containing the index of device.\n            input: A string containing the input of specified function.\n\n        Returns:\n            bool: True if set function is successfully, False if not\n        \"\"\"\n        cleaned_input = self._clean_input(input, config)\n        if not cleaned_input:\n            return False\n\n        set_method = config.get('set_method')\n        if set_method == self.SET_METHOD_IPMI:\n            output = self._ipmi_set(index, config, cleaned_input)[0]\n        elif set_method == self.OUTPUT_SOURCE_SYSFS:\n            output = self._sysfs_write(index, config, cleaned_input)[0]\n        else:\n            output = False\n\n        return output\n\n    def get_event(self, timeout, config, sfp_list):\n        \"\"\"\n        Returns a nested dictionary containing all devices which have\n        experienced a change at chassis level\n\n        \"\"\"\n        event_class = self._get_class(config)\n        return event_class(sfp_list).get_event(timeout)\n"}, "/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py": {"changes": [{"diff": "\n import logging\n import subprocess\n \n-IPMI_SDR_CMD = \"ipmitool sdr elist\"\n+IPMI_SDR_CMD = [\"ipmitool\", \"sdr\", \"elist\"]\n MAX_NUM_FANS = 7\n MAX_NUM_PSUS = 2\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py", "badparts": ["IPMI_SDR_CMD = \"ipmitool sdr elist\""], "goodparts": ["IPMI_SDR_CMD = [\"ipmitool\", \"sdr\", \"elist\"]"]}, {"diff": "\n     '''\n     sensor_dump = ''\n     try:\n-        sensor_dump = subprocess.check_output(cmd, shell=True)\n+        sensor_dump = subprocess.check_output(cmd)\n     except subprocess.CalledProcessError as e:\n         logging.error('Error! Failed to execute: {}'.format(cmd))\n         sys.exit(1)\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py", "badparts": ["        sensor_dump = subprocess.check_output(cmd, shell=True)"], "goodparts": ["        sensor_dump = subprocess.check_output(cmd)"]}], "source": "\n import sys import logging import subprocess IPMI_SDR_CMD=\"ipmitool sdr elist\" MAX_NUM_FANS=7 MAX_NUM_PSUS=2 def ipmi_sensor_dump(cmd): ''' Execute ipmitool command return dump output exit if any error occur. ''' sensor_dump='' try: sensor_dump=subprocess.check_output(cmd, shell=True) except subprocess.CalledProcessError as e: logging.error('Error! Failed to execute:{}'.format(cmd)) sys.exit(1) return sensor_dump def get_reading_by_name(sensor_name, sdr_elist_dump): ''' Search for the match sensor name, return sensor reading value and unit, return object epmtry string if search not match. The output of sensor dump: TEMP_FAN_U52 | 00h | ok | 7.1 | 31 degrees C TEMP_FAN_U17 | 01h | ok | 7.1 | 27 degrees C TEMP_SW_U52 | 02h | ok | 7.1 | 30 degrees C Fan2_Status | 07h | ok | 29.2 | Present Fan2_Front | 0Eh | ok | 29.2 | 12000 RPM Fan2_Rear | 46h | ok | 29.2 | 14700 RPM PSU2_Status | 39h | ok | 10.2 | Presence detected PSU2_Fan | 3Dh | ok | 10.2 | 16000 RPM PSU2_VIn | 3Ah | ok | 10.2 | 234.30 Volts PSU2_CIn | 3Bh | ok | 10.2 | 0.80 Amps ''' found='' for line in sdr_elist_dump.split(\"\\n\"): if sensor_name in line: found=line.strip() break if not found: logging.error('Cannot find sensor name:' +sensor_name) else: try: found=found.split('|')[4] except IndexError: logging.error('Cannot get sensor data of:' +sensor_name) logging.basicConfig(level=logging.DEBUG) return found def read_temperature_sensors(ipmi_sdr_elist): sensor_list=[ ('TEMP_FAN_U52', 'Fan Tray Middle Temp'), ('TEMP_FAN_U17', 'Fan Tray Right Temp'), ('TEMP_SW_U52', 'Switchboard Left Inlet Temp'), ('TEMP_SW_U16', 'Switchboard Right Inlet Temp'), ('TEMP_BB_U3', 'Baseboard Temp'), ('TEMP_CPU', 'CPU Internal Temp'), ('TEMP_SW_Internal', 'ASIC Internal Temp'), ('SW_U04_Temp', 'IR3595 Chip Left Temp'), ('SW_U14_Temp', 'IR3595 Chip Right Temp'), ('SW_U4403_Temp', 'IR3584 Chip Temp'), ] output='' sensor_format='{0:{width}}{1}\\n' max_name_width=max(len(sensor[1]) for sensor in sensor_list) output +=\"Temperature Sensors\\n\" output +=\"Adapter: IPMI adapter\\n\" for sensor in sensor_list: reading=get_reading_by_name(sensor[0],ipmi_sdr_elist) output +=sensor_format.format('{}:'.format(sensor[1]), reading, width=str(max_name_width+1)) output +='\\n' return output def read_fan_sensors(num_fans, ipmi_sdr_elist): sensor_list=[ ('Fan{}_Status', 'Status'), ('Fan{}_Front', 'Fan{} front'), ('Fan{}_Rear', 'Fan{} rear'), ] output='' sensor_format='{0:{width}}{1}\\n' max_name_width=max(len(sensor[1]) for sensor in sensor_list) output +=\"Fan Trays\\n\" output +=\"Adapter: IPMI adapter\\n\" for fan_num in range(1, num_fans+1): for sensor in sensor_list: ipmi_sensor_name=sensor[0].format(fan_num) display_sensor_name=sensor[1].format(fan_num) reading=get_reading_by_name(ipmi_sensor_name, ipmi_sdr_elist) output +=sensor_format.format('{}:'.format(display_sensor_name), reading, width=str(max_name_width+1)) output +='\\n' return output def read_psu_sensors(num_psus, ipmi_sdr_elist): sensor_list=[ ('PSU{}_Status', 'PSU{} Status'), ('PSU{}_Fan', 'PSU{} Fan'), ('PSU{}_VIn', 'PSU{} Input Voltag'), ('PSU{}_CIn', 'PSU{} Input Current'), ('PSU{}_PIn', 'PSU{} Input Power'), ('PSU{}_Temp1', 'PSU{} Temp1'), ('PSU{}_Temp2', 'PSU{} Temp2'), ('PSU{}_VOut', 'PSU{} Output Voltag'), ('PSU{}_COut', 'PSU{} Output Current'), ('PSU{}_POut', 'PSU{} Output Power'), ] output='' sensor_format='{0:{width}}{1}\\n' max_name_width=max(len(sensor[1]) for sensor in sensor_list) output +=\"PSU\\n\" output +=\"Adapter: IPMI adapter\\n\" for psu_num in range(1, num_psus+1): for sensor in sensor_list: ipmi_sensor_name=sensor[0].format(psu_num) display_sensor_name=sensor[1].format(psu_num) reading=get_reading_by_name(ipmi_sensor_name, ipmi_sdr_elist) output +=sensor_format.format('{}:'.format(display_sensor_name), reading, width=str(max_name_width+1)) output +='\\n' return output def main(): output_string='' ipmi_sdr_elist=ipmi_sensor_dump(IPMI_SDR_CMD) output_string +=read_temperature_sensors(ipmi_sdr_elist) output_string +=read_psu_sensors(MAX_NUM_PSUS, ipmi_sdr_elist) output_string +=read_fan_sensors(MAX_NUM_FANS, ipmi_sdr_elist) print(output_string) if __name__=='__main__': main() ", "sourceWithComments": "#!/usr/bin/python\n#\n# Silverstone platform sensors. This script get the sensor data from BMC \n# using ipmitool and display them in lm-sensor alike format.\n#\n# The following data is support:\n#  1. Temperature sensors\n#  2. PSUs\n#  3. Fan trays\n\nimport sys\nimport logging\nimport subprocess\n\nIPMI_SDR_CMD = \"ipmitool sdr elist\"\nMAX_NUM_FANS = 7\nMAX_NUM_PSUS = 2\n\n\ndef ipmi_sensor_dump(cmd):\n    ''' Execute ipmitool command return dump output\n        exit if any error occur.\n    '''\n    sensor_dump = ''\n    try:\n        sensor_dump = subprocess.check_output(cmd, shell=True)\n    except subprocess.CalledProcessError as e:\n        logging.error('Error! Failed to execute: {}'.format(cmd))\n        sys.exit(1)\n    return sensor_dump\n\ndef get_reading_by_name(sensor_name, sdr_elist_dump):\n    '''\n        Search for the match sensor name, return sensor\n        reading value and unit, return object epmtry string \n        if search not match.\n\n        The output of sensor dump:\n        TEMP_FAN_U52     | 00h | ok  |  7.1 | 31 degrees C\n        TEMP_FAN_U17     | 01h | ok  |  7.1 | 27 degrees C\n        TEMP_SW_U52      | 02h | ok  |  7.1 | 30 degrees C\n        Fan2_Status      | 07h | ok  | 29.2 | Present\n        Fan2_Front       | 0Eh | ok  | 29.2 | 12000 RPM\n        Fan2_Rear        | 46h | ok  | 29.2 | 14700 RPM\n        PSU2_Status      | 39h | ok  | 10.2 | Presence detected\n        PSU2_Fan         | 3Dh | ok  | 10.2 | 16000 RPM\n        PSU2_VIn         | 3Ah | ok  | 10.2 | 234.30 Volts\n        PSU2_CIn         | 3Bh | ok  | 10.2 | 0.80 Amps\n    '''\n    found = ''\n\n    for line in sdr_elist_dump.split(\"\\n\"):\n        if sensor_name in line:\n            found = line.strip()\n            break\n\n    if not found:\n        logging.error('Cannot find sensor name:' + sensor_name)\n\n    else:\n        try:\n            found = found.split('|')[4]\n        except IndexError:\n            logging.error('Cannot get sensor data of:' + sensor_name)\n\n    logging.basicConfig(level=logging.DEBUG)\n    return found\n\n\ndef read_temperature_sensors(ipmi_sdr_elist):\n\n    sensor_list = [\n        ('TEMP_FAN_U52',        'Fan Tray Middle Temp'),\n        ('TEMP_FAN_U17',        'Fan Tray Right Temp'),\n        ('TEMP_SW_U52',         'Switchboard Left Inlet Temp'),\n        ('TEMP_SW_U16',         'Switchboard Right Inlet Temp'),\n        ('TEMP_BB_U3',          'Baseboard Temp'),\n        ('TEMP_CPU',            'CPU Internal Temp'),\n        ('TEMP_SW_Internal',    'ASIC Internal Temp'),\n        ('SW_U04_Temp',         'IR3595 Chip Left Temp'),\n        ('SW_U14_Temp',         'IR3595 Chip Right Temp'),\n        ('SW_U4403_Temp',       'IR3584 Chip Temp'),\n    ]\n\n    output = ''\n    sensor_format = '{0:{width}}{1}\\n'\n    # Find max length of sensor calling name\n    max_name_width = max(len(sensor[1]) for sensor in sensor_list)\n\n    output += \"Temperature Sensors\\n\"\n    output += \"Adapter: IPMI adapter\\n\"\n    for sensor in sensor_list:\n        reading = get_reading_by_name(sensor[0],ipmi_sdr_elist)\n        output += sensor_format.format('{}:'.format(sensor[1]),\n                                       reading,\n                                       width=str(max_name_width+1))\n    output += '\\n'\n    return output\n\n\ndef read_fan_sensors(num_fans, ipmi_sdr_elist):\n\n    sensor_list = [\n        ('Fan{}_Status',    'Status'),\n        ('Fan{}_Front',     'Fan {} front'),\n        ('Fan{}_Rear',      'Fan {} rear'),\n    ]\n\n    output = ''\n    sensor_format = '{0:{width}}{1}\\n'\n    # Find max length of sensor calling name\n    max_name_width = max(len(sensor[1]) for sensor in sensor_list)\n\n    output += \"Fan Trays\\n\"\n    output += \"Adapter: IPMI adapter\\n\"\n    for fan_num in range(1, num_fans+1):\n        for sensor in sensor_list:\n            ipmi_sensor_name = sensor[0].format(fan_num)\n            display_sensor_name = sensor[1].format(fan_num)\n            reading = get_reading_by_name(ipmi_sensor_name, ipmi_sdr_elist)\n            output += sensor_format.format('{}:'.format(display_sensor_name),\n                                           reading,\n                                           width=str(max_name_width+1))\n    output += '\\n'\n    return output\n\n\ndef read_psu_sensors(num_psus, ipmi_sdr_elist):\n\n    sensor_list = [\n        ('PSU{}_Status',    'PSU {} Status'),\n        ('PSU{}_Fan',       'PSU {} Fan'),\n        ('PSU{}_VIn',       'PSU {} Input Voltag'),\n        ('PSU{}_CIn',       'PSU {} Input Current'),\n        ('PSU{}_PIn',       'PSU {} Input Power'),\n        ('PSU{}_Temp1',     'PSU {} Temp1'),\n        ('PSU{}_Temp2',     'PSU {} Temp2'),\n        ('PSU{}_VOut',      'PSU {} Output Voltag'),\n        ('PSU{}_COut',      'PSU {} Output Current'),\n        ('PSU{}_POut',      'PSU {} Output Power'),\n    ]\n\n    output = ''\n    sensor_format = '{0:{width}}{1}\\n'\n    # Find max length of sensor calling name\n    max_name_width = max(len(sensor[1]) for sensor in sensor_list)\n\n    output += \"PSU\\n\"\n    output += \"Adapter: IPMI adapter\\n\"\n    for psu_num in range(1, num_psus+1):\n        for sensor in sensor_list:\n            ipmi_sensor_name = sensor[0].format(psu_num)\n            display_sensor_name = sensor[1].format(psu_num)\n            reading = get_reading_by_name(ipmi_sensor_name, ipmi_sdr_elist)\n            output += sensor_format.format('{}:'.format(display_sensor_name),\n                                           reading,\n                                           width=str(max_name_width+1))\n    output += '\\n'\n    return output\n\n\ndef main():\n    output_string = ''\n\n    ipmi_sdr_elist = ipmi_sensor_dump(IPMI_SDR_CMD)\n    output_string += read_temperature_sensors(ipmi_sdr_elist)\n    output_string += read_psu_sensors(MAX_NUM_PSUS, ipmi_sdr_elist)\n    output_string += read_fan_sensors(MAX_NUM_FANS, ipmi_sdr_elist)\n    print(output_string)\n\n\nif __name__ == '__main__':\n    main()\n"}}, "msg": "[device/celestica] Mitigation for command injection vulnerability (#11740)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\nDependency: [PR (#12065)](https://github.com/sonic-net/sonic-buildimage/pull/12065) needs to merge first.\r\n#### Why I did it\r\n1. `eval()` - not secure against maliciously constructed input, can be dangerous if used to evaluate dynamic content. This may be a code injection vulnerability.\r\n2. `subprocess()` - when using with `shell=True` is dangerous. Using subprocess function without a static string can lead to command injection.\r\n3. `os` - not secure against maliciously constructed input and dangerous if used to evaluate dynamic content.\r\n4. `is` operator - string comparison should not be used with reference equality.\r\n5. `globals()` - extremely dangerous because it may allow an attacker to execute arbitrary code on the system\r\n#### How I did it\r\n1. `eval()` - use `literal_eval()`\r\n2. `subprocess()` - use `shell=False` instead. use an array string. Ref: [https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation](https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation)\r\n3. `os` - use with `subprocess`\r\n4. `is` - replace by `==` operator for value equality\r\n5. `globals()` - avoid the use of globals()"}}, "https://github.com/mohsin75/sonic-buildimage": {"92d25be08f3866b4ae37f8eeba7ef53369851803": {"url": "https://api.github.com/repos/mohsin75/sonic-buildimage/commits/92d25be08f3866b4ae37f8eeba7ef53369851803", "html_url": "https://github.com/mohsin75/sonic-buildimage/commit/92d25be08f3866b4ae37f8eeba7ef53369851803", "sha": "92d25be08f3866b4ae37f8eeba7ef53369851803", "keyword": "command injection malicious", "diff": "diff --git a/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py b/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py\nindex bcb05b9cb8..9c994c572d 100755\n--- a/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py\n@@ -17,13 +17,11 @@\n \n try:\n     import os\n-    import commands\n-    import sys, getopt\n-    import logging\n     import re\n     import time\n     import syslog\n     from sonic_sfp.bcmshell import bcmshell\n+    from sonic_py_common.general import getstatusoutput_noshell\n     \n except ImportError as e:\n     raise ImportError(\"%s - required module not found\" % str(e))\n@@ -53,10 +51,10 @@ def initialLoop():\n             bcm_obj = BCMUtil()\n             bcm_obj.execute_command(\"echo\")\n             initialNotOK = False\n-            print bcm_obj\n+            print(bcm_obj)\n             log_message( syslog.LOG_INFO, \"BCMUtil Object initialed successfully\" )  \n-        except Exception, e:   \n-            print \"Exception. The warning is {0}\".format(str(e)) \n+        except Exception as e:   \n+            print(\"Exception. The warning is {0}\".format(str(e)))\n             time.sleep(10)\n             \n class BCMUtil(bcmshell):\n@@ -66,7 +64,7 @@ class BCMUtil(bcmshell):\n     \n     def get_platform(self):\n         if self.platform is None:\n-            self.platform = os.popen(\"uname -n\").read().strip()\n+            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"]).strip()\n         return self.platform\n         \n     def get_asic_temperature( self ):\n@@ -102,14 +100,18 @@ def main():\n                         content = readPtr.read().strip()\n                         if bcm_obj.get_platform() == INV_SEQUOIA_PLATFORM :\n                             if content == \"inv_bmc\" and SWITCH_TEMP_FILE_NAME in file_list :\n-                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n+                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)\n+                                with open(file, 'w') as f:\n+                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')\n                                 break\n                         else :\n                             if content == \"inv_psoc\" and SWITCH_TEMP_FILE_NAME in file_list :\n-                                print \"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME )\n-                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n+                                print(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME))\n+                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)\n+                                with open(file, 'w') as f:\n+                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')\n                                 break\n-        except Exception, e:\n+        except Exception as e:\n             log_message( syslog.LOG_WARNING, \"Exception. The warning is {0}\".format(str(e)) )\n             initialLoop()            \n         time.sleep(5)\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py b/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py\nindex bab0e2dafe..8f4564287d 100755\n--- a/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py\n@@ -20,6 +20,7 @@\n import syslog\n import re\n from sonic_sfp.bcmshell import bcmshell\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n # =====================================================================\n@@ -120,8 +121,8 @@ def _board_init():\n     global SYNC_S\n     global SYNC_P\n \n-    cmd = \"uname -n\"\n-    platform = os.popen(cmd).read()\n+    cmd = [\"uname\", \"-n\"]\n+    _, platform = getstatusoutput_noshell(cmd)\n \n     if platform.rstrip() == INV_MAGNOLIA:\n         BOARD_TPYE      = \"inventec_d6254qs\"\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py b/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py\nindex f1e7f7fece..d73687e025 100755\n--- a/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py\n@@ -2,6 +2,7 @@\n \n import os\n import socket\n+import subprocess\n from collections import OrderedDict\n \n # Purpose:  Shutdown DUT upon receiving thermaltrip event from kernel (inv_pthread)\n@@ -59,6 +60,6 @@ def next_events(self):\n \n             # Receive thermaltrip event\n             if event['ACTION'] == 'remove' and event['DEVPATH'] == '/kernel/platform_status/fan':\n-                os.system(\"shutdown -h now\")\n+                subprocess.call([\"shutdown\", \"-h\", \"now\"])\n                 \n \ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py b/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py\nindex 9e4a44c167..453c33deea 100755\n--- a/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py\n@@ -28,6 +28,7 @@\n     import syslog\n     from sfputil import SfpUtil\n     from sonic_sfp.bcmshell import bcmshell\n+    from sonic_py_common.general import getstatusoutput_noshell\n     \n except ImportError as e:\n     raise ImportError(\"%s - required module not found\" % str(e))\n@@ -127,7 +128,7 @@ class BCMUtil(bcmshell):\n     \n     def get_platform(self):\n         if self.platform is None:\n-            self.platform = os.popen(\"uname -n\").read().strip()\n+            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"])\n         return self.platform\n     \n     def get_port_to_bcm_mapping(self):  \ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py b/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py\nindex b1f8799ab5..f71a19d00e 100644\n--- a/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py\n@@ -8,6 +8,7 @@\n try:\n     import os\n     import logging\n+    import subprocess\n     from ctypes import create_string_buffer\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8436 import sff8436Dom\n@@ -120,7 +121,7 @@ def __set_attr_value(self, attr_path, value):\n         return True\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/device'\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py b/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py\nindex a468a323d6..d467fd8fb5 100755\n--- a/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py\n@@ -33,6 +33,7 @@\n import logging\n import syslog\n import time\n+from sonic_py_common.general import getstatusoutput_noshell_pipe\n \n DEBUG = False\n args = []\n@@ -236,8 +237,9 @@ def system_install(boot_option):\n \t      return status\n     for addr_offset in range (0,FAN_NUM):\n         addr=FAN_VPD_ADDR_BASE+addr_offset\n-        cmd = \"i2cdetect -y \"+str(FAN_VPD_CHANNEL)+\" \"+str(addr)+\" \"+str(addr)+\" | grep \"+str(hex(addr)).replace('0x','')\n-        result=os.system(cmd)\n+        cmd1 = [\"i2cdetect\", \"-y\", str(FAN_VPD_CHANNEL), str(addr), str(addr)]\n+        cmd2 = [\"grep\", f'{addr:x}']\n+        result, _ = getstatusoutput_noshell_pipe(cmd1, cmd2)\n         if( result==0 ):\n             cmd=\"echo inv_eeprom \"+str(addr)+\" > /sys/bus/i2c/devices/i2c-\"+FAN_VPD_CHANNEL\n             status, output = exec_cmd(cmd,1)\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py b/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py\nindex fccde46df4..22eae317f8 100644\n--- a/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py\n@@ -9,6 +9,7 @@\n     import os\n     import sys\n     import time\n+    import subprocess\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8436 import sff8436Dom\n     from sonic_platform_base.sonic_sfp.sff8436 import sff8436InterfaceId\n@@ -108,7 +109,7 @@ def __get_attr_value(self, attr_path):\n         return retval\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/device'\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py b/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py\nindex 5c75a8749a..de8d50b7ab 100644\n--- a/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py\n@@ -7,7 +7,7 @@\n \n try:\n     import os\n-    import sys\n+    import subprocess\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472InterfaceId\n@@ -95,7 +95,7 @@ def __get_attr_value(self, attr_path):\n         return retval\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/device'\ndiff --git a/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py b/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py\nindex 9d6337195d..ee5768a640 100644\n--- a/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py\n+++ b/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py\n@@ -153,7 +153,7 @@ class Sfp(SfpBase):\n     # Path to QSFP sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-inventec_d7054q28b-r0\"\n     HWSKU  = \"INVENTEC-D7054Q28B-S48-Q6\"\n@@ -285,7 +285,7 @@ def __read_txt_file(self, file_path):\n         return \"\"\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n", "message": "", "files": {"/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py": {"changes": [{"diff": "\n \n try:\n     import os\n-    import commands\n-    import sys, getopt\n-    import logging\n     import re\n     import time\n     import syslog\n     from sonic_sfp.bcmshell import bcmshell\n+    from sonic_py_common.general import getstatusoutput_noshell\n     \n except ImportError as e:\n     raise ImportError(\"%s - required module not found\" % str(e))\n", "add": 1, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py", "badparts": ["    import commands", "    import sys, getopt", "    import logging"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n             bcm_obj = BCMUtil()\n             bcm_obj.execute_command(\"echo\")\n             initialNotOK = False\n-            print bcm_obj\n+            print(bcm_obj)\n             log_message( syslog.LOG_INFO, \"BCMUtil Object initialed successfully\" )  \n-        except Exception, e:   \n-            print \"Exception. The warning is {0}\".format(str(e)) \n+        except Exception as e:   \n+            print(\"Exception. The warning is {0}\".format(str(e)))\n             time.sleep(10)\n             \n class BCMUtil(bcmshell):\n", "add": 3, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py", "badparts": ["            print bcm_obj", "        except Exception, e:   ", "            print \"Exception. The warning is {0}\".format(str(e)) "], "goodparts": ["            print(bcm_obj)", "        except Exception as e:   ", "            print(\"Exception. The warning is {0}\".format(str(e)))"]}, {"diff": "\n     \n     def get_platform(self):\n         if self.platform is None:\n-            self.platform = os.popen(\"uname -n\").read().strip()\n+            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"]).strip()\n         return self.platform\n         \n     def get_asic_temperature( self ):\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py", "badparts": ["            self.platform = os.popen(\"uname -n\").read().strip()"], "goodparts": ["            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"]).strip()"]}, {"diff": "\n                         content = readPtr.read().strip()\n                         if bcm_obj.get_platform() == INV_SEQUOIA_PLATFORM :\n                             if content == \"inv_bmc\" and SWITCH_TEMP_FILE_NAME in file_list :\n-                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n+                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)\n+                                with open(file, 'w') as f:\n+                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')\n                                 break\n                         else :\n                             if content == \"inv_psoc\" and SWITCH_TEMP_FILE_NAME in file_list :\n-                                print \"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME )\n-                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n+                                print(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME))\n+                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)\n+                                with open(file, 'w') as f:\n+                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')\n                                 break\n-        except Exception, e:\n+        except Exception as e:\n             log_message( syslog.LOG_WARNING, \"Exception. The warning is {0}\".format(str(e)) )\n             initialLoop()            \n         time.sleep(5)", "add": 8, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/asic_monitor.py", "badparts": ["                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))", "                                print \"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME )", "                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))", "        except Exception, e:"], "goodparts": ["                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)", "                                with open(file, 'w') as f:", "                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')", "                                print(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME))", "                                file = \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)", "                                with open(file, 'w') as f:", "                                    f.write(str(bcm_obj.get_asic_temperature() * 1000) + '\\n')", "        except Exception as e:"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object Auto detecting the Chipset temperature and update options: -h | --help : this help message -d | --debug : run with debug mode \"\"\" try: import os import commands import sys, getopt import logging import re import time import syslog from sonic_sfp.bcmshell import bcmshell except ImportError as e: raise ImportError(\"%s -required module not found\" % str(e)) args=[] INV_REDWOOD_PLATFORM=\"SONiC-Inventec-d7032-100\" INV_CYPRESS_PLATFORM=\"SONiC-Inventec-d7054\" INV_SEQUOIA_PLATFORM=\"SONiC-Inventec-d7264\" INV_MAPLE_PLATFORM=\"SONiC-Inventec-d6556\" INV_MAGNOLIA_PLATFORM=\"SONiC-Inventec-d6254qs\" PSOC_NAME=\"name\" HWMON_PATH=\"/sys/class/hwmon/\" SWITCH_TEMP_FILE_NAME=\"switch_tmp\" def log_message( level, string): syslog.openlog(\"asic_monitor\", syslog.LOG_PID, facility=syslog.LOG_DAEMON) syslog.syslog( level, string) def initialLoop(): global bcm_obj initialNotOK=True while initialNotOK: try: bcm_obj=BCMUtil() bcm_obj.execute_command(\"echo\") initialNotOK=False print bcm_obj log_message( syslog.LOG_INFO, \"BCMUtil Object initialed successfully\") except Exception, e: print \"Exception. The warning is{0}\".format(str(e)) time.sleep(10) class BCMUtil(bcmshell): asic_temperature=0 platform=None def get_platform(self): if self.platform is None: self.platform=os.popen(\"uname -n\").read().strip() return self.platform def get_asic_temperature( self): return self.asic_temperature def set_asic_temperature( self, temp): self.asic_temperature=temp def parsing_asic_temp(self): content=self.run(\"show temp\") for line in content.split(\"\\n\"): TempObject=re.search(r\"(average current temperature is)\\s+(?P<temperature_high>\\d+)\\.(?P<temperature_low>\\d+)\",line) if TempObject is not None: self.set_asic_temperature( int( TempObject.group(\"temperature_high\"))) def execute_command(self, cmd): return self.run(cmd) def main(): global bcm_obj initialLoop() log_message( syslog.LOG_INFO, \"Object initialed successfully\") while 1: try: bcm_obj.parsing_asic_temp() for index in os.listdir(HWMON_PATH): file_list=os.listdir(\"{0}/{1}/device/\".format(HWMON_PATH,index)) if PSOC_NAME in file_list: with open( \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, PSOC_NAME), 'rb') as readPtr: content=readPtr.read().strip() if bcm_obj.get_platform()==INV_SEQUOIA_PLATFORM: if content==\"inv_bmc\" and SWITCH_TEMP_FILE_NAME in file_list: os.system(\"echo{0} >{1}/{2}/device/{3}\".format(( bcm_obj.get_asic_temperature() * 1000), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)) break else: if content==\"inv_psoc\" and SWITCH_TEMP_FILE_NAME in file_list: print \"echo{0} >{1}/{2}/device/{3}\".format(( bcm_obj.get_asic_temperature() * 1000), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME) os.system(\"echo{0} >{1}/{2}/device/{3}\".format(( bcm_obj.get_asic_temperature() * 1000), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME)) break except Exception, e: log_message( syslog.LOG_WARNING, \"Exception. The warning is{0}\".format(str(e))) initialLoop() time.sleep(5) syslog.closelog() del bcm_obj if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2018 Inventec, Inc.\n# \n# Editor: James Huang ( Huang.James@inventec.com )\n#  \n\"\"\"\nUsage: %(scriptName)s [options] command object\n\nAuto detecting the Chipset temperature and update\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n   \n\"\"\"\n\ntry:\n    import os\n    import commands\n    import sys, getopt\n    import logging\n    import re\n    import time\n    import syslog\n    from sonic_sfp.bcmshell import bcmshell\n    \nexcept ImportError as e:\n    raise ImportError(\"%s - required module not found\" % str(e))\n\nargs = []\nINV_REDWOOD_PLATFORM = \"SONiC-Inventec-d7032-100\"\nINV_CYPRESS_PLATFORM = \"SONiC-Inventec-d7054\"\nINV_SEQUOIA_PLATFORM = \"SONiC-Inventec-d7264\"\nINV_MAPLE_PLATFORM = \"SONiC-Inventec-d6556\"\nINV_MAGNOLIA_PLATFORM = \"SONiC-Inventec-d6254qs\"\n\nPSOC_NAME = \"name\"\nHWMON_PATH = \"/sys/class/hwmon/\"\nSWITCH_TEMP_FILE_NAME = \"switch_tmp\"\n\ndef log_message( level, string ):\n    syslog.openlog(\"asic_monitor\", syslog.LOG_PID, facility=syslog.LOG_DAEMON)\n    syslog.syslog( level, string )\n\ndef initialLoop():\n\n    global bcm_obj\n    initialNotOK = True\n    \n    while initialNotOK :        \n        try:                \n            bcm_obj = BCMUtil()\n            bcm_obj.execute_command(\"echo\")\n            initialNotOK = False\n            print bcm_obj\n            log_message( syslog.LOG_INFO, \"BCMUtil Object initialed successfully\" )  \n        except Exception, e:   \n            print \"Exception. The warning is {0}\".format(str(e)) \n            time.sleep(10)\n            \nclass BCMUtil(bcmshell):\n\n    asic_temperature = 0\n    platform = None\n    \n    def get_platform(self):\n        if self.platform is None:\n            self.platform = os.popen(\"uname -n\").read().strip()\n        return self.platform\n        \n    def get_asic_temperature( self ):\n        return self.asic_temperature\n        \n    def set_asic_temperature( self, temp ):\n        self.asic_temperature = temp\n                \n    def parsing_asic_temp(self):\n        content = self.run(\"show temp\")\n        for line in content.split(\"\\n\"):\n            TempObject = re.search(r\"(average current temperature is)\\s+(?P<temperature_high>\\d+)\\.(?P<temperature_low>\\d+)\",line)\n            if TempObject is not None:\n                self.set_asic_temperature( int( TempObject.group(\"temperature_high\") ) )\n        \n    def execute_command(self, cmd):\n        return self.run(cmd)\n     \n        \ndef main():\n\n    global bcm_obj\n    initialLoop()\n    log_message( syslog.LOG_INFO, \"Object initialed successfully\" )\n\n    while 1 :\n        try:\n            bcm_obj.parsing_asic_temp()\n            for index in os.listdir(HWMON_PATH):\n                file_list = os.listdir(\"{0}/{1}/device/\".format(HWMON_PATH,index))\n                if PSOC_NAME in file_list :\n                    with open( \"{0}/{1}/device/{2}\".format(HWMON_PATH, index, PSOC_NAME), 'rb') as readPtr:\n                        content = readPtr.read().strip()\n                        if bcm_obj.get_platform() == INV_SEQUOIA_PLATFORM :\n                            if content == \"inv_bmc\" and SWITCH_TEMP_FILE_NAME in file_list :\n                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n                                break\n                        else :\n                            if content == \"inv_psoc\" and SWITCH_TEMP_FILE_NAME in file_list :\n                                print \"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME )\n                                os.system(\"echo {0} > {1}/{2}/device/{3}\".format( ( bcm_obj.get_asic_temperature() * 1000 ), HWMON_PATH, index, SWITCH_TEMP_FILE_NAME ))\n                                break\n        except Exception, e:\n            log_message( syslog.LOG_WARNING, \"Exception. The warning is {0}\".format(str(e)) )\n            initialLoop()            \n        time.sleep(5)\n\n    syslog.closelog()\n    del bcm_obj\n\nif __name__ == \"__main__\":\n    main()\n\n\n\n\n\n"}, "/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py": {"changes": [{"diff": "\n     global SYNC_S\n     global SYNC_P\n \n-    cmd = \"uname -n\"\n-    platform = os.popen(cmd).read()\n+    cmd = [\"uname\", \"-n\"]\n+    _, platform = getstatusoutput_noshell(cmd)\n \n     if platform.rstrip() == INV_MAGNOLIA:\n         BOARD_TPYE      = \"inventec_d6254qs", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/led_proc.py", "badparts": ["    cmd = \"uname -n\"", "    platform = os.popen(cmd).read()"], "goodparts": ["    cmd = [\"uname\", \"-n\"]", "    _, platform = getstatusoutput_noshell(cmd)"]}], "source": "\n import os import time import syslog import re from sonic_sfp.bcmshell import bcmshell PORT_LIST =[] BCM_SHELL =None SHELL_READY=False STATUS_RX =1<<0 STATUS_TX =1<<1 PORT_DATA_OFFSET_ADDR =0xA0 INV_MAGNOLIA =\"SONiC-Inventec-d6254qs\" INV_REDWOOD =\"SONiC-Inventec-d7032-100\" INV_CYPRESS =\"SONiC-Inventec-d7054\" INV_MAPLE =\"SONiC-Inventec-d6556\" INV_SEQUOIA =\"\" BOARD_TPYE =\"\" EAGLE_CORE =[] BIT_LINK =None BIT_FAULT =None BIT_TX =None BIT_RX =None BIT_SPEED0 =None BIT_SPEED1 =None SPEED_100G =100 SPEED_40G =40 SPEED_25G =25 SPEED_10G =10 class Port(): port_num =None name =None bcm_id =None led_up =None s_addr =None write2_up =None led_index =None link_status =None speed =None def write_data_ram(self, data): BCM_SHELL.cmd(\"setreg CMIC_LEDUP{0}_DATA_RAM({1}){2}\".format(self.write2_up, self.led_index, data)) def read_data_ram(self): r_string=BCM_SHELL.run(\"getreg CMIC_LEDUP{0}_DATA_RAM({1})\".format(self.led_up, self.s_addr)) for line in r_string.split(\"\\n\"): re_obj=re.search(r\"\\<DATA\\=(?P<data>.+)\\>\", line) if re_obj is not None: return int(re_obj.group(\"data\"), 16) def _remap_registers(fp): content=fp.readlines() fp.close() err=False for line in content: try: BCM_SHELL.cmd(line.rstrip()) except Exception, e: err=True syslog.syslog(syslog.LOG_ERR, \"remap register abnormal:{0}\".format(str(e))) if not err: syslog.syslog(syslog.LOG_INFO, \"remap Led registers successfully\") def _board_init(): global BOARD_TPYE global BIT_LINK global BIT_FAULT global BIT_TX global BIT_RX global BIT_SPEED0 global BIT_SPEED1 global EAGLE_CORE global TOTAL_SCAN_BITS global SYNC_S global SYNC_P cmd=\"uname -n\" platform=os.popen(cmd).read() if platform.rstrip()==INV_MAGNOLIA: BOARD_TPYE =\"inventec_d6254qs\" BIT_RX =1<<0 BIT_TX =1<<1 BIT_SPEED1 =1<<4 BIT_LINK =1<<7 fp=open('/usr/share/sonic/device/x86_64-inventec_d6254qs-r0/led_proc_init.soc', \"r\") _remap_registers(fp) elif platform.rstrip()==INV_REDWOOD: BOARD_TPYE =\"inventec_d7032q28b\" BIT_RX =1<<0 BIT_TX =1<<1 BIT_SPEED0 =1<<3 BIT_SPEED1 =1<<4 BIT_FAULT =1<<6 BIT_LINK =1<<7 EAGLE_CORE =[66, 100] fp=open('/usr/share/sonic/device/x86_64-inventec_d7032q28b-r0/led_proc_init.soc', \"r\") _remap_registers(fp) elif platform.rstrip()==INV_CYPRESS: BOARD_TPYE =\"inventec_d7054q28b\" BIT_LINK =1<<0 BIT_FAULT =1<<1 BIT_SPEED0 =1<<2 EAGLE_CORE =[66, 100] elif platform.rstrip()==INV_SEQUOIA: BOARD_TPYE=\"inventec_d7264q28b\" elif platform.rstrip()==INV_MAPLE: BOARD_TPYE=\"inventec_d6556\" fp=open('/usr/share/sonic/device/x86_64-inventec_d6556-r0/led_proc_init.soc', \"r\") _remap_registers(fp) syslog.syslog(syslog.LOG_INFO, \"Found device:{0}\".format(BOARD_TPYE)) exit(0) else: BOARD_TPYE=\"not found\" syslog.syslog(syslog.LOG_ERR, \"Found device:{0}\".format(BOARD_TPYE)) exit(0) syslog.syslog(syslog.LOG_INFO, \"Found device:{0}\".format(BOARD_TPYE)) def _lookup_led_index(p): index=0 if BOARD_TPYE==\"inventec_d6254qs\": if 0 <=p.port_num <=47: index=p.port_num +(p.port_num / 4) p.write2_up=0 elif 48 <=p.port_num <=71: index=p.port_num -48 p.write2_up=1 if p.led_up==0: p.s_addr=p.port_num * 2 elif p.led_up==1: p.s_addr=(p.port_num -36) * 2 elif BOARD_TPYE==\"inventec_d7032q28b\": p.write2_up=0 index=p.port_num if 0 <=p.port_num <=7: p.s_addr=p.port_num * 8 elif 8 <=p.port_num <=23: p.s_addr=(p.port_num -8) * 8 elif 24 <=p.port_num <=31: p.s_addr=(p.port_num -16) * 8 else: p.write2_up=p.led_up for port in PORT_LIST: if p.bcm_id==port.bcm_id: break if p.led_up==port.led_up: index +=1 return PORT_DATA_OFFSET_ADDR +index def _update_port_list(only_update): global PORT_LIST number =0 count =0 content=BCM_SHELL.run(\"ps\") for line in content.split(\"\\n\"): re_obj=re.search(r\"(?P<port_name>(xe|ce)\\d+)\\(\\s*(?P<bcm_id>\\d+)\\)\\s+(?P<link>(up|down|!ena)).+\\s+(?P<speed>\\d+)G\", line) if re_obj is not None: if int(re_obj.group(\"bcm_id\")) not in EAGLE_CORE: if only_update: PORT_LIST[number].link_status=re_obj.group(\"link\") else: port_obj=Port() port_obj.port_num=number port_obj.name=re_obj.group(\"port_name\") port_obj.bcm_id=int(re_obj.group(\"bcm_id\")) port_obj.link_status=re_obj.group(\"link\") port_obj.speed=int(re_obj.group(\"speed\")) PORT_LIST.append(port_obj) number +=1 if not only_update: content=BCM_SHELL.run(\"led status\") for line in content.split(\"\\n\"): re_obj=re.search(r\"(?P<bcm_id>\\d+).+(?P<led_up>\\d)\\:\", line) if re_obj is not None: if int(re_obj.group(\"bcm_id\")) not in EAGLE_CORE: PORT_LIST[count].led_up=int(re_obj.group(\"led_up\")) PORT_LIST[count].led_index=_lookup_led_index(PORT_LIST[count]) count +=1 if number is not count: PORT_LIST=[] syslog.syslog(syslog.LOG_ERR, \"The amount of port is not match\") def sync_bcmsh_socket(): global BCM_SHELL global SHELL_READY waitSyncd =True retryCount =0 while waitSyncd: time.sleep(10) try: BCM_SHELL=bcmshell() BCM_SHELL.run(\"Echo\") waitSyncd=False except Exception, e: print \"{0}, Retry times({1})\".format(str(e),retryCount) retryCount +=1 syslog.syslog(syslog.LOG_INFO, \"bcmshell socket create successfully\") if SHELL_READY is False: SHELL_READY=True return elif SHELL_READY is True: update_led_status() def update_led_status(): led_thread =True reset_sec =2 count_down =0 queue_active =[] port_data =None s_byte =None while led_thread: try: if count_down==0: queue_active=[] _update_port_list(1) for port in PORT_LIST: if port.link_status==\"up\": queue_active.append(port) else: port_data=0 port.write_data_ram(port_data) count_down=reset_sec else: for port in queue_active: port_data=0 if BOARD_TPYE==\"inventec_d6254qs\": s_byte=port.read_data_ram() if s_byte&STATUS_RX: port_data |=BIT_RX if s_byte&STATUS_TX: port_data |=BIT_TX port_data |=BIT_LINK elif BOARD_TPYE==\"inventec_d7032q28b\": s_byte=port.read_data_ram() if s_byte&STATUS_RX: port_data |=BIT_RX if s_byte&STATUS_TX: port_data |=BIT_TX if port.speed==SPEED_100G: port_data |=BIT_SPEED0 port_data |=BIT_SPEED1 elif port.speed==SPEED_40G: port_data |=BIT_SPEED1 elif port.speed==SPEED_25G: port_data |=BIT_SPEED0 else: pass port_data |=BIT_LINK elif BOARD_TPYE==\"inventec_d7054q28b\": if port.speed !=SPEED_100G and port.speed !=SPEED_25G: port_data |=BIT_SPEED0 port.write_data_ram(port_data) time.sleep(0.5) count_down -=1 except Exception, e: syslog.syslog(syslog.LOG_WARNING, \"{0}\".format(str(e))) sync_bcmsh_socket() def debug_print(): for port in PORT_LIST: output=\"\" output +=\"name:{0} | \".format(port.name) output +=\"port_num:{0} | \".format(port.port_num) output +=\"bcm_id:{0} | \".format(port.bcm_id) output +=\"link_status:{0} | \".format(port.link_status) output +=\"speed:{0} | \".format(port.speed) output +=\"led_up:{0} | \".format(port.led_up) output +=\"s_addr:{0} | \".format(port.s_addr) output +=\"write2_up:{0} | \".format(port.write2_up) output +=\"led_index:{0} | \".format(port.led_index) print output if __name__==\"__main__\": syslog.openlog(\"led_proc\", syslog.LOG_PID, facility=syslog.LOG_DAEMON) sync_bcmsh_socket() _board_init() _update_port_list(0) update_led_status() syslog.closelog() ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2018 Inventec, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport time\nimport syslog\nimport re\nfrom sonic_sfp.bcmshell import bcmshell\n\n\n# =====================================================================\n#  global variable init\n# =====================================================================\n# port object\nPORT_LIST               = []\n# object is to execute bcm shell command\nBCM_SHELL   = None\nSHELL_READY = False\n# port status that is auto update by chip in data ram\nSTATUS_RX               = 1<<0\nSTATUS_TX               = 1<<1\n# define data ram address\nPORT_DATA_OFFSET_ADDR   = 0xA0\n# define board type\nINV_MAGNOLIA            = \"SONiC-Inventec-d6254qs\"\nINV_REDWOOD             = \"SONiC-Inventec-d7032-100\"\nINV_CYPRESS             = \"SONiC-Inventec-d7054\"\nINV_MAPLE               = \"SONiC-Inventec-d6556\"\nINV_SEQUOIA             = \"\"\nBOARD_TPYE              = \"\"\nEAGLE_CORE              = []\n# define port data for bit streaming\nBIT_LINK                = None\nBIT_FAULT               = None\nBIT_TX                  = None\nBIT_RX                  = None\nBIT_SPEED0              = None\nBIT_SPEED1              = None\n# define port speed\nSPEED_100G              = 100\nSPEED_40G               = 40\nSPEED_25G               = 25\nSPEED_10G               = 10\n\n\n# =====================================================================\n#  class object\n# =====================================================================\nclass Port():\n\n    port_num        = None\n    name            = None\n    bcm_id          = None\n    led_up          = None\n    s_addr          = None\n    write2_up       = None\n    led_index       = None\n    link_status     = None\n    speed           = None\n\n    def write_data_ram(self, data):\n        BCM_SHELL.cmd(\"setreg CMIC_LEDUP{0}_DATA_RAM({1}) {2}\".format(self.write2_up, self.led_index, data))\n\n    def read_data_ram(self):\n        r_string = BCM_SHELL.run(\"getreg CMIC_LEDUP{0}_DATA_RAM({1})\".format(self.led_up, self.s_addr))\n        for line in r_string.split(\"\\n\"):\n            re_obj = re.search(r\"\\<DATA\\=(?P<data>.+)\\>\", line)\n            if re_obj is not None:\n                #syslog.syslog(syslog.LOG_DEBUG, \"Read Led({0}) data_ram({1}): {2}\".format(self.up, addr, re_obj.group(\"data\")))\n                return int(re_obj.group(\"data\"), 16)\n\n\n\n# =====================================================================\n#  Function\n# =====================================================================\ndef _remap_registers(fp):\n\n    content = fp.readlines()\n    fp.close()\n    err = False\n\n    for line in content:\n        try:\n            BCM_SHELL.cmd(line.rstrip())\n        except Exception, e:\n            err = True\n            syslog.syslog(syslog.LOG_ERR, \"remap register abnormal: {0}\".format(str(e)))\n\n    if not err:\n        syslog.syslog(syslog.LOG_INFO, \"remap Led registers successfully\")\n\n\n\ndef _board_init():\n\n    global BOARD_TPYE\n    global BIT_LINK\n    global BIT_FAULT\n    global BIT_TX\n    global BIT_RX\n    global BIT_SPEED0\n    global BIT_SPEED1\n    global EAGLE_CORE\n    global TOTAL_SCAN_BITS\n    global SYNC_S\n    global SYNC_P\n\n    cmd = \"uname -n\"\n    platform = os.popen(cmd).read()\n\n    if platform.rstrip() == INV_MAGNOLIA:\n        BOARD_TPYE      = \"inventec_d6254qs\"\n        BIT_RX          = 1<<0  #0x01\n        BIT_TX          = 1<<1  #0x02\n        BIT_SPEED1      = 1<<4  #0x10\n        BIT_LINK        = 1<<7  #0x80\n        fp = open('/usr/share/sonic/device/x86_64-inventec_d6254qs-r0/led_proc_init.soc', \"r\")\n        _remap_registers(fp)\n\n    elif platform.rstrip() == INV_REDWOOD:\n        BOARD_TPYE      = \"inventec_d7032q28b\"\n        BIT_RX          = 1<<0  #0x01\n        BIT_TX          = 1<<1  #0x02\n        BIT_SPEED0      = 1<<3  #0x08\n        BIT_SPEED1      = 1<<4  #0x10\n        BIT_FAULT       = 1<<6  #0x40\n        BIT_LINK        = 1<<7  #0x80\n        EAGLE_CORE      = [66, 100]\n        fp = open('/usr/share/sonic/device/x86_64-inventec_d7032q28b-r0/led_proc_init.soc', \"r\")\n        _remap_registers(fp)\n\n    elif platform.rstrip() == INV_CYPRESS:\n        BOARD_TPYE      = \"inventec_d7054q28b\"\n        BIT_LINK        = 1<<0  #0x01\n        BIT_FAULT       = 1<<1  #0x02\n        BIT_SPEED0      = 1<<2  #0x04\n        EAGLE_CORE      = [66, 100]\n\n    elif platform.rstrip() == INV_SEQUOIA:\n        BOARD_TPYE = \"inventec_d7264q28b\"\n\n    elif platform.rstrip() == INV_MAPLE:\n        BOARD_TPYE = \"inventec_d6556\"\n        fp = open('/usr/share/sonic/device/x86_64-inventec_d6556-r0/led_proc_init.soc', \"r\")\n        _remap_registers(fp)\n        #led process: m0 led process that is controlled by linkscan_led_fw.bin and custom_led.bin\n        syslog.syslog(syslog.LOG_INFO, \"Found device: {0}\".format(BOARD_TPYE))\n        exit(0)\n\n    else:\n        BOARD_TPYE = \"not found\"\n        syslog.syslog(syslog.LOG_ERR, \"Found device: {0}\".format(BOARD_TPYE))\n        exit(0)\n\n    syslog.syslog(syslog.LOG_INFO, \"Found device: {0}\".format(BOARD_TPYE))\n\n\n\ndef _lookup_led_index(p):\n\n    index = 0\n    if BOARD_TPYE == \"inventec_d6254qs\":\n        if 0 <= p.port_num <= 47:\n            index = p.port_num + (p.port_num / 4)\n            p.write2_up = 0\n        elif 48 <= p.port_num <= 71:\n            index = p.port_num - 48\n            p.write2_up = 1\n        if p.led_up == 0:\n            p.s_addr = p.port_num * 2\n        elif p.led_up == 1:\n            p.s_addr = (p.port_num - 36) * 2\n\n    elif BOARD_TPYE == \"inventec_d7032q28b\":\n        p.write2_up = 0\n        index = p.port_num\n        if 0 <= p.port_num <= 7:\n            p.s_addr = p.port_num * 8\n        elif 8 <= p.port_num <= 23:\n            p.s_addr = (p.port_num - 8) * 8\n        elif 24 <= p.port_num <= 31:\n            p.s_addr = (p.port_num - 16) * 8\n\n    else:\n        p.write2_up = p.led_up\n        for port in PORT_LIST:\n            if p.bcm_id == port.bcm_id:\n                break\n            if p.led_up == port.led_up:\n                index += 1\n\n    return PORT_DATA_OFFSET_ADDR + index\n\n\ndef _update_port_list(only_update):\n\n    global PORT_LIST\n    number      = 0\n    count       = 0\n\n    content = BCM_SHELL.run(\"ps\")\n    for line in content.split(\"\\n\"):\n        re_obj = re.search(r\"(?P<port_name>(xe|ce)\\d+)\\(\\s*(?P<bcm_id>\\d+)\\)\\s+(?P<link>(up|down|!ena)).+\\s+(?P<speed>\\d+)G\", line)\n        if re_obj is not None:\n            if int(re_obj.group(\"bcm_id\")) not in EAGLE_CORE:\n                if only_update:\n                    PORT_LIST[number].link_status = re_obj.group(\"link\")\n                else:\n                    # create port object while first time\n                    port_obj = Port()\n                    port_obj.port_num = number\n                    port_obj.name = re_obj.group(\"port_name\")\n                    port_obj.bcm_id = int(re_obj.group(\"bcm_id\"))\n                    port_obj.link_status = re_obj.group(\"link\")\n                    port_obj.speed = int(re_obj.group(\"speed\"))\n                    PORT_LIST.append(port_obj)\n                number += 1\n\n    if not only_update:\n        content = BCM_SHELL.run(\"led status\")\n        for line in content.split(\"\\n\"):\n            re_obj = re.search(r\"(?P<bcm_id>\\d+).+(?P<led_up>\\d)\\:\", line)\n            if re_obj is not None:\n                if int(re_obj.group(\"bcm_id\")) not in EAGLE_CORE:\n                    PORT_LIST[count].led_up = int(re_obj.group(\"led_up\"))\n                    PORT_LIST[count].led_index = _lookup_led_index(PORT_LIST[count])\n                    count += 1\n\n        if number is not count:\n            PORT_LIST = []\n            syslog.syslog(syslog.LOG_ERR, \"The amount of port is not match\")\n\n\n\ndef sync_bcmsh_socket():\n\n    global BCM_SHELL\n    global SHELL_READY\n    waitSyncd   = True\n    retryCount  = 0\n\n    while waitSyncd:\n        time.sleep(10)\n        try:\n            BCM_SHELL = bcmshell()\n            BCM_SHELL.run(\"Echo\")\n            waitSyncd = False\n        except Exception, e:\n            print \"{0}, Retry times({1})\".format(str(e),retryCount)\n            #syslog.syslog(syslog.LOG_DEBUG, \"{0}, Retry times({1})\".format(str(e),retryCount))\n            retryCount += 1\n\n    syslog.syslog(syslog.LOG_INFO, \"bcmshell socket create successfully\")\n\n    if SHELL_READY is False:\n        SHELL_READY = True\n        return\n    elif SHELL_READY is True:\n        update_led_status()\n\n\n\ndef update_led_status():\n\n    led_thread      = True  # True/False (gate to turn on/off)\n    reset_sec       = 2\n    count_down      = 0\n    queue_active    = []\n    port_data       = None\n    s_byte          = None\n\n\n    # thread for keeping update port status in data ram\n    while led_thread:\n        try:\n            if count_down == 0:\n                queue_active = []\n                _update_port_list(1)\n                for port in PORT_LIST:\n                    if port.link_status == \"up\":\n                        queue_active.append(port)\n                    else:\n                        port_data = 0\n                        port.write_data_ram(port_data)\n                count_down = reset_sec\n            else:\n                for port in queue_active:\n                    port_data = 0\n\n                    if BOARD_TPYE == \"inventec_d6254qs\":\n                        s_byte = port.read_data_ram()\n                        if s_byte&STATUS_RX:\n                            port_data |= BIT_RX\n                        if s_byte&STATUS_TX:\n                            port_data |= BIT_TX\n                        port_data |= BIT_LINK\n\n                    elif BOARD_TPYE == \"inventec_d7032q28b\":\n                        s_byte = port.read_data_ram()\n                        if s_byte&STATUS_RX:\n                            port_data |= BIT_RX\n                        if s_byte&STATUS_TX:\n                            port_data |= BIT_TX\n                        if port.speed == SPEED_100G:\n                            port_data |= BIT_SPEED0\n                            port_data |= BIT_SPEED1\n                        elif port.speed == SPEED_40G:\n                            port_data |= BIT_SPEED1\n                        elif port.speed == SPEED_25G:\n                            port_data |= BIT_SPEED0\n                        else:\n                            pass\n                        port_data |= BIT_LINK\n\n                    elif BOARD_TPYE == \"inventec_d7054q28b\":\n                        if port.speed != SPEED_100G and port.speed != SPEED_25G:\n                            port_data |= BIT_SPEED0\n\n                    # write data to update data ram for specific port\n                    port.write_data_ram(port_data)\n\n                time.sleep(0.5)\n                count_down -= 1\n\n        except Exception, e:\n            syslog.syslog(syslog.LOG_WARNING, \"{0}\".format(str(e)))\n            sync_bcmsh_socket()\n\n\n\ndef debug_print():\n\n    for port in PORT_LIST:\n        output = \"\"\n        output += \"name:{0} | \".format(port.name)\n        output += \"port_num:{0} | \".format(port.port_num)\n        output += \"bcm_id:{0} | \".format(port.bcm_id)\n        output += \"link_status:{0} | \".format(port.link_status)\n        output += \"speed:{0} | \".format(port.speed)\n        output += \"led_up:{0} | \".format(port.led_up)\n        output += \"s_addr:{0} | \".format(port.s_addr)\n        output += \"write2_up:{0} | \".format(port.write2_up)\n        output += \"led_index:{0} | \".format(port.led_index)\n        print output\n\n\nif __name__ == \"__main__\":\n\n    syslog.openlog(\"led_proc\", syslog.LOG_PID, facility=syslog.LOG_DAEMON)\n\n    sync_bcmsh_socket()\n    _board_init()\n    _update_port_list(0)\n    #debug_print()\n    update_led_status()\n\n    syslog.closelog()\n"}, "/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py": {"changes": [{"diff": "\n \n             # Receive thermaltrip event\n             if event['ACTION'] == 'remove' and event['DEVPATH'] == '/kernel/platform_status/fan':\n-                os.system(\"shutdown -h now\")\n+                subprocess.call([\"shutdown\", \"-h\", \"now\"])\n                 ", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/platform_status.py", "badparts": ["                os.system(\"shutdown -h now\")"], "goodparts": ["                subprocess.call([\"shutdown\", \"-h\", \"now\"])"]}], "source": "\n import os import socket from collections import OrderedDict NETLINK_KOBJECT_UEVENT=15 class KernelEventMonitor(object): def __init__(self): self.received_events=OrderedDict() self.socket=socket.socket(socket.AF_NETLINK, socket.SOCK_DGRAM, NETLINK_KOBJECT_UEVENT) def start(self): self.socket.bind((os.getpid(), -1)) def stop(self): self.socket.close() def __enter__(self): self.start() return self def __exit__(self, exc_type, exc_value, traceback): self.stop() def __iter__(self): while True: for item in monitor.next_events(): yield item def next_events(self): data=self.socket.recv(16384) event={} for item in data.split(b'\\x00'): if not item: if event and event['SEQNUM'] not in self.received_events: self.received_events[event['SEQNUM']]=None if(len(self.received_events) > 100): self.received_events.popitem(last=False) yield event event={} else: try: k, v=item.split(b'=', 1) event[k.decode('ascii')]=v.decode('ascii') except ValueError: pass if __name__=='__main__': with KernelEventMonitor() as monitor: for event in monitor: if event['SUBSYSTEM']=='platform_status': print('subsystem is platform_status') if event['ACTION']=='remove' and event['DEVPATH']=='/kernel/platform_status/fan': os.system(\"shutdown -h now\") ", "sourceWithComments": "#!/usr/bin/env python\n\nimport os\nimport socket\nfrom collections import OrderedDict\n\n# Purpose:  Shutdown DUT upon receiving thermaltrip event from kernel (inv_pthread)\n\nNETLINK_KOBJECT_UEVENT = 15\n\nclass KernelEventMonitor(object):\n\n    def __init__(self):\n        self.received_events = OrderedDict()\n        self.socket = socket.socket(socket.AF_NETLINK, socket.SOCK_DGRAM, NETLINK_KOBJECT_UEVENT)\n\n    def start(self):\n        self.socket.bind((os.getpid(), -1))\n\n    def stop(self):\n        self.socket.close()\n\n    def __enter__(self):\n        self.start()\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.stop()\n\n    def __iter__(self):\n        while True:\n          for item in monitor.next_events():\n              yield item\n\n    def next_events(self):\n        data = self.socket.recv(16384)\n        event = {}\n        for item in data.split(b'\\x00'):\n            if not item:        \n                #check if we have an event and if we already received it\n                if event and event['SEQNUM'] not in self.received_events:\n                    self.received_events[event['SEQNUM']] = None\n                    if (len(self.received_events) > 100):\n                        self.received_events.popitem(last=False)\n                    yield event\n                event = {}\n            else:\n                try:\n                    k, v = item.split(b'=', 1)\n                    event[k.decode('ascii')] = v.decode('ascii')\n                except ValueError:\n                    pass\n\nif __name__ == '__main__':\n    with KernelEventMonitor() as monitor:\n        for event in monitor:\n            if event['SUBSYSTEM'] == 'platform_status':\n                print('subsystem is platform_status')\n\n            # Receive thermaltrip event\n            if event['ACTION'] == 'remove' and event['DEVPATH'] == '/kernel/platform_status/fan':\n                os.system(\"shutdown -h now\")\n                \n\n"}, "/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py": {"changes": [{"diff": "\n     \n     def get_platform(self):\n         if self.platform is None:\n-            self.platform = os.popen(\"uname -n\").read().strip()\n+            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"])\n         return self.platform\n     \n     def get_port_to_bcm_mapping(self)", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/common/utils/transceiver_monitor.py", "badparts": ["            self.platform = os.popen(\"uname -n\").read().strip()"], "goodparts": ["            _, self.platform = getstatusoutput_noshell([\"uname\", \"-n\"])"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object Auto detecting the transceiver and set the correct if_type value options: -h | --help : this help message -d | --debug : run with debug mode \"\"\" try: import os import commands import sys, getopt import logging import re import time import datetime import syslog from sfputil import SfpUtil from sonic_sfp.bcmshell import bcmshell except ImportError as e: raise ImportError(\"%s -required module not found\" % str(e)) DEBUG=False args=[] INV_REDWOOD_PLATFORM=\"SONiC-Inventec-d7032-100\" INV_CYPRESS_PLATFORM=\"SONiC-Inventec-d7054\" INV_SEQUOIA_PLATFORM=\"SONiC-Inventec-d7264\" INV_MAPLE_PLATFORM=\"SONiC-Inventec-d6556\" INV_MAGNOLIA_PLATFORM=\"SONiC-Inventec-d6254qs\" transceiver_type_dict={ \"FCBG110SD1C03\": \"SR\", \"FCBG110SD1C05\": \"SR\", \"FTLX8571D3BCL\": \"SR\", \"FTLX8574D3BCL\": \"SR\", \"AFBR-709DMZ\": \"SR\", \"AFBR-709SMZ\": \"SR\", \"FTLX8571D3BCV\": \"SR\", \"FTLX1471D3BCL\": \"SR\", \"FTLX1871M3BCL\": \"SR\", \"FTLF8536P4BCL\": \"SR\", \"FCBG125SD1C05\": \"SR\", \"FCBG125SD1C30\": \"SR\", \"FCBG125SD1C03\": \"SR\", \"FCBG410QB1C03-1E\": \"SR4\", \"FCBG4100QB1C030-1E\": \"SR4\", \"885350163\": \"SR4\", \"88535017\": \"SR4\", \"FTL410QE2C\": \"SR4\", \"FTL410QD3C\": \"SR4\", \"FTL410QD2C\": \"SR4\", \"AFBR-79E3PZ\": \"SR4\", \"AFBR-79Q4Z\": \"SR4\", \"FTL4C1QE1C\": \"SR4\", \"FTLC9551REPM\": \"SR4\", \"FTLC1151RDPL\": \"SR4\", \"DAC-010SS-X50\": \"KR\", \"DAC-010QQ-X50\": \"KR4\", \"DAC-040QS-007\": \"KR4\", \"DAC-040QQ-007\": \"KR4\", \"DAC-040QQ-005\": \"KR4\", \"DAC-040QS-005\": \"KR4\", \"NDAAFF-0001\": \"KR4\", \"L0HQF001-SD-R\": \"KR4\", \"DAC-Q28/Q28-28-01\": \"KR4\", \"NDAAFF-0003\": \"KR4\", \"NDAQGF0001\": \"KR4\", \"L0HQF003-SD-R\": \"KR4\", \"NDAQGJ-0003\": \"KR4\", \"L0HQF004-SD-R\": \"KR4\", \"L0HSF006-SD-R\": \"KR\", \"L0HSF007-SD-R\": \"KR\", \"L0HSF008-SD-R\": \"KR\", \"L0HQF009-SD-R\": \"KR4\", \"FSPP-H7-M85-X3D\": \"SR\", \"PT0-M3-4D33K-C2\": \"SR\", \"RTXM228-551\": \"SR\", \"RTXM330-003\": \"SR\", \"RTXM330-030\": \"SR\", \"MFA2P10-A005\": \"SR\", \"QAB-OA03MC\": \"SR4\", \"QAB-OA05MC\": \"SR4\", \"RTXM320-571\": \"SR4\", \"AFBR-89CDDZ\": \"SR4\", \"RTXM420-550\": \"SR4\", \"MMA1B00-C100D\": \"SR4\", \"RTXM420-551\": \"SR4\", \"E04025QTXA000\": \"SR4\", \"LQ210PR-Oxxx\": \"SR4\", \"TR-FC13L-N00\": \"SR4\", \"SPQ-CE-LR-CDFL\": \"SR4\", \"FIM37700/170\": \"SR4\", \"FCBN425QE1C03\": \"SR4\", \"TQS-Q14H8-XCAXX\": \"SR4\", \"FPD-203R008-10/3\": \"SR4\", \"LTA8531-PC+\": \"SR4\" } initial_command=[] def show_help(): print __doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]} sys.exit(0) def log_message( string): syslog.openlog(\"transceiver_monitor\", syslog.LOG_PID, facility=syslog.LOG_DAEMON) syslog.syslog(syslog.LOG_NOTICE, string) class BCMUtil(bcmshell): port_to_bcm_mapping=dict() sal_config_list=dict() eagle_list=[] platform=None def get_platform(self): if self.platform is None: self.platform=os.popen(\"uname -n\").read().strip() return self.platform def get_port_to_bcm_mapping(self): if self.port_to_bcm_mapping is None: return dict() else: return self.port_to_bcm_mapping def show_port_to_bcm_mapping(self): for key,value in self.port_to_bcm_mapping.iteritems(): print \"{0}---{1}\".format(key, value) def get_eagle_port(self): return self.eagle_list def parsing_eagle_port(self): name=self.get_platform() if name is not None: if name==INV_REDWOOD_PLATFORM: self.eagle_list=[66,100] elif name==INV_CYPRESS_PLATFORM: self.eagle_list=[66,100] elif name==INV_SEQUOIA_PLATFORM: self.eagle_list=[66,100] elif name==INV_MAPLE_PLATFORM: self.eagle_list=[66,130] else: self.eagle_list=[] def get_sal_config_list(self): return self.sal_config_list def show_sal_config_list(self): for key,value in self.sal_config_list.iteritems(): print \"{0}---{1}\".format(key, value) def initial_sal_config_list( self): content=self.run(\"config\") for line in content.split(\"\\n\"): ConfigObject=re.search(r\"portmap\\_(?P<bcm_id>\\d+)\\=(?P<lane_id>\\d+)\\:\\d+\",line) if ConfigObject is not None: if int(ConfigObject.group(\"bcm_id\")) not in self.get_eagle_port(): self.get_sal_config_list()[int(ConfigObject.group(\"bcm_id\"))]={\"lane\": int(ConfigObject.group(\"lane_id\")), \"speed\": None, \"portname\": None} def parsing_port_list(self): content=self.run(\"ps\") count=0 for line in content.split(\"\\n\"): PSObject=re.search(r\"(?P<port_name>(xe|ce)\\d+)\\(\\s*(?P<bcm_id>\\d+)\\).+\\s+(?P<speed>\\d+)G\",line) if PSObject is not None: if int(PSObject.group(\"bcm_id\")) not in self.get_eagle_port(): if self.get_sal_config_list().has_key(int(PSObject.group(\"bcm_id\"))): self.get_sal_config_list()[int(PSObject.group(\"bcm_id\"))][\"portname\"]=PSObject.group(\"port_name\") self.get_sal_config_list()[int(PSObject.group(\"bcm_id\"))][\"speed\"]=int(PSObject.group(\"speed\"))*1000 self.port_to_bcm_mapping[count]=int(PSObject.group(\"bcm_id\")) count=count +1 def execute_command(self, cmd): self.cmd(cmd) class TransceiverUtil(SfpUtil): transceiver_port_mapping=dict() def get_transceiver_port_mapping(self): return self.transceiver_port_mapping def show_transceiver_port_mapping(self): for key,value in self.transceiver_port_mapping.iteritems(): print \"{0}---{1}\".format(key, value) def get_bcm_port_name(self, index): if self.transceiver_port_mapping.has_key(index) and bcm_obj.get_sal_config_list().has_key(self.transceiver_port_mapping[index][\"bcm\"]): return bcm_obj.get_sal_config_list()[self.transceiver_port_mapping[index][\"bcm\"]][\"portname\"] else: return \"\" def get_port_to_i2c_mapping(self): if self.port_to_i2c_mapping is None: return dict() else: return self.port_to_i2c_mapping def show_port_to_i2c_mapping(self): for key,value in self.port_to_i2c_mapping.iteritems(): print \"{0}---{1}\".format(key, value) def get_eeprom_partNum(self, portNum): tempdict=dict() tempdict=self.get_eeprom_dict(portNum) self.get_eeprom_partNum_from_parser_eeprom_dict(tempdict) def get_eeprom_dict_info(self, portNum): return self.get_eeprom_dict(portNum) def get_eeprom_partNum_from_parser_eeprom_dict(self, tempdict): if tempdict is not None: if tempdict[\"interface\"][\"data\"].has_key(\"VendorPN\"): return tempdict[\"interface\"][\"data\"][\"VendorPN\"] elif tempdict[\"interface\"][\"data\"].has_key(\"Vendor PN\"): return tempdict[\"interface\"][\"data\"][\"Vendor PN\"] else: return None else: return None def get_transceiver_type(self, pn): if pn is not None: if transceiver_type_dict.has_key(pn.upper()): return transceiver_type_dict[pn.upper()] else: return None def set_transceiver_type( self, portNum, pn): type=self.get_transceiver_type( pn) if type is not None: if bcm_obj.get_platform()==INV_SEQUOIA_PLATFORM or bcm_obj.get_platform()==INV_MAPLE_PLATFORM: speed=bcm_obj.get_sal_config_list()[self.transceiver_port_mapping[portNum][\"bcm\"]][\"speed\"] bcm_obj.execute_command( \"port %s if=%s speed=%d\" %( self.get_bcm_port_name(portNum), type, speed)) else: bcm_obj.execute_command( \"port %s if=%s\" %( self.get_bcm_port_name(portNum), type)) print \"Detecting port{0}({1}) need to change interface type{2}({3})\".format( self.get_bcm_port_name(portNum), portNum, type, self.get_transceiver_port_mapping()[portNum][\"pn\"]) log_message(\"Detecting port{0} need to change interface type{1}({2})\".format(self.get_bcm_port_name(portNum), type, self.get_transceiver_port_mapping()[portNum][\"pn\"])) def initial_transceiver_port_mapping(self): for index in self.get_port_to_i2c_mapping().keys(): if self.transceiver_port_mapping.has_key(index) is False: i2cValue=self.get_port_to_i2c_mapping()[index] bcmValue=bcm_obj.get_port_to_bcm_mapping()[index] self.transceiver_port_mapping[index]={\"i2c\": i2cValue, \"bcm\": bcmValue, \"pn\": None} def set_power_mode_for_QSFP(self): for index in self.get_port_to_i2c_mapping().keys(): if index >=self.qsfp_port_start and index <=self.qsfp_port_end: self.set_low_power_mode(index, False) else: self.set_tx_disable(index) def set_tx_disable(self, port_num): if port_num >=self.qsfp_port_start and port_num <=self.qsfp_port_end: pass else: try: tx_file=open(\"/sys/class/swps/port\"+str(port_num)+\"/tx_disable\", \"r+\") except IOError as e: print \"Error: unable to open file: %s\" % str(e) return False reg_value=int(tx_file.readline().rstrip()) if reg_value==1: reg_value=0 tx_file.write(hex(reg_value)) tx_file.close() def main(): global DEBUG global transceiver_obj global bcm_obj initalNotOK=True retestCount=0 while initalNotOK: try: transceiver_obj=TransceiverUtil() bcm_obj=BCMUtil() initalNotOK=False except Exception, e: log_message(\"Exception. The warning is{0}, Retry again({1})\".format(str(e),retestCount)) retestCount=retestCount +1 time.sleep(5) log_message( \"Object initialed successfully\") options, args=getopt.getopt(sys.argv[1:], 'hd',['help', 'debug' ]) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) else: logging.info(\"no option\") initalNotOK=True while initalNotOK: try: for cmd_index in initial_command: bcm_obj.execute_command(cmd_index) bcm_obj.parsing_eagle_port() bcm_obj.initial_sal_config_list() bcm_obj.parsing_port_list() transceiver_obj.initial_transceiver_port_mapping() initalNotOK=False except Exception, e: log_message(\"Exception. The warning is{0}\".format(str(e))) time.sleep(5) transceiver_obj.set_power_mode_for_QSFP() while 1: try: if bcm_obj.get_platform()==INV_SEQUOIA_PLATFORM: bcm_obj.parsing_port_list() for index in transceiver_obj.get_port_to_i2c_mapping().keys(): info=transceiver_obj.get_eeprom_dict_info(index) value=transceiver_obj.get_eeprom_partNum_from_parser_eeprom_dict(info) if transceiver_obj.get_transceiver_port_mapping().has_key(index) is not False and transceiver_obj.get_transceiver_port_mapping()[index][\"pn\"] <> value: transceiver_obj.get_transceiver_port_mapping()[index][\"pn\"]=value transceiver_obj.set_transceiver_type(index,value) transceiver_obj.set_tx_disable(index) except Exception, e: log_message(\"Exception. The warning is{0}\".format(str(e))) time.sleep(1) syslog.closelog() del transceiver_obj del bcm_obj if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2018 Inventec, Inc.\n# \n# Editor: James Huang ( Huang.James@inventec.com )\n#  \n# \n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\nAuto detecting the transceiver and set the correct if_type value\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n   \n\"\"\"\n\ntry:\n    import os\n    import commands\n    import sys, getopt\n    import logging\n    import re\n    import time\n    import datetime\n    import syslog\n    from sfputil import SfpUtil\n    from sonic_sfp.bcmshell import bcmshell\n    \nexcept ImportError as e:\n    raise ImportError(\"%s - required module not found\" % str(e))\n\nDEBUG = False\nargs = []\nINV_REDWOOD_PLATFORM = \"SONiC-Inventec-d7032-100\"\nINV_CYPRESS_PLATFORM = \"SONiC-Inventec-d7054\"\nINV_SEQUOIA_PLATFORM = \"SONiC-Inventec-d7264\"\nINV_MAPLE_PLATFORM = \"SONiC-Inventec-d6556\"\nINV_MAGNOLIA_PLATFORM = \"SONiC-Inventec-d6254qs\"\n\ntransceiver_type_dict = { \n                          \"FCBG110SD1C03\": \"SR\",\n                          \"FCBG110SD1C05\": \"SR\",\n                          \"FTLX8571D3BCL\": \"SR\",\n                          \"FTLX8574D3BCL\": \"SR\",\n                          \"AFBR-709DMZ\": \"SR\",\n                          \"AFBR-709SMZ\": \"SR\",\n                          \"FTLX8571D3BCV\": \"SR\",\n                          \"FTLX1471D3BCL\": \"SR\",\n                          \"FTLX1871M3BCL\": \"SR\",\n                          \"FTLF8536P4BCL\": \"SR\",\n                          \"FCBG125SD1C05\": \"SR\",\n                          \"FCBG125SD1C30\": \"SR\",\n                          \"FCBG125SD1C03\": \"SR\",\n                          \"FCBG410QB1C03-1E\": \"SR4\",\n                          \"FCBG4100QB1C030-1E\": \"SR4\",\n                          \"885350163\": \"SR4\",\n                          \"88535017\": \"SR4\",\n                          \"FTL410QE2C\": \"SR4\",\n                          \"FTL410QD3C\": \"SR4\",\n                          \"FTL410QD2C\": \"SR4\",\n                          \"AFBR-79E3PZ\": \"SR4\",\n                          \"AFBR-79Q4Z\": \"SR4\",\n                          \"FTL4C1QE1C\": \"SR4\",\n                          \"FTLC9551REPM\": \"SR4\",\n                          \"FTLC1151RDPL\": \"SR4\",\n                          \"DAC-010SS-X50\" : \"KR\",\n                          \"DAC-010QQ-X50\": \"KR4\",\n                          \"DAC-040QS-007\": \"KR4\",\n                          \"DAC-040QQ-007\": \"KR4\",\n                          \"DAC-040QQ-005\": \"KR4\",\n                          \"DAC-040QS-005\": \"KR4\",\n                          \"NDAAFF-0001\": \"KR4\",\n                          \"L0HQF001-SD-R\": \"KR4\",\n                          \"DAC-Q28/Q28-28-01\": \"KR4\",\n                          \"NDAAFF-0003\": \"KR4\",\n                          \"NDAQGF0001\": \"KR4\",\n                          \"L0HQF003-SD-R\": \"KR4\",\n                          \"NDAQGJ-0003\": \"KR4\",\n                          \"L0HQF004-SD-R\": \"KR4\",\n                          \"L0HSF006-SD-R\": \"KR\",\n                          \"L0HSF007-SD-R\": \"KR\",\n                          \"L0HSF008-SD-R\": \"KR\",\n                          \"L0HQF009-SD-R\": \"KR4\",\n                          \"FSPP-H7-M85-X3D\": \"SR\",   \n                          \"PT0-M3-4D33K-C2\": \"SR\",\n                          \"RTXM228-551\": \"SR\",\n                          \"RTXM330-003\": \"SR\",\n                          \"RTXM330-030\": \"SR\",   \n                          \"MFA2P10-A005\": \"SR\",\n                          \"QAB-OA03MC\": \"SR4\",\n                          \"QAB-OA05MC\": \"SR4\",\n                          \"RTXM320-571\": \"SR4\",\n                          \"AFBR-89CDDZ\": \"SR4\",\n                          \"RTXM420-550\": \"SR4\",\n                          \"MMA1B00-C100D\": \"SR4\",\n                          \"RTXM420-551\": \"SR4\",\n                          \"E04025QTXA000\": \"SR4\",\n                          \"LQ210PR-Oxxx\": \"SR4\",\n                          \"TR-FC13L-N00\": \"SR4\",  \n                          \"SPQ-CE-LR-CDFL\": \"SR4\",\n                          \"FIM37700/170\": \"SR4\",\n                          \"FCBN425QE1C03\": \"SR4\",\n                          \"TQS-Q14H8-XCAXX\": \"SR4\",\n                          \"FPD-203R008-10/3\": \"SR4\",\n                          \"LTA8531-PC+\": \"SR4\"                       \n                        }\n \ninitial_command = []\n\ndef show_help():\n    print __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]}\n    sys.exit(0)\n\ndef log_message( string ):\n    syslog.openlog(\"transceiver_monitor\", syslog.LOG_PID, facility=syslog.LOG_DAEMON)\n    syslog.syslog(syslog.LOG_NOTICE, string)\n\nclass BCMUtil(bcmshell):\n\n    port_to_bcm_mapping = dict()         \n    sal_config_list = dict()\n    eagle_list = []\n    platform = None\n    \n    def get_platform(self):\n        if self.platform is None:\n            self.platform = os.popen(\"uname -n\").read().strip()\n        return self.platform\n    \n    def get_port_to_bcm_mapping(self):  \n        if self.port_to_bcm_mapping is None:\n            return dict()\n        else:\n            return self.port_to_bcm_mapping     \n    \n    def show_port_to_bcm_mapping(self): \n        for key,value in self.port_to_bcm_mapping.iteritems():\n            print \"{0}---{1}\".format(key, value)    \n    \n    def get_eagle_port(self):\n        return self.eagle_list\n        \n    def parsing_eagle_port(self):\n        name = self.get_platform()\n        if name is not None:\n            if name == INV_REDWOOD_PLATFORM:\n                self.eagle_list = [66,100]\n            elif name == INV_CYPRESS_PLATFORM:\n                self.eagle_list = [66,100]\n            elif name == INV_SEQUOIA_PLATFORM:\n                self.eagle_list = [66,100]\n            elif name == INV_MAPLE_PLATFORM:\n                self.eagle_list = [66,130]\n            else:\n                self.eagle_list = []\n                \n    def get_sal_config_list(self):\n        return self.sal_config_list\n\n    def show_sal_config_list(self):\n        for key,value in self.sal_config_list.iteritems():\n            print \"{0}---{1}\".format(key, value)\n        \n    def initial_sal_config_list( self ):\n        content = self.run(\"config\")  \n        for line in content.split(\"\\n\"):\n            ConfigObject = re.search(r\"portmap\\_(?P<bcm_id>\\d+)\\=(?P<lane_id>\\d+)\\:\\d+\",line)\n            if ConfigObject is not None:   \n                if int(ConfigObject.group(\"bcm_id\")) not in self.get_eagle_port():\n                    self.get_sal_config_list()[int(ConfigObject.group(\"bcm_id\"))]={\"lane\": int(ConfigObject.group(\"lane_id\")), \"speed\": None, \"portname\": None} \n                \n    def parsing_port_list(self):\n        content = self.run(\"ps\")\n        count = 0\n        for line in content.split(\"\\n\"):\n            PSObject = re.search(r\"(?P<port_name>(xe|ce)\\d+)\\(\\s*(?P<bcm_id>\\d+)\\).+\\s+(?P<speed>\\d+)G\",line)\n            if PSObject is not None:\n                if int(PSObject.group(\"bcm_id\")) not in self.get_eagle_port():                    \n                    if self.get_sal_config_list().has_key(int(PSObject.group(\"bcm_id\"))):\n                        self.get_sal_config_list()[int(PSObject.group(\"bcm_id\"))][\"portname\"] = PSObject.group(\"port_name\")\n                        self.get_sal_config_list()[int(PSObject.group(\"bcm_id\"))][\"speed\"] = int(PSObject.group(\"speed\"))*1000\n                        self.port_to_bcm_mapping[count] = int(PSObject.group(\"bcm_id\"))\n                        count = count +1\n                \n    \n    def execute_command(self, cmd):\n        self.cmd(cmd)\n\nclass TransceiverUtil(SfpUtil):     \n    \n    transceiver_port_mapping = dict()\n    \n    def get_transceiver_port_mapping(self):\n        return self.transceiver_port_mapping\n        \n    def show_transceiver_port_mapping(self):\n        for key,value in self.transceiver_port_mapping.iteritems():\n            print \"{0}---{1}\".format(key, value)     \n       \n    def get_bcm_port_name(self, index):\n        if self.transceiver_port_mapping.has_key(index) and bcm_obj.get_sal_config_list().has_key(self.transceiver_port_mapping[index][\"bcm\"]):\n            return bcm_obj.get_sal_config_list()[self.transceiver_port_mapping[index][\"bcm\"]][\"portname\"]            \n        else:\n            return \"\"\n                \n    def get_port_to_i2c_mapping(self):\n        if self.port_to_i2c_mapping is None:\n            return dict()\n        else:\n            return self.port_to_i2c_mapping\n    \n    def show_port_to_i2c_mapping(self):\n        for key,value in self.port_to_i2c_mapping.iteritems():\n            print \"{0}---{1}\".format(key, value)\n        \n    def get_eeprom_partNum(self, portNum):\n        tempdict = dict()\n        tempdict = self.get_eeprom_dict(portNum)\n        self.get_eeprom_partNum_from_parser_eeprom_dict(tempdict)\n    \n    def get_eeprom_dict_info(self, portNum): \n        return self.get_eeprom_dict(portNum) \n                \n    def get_eeprom_partNum_from_parser_eeprom_dict(self, tempdict ):\n        if tempdict is not None:\n            if tempdict[\"interface\"][\"data\"].has_key(\"VendorPN\"):\n               return tempdict[\"interface\"][\"data\"][\"VendorPN\"]\n            elif tempdict[\"interface\"][\"data\"].has_key(\"Vendor PN\"):\n                return tempdict[\"interface\"][\"data\"][\"Vendor PN\"]\n            else:\n                return None\n        else:\n            return None\n            \n    def get_transceiver_type(self, pn ):\n        if pn is not None:\n            if transceiver_type_dict.has_key(pn.upper()):\n                return transceiver_type_dict[pn.upper()]\n            else:\n                return None    \n\n    def set_transceiver_type( self, portNum, pn ):\n        type = self.get_transceiver_type( pn )\n        if type is not None:             \n            if bcm_obj.get_platform() == INV_SEQUOIA_PLATFORM or bcm_obj.get_platform() == INV_MAPLE_PLATFORM :\n                speed = bcm_obj.get_sal_config_list()[self.transceiver_port_mapping[portNum][\"bcm\"]][\"speed\"]\n                bcm_obj.execute_command( \"port %s if=%s speed=%d\" % ( self.get_bcm_port_name(portNum), type, speed ) )\n            else:\n                bcm_obj.execute_command( \"port %s if=%s\" % ( self.get_bcm_port_name(portNum), type ) )\n            print \"Detecting port {0}({1})  need to change interface type {2} ({3})\".format( self.get_bcm_port_name(portNum), portNum, type, self.get_transceiver_port_mapping()[portNum][\"pn\"])\n            log_message(\"Detecting port {0} need to change interface type {1} ({2})\".format(self.get_bcm_port_name(portNum), type, self.get_transceiver_port_mapping()[portNum][\"pn\"]) )\n    \n    def initial_transceiver_port_mapping(self):\n        for index in self.get_port_to_i2c_mapping().keys():\n            if self.transceiver_port_mapping.has_key(index) is False :\n                i2cValue = self.get_port_to_i2c_mapping()[index]\n                bcmValue = bcm_obj.get_port_to_bcm_mapping()[index]\n                self.transceiver_port_mapping[index]={\"i2c\": i2cValue, \"bcm\": bcmValue , \"pn\": None}\n            \n    def set_power_mode_for_QSFP(self):\n        for index in self.get_port_to_i2c_mapping().keys():\n            if index >= self.qsfp_port_start and index <= self.qsfp_port_end :\n                self.set_low_power_mode(index, False)\n            else:\n                # To set tx_disable\n                self.set_tx_disable(index)\n\n    def set_tx_disable(self, port_num):\n        if port_num >= self.qsfp_port_start and port_num <= self.qsfp_port_end :\n            pass\n        else:\n            try:\n                tx_file = open(\"/sys/class/swps/port\"+str(port_num)+\"/tx_disable\", \"r+\")\n            except IOError as e:\n                print \"Error: unable to open file: %s\" % str(e)\n                return False\n\n            reg_value = int(tx_file.readline().rstrip())\n\n            # always set 0 to tx_disable field\n            if reg_value == 1 :\n                reg_value = 0        \n                tx_file.write(hex(reg_value))\n                tx_file.close()\n\n        \ndef main():\n\n    global DEBUG  \n    global transceiver_obj\n    global bcm_obj\n    \n    initalNotOK = True\n    retestCount = 0 \n    while initalNotOK :\n        try:                \n            transceiver_obj = TransceiverUtil()\n            bcm_obj = BCMUtil()\n            initalNotOK = False\n        except Exception, e:               \n            log_message(\"Exception. The warning is {0}, Retry again ({1})\".format(str(e),retestCount) )                    \n            retestCount = retestCount + 1\n        time.sleep(5)\n     \n    log_message( \"Object initialed successfully\" )  \n    options, args = getopt.getopt(sys.argv[1:], 'hd', ['help',\n                                                       'debug'\n                                                          ])\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):            \n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        else:\n            logging.info(\"no option\")\n    \n    initalNotOK = True\n    while initalNotOK :\n        try :\n            # Before loop, You could execute specific command to initial chip\n            for cmd_index in initial_command :\n                bcm_obj.execute_command(cmd_index)\n            \n            # Initial the sal config list\n            bcm_obj.parsing_eagle_port()\n            bcm_obj.initial_sal_config_list()\n            # bcm_obj.show_sal_config_list()\n            bcm_obj.parsing_port_list()                 \n            #bcm_obj.show_port_to_bcm_mapping()                 \n            #bcm_obj.show_sal_config_list()\n            # transceiver_obj.show_port_to_i2c_mapping()\n            \n            # Initial the transceiver_obj \n            transceiver_obj.initial_transceiver_port_mapping()       \n            # transceiver_obj.show_transceiver_port_mapping()\n             \n            initalNotOK = False\n        except Exception, e:               \n            log_message(\"Exception. The warning is {0}\".format(str(e)) )\n        time.sleep(5)            \n    \n    # Improve the power mode for QSFP ports\n    transceiver_obj.set_power_mode_for_QSFP()\n\n    while 1 :\n        try:\n            if bcm_obj.get_platform() == INV_SEQUOIA_PLATFORM:\n                bcm_obj.parsing_port_list()  \n            for index in transceiver_obj.get_port_to_i2c_mapping().keys():\n                info = transceiver_obj.get_eeprom_dict_info(index)\n                value = transceiver_obj.get_eeprom_partNum_from_parser_eeprom_dict(info)\n                if transceiver_obj.get_transceiver_port_mapping().has_key(index) is not False and transceiver_obj.get_transceiver_port_mapping()[index][\"pn\"] <> value:\n                    transceiver_obj.get_transceiver_port_mapping()[index][\"pn\"] = value\n                    transceiver_obj.set_transceiver_type(index,value) \n                    transceiver_obj.set_tx_disable(index)\n                    #transceiver_obj.show_transceiver_port_mapping()     \n            # transceiver_obj.show_transceiver_port_mapping()       \n        except Exception, e:\n            log_message(\"Exception. The warning is {0}\".format(str(e)) )            \n        time.sleep(1)\n\n    syslog.closelog()\n    del transceiver_obj\n    del bcm_obj\n\nif __name__ == \"__main__\":\n    main()\n\n\n\n\n\n\n\n"}, "/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py": {"changes": [{"diff": "\n         return True\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/dev", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d6332/sonic_platform/qsfp.py", "badparts": ["        return os.system(\"docker > /dev/null 2>&1\") == 0"], "goodparts": ["        return subprocess.call([\"docker\"]) == 0"]}]}, "/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py": {"changes": [{"diff": "\n \t      return status\n     for addr_offset in range (0,FAN_NUM):\n         addr=FAN_VPD_ADDR_BASE+addr_offset\n-        cmd = \"i2cdetect -y \"+str(FAN_VPD_CHANNEL)+\" \"+str(addr)+\" \"+str(addr)+\" | grep \"+str(hex(addr)).replace('0x','')\n-        result=os.system(cmd)\n+        cmd1 = [\"i2cdetect\", \"-y\", str(FAN_VPD_CHANNEL), str(addr), str(addr)]\n+        cmd2 = [\"grep\", f'{addr:x}']\n+        result, _ = getstatusoutput_noshell_pipe(cmd1, cmd2)\n         if( result==0 ):\n             cmd=\"echo inv_eeprom \"+str(addr)+\" > /sys/bus/i2c/devices/i2c-\"+FAN_VPD_CHANNEL\n             status, output = exec_cmd(c", "add": 3, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d6332/utils/inventec_d6332_util.py", "badparts": ["        cmd = \"i2cdetect -y \"+str(FAN_VPD_CHANNEL)+\" \"+str(addr)+\" \"+str(addr)+\" | grep \"+str(hex(addr)).replace('0x','')", "        result=os.system(cmd)"], "goodparts": ["        cmd1 = [\"i2cdetect\", \"-y\", str(FAN_VPD_CHANNEL), str(addr), str(addr)]", "        cmd2 = [\"grep\", f'{addr:x}']", "        result, _ = getstatusoutput_noshell_pipe(cmd1, cmd2)"]}], "source": "\n \"\"\" Usage: %(scriptName)s[options] command object options: -h | --help : this help message -d | --debug : run with debug mode -f | --force : ignore error during installation or clean command: install : install drivers and generate related sysfs nodes clean : uninstall drivers and remove related sysfs nodes \"\"\" import os import commands import sys, getopt import logging import syslog import time DEBUG=False args=[] FORCE=0 FAN_VPD_CHANNEL=1 FAN_VPD_ADDR_BASE=0x52 FAN_NUM=5 RETRY_LIMIT=5 i2c_prefix='/sys/bus/i2c/devices/' if DEBUG==True: print sys.argv[0] print 'ARGV: ', sys.argv[1:] def main(): global DEBUG global args global FORCE if len(sys.argv)<2: show_help() options, args=getopt.getopt(sys.argv[1:], 'hdf',['help', 'debug', 'force', ]) if DEBUG==True: print options print args print len(sys.argv) for opt, arg in options: if opt in('-h', '--help'): show_help() elif opt in('-d', '--debug'): DEBUG=True logging.basicConfig(level=logging.INFO) elif opt in('-f', '--force'): FORCE=1 else: logging.info('no option') for arg in args: if arg=='install': install() elif arg=='clean': uninstall() else: show_help() return 0 def show_help(): print __doc__ %{'scriptName': sys.argv[0].split(\"/\")[-1]} sys.exit(0) def show_log(txt): if DEBUG==True: print \"[D6332]\"+txt return def exec_cmd(cmd, show): logging.info('Run:'+cmd) status, output=commands.getstatusoutput(cmd) show_log(cmd +\" with result:\" +str(status)) show_log(\" output:\"+output) if status: logging.info('Failed:'+cmd) if show: print('Failed:'+cmd) return status, output def link_dir(prefix,dst): retry=0 ret=False while(ret==False and retry<RETRY_LIMIT): ret=os.path.isdir(prefix) if ret==True: break time.sleep(0.5) retry+=1 if ret==True: dirs=os.listdir(prefix) ret=False for i in dirs: if i.startswith('hwmon'): src=prefix+i os.symlink(src,dst) ret=True break if ret==False: syslog.syslog(syslog.LOG_ERR, \"Can't find proper dir to link under %s\" % prefix) else: syslog.syslog(syslog.LOG_ERR,\"Path %s is not a dir\" % prefix) _path_prefix_list=[ \"/sys/bus/i2c/devices/i2c-pmbus-1/hwmon/\", \"/sys/bus/i2c/devices/i2c-pmbus-2/hwmon/\", \"/sys/devices/platform/coretemp.0/hwmon/\", \"/sys/bus/i2c/devices/i2c-tmp75-1/hwmon/\", \"/sys/bus/i2c/devices/i2c-tmp75-2/hwmon/\", \"/sys/bus/i2c/devices/i2c-tmp75-3/hwmon/\", \"/sys/bus/i2c/devices/i2c-tmp75-4/hwmon/\" ] _path_dst_list=[ \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/psu1\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/psu2\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/coretemp\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_1\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_2\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_3\", \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_4\", ] instantiate=[ 'echo inv_eeprom 0x55 > /sys/bus/i2c/devices/i2c-0/new_device' ] drivers=[ 'gpio_ich', 'lpc_ich', 'i2c-i801', 'i2c-mux', 'i2c-mux-pca954x', 'i2c-mux-pca9541', 'i2c-dev', 'ucd9000', 'inv_eeprom', 'inv_cpld', 'lm75', 'inv_platform', 'swps'] def system_install(boot_option): global FORCE status, output=exec_cmd(\"rmmod i2c_ismt \", 1) if status: print output if FORCE==0: return status status, output=exec_cmd(\"rmmod i2c-i801 \", 1) if status: print output if FORCE==0: return status status, output=exec_cmd(\"rmmod gpio_ich \", 1) if status: print output if FORCE==0: return status status, output=exec_cmd(\"rmmod lpc_ich \", 1) if status: print output if FORCE==0: return status ''' boot_option: 0 -normal, 1 -fast-reboot''' for i in range(0,len(drivers)): if drivers[i]==\"swps\": if boot_option==1: status, output=exec_cmd(\"modprobe swps io_no_init=1\", 1) else: status, output=exec_cmd(\"modprobe \"+drivers[i], 1) else: status, output=exec_cmd(\"modprobe \"+drivers[i], 1) if status: \t print output \t if FORCE==0: \t return status for i in range(0,len(instantiate)): status, output=exec_cmd(instantiate[i], 1) if status: \t print output \t if FORCE==0: \t return status for addr_offset in range(0,FAN_NUM): addr=FAN_VPD_ADDR_BASE+addr_offset cmd=\"i2cdetect -y \"+str(FAN_VPD_CHANNEL)+\" \"+str(addr)+\" \"+str(addr)+\" | grep \"+str(hex(addr)).replace('0x','') result=os.system(cmd) if( result==0): cmd=\"echo inv_eeprom \"+str(addr)+\" > /sys/bus/i2c/devices/i2c-\"+FAN_VPD_CHANNEL status, output=exec_cmd(cmd,1) if status: print output if FORCE==0: return status for i in range(12,20): cmd=\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-4/i2c-\"+str(i)+\"/new_device\" status, output=exec_cmd(cmd,1) if status: print output if FORCE==0: return status for i in range(20,28): status, output=exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-5/i2c-\"+str(i)+\"/new_device\", 1) if status: print output if FORCE==0: return status for i in range(28,36): status, output=exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-6/i2c-\"+str(i)+\"/new_device\", 1) if status: print output if FORCE==0: return status for i in range(36,44): status, output=exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-7/i2c-\"+str(i)+\"/new_device\", 1) if status: print output if FORCE==0: return status for i in range(0,len(_path_prefix_list)): if( os.path.islink(_path_dst_list[i])): os.unlink(_path_dst_list[i]) syslog.syslog(syslog.LOG_WARNING, \"Path %s exists, remove before link again\" % _path_dst_list[i]) link_dir(_path_prefix_list[i],_path_dst_list[i]) return def system_ready(): if not device_found(): return False return True def install(boot_option=0): ''' boot_option: 0 -normal, 1 -fast-reboot ''' if not device_found(): print \"No device, installing....\" status=system_install(boot_option) if status: if FORCE==0: return status else: print \"D6332 devices detected....\" return def uninstall(): global FORCE for i in range(len(drivers)-1,-1,-1): status, output=exec_cmd(\"rmmod \"+drivers[i], 1) if status: \t print output \t if FORCE==0: \t return status return def device_found(): ret1, log=exec_cmd(\"ls \"+i2c_prefix+\"*0072\", 0) ret2, log=exec_cmd(\"ls \"+i2c_prefix+\"i2c-5\", 0) return not(ret1 or ret2) if __name__==\"__main__\": main() ", "sourceWithComments": "#!/usr/bin/env python\n#\n# Copyright (C) 2017 Inventec, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nUsage: %(scriptName)s [options] command object\n\noptions:\n    -h | --help     : this help message\n    -d | --debug    : run with debug mode\n    -f | --force    : ignore error during installation or clean \ncommand:\n    install         : install drivers and generate related sysfs nodes\n    clean           : uninstall drivers and remove related sysfs nodes\n\"\"\"\n\nimport os\nimport commands\nimport sys, getopt\nimport logging\nimport syslog\nimport time\n\nDEBUG = False\nargs = []\nFORCE = 0\nFAN_VPD_CHANNEL= 1\nFAN_VPD_ADDR_BASE=0x52\nFAN_NUM=5\nRETRY_LIMIT = 5\ni2c_prefix = '/sys/bus/i2c/devices/'\n\n\nif DEBUG == True:\n    print sys.argv[0]\n    print 'ARGV: ', sys.argv[1:]\n\n\ndef main():\n    global DEBUG\n    global args\n    global FORCE\n\n\n    if len(sys.argv)<2:\n        show_help()\n\n    options, args = getopt.getopt(sys.argv[1:], 'hdf', ['help',\n                                                       'debug',\n                                                       'force',\n                                                          ])\n    if DEBUG == True:\n        print options\n        print args\n        print len(sys.argv)\n\n    for opt, arg in options:\n        if opt in ('-h', '--help'):\n            show_help()\n        elif opt in ('-d', '--debug'):\n            DEBUG = True\n            logging.basicConfig(level=logging.INFO)\n        elif opt in ('-f', '--force'):\n            FORCE = 1\n        else:\n            logging.info('no option')\n    for arg in args:\n        if arg == 'install':\n            install()\n        elif arg == 'clean':\n            uninstall()\n        else:\n            show_help()\n\n\n    return 0\n\ndef show_help():\n    print __doc__ % {'scriptName' : sys.argv[0].split(\"/\")[-1]}\n    sys.exit(0)\n\ndef show_log(txt):\n    if DEBUG == True:\n        print \"[D6332]\"+txt\n    return\n\ndef exec_cmd(cmd, show):\n    logging.info('Run :'+cmd)\n    status, output = commands.getstatusoutput(cmd)\n    show_log (cmd +\" with result:\" + str(status))\n    show_log (\"      output:\"+output)\n    if status:\n        logging.info('Failed :'+cmd)\n        if show:\n            print('Failed :'+cmd)\n    return  status, output\n\ndef link_dir(prefix,dst):\n    retry=0\n    ret=False\n    while(ret==False and retry<RETRY_LIMIT):\n        ret=os.path.isdir(prefix)\n        if ret==True:\n            break\n        time.sleep(0.5)\n        retry+=1\n\n    if ret==True:\n        dirs=os.listdir(prefix)\n        ret=False\n        for i in dirs:\n            if i.startswith('hwmon'):\n                src=prefix+i\n                os.symlink(src,dst)\n                ret=True\n                break\n        if ret==False:\n            syslog.syslog(syslog.LOG_ERR, \"Can't find proper dir to link under %s\" % prefix)\n    else:\n        syslog.syslog(syslog.LOG_ERR,\"Path %s is not a dir\" % prefix)\n\n_path_prefix_list=[\n    \"/sys/bus/i2c/devices/i2c-pmbus-1/hwmon/\",\n    \"/sys/bus/i2c/devices/i2c-pmbus-2/hwmon/\",\n    \"/sys/devices/platform/coretemp.0/hwmon/\",\n    \"/sys/bus/i2c/devices/i2c-tmp75-1/hwmon/\",\n    \"/sys/bus/i2c/devices/i2c-tmp75-2/hwmon/\",\n    \"/sys/bus/i2c/devices/i2c-tmp75-3/hwmon/\",\n    \"/sys/bus/i2c/devices/i2c-tmp75-4/hwmon/\"\n]\n\n_path_dst_list=[\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/psu1\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/psu2\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/coretemp\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_1\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_2\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_3\",\n    \"/usr/share/sonic/device/x86_64-inventec_d6332-r0/board_thermal_4\",\n]\n\ninstantiate = [\n'echo inv_eeprom 0x55 > /sys/bus/i2c/devices/i2c-0/new_device'\n#'echo inv_cpld 0x33 > /sys/bus/i2c/devices/i2c-0/i2c-2/new_device',\n#'echo inv_cpld 0x77 > /sys/bus/i2c/devices/i2c-0/i2c-2/new_device'\n]\n\n\ndrivers =[\n#kernel-dirvers\n'gpio_ich',\n'lpc_ich',\n'i2c-i801',\n'i2c-mux',\n'i2c-mux-pca954x',\n'i2c-mux-pca9541',\n'i2c-dev',\n'ucd9000',\n#inv-modules\n'inv_eeprom',\n'inv_cpld',\n'lm75',\n'inv_platform',\n#'monitor',\n'swps']\n\n\n# Modify for fast-reboot\ndef system_install(boot_option):\n    global FORCE\n\n    #remove default drivers to avoid modprobe order conflicts\n    status, output = exec_cmd(\"rmmod i2c_ismt \", 1)\n    if status:\n       print output\n       if FORCE == 0:\n          return status\n\n    status, output = exec_cmd(\"rmmod i2c-i801 \", 1)\n    if status:\n       print output\n       if FORCE == 0:\n          return status\n\n    status, output = exec_cmd(\"rmmod gpio_ich \", 1)\n    if status:\n       print output\n       if FORCE == 0:\n          return status\n\n    status, output = exec_cmd(\"rmmod lpc_ich \", 1)\n    if status:\n       print output\n       if FORCE == 0:\n          return status\n\n    #insert extra module\n    #status, output = exec_cmd(\"insmod /lib/modules/4.9.0-9-2-amd64/kernel/drivers/gpio/gpio-ich.ko gpiobase=0\",1)\n\n    #install drivers\n    ''' boot_option: 0 - normal, 1 - fast-reboot'''\n    for i in range(0,len(drivers)):\n       if drivers[i] == \"swps\":\n           if boot_option == 1:\n               status, output = exec_cmd(\"modprobe swps io_no_init=1\", 1)\n           else:\n               status, output = exec_cmd(\"modprobe \"+drivers[i], 1)\n       else:\n           status, output = exec_cmd(\"modprobe \"+drivers[i], 1)\n\n    if status:\n\t   print output\n\t   if FORCE == 0:\n\t      return status\n\n    #instantiate devices\n    for i in range(0,len(instantiate)):\n       #time.sleep(1)\n       status, output = exec_cmd(instantiate[i], 1)\n    if status:\n\t   print output\n\t   if FORCE == 0:                \n\t      return status\n    for addr_offset in range (0,FAN_NUM):\n        addr=FAN_VPD_ADDR_BASE+addr_offset\n        cmd = \"i2cdetect -y \"+str(FAN_VPD_CHANNEL)+\" \"+str(addr)+\" \"+str(addr)+\" | grep \"+str(hex(addr)).replace('0x','')\n        result=os.system(cmd)\n        if( result==0 ):\n            cmd=\"echo inv_eeprom \"+str(addr)+\" > /sys/bus/i2c/devices/i2c-\"+FAN_VPD_CHANNEL\n            status, output = exec_cmd(cmd,1)\n            if status:\n               print output\n               if FORCE == 0:                \n                  return status\n#\n# INV_FIX-4037\n# It replaces the original sff8436 driver with the optoe driver\n#\n    #optoe map to i2c-bus\\\n    for i in range(12,20):\n        cmd=\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-4/i2c-\"+str(i)+\"/new_device\"\n        status, output =exec_cmd(cmd,1)\n        if status:\n            print output\n            if FORCE == 0:\n                return status\n    for i in range(20,28):\n        status, output =exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-5/i2c-\"+str(i)+\"/new_device\", 1)\n        if status:\n            print output\n            if FORCE == 0:\n                return status\n    for i in range(28,36):\n        status, output =exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-6/i2c-\"+str(i)+\"/new_device\", 1)\n        if status:\n            print output\n            if FORCE == 0:\n                return status\n    for i in range(36,44):\n        status, output =exec_cmd(\"echo optoe1 0x50 > /sys/bus/i2c/devices/i2c-0/i2c-7/i2c-\"+str(i)+\"/new_device\", 1)\n        if status:\n            print output\n            if FORCE == 0:\n                return status\n                \n    #make softlink for device info\n    for i in range(0,len(_path_prefix_list)):\n        if( os.path.islink(_path_dst_list[i]) ):\n            os.unlink(_path_dst_list[i])\n            syslog.syslog(syslog.LOG_WARNING, \"Path %s exists, remove before link again\" % _path_dst_list[i] )\n        link_dir(_path_prefix_list[i],_path_dst_list[i])\n\n    return\n\n\ndef system_ready():\n    if not device_found():\n        return False\n    return True\n\ndef install(boot_option=0):\n    ''' boot_option: 0 - normal, 1 - fast-reboot '''\n    if not device_found():\n        print \"No device, installing....\"\n        status = system_install(boot_option)\n        if status:\n            if FORCE == 0:\n                return status\n    else:\n        print \"D6332 devices detected....\"\n    return\n\ndef uninstall():\n    global FORCE\n    #uninstall drivers\n    for i in range(len(drivers)-1,-1,-1):\n       status, output = exec_cmd(\"rmmod \"+drivers[i], 1)\n    if status:\n\t   print output\n\t   if FORCE == 0:\n\t      return status\n    return\n\ndef device_found():\n    ret1, log = exec_cmd(\"ls \"+i2c_prefix+\"*0072\", 0)\n    ret2, log = exec_cmd(\"ls \"+i2c_prefix+\"i2c-5\", 0)\n    return not(ret1 or ret2)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"}, "/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py": {"changes": [{"diff": "\n         return retval\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/d", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/qsfp.py", "badparts": ["        return os.system(\"docker > /dev/null 2>&1\") == 0"], "goodparts": ["        return subprocess.call([\"docker\"]) == 0"]}]}, "/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py": {"changes": [{"diff": "\n \n try:\n     import os\n-    import sys\n+    import subprocess\n     from sonic_platform_base.sfp_base import SfpBase\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom\n     from sonic_platform_base.sonic_sfp.sff8472 import sff8472InterfaceId\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py", "badparts": ["    import sys"], "goodparts": ["    import subprocess"]}, {"diff": "\n         return retval\n \n     def __is_host(self):\n-        return os.system(\"docker > /dev/null 2>&1\") == 0\n+        return subprocess.call([\"docker\"]) == 0\n \n     def __get_path_to_port_config_file(self):\n         host_platform_root_path = '/usr/share/sonic/", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d6356/sonic_platform/sfp.py", "badparts": ["        return os.system(\"docker > /dev/null 2>&1\") == 0"], "goodparts": ["        return subprocess.call([\"docker\"]) == 0"]}]}, "/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to QSFP sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-inventec_d7054q28b-r0\"\n     HWSKU  = \"INVENTEC-D7054Q28B-S48-Q6\"\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         return \"\"\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-inventec/d7054q28b/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        return subprocess.call(self.HOST_CHK_CMD) == 0"]}]}}, "msg": "[inventec] Replace os.system and remove subprocess with shell=True (#12108)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\nDependency: [https://github.com/sonic-net/sonic-buildimage/pull/12065](https://github.com/sonic-net/sonic-buildimage/pull/12065)\r\n#### Why I did it\r\n1. `getstatusoutput` is used without a static string and it uses `shell=True`\r\n2. `subprocess()` - when using with `shell=True` is dangerous. Using subprocess function without a static string can lead to command injection.\r\n3. `os` - not secure against maliciously constructed input and dangerous if used to evaluate dynamic content.\r\n#### How I did it\r\n1. use `getstatusoutput` without shell=True\r\n2. `subprocess()` - use `shell=False` instead. use an array string. Ref: [https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation](https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation)\r\n3. `os` - use with `subprocess`"}, "35c4e9912de88dcc821ac5c8aebcc994ddcb9838": {"url": "https://api.github.com/repos/mohsin75/sonic-buildimage/commits/35c4e9912de88dcc821ac5c8aebcc994ddcb9838", "html_url": "https://github.com/mohsin75/sonic-buildimage/commit/35c4e9912de88dcc821ac5c8aebcc994ddcb9838", "sha": "35c4e9912de88dcc821ac5c8aebcc994ddcb9838", "keyword": "command injection malicious", "diff": "diff --git a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py\nindex 56e9d8664a..12f1cc8ed7 100644\n--- a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py\n@@ -37,14 +37,14 @@ def get_pcie_device(self):\n         pciList = []\n         p1 = \"^(\\w+):(\\w+)\\.(\\w)\\s(.*)\\s*\\(*.*\\)*\"\n         p2 = \"^.*:.*:.*:(\\w+)\\s*\\(*.*\\)*\"\n-        command1 = \"sudo lspci\"\n-        command2 = \"sudo lspci -n\"\n+        command1 = [\"sudo\", \"lspci\"]\n+        command2 = [\"sudo\", \"lspci\", \"-n\"]\n         # run command 1\n-        proc1 = subprocess.Popen(command1, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc1 = subprocess.Popen(command1, universal_newlines=True, stdout=subprocess.PIPE)\n         output1 = proc1.stdout.readlines()\n         proc1.communicate()\n         # run command 2\n-        proc2 = subprocess.Popen(command2, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc2 = subprocess.Popen(command2, universal_newlines=True, stdout=subprocess.PIPE)\n         output2 = proc2.stdout.readlines()\n         proc2.communicate()\n \ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py\nindex ea4048e19f..18ca047cba 100644\n--- a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py\n@@ -10,13 +10,13 @@\n \n try:\n     import time\n-    import subprocess\n     from sonic_platform_base.chassis_base import ChassisBase\n     from sonic_platform.common import Common\n     from sonic_platform.sfp import Sfp\n     from sonic_platform.sfp import PORT_START\n     from sonic_platform.sfp import PORTS_IN_BLOCK\n     from sonic_platform.logger import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -36,17 +36,17 @@ def __init__(self):\n         self.SFP_STATUS_INSERTED = \"1\"\n         self.SFP_STATUS_REMOVED = \"0\"\n         self.port_dict = {}\n-        self.enable_read= \"i2cset -f -y 2 0x35 0x2a 0x01\"\n-        self.disable_read = \"i2cset -f -y 2 0x35 0x2a 0x00\"\n-        self.enable_write = \"i2cset -f -y 2 0x35 0x2b 0x00\"\n-        self.disable_write = \"i2cset -f -y 2 0x35 0x2b 0x01\"\n-        self.enable_erase = \"i2cset -f -y 2 0x35 0x2c 0x01\"\n-        self.disable_erase = \"i2cset -f -y 2 0x35 0x2c 0x00\"\n-        self.read_value = \"i2cget -f -y 2 0x35 0x25\"\n-        self.write_value = \"i2cset -f -y 2 0x35 0x21 0x0a\"\n-        self.set_sys_led_cmd = \"i2cset -f -y 2 0x33 0xb2 \"\n-        self.get_sys_led_cmd = \"i2cget -f -y 2 0x33 0xb2\"\n-        self.led_status = \"red\"\n+        self.enable_read= [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x01\"]\n+        self.disable_read = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x00\"]\n+        self.enable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x00\"]\n+        self.disable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x01\"]\n+        self.enable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x01\"]\n+        self.disable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x00\"]\n+        self.read_value = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x25\"]\n+        self.write_value = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x21\", \"0x0a\"]\n+        self.set_sys_led_cmd = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]\n+        self.get_sys_led_cmd = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]\n+        self.led_status = \"red\" \n         # Initialize SFP list\n         # sfp.py will read eeprom contents and retrive the eeprom data.\n         # It will also provide support sfp controls like reset and setting\n@@ -210,25 +210,25 @@ def get_reboot_cause(self):\n         try:\n             is_power_loss = False\n             # enable read\n-            subprocess.getstatusoutput(self.disable_write)\n-            subprocess.getstatusoutput(self.enable_read)\n-            ret , log = subprocess.getstatusoutput(self.read_value)\n+            getstatusoutput_noshell(self.disable_write)\n+            getstatusoutput_noshell(self.enable_read)\n+            ret , log = getstatusoutput_noshell(self.read_value)\n             if ret == 0 and \"0x0a\" in log:\n                 is_power_loss = True\n \n             # erase i2c and e2\n-            subprocess.getstatusoutput(self.enable_erase)\n+            getstatusoutput_noshell(self.enable_erase)\n             time.sleep(1)\n-            subprocess.getstatusoutput(self.disable_erase)\n+            getstatusoutput_noshell(self.disable_erase)\n             # clear data\n-            subprocess.getstatusoutput(self.enable_write)\n-            subprocess.getstatusoutput(self.disable_read)\n-            subprocess.getstatusoutput(self.disable_write)\n-            subprocess.getstatusoutput(self.enable_read)\n+            getstatusoutput_noshell(self.enable_write)\n+            getstatusoutput_noshell(self.disable_read)\n+            getstatusoutput_noshell(self.disable_write)\n+            getstatusoutput_noshell(self.enable_read)\n             # enable write and set data\n-            subprocess.getstatusoutput(self.enable_write)\n-            subprocess.getstatusoutput(self.disable_read)\n-            subprocess.getstatusoutput(self.write_value)\n+            getstatusoutput_noshell(self.enable_write)\n+            getstatusoutput_noshell(self.disable_read)\n+            getstatusoutput_noshell(self.write_value)\n             if is_power_loss:\n                 return(self.REBOOT_CAUSE_POWER_LOSS, None)\n         except Exception as e:\n@@ -417,7 +417,8 @@ def set_status_led(self, color):\n         if regval is None:\n             print(\"Invaild color input.\")\n             return False\n-        ret , log = subprocess.getstatusoutput(self.set_sys_led_cmd + regval)\n+        cmd = self.set_sys_led_cmd + [regval]\n+        ret, log = getstatusoutput_noshell(cmd)\n         if ret != 0:\n             print(\"Cannot execute %s\" % self.set_sys_led_cmd + regval)\n             return False\n@@ -431,7 +432,7 @@ def get_status_led(self):\n             A string, one of the valid LED color strings which could be vendor\n             specified.\n         \"\"\"\n-        ret , log = subprocess.getstatusoutput(self.get_sys_led_cmd)\n+        ret , log = getstatusoutput_noshell(self.get_sys_led_cmd)\n         if ret != 0:\n             print(\"Cannot execute %s\" % self.get_sys_led_cmd)\n             return False\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py\nindex c1a85f6186..e1bef19c24 100644\n--- a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py\n@@ -1,6 +1,6 @@\n import os\n import yaml\n-\n+import subprocess\n from sonic_py_common import device_info\n \n \n@@ -10,13 +10,13 @@ class Common:\n     PMON_PLATFORM_PATH = '/usr/share/sonic/platform/'\n     CONFIG_DIR = 'sonic_platform_config'\n \n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def load_json_file(self, path):\n         \"\"\"\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py\nindex 33ff6ef8b3..26e83fb191 100644\n--- a/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py\n@@ -8,10 +8,10 @@\n ########################################################################\n \n try:\n-    import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n     from sonic_platform.regutil import Reg\n     from sonic_platform.logger import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -70,12 +70,12 @@ def install_firmware(self, image_path):\n         \"\"\"\n         try:\n             successtips = \"CPLD Upgrade succeeded!\"\n-            status, output = subprocess.getstatusoutput(\"which firmware_upgrade\")\n+            status, output = getstatusoutput_noshell([\"which\", \"firmware_upgrade\"])\n             if status or len(output) <= 0:\n                 logger.error(\"no upgrade tool.\")\n                 return False\n-            cmdstr = \"%s %s cpld %d cpld\"%(output,image_path,self.slot)\n-            ret, log = subprocess.getstatusoutput(cmdstr)\n+            cmdstr = [output, image_path, \"cpld\", self.slot, \"cpld\"]\n+            ret, log = getstatusoutput_noshell(cmdstr)\n             if ret == 0 and successtips in log:\n                 return True\n             logger.error(\"upgrade failed. ret:%d, log:\\n%s\" % (ret, log))\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py b/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py\nindex 46f3089bbd..88453c9e91 100644\n--- a/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py\n@@ -6,7 +6,6 @@\n #\n #######################################################\n \n-import subprocess\n import time\n import glob\n import re\n@@ -14,6 +13,7 @@\n from rjutil.smbus import SMBus\n import time\n from  functools import wraps\n+from sonic_py_common.general import getstatusoutput_noshell\n \n \n def retry(maxretry =6, delay = 0.01):\n@@ -80,13 +80,13 @@ def rji2csetword_python(bus, addr, reg, value):\n \n     @staticmethod\n     def command(cmdstr):\n-        retcode, output = subprocess.getstatusoutput(cmdstr)\n+        retcode, output = getstatusoutput_noshell(cmdstr)\n         return retcode, output\n \n \n     @staticmethod\n     def geti2cword_i2ctool(bus, addr, offset):\n-        command_line = \"i2cget -f -y %d 0x%02x 0x%02x  wp\" % (bus, addr, offset)\n+        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%02x\"%offset, \"wp\"]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n@@ -99,7 +99,7 @@ def geti2cword_i2ctool(bus, addr, offset):\n \n     @staticmethod\n     def seti2cword_i2ctool(bus, addr, offset, val):\n-        command_line = \"i2cset -f -y %d 0x%02x 0x%0x 0x%04x wp\" % (bus, addr, offset, val)\n+        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%0x\"%offset, \"0x%04x\"%val, \"wp\"]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n@@ -111,7 +111,7 @@ def seti2cword_i2ctool(bus, addr, offset, val):\n \n     @staticmethod\n     def rji2cget_i2ctool(bus, devno, address):\n-        command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)\n+        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n@@ -123,8 +123,7 @@ def rji2cget_i2ctool(bus, devno, address):\n \n     @staticmethod\n     def rji2cset_i2ctool(bus, devno, address, byte):\n-        command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (\n-            bus, devno, address, byte)\n+        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address, \"0x%02x\"%byte]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n@@ -166,7 +165,7 @@ def readsysfs(location):\n \n     @staticmethod\n     def getdevmem(addr, digit, mask):\n-        command_line = \"devmem 0x%02x %d\" %(addr, digit)\n+        command_line = [\"devmem\", \"0x%02x\"%addr, str(digit)]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n@@ -179,13 +178,13 @@ def getdevmem(addr, digit, mask):\n \n     @staticmethod\n     def rj_os_system(cmd):\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         return status, output\n \n     @staticmethod\n     def getsdkreg(reg):\n         try:\n-            cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg\n+            cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]\n             ret, result = osutil.rj_os_system(cmd)\n             result_t = result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n             if ret != 0 or \"Error:\" in result_t:\n@@ -203,8 +202,8 @@ def getmactemp():\n             result = {}\n             #waitForDocker()\n             #need to exec twice\n-            osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n-            ret, log = osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n+            osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n+            ret, log = osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n             if ret:\n                 return False, result\n             else:\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py b/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py\nindex 35bca09c02..c812ba2958 100755\n--- a/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py\n@@ -6,7 +6,7 @@\n import subprocess\n import time\n from  ruijieconfig import GLOBALCONFIG, GLOBALINITPARAM, GLOBALINITCOMMAND, MAC_LED_RESET, STARTMODULE, i2ccheck_params\n-\n+from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe\n from  ruijieutil   import rjpciwr\n \n CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])\n@@ -46,7 +46,7 @@ def write_sysfs_value(reg_name, value):\n \n def check_driver():\n     u'''whether there is driver start with rg'''\n-    status, output = log_os_system(\"lsmod | grep rg | wc -l\")\n+    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", \"rg\"], [\"wc\", \"-l\"])\n     #System execution error\n     if status: \n         return False\n@@ -70,61 +70,59 @@ def i2c_getPid(name):\n     return ret\n \n def startAvscontrol():\n-    cmd = \"nohup avscontrol.py start >/dev/null 2>&1 &\"\n+    cmd = [\"avscontrol.py\", \"start\"]\n     rets = i2c_getPid(\"avscontrol.py\")\n     if len(rets) == 0:\n-        os.system(cmd)\n+        subprocess.Popen(cmd)\n \n def startFanctrol():\n     if STARTMODULE['fancontrol'] == 1:\n-        cmd = \"nohup fancontrol.py start >/dev/null 2>&1 &\"\n+        cmd = [\"fancontrol.py\", \"start\"]\n         rets = i2c_getPid(\"fancontrol.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def starthal_fanctrl():\n     if STARTMODULE.get('hal_fanctrl',0) == 1:\n-        cmd = \"nohup hal_fanctrl.py start >/dev/null 2>&1 &\"\n+        cmd = [\"hal_fanctrl.py\", \"start\"]\n         rets = i2c_getPid(\"hal_fanctrl.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def starthal_ledctrl():\n     if STARTMODULE.get('hal_ledctrl',0) == 1:\n-        cmd = \"nohup hal_ledctrl.py start >/dev/null 2>&1 &\"\n+        cmd = [\"hal_ledctrl.py\", \"start\"]\n         rets = i2c_getPid(\"hal_ledctrl.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n-\n+            subprocess.Popen(cmd)\n def startDevmonitor():\n     if STARTMODULE.get('dev_monitor',0) == 1:\n-        cmd = \"nohup dev_monitor.py start >/dev/null 2>&1 &\"\n+        cmd = [\"dev_monitor.py\", \"start\"]\n         rets = i2c_getPid(\"dev_monitor.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n-\n+            subprocess.Popen(cmd)\n def startSlotmonitor():\n     if STARTMODULE.get('slot_monitor',0) == 1:\n-        cmd = \"nohup slot_monitor.py start >/dev/null 2>&1 &\"\n+        cmd = [\"slot_monitor.py\", \"start\"]\n         rets = i2c_getPid(\"slot_monitor.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def stopFanctrol():\n     u'''disable fan timer service'''\n     if STARTMODULE['fancontrol'] == 1:\n         rets = i2c_getPid(\"fancontrol.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def stophal_ledctrl():\n     if STARTMODULE.get('hal_ledctrl',0) == 1:\n         rets = i2c_getPid(\"hal_ledctrl.py\")\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n \n@@ -133,8 +131,8 @@ def stopDevmonitor():\n     if STARTMODULE.get('dev_monitor',0) == 1:\n         rets = i2c_getPid(\"dev_monitor.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def stopSlotmonitor():\n@@ -142,15 +140,16 @@ def stopSlotmonitor():\n     if STARTMODULE.get('slot_monitor',0) == 1:\n         rets = i2c_getPid(\"slot_monitor.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def removeDev(bus, loc):\n-    cmd = \"echo  0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device\" % (loc, bus)\n     devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n     if os.path.exists(devpath):\n-        log_os_system(cmd)\n+        file = \"/sys/bus/i2c/devices/i2c-%d/delete_device\" % bus\n+        with open(file, 'w') as f:\n+            f.write('0x%02x\\n'%str(bus))\n         \n def addDev(name, bus, loc):\n     if name == \"lm75\":\n@@ -163,10 +162,11 @@ def addDev(name, bus, loc):\n         if i % 10 == 0:\n             click.echo(\"%%DEVICE_I2C-INIT: %s not found, wait 0.1 second ! i %d \" % (pdevpath,i))\n             \n-    cmd = \"echo  %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device\" % (name, loc, bus)\n     devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n     if os.path.exists(devpath) == False:\n-        os.system(cmd)\n+        file = \"/sys/bus/i2c/devices/i2c-%d/new_device\" % bus\n+        with open(file, 'w') as f:\n+            f.write('%s 0x%02x\\n' % (name, loc))\n \n def removedevs():\n     devs = GLOBALCONFIG[\"DEVS\"]\n@@ -179,8 +179,7 @@ def adddevs():\n         addDev(devs[dev][\"name\"], devs[dev][\"bus\"] , devs[dev][\"loc\"])\n \n def checksignaldriver(name):\n-    modisexistcmd = \"lsmod | grep %s | wc -l\" % name\n-    status, output = log_os_system(modisexistcmd)\n+    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", name], [\"wc\", \"-l\"])\n     #System execution error\n     if status: \n         return False\n@@ -190,17 +189,17 @@ def checksignaldriver(name):\n         return False\n \n def adddriver(name, delay):\n-    cmd = \"modprobe %s\" % name\n+    cmd = [\"modprobe\", name]\n     if delay != 0:\n         time.sleep(delay)\n     if checksignaldriver(name) != True:\n-        log_os_system(cmd)\n+        getstatusoutput_noshell(cmd)\n \n def removedriver(name, delay):\n     realname = name.lstrip().split(\" \")[0];\n-    cmd = \"rmmod -f %s\" % realname\n+    cmd = [\"rmmod\", \"-f\", realname]\n     if checksignaldriver(realname):\n-        log_os_system(cmd)\n+        getstatusoutput_noshell(cmd)\n \n def removedrivers():\n     u'''remove all drivers'''\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py b/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py\nindex 87fb01e5f6..e12bb25d7f 100755\n--- a/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py\n@@ -4,6 +4,7 @@\n import os\n import time\n import syslog\n+import subprocess\n from ruijieconfig import MONITOR_CONST, FANCTROLDEBUG, MONITOR_FANS_LED, DEV_LEDS, MONITOR_PSU_STATUS, \\\n         MONITOR_SYS_PSU_LED, MONITOR_DEV_STATUS, MONITOR_FAN_STATUS, MONITOR_DEV_STATUS_DECODE, \\\n         MONITOR_SYS_FAN_LED, MONITOR_SYS_LED, fanloc\n@@ -766,7 +767,7 @@ def checkCrit(self):\n                     self.fanSpeedSetMax()  # fan full speed\n                     self.critnum += 1 # anti-shake\n                     if self.critnum >= MONITOR_CONST.CRITICAL_NUM:\n-                       os.system(\"reboot\")\n+                        subprocess.call([\"reboot\"])\n                     fanwarningdebuglog(DEBUG_FANCONTROL,\"crit\u6b21\u6570:%d\" % self.critnum)\n                 else:\n                     self.critnum = 0\ndiff --git a/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py b/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py\nindex ff594b72e3..9d1930ec08 100755\n--- a/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py\n+++ b/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py\n@@ -11,7 +11,6 @@\n import sys\n import os\n import re\n-import subprocess\n import syslog\n import time\n import binascii\n@@ -20,6 +19,7 @@\n import threading\n import click\n import mmap\n+from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe\n from ruijieconfig import rg_eeprom, FRULISTS, MAC_DEFAULT_PARAM, MAC_AVS_PARAM, FANS_DEF, \\\n         FAN_PROTECT, E2_LOC, E2_PROTECT, RUIJIE_SERVICE_TAG, RUIJIE_DIAG_VERSION, \\\n         STARTMODULE, RUIJIE_CARDID, RUIJIE_PRODUCTNAME, RUIJIE_PART_NUMBER, \\\n@@ -538,8 +538,8 @@ def __new__(cls, *args, **kwargs):\n \n def getSdkReg(reg):\n     try:\n-        cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg\n-        ret, result = rj_os_system(cmd)\n+        cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]\n+        ret, result = getstatusoutput_noshell(cmd)\n         result_t = result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n         if ret != 0 or \"Error:\" in result_t:\n             return False, result\n@@ -632,8 +632,8 @@ def getMacTemp():\n     result = {}\n     #waitForDocker()\n     # exec twice, get the second result\n-    rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n-    ret, log = rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n+    getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n+    ret, log = getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n     if ret:\n         return False, result\n     else:\n@@ -689,21 +689,21 @@ def getMacTemp_sysfs(mactempconf):\n \n def restartDockerService(force=False):\n     container_name = [\"database\",\"snmp\",\"syncd\",\"swss\",\"dhcp_relay\",\"radv\",\"teamd\",\"pmon\"]\n-    ret, status = rj_os_system(\"docker ps\")\n+    ret, status = getstatusoutput_noshell([\"docker\", \"ps\"])\n     if ret == 0 :\n         for tmpname in container_name:\n             if (tmpname not in status):\n                 if (force == True):\n-                    rj_os_system(\"docker restart %s\"%tmpname)\n+                    getstatusoutput_noshell([\"docker\", \"restart\", tmpname])\n                 else:\n-                    rj_os_system(\"systemctl restart %s\"%tmpname)\n+                    getstatusoutput_noshell([\"systemctl\", \"restart\", tmpname])\n \n \n def waitForDhcp(timeout):\n     time_cnt = 0\n     while True:\n         try:\n-            ret, status = rj_os_system(\"systemctl status dhcp_relay.service\")\n+            ret, status = getstatusoutput_noshell([\"systemctl\", \"status\", \"dhcp_relay.service\"])\n             if (ret == 0 and \"running\" in status)  or \"SUCCESS\" in status:\n                 break\n             else:\n@@ -839,8 +839,10 @@ def util_setmac(eth, mac):\n     rulefile = \"/etc/udev/rules.d/70-persistent-net.rules\"\n     if isValidMac(mac) == False:\n         return False, \"MAC invaild\"\n-    cmd = \"ethtool -e %s | grep 0x0010 | awk '{print \\\"0x\\\"$13$12$15$14}'\" % eth\n-    ret, log = rj_os_system(cmd)\n+    cmd1 = [\"ethtool\", \"-e\", eth] \n+    cmd2 = [\"grep\", \"0x0010\"]\n+    cmd3 = [\"awk\", '{print \\\"0x\\\"$13$12$15$14}']\n+    ret, log = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)\n     log_debug(log)\n     magic = \"\"\n     if ret == 0 and len(log):\n@@ -848,23 +850,22 @@ def util_setmac(eth, mac):\n     macs = mac.upper().split(\":\")\n \n     # chage ETH0 to value after setmac\n-    ifconfigcmd = \"ifconfig eth0 hw ether %s\" % mac\n-    log_debug(ifconfigcmd)\n-    ret, status = rj_os_system(ifconfigcmd)\n+    ifconfigcmd = [\"ifconfig\", \"eth0\", \"hw\", \"ether\", mac]\n+    log_debug(' '.join(ifconfigcmd))\n+    ret, status = getstatusoutput_noshell(ifconfigcmd)\n     if ret:\n         raise SETMACException(\"software set  Internet cardMAC error\")\n     index = 0\n     for item in macs:\n-        cmd = \"ethtool -E %s magic %s offset %d value 0x%s\" % (\n-            eth, magic, index, item)\n+        cmd = [\"ethtool\", \"-E\", eht, \"magic\", magic, \"offset\", str(index), \"value\", \"0x\"+item]\n         log_debug(cmd)\n         index += 1\n-        ret, log = rj_os_system(cmd)\n+        ret, log = getstatusoutput_noshell(cmd)\n         if ret != 0:\n             raise SETMACException(\" set hardware Internet card MAC error\")\n     # get value after setting \n-    cmd_t = \"ethtool -e eth0 offset 0 length 6\"\n-    ret, log = rj_os_system(cmd_t)\n+    cmd_t = [\"ethtool\", \"-e\", \"eth0\", \"offset\", \"0\", \"length\", \"6\"]\n+    ret, log = getstatusoutput_noshell(cmd_t)\n     m = re.split(':', log)[-1].strip().upper()\n     mac_result = m.upper().split(\" \")\n \n@@ -979,11 +980,11 @@ def generate_ext(cardid):\n \n \n def rji2cget(bus, devno, address):\n-    command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)\n+    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address)]\n     retrytime = 6\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n         time.sleep(0.1)\n@@ -991,12 +992,11 @@ def rji2cget(bus, devno, address):\n \n \n def rji2cset(bus, devno, address, byte):\n-    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (\n-        bus, devno, address, byte)\n+    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%02x\"%str(byte)]\n     retrytime = 6\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n     return False, ret_t\n@@ -1033,31 +1033,30 @@ def rjpciwr(pcibus , slot ,fn, bar, offset, data):\n     data.close()\n \n def rjsysset(location, value):\n-    command_line = \"echo 0x%02x > %s\" % (value, location)\n     retrytime = 6\n-    ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n-        if ret == 0:\n-            return True, ret_t\n-    return False, ret_t\n+        try:\n+            with open(location, 'w') as f:\n+                f.write('0x%02x\\n'%value)\n+        except (IOError, FileNotFoundError) as e:\n+            return False, str(e)\n+    return True, ''\n \n \n def rji2cgetWord(bus, devno, address):\n-    command_line = \"i2cget -f -y %d 0x%02x 0x%02x w\" % (bus, devno, address)\n+    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"w\"]\n     retrytime = 3\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n     return False, ret_t\n \n \n def rji2csetWord(bus, devno, address, byte):\n-    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%x w\" % (\n-        bus, devno, address, byte)\n-    rj_os_system(command_line)\n+    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%x\"%str(byte), \"w\"]\n+    getstatusoutput_noshell(command_line)\n \n \n def fan_setmac():\n@@ -1264,14 +1263,15 @@ def writeToEEprom(rst_arr):\n     elif dealtype == \"io\":\n         io_wr(E2_PROTECT[\"io_addr\"], E2_PROTECT[\"close\"])\n     # deal last drivers\n-    os.system(\"rmmod at24 \")\n-    os.system(\"modprobe at24 \")\n-    os.system(\"rm -f /var/cache/sonic/decode-syseeprom/syseeprom_cache\")\n+    getstatusoutput_noshell([\"rmmod\", \"at24\"])\n+    getstatusoutput_noshell([\"modprobe\", \"at24\"])\n+    getstatusoutput_noshell([\"rm\", \"-f\", \"/var/cache/sonic/decode-syseeprom/syseeprom_cache\"])\n \n \n def get_local_eth0_mac():\n-    cmd = \"ifconfig eth0 |grep HWaddr\"\n-    print(rj_os_system(cmd))\n+    cmd1 = [\"ifconfig\", \"eth0\"]\n+    cmd2 = [\"grep\", \"HWaddr\"]\n+    print(getstatusoutput_noshell_pipe(cmd1, cmd2))\n \n def getonieversion():\n     if not os.path.isfile('/host/machine.conf'):\n@@ -1348,12 +1348,12 @@ def fac_board_setmac():\n \n def ipmi_set_mac(mac):\n     macs = mac.split(\":\")\n-    cmdinit = \"ipmitool raw 0x0c 0x01 0x01 0xc2 0x00\"\n-    cmdset = \"ipmitool raw 0x0c 0x01 0x01 0x05\"\n+    cmdinit = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0xc2\", \"0x00\"]\n+    cmdset = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0x05\"]\n     for ind in range(len(macs)):\n-        cmdset += \" 0x%02x\" % int(macs[ind], 16)\n-    rj_os_system(cmdinit)\n-    ret, status = rj_os_system(cmdset)\n+        cmdset.append(\"0x%02x\" % int(macs[ind], 16))\n+    getstatusoutput_noshell(cmdinit)\n+    ret, status = getstatusoutput_noshell(cmdset)\n     if ret:\n         RJPRINTERR(\"\\n\\n%s\\n\\n\" % status)\n         return False\n@@ -1393,11 +1393,11 @@ def closeProtocol():\n     log_info(\"disable LLDP\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n-    rj_os_system(\"systemctl stop lldp.service\")\n+    getstatusoutput_noshell([\"systemctl\", \"stop\", \"lldp.service\"])\n     log_info(\"disable lldp service\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n-    rj_os_system(\"systemctl stop bgp.service\")\n+    getstatusoutput_noshell([\"systemctl\", \"stop\", \"bgp.service\"])\n     log_info(\"disable bgp service\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n@@ -1420,8 +1420,8 @@ def checkSdkMem():\n     with open(file_name, \"w\") as f:\n         f.write(file_data)\n     print(\"change SDK memory to 256, reboot required\")\n-    rj_os_system(\"sync\")\n-    rj_os_system(\"reboot\")\n+    getstatusoutput_noshell([\"sync\"])\n+    getstatusoutput_noshell([\"reboot\"])\n \n ##########################################################################\n # receives a character setting\n@@ -1604,25 +1604,22 @@ def getCardId():\n             return item.get('value',None)\n     return None\n \n-# ====================================\n-# execute shell command\n-# ====================================\n-def rj_os_system(cmd):\n-    status, output = subprocess.getstatusoutput(cmd)\n-    return status, output\n \n ###########################################\n # get memory slot and number via DMI command\n ###########################################\n def getsysmeminfo():\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \"|grep -P -A5 \\\"Memory\\s+Device\\\"|grep Size|grep -v Range\"\n+    cmd1 = [log[0].rstrip('\\n')]\n+    cmd2 = [\"grep\", \"-P\", \"-A5\", \"Memory\\s+Device\"]\n+    cmd3 = [\"grep\", \"Size\"]\n+    cmd4 = [\"grep\", \"-v\", \"Range\"]\n     # get total number first\n     result = []\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3, cmd4)\n     if ret1 == 0 and len(log1):\n         log1 = log1.lstrip()\n         arr = log1.split(\"\\n\")\n@@ -1642,15 +1639,16 @@ def getsysmeminfo():\n # return various arrays\n ###########################################\n def getsysmeminfo_detail():\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \" -t 17 | grep  -A21 \\\"Memory Device\\\"\"  # 17\n+    cmd1 = [log[0].rstrip('\\n')] + [\"-t\", \"17\"]\n+    cmd2 = [\"grep\", \"-A21\", \"Memory Device\"]  # 17\n     # get total number\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)\n     if ret1 != 0 or len(log1) <= 0:\n-        return False, \"command execution error[%s]\" % cmd\n+        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)\n     result_t = log1.split(\"--\")\n     mem_rets = []\n     for item in result_t:\n@@ -1669,13 +1667,13 @@ def getsysmeminfo_detail():\n # get BIOS info via DMI command\n ###########################################\n def getDmiSysByType(type_t):\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \" -t %s\" % type_t\n+    cmd = [log[0].rstrip('\\n')] + [\"-t\", str(type_t)]\n     # get total number\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell(cmd)\n     if ret1 != 0 or len(log1) <= 0:\n         return False, \"command execution error[%s]\" % cmd\n     its = log1.replace(\"\\t\", \"\").strip().split(\"\\n\")\n@@ -1742,11 +1740,12 @@ def getusbinfo():\n         return False, \"Err\"\n \n def get_cpu_info():\n-    cmd = \"cat /proc/cpuinfo |grep processor -A18\"  # 17\n+    cmd1 = [\"cat\", \"/proc/cpuinfo\"]\n+    cmd2 = [\"grep\", \"processor\", \"-A18\"]  # 17\n \n-    ret, log1 = rj_os_system(cmd)\n+    ret, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)\n     if ret != 0 or len(log1) <= 0:\n-        return False, \"command execution error[%s]\" % cmd\n+        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)\n     result_t = log1.split(\"--\")\n     mem_rets = []\n     for item in result_t:\n", "message": "", "files": {"/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py": {"changes": [{"diff": "\n         pciList = []\n         p1 = \"^(\\w+):(\\w+)\\.(\\w)\\s(.*)\\s*\\(*.*\\)*\"\n         p2 = \"^.*:.*:.*:(\\w+)\\s*\\(*.*\\)*\"\n-        command1 = \"sudo lspci\"\n-        command2 = \"sudo lspci -n\"\n+        command1 = [\"sudo\", \"lspci\"]\n+        command2 = [\"sudo\", \"lspci\", \"-n\"]\n         # run command 1\n-        proc1 = subprocess.Popen(command1, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc1 = subprocess.Popen(command1, universal_newlines=True, stdout=subprocess.PIPE)\n         output1 = proc1.stdout.readlines()\n         proc1.communicate()\n         # run command 2\n-        proc2 = subprocess.Popen(command2, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc2 = subprocess.Popen(command2, universal_newlines=True, stdout=subprocess.PIPE)\n         output2 = proc2.stdout.readlines()\n         proc2.communicate()\n ", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_pcie/pcie_common.py", "badparts": ["        command1 = \"sudo lspci\"", "        command2 = \"sudo lspci -n\"", "        proc1 = subprocess.Popen(command1, shell=True, universal_newlines=True, stdout=subprocess.PIPE)", "        proc2 = subprocess.Popen(command2, shell=True, universal_newlines=True, stdout=subprocess.PIPE)"], "goodparts": ["        command1 = [\"sudo\", \"lspci\"]", "        command2 = [\"sudo\", \"lspci\", \"-n\"]", "        proc1 = subprocess.Popen(command1, universal_newlines=True, stdout=subprocess.PIPE)", "        proc2 = subprocess.Popen(command2, universal_newlines=True, stdout=subprocess.PIPE)"]}], "source": "\n import os import yaml import subprocess import re import sys from copy import deepcopy try: from.pcie import PcieBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class PcieUtil(PcieBase): \"\"\"Platform-specific PCIEutil class\"\"\" def __init__(self, path): self.config_path=path def load_config_file(self): config_file=self.config_path +\"/\" +\"pcie.yaml\" try: with open(config_file) as conf_file: self.confInfo=yaml.load(conf_file) except IOError as e: print(\"Error:{}\".format(str(e))) print(\"Not found config file, please add a config file manually, or generate it by running[pcieutil pcie_generate]\") sys.exit() def get_pcie_device(self): pciDict={} pciList=[] p1=\"^(\\w+):(\\w+)\\.(\\w)\\s(.*)\\s*\\(*.*\\)*\" p2=\"^.*:.*:.*:(\\w+)\\s*\\(*.*\\)*\" command1=\"sudo lspci\" command2=\"sudo lspci -n\" proc1=subprocess.Popen(command1, shell=True, universal_newlines=True, stdout=subprocess.PIPE) output1=proc1.stdout.readlines() proc1.communicate() proc2=subprocess.Popen(command2, shell=True, universal_newlines=True, stdout=subprocess.PIPE) output2=proc2.stdout.readlines() proc2.communicate() if proc1.returncode > 0: for line1 in output1: print(line1.strip()) return elif proc2.returncode > 0: for line2 in output2: print(line2.strip()) return else: for(line1, line2) in zip(output1, output2): pciDict.clear() match1=re.search(p1, line1.strip()) match2=re.search(p2, line2.strip()) if match1 and match2: Bus=match1.group(1) Dev=match1.group(2) Fn=match1.group(3) Name=match1.group(4) Id=match2.group(1) pciDict[\"name\"]=Name pciDict[\"bus\"]=Bus pciDict[\"dev\"]=Dev pciDict[\"fn\"]=Fn pciDict[\"id\"]=Id pciList.append(pciDict) pciDict=deepcopy(pciDict) else: print(\"CAN NOT MATCH PCIe DEVICE\") return pciList def check_pcie_sysfs(self, domain=0, bus=0, device=0, func=0): dev_path=os.path.join('/sys/bus/pci/devices', '%04x:%02x:%02x.%d' %(domain, bus, device, func)) if os.path.exists(dev_path): return True return False def get_pcie_check(self): self.load_config_file() for item_conf in self.confInfo: bus_conf=item_conf[\"bus\"] dev_conf=item_conf[\"dev\"] fn_conf=item_conf[\"fn\"] if self.check_pcie_sysfs(bus=int(bus_conf, base=16), device=int(dev_conf, base=16), func=int(fn_conf, base=16)): item_conf[\"result\"]=\"Passed\" else: item_conf[\"result\"]=\"Failed\" return self.confInfo def dump_conf_yaml(self): curInfo=self.get_pcie_device() with open(self.config_path +\"/\" +\"pcie.yaml\", \"w\") as conf_file: yaml.dump(curInfo, conf_file, default_flow_style=False) return ", "sourceWithComments": "# pcie_common.py\n# Common PCIE check interfaces for SONIC\n#\n\nimport os\nimport yaml\nimport subprocess\nimport re\nimport sys\nfrom copy import deepcopy\ntry:\n    from .pcie import PcieBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass PcieUtil(PcieBase):\n    \"\"\"Platform-specific PCIEutil class\"\"\"\n    # got the config file path\n    def __init__(self, path):\n        self.config_path = path\n\n    # load the config file\n    def load_config_file(self):\n        config_file = self.config_path + \"/\" + \"pcie.yaml\"\n        try:\n            with open(config_file) as conf_file:\n                self.confInfo = yaml.load(conf_file)\n        except IOError as e:\n            print(\"Error: {}\".format(str(e)))\n            print(\"Not found config file, please add a config file manually, or generate it by running [pcieutil pcie_generate]\")\n            sys.exit()\n\n    # load current PCIe device\n    def get_pcie_device(self):\n        pciDict = {}\n        pciList = []\n        p1 = \"^(\\w+):(\\w+)\\.(\\w)\\s(.*)\\s*\\(*.*\\)*\"\n        p2 = \"^.*:.*:.*:(\\w+)\\s*\\(*.*\\)*\"\n        command1 = \"sudo lspci\"\n        command2 = \"sudo lspci -n\"\n        # run command 1\n        proc1 = subprocess.Popen(command1, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n        output1 = proc1.stdout.readlines()\n        proc1.communicate()\n        # run command 2\n        proc2 = subprocess.Popen(command2, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n        output2 = proc2.stdout.readlines()\n        proc2.communicate()\n\n        if proc1.returncode > 0:\n            for line1 in output1:\n                print(line1.strip())\n            return\n        elif proc2.returncode > 0:\n            for line2 in output2:\n                print(line2.strip())\n            return\n        else:\n            for (line1, line2) in zip(output1, output2):\n                pciDict.clear()\n                match1 = re.search(p1, line1.strip())\n                match2 = re.search(p2, line2.strip())\n                if match1 and match2:\n                    Bus = match1.group(1)\n                    Dev = match1.group(2)\n                    Fn = match1.group(3)\n                    Name = match1.group(4)\n                    Id = match2.group(1)\n                    pciDict[\"name\"] = Name\n                    pciDict[\"bus\"] = Bus\n                    pciDict[\"dev\"] = Dev\n                    pciDict[\"fn\"] = Fn\n                    pciDict[\"id\"] = Id\n                    pciList.append(pciDict)\n                    pciDict = deepcopy(pciDict)\n                else:\n                    print(\"CAN NOT MATCH PCIe DEVICE\")\n        return pciList\n\n    # check the sysfs tree for each PCIe device\n    def check_pcie_sysfs(self, domain=0, bus=0, device=0, func=0):\n        dev_path = os.path.join('/sys/bus/pci/devices', '%04x:%02x:%02x.%d' % (domain, bus, device, func))\n        if os.path.exists(dev_path):\n            return True\n        return False\n\n    # check the current PCIe device with config file and return the result\n    def get_pcie_check(self):\n        self.load_config_file()\n        for item_conf in self.confInfo:\n            bus_conf = item_conf[\"bus\"]\n            dev_conf = item_conf[\"dev\"]\n            fn_conf = item_conf[\"fn\"]\n            if self.check_pcie_sysfs(bus=int(bus_conf, base=16), device=int(dev_conf, base=16), func=int(fn_conf, base=16)):\n                item_conf[\"result\"] = \"Passed\"\n            else:\n                item_conf[\"result\"] = \"Failed\"\n        return self.confInfo\n\n    # generate the config file with current pci device\n    def dump_conf_yaml(self):\n        curInfo = self.get_pcie_device()\n        with open(self.config_path + \"/\" + \"pcie.yaml\", \"w\") as conf_file:\n            yaml.dump(curInfo, conf_file, default_flow_style=False)\n        return\n\n"}, "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py": {"changes": [{"diff": "\n \n try:\n     import time\n-    import subprocess\n     from sonic_platform_base.chassis_base import ChassisBase\n     from sonic_platform.common import Common\n     from sonic_platform.sfp import Sfp\n     from sonic_platform.sfp import PORT_START\n     from sonic_platform.sfp import PORTS_IN_BLOCK\n     from sonic_platform.logger import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py", "badparts": ["    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         self.SFP_STATUS_INSERTED = \"1\"\n         self.SFP_STATUS_REMOVED = \"0\"\n         self.port_dict = {}\n-        self.enable_read= \"i2cset -f -y 2 0x35 0x2a 0x01\"\n-        self.disable_read = \"i2cset -f -y 2 0x35 0x2a 0x00\"\n-        self.enable_write = \"i2cset -f -y 2 0x35 0x2b 0x00\"\n-        self.disable_write = \"i2cset -f -y 2 0x35 0x2b 0x01\"\n-        self.enable_erase = \"i2cset -f -y 2 0x35 0x2c 0x01\"\n-        self.disable_erase = \"i2cset -f -y 2 0x35 0x2c 0x00\"\n-        self.read_value = \"i2cget -f -y 2 0x35 0x25\"\n-        self.write_value = \"i2cset -f -y 2 0x35 0x21 0x0a\"\n-        self.set_sys_led_cmd = \"i2cset -f -y 2 0x33 0xb2 \"\n-        self.get_sys_led_cmd = \"i2cget -f -y 2 0x33 0xb2\"\n-        self.led_status = \"red\"\n+        self.enable_read= [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x01\"]\n+        self.disable_read = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x00\"]\n+        self.enable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x00\"]\n+        self.disable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x01\"]\n+        self.enable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x01\"]\n+        self.disable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x00\"]\n+        self.read_value = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x25\"]\n+        self.write_value = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x21\", \"0x0a\"]\n+        self.set_sys_led_cmd = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]\n+        self.get_sys_led_cmd = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]\n+        self.led_status = \"red\" \n         # Initialize SFP list\n         # sfp.py will read eeprom contents and retrive the eeprom data.\n         # It will also provide support sfp controls like reset and setting\n", "add": 11, "remove": 11, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py", "badparts": ["        self.enable_read= \"i2cset -f -y 2 0x35 0x2a 0x01\"", "        self.disable_read = \"i2cset -f -y 2 0x35 0x2a 0x00\"", "        self.enable_write = \"i2cset -f -y 2 0x35 0x2b 0x00\"", "        self.disable_write = \"i2cset -f -y 2 0x35 0x2b 0x01\"", "        self.enable_erase = \"i2cset -f -y 2 0x35 0x2c 0x01\"", "        self.disable_erase = \"i2cset -f -y 2 0x35 0x2c 0x00\"", "        self.read_value = \"i2cget -f -y 2 0x35 0x25\"", "        self.write_value = \"i2cset -f -y 2 0x35 0x21 0x0a\"", "        self.set_sys_led_cmd = \"i2cset -f -y 2 0x33 0xb2 \"", "        self.get_sys_led_cmd = \"i2cget -f -y 2 0x33 0xb2\"", "        self.led_status = \"red\""], "goodparts": ["        self.enable_read= [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x01\"]", "        self.disable_read = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2a\", \"0x00\"]", "        self.enable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x00\"]", "        self.disable_write = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2b\", \"0x01\"]", "        self.enable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x01\"]", "        self.disable_erase = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x2c\", \"0x00\"]", "        self.read_value = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x25\"]", "        self.write_value = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x35\", \"0x21\", \"0x0a\"]", "        self.set_sys_led_cmd = [\"i2cset\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]", "        self.get_sys_led_cmd = [\"i2cget\", \"-f\", \"-y\", \"2\", \"0x33\", \"0xb2\"]", "        self.led_status = \"red\" "]}, {"diff": "\n         try:\n             is_power_loss = False\n             # enable read\n-            subprocess.getstatusoutput(self.disable_write)\n-            subprocess.getstatusoutput(self.enable_read)\n-            ret , log = subprocess.getstatusoutput(self.read_value)\n+            getstatusoutput_noshell(self.disable_write)\n+            getstatusoutput_noshell(self.enable_read)\n+            ret , log = getstatusoutput_noshell(self.read_value)\n             if ret == 0 and \"0x0a\" in log:\n                 is_power_loss = True\n \n             # erase i2c and e2\n-            subprocess.getstatusoutput(self.enable_erase)\n+            getstatusoutput_noshell(self.enable_erase)\n             time.sleep(1)\n-            subprocess.getstatusoutput(self.disable_erase)\n+            getstatusoutput_noshell(self.disable_erase)\n             # clear data\n-            subprocess.getstatusoutput(self.enable_write)\n-            subprocess.getstatusoutput(self.disable_read)\n-            subprocess.getstatusoutput(self.disable_write)\n-            subprocess.getstatusoutput(self.enable_read)\n+            getstatusoutput_noshell(self.enable_write)\n+            getstatusoutput_noshell(self.disable_read)\n+            getstatusoutput_noshell(self.disable_write)\n+            getstatusoutput_noshell(self.enable_read)\n             # enable write and set data\n-            subprocess.getstatusoutput(self.enable_write)\n-            subprocess.getstatusoutput(self.disable_read)\n-            subprocess.getstatusoutput(self.write_value)\n+            getstatusoutput_noshell(self.enable_write)\n+            getstatusoutput_noshell(self.disable_read)\n+            getstatusoutput_noshell(self.write_value)\n             if is_power_loss:\n                 return(self.REBOOT_CAUSE_POWER_LOSS, None)\n         except Exception as e:\n", "add": 12, "remove": 12, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py", "badparts": ["            subprocess.getstatusoutput(self.disable_write)", "            subprocess.getstatusoutput(self.enable_read)", "            ret , log = subprocess.getstatusoutput(self.read_value)", "            subprocess.getstatusoutput(self.enable_erase)", "            subprocess.getstatusoutput(self.disable_erase)", "            subprocess.getstatusoutput(self.enable_write)", "            subprocess.getstatusoutput(self.disable_read)", "            subprocess.getstatusoutput(self.disable_write)", "            subprocess.getstatusoutput(self.enable_read)", "            subprocess.getstatusoutput(self.enable_write)", "            subprocess.getstatusoutput(self.disable_read)", "            subprocess.getstatusoutput(self.write_value)"], "goodparts": ["            getstatusoutput_noshell(self.disable_write)", "            getstatusoutput_noshell(self.enable_read)", "            ret , log = getstatusoutput_noshell(self.read_value)", "            getstatusoutput_noshell(self.enable_erase)", "            getstatusoutput_noshell(self.disable_erase)", "            getstatusoutput_noshell(self.enable_write)", "            getstatusoutput_noshell(self.disable_read)", "            getstatusoutput_noshell(self.disable_write)", "            getstatusoutput_noshell(self.enable_read)", "            getstatusoutput_noshell(self.enable_write)", "            getstatusoutput_noshell(self.disable_read)", "            getstatusoutput_noshell(self.write_value)"]}, {"diff": "\n         if regval is None:\n             print(\"Invaild color input.\")\n             return False\n-        ret , log = subprocess.getstatusoutput(self.set_sys_led_cmd + regval)\n+        cmd = self.set_sys_led_cmd + [regval]\n+        ret, log = getstatusoutput_noshell(cmd)\n         if ret != 0:\n             print(\"Cannot execute %s\" % self.set_sys_led_cmd + regval)\n             return False\n", "add": 2, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py", "badparts": ["        ret , log = subprocess.getstatusoutput(self.set_sys_led_cmd + regval)"], "goodparts": ["        cmd = self.set_sys_led_cmd + [regval]", "        ret, log = getstatusoutput_noshell(cmd)"]}, {"diff": "\n             A string, one of the valid LED color strings which could be vendor\n             specified.\n         \"\"\"\n-        ret , log = subprocess.getstatusoutput(self.get_sys_led_cmd)\n+        ret , log = getstatusoutput_noshell(self.get_sys_led_cmd)\n         if ret != 0:\n             print(\"Cannot execute %s\" % self.get_sys_led_cmd)\n             return Fals", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/chassis.py", "badparts": ["        ret , log = subprocess.getstatusoutput(self.get_sys_led_cmd)"], "goodparts": ["        ret , log = getstatusoutput_noshell(self.get_sys_led_cmd)"]}], "source": "\n try: import time import subprocess from sonic_platform_base.chassis_base import ChassisBase from sonic_platform.common import Common from sonic_platform.sfp import Sfp from sonic_platform.sfp import PORT_START from sonic_platform.sfp import PORTS_IN_BLOCK from sonic_platform.logger import logger except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class Chassis(ChassisBase): \"\"\" Ruijie B6510-48VS8CQ Platform-specific Chassis class \"\"\" def __init__(self): ChassisBase.__init__(self) self.CHASSIS_CONFIG='chassis.json' self.THERMAL_CONFIG='thermal.json' self.SFP_CONFIG='sfp.json' self.PSU_CONFIG='psu.json' self.FAN_CONFIG='fan.json' self.COMPONENT_CONFIG='component.json' self.SFP_STATUS_INSERTED=\"1\" self.SFP_STATUS_REMOVED=\"0\" self.port_dict={} self.enable_read=\"i2cset -f -y 2 0x35 0x2a 0x01\" self.disable_read=\"i2cset -f -y 2 0x35 0x2a 0x00\" self.enable_write=\"i2cset -f -y 2 0x35 0x2b 0x00\" self.disable_write=\"i2cset -f -y 2 0x35 0x2b 0x01\" self.enable_erase=\"i2cset -f -y 2 0x35 0x2c 0x01\" self.disable_erase=\"i2cset -f -y 2 0x35 0x2c 0x00\" self.read_value=\"i2cget -f -y 2 0x35 0x25\" self.write_value=\"i2cset -f -y 2 0x35 0x21 0x0a\" self.set_sys_led_cmd=\"i2cset -f -y 2 0x33 0xb2 \" self.get_sys_led_cmd=\"i2cget -f -y 2 0x33 0xb2\" self.led_status=\"red\" for index in range(PORT_START, PORTS_IN_BLOCK): sfp_node=Sfp(index) self._sfp_list.append(sfp_node) if sfp_node.get_presence(): self.port_dict[index]=self.SFP_STATUS_INSERTED else: self.port_dict[index]=self.SFP_STATUS_REMOVED self._api_common=Common() config_path=self._api_common.get_config_path(self.CHASSIS_CONFIG) self._config=self._api_common.load_json_file(config_path) self.__initialize_eeprom() if self._api_common.is_host(): self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() else: self.__initialize_components() def __initialize_fan(self): from sonic_platform.fan import Fan from sonic_platform.fan_drawer import FanDrawer fan_config_path=self._api_common.get_config_path(self.FAN_CONFIG) self.fan_config=self._api_common.load_json_file(fan_config_path)[\"fans\"] if self.fan_config: drawer_fan_list=[] for index in range(0, len(self.fan_config)): fan=Fan(index, config=self.fan_config[index]) self._fan_list.append(fan) drawer_fan_list.append(fan) fan_drawer=FanDrawer(0, fan_list=drawer_fan_list) self._fan_drawer_list.append(fan_drawer) def __initialize_psu(self): from sonic_platform.psu import Psu psu_config_path=self._api_common.get_config_path(self.PSU_CONFIG) self.psu_config=self._api_common.load_json_file(psu_config_path)[\"psus\"] if self.psu_config: for index in range(0, len(self.psu_config)): psu=Psu(index, config=self.psu_config[index]) self._psu_list.append(psu) def __initialize_thermals(self): from sonic_platform.thermal import Thermal thermal_config_path=self._api_common.get_config_path(self.THERMAL_CONFIG) self.thermal_config=self._api_common.load_json_file(thermal_config_path)['thermals'] if self.thermal_config: for index in range(0, len(self.thermal_config)): thermal=Thermal(index, config=self.thermal_config[index]) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Eeprom self._eeprom=Eeprom(config=self._config[\"eeprom\"]) def __initialize_components(self): from sonic_platform.component import Component component_config_path=self._api_common.get_config_path(self.COMPONENT_CONFIG) self.component_config=self._api_common.load_json_file(component_config_path)['components'] if self.component_config: for index in range(0, len(self.component_config)): component=Component(index, config=self.component_config[index]) self._component_list.append(component) def _init_standard_config(self, conflist, class_name, objlist): for conf in conflist: obj=globals()[class_name](conf.get(\"name\"), config=conf) objlist.append(obj) def _init_by_hal(self, hal_interface): self.hal_interface=hal_interface self.hal_interface.get_fans() def get_name(self): \"\"\" Retrieves the name of the chassis Returns: string: The name of the chassis \"\"\" return self._eeprom.modelstr() def get_presence(self): \"\"\" Retrieves the presence of the chassis Returns: bool: True if chassis is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the chassis Returns: string: Model/part number of chassis \"\"\" return self._eeprom.part_number_str() def get_serial(self): \"\"\" Retrieves the serial number of the chassis(Service tag) Returns: string: Serial number of chassis \"\"\" return self._eeprom.serial_str() def get_status(self): \"\"\" Retrieves the operational status of the chassis Returns: bool: A boolean value, True if chassis is operating properly False if not \"\"\" return True def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.base_mac_addr() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.system_eeprom_info() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" try: is_power_loss=False subprocess.getstatusoutput(self.disable_write) subprocess.getstatusoutput(self.enable_read) ret, log=subprocess.getstatusoutput(self.read_value) if ret==0 and \"0x0a\" in log: is_power_loss=True subprocess.getstatusoutput(self.enable_erase) time.sleep(1) subprocess.getstatusoutput(self.disable_erase) subprocess.getstatusoutput(self.enable_write) subprocess.getstatusoutput(self.disable_read) subprocess.getstatusoutput(self.disable_write) subprocess.getstatusoutput(self.enable_read) subprocess.getstatusoutput(self.enable_write) subprocess.getstatusoutput(self.disable_read) subprocess.getstatusoutput(self.write_value) if is_power_loss: return(self.REBOOT_CAUSE_POWER_LOSS, None) except Exception as e: logger.error(str(e)) return(self.REBOOT_CAUSE_NON_HARDWARE, None) def get_change_event(self, timeout=0): \"\"\" Returns a nested dictionary containing all devices which have experienced a change at chassis level Args: timeout: Timeout in milliseconds(optional). If timeout==0, this method will block until a change is detected. Returns: (bool, dict): -True if call successful, False if not; -A nested dictionary where key is a device type, value is a dictionary with key:value pairs in the format of {'device_id':'device_event'}, where device_id is the device ID for this device and device_event, status='1' represents device inserted, status='0' represents device removed. Ex.{'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}} indicates that fan 0 has been removed, fan 2 has been inserted and sfp 11 has been removed. Specifically for SFP event, besides SFP plug in and plug out, there are some other error event could be raised from SFP, when these error happened, SFP eeprom will not be avalaible, XCVRD shall stop to read eeprom before SFP recovered from error status. status='2' I2C bus stuck, status='3' Bad eeprom, status='4' Unsupported cable, status='5' High Temperature, status='6' Bad cable. \"\"\" change_event_dict={\"fan\":{}, \"sfp\":{}} sfp_status, sfp_change_dict=self.get_transceiver_change_event(timeout) change_event_dict[\"sfp\"]=sfp_change_dict if sfp_status is True: return True, change_event_dict return False,{} def get_transceiver_change_event(self, timeout=0): start_time=time.time() currernt_port_dict={} forever=False if timeout==0: forever=True elif timeout > 0: timeout=timeout / float(1000) else: print(\"get_transceiver_change_event:Invalid timeout value\", timeout) return False,{} end_time=start_time +timeout if start_time > end_time: print( \"get_transceiver_change_event:\" \"time wrap / invalid timeout value\", timeout, ) return False,{} while timeout >=0: for index in range(PORT_START, PORTS_IN_BLOCK): if self._sfp_list[index].get_presence(): currernt_port_dict[index]=self.SFP_STATUS_INSERTED else: currernt_port_dict[index]=self.SFP_STATUS_REMOVED if currernt_port_dict==self.port_dict: if forever: time.sleep(1) else: timeout=end_time -time.time() if timeout >=1: time.sleep(1) else: if timeout > 0: time.sleep(timeout) return True,{} else: self.port_dict=currernt_port_dict print(self.port_dict) return True, self.port_dict print(\"get_transceiver_change_event: Should not reach here.\") return False,{} def get_all_components(self): return self._component_list def get_all_fans(self): return self._fan_list def get_all_psus(self): return self._psu_list def get_all_thermals(self): return self._thermal_list def get_supervisor_slot(self): \"\"\" Retrieves the physical-slot of the supervisor-module in the modular chassis. On the supervisor or line-card modules, it will return the physical-slot of the supervisor-module. On the fixed-platforms, the API can be ignored. Users of the API can catch the exception and return a default ModuleBase.MODULE_INVALID_SLOT and bypass code for fixed-platforms. Returns: An integer, the vendor specific physical slot identifier of the supervisor module in the modular-chassis. \"\"\" return 0 def get_my_slot(self): \"\"\" Retrieves the physical-slot of this module in the modular chassis. On the supervisor, it will return the physical-slot of the supervisor module. On the linecard, it will return the physical-slot of the linecard module where this instance of SONiC is running. On the fixed-platforms, the API can be ignored. Users of the API can catch the exception and return a default ModuleBase.MODULE_INVALID_SLOT and bypass code for fixed-platforms. Returns: An integer, the vendor specific physical slot identifier of this module in the modular-chassis. \"\"\" return 0 def is_modular_chassis(self): \"\"\" Retrieves whether the sonic instance is part of modular chassis Returns: A bool value, should return False by default or for fixed-platforms. Should return True for supervisor-cards, line-cards etc running as part of modular-chassis. \"\"\" return True def init_midplane_switch(self): \"\"\" Initializes the midplane functionality of the modular chassis. For example, any validation of midplane, populating any lookup tables etc can be done here. The expectation is that the required kernel modules, ip-address assignment etc are done before the pmon, database dockers are up. Returns: A bool value, should return True if the midplane initialized successfully. \"\"\" return True def get_module_index(self, module_name): \"\"\" Retrieves module index from the module name Args: module_name: A string, prefixed by SUPERVISOR, LINE-CARD or FABRIC-CARD Ex. SUPERVISOR0, LINE-CARD1, FABRIC-CARD5 Returns: An integer, the index of the ModuleBase object in the module_list \"\"\" return 0 def set_status_led(self, color): \"\"\" Sets the state of the system LED Args: color: A string representing the color with which to set the system LED Returns: bool: True if system LED state is set successfully, False if not \"\"\" colors={ \"amber\": \"0x00\", \"red\": \"0x02\", \"green\": \"0x04\" } regval=colors.get(color, None) if regval is None: print(\"Invaild color input.\") return False ret, log=subprocess.getstatusoutput(self.set_sys_led_cmd +regval) if ret !=0: print(\"Cannot execute %s\" % self.set_sys_led_cmd +regval) return False self.led_status=color return True def get_status_led(self): \"\"\" Gets the state of the system LED Returns: A string, one of the valid LED color strings which could be vendor specified. \"\"\" ret, log=subprocess.getstatusoutput(self.get_sys_led_cmd) if ret !=0: print(\"Cannot execute %s\" % self.get_sys_led_cmd) return False colors={ \"0x00\": \"amber\", \"0x02\": \"red\", \"0x04\": \"green\" } color=colors.get(log, None) if color is None: return \"Unknown color status\" self.led_status=color return self.led_status ", "sourceWithComments": "# -*- coding: utf-8 -*-\n\n#############################################################################\n# Ruijie B6510-48VS8CQ\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the platform information\n#\n#############################################################################\n\ntry:\n    import time\n    import subprocess\n    from sonic_platform_base.chassis_base import ChassisBase\n    from sonic_platform.common import Common\n    from sonic_platform.sfp import Sfp\n    from sonic_platform.sfp import PORT_START\n    from sonic_platform.sfp import PORTS_IN_BLOCK\n    from sonic_platform.logger import logger\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nclass Chassis(ChassisBase):\n    \"\"\"\n    Ruijie B6510-48VS8CQ Platform-specific Chassis class\n    \"\"\"\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self.CHASSIS_CONFIG = 'chassis.json'\n        self.THERMAL_CONFIG = 'thermal.json'\n        self.SFP_CONFIG = 'sfp.json'\n        self.PSU_CONFIG = 'psu.json'\n        self.FAN_CONFIG = 'fan.json'\n        self.COMPONENT_CONFIG = 'component.json'\n\n        self.SFP_STATUS_INSERTED = \"1\"\n        self.SFP_STATUS_REMOVED = \"0\"\n        self.port_dict = {}\n        self.enable_read= \"i2cset -f -y 2 0x35 0x2a 0x01\"\n        self.disable_read = \"i2cset -f -y 2 0x35 0x2a 0x00\"\n        self.enable_write = \"i2cset -f -y 2 0x35 0x2b 0x00\"\n        self.disable_write = \"i2cset -f -y 2 0x35 0x2b 0x01\"\n        self.enable_erase = \"i2cset -f -y 2 0x35 0x2c 0x01\"\n        self.disable_erase = \"i2cset -f -y 2 0x35 0x2c 0x00\"\n        self.read_value = \"i2cget -f -y 2 0x35 0x25\"\n        self.write_value = \"i2cset -f -y 2 0x35 0x21 0x0a\"\n        self.set_sys_led_cmd = \"i2cset -f -y 2 0x33 0xb2 \"\n        self.get_sys_led_cmd = \"i2cget -f -y 2 0x33 0xb2\"\n        self.led_status = \"red\"\n        # Initialize SFP list\n        # sfp.py will read eeprom contents and retrive the eeprom data.\n        # It will also provide support sfp controls like reset and setting\n        # low power mode.\n        # We pass the eeprom path and sfp control path from chassis.py\n        # So that sfp.py implementation can be generic to all platforms\n        for index in range(PORT_START, PORTS_IN_BLOCK):\n            sfp_node = Sfp(index)\n            self._sfp_list.append(sfp_node)\n            if sfp_node.get_presence():\n                self.port_dict[index] = self.SFP_STATUS_INSERTED\n            else:\n                self.port_dict[index] = self.SFP_STATUS_REMOVED\n\n        self._api_common = Common()\n        config_path = self._api_common.get_config_path(self.CHASSIS_CONFIG)\n        self._config = self._api_common.load_json_file(config_path)\n        self.__initialize_eeprom()\n\n        if self._api_common.is_host():\n            self.__initialize_fan()\n            self.__initialize_psu()\n            self.__initialize_thermals()\n        else:\n            self.__initialize_components()\n\n    def __initialize_fan(self):\n        from sonic_platform.fan import Fan\n        from sonic_platform.fan_drawer import FanDrawer\n\n        fan_config_path = self._api_common.get_config_path(self.FAN_CONFIG)\n        self.fan_config = self._api_common.load_json_file(fan_config_path)[\"fans\"]\n\n        if self.fan_config:\n            drawer_fan_list = []\n            for index in range(0, len(self.fan_config)):\n                fan = Fan(index, config=self.fan_config[index])\n                self._fan_list.append(fan)\n                drawer_fan_list.append(fan)\n            fan_drawer = FanDrawer(0, fan_list=drawer_fan_list)\n            self._fan_drawer_list.append(fan_drawer)\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n\n        psu_config_path = self._api_common.get_config_path(self.PSU_CONFIG)\n        self.psu_config = self._api_common.load_json_file(psu_config_path)[\"psus\"]\n\n        if self.psu_config:\n            for index in range(0, len(self.psu_config)):\n                psu = Psu(index, config=self.psu_config[index])\n                self._psu_list.append(psu)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n\n        thermal_config_path = self._api_common.get_config_path(self.THERMAL_CONFIG)\n        self.thermal_config = self._api_common.load_json_file(thermal_config_path)['thermals']\n\n        if self.thermal_config:\n            for index in range(0, len(self.thermal_config)):\n                thermal = Thermal(index, config=self.thermal_config[index])\n                self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Eeprom\n        self._eeprom = Eeprom(config=self._config[\"eeprom\"])\n\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n\n        component_config_path = self._api_common.get_config_path(self.COMPONENT_CONFIG)\n        self.component_config = self._api_common.load_json_file(component_config_path)['components']\n\n        if self.component_config:\n            for index in range(0, len(self.component_config)):\n                component = Component(index, config=self.component_config[index])\n                self._component_list.append(component)\n\n    def _init_standard_config(self, conflist, class_name, objlist):\n        for conf in conflist:\n            obj = globals()[class_name](conf.get(\"name\"), config=conf)\n            objlist.append(obj)\n\n    def _init_by_hal(self, hal_interface):\n        self.hal_interface = hal_interface\n        self.hal_interface.get_fans()\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the chassis\n        Returns:\n            string: The name of the chassis\n        \"\"\"\n        return self._eeprom.modelstr()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the chassis\n        Returns:\n            bool: True if chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the chassis\n        Returns:\n            string: Model/part number of chassis\n        \"\"\"\n        return self._eeprom.part_number_str()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the chassis (Service tag)\n        Returns:\n            string: Serial number of chassis\n        \"\"\"\n        return self._eeprom.serial_str()\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the chassis\n        Returns:\n            bool: A boolean value, True if chassis is operating properly\n            False if not\n        \"\"\"\n        return True\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.base_mac_addr()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.system_eeprom_info()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        try:\n            is_power_loss = False\n            # enable read\n            subprocess.getstatusoutput(self.disable_write)\n            subprocess.getstatusoutput(self.enable_read)\n            ret , log = subprocess.getstatusoutput(self.read_value)\n            if ret == 0 and \"0x0a\" in log:\n                is_power_loss = True\n\n            # erase i2c and e2\n            subprocess.getstatusoutput(self.enable_erase)\n            time.sleep(1)\n            subprocess.getstatusoutput(self.disable_erase)\n            # clear data\n            subprocess.getstatusoutput(self.enable_write)\n            subprocess.getstatusoutput(self.disable_read)\n            subprocess.getstatusoutput(self.disable_write)\n            subprocess.getstatusoutput(self.enable_read)\n            # enable write and set data\n            subprocess.getstatusoutput(self.enable_write)\n            subprocess.getstatusoutput(self.disable_read)\n            subprocess.getstatusoutput(self.write_value)\n            if is_power_loss:\n                return(self.REBOOT_CAUSE_POWER_LOSS, None)\n        except Exception as e:\n            logger.error(str(e))\n\n        return (self.REBOOT_CAUSE_NON_HARDWARE, None)\n\n    def get_change_event(self, timeout=0):\n        \"\"\"\n        Returns a nested dictionary containing all devices which have\n        experienced a change at chassis level\n\n        Args:\n            timeout: Timeout in milliseconds (optional). If timeout == 0,\n                this method will block until a change is detected.\n\n        Returns:\n            (bool, dict):\n                - True if call successful, False if not;\n                - A nested dictionary where key is a device type,\n                  value is a dictionary with key:value pairs in the format of\n                  {'device_id':'device_event'},\n                  where device_id is the device ID for this device and\n                        device_event,\n                             status='1' represents device inserted,\n                             status='0' represents device removed.\n                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}\n                      indicates that fan 0 has been removed, fan 2\n                      has been inserted and sfp 11 has been removed.\n                  Specifically for SFP event, besides SFP plug in and plug out,\n                  there are some other error event could be raised from SFP, when\n                  these error happened, SFP eeprom will not be avalaible, XCVRD shall\n                  stop to read eeprom before SFP recovered from error status.\n                      status='2' I2C bus stuck,\n                      status='3' Bad eeprom,\n                      status='4' Unsupported cable,\n                      status='5' High Temperature,\n                      status='6' Bad cable.\n        \"\"\"\n        change_event_dict = {\"fan\": {}, \"sfp\": {}}\n        sfp_status, sfp_change_dict = self.get_transceiver_change_event(timeout)\n        change_event_dict[\"sfp\"] = sfp_change_dict\n        if sfp_status is True:\n            return True, change_event_dict\n\n        return False, {}\n\n    def get_transceiver_change_event(self, timeout=0):\n\n        start_time = time.time()\n        currernt_port_dict = {}\n        forever = False\n\n        if timeout == 0:\n            forever = True\n        elif timeout > 0:\n            timeout = timeout / float(1000)  # Convert to secs\n        else:\n            print(\"get_transceiver_change_event:Invalid timeout value\", timeout)\n            return False, {}\n\n        end_time = start_time + timeout\n        if start_time > end_time:\n            print(\n                \"get_transceiver_change_event:\" \"time wrap / invalid timeout value\",\n                timeout,\n            )\n            return False, {}  # Time wrap or possibly incorrect timeout\n\n        while timeout >= 0:\n            # Check for OIR events and return updated port_dict\n            for index in range(PORT_START, PORTS_IN_BLOCK):\n                if self._sfp_list[index].get_presence():\n                    currernt_port_dict[index] = self.SFP_STATUS_INSERTED\n                else:\n                    currernt_port_dict[index] = self.SFP_STATUS_REMOVED\n            if currernt_port_dict == self.port_dict:\n                if forever:\n                    time.sleep(1)\n                else:\n                    timeout = end_time - time.time()\n                    if timeout >= 1:\n                        time.sleep(1)  # We poll at 1 second granularity\n                    else:\n                        if timeout > 0:\n                            time.sleep(timeout)\n                        return True, {}\n            else:\n                # Update reg value\n                self.port_dict = currernt_port_dict\n                print(self.port_dict)\n                return True, self.port_dict\n        print(\"get_transceiver_change_event: Should not reach here.\")\n        return False, {}\n\n    def get_all_components(self):\n        return self._component_list\n\n    def get_all_fans(self):\n        return self._fan_list\n\n    def get_all_psus(self):\n        return self._psu_list\n\n    def get_all_thermals(self):\n        return self._thermal_list\n\n    def get_supervisor_slot(self):\n        \"\"\"\n        Retrieves the physical-slot of the supervisor-module in the modular\n        chassis. On the supervisor or line-card modules, it will return the\n        physical-slot of the supervisor-module.\n        On the fixed-platforms, the API can be ignored.\n        Users of the API can catch the exception and return a default\n        ModuleBase.MODULE_INVALID_SLOT and bypass code for fixed-platforms.\n        Returns:\n            An integer, the vendor specific physical slot identifier of the\n            supervisor module in the modular-chassis.\n        \"\"\"\n        return 0\n\n    def get_my_slot(self):\n        \"\"\"\n        Retrieves the physical-slot of this module in the modular chassis.\n        On the supervisor, it will return the physical-slot of the supervisor\n        module. On the linecard, it will return the physical-slot of the\n        linecard module where this instance of SONiC is running.\n        On the fixed-platforms, the API can be ignored.\n        Users of the API can catch the exception and return a default\n        ModuleBase.MODULE_INVALID_SLOT and bypass code for fixed-platforms.\n        Returns:\n            An integer, the vendor specific physical slot identifier of this\n            module in the modular-chassis.\n        \"\"\"\n        return 0\n\n    def is_modular_chassis(self):\n        \"\"\"\n        Retrieves whether the sonic instance is part of modular chassis\n        Returns:\n            A bool value, should return False by default or for fixed-platforms.\n            Should return True for supervisor-cards, line-cards etc running as part\n            of modular-chassis.\n        \"\"\"\n        return True\n\n    def init_midplane_switch(self):\n        \"\"\"\n        Initializes the midplane functionality of the modular chassis. For\n        example, any validation of midplane, populating any lookup tables etc\n        can be done here. The expectation is that the required kernel modules,\n        ip-address assignment etc are done before the pmon, database dockers\n        are up.\n        Returns:\n            A bool value, should return True if the midplane initialized\n            successfully.\n        \"\"\"\n        return True\n\n    def get_module_index(self, module_name):\n        \"\"\"\n        Retrieves module index from the module name\n        Args:\n            module_name: A string, prefixed by SUPERVISOR, LINE-CARD or FABRIC-CARD\n            Ex. SUPERVISOR0, LINE-CARD1, FABRIC-CARD5\n        Returns:\n            An integer, the index of the ModuleBase object in the module_list\n        \"\"\"\n        return 0\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the system LED\n        Args:\n            color: A string representing the color with which to set the\n                   system LED\n        Returns:\n            bool: True if system LED state is set successfully, False if not\n        \"\"\"\n        colors = {\n            \"amber\" : \"0x00\",\n            \"red\" : \"0x02\",\n            \"green\" : \"0x04\"\n        }\n        regval = colors.get(color, None)\n        if regval is None:\n            print(\"Invaild color input.\")\n            return False\n        ret , log = subprocess.getstatusoutput(self.set_sys_led_cmd + regval)\n        if ret != 0:\n            print(\"Cannot execute %s\" % self.set_sys_led_cmd + regval)\n            return False\n        self.led_status = color\n        return True\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the system LED\n        Returns:\n            A string, one of the valid LED color strings which could be vendor\n            specified.\n        \"\"\"\n        ret , log = subprocess.getstatusoutput(self.get_sys_led_cmd)\n        if ret != 0:\n            print(\"Cannot execute %s\" % self.get_sys_led_cmd)\n            return False\n        colors = {\n            \"0x00\" : \"amber\",\n            \"0x02\" : \"red\",\n            \"0x04\" : \"green\"\n        }\n        color = colors.get(log, None)\n        if color is None:\n            return \"Unknown color status\"\n        self.led_status = color\n        return self.led_status\n\n"}, "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py": {"changes": [{"diff": "\n     PMON_PLATFORM_PATH = '/usr/share/sonic/platform/'\n     CONFIG_DIR = 'sonic_platform_config'\n \n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        return subprocess.call(self.HOST_CHK_CMD) == 0\n \n     def load_json_file(self, path):\n         \"", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/common.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"", "        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]", "        return subprocess.call(self.HOST_CHK_CMD) == 0"]}], "source": "\nimport os import yaml from sonic_py_common import device_info class Common: DEVICE_PATH='/usr/share/sonic/device/' PMON_PLATFORM_PATH='/usr/share/sonic/platform/' CONFIG_DIR='sonic_platform_config' HOST_CHK_CMD=\"docker > /dev/null 2>&1\" def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(self.HOST_CHK_CMD)==0 def load_json_file(self, path): \"\"\" Retrieves the json object from json file path Returns: A json object \"\"\" with open(path, 'r') as f: json_data=yaml.safe_load(f) return json_data def get_config_path(self, config_name): \"\"\" Retrieves the path to platform api config directory Args: config_name: A string containing the name of config file. Returns: A string containing the path to json file \"\"\" return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name) ", "sourceWithComments": "import os\nimport yaml\n\nfrom sonic_py_common import device_info\n\n\nclass Common:\n\n    DEVICE_PATH = '/usr/share/sonic/device/'\n    PMON_PLATFORM_PATH = '/usr/share/sonic/platform/'\n    CONFIG_DIR = 'sonic_platform_config'\n\n    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def load_json_file(self, path):\n        \"\"\"\n        Retrieves the json object from json file path\n\n        Returns:\n            A json object\n        \"\"\"\n        with open(path, 'r') as f:\n            json_data = yaml.safe_load(f)\n\n        return json_data\n\n    def get_config_path(self, config_name):\n        \"\"\"\n        Retrieves the path to platform api config directory\n\n        Args:\n            config_name: A string containing the name of config file.\n\n        Returns:\n            A string containing the path to json file\n        \"\"\"\n        return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\n\n"}, "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py": {"changes": [{"diff": "\n ########################################################################\n \n try:\n-    import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n     from sonic_platform.regutil import Reg\n     from sonic_platform.logger import logger\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py", "badparts": ["    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         \"\"\"\n         try:\n             successtips = \"CPLD Upgrade succeeded!\"\n-            status, output = subprocess.getstatusoutput(\"which firmware_upgrade\")\n+            status, output = getstatusoutput_noshell([\"which\", \"firmware_upgrade\"])\n             if status or len(output) <= 0:\n                 logger.error(\"no upgrade tool.\")\n                 return False\n-            cmdstr = \"%s %s cpld %d cpld\"%(output,image_path,self.slot)\n-            ret, log = subprocess.getstatusoutput(cmdstr)\n+            cmdstr = [output, image_path, \"cpld\", self.slot, \"cpld\"]\n+            ret, log = getstatusoutput_noshell(cmdstr)\n             if ret == 0 and successtips in log:\n                 return True\n             logger.error(\"upgrade failed. ret:%d, log:\\n%s\" % (ret, lo", "add": 3, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/b6510-48vs8cq/sonic_platform/component.py", "badparts": ["            status, output = subprocess.getstatusoutput(\"which firmware_upgrade\")", "            cmdstr = \"%s %s cpld %d cpld\"%(output,image_path,self.slot)", "            ret, log = subprocess.getstatusoutput(cmdstr)"], "goodparts": ["            status, output = getstatusoutput_noshell([\"which\", \"firmware_upgrade\"])", "            cmdstr = [output, image_path, \"cpld\", self.slot, \"cpld\"]", "            ret, log = getstatusoutput_noshell(cmdstr)"]}], "source": "\n try: import subprocess from sonic_platform_base.component_base import ComponentBase from sonic_platform.regutil import Reg from sonic_platform.logger import logger except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class Component(ComponentBase): \"\"\"Ruijie Platform-specific Component class\"\"\" def __init__(self, index, config=None): self.index=index self.name=config.get(\"name\") self._reg_fm_ver=Reg(config.get(\"firmware_version\")) self.description=config.get(\"desc\") self.slot=config.get(\"slot\") def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return self.name def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return self.description def get_firmware_version(self): \"\"\" Retrieves the firmware version of the component Returns: A string containing the firmware version of the component \"\"\" try: return self._reg_fm_ver.decode() except Exception as e: logger.error(str(e)) return \"\" def install_firmware(self, image_path): \"\"\" Installs firmware to the component Args: image_path: A string, path to firmware image Returns: A boolean, True if install was successful, False if not \"\"\" try: successtips=\"CPLD Upgrade succeeded!\" status, output=subprocess.getstatusoutput(\"which firmware_upgrade\") if status or len(output) <=0: logger.error(\"no upgrade tool.\") return False cmdstr=\"%s %s cpld %d cpld\"%(output,image_path,self.slot) ret, log=subprocess.getstatusoutput(cmdstr) if ret==0 and successtips in log: return True logger.error(\"upgrade failed. ret:%d, log:\\n%s\" %(ret, log)) except Exception as e: logger.error(str(e)) return False ", "sourceWithComments": "########################################################################\n# Ruijie B6510-48VS8CQ\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Components' (e.g., BIOS, CPLD, FPGA, etc.) available in\n# the platform\n#\n########################################################################\n\ntry:\n    import subprocess\n    from sonic_platform_base.component_base import ComponentBase\n    from sonic_platform.regutil import Reg\n    from sonic_platform.logger import logger\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass Component(ComponentBase):\n    \"\"\"Ruijie Platform-specific Component class\"\"\"\n\n    def __init__(self, index, config=None):\n        self.index = index\n        self.name = config.get(\"name\")\n        self._reg_fm_ver = Reg(config.get(\"firmware_version\"))\n        self.description = config.get(\"desc\")\n        self.slot = config.get(\"slot\")\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n\n        Returns:\n            A string containing the name of the component\n        \"\"\"\n        return self.name\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n\n        Returns:\n            A string containing the description of the component\n        \"\"\"\n        return self.description\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of the component\n\n        Returns:\n            A string containing the firmware version of the component\n        \"\"\"\n        try:\n            return self._reg_fm_ver.decode()\n        except Exception as e:\n            logger.error(str(e))\n\n        return \"\"\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Installs firmware to the component\n\n        Args:\n            image_path: A string, path to firmware image\n\n        Returns:\n            A boolean, True if install was successful, False if not\n        \"\"\"\n        try:\n            successtips = \"CPLD Upgrade succeeded!\"\n            status, output = subprocess.getstatusoutput(\"which firmware_upgrade\")\n            if status or len(output) <= 0:\n                logger.error(\"no upgrade tool.\")\n                return False\n            cmdstr = \"%s %s cpld %d cpld\"%(output,image_path,self.slot)\n            ret, log = subprocess.getstatusoutput(cmdstr)\n            if ret == 0 and successtips in log:\n                return True\n            logger.error(\"upgrade failed. ret:%d, log:\\n%s\" % (ret, log))\n        except Exception as e:\n            logger.error(str(e))\n        return False\n        \n"}, "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py": {"changes": [{"diff": "\n #\n #######################################################\n \n-import subprocess\n import time\n import glob\n import re\n", "add": 0, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["import subprocess"], "goodparts": []}, {"diff": "\n \n     @staticmethod\n     def command(cmdstr):\n-        retcode, output = subprocess.getstatusoutput(cmdstr)\n+        retcode, output = getstatusoutput_noshell(cmdstr)\n         return retcode, output\n \n \n     @staticmethod\n     def geti2cword_i2ctool(bus, addr, offset):\n-        command_line = \"i2cget -f -y %d 0x%02x 0x%02x  wp\" % (bus, addr, offset)\n+        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%02x\"%offset, \"wp\"]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        retcode, output = subprocess.getstatusoutput(cmdstr)", "        command_line = \"i2cget -f -y %d 0x%02x 0x%02x  wp\" % (bus, addr, offset)"], "goodparts": ["        retcode, output = getstatusoutput_noshell(cmdstr)", "        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%02x\"%offset, \"wp\"]"]}, {"diff": "\n \n     @staticmethod\n     def seti2cword_i2ctool(bus, addr, offset, val):\n-        command_line = \"i2cset -f -y %d 0x%02x 0x%0x 0x%04x wp\" % (bus, addr, offset, val)\n+        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%0x\"%offset, \"0x%04x\"%val, \"wp\"]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        command_line = \"i2cset -f -y %d 0x%02x 0x%0x 0x%04x wp\" % (bus, addr, offset, val)"], "goodparts": ["        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%addr, \"0x%0x\"%offset, \"0x%04x\"%val, \"wp\"]"]}, {"diff": "\n \n     @staticmethod\n     def rji2cget_i2ctool(bus, devno, address):\n-        command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)\n+        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)"], "goodparts": ["        command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address]"]}, {"diff": "\n \n     @staticmethod\n     def rji2cset_i2ctool(bus, devno, address, byte):\n-        command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (\n-            bus, devno, address, byte)\n+        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address, \"0x%02x\"%byte]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n", "add": 1, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (", "            bus, devno, address, byte)"], "goodparts": ["        command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%devno, \"0x%02x\"%address, \"0x%02x\"%byte]"]}, {"diff": "\n \n     @staticmethod\n     def getdevmem(addr, digit, mask):\n-        command_line = \"devmem 0x%02x %d\" %(addr, digit)\n+        command_line = [\"devmem\", \"0x%02x\"%addr, str(digit)]\n         retrytime = 6\n         ret_t = \"\"\n         for i in range(retrytime):\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        command_line = \"devmem 0x%02x %d\" %(addr, digit)"], "goodparts": ["        command_line = [\"devmem\", \"0x%02x\"%addr, str(digit)]"]}, {"diff": "\n \n     @staticmethod\n     def rj_os_system(cmd):\n-        status, output = subprocess.getstatusoutput(cmd)\n+        status, output = getstatusoutput_noshell(cmd)\n         return status, output\n \n     @staticmethod\n     def getsdkreg(reg):\n         try:\n-            cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg\n+            cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]\n             ret, result = osutil.rj_os_system(cmd)\n             result_t = result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n             if ret != 0 or \"Error:\" in result_t:\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["        status, output = subprocess.getstatusoutput(cmd)", "            cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg"], "goodparts": ["        status, output = getstatusoutput_noshell(cmd)", "            cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]"]}, {"diff": "\n             result = {}\n             #waitForDocker()\n             #need to exec twice\n-            osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n-            ret, log = osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n+            osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n+            ret, log = osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n             if ret:\n                 return False, result\n             e", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/lib/plat_hal/osutil.py", "badparts": ["            osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")", "            ret, log = osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")"], "goodparts": ["            osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])", "            ret, log = osutil.rj_os_system([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])"]}], "source": "\n import subprocess import time import glob import re from rjutil.smbus import SMBus import time from functools import wraps def retry(maxretry=6, delay=0.01): ''' maxretry: max retry times delay : interval after last retry ''' def decorator(f): @wraps(f) def wrapper(*args, **kwargs): time_retry=maxretry time_delay=delay result_msg=\"\" while time_retry: try: val, result_msg=f(*args, **kwargs) if val is False: time_retry -=1 time.sleep(time_delay) continue else: return val, result_msg except Exception as e: time_retry -=1 result_msg=str(e) time.sleep(time_delay) return False, \"max time retry last errmsg is{}\".format(result_msg) return wrapper return decorator class osutil(object): \"\"\" osutil \"\"\" @staticmethod @retry(maxretry=6) def rji2cget_python(bus, addr, reg): with SMBus(bus) as y: val, ind =y.read_byte_data(addr, reg, True) return val, ind @staticmethod @retry(maxretry=6) def rji2cset_python(bus, addr, reg, value): with SMBus(bus) as y: val, ind =y.write_byte_data(addr, reg, value, True) return val, ind @staticmethod @retry(maxretry=6) def rji2cgetword_python(bus, addr, reg): with SMBus(bus) as y: val, ind =y.read_word_data(addr, reg, True) return val, ind @staticmethod @retry(maxretry=6) def rji2csetword_python(bus, addr, reg, value): with SMBus(bus) as y: val, ind =y.write_word_data(addr, reg, value, True) return val, ind @staticmethod def command(cmdstr): retcode, output=subprocess.getstatusoutput(cmdstr) return retcode, output @staticmethod def geti2cword_i2ctool(bus, addr, offset): command_line=\"i2cget -f -y %d 0x%02x 0x%02x wp\" %(bus, addr, offset) retrytime=6 ret_t=\"\" for i in range(retrytime): ret, ret_t=osutil.command(command_line) if ret==0: return True, int(ret_t, 16) time.sleep(0.1) return False, ret_t @staticmethod def seti2cword_i2ctool(bus, addr, offset, val): command_line=\"i2cset -f -y %d 0x%02x 0x%0x 0x%04x wp\" %(bus, addr, offset, val) retrytime=6 ret_t=\"\" for i in range(retrytime): ret, ret_t=osutil.command(command_line) if ret==0: return True, ret_t time.sleep(0.1) return False, ret_t @staticmethod def rji2cget_i2ctool(bus, devno, address): command_line=\"i2cget -f -y %d 0x%02x 0x%02x \" %(bus, devno, address) retrytime=6 ret_t=\"\" for i in range(retrytime): ret, ret_t=osutil.command(command_line) if ret==0: return True, int(ret_t, 16) time.sleep(0.1) return False, ret_t @staticmethod def rji2cset_i2ctool(bus, devno, address, byte): command_line=\"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" %( bus, devno, address, byte) retrytime=6 ret_t=\"\" for i in range(retrytime): ret, ret_t=osutil.command(command_line) if ret==0: return True, ret_t return False, ret_t @staticmethod def geti2cword(bus, addr, offset): return osutil.rji2cgetword_python(bus, addr, offset) @staticmethod def seti2cword(bus, addr, offset, val): return osutil.rji2csetword_python(bus, addr, offset, val) @staticmethod def rji2cget(bus, devno, address): return osutil.rji2cget_python(bus, devno, address) @staticmethod def rji2cset(bus, devno, address, byte): return osutil.rji2cset_python(bus, devno, address, byte) @staticmethod def byteTostr(val): strtmp='' for i in range(len(val)): strtmp +=chr(val[i]) return strtmp @staticmethod def readsysfs(location): try: locations=glob.glob(location) with open(locations[0], 'rb') as fd1: retval=fd1.read() retval=retval.strip() except Exception as e: return False,(str(e)+\" location[%s]\" % location) return True, retval.decode(\"utf-8\", \"ignore\") @staticmethod def getdevmem(addr, digit, mask): command_line=\"devmem 0x%02x %d\" %(addr, digit) retrytime=6 ret_t=\"\" for i in range(retrytime): ret, ret_t=osutil.command(command_line) if ret==0: if mask !=None: ret_t=str(int(ret_t, 16) & mask) return True, ret_t return False, ret_t @staticmethod def rj_os_system(cmd): status, output=subprocess.getstatusoutput(cmd) return status, output @staticmethod def getsdkreg(reg): try: cmd=\"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg ret, result=osutil.rj_os_system(cmd) result_t=result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\") if ret !=0 or \"Error:\" in result_t: return False, result patt=r\"%s.(.*):(.*)>drivshell\" % reg rt=re.findall(patt, result_t, re.S) test=re.findall(\"=(.*)\", rt[0][0])[0] except Exception as e: return False, 'get sdk register error' return True, test @staticmethod def getmactemp(): try: result={} osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\") ret, log=osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\") if ret: return False, result else: logs=log.splitlines() for line in logs: if \"average\" in line: b=re.findall(r'\\d+.\\d+', line) result[\"average\"]=b[0] elif \"maximum\" in line: b=re.findall(r'\\d+.\\d+', line) result[\"maximum\"]=b[0] except Exception as e: return False, str(e) return True, result ", "sourceWithComments": "#######################################################\n#\n# osutil.py\n# Python implementation of the Class osutil\n# Original author: sonic_rd@ruijie.com.cn\n#\n#######################################################\n\nimport subprocess\nimport time\nimport glob\nimport re\n#import chardet\nfrom rjutil.smbus import SMBus\nimport time\nfrom  functools import wraps\n\n\ndef retry(maxretry =6, delay = 0.01):\n    '''\n        maxretry:  max retry times\n        delay   :  interval after last retry\n    '''\n    def decorator(f):\n        @wraps(f)\n        def wrapper(*args, **kwargs):\n            time_retry = maxretry\n            time_delay = delay\n            result_msg = \"\"\n            while time_retry:\n                try:\n                    val , result_msg = f(*args, **kwargs)\n                    if val is False:\n                        time_retry -=1\n                        time.sleep(time_delay)\n                        continue\n                    else:\n                        return val, result_msg\n                except Exception as e:\n                    time_retry -= 1\n                    result_msg = str(e)\n                    time.sleep(time_delay)\n            return False, \"max time retry last errmsg is {}\".format(result_msg)\n        return wrapper\n    return decorator\n\nclass osutil(object):\n    \"\"\"\n       osutil\n    \"\"\"\n\n    @staticmethod\n    @retry(maxretry = 6)\n    def rji2cget_python(bus, addr, reg):\n        with SMBus(bus) as y:\n            val , ind  = y.read_byte_data(addr, reg, True)\n        return val , ind\n\n\n    @staticmethod\n    @retry(maxretry = 6)\n    def rji2cset_python(bus, addr, reg, value):\n        with SMBus(bus) as y:\n            val , ind  = y.write_byte_data(addr, reg, value, True)\n        return val , ind\n\n    @staticmethod\n    @retry(maxretry = 6)\n    def rji2cgetword_python(bus, addr, reg):\n        with SMBus(bus) as y:\n            val , ind  = y.read_word_data(addr, reg, True)\n        return val , ind\n\n    @staticmethod\n    @retry(maxretry = 6)\n    def rji2csetword_python(bus, addr, reg, value):\n        with SMBus(bus) as y:\n            val , ind  = y.write_word_data(addr, reg, value, True)\n        return val , ind\n\n    @staticmethod\n    def command(cmdstr):\n        retcode, output = subprocess.getstatusoutput(cmdstr)\n        return retcode, output\n\n\n    @staticmethod\n    def geti2cword_i2ctool(bus, addr, offset):\n        command_line = \"i2cget -f -y %d 0x%02x 0x%02x  wp\" % (bus, addr, offset)\n        retrytime = 6\n        ret_t = \"\"\n        for i in range(retrytime):\n            ret, ret_t = osutil.command(command_line)\n            if ret == 0:\n                return True, int(ret_t, 16)\n            time.sleep(0.1)\n        return False, ret_t\n\n\n    @staticmethod\n    def seti2cword_i2ctool(bus, addr, offset, val):\n        command_line = \"i2cset -f -y %d 0x%02x 0x%0x 0x%04x wp\" % (bus, addr, offset, val)\n        retrytime = 6\n        ret_t = \"\"\n        for i in range(retrytime):\n            ret, ret_t = osutil.command(command_line)\n            if ret == 0:\n                return True, ret_t\n            time.sleep(0.1)\n        return False, ret_t\n\n    @staticmethod\n    def rji2cget_i2ctool(bus, devno, address):\n        command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)\n        retrytime = 6\n        ret_t = \"\"\n        for i in range(retrytime):\n            ret, ret_t = osutil.command(command_line)\n            if ret == 0:\n                return True, int(ret_t, 16)\n            time.sleep(0.1)\n        return False, ret_t\n\n    @staticmethod\n    def rji2cset_i2ctool(bus, devno, address, byte):\n        command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (\n            bus, devno, address, byte)\n        retrytime = 6\n        ret_t = \"\"\n        for i in range(retrytime):\n            ret, ret_t = osutil.command(command_line)\n            if ret == 0:\n                return True, ret_t\n        return False, ret_t\n\n    @staticmethod\n    def geti2cword(bus, addr, offset):\n        return osutil.rji2cgetword_python(bus, addr, offset)\n    @staticmethod\n    def seti2cword(bus, addr, offset, val):\n        return osutil.rji2csetword_python(bus, addr, offset, val)\n    @staticmethod\n    def rji2cget(bus, devno, address):\n        return osutil.rji2cget_python(bus, devno, address)\n    @staticmethod\n    def rji2cset(bus, devno, address, byte):\n        return osutil.rji2cset_python(bus, devno, address, byte)\n\n    @staticmethod\n    def byteTostr(val):\n        strtmp = ''\n        for i in range(len(val)):\n            strtmp += chr(val[i])\n        return strtmp\n\n    @staticmethod\n    def readsysfs(location):\n        try:\n            locations = glob.glob(location)\n            with open(locations[0], 'rb') as fd1:\n                retval = fd1.read()\n            retval = retval.strip()\n        except Exception as e:\n            return False, (str(e)+\" location[%s]\" % location)\n        return True, retval.decode(\"utf-8\", \"ignore\")\n\n    @staticmethod\n    def getdevmem(addr, digit, mask):\n        command_line = \"devmem 0x%02x %d\" %(addr, digit)\n        retrytime = 6\n        ret_t = \"\"\n        for i in range(retrytime):\n            ret, ret_t = osutil.command(command_line)\n            if ret == 0:\n                if mask != None:\n                    ret_t = str(int(ret_t, 16) & mask)\n            return True, ret_t\n        return False, ret_t\n\n    @staticmethod\n    def rj_os_system(cmd):\n        status, output = subprocess.getstatusoutput(cmd)\n        return status, output\n\n    @staticmethod\n    def getsdkreg(reg):\n        try:\n            cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg\n            ret, result = osutil.rj_os_system(cmd)\n            result_t = result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n            if ret != 0 or \"Error:\" in result_t:\n                return False, result\n            patt = r\"%s.(.*):(.*)>drivshell\" % reg\n            rt = re.findall(patt, result_t, re.S)\n            test = re.findall(\"=(.*)\", rt[0][0])[0]\n        except Exception as e:\n            return False, 'get sdk register error'\n        return True, test\n\n    @staticmethod\n    def getmactemp():\n        try:\n            result = {}\n            #waitForDocker()\n            #need to exec twice\n            osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n            ret, log = osutil.rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n            if ret:\n                return False, result\n            else:\n                logs = log.splitlines()\n                for line in logs:\n                    if \"average\" in line:\n                        b = re.findall(r'\\d+.\\d+', line)\n                        result[\"average\"] = b[0]\n                    elif \"maximum\" in line:\n                        b = re.findall(r'\\d+.\\d+', line)\n                        result[\"maximum\"] = b[0]\n        except Exception as e:\n            return False, str(e)\n        return True, result\n\n"}, "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py": {"changes": [{"diff": "\n \n def check_driver():\n     u'''whether there is driver start with rg'''\n-    status, output = log_os_system(\"lsmod | grep rg | wc -l\")\n+    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", \"rg\"], [\"wc\", \"-l\"])\n     #System execution error\n     if status: \n         return False\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["    status, output = log_os_system(\"lsmod | grep rg | wc -l\")"], "goodparts": ["    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", \"rg\"], [\"wc\", \"-l\"])"]}, {"diff": "\n     return ret\n \n def startAvscontrol():\n-    cmd = \"nohup avscontrol.py start >/dev/null 2>&1 &\"\n+    cmd = [\"avscontrol.py\", \"start\"]\n     rets = i2c_getPid(\"avscontrol.py\")\n     if len(rets) == 0:\n-        os.system(cmd)\n+        subprocess.Popen(cmd)\n \n def startFanctrol():\n     if STARTMODULE['fancontrol'] == 1:\n-        cmd = \"nohup fancontrol.py start >/dev/null 2>&1 &\"\n+        cmd = [\"fancontrol.py\", \"start\"]\n         rets = i2c_getPid(\"fancontrol.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def starthal_fanctrl():\n     if STARTMODULE.get('hal_fanctrl',0) == 1:\n-        cmd = \"nohup hal_fanctrl.py start >/dev/null 2>&1 &\"\n+        cmd = [\"hal_fanctrl.py\", \"start\"]\n         rets = i2c_getPid(\"hal_fanctrl.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def starthal_ledctrl():\n     if STARTMODULE.get('hal_ledctrl',0) == 1:\n-        cmd = \"nohup hal_ledctrl.py start >/dev/null 2>&1 &\"\n+        cmd = [\"hal_ledctrl.py\", \"start\"]\n         rets = i2c_getPid(\"hal_ledctrl.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n-\n+            subprocess.Popen(cmd)\n def startDevmonitor():\n     if STARTMODULE.get('dev_monitor',0) == 1:\n-        cmd = \"nohup dev_monitor.py start >/dev/null 2>&1 &\"\n+        cmd = [\"dev_monitor.py\", \"start\"]\n         rets = i2c_getPid(\"dev_monitor.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n-\n+            subprocess.Popen(cmd)\n def startSlotmonitor():\n     if STARTMODULE.get('slot_monitor',0) == 1:\n-        cmd = \"nohup slot_monitor.py start >/dev/null 2>&1 &\"\n+        cmd = [\"slot_monitor.py\", \"start\"]\n         rets = i2c_getPid(\"slot_monitor.py\")\n         if len(rets) == 0:\n-            os.system(cmd)\n+            subprocess.Popen(cmd)\n \n def stopFanctrol():\n     u'''disable fan timer service'''\n     if STARTMODULE['fancontrol'] == 1:\n         rets = i2c_getPid(\"fancontrol.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def stophal_ledctrl():\n     if STARTMODULE.get('hal_ledctrl',0) == 1:\n         rets = i2c_getPid(\"hal_ledctrl.py\")\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n \n", "add": 16, "remove": 18, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["    cmd = \"nohup avscontrol.py start >/dev/null 2>&1 &\"", "        os.system(cmd)", "        cmd = \"nohup fancontrol.py start >/dev/null 2>&1 &\"", "            os.system(cmd)", "        cmd = \"nohup hal_fanctrl.py start >/dev/null 2>&1 &\"", "            os.system(cmd)", "        cmd = \"nohup hal_ledctrl.py start >/dev/null 2>&1 &\"", "            os.system(cmd)", "        cmd = \"nohup dev_monitor.py start >/dev/null 2>&1 &\"", "            os.system(cmd)", "        cmd = \"nohup slot_monitor.py start >/dev/null 2>&1 &\"", "            os.system(cmd)", "            cmd = \"kill \"+ ret", "            os.system(cmd)", "            cmd = \"kill \"+ ret", "            os.system(cmd)"], "goodparts": ["    cmd = [\"avscontrol.py\", \"start\"]", "        subprocess.Popen(cmd)", "        cmd = [\"fancontrol.py\", \"start\"]", "            subprocess.Popen(cmd)", "        cmd = [\"hal_fanctrl.py\", \"start\"]", "            subprocess.Popen(cmd)", "        cmd = [\"hal_ledctrl.py\", \"start\"]", "            subprocess.Popen(cmd)", "        cmd = [\"dev_monitor.py\", \"start\"]", "            subprocess.Popen(cmd)", "        cmd = [\"slot_monitor.py\", \"start\"]", "            subprocess.Popen(cmd)", "            cmd = [\"kill\", ret]", "            subprocess.call(cmd)", "            cmd = [\"kill\", ret]", "            subprocess.call(cmd)"]}, {"diff": "\n     if STARTMODULE.get('dev_monitor',0) == 1:\n         rets = i2c_getPid(\"dev_monitor.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def stopSlotmonitor():\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["            cmd = \"kill \"+ ret", "            os.system(cmd)"], "goodparts": ["            cmd = [\"kill\", ret]", "            subprocess.call(cmd)"]}, {"diff": "\n     if STARTMODULE.get('slot_monitor',0) == 1:\n         rets = i2c_getPid(\"slot_monitor.py\")  #\n         for ret in rets:\n-            cmd = \"kill \"+ ret\n-            os.system(cmd)\n+            cmd = [\"kill\", ret]\n+            subprocess.call(cmd)\n         return True\n \n def removeDev(bus, loc):\n-    cmd = \"echo  0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device\" % (loc, bus)\n     devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n     if os.path.exists(devpath):\n-        log_os_system(cmd)\n+        file = \"/sys/bus/i2c/devices/i2c-%d/delete_device\" % bus\n+        with open(file, 'w') as f:\n+            f.write('0x%02x\\n'%str(bus))\n         \n def addDev(name, bus, loc):\n     if name == \"lm75\":\n", "add": 5, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["            cmd = \"kill \"+ ret", "            os.system(cmd)", "    cmd = \"echo  0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device\" % (loc, bus)", "        log_os_system(cmd)"], "goodparts": ["            cmd = [\"kill\", ret]", "            subprocess.call(cmd)", "        file = \"/sys/bus/i2c/devices/i2c-%d/delete_device\" % bus", "        with open(file, 'w') as f:", "            f.write('0x%02x\\n'%str(bus))"]}, {"diff": "\n         if i % 10 == 0:\n             click.echo(\"%%DEVICE_I2C-INIT: %s not found, wait 0.1 second ! i %d \" % (pdevpath,i))\n             \n-    cmd = \"echo  %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device\" % (name, loc, bus)\n     devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n     if os.path.exists(devpath) == False:\n-        os.system(cmd)\n+        file = \"/sys/bus/i2c/devices/i2c-%d/new_device\" % bus\n+        with open(file, 'w') as f:\n+            f.write('%s 0x%02x\\n' % (name, loc))\n \n def removedevs():\n     devs = GLOBALCONFIG[\"DEVS\"]\n", "add": 3, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["    cmd = \"echo  %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device\" % (name, loc, bus)", "        os.system(cmd)"], "goodparts": ["        file = \"/sys/bus/i2c/devices/i2c-%d/new_device\" % bus", "        with open(file, 'w') as f:", "            f.write('%s 0x%02x\\n' % (name, loc))"]}, {"diff": "\n         addDev(devs[dev][\"name\"], devs[dev][\"bus\"] , devs[dev][\"loc\"])\n \n def checksignaldriver(name):\n-    modisexistcmd = \"lsmod | grep %s | wc -l\" % name\n-    status, output = log_os_system(modisexistcmd)\n+    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", name], [\"wc\", \"-l\"])\n     #System execution error\n     if status: \n         return False\n", "add": 1, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["    modisexistcmd = \"lsmod | grep %s | wc -l\" % name", "    status, output = log_os_system(modisexistcmd)"], "goodparts": ["    status, output = getstatusoutput_noshell_pipe([\"lsmod\"], [\"grep\", name], [\"wc\", \"-l\"])"]}, {"diff": "\n         return False\n \n def adddriver(name, delay):\n-    cmd = \"modprobe %s\" % name\n+    cmd = [\"modprobe\", name]\n     if delay != 0:\n         time.sleep(delay)\n     if checksignaldriver(name) != True:\n-        log_os_system(cmd)\n+        getstatusoutput_noshell(cmd)\n \n def removedriver(name, delay):\n     realname = name.lstrip().split(\" \")[0];\n-    cmd = \"rmmod -f %s\" % realname\n+    cmd = [\"rmmod\", \"-f\", realname]\n     if checksignaldriver(realname):\n-        log_os_system(cmd)\n+        getstatusoutput_noshell(cmd)\n \n def removedrivers():\n     u'''remove all drive", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/device_i2c.py", "badparts": ["    cmd = \"modprobe %s\" % name", "        log_os_system(cmd)", "    cmd = \"rmmod -f %s\" % realname", "        log_os_system(cmd)"], "goodparts": ["    cmd = [\"modprobe\", name]", "        getstatusoutput_noshell(cmd)", "    cmd = [\"rmmod\", \"-f\", realname]", "        getstatusoutput_noshell(cmd)"]}], "source": "\n import click import os import subprocess import time from ruijieconfig import GLOBALCONFIG, GLOBALINITPARAM, GLOBALINITCOMMAND, MAC_LED_RESET, STARTMODULE, i2ccheck_params from ruijieutil import rjpciwr CONTEXT_SETTINGS=dict(help_option_names=['-h', '--help']) class AliasedGroup(click.Group): def get_command(self, ctx, cmd_name): rv=click.Group.get_command(self, ctx, cmd_name) if rv is not None: return rv matches=[x for x in self.list_commands(ctx) if x.startswith(cmd_name)] if not matches: return None elif len(matches)==1: return click.Group.get_command(self, ctx, matches[0]) ctx.fail('Too many matches: %s' % ', '.join(sorted(matches))) def log_os_system(cmd): u'''execute shell command''' status, output=subprocess.getstatusoutput(cmd) if status: print(output) return status, output def write_sysfs_value(reg_name, value): u'''write sysfs file''' mb_reg_file=\"/sys/bus/i2c/devices/\" +reg_name if(not os.path.isfile(mb_reg_file)): print(mb_reg_file, 'not found !') return False try: with open(mb_reg_file, 'w') as fd: fd.write(value) except Exception as error: return False return True def check_driver(): u'''whether there is driver start with rg''' status, output=log_os_system(\"lsmod | grep rg | wc -l\") if status: return False if output.isdigit() and int(output) > 0: return True else: return False def i2c_getPid(name): ret=[] for dirname in os.listdir('/proc'): if dirname=='curproc': continue try: with open('/proc/{}/cmdline'.format(dirname), mode='r') as fd: content=fd.read() except Exception: continue if name in content: ret.append(dirname) return ret def startAvscontrol(): cmd=\"nohup avscontrol.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"avscontrol.py\") if len(rets)==0: os.system(cmd) def startFanctrol(): if STARTMODULE['fancontrol']==1: cmd=\"nohup fancontrol.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"fancontrol.py\") if len(rets)==0: os.system(cmd) def starthal_fanctrl(): if STARTMODULE.get('hal_fanctrl',0)==1: cmd=\"nohup hal_fanctrl.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"hal_fanctrl.py\") if len(rets)==0: os.system(cmd) def starthal_ledctrl(): if STARTMODULE.get('hal_ledctrl',0)==1: cmd=\"nohup hal_ledctrl.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"hal_ledctrl.py\") if len(rets)==0: os.system(cmd) def startDevmonitor(): if STARTMODULE.get('dev_monitor',0)==1: cmd=\"nohup dev_monitor.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"dev_monitor.py\") if len(rets)==0: os.system(cmd) def startSlotmonitor(): if STARTMODULE.get('slot_monitor',0)==1: cmd=\"nohup slot_monitor.py start >/dev/null 2>&1 &\" rets=i2c_getPid(\"slot_monitor.py\") if len(rets)==0: os.system(cmd) def stopFanctrol(): u'''disable fan timer service''' if STARTMODULE['fancontrol']==1: rets=i2c_getPid(\"fancontrol.py\") for ret in rets: cmd=\"kill \"+ret os.system(cmd) return True def stophal_ledctrl(): if STARTMODULE.get('hal_ledctrl',0)==1: rets=i2c_getPid(\"hal_ledctrl.py\") for ret in rets: cmd=\"kill \"+ret os.system(cmd) return True def stopDevmonitor(): u'''disable the fan timer service''' if STARTMODULE.get('dev_monitor',0)==1: rets=i2c_getPid(\"dev_monitor.py\") for ret in rets: cmd=\"kill \"+ret os.system(cmd) return True def stopSlotmonitor(): u'''disable slot timer service''' if STARTMODULE.get('slot_monitor',0)==1: rets=i2c_getPid(\"slot_monitor.py\") for ret in rets: cmd=\"kill \"+ret os.system(cmd) return True def removeDev(bus, loc): cmd=\"echo 0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device\" %(loc, bus) devpath=\"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc) if os.path.exists(devpath): log_os_system(cmd) def addDev(name, bus, loc): if name==\"lm75\": time.sleep(0.1) pdevpath=\"/sys/bus/i2c/devices/i2c-%d/\" %(bus) for i in range(1, 100): if os.path.exists(pdevpath)==True: break time.sleep(0.1) if i % 10==0: click.echo(\"%%DEVICE_I2C-INIT: %s not found, wait 0.1 second ! i %d \" %(pdevpath,i)) cmd=\"echo %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device\" %(name, loc, bus) devpath=\"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc) if os.path.exists(devpath)==False: os.system(cmd) def removedevs(): devs=GLOBALCONFIG[\"DEVS\"] for index in range(len(devs)-1, -1, -1): removeDev(devs[index][\"bus\"], devs[index][\"loc\"]) def adddevs(): devs=GLOBALCONFIG[\"DEVS\"] for dev in range(0, devs.__len__()): addDev(devs[dev][\"name\"], devs[dev][\"bus\"], devs[dev][\"loc\"]) def checksignaldriver(name): modisexistcmd=\"lsmod | grep %s | wc -l\" % name status, output=log_os_system(modisexistcmd) if status: return False if output.isdigit() and int(output) > 0: return True else: return False def adddriver(name, delay): cmd=\"modprobe %s\" % name if delay !=0: time.sleep(delay) if checksignaldriver(name) !=True: log_os_system(cmd) def removedriver(name, delay): realname=name.lstrip().split(\" \")[0]; cmd=\"rmmod -f %s\" % realname if checksignaldriver(realname): log_os_system(cmd) def removedrivers(): u'''remove all drivers''' if GLOBALCONFIG is None: click.echo(\"%%DEVICE_I2C-INIT: load global config failed.\") return drivers=GLOBALCONFIG.get(\"DRIVERLISTS\", None) if drivers is None: click.echo(\"%%DEVICE_I2C-INIT: load driver list failed.\") return for index in range(len(drivers)-1, -1, -1): delay=0 name=\"\" if type(drivers[index])==dict and \"delay\" in drivers[index]: name=drivers[index].get(\"name\") delay=drivers[index][\"delay\"] else: name=drivers[index] removedriver(name, delay) def adddrivers(): u'''add drivers''' if GLOBALCONFIG is None: click.echo(\"%%DEVICE_I2C-INIT: load global config failed.\") return drivers=GLOBALCONFIG.get(\"DRIVERLISTS\", None) if drivers is None: click.echo(\"%%DEVICE_I2C-INIT: load driver list failed.\") return for index in range(0,len(drivers)): delay=0 name=\"\" if type(drivers[index])==dict and \"delay\" in drivers[index]: name=drivers[index].get(\"name\") delay=drivers[index][\"delay\"] else: name=drivers[index] adddriver(name, delay) def otherinit(): for index in GLOBALINITPARAM: write_sysfs_value(index[\"loc\"], index[\"value\"]) for index in GLOBALINITCOMMAND: log_os_system(index) def unload_driver(): u'''remove devices and drivers''' stopDevmonitor() stopFanctrol() removedevs() removedrivers() def reload_driver(): u'''reload devices and drivers''' removedevs() removedrivers() time.sleep(1) adddrivers() adddevs() def i2c_check(bus,retrytime=6): try: i2cpath=\"/sys/bus/i2c/devices/\" +bus while retrytime and not os.path.exists(i2cpath): click.echo(\"%%DEVICE_I2C-HA: i2c bus abnormal, last bus %s is not exist.\" % i2cpath) reload_driver() retrytime -=1 time.sleep(1) except Exception as e: click.echo(\"%%DEVICE_I2C-HA: %s\" % str(e)) return def MacLedSet(data): '''write pci register''' pcibus=MAC_LED_RESET.get(\"pcibus\") slot=MAC_LED_RESET.get(\"slot\") fn=MAC_LED_RESET.get(\"fn\") bar=MAC_LED_RESET.get(\"bar\") offset=MAC_LED_RESET.get(\"offset\") val=MAC_LED_RESET.get(data, None) if val is None: click.echo(\"%%DEVICE_I2C-INIT: MacLedSet wrong input\") return rjpciwr(pcibus, slot, fn, bar, offset, val) def load_driver(): u'''load devices and drivers''' adddrivers() adddevs() if STARTMODULE.get(\"i2ccheck\",0)==1: busend=i2ccheck_params.get(\"busend\") retrytime=i2ccheck_params.get(\"retrytime\") i2c_check(busend,retrytime) startFanctrol() starthal_fanctrl() starthal_ledctrl() if STARTMODULE['avscontrol']==1: startAvscontrol() startDevmonitor() startSlotmonitor() otherinit(); if STARTMODULE.get(\"macledreset\",0)==1: MacLedSet(\"reset\") @click.group(cls=AliasedGroup, context_settings=CONTEXT_SETTINGS) def main(): '''device operator''' pass @main.command() def start(): '''load device ''' if check_driver(): unload_driver() load_driver() @main.command() def stop(): '''stop device ''' unload_driver() @main.command() def restart(): '''restart device''' unload_driver() load_driver() if __name__=='__main__': u'''device_i2c operation''' main() ", "sourceWithComments": "#!/usr/bin/env python3\n# -*- coding: UTF-8 -*-\n\nimport click\nimport os\nimport subprocess\nimport time\nfrom  ruijieconfig import GLOBALCONFIG, GLOBALINITPARAM, GLOBALINITCOMMAND, MAC_LED_RESET, STARTMODULE, i2ccheck_params\n\nfrom  ruijieutil   import rjpciwr\n\nCONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])\n\nclass AliasedGroup(click.Group):\n    def get_command(self, ctx, cmd_name):\n        rv = click.Group.get_command(self, ctx, cmd_name)\n        if rv is not None:\n            return rv\n        matches = [x for x in self.list_commands(ctx)\n                   if x.startswith(cmd_name)]\n        if not matches:\n            return None\n        elif len(matches) == 1:\n            return click.Group.get_command(self, ctx, matches[0])\n        ctx.fail('Too many matches: %s' % ', '.join(sorted(matches)))\n   \ndef log_os_system(cmd):\n    u'''execute shell command'''\n    status, output = subprocess.getstatusoutput(cmd)\n    if status:\n        print(output)\n    return  status, output\n\ndef write_sysfs_value(reg_name, value):\n    u'''write sysfs file'''\n    mb_reg_file = \"/sys/bus/i2c/devices/\" + reg_name\n    if (not os.path.isfile(mb_reg_file)):\n        print(mb_reg_file,  'not found !')\n        return False\n    try:\n        with open(mb_reg_file, 'w') as fd:\n            fd.write(value)\n    except Exception as error:\n        return False\n    return True\n\ndef check_driver():\n    u'''whether there is driver start with rg'''\n    status, output = log_os_system(\"lsmod | grep rg | wc -l\")\n    #System execution error\n    if status: \n        return False\n    if output.isdigit() and int(output) > 0:\n        return True\n    else:\n        return False\n\ndef i2c_getPid(name):\n    ret = []\n    for dirname in os.listdir('/proc'):\n        if dirname == 'curproc':\n            continue\n        try:\n            with open('/proc/{}/cmdline'.format(dirname), mode='r') as fd:\n                content = fd.read()\n        except Exception:\n            continue\n        if name in content:\n            ret.append(dirname)\n    return ret\n\ndef startAvscontrol():\n    cmd = \"nohup avscontrol.py start >/dev/null 2>&1 &\"\n    rets = i2c_getPid(\"avscontrol.py\")\n    if len(rets) == 0:\n        os.system(cmd)\n\ndef startFanctrol():\n    if STARTMODULE['fancontrol'] == 1:\n        cmd = \"nohup fancontrol.py start >/dev/null 2>&1 &\"\n        rets = i2c_getPid(\"fancontrol.py\")\n        if len(rets) == 0:\n            os.system(cmd)\n\ndef starthal_fanctrl():\n    if STARTMODULE.get('hal_fanctrl',0) == 1:\n        cmd = \"nohup hal_fanctrl.py start >/dev/null 2>&1 &\"\n        rets = i2c_getPid(\"hal_fanctrl.py\")\n        if len(rets) == 0:\n            os.system(cmd)\n\ndef starthal_ledctrl():\n    if STARTMODULE.get('hal_ledctrl',0) == 1:\n        cmd = \"nohup hal_ledctrl.py start >/dev/null 2>&1 &\"\n        rets = i2c_getPid(\"hal_ledctrl.py\")\n        if len(rets) == 0:\n            os.system(cmd)\n\ndef startDevmonitor():\n    if STARTMODULE.get('dev_monitor',0) == 1:\n        cmd = \"nohup dev_monitor.py start >/dev/null 2>&1 &\"\n        rets = i2c_getPid(\"dev_monitor.py\")\n        if len(rets) == 0:\n            os.system(cmd)\n\ndef startSlotmonitor():\n    if STARTMODULE.get('slot_monitor',0) == 1:\n        cmd = \"nohup slot_monitor.py start >/dev/null 2>&1 &\"\n        rets = i2c_getPid(\"slot_monitor.py\")\n        if len(rets) == 0:\n            os.system(cmd)\n\ndef stopFanctrol():\n    u'''disable fan timer service'''\n    if STARTMODULE['fancontrol'] == 1:\n        rets = i2c_getPid(\"fancontrol.py\")  #\n        for ret in rets:\n            cmd = \"kill \"+ ret\n            os.system(cmd)\n        return True\n\ndef stophal_ledctrl():\n    if STARTMODULE.get('hal_ledctrl',0) == 1:\n        rets = i2c_getPid(\"hal_ledctrl.py\")\n        for ret in rets:\n            cmd = \"kill \"+ ret\n            os.system(cmd)\n        return True\n\n\ndef stopDevmonitor():\n    u'''disable the fan timer service'''\n    if STARTMODULE.get('dev_monitor',0) == 1:\n        rets = i2c_getPid(\"dev_monitor.py\")  #\n        for ret in rets:\n            cmd = \"kill \"+ ret\n            os.system(cmd)\n        return True\n\ndef stopSlotmonitor():\n    u'''disable slot timer service'''\n    if STARTMODULE.get('slot_monitor',0) == 1:\n        rets = i2c_getPid(\"slot_monitor.py\")  #\n        for ret in rets:\n            cmd = \"kill \"+ ret\n            os.system(cmd)\n        return True\n\ndef removeDev(bus, loc):\n    cmd = \"echo  0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device\" % (loc, bus)\n    devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n    if os.path.exists(devpath):\n        log_os_system(cmd)\n        \ndef addDev(name, bus, loc):\n    if name == \"lm75\":\n        time.sleep(0.1)\n    pdevpath = \"/sys/bus/i2c/devices/i2c-%d/\" % (bus)\n    for i in range(1, 100):#wait for mother-bus generation\uff0cmaximum wait time is 10s\n        if os.path.exists(pdevpath) == True: \n            break\n        time.sleep(0.1)\n        if i % 10 == 0:\n            click.echo(\"%%DEVICE_I2C-INIT: %s not found, wait 0.1 second ! i %d \" % (pdevpath,i))\n            \n    cmd = \"echo  %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device\" % (name, loc, bus)\n    devpath = \"/sys/bus/i2c/devices/%d-%04x\"%(bus, loc)\n    if os.path.exists(devpath) == False:\n        os.system(cmd)\n\ndef removedevs():\n    devs = GLOBALCONFIG[\"DEVS\"]\n    for index in range(len(devs)-1, -1, -1 ):\n        removeDev(devs[index][\"bus\"] , devs[index][\"loc\"])\n        \ndef adddevs():\n    devs = GLOBALCONFIG[\"DEVS\"]\n    for dev in range(0, devs.__len__()):\n        addDev(devs[dev][\"name\"], devs[dev][\"bus\"] , devs[dev][\"loc\"])\n\ndef checksignaldriver(name):\n    modisexistcmd = \"lsmod | grep %s | wc -l\" % name\n    status, output = log_os_system(modisexistcmd)\n    #System execution error\n    if status: \n        return False\n    if output.isdigit() and int(output) > 0:\n        return True\n    else:\n        return False\n\ndef adddriver(name, delay):\n    cmd = \"modprobe %s\" % name\n    if delay != 0:\n        time.sleep(delay)\n    if checksignaldriver(name) != True:\n        log_os_system(cmd)\n\ndef removedriver(name, delay):\n    realname = name.lstrip().split(\" \")[0];\n    cmd = \"rmmod -f %s\" % realname\n    if checksignaldriver(realname):\n        log_os_system(cmd)\n\ndef removedrivers():\n    u'''remove all drivers'''\n    if GLOBALCONFIG is None:\n        click.echo(\"%%DEVICE_I2C-INIT: load global config failed.\")\n        return\n    drivers = GLOBALCONFIG.get(\"DRIVERLISTS\", None)\n    if drivers is None:\n        click.echo(\"%%DEVICE_I2C-INIT: load driver list failed.\")\n        return \n    for index in range(len(drivers)-1, -1, -1 ):\n        delay = 0\n        name = \"\"\n        if type(drivers[index]) == dict and \"delay\" in drivers[index]:\n            name = drivers[index].get(\"name\")\n            delay = drivers[index][\"delay\"]\n        else:\n            name = drivers[index]\n        removedriver(name, delay)\n\ndef adddrivers():\n    u'''add drivers'''\n    if GLOBALCONFIG is None:\n        click.echo(\"%%DEVICE_I2C-INIT: load global config failed.\")\n        return\n    drivers = GLOBALCONFIG.get(\"DRIVERLISTS\", None)\n    if drivers is None:\n        click.echo(\"%%DEVICE_I2C-INIT: load driver list failed.\")\n        return \n    for index in range(0 ,len(drivers)):\n        delay = 0\n        name = \"\"\n        if type(drivers[index]) == dict and \"delay\" in drivers[index]:\n            name = drivers[index].get(\"name\")\n            delay = drivers[index][\"delay\"]\n        else:\n            name = drivers[index]\n        adddriver(name, delay)\n\ndef otherinit():\n    for index in GLOBALINITPARAM:\n        write_sysfs_value(index[\"loc\"], index[\"value\"])\n\n    for index in GLOBALINITCOMMAND:\n        log_os_system(index)\n    \ndef unload_driver():\n    u'''remove devices and drivers'''\n    stopDevmonitor() # disable removable device driver monitors\n    stopFanctrol()  # disable fan-control service\n    removedevs()    # remove other devices\n    removedrivers() # remove drivers\n\ndef reload_driver():\n    u'''reload devices and drivers'''\n    removedevs()    # remove other devices\n    removedrivers() # remove drivers\n    time.sleep(1)\n    adddrivers()\n    adddevs()\n\n\ndef i2c_check(bus,retrytime = 6):\n    try:\n        i2cpath = \"/sys/bus/i2c/devices/\" + bus\n        while retrytime and not os.path.exists(i2cpath):\n            click.echo(\"%%DEVICE_I2C-HA: i2c bus abnormal, last bus %s is not exist.\" % i2cpath)\n            reload_driver()\n            retrytime -= 1\n            time.sleep(1)\n    except Exception as e:\n        click.echo(\"%%DEVICE_I2C-HA: %s\" % str(e))\n    return \n\ndef MacLedSet(data):\n    '''write pci register'''\n    pcibus = MAC_LED_RESET.get(\"pcibus\")\n    slot = MAC_LED_RESET.get(\"slot\")\n    fn = MAC_LED_RESET.get(\"fn\")\n    bar = MAC_LED_RESET.get(\"bar\")\n    offset = MAC_LED_RESET.get(\"offset\")\n    val = MAC_LED_RESET.get(data, None)\n    if val is None:\n        click.echo(\"%%DEVICE_I2C-INIT: MacLedSet wrong input\")\n        return\n    rjpciwr(pcibus, slot, fn, bar, offset, val)\n\ndef load_driver():\n    u'''load devices and drivers'''\n    adddrivers()\n    adddevs()\n    if STARTMODULE.get(\"i2ccheck\",0) == 1: #i2c HA\n        busend = i2ccheck_params.get(\"busend\")\n        retrytime = i2ccheck_params.get(\"retrytime\")\n        i2c_check(busend,retrytime)\n    startFanctrol() # enable fan\n    starthal_fanctrl() # enable fan control\n    starthal_ledctrl() # enable LED control\n    if STARTMODULE['avscontrol'] == 1:\n        startAvscontrol() # avs voltage-adjustment\n    startDevmonitor() # enable removable device driver monitors\n    startSlotmonitor() # slot insertion and removal initialization monitor\n    otherinit();    # other initialization, QSFP initialization\n    if STARTMODULE.get(\"macledreset\",0) == 1:\n        MacLedSet(\"reset\")\n    \n@click.group(cls=AliasedGroup, context_settings=CONTEXT_SETTINGS)\ndef main():\n    '''device operator'''\n    pass\n\n\n@main.command()\ndef start():\n    '''load device '''\n    if check_driver():\n        unload_driver()\n    load_driver()\n\n@main.command()\ndef stop():\n    '''stop device '''\n    unload_driver()\n\n@main.command()\ndef restart():\n    '''restart device'''\n    unload_driver()\n    load_driver()\n\nif __name__ == '__main__':\n    u'''device_i2c operation'''\n    main()\n"}, "/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py": {"changes": [{"diff": "\n                     self.fanSpeedSetMax()  # fan full speed\n                     self.critnum += 1 # anti-shake\n                     if self.critnum >= MONITOR_CONST.CRITICAL_NUM:\n-                       os.system(\"reboot\")\n+                        subprocess.call([\"reboot\"])\n                     fanwarningdebuglog(DEBUG_FANCONTROL,\"crit\u6b21\u6570:%d\" % self.critnum)\n                 else:\n                     self.critn", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/fancontrol.py", "badparts": ["                       os.system(\"reboot\")"], "goodparts": ["                        subprocess.call([\"reboot\"])"]}]}, "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py": {"changes": [{"diff": "\n import sys\n import os\n import re\n-import subprocess\n import syslog\n import time\n import binascii\n", "add": 0, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["import subprocess"], "goodparts": []}, {"diff": "\n \n def getSdkReg(reg):\n     try:\n-        cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg\n-        ret, result = rj_os_system(cmd)\n+        cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]\n+        ret, result = getstatusoutput_noshell(cmd)\n         result_t = result.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n         if ret != 0 or \"Error:\" in result_t:\n             return False, result\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["        cmd = \"bcmcmd -t 1 'getr %s ' < /dev/null\" % reg", "        ret, result = rj_os_system(cmd)"], "goodparts": ["        cmd = [\"bcmcmd\", \"-t\", \"1\", \"getr\"+str(reg)]", "        ret, result = getstatusoutput_noshell(cmd)"]}, {"diff": "\n     result = {}\n     #waitForDocker()\n     # exec twice, get the second result\n-    rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n-    ret, log = rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")\n+    getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n+    ret, log = getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])\n     if ret:\n         return False, result\n     else:\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")", "    ret, log = rj_os_system(\"bcmcmd -t 1 \\\"show temp\\\" < /dev/null\")"], "goodparts": ["    getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])", "    ret, log = getstatusoutput_noshell([\"bcmcmd\", \"-t\", \"1\", \"show temp\"])"]}, {"diff": "\n \n def restartDockerService(force=False):\n     container_name = [\"database\",\"snmp\",\"syncd\",\"swss\",\"dhcp_relay\",\"radv\",\"teamd\",\"pmon\"]\n-    ret, status = rj_os_system(\"docker ps\")\n+    ret, status = getstatusoutput_noshell([\"docker\", \"ps\"])\n     if ret == 0 :\n         for tmpname in container_name:\n             if (tmpname not in status):\n                 if (force == True):\n-                    rj_os_system(\"docker restart %s\"%tmpname)\n+                    getstatusoutput_noshell([\"docker\", \"restart\", tmpname])\n                 else:\n-                    rj_os_system(\"systemctl restart %s\"%tmpname)\n+                    getstatusoutput_noshell([\"systemctl\", \"restart\", tmpname])\n \n \n def waitForDhcp(timeout):\n     time_cnt = 0\n     while True:\n         try:\n-            ret, status = rj_os_system(\"systemctl status dhcp_relay.service\")\n+            ret, status = getstatusoutput_noshell([\"systemctl\", \"status\", \"dhcp_relay.service\"])\n             if (ret == 0 and \"running\" in status)  or \"SUCCESS\" in status:\n                 break\n             else:\n", "add": 4, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    ret, status = rj_os_system(\"docker ps\")", "                    rj_os_system(\"docker restart %s\"%tmpname)", "                    rj_os_system(\"systemctl restart %s\"%tmpname)", "            ret, status = rj_os_system(\"systemctl status dhcp_relay.service\")"], "goodparts": ["    ret, status = getstatusoutput_noshell([\"docker\", \"ps\"])", "                    getstatusoutput_noshell([\"docker\", \"restart\", tmpname])", "                    getstatusoutput_noshell([\"systemctl\", \"restart\", tmpname])", "            ret, status = getstatusoutput_noshell([\"systemctl\", \"status\", \"dhcp_relay.service\"])"]}, {"diff": "\n     rulefile = \"/etc/udev/rules.d/70-persistent-net.rules\"\n     if isValidMac(mac) == False:\n         return False, \"MAC invaild\"\n-    cmd = \"ethtool -e %s | grep 0x0010 | awk '{print \\\"0x\\\"$13$12$15$14}'\" % eth\n-    ret, log = rj_os_system(cmd)\n+    cmd1 = [\"ethtool\", \"-e\", eth] \n+    cmd2 = [\"grep\", \"0x0010\"]\n+    cmd3 = [\"awk\", '{print \\\"0x\\\"$13$12$15$14}']\n+    ret, log = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)\n     log_debug(log)\n     magic = \"\"\n     if ret == 0 and len(log):\n", "add": 4, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    cmd = \"ethtool -e %s | grep 0x0010 | awk '{print \\\"0x\\\"$13$12$15$14}'\" % eth", "    ret, log = rj_os_system(cmd)"], "goodparts": ["    cmd1 = [\"ethtool\", \"-e\", eth] ", "    cmd2 = [\"grep\", \"0x0010\"]", "    cmd3 = [\"awk\", '{print \\\"0x\\\"$13$12$15$14}']", "    ret, log = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)"]}, {"diff": "\n     macs = mac.upper().split(\":\")\n \n     # chage ETH0 to value after setmac\n-    ifconfigcmd = \"ifconfig eth0 hw ether %s\" % mac\n-    log_debug(ifconfigcmd)\n-    ret, status = rj_os_system(ifconfigcmd)\n+    ifconfigcmd = [\"ifconfig\", \"eth0\", \"hw\", \"ether\", mac]\n+    log_debug(' '.join(ifconfigcmd))\n+    ret, status = getstatusoutput_noshell(ifconfigcmd)\n     if ret:\n         raise SETMACException(\"software set  Internet cardMAC error\")\n     index = 0\n     for item in macs:\n-        cmd = \"ethtool -E %s magic %s offset %d value 0x%s\" % (\n-            eth, magic, index, item)\n+        cmd = [\"ethtool\", \"-E\", eht, \"magic\", magic, \"offset\", str(index), \"value\", \"0x\"+item]\n         log_debug(cmd)\n         index += 1\n-        ret, log = rj_os_system(cmd)\n+        ret, log = getstatusoutput_noshell(cmd)\n         if ret != 0:\n             raise SETMACException(\" set hardware Internet card MAC error\")\n     # get value after setting \n-    cmd_t = \"ethtool -e eth0 offset 0 length 6\"\n-    ret, log = rj_os_system(cmd_t)\n+    cmd_t = [\"ethtool\", \"-e\", \"eth0\", \"offset\", \"0\", \"length\", \"6\"]\n+    ret, log = getstatusoutput_noshell(cmd_t)\n     m = re.split(':', log)[-1].strip().upper()\n     mac_result = m.upper().split(\" \")\n \n", "add": 7, "remove": 8, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    ifconfigcmd = \"ifconfig eth0 hw ether %s\" % mac", "    log_debug(ifconfigcmd)", "    ret, status = rj_os_system(ifconfigcmd)", "        cmd = \"ethtool -E %s magic %s offset %d value 0x%s\" % (", "            eth, magic, index, item)", "        ret, log = rj_os_system(cmd)", "    cmd_t = \"ethtool -e eth0 offset 0 length 6\"", "    ret, log = rj_os_system(cmd_t)"], "goodparts": ["    ifconfigcmd = [\"ifconfig\", \"eth0\", \"hw\", \"ether\", mac]", "    log_debug(' '.join(ifconfigcmd))", "    ret, status = getstatusoutput_noshell(ifconfigcmd)", "        cmd = [\"ethtool\", \"-E\", eht, \"magic\", magic, \"offset\", str(index), \"value\", \"0x\"+item]", "        ret, log = getstatusoutput_noshell(cmd)", "    cmd_t = [\"ethtool\", \"-e\", \"eth0\", \"offset\", \"0\", \"length\", \"6\"]", "    ret, log = getstatusoutput_noshell(cmd_t)"]}, {"diff": "\n \n \n def rji2cget(bus, devno, address):\n-    command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)\n+    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address)]\n     retrytime = 6\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n         time.sleep(0.1)\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    command_line = \"i2cget -f -y %d 0x%02x 0x%02x \" % (bus, devno, address)", "        ret, ret_t = rj_os_system(command_line)"], "goodparts": ["    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address)]", "        ret, ret_t = getstatusoutput_noshell(command_line)"]}, {"diff": "\n \n \n def rji2cset(bus, devno, address, byte):\n-    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (\n-        bus, devno, address, byte)\n+    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%02x\"%str(byte)]\n     retrytime = 6\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n     return False, ret_t\n", "add": 2, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%02x\" % (", "        bus, devno, address, byte)", "        ret, ret_t = rj_os_system(command_line)"], "goodparts": ["    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%02x\"%str(byte)]", "        ret, ret_t = getstatusoutput_noshell(command_line)"]}, {"diff": "\n     data.close()\n \n def rjsysset(location, value):\n-    command_line = \"echo 0x%02x > %s\" % (value, location)\n     retrytime = 6\n-    ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n-        if ret == 0:\n-            return True, ret_t\n-    return False, ret_t\n+        try:\n+            with open(location, 'w') as f:\n+                f.write('0x%02x\\n'%value)\n+        except (IOError, FileNotFoundError) as e:\n+            return False, str(e)\n+    return True, ''\n \n \n def rji2cgetWord(bus, devno, address):\n-    command_line = \"i2cget -f -y %d 0x%02x 0x%02x w\" % (bus, devno, address)\n+    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"w\"]\n     retrytime = 3\n     ret_t = \"\"\n     for i in range(retrytime):\n-        ret, ret_t = rj_os_system(command_line)\n+        ret, ret_t = getstatusoutput_noshell(command_line)\n         if ret == 0:\n             return True, ret_t\n     return False, ret_t\n \n \n def rji2csetWord(bus, devno, address, byte):\n-    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%x w\" % (\n-        bus, devno, address, byte)\n-    rj_os_system(command_line)\n+    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%x\"%str(byte), \"w\"]\n+    getstatusoutput_noshell(command_line)\n \n \n def fan_setmac():\n", "add": 10, "remove": 11, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    command_line = \"echo 0x%02x > %s\" % (value, location)", "    ret_t = \"\"", "        ret, ret_t = rj_os_system(command_line)", "        if ret == 0:", "            return True, ret_t", "    return False, ret_t", "    command_line = \"i2cget -f -y %d 0x%02x 0x%02x w\" % (bus, devno, address)", "        ret, ret_t = rj_os_system(command_line)", "    command_line = \"i2cset -f -y %d 0x%02x 0x%02x 0x%x w\" % (", "        bus, devno, address, byte)", "    rj_os_system(command_line)"], "goodparts": ["        try:", "            with open(location, 'w') as f:", "                f.write('0x%02x\\n'%value)", "        except (IOError, FileNotFoundError) as e:", "            return False, str(e)", "    return True, ''", "    command_line = [\"i2cget\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"w\"]", "        ret, ret_t = getstatusoutput_noshell(command_line)", "    command_line = [\"i2cset\", \"-f\", \"-y\", str(bus), \"0x%02x\"%str(devno), \"0x%02x\"%str(address), \"0x%x\"%str(byte), \"w\"]", "    getstatusoutput_noshell(command_line)"]}, {"diff": "\n     elif dealtype == \"io\":\n         io_wr(E2_PROTECT[\"io_addr\"], E2_PROTECT[\"close\"])\n     # deal last drivers\n-    os.system(\"rmmod at24 \")\n-    os.system(\"modprobe at24 \")\n-    os.system(\"rm -f /var/cache/sonic/decode-syseeprom/syseeprom_cache\")\n+    getstatusoutput_noshell([\"rmmod\", \"at24\"])\n+    getstatusoutput_noshell([\"modprobe\", \"at24\"])\n+    getstatusoutput_noshell([\"rm\", \"-f\", \"/var/cache/sonic/decode-syseeprom/syseeprom_cache\"])\n \n \n def get_local_eth0_mac():\n-    cmd = \"ifconfig eth0 |grep HWaddr\"\n-    print(rj_os_system(cmd))\n+    cmd1 = [\"ifconfig\", \"eth0\"]\n+    cmd2 = [\"grep\", \"HWaddr\"]\n+    print(getstatusoutput_noshell_pipe(cmd1, cmd2))\n \n def getonieversion():\n     if not os.path.isfile('/host/machine.conf'):\n", "add": 6, "remove": 5, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    os.system(\"rmmod at24 \")", "    os.system(\"modprobe at24 \")", "    os.system(\"rm -f /var/cache/sonic/decode-syseeprom/syseeprom_cache\")", "    cmd = \"ifconfig eth0 |grep HWaddr\"", "    print(rj_os_system(cmd))"], "goodparts": ["    getstatusoutput_noshell([\"rmmod\", \"at24\"])", "    getstatusoutput_noshell([\"modprobe\", \"at24\"])", "    getstatusoutput_noshell([\"rm\", \"-f\", \"/var/cache/sonic/decode-syseeprom/syseeprom_cache\"])", "    cmd1 = [\"ifconfig\", \"eth0\"]", "    cmd2 = [\"grep\", \"HWaddr\"]", "    print(getstatusoutput_noshell_pipe(cmd1, cmd2))"]}, {"diff": "\n \n def ipmi_set_mac(mac):\n     macs = mac.split(\":\")\n-    cmdinit = \"ipmitool raw 0x0c 0x01 0x01 0xc2 0x00\"\n-    cmdset = \"ipmitool raw 0x0c 0x01 0x01 0x05\"\n+    cmdinit = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0xc2\", \"0x00\"]\n+    cmdset = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0x05\"]\n     for ind in range(len(macs)):\n-        cmdset += \" 0x%02x\" % int(macs[ind], 16)\n-    rj_os_system(cmdinit)\n-    ret, status = rj_os_system(cmdset)\n+        cmdset.append(\"0x%02x\" % int(macs[ind], 16))\n+    getstatusoutput_noshell(cmdinit)\n+    ret, status = getstatusoutput_noshell(cmdset)\n     if ret:\n         RJPRINTERR(\"\\n\\n%s\\n\\n\" % status)\n         return False\n", "add": 5, "remove": 5, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    cmdinit = \"ipmitool raw 0x0c 0x01 0x01 0xc2 0x00\"", "    cmdset = \"ipmitool raw 0x0c 0x01 0x01 0x05\"", "        cmdset += \" 0x%02x\" % int(macs[ind], 16)", "    rj_os_system(cmdinit)", "    ret, status = rj_os_system(cmdset)"], "goodparts": ["    cmdinit = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0xc2\", \"0x00\"]", "    cmdset = [\"ipmitool\", \"raw\", \"0x0c\", \"0x01\", \"0x01\", \"0x05\"]", "        cmdset.append(\"0x%02x\" % int(macs[ind], 16))", "    getstatusoutput_noshell(cmdinit)", "    ret, status = getstatusoutput_noshell(cmdset)"]}, {"diff": "\n     log_info(\"disable LLDP\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n-    rj_os_system(\"systemctl stop lldp.service\")\n+    getstatusoutput_noshell([\"systemctl\", \"stop\", \"lldp.service\"])\n     log_info(\"disable lldp service\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n-    rj_os_system(\"systemctl stop bgp.service\")\n+    getstatusoutput_noshell([\"systemctl\", \"stop\", \"bgp.service\"])\n     log_info(\"disable bgp service\")\n     sys.stdout.write(\".\")\n     sys.stdout.flush()\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    rj_os_system(\"systemctl stop lldp.service\")", "    rj_os_system(\"systemctl stop bgp.service\")"], "goodparts": ["    getstatusoutput_noshell([\"systemctl\", \"stop\", \"lldp.service\"])", "    getstatusoutput_noshell([\"systemctl\", \"stop\", \"bgp.service\"])"]}, {"diff": "\n     with open(file_name, \"w\") as f:\n         f.write(file_data)\n     print(\"change SDK memory to 256, reboot required\")\n-    rj_os_system(\"sync\")\n-    rj_os_system(\"reboot\")\n+    getstatusoutput_noshell([\"sync\"])\n+    getstatusoutput_noshell([\"reboot\"])\n \n ##########################################################################\n # receives a character setting\n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    rj_os_system(\"sync\")", "    rj_os_system(\"reboot\")"], "goodparts": ["    getstatusoutput_noshell([\"sync\"])", "    getstatusoutput_noshell([\"reboot\"])"]}, {"diff": "\n             return item.get('value',None)\n     return None\n \n-# ====================================\n-# execute shell command\n-# ====================================\n-def rj_os_system(cmd):\n-    status, output = subprocess.getstatusoutput(cmd)\n-    return status, output\n \n ###########################################\n # get memory slot and number via DMI command\n ###########################################\n def getsysmeminfo():\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \"|grep -P -A5 \\\"Memory\\s+Device\\\"|grep Size|grep -v Range\"\n+    cmd1 = [log[0].rstrip('\\n')]\n+    cmd2 = [\"grep\", \"-P\", \"-A5\", \"Memory\\s+Device\"]\n+    cmd3 = [\"grep\", \"Size\"]\n+    cmd4 = [\"grep\", \"-v\", \"Range\"]\n     # get total number first\n     result = []\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3, cmd4)\n     if ret1 == 0 and len(log1):\n         log1 = log1.lstrip()\n         arr = log1.split(\"\\n\")\n", "add": 6, "remove": 9, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["def rj_os_system(cmd):", "    status, output = subprocess.getstatusoutput(cmd)", "    return status, output", "    ret, log = rj_os_system(\"which dmidecode \")", "    cmd = log + \"|grep -P -A5 \\\"Memory\\s+Device\\\"|grep Size|grep -v Range\"", "    ret1, log1 = rj_os_system(cmd)"], "goodparts": ["    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])", "    cmd1 = [log[0].rstrip('\\n')]", "    cmd2 = [\"grep\", \"-P\", \"-A5\", \"Memory\\s+Device\"]", "    cmd3 = [\"grep\", \"Size\"]", "    cmd4 = [\"grep\", \"-v\", \"Range\"]", "    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3, cmd4)"]}, {"diff": "\n # return various arrays\n ###########################################\n def getsysmeminfo_detail():\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \" -t 17 | grep  -A21 \\\"Memory Device\\\"\"  # 17\n+    cmd1 = [log[0].rstrip('\\n')] + [\"-t\", \"17\"]\n+    cmd2 = [\"grep\", \"-A21\", \"Memory Device\"]  # 17\n     # get total number\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)\n     if ret1 != 0 or len(log1) <= 0:\n-        return False, \"command execution error[%s]\" % cmd\n+        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)\n     result_t = log1.split(\"--\")\n     mem_rets = []\n     for item in result_t:\n", "add": 5, "remove": 4, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    ret, log = rj_os_system(\"which dmidecode \")", "    cmd = log + \" -t 17 | grep  -A21 \\\"Memory Device\\\"\"  # 17", "    ret1, log1 = rj_os_system(cmd)", "        return False, \"command execution error[%s]\" % cmd"], "goodparts": ["    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])", "    cmd1 = [log[0].rstrip('\\n')] + [\"-t\", \"17\"]", "    cmd2 = [\"grep\", \"-A21\", \"Memory Device\"]  # 17", "    ret1, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)", "        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)"]}, {"diff": "\n # get BIOS info via DMI command\n ###########################################\n def getDmiSysByType(type_t):\n-    ret, log = rj_os_system(\"which dmidecode \")\n+    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])\n     if ret != 0 or len(log) <= 0:\n         error = \"cmd find dmidecode\"\n         return False, error\n-    cmd = log + \" -t %s\" % type_t\n+    cmd = [log[0].rstrip('\\n')] + [\"-t\", str(type_t)]\n     # get total number\n-    ret1, log1 = rj_os_system(cmd)\n+    ret1, log1 = getstatusoutput_noshell(cmd)\n     if ret1 != 0 or len(log1) <= 0:\n         return False, \"command execution error[%s]\" % cmd\n     its = log1.replace(\"\\t\", \"\").strip().split(\"\\n\")\n", "add": 3, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    ret, log = rj_os_system(\"which dmidecode \")", "    cmd = log + \" -t %s\" % type_t", "    ret1, log1 = rj_os_system(cmd)"], "goodparts": ["    ret, log = getstatusoutput_noshell([\"which\", \"dmidecode\"])", "    cmd = [log[0].rstrip('\\n')] + [\"-t\", str(type_t)]", "    ret1, log1 = getstatusoutput_noshell(cmd)"]}, {"diff": "\n         return False, \"Err\"\n \n def get_cpu_info():\n-    cmd = \"cat /proc/cpuinfo |grep processor -A18\"  # 17\n+    cmd1 = [\"cat\", \"/proc/cpuinfo\"]\n+    cmd2 = [\"grep\", \"processor\", \"-A18\"]  # 17\n \n-    ret, log1 = rj_os_system(cmd)\n+    ret, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)\n     if ret != 0 or len(log1) <= 0:\n-        return False, \"command execution error[%s]\" % cmd\n+        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)\n     result_t = log1.split(\"--\")\n     mem_rets = []\n     for item in result_t:\n", "add": 4, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-ruijie/common/script/ruijieutil.py", "badparts": ["    cmd = \"cat /proc/cpuinfo |grep processor -A18\"  # 17", "    ret, log1 = rj_os_system(cmd)", "        return False, \"command execution error[%s]\" % cmd"], "goodparts": ["    cmd1 = [\"cat\", \"/proc/cpuinfo\"]", "    cmd2 = [\"grep\", \"processor\", \"-A18\"]  # 17", "    ret, log1 = getstatusoutput_noshell_pipe(cmd1, cmd2)", "        return False, \"command execution error[%s][%s]\" % (cmd1, cmd2)"]}]}}, "msg": "[ruijie] Replace os.system and remove subprocess with shell=True (#12107)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\nDependency: [https://github.com/sonic-net/sonic-buildimage/pull/12065](https://github.com/sonic-net/sonic-buildimage/pull/12065)\r\n#### Why I did it\r\n1. `getstatusoutput` is used without a static string and it uses `shell=True`\r\n2. `subprocess()` - when using with `shell=True` is dangerous. Using subprocess function without a static string can lead to command injection.\r\n3. `os` - not secure against maliciously constructed input and dangerous if used to evaluate dynamic content.\r\n#### How I did it\r\n1. use `getstatusoutput` without shell=True\r\n2. `subprocess()` - use `shell=False` instead. use an array string. Ref: [https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation](https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation)\r\n3. `os` - use with `subprocess`"}, "51a1eb112b8a3e00b4c5857afb470bb0e4d24433": {"url": "https://api.github.com/repos/mohsin75/sonic-buildimage/commits/51a1eb112b8a3e00b4c5857afb470bb0e4d24433", "html_url": "https://github.com/mohsin75/sonic-buildimage/commit/51a1eb112b8a3e00b4c5857afb470bb0e4d24433", "sha": "51a1eb112b8a3e00b4c5857afb470bb0e4d24433", "keyword": "command injection attack", "diff": "diff --git a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py\nindex 4b081f4e3c..35c045dad3 100644\n--- a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py\n+++ b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py\n@@ -24,7 +24,6 @@\n RESET_REGISTER = \"0x112\"\n HOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/previous-reboot-cause.txt\"\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n STATUS_LED_PATH = \"/sys/devices/platform/e1031.smc/master_led\"\n \n \ndiff --git a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py\nindex 08e8fc4147..7d3b37e365 100644\n--- a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py\n+++ b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py\n@@ -1,8 +1,8 @@\n import os\r\n+import ast\r\n import imp\r\n import yaml\r\n import subprocess\r\n-\r\n from sonic_py_common import device_info\r\n \r\n \r\n@@ -24,7 +24,7 @@ class Common:\n \r\n     SET_METHOD_IPMI = 'ipmitool'\r\n     NULL_VAL = 'N/A'\r\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\r\n+    HOST_CHK_CMD = [\"docker\"]\r\n     REF_KEY = '$ref:'\r\n \r\n     def __init__(self, conf=None):\r\n@@ -46,8 +46,7 @@ def run_command(self, command):\n         status = False\r\n         output = \"\"\r\n         try:\r\n-            p = subprocess.Popen(\r\n-                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n+            p = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n             raw_data, err = p.communicate()\r\n             if p.returncode == 0:\r\n                 status, output = True, raw_data.strip()\r\n@@ -67,7 +66,7 @@ def _clean_input(self, input, config):\n             cleaned_input = input_translator.get(input)\r\n \r\n         elif type(input_translator) is str:\r\n-            cleaned_input = eval(input_translator.format(input))\r\n+            cleaned_input = ast.literal_eval(input_translator.format(input))\r\n \r\n         return cleaned_input\r\n \r\n@@ -77,19 +76,12 @@ def _clean_output(self, index, output, config):\n         if type(output_translator) is dict:\r\n             output = output_translator.get(output)\r\n         elif type(output_translator) is str:\r\n-            output = eval(output_translator.format(output))\r\n+            output = ast.literal_eval(output_translator.format(output))\r\n         elif type(output_translator) is list:\r\n-            output = eval(output_translator[index].format(output))\r\n+            output = ast.literal_eval(output_translator[index].format(output))\r\n \r\n         return output\r\n \r\n-    def _ipmi_get(self, index, config):\r\n-        argument = config.get('argument')\r\n-        cmd = config['command'].format(\r\n-            config['argument'][index]) if argument else config['command']\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n-\r\n     def _sysfs_read(self, index, config):\r\n         sysfs_path = config.get('sysfs_path')\r\n         argument = config.get('argument', '')\r\n@@ -132,10 +124,6 @@ def _sysfs_write(self, index, config, input):\n             return False, output\r\n         return True, output\r\n \r\n-    def _ipmi_set(self, index, config, input):\r\n-        arg = config['argument'][index].format(input)\r\n-        return self.run_command(config['command'].format(arg))\r\n-\r\n     def _hex_ver_decode(self, hver, num_of_bits, num_of_points):\r\n         ver_list = []\r\n         c_bit = 0\r\n@@ -159,14 +147,16 @@ def _get_class(self, config):\n         return class_\r\n \r\n     def get_reg(self, path, reg_addr):\r\n-        cmd = \"echo {1} > {0}; cat {0}\".format(path, reg_addr)\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n+        with open(path, 'w') as file:\r\n+            file.write(reg_addr + '\\n')\r\n+        with open(path, 'r') as file:\r\n+            output = file.readline().strip()\r\n+        return output\r\n \r\n     def set_reg(self, path, reg_addr, value):\r\n-        cmd = \"echo {0} {1} > {2}\".format(reg_addr, value, path)\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n+        with open(path, 'w') as file:\r\n+            file.write(\"{0} {1}\\n\".format(reg_addr, value))\r\n+        return None\r\n \r\n     def read_txt_file(self, path):\r\n         try:\r\n@@ -195,7 +185,11 @@ def write_txt_file(self, file_path, value):\n         return True\r\n \r\n     def is_host(self):\r\n-        return os.system(self.HOST_CHK_CMD) == 0\r\n+        try:\r\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\r\n+        except FileNotFoundError:\r\n+            return False\r\n+        return True\r\n \r\n     def load_json_file(self, path):\r\n         \"\"\"\r\n@@ -221,87 +215,6 @@ def get_config_path(self, config_name):\n         \"\"\"\r\n         return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\r\n \r\n-    def get_output(self, index, config, default):\r\n-        \"\"\"\r\n-        Retrieves the output for each function base on config\r\n-\r\n-        Args:\r\n-            index: An integer containing the index of device.\r\n-            config: A dict object containing the configuration of specified function.\r\n-            default: A string containing the default output of specified function.\r\n-\r\n-        Returns:\r\n-            A string containing the output of specified function in config\r\n-        \"\"\"\r\n-        output_source = config.get('output_source')\r\n-\r\n-        if output_source == self.OUTPUT_SOURCE_IPMI:\r\n-            output = self._ipmi_get(index, config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VALUE:\r\n-            output = config[\"value\"]\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_CLASS:\r\n-            output = self._get_class(config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_LIST:\r\n-            output = config[\"value_list\"][index]\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_SYSFS:\r\n-            output = self._sysfs_read(index, config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_FUNC:\r\n-            func_conf = self._main_conf[config['function'][index]]\r\n-            output = self.get_output(index, func_conf, default)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\r\n-            path = config.get('path')\r\n-            output = self.read_txt_file(path)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\r\n-            path = config.get('path')\r\n-            hex_ver = self.read_txt_file(path)\r\n-            output = self._hex_ver_decode(\r\n-                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\r\n-            path = config.get('path')\r\n-            addr = config.get('reg_addr')\r\n-            hex_ver = self.get_reg(path, addr)\r\n-            output = self._hex_ver_decode(\r\n-                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n-\r\n-        else:\r\n-            output = default\r\n-\r\n-        return self._clean_output(index, output, config) or default\r\n-\r\n-    def set_output(self, index, input, config):\r\n-        \"\"\"\r\n-        Sets the output of specified function on config\r\n-\r\n-        Args:\r\n-            config: A dict object containing the configuration of specified function.\r\n-            index: An integer containing the index of device.\r\n-            input: A string containing the input of specified function.\r\n-\r\n-        Returns:\r\n-            bool: True if set function is successfully, False if not\r\n-        \"\"\"\r\n-        cleaned_input = self._clean_input(input, config)\r\n-        if not cleaned_input:\r\n-            return False\r\n-\r\n-        set_method = config.get('set_method')\r\n-        if set_method == self.SET_METHOD_IPMI:\r\n-            output = self._ipmi_set(index, config, cleaned_input)[0]\r\n-        elif set_method == self.OUTPUT_SOURCE_SYSFS:\r\n-            output = self._sysfs_write(index, config, cleaned_input)[0]\r\n-        else:\r\n-            output = False\r\n-\r\n-        return output\r\n-\r\n     def get_event(self, timeout, config, sfp_list):\r\n         \"\"\"\r\n         Returns a nested dictionary containing all devices which have\r\ndiff --git a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py\nindex 56fae35914..6e33e33401 100644\n--- a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py\n+++ b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py\n@@ -10,7 +10,6 @@\n try:\n     import os.path\n     import shutil\n-    import shlex\n     import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n except ImportError as e:\n@@ -39,8 +38,7 @@ def __init__(self, component_index):\n     def __run_command(self, command):\n         # Run bash command and print output to stdout\n         try:\n-            process = subprocess.Popen(\n-                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n+            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n             while True:\n                 output = process.stdout.readline()\n                 if output == '' and process.poll() is not None:\n@@ -63,12 +61,10 @@ def __get_bios_version(self):\n \n     def get_register_value(self, register):\n         # Retrieves the cpld register value\n-        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n-        p = subprocess.Popen(\n-            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-        raw_data, err = p.communicate()\n-        if err is not '':\n-            return None\n+        with open(GETREG_PATH, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(GETREG_PATH, 'r') as file:\n+            raw_data = file.readline()\n         return raw_data.strip()\n \n     def __get_cpld_version(self):\n@@ -76,11 +72,11 @@ def __get_cpld_version(self):\n         cpld_version = dict()\n         with open(SMC_CPLD_PATH, 'r') as fd:\n             smc_cpld_version = fd.read()\n-        smc_cpld_version = 'None' if smc_cpld_version is 'None' else \"{}.{}\".format(\n+        smc_cpld_version = 'None' if smc_cpld_version == 'None' else \"{}.{}\".format(\n             int(smc_cpld_version[2], 16), int(smc_cpld_version[3], 16))\n \n         mmc_cpld_version = self.get_register_value(MMC_CPLD_ADDR)\n-        mmc_cpld_version = 'None' if mmc_cpld_version is 'None' else \"{}.{}\".format(\n+        mmc_cpld_version = 'None' if mmc_cpld_version == 'None' else \"{}.{}\".format(\n             int(mmc_cpld_version[2], 16), int(mmc_cpld_version[3], 16))\n \n         cpld_version[\"SMC_CPLD\"] = smc_cpld_version\n@@ -159,7 +155,7 @@ def install_firmware(self, image_path):\n             ext = \".vme\" if ext == \"\" else ext\n             new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n             shutil.copy(image_path, new_image_path)\n-            install_command = \"ispvm %s\" % new_image_path\n+            install_command = [\"ispvm\", str(new_image_path)]\n         # elif self.name == \"BIOS\":\n         #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n         return self.__run_command(install_command)\ndiff --git a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py\nindex 75307d2914..144fdae215 100644\n--- a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py\n+++ b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py\n@@ -73,6 +73,5 @@ def execute(self, thermal_info_dict):\n         thermal_overload_position = Common().read_txt_file(\r\n             thermal_overload_position_path)\r\n \r\n-        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\r\n-            thermal_overload_position)\r\n+        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', thermal_overload_position]\r\n         Common().run_command(cmd)\r\ndiff --git a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py\nindex 2e379f8c2a..28e113fb7e 100644\n--- a/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py\n+++ b/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py\n@@ -6,7 +6,7 @@\n \n \n class ThermalManager(ThermalManagerBase):\n-    FSC_ALGORITHM_CMD = ' supervisorctl {} fancontrol'\n+    FSC_ALGORITHM_CMD = ['supervisorctl', '', 'fancontrol']\n \n     @classmethod\n     def start_thermal_control_algorithm(cls):\n@@ -43,5 +43,5 @@ def _enable_fancontrol_service(cls, enable):\n         Returns:\n             bool: True if set success, False if fail.\n         \"\"\"\n-        cmd = 'start' if enable else 'stop'\n-        return Common().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n+        cls.FSC_ALGORITHM_CMD[1] = 'start' if enable else 'stop'\n+        return Common().run_command(cls.FSC_ALGORITHM_CMD)\ndiff --git a/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py b/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py\nindex 0c93576e1f..13c19841ed 100644\n--- a/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py\n+++ b/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py\n@@ -6,8 +6,6 @@\n #\n #############################################################################\n \n-import os.path\n-import subprocess\n \n try:\n     from sonic_psu.psu_base import PsuBase\ndiff --git a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py\nindex 8a9ed17139..2fc2c60fdc 100644\n--- a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py\n+++ b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py\n@@ -26,7 +26,6 @@\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n GETREG_PATH = \"/sys/devices/platform/dx010_cpld/getreg\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n STATUS_LED_PATH = \"/sys/devices/platform/leds_dx010/leds/dx010:green:stat/brightness\"\n \n \ndiff --git a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py\nindex 782708025a..da735d2ac0 100644\n--- a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py\n+++ b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py\n@@ -8,7 +8,6 @@\n \n import os.path\n import shutil\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n@@ -52,12 +51,10 @@ def __get_bios_version(self):\n \n     def get_register_value(self, register):\n         # Retrieves the cpld register value\n-        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n-        p = subprocess.Popen(\n-            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-        raw_data, err = p.communicate()\n-        if err is not '':\n-            return None\n+        with open(GETREG_PATH, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(GETREG_PATH, 'r') as file:\n+            raw_data = file.readline()\n         return raw_data.strip()\n \n     def __get_cpld_version(self):\n@@ -146,11 +143,11 @@ def install_firmware(self, image_path):\n             ext = \".vme\" if ext == \"\" else ext\n             new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n             shutil.copy(image_path, new_image_path)\n-            install_command = \"ispvm %s\" % new_image_path\n+            install_command = [\"ispvm\", str(new_image_path)]\n         # elif self.name == \"BIOS\":\n         #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n \n-        return self.__run_command(install_command)\n+        return self._api_helper.run_command(install_command)\n \n \n     def update_firmware(self, image_path):\ndiff --git a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py\nindex 140c62c086..a77d27837e 100644\n--- a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py\n+++ b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py\n@@ -5,7 +5,7 @@\n \n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -15,7 +15,11 @@ def __init__(self):\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -35,7 +39,7 @@ def run_command(self, cmd):\n         result = \"\"\n         try:\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = raw_data.strip()\n@@ -43,13 +47,6 @@ def run_command(self, cmd):\n             status = False\n         return status, result\n \n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n@@ -77,57 +74,9 @@ def write_txt_file(self, file_path, value):\n         return True\n \n     def get_cpld_reg_value(self, getreg_path, register):\n-        cmd = \"echo {1} > {0}; cat {0}\".format(getreg_path, register)\n-        status, result = self.run_command(cmd)\n-        return result if status else None\n+        with open(getreg_path, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(getreg_path, 'r') as file:\n+            result = file.readline()\n+        return result\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(\n-                str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status, result\ndiff --git a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py\nindex 545db861f6..fc55445d0e 100644\n--- a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py\n+++ b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py\n@@ -73,6 +73,5 @@ def execute(self, thermal_info_dict):\n         thermal_overload_position = APIHelper().read_one_line_file(\n             thermal_overload_position_path)\n \n-        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\n-            thermal_overload_position)\n+        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', str(thermal_overload_position)]\n         APIHelper().run_command(cmd)\ndiff --git a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py\nindex 9f057cf1f3..dfd4abc40b 100644\n--- a/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py\n+++ b/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py\n@@ -5,7 +5,7 @@\n from .thermal_infos import *\n \n class ThermalManager(ThermalManagerBase):\n-    FSC_ALGORITHM_CMD = 'service fancontrol {}'\n+    FSC_ALGORITHM_CMD = ['service', 'fancontrol', '']\n \n     @classmethod\n     def start_thermal_control_algorithm(cls):\n@@ -42,5 +42,5 @@ def _enable_fancontrol_service(cls, enable):\n         Returns:\n             bool: True if set success, False if fail.\n         \"\"\"\n-        cmd = 'start' if enable else 'stop'\n-        return APIHelper().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n+        cls.FSC_ALGORITHM_CMD[2] = 'start' if enable else 'stop'\n+        return APIHelper().run_command(cls.FSC_ALGORITHM_CMD)\ndiff --git a/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py b/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py\nindex cc5461ccb5..2eb92eb919 100644\n--- a/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py\n+++ b/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py\n@@ -1,10 +1,9 @@\n-import os.path\n-import subprocess\n import sys\n import re\n \n try:\n     from sonic_psu.psu_base import PsuBase\n+    from sonic_py_common.general import getstatusoutput_noshell_pipe\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n@@ -13,16 +12,16 @@ class PsuUtil(PsuBase):\n     \"\"\"Platform-specific PSUutil class\"\"\"\n \n     def __init__(self):\n-        self.ipmi_sensor = \"ipmitool sensor\"\n+        self.ipmi_sensor = [\"ipmitool\", \"sensor\"]\n         PsuBase.__init__(self)\n \n-    def run_command(self, command):\n-        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n-        (out, err) = proc.communicate()\n-\n-        if proc.returncode != 0:\n-            sys.exit(proc.returncode)\n-\n+    def run_command(self, cmd1, cmd2):\n+        exitcode, out = getstatusoutput_noshell_pipe(cmd1, cmd2)\n+        i = 0\n+        while i < 2:\n+            if exitcode[i] != 0:\n+                sys.exit(exitcode[i])\n+            i += 1\n         return out\n \n     def find_value(self, grep_string):\n@@ -50,7 +49,8 @@ def get_psu_status(self, index):\n             return False\n \n         grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n-        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n+        grep_cmd = [\"grep\", grep_key]\n+        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)\n         status_byte = self.find_value(grep_string)\n \n         if status_byte is None:\n@@ -74,7 +74,8 @@ def get_psu_presence(self, index):\n             return False\n \n         grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n-        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n+        grep_cmd = [\"grep\", grep_key]\n+        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)\n         status_byte = self.find_value(grep_string)\n \n         if status_byte is None:\ndiff --git a/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py b/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py\nindex ca75ad9833..46684aae0f 100644\n--- a/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py\n+++ b/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py\n@@ -1,4 +1,3 @@\n-import os.path\n import subprocess\n import sys\n import re\n@@ -13,13 +12,13 @@ class PsuUtil(PsuBase):\n     \"\"\"Platform-specific PSUutil class\"\"\"\n \n     def __init__(self):\n-        self.ipmi_raw = \"docker exec -ti pmon ipmitool raw 0x4 0x2d\"\n+        self.ipmi_raw = [\"docker\", \"exec\", \"-ti\", \"pmon\", \"ipmitool\", \"raw\", \"0x4\", \"0x2d\", \"\"]\n         self.psu1_id = \"0x2f\"\n         self.psu2_id = \"0x39\"\n         PsuBase.__init__(self)\n \n     def run_command(self, command):\n-        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n         (out, err) = proc.communicate()\n \n         if proc.returncode != 0:\n@@ -52,7 +51,8 @@ def get_psu_status(self, index):\n             return False\n \n         psu_id = self.psu1_id if index == 1 else self.psu2_id\n-        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n+        self.ipmi_raw[8] = psu_id\n+        res_string = self.run_command(self.ipmi_raw)\n         status_byte = self.find_value(res_string)\n \n         if status_byte is None:\n@@ -76,7 +76,8 @@ def get_psu_presence(self, index):\n             return False\n \n         psu_id = self.psu1_id if index == 1 else self.psu2_id\n-        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n+        self.ipmi_raw[8] = psu_id\n+        res_string = self.run_command(self.ipmi_raw)\n         status_byte = self.find_value(res_string)\n \n         if status_byte is None:\ndiff --git a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py\nindex bbbb9f1d45..ba7742c66b 100644\n--- a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py\n+++ b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py\n@@ -6,7 +6,6 @@\n #\n #############################################################################\n \n-import json\n import os.path\n \n try:\n@@ -24,14 +23,18 @@\n ]\n SW_CPLD_VER_PATH = \"/sys/module/switch_cpld/version\"\n BASE_CPLD_VER_PATH = \"/sys/module/baseboard_lpc/version\"\n-CPLD_UPGRADE_OPT = 4\n BIOS_VER_PATH = \"/sys/class/dmi/id/bios_version\"\n-BIOS__UPGRADE_OPT = 2\n-BMC_VER_CMD = \"ipmitool mc info | grep 'Firmware Revision'\"\n-BMC_UPGRADE_OPT = 1\n-CFUFLASH_FW_UPGRADE_CMD = \"CFUFLASH -cd -d {} -mse 3 {}\"\n+BMC_VER_CMD1 = [\"ipmitool\", \"mc\", \"info\"]\n+BMC_VER_CMD2 = [\"grep\", \"Firmware Revision\"]\n+CFUFLASH_FW_UPGRADE_CMD = [\"CFUFLASH\", \"-cd\", \"-d\", \"\", \"-mse\", \"3\", \"\"]\n MEM_PCI_RESOURCE = \"/sys/bus/pci/devices/0000:09:00.0/resource0\"\n FPGA_VER_MEM_OFFSET = 0\n+UPGRADE_OPT = {\n+    'BMC': '1',\n+    'BIOS': '2',\n+    'SWITCH_CPLD': '4',\n+    'BASE_CPLD': '4'\n+}\n \n \n class Component(ComponentBase):\n@@ -47,7 +50,7 @@ def __init__(self, component_index):\n \n     def __get_bmc_ver(self):\n         bmc_ver = \"Unknown\"\n-        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD)\n+        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD1, BMC_VER_CMD2)\n         if status:\n             bmc_ver_data = raw_bmc_data.split(\":\")\n             bmc_ver = bmc_ver_data[-1].strip() if len(\n@@ -104,16 +107,12 @@ def install_firmware(self, image_path):\n         Returns:\n             A boolean, True if install successfully, False if not\n         \"\"\"\n-        install_command = {\n-            \"BMC\": CFUFLASH_FW_UPGRADE_CMD.format(BMC_UPGRADE_OPT, image_path),\n-            \"BIOS\": CFUFLASH_FW_UPGRADE_CMD.format(BIOS__UPGRADE_OPT, image_path),\n-            \"SWITCH_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path),\n-            \"BASE_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path)\n-        }.get(self.name, None)\n-\n-        if not os.path.isfile(image_path) or install_command is None:\n+        CFUFLASH_FW_UPGRADE_CMD[3] = UPGRADE_OPT.get(self.name)\n+        CFUFLASH_FW_UPGRADE_CMD[6] = image_path\n+\n+        if not os.path.isfile(image_path):\n             return False\n \n         # print(install_command)\n-        status = self._api_helper.run_interactive_command(install_command)\n+        status = self._api_helper.run_interactive_command(CFUFLASH_FW_UPGRADE_CMD)\n         return status\ndiff --git a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py\nindex 144d9e1543..d53de841ee 100644\n--- a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py\n+++ b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py\n@@ -2,8 +2,9 @@\n import struct\n import subprocess\n from mmap import *\n+from sonic_py_common.general import check_output_pipe\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n@@ -13,7 +14,11 @@ def __init__(self):\n         pass\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def pci_get_value(self, resource, offset):\n         status = True\n@@ -28,22 +33,18 @@ def pci_get_value(self, resource, offset):\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n+    def run_command(self, cmd1_args, cmd2_args):\n         status = True\n         result = \"\"\n         try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except:\n+            result = check_output_pipe(cmd1_args, cmd2_args)\n+        except subprocess.CalledProcessError:\n             status = False\n         return status, result\n \n     def run_interactive_command(self, cmd):\n         try:\n-            os.system(cmd)\n+            subprocess.call(cmd)\n         except:\n             return False\n         return True\n@@ -61,9 +62,9 @@ def ipmi_raw(self, netfn, cmd):\n         status = True\n         result = \"\"\n         try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n+            cmd = [\"ipmitool\", \"raw\", str(netfn), str(cmd)]\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = raw_data.strip()\n@@ -76,28 +77,30 @@ def ipmi_raw(self, netfn, cmd):\n     def ipmi_fru_id(self, id, key=None):\n         status = True\n         result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n+        cmd1_args = [\"ipmitool\", \"fru\", \"print\", str(id)]\n+        if not key:\n+            try:\n+                p = subprocess.Popen(\n+                    cmd1_args, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                raw_data, err = p.communicate()\n+                if err == '':\n+                    result = raw_data.strip()\n+                else:\n+                    status = False\n+            except:\n                 status = False\n-        except:\n-            status = False\n+        else:\n+            cmd2_args = [\"grep\", str(key)]\n+            status, result = self.run_command(cmd1_args, cmd2_args)\n         return status, result\n \n     def ipmi_set_ss_thres(self, id, threshold_key, value):\n         status = True\n         result = \"\"\n         try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n+            cmd = [\"ipmitool\", \"sensor\", \"thresh\", str(id), str(threshold_key), str(value)]\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = raw_data.strip()\ndiff --git a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py\nindex 9ad0f1dc93..a6c805d3ca 100644\n--- a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py\n+++ b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py\n@@ -33,20 +33,15 @@\n PSU_LED_GREEN_CMD = \"0x01\"\n PSU_LED_AMBER_CMD = \"0x02\"\n \n-PSU1_VOUT_SS_ID = \"0x36\"\n-PSU1_COUT_SS_ID = \"0x37\"\n-PSU1_POUT_SS_ID = \"0x38\"\n-PSU1_STATUS_REG = \"0x39\"\n-\n-PSU2_VOUT_SS_ID = \"0x40\"\n-PSU2_COUT_SS_ID = \"0x41\"\n-PSU2_POUT_SS_ID = \"0x42\"\n-PSU2_STATUS_REG = \"0x2f\"\n-\n PSU1_FRU_ID = 3\n \n SS_READ_OFFSET = 0\n \n+PSU_VOUT_SS_ID = [\"0x36\", \"0x40\"]\n+PSU_COUT_SS_ID = [\"0x37\", \"0x41\"]\n+PSU_POUT_SS_ID = [\"0x38\", \"0x42\"]\n+PSU_STATUS_REG = [\"0x39\", \"0x2f\"]\n+\n \n class Psu(PsuBase):\n     \"\"\"Platform-specific Psu class\"\"\"\n@@ -71,7 +66,7 @@ def get_voltage(self):\n             e.g. 12.1\n         \"\"\"\n         psu_voltage = 0.0\n-        psu_vout_key = globals()['PSU{}_VOUT_SS_ID'.format(self.index+1)]\n+        psu_vout_key = PSU_VOUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_vout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n@@ -87,7 +82,7 @@ def get_current(self):\n             A float number, the electric current in amperes, e.g 15.4\n         \"\"\"\n         psu_current = 0.0\n-        psu_cout_key = globals()['PSU{}_COUT_SS_ID'.format(self.index+1)]\n+        psu_cout_key = PSU_COUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_cout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n@@ -103,7 +98,7 @@ def get_power(self):\n             A float number, the power in watts, e.g. 302.6\n         \"\"\"\n         psu_power = 0.0\n-        psu_pout_key = globals()['PSU{}_POUT_SS_ID'.format(self.index+1)]\n+        psu_pout_key = PSU_POUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n@@ -176,7 +171,7 @@ def get_presence(self):\n             bool: True if PSU is present, False if not\n         \"\"\"\n         psu_presence = False\n-        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n+        psu_pstatus_key = PSU_STATUS_REG[self.index]\n         status, raw_status_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n         status_byte = self.find_value(raw_status_read)\n@@ -228,7 +223,7 @@ def get_status(self):\n             A boolean value, True if device is operating properly, False if not\n         \"\"\"\n         psu_status = False\n-        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n+        psu_pstatus_key = PSU_STATUS_REG[self.index]\n         status, raw_status_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n         status_byte = self.find_value(raw_status_read)\ndiff --git a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py\nindex c22c7a9b75..4ad97b42ff 100644\n--- a/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py\n+++ b/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py\n@@ -6,7 +6,6 @@\n #\n #############################################################################\n \n-import os\n import time\n import subprocess\n from ctypes import create_string_buffer\n@@ -168,7 +167,7 @@ class Sfp(SfpBase):\n     # Path to QSFP sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-cel_silverstone-r0\"\n     HWSKU = \"Silverstone\"\n@@ -270,7 +269,11 @@ def __convert_string_to_num(self, value_str):\n             return 'N/A'\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])\ndiff --git a/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py b/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py\nindex e4f3e1257d..7fee0aee58 100644\n--- a/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py\n+++ b/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py\n@@ -8,19 +8,18 @@\n #\r\n #############################################################################\r\n \r\n-import os.path\r\n import subprocess\r\n-import time\r\n-import os\r\n \r\n try:\r\n     from sonic_platform_base.component_base import ComponentBase\r\n+    from sonic_py_common.general import getstatusoutput_noshell_pipe\r\n     #from helper import APIHelper\r\n except ImportError as e:\r\n     raise ImportError(str(e) + \"- required module not found\")\r\n \r\n-SWCPLD_VERSION_PATH = \"i2cget -y -f 2 0x32 0\"\r\n-BIOS_VERSION_PATH = \"dmidecode -t bios | grep Version\"\r\n+SWCPLD_VERSION_PATH = [\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0\"]\r\n+BIOS_VERSION_PATH_CMD1 = [\"dmidecode\", \"-t\", \"bios\"]\r\n+BIOS_VERSION_PATH_CMD2 = [\"grep\", \"Version\"]\r\n COMPONENT_NAME_LIST = [\"SWCPLD\", \"Main_BIOS\", \"Backup_BIOS\"]\r\n COMPONENT_DES_LIST = [\"Use for boot control and BIOS switch\",\r\n                       \"Main basic Input/Output System\",\r\n@@ -39,15 +38,15 @@ def __init__(self, component_index):\n         self.name = self.get_name()\r\n \r\n     def run_command(self,cmd):\r\n-        responses = os.popen(cmd).read()\r\n+        responses = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()\r\n         return responses\r\n \r\n     def __get_bios_version(self):\r\n         # Retrieves the BIOS firmware version\r\n-        result = self.run_command(\"i2cget -y -f 2 0x32 0x19\")\r\n+        result = self.run_command([\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0x19\"])\r\n         if result.strip() == \"0x01\":\r\n             if self.name == \"Main_BIOS\":\r\n-                version = self.run_command(BIOS_VERSION_PATH)\r\n+                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r\n                 bios_version = version.strip().split(\" \")[1]\r\n                 return str(bios_version)\r\n             elif self.name == \"Backup_BIOS\":\r\n@@ -56,7 +55,7 @@ def __get_bios_version(self):\n                 \r\n         elif result.strip() == \"0x03\":\r\n             if self.name == \"Backup_BIOS\":\r\n-                version = self.run_command(BIOS_VERSION_PATH)\r\n+                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r\n                 bios_version = version.strip().split(\" \")[1]\r\n                 return str(bios_version)\r\n             elif self.name == \"Main_BIOS\":\r\ndiff --git a/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py b/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py\nindex 36e95f2c0c..d5ee08049d 100644\n--- a/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py\n+++ b/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py\n@@ -1,6 +1,6 @@\n try:\n     from sonic_platform_pddf_base.pddf_fan import PddfFan\n-    import os\n+    import subprocess\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n # ------------------------------------------------------------------\n@@ -47,8 +47,9 @@ def get_direction(self):\n         \"\"\"\n         if self.is_psu_fan:\n             cmd_num = \"58\" if self.fans_psu_index == 1 else \"59\"\n-            cmd = \"i2cget -y -f 4 0x%s 0x80\" % cmd_num\n-            res = os.popen(cmd).read()\n+            cmd = [\"i2cget\", \"-y\", \"-f\", \"4\", \"\", \"0x80\"]\n+            cmd[4] = \"0x\" + cmd_num\n+            res = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()\n             # F2B \n             if res.strip() == \"0x01\":\n                 direction = \"EXHAUST\"\ndiff --git a/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py b/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py\nindex 017a04709f..5ce0469a0d 100755\n--- a/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py\n+++ b/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py\n@@ -23,13 +23,13 @@\n try:\n     import sys\n     import getopt\n-    import subprocess\n     import logging\n     import logging.config\n     import time  # this is only being used as part of the example\n     import signal\n     import math\n     from sonic_platform import platform\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n@@ -224,7 +224,7 @@ def handler(signum, frame):\n         else:\n             logging.debug('INFO: FAIL. set_fan_duty_cycle (%d)' % DUTY_MAX)\n         # Enable the CPLD Heartbeat back\n-        status, output = subprocess.getstatusoutput('i2cset -f -y 75 0x40 0x22 0x00')\n+        status, output = getstatusoutput_noshell([\"i2cset\", \"-f\", \"-y\", \"75\", \"0x40\", \"0x22\", \"0x00\"])\n         if status == 0:\n             logging.debug('INFO: CPLD Heartbeat check is enabled back')\n     sys.exit(0)\n@@ -258,7 +258,7 @@ def main(argv):\n     signal.signal(signal.SIGINT, handler)\n     signal.signal(signal.SIGTERM, handler)\n     # Disaable the CPLD Heartbeat check to control Fan speed from CPU via ADT7470\n-    subprocess.getstatusoutput('i2cset -f -y 2 0x32 0x30 0x01')\n+    getstatusoutput_noshell(['i2cset', '-f', '-y', '2', '0x32', '0x30', '0x01'])\n \n     monitor = cel_belgite_monitor(log_file, log_level)\n \ndiff --git a/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py b/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py\nindex 697308b8c3..2d96835997 100644\n--- a/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py\n+++ b/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py\n@@ -1,4 +1,5 @@\n import os\n+import ast\n import imp\n import yaml\n import subprocess\n@@ -24,7 +25,7 @@ class Common:\n \n     SET_METHOD_IPMI = 'ipmitool'\n     NULL_VAL = 'N/A'\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n     REF_KEY = '$ref:'\n \n     def __init__(self, conf=None):\n@@ -56,7 +57,7 @@ def _clean_input(self, input, config):\n             cleaned_input = input_translator.get(input)\n \n         elif type(input_translator) is str:\n-            cleaned_input = eval(input_translator.format(input))\n+            cleaned_input = ast.literal_eval(input_translator.format(input))\n \n         return cleaned_input\n \n@@ -66,9 +67,9 @@ def _clean_output(self, index, output, config):\n         if type(output_translator) is dict:\n             output = output_translator.get(output)\n         elif type(output_translator) is str:\n-            output = eval(output_translator.format(output))\n+            output = ast.literal_eval(output_translator.format(output))\n         elif type(output_translator) is list:\n-            output = eval(output_translator[index].format(output))\n+            output = ast.literal_eval(output_translator[index].format(output))\n \n         return output\n \n@@ -166,7 +167,11 @@ def write_txt_file(self, file_path, value):\n         return True\n \n     def is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def load_json_file(self, path):\n         \"\"\"\ndiff --git a/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py b/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py\nindex 186ee6c545..1aa1c07198 100755\n--- a/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py\n+++ b/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py\n@@ -12,7 +12,7 @@\n import logging\n import subprocess\n \n-IPMI_SDR_CMD = \"ipmitool sdr elist\"\n+IPMI_SDR_CMD = [\"ipmitool\", \"sdr\", \"elist\"]\n MAX_NUM_FANS = 7\n MAX_NUM_PSUS = 2\n \n@@ -23,7 +23,7 @@ def ipmi_sensor_dump(cmd):\n     '''\n     sensor_dump = ''\n     try:\n-        sensor_dump = subprocess.check_output(cmd, shell=True)\n+        sensor_dump = subprocess.check_output(cmd)\n     except subprocess.CalledProcessError as e:\n         logging.error('Error! Failed to execute: {}'.format(cmd))\n         sys.exit(1)\n", "message": "", "files": {"/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n RESET_REGISTER = \"0x112\"\n HOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/previous-reboot-cause.txt\"\n PMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/previous-reboot-cause.txt\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n STATUS_LED_PATH = \"/sys/devices/platform/e1031.smc/master_led\"\n \n ", "add": 0, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": []}], "source": "\n try: from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper from sonic_platform_base.chassis_base import ChassisBase from sonic_py_common import device_info from.common import Common from.event import SfpEvent except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=3 NUM_PSU=2 NUM_THERMAL=7 NUM_SFP=55 NUM_COMPONENT=3 RESET_REGISTER=\"0x112\" HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/previous-reboot-cause.txt\" PMON_REBOOT_CAUSE_PATH=\"/usr/share/sonic/platform/api_files/reboot-cause/previous-reboot-cause.txt\" HOST_CHK_CMD=\"docker > /dev/null 2>&1\" STATUS_LED_PATH=\"/sys/devices/platform/e1031.smc/master_led\" class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_common=Common() self._is_host=self._api_common.is_host() self.__initialize_eeprom() self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() self.sfp_module_initialized=False self._reboot_cause_path=HOST_REBOOT_CAUSE_PATH if self._is_host else PMON_REBOOT_CAUSE_PATH def __initialize_sfp(self): sfputil_helper=SfpUtilHelper() port_config_file_path=device_info.get_path_to_port_config_file() sfputil_helper.read_porttab_mappings(port_config_file_path, 0) from.sfp import Sfp for index in range(0, NUM_SFP): sfp=Sfp(index, sfputil_helper.logical[index]) self._sfp_list.append(sfp) self.sfp_module_initialized=True def __initialize_psu(self): from.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_fan(self): from.fan_drawer import FanDrawer for i in range(NUM_FAN_TRAY): fandrawer=FanDrawer(i) self._fan_drawer_list.append(fandrawer) self._fan_list +=fandrawer.get_all_fans() def __initialize_thermals(self): from.thermal import Thermal airflow=self.__get_air_flow() for index in range(0, NUM_THERMAL): thermal=Thermal(index, airflow) self._thermal_list.append(thermal) def __initialize_eeprom(self): from.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __get_air_flow(self): air_flow_path='/usr/share/sonic/device/{}/fan_airflow'.format( self._api_common.get_platform()) if self._is_host else '/usr/share/sonic/platform/fan_airflow' air_flow=self._api_common.read_txt_file(air_flow_path) return air_flow or 'B2F' def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_serial_number(self): \"\"\" Retrieves the hardware serial number for the chassis Returns: A string containing the hardware serial number for this chassis. \"\"\" return self._eeprom.get_serial() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. \"\"\" description='None' reboot_cause=self.REBOOT_CAUSE_HARDWARE_OTHER hw_reboot_cause=self._component_list[0].get_register_value( RESET_REGISTER) sw_reboot_cause=self._api_common.read_txt_file( self._reboot_cause_path) or \"Unknown\" if hw_reboot_cause==\"0x55\": reboot_cause=self.REBOOT_CAUSE_NON_HARDWARE description=sw_reboot_cause elif hw_reboot_cause==\"0x11\": reboot_cause=self.REBOOT_CAUSE_POWER_LOSS elif hw_reboot_cause==\"0x33\": reboot_cause=self.REBOOT_CAUSE_WATCHDOG elif hw_reboot_cause==\"0x88\": reboot_cause=self.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU elif hw_reboot_cause==\"0x99\": reboot_cause=self.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC else: reboot_cause=self.REBOOT_CAUSE_NON_HARDWARE description='Unknown reason' return(reboot_cause, description) def get_watchdog(self): \"\"\" Retreives hardware watchdog device on this chassis Returns: An object derived from WatchdogBase representing the hardware watchdog device \"\"\" if self._watchdog is None: from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() return self._watchdog def get_change_event(self, timeout=0): \"\"\" Returns a nested dictionary containing all devices which have experienced a change at chassis level Args: timeout: Timeout in milliseconds(optional). If timeout==0, this method will block until a change is detected. Returns: (bool, dict): -True if call successful, False if not; -A nested dictionary where key is a device type, value is a dictionary with key:value pairs in the format of {'device_id':'device_event'}, where device_id is the device ID for this device and device_event, status='1' represents device inserted, status='0' represents device removed. Ex.{'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}} indicates that fan 0 has been removed, fan 2 has been inserted and sfp 11 has been removed. \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() sfp_event=SfpEvent(self._sfp_list).get_sfp_event(timeout) if sfp_event: return True,{'sfp': sfp_event} return False,{'sfp':{}} def get_num_sfps(self): \"\"\" Retrieves the number of sfps available on this chassis Returns: An integer, the number of sfps available on this chassis \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() return len(self._sfp_list) def get_all_sfps(self): \"\"\" Retrieves all sfps available on this chassis Returns: A list of objects derived from SfpBase representing all sfps available on this chassis \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfp_list def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() return super(Chassis, self).get_sfp(index -1) def get_thermal_manager(self): from.thermal_manager import ThermalManager return ThermalManager def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._api_common.get_hwsku() def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return self.get_serial_number() def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def set_status_led(self, color): \"\"\" Sets the state of the PSU status LED Args: color: A string representing the color with which to set the PSU status LED Note: Only support green and off Returns: bool: True if status LED state is set successfully, False if not \"\"\" status_str={ self.STATUS_LED_COLOR_GREEN: 'green', self.STATUS_LED_COLOR_AMBER: 'amber', self.STATUS_LED_COLOR_OFF: 'off' }.get(color, 'off') return self._api_common.write_txt_file(STATUS_LED_PATH, status_str) def get_status_led(self): \"\"\" Gets the state of the PSU status LED Returns: A string, one of the predefined STATUS_LED_COLOR_* strings above \"\"\" status=self._api_common.read_txt_file(STATUS_LED_PATH) status_str={ 'on': self.STATUS_LED_COLOR_GREEN, 'amber': self.STATUS_LED_COLOR_AMBER, 'off': self.STATUS_LED_COLOR_OFF }.get(status, None) return status_str ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\n\ntry:\n    from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper\n    from sonic_platform_base.chassis_base import ChassisBase\n    from sonic_py_common import device_info\n    from .common import Common\n    from .event import SfpEvent\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 3\nNUM_PSU = 2\nNUM_THERMAL = 7\nNUM_SFP = 55\nNUM_COMPONENT = 3\nRESET_REGISTER = \"0x112\"\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/previous-reboot-cause.txt\"\nPMON_REBOOT_CAUSE_PATH = \"/usr/share/sonic/platform/api_files/reboot-cause/previous-reboot-cause.txt\"\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nSTATUS_LED_PATH = \"/sys/devices/platform/e1031.smc/master_led\"\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n\n        self._api_common = Common()\n        self._is_host = self._api_common.is_host()\n\n        self.__initialize_eeprom()\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n\n        self.sfp_module_initialized = False\n        self._reboot_cause_path = HOST_REBOOT_CAUSE_PATH if self._is_host else PMON_REBOOT_CAUSE_PATH\n\n    def __initialize_sfp(self):\n        sfputil_helper = SfpUtilHelper()\n        port_config_file_path = device_info.get_path_to_port_config_file()\n        sfputil_helper.read_porttab_mappings(port_config_file_path, 0)\n\n        from .sfp import Sfp\n        for index in range(0, NUM_SFP):\n            sfp = Sfp(index, sfputil_helper.logical[index])\n            self._sfp_list.append(sfp)\n        self.sfp_module_initialized = True\n\n    def __initialize_psu(self):\n        from .psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_fan(self):\n        from .fan_drawer import FanDrawer\n        for i in range(NUM_FAN_TRAY):\n            fandrawer = FanDrawer(i)\n            self._fan_drawer_list.append(fandrawer)\n            self._fan_list += fandrawer.get_all_fans()\n\n    def __initialize_thermals(self):\n        from .thermal import Thermal\n        airflow = self.__get_air_flow()\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index, airflow)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from .eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from .component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __get_air_flow(self):\n        air_flow_path = '/usr/share/sonic/device/{}/fan_airflow'.format(\n            self._api_common.get_platform()) if self._is_host else '/usr/share/sonic/platform/fan_airflow'\n        air_flow = self._api_common.read_txt_file(air_flow_path)\n        return air_flow or 'B2F'\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_serial_number(self):\n        \"\"\"\n        Retrieves the hardware serial number for the chassis\n        Returns:\n            A string containing the hardware serial number for this chassis.\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n        \"\"\"\n        description = 'None'\n        reboot_cause = self.REBOOT_CAUSE_HARDWARE_OTHER\n        hw_reboot_cause = self._component_list[0].get_register_value(\n            RESET_REGISTER)\n        sw_reboot_cause = self._api_common.read_txt_file(\n            self._reboot_cause_path) or \"Unknown\"\n\n        if hw_reboot_cause == \"0x55\":\n            reboot_cause = self.REBOOT_CAUSE_NON_HARDWARE\n            description = sw_reboot_cause\n        elif hw_reboot_cause == \"0x11\":\n            reboot_cause = self.REBOOT_CAUSE_POWER_LOSS\n        elif hw_reboot_cause == \"0x33\":\n            reboot_cause = self.REBOOT_CAUSE_WATCHDOG\n        elif hw_reboot_cause == \"0x88\":\n            reboot_cause = self.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU\n        elif hw_reboot_cause == \"0x99\":\n            reboot_cause = self.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC\n        else:\n            reboot_cause = self.REBOOT_CAUSE_NON_HARDWARE\n            description = 'Unknown reason'\n        return (reboot_cause, description)\n\n    def get_watchdog(self):\n        \"\"\"\n        Retreives hardware watchdog device on this chassis\n        Returns:\n            An object derived from WatchdogBase representing the hardware\n            watchdog device\n        \"\"\"\n        if self._watchdog is None:\n            from sonic_platform.watchdog import Watchdog\n            self._watchdog = Watchdog()\n\n        return self._watchdog\n\n    def get_change_event(self, timeout=0):\n        \"\"\"\n        Returns a nested dictionary containing all devices which have\n        experienced a change at chassis level\n        Args:\n            timeout: Timeout in milliseconds (optional). If timeout == 0,\n                this method will block until a change is detected.\n        Returns:\n            (bool, dict):\n                - True if call successful, False if not;\n                - A nested dictionary where key is a device type,\n                  value is a dictionary with key:value pairs in the format of\n                  {'device_id':'device_event'},\n                  where device_id is the device ID for this device and\n                        device_event,\n                             status='1' represents device inserted,\n                             status='0' represents device removed.\n                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}\n                      indicates that fan 0 has been removed, fan 2\n                      has been inserted and sfp 11 has been removed.\n        \"\"\"\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        sfp_event = SfpEvent(self._sfp_list).get_sfp_event(timeout)\n        if sfp_event:\n            return True, {'sfp': sfp_event}\n\n        return False, {'sfp': {}}\n\n    ##############################################################\n    ######################## SFP methods #########################\n    ##############################################################\n\n    def get_num_sfps(self):\n        \"\"\"\n        Retrieves the number of sfps available on this chassis\n        Returns:\n            An integer, the number of sfps available on this chassis\n        \"\"\"\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return len(self._sfp_list)\n\n    def get_all_sfps(self):\n        \"\"\"\n        Retrieves all sfps available on this chassis\n        Returns:\n            A list of objects derived from SfpBase representing all sfps\n            available on this chassis\n        \"\"\"\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return self._sfp_list\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return super(Chassis, self).get_sfp(index - 1)\n\n    ##############################################################\n    ################## ThermalManager methods ####################\n    ##############################################################\n\n    def get_thermal_manager(self):\n        from .thermal_manager import ThermalManager\n        return ThermalManager\n\n    ##############################################################\n    ###################### Device methods ########################\n    ##############################################################\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return self._api_common.get_hwsku()\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return self.get_serial_number()\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the PSU status LED\n        Args:\n            color: A string representing the color with which to set the PSU status LED\n                   Note: Only support green and off\n        Returns:\n            bool: True if status LED state is set successfully, False if not\n        \"\"\"\n\n        status_str = {\n            self.STATUS_LED_COLOR_GREEN: 'green',\n            self.STATUS_LED_COLOR_AMBER: 'amber',\n            self.STATUS_LED_COLOR_OFF: 'off'\n        }.get(color, 'off')\n\n        return self._api_common.write_txt_file(STATUS_LED_PATH, status_str)\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the PSU status LED\n        Returns:\n            A string, one of the predefined STATUS_LED_COLOR_* strings above\n        \"\"\"\n        status = self._api_common.read_txt_file(STATUS_LED_PATH)\n        status_str = {\n            'on': self.STATUS_LED_COLOR_GREEN,\n            'amber': self.STATUS_LED_COLOR_AMBER,\n            'off': self.STATUS_LED_COLOR_OFF\n        }.get(status, None)\n\n        return status_str\n"}, "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py": {"changes": [{"diff": "\n import os\r\n+import ast\r\n import imp\r\n import yaml\r\n import subprocess\r\n-\r\n from sonic_py_common import device_info\r\n \r\n \r\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["\r"], "goodparts": ["import ast\r"]}, {"diff": "\n \r\n     SET_METHOD_IPMI = 'ipmitool'\r\n     NULL_VAL = 'N/A'\r\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\r\n+    HOST_CHK_CMD = [\"docker\"]\r\n     REF_KEY = '$ref:'\r\n \r\n     def __init__(self, conf=None):\r\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\r"], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]\r"]}, {"diff": "\n         status = False\r\n         output = \"\"\r\n         try:\r\n-            p = subprocess.Popen(\r\n-                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n+            p = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n             raw_data, err = p.communicate()\r\n             if p.returncode == 0:\r\n                 status, output = True, raw_data.strip()\r\n", "add": 1, "remove": 2, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["            p = subprocess.Popen(\r", "                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r"], "goodparts": ["            p = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r"]}, {"diff": "\n             cleaned_input = input_translator.get(input)\r\n \r\n         elif type(input_translator) is str:\r\n-            cleaned_input = eval(input_translator.format(input))\r\n+            cleaned_input = ast.literal_eval(input_translator.format(input))\r\n \r\n         return cleaned_input\r\n \r\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["            cleaned_input = eval(input_translator.format(input))\r"], "goodparts": ["            cleaned_input = ast.literal_eval(input_translator.format(input))\r"]}, {"diff": "\n         if type(output_translator) is dict:\r\n             output = output_translator.get(output)\r\n         elif type(output_translator) is str:\r\n-            output = eval(output_translator.format(output))\r\n+            output = ast.literal_eval(output_translator.format(output))\r\n         elif type(output_translator) is list:\r\n-            output = eval(output_translator[index].format(output))\r\n+            output = ast.literal_eval(output_translator[index].format(output))\r\n \r\n         return output\r\n \r\n-    def _ipmi_get(self, index, config):\r\n-        argument = config.get('argument')\r\n-        cmd = config['command'].format(\r\n-            config['argument'][index]) if argument else config['command']\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n-\r\n     def _sysfs_read(self, index, config):\r\n         sysfs_path = config.get('sysfs_path')\r\n         argument = config.get('argument', '')\r\n", "add": 2, "remove": 9, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["            output = eval(output_translator.format(output))\r", "            output = eval(output_translator[index].format(output))\r", "    def _ipmi_get(self, index, config):\r", "        argument = config.get('argument')\r", "        cmd = config['command'].format(\r", "            config['argument'][index]) if argument else config['command']\r", "        status, output = self.run_command(cmd)\r", "        return output if status else None\r", "\r"], "goodparts": ["            output = ast.literal_eval(output_translator.format(output))\r", "            output = ast.literal_eval(output_translator[index].format(output))\r"]}, {"diff": "\n             return False, output\r\n         return True, output\r\n \r\n-    def _ipmi_set(self, index, config, input):\r\n-        arg = config['argument'][index].format(input)\r\n-        return self.run_command(config['command'].format(arg))\r\n-\r\n     def _hex_ver_decode(self, hver, num_of_bits, num_of_points):\r\n         ver_list = []\r\n         c_bit = 0\r\n", "add": 0, "remove": 4, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["    def _ipmi_set(self, index, config, input):\r", "        arg = config['argument'][index].format(input)\r", "        return self.run_command(config['command'].format(arg))\r", "\r"], "goodparts": []}, {"diff": "\n         return class_\r\n \r\n     def get_reg(self, path, reg_addr):\r\n-        cmd = \"echo {1} > {0}; cat {0}\".format(path, reg_addr)\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n+        with open(path, 'w') as file:\r\n+            file.write(reg_addr + '\\n')\r\n+        with open(path, 'r') as file:\r\n+            output = file.readline().strip()\r\n+        return output\r\n \r\n     def set_reg(self, path, reg_addr, value):\r\n-        cmd = \"echo {0} {1} > {2}\".format(reg_addr, value, path)\r\n-        status, output = self.run_command(cmd)\r\n-        return output if status else None\r\n+        with open(path, 'w') as file:\r\n+            file.write(\"{0} {1}\\n\".format(reg_addr, value))\r\n+        return None\r\n \r\n     def read_txt_file(self, path):\r\n         try:\r\n", "add": 8, "remove": 6, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["        cmd = \"echo {1} > {0}; cat {0}\".format(path, reg_addr)\r", "        status, output = self.run_command(cmd)\r", "        return output if status else None\r", "        cmd = \"echo {0} {1} > {2}\".format(reg_addr, value, path)\r", "        status, output = self.run_command(cmd)\r", "        return output if status else None\r"], "goodparts": ["        with open(path, 'w') as file:\r", "            file.write(reg_addr + '\\n')\r", "        with open(path, 'r') as file:\r", "            output = file.readline().strip()\r", "        return output\r", "        with open(path, 'w') as file:\r", "            file.write(\"{0} {1}\\n\".format(reg_addr, value))\r", "        return None\r"]}, {"diff": "\n         return True\r\n \r\n     def is_host(self):\r\n-        return os.system(self.HOST_CHK_CMD) == 0\r\n+        try:\r\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\r\n+        except FileNotFoundError:\r\n+            return False\r\n+        return True\r\n \r\n     def load_json_file(self, path):\r\n         \"\"\"\r\n", "add": 5, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0\r"], "goodparts": ["        try:\r", "            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\r", "        except FileNotFoundError:\r", "            return False\r", "        return True\r"]}, {"diff": "\n         \"\"\"\r\n         return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\r\n \r\n-    def get_output(self, index, config, default):\r\n-        \"\"\"\r\n-        Retrieves the output for each function base on config\r\n-\r\n-        Args:\r\n-            index: An integer containing the index of device.\r\n-            config: A dict object containing the configuration of specified function.\r\n-            default: A string containing the default output of specified function.\r\n-\r\n-        Returns:\r\n-            A string containing the output of specified function in config\r\n-        \"\"\"\r\n-        output_source = config.get('output_source')\r\n-\r\n-        if output_source == self.OUTPUT_SOURCE_IPMI:\r\n-            output = self._ipmi_get(index, config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VALUE:\r\n-            output = config[\"value\"]\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_CLASS:\r\n-            output = self._get_class(config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_LIST:\r\n-            output = config[\"value_list\"][index]\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_SYSFS:\r\n-            output = self._sysfs_read(index, config)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_FUNC:\r\n-            func_conf = self._main_conf[config['function'][index]]\r\n-            output = self.get_output(index, func_conf, default)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\r\n-            path = config.get('path')\r\n-            output = self.read_txt_file(path)\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\r\n-            path = config.get('path')\r\n-            hex_ver = self.read_txt_file(path)\r\n-            output = self._hex_ver_decode(\r\n-                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n-\r\n-        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\r\n-            path = config.get('path')\r\n-            addr = config.get('reg_addr')\r\n-            hex_ver = self.get_reg(path, addr)\r\n-            output = self._hex_ver_decode(\r\n-                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n-\r\n-        else:\r\n-            output = default\r\n-\r\n-        return self._clean_output(index, output, config) or default\r\n-\r\n-    def set_output(self, index, input, config):\r\n-        \"\"\"\r\n-        Sets the output of specified function on config\r\n-\r\n-        Args:\r\n-            config: A dict object containing the configuration of specified function.\r\n-            index: An integer containing the index of device.\r\n-            input: A string containing the input of specified function.\r\n-\r\n-        Returns:\r\n-            bool: True if set function is successfully, False if not\r\n-        \"\"\"\r\n-        cleaned_input = self._clean_input(input, config)\r\n-        if not cleaned_input:\r\n-            return False\r\n-\r\n-        set_method = config.get('set_method')\r\n-        if set_method == self.SET_METHOD_IPMI:\r\n-            output = self._ipmi_set(index, config, cleaned_input)[0]\r\n-        elif set_method == self.OUTPUT_SOURCE_SYSFS:\r\n-            output = self._sysfs_write(index, config, cleaned_input)[0]\r\n-        else:\r\n-            output = False\r\n-\r\n-        return output\r\n-\r\n     def get_event(self, timeout, config, sfp_list):\r\n         \"\"\"\r\n         Returns a nested dictionary containing all devices which have", "add": 0, "remove": 81, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/common.py", "badparts": ["    def get_output(self, index, config, default):\r", "        \"\"\"\r", "        Retrieves the output for each function base on config\r", "\r", "        Args:\r", "            index: An integer containing the index of device.\r", "            config: A dict object containing the configuration of specified function.\r", "            default: A string containing the default output of specified function.\r", "\r", "        Returns:\r", "            A string containing the output of specified function in config\r", "        \"\"\"\r", "        output_source = config.get('output_source')\r", "\r", "        if output_source == self.OUTPUT_SOURCE_IPMI:\r", "            output = self._ipmi_get(index, config)\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_VALUE:\r", "            output = config[\"value\"]\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_CLASS:\r", "            output = self._get_class(config)\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_LIST:\r", "            output = config[\"value_list\"][index]\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_SYSFS:\r", "            output = self._sysfs_read(index, config)\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_FUNC:\r", "            func_conf = self._main_conf[config['function'][index]]\r", "            output = self.get_output(index, func_conf, default)\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\r", "            path = config.get('path')\r", "            output = self.read_txt_file(path)\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\r", "            path = config.get('path')\r", "            hex_ver = self.read_txt_file(path)\r", "            output = self._hex_ver_decode(\r", "                hex_ver, config['num_of_bits'], config['num_of_points'])\r", "\r", "        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\r", "            path = config.get('path')\r", "            addr = config.get('reg_addr')\r", "            hex_ver = self.get_reg(path, addr)\r", "            output = self._hex_ver_decode(\r", "                hex_ver, config['num_of_bits'], config['num_of_points'])\r", "\r", "        else:\r", "            output = default\r", "\r", "        return self._clean_output(index, output, config) or default\r", "\r", "    def set_output(self, index, input, config):\r", "        \"\"\"\r", "        Sets the output of specified function on config\r", "\r", "        Args:\r", "            config: A dict object containing the configuration of specified function.\r", "            index: An integer containing the index of device.\r", "            input: A string containing the input of specified function.\r", "\r", "        Returns:\r", "            bool: True if set function is successfully, False if not\r", "        \"\"\"\r", "        cleaned_input = self._clean_input(input, config)\r", "        if not cleaned_input:\r", "            return False\r", "\r", "        set_method = config.get('set_method')\r", "        if set_method == self.SET_METHOD_IPMI:\r", "            output = self._ipmi_set(index, config, cleaned_input)[0]\r", "        elif set_method == self.OUTPUT_SOURCE_SYSFS:\r", "            output = self._sysfs_write(index, config, cleaned_input)[0]\r", "        else:\r", "            output = False\r", "\r", "        return output\r", "\r"], "goodparts": []}], "source": "\nimport os\r import imp\r import yaml\r import subprocess\r \r from sonic_py_common import device_info\r \r \r class Common:\r \r DEVICE_PATH='/usr/share/sonic/device/'\r PMON_PLATFORM_PATH='/usr/share/sonic/platform/'\r CONFIG_DIR='sonic_platform_config'\r \r OUTPUT_SOURCE_IPMI='ipmitool'\r OUTPUT_SOURCE_GIVEN_LIST='value_list'\r OUTPUT_SOURCE_GIVEN_VALUE='value'\r OUTPUT_SOURCE_GIVEN_CLASS='class'\r OUTPUT_SOURCE_SYSFS='sysfs_value'\r OUTPUT_SOURCE_FUNC='function'\r OUTPUT_SOURCE_GIVEN_TXT_FILE='txt_file'\r OUTPUT_SOURCE_GIVEN_VER_HEX_FILE='hex_version_file'\r OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR='hex_version_getreg'\r \r SET_METHOD_IPMI='ipmitool'\r NULL_VAL='N/A'\r HOST_CHK_CMD=\"docker > /dev/null 2>&1\"\r REF_KEY='$ref:'\r \r def __init__(self, conf=None):\r self._main_conf=conf\r self.platform=None\r self.hwsku=None\r \r def get_platform(self):\r (self.platform, self.hwsku)=device_info.get_platform_and_hwsku(\r ) if not self.platform else(self.platform, self.hwsku)\r return self.platform\r \r def get_hwsku(self):\r (self.platform, self.hwsku)=device_info.get_platform_and_hwsku(\r ) if not self.hwsku else(self.platform, self.hwsku)\r return self.hwsku\r \r def run_command(self, command):\r status=False\r output=\"\"\r try:\r p=subprocess.Popen(\r command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r raw_data, err=p.communicate()\r if p.returncode==0:\r status, output=True, raw_data.strip()\r except Exception:\r pass\r return status, output\r \r def _clean_input(self, input, config):\r cleaned_input=input\r \r ai=config.get('avaliable_input')\r if ai and input not in ai:\r return None\r \r input_translator=config.get('input_translator')\r if type(input_translator) is dict:\r cleaned_input=input_translator.get(input)\r \r elif type(input_translator) is str:\r cleaned_input=eval(input_translator.format(input))\r \r return cleaned_input\r \r def _clean_output(self, index, output, config):\r output_translator=config.get('output_translator')\r \r if type(output_translator) is dict:\r output=output_translator.get(output)\r elif type(output_translator) is str:\r output=eval(output_translator.format(output))\r elif type(output_translator) is list:\r output=eval(output_translator[index].format(output))\r \r return output\r \r def _ipmi_get(self, index, config):\r argument=config.get('argument')\r cmd=config['command'].format(\r config['argument'][index]) if argument else config['command']\r status, output=self.run_command(cmd)\r return output if status else None\r \r def _sysfs_read(self, index, config):\r sysfs_path=config.get('sysfs_path')\r argument=config.get('argument', '')\r \r if self.REF_KEY in argument:\r argument=self._main_conf[argument.split(\":\")[1]]\r \r if type(argument) is list:\r sysfs_path=sysfs_path.format(argument[index])\r \r content=\"\"\r try:\r content=open(sysfs_path)\r content=content.readline().rstrip()\r except IOError as e:\r print(\"Error: unable to open file: %s\" % str(e))\r return False\r \r return content\r \r def _sysfs_write(self, index, config, input):\r sysfs_path=config.get('sysfs_path')\r argument=config.get('argument', '')\r \r if self.REF_KEY in argument:\r argument=self._main_conf[argument.split(\":\")[1]]\r \r if type(argument) is list:\r sysfs_path=sysfs_path.format(argument[index])\r \r write_offset=int(config.get('write_offset', 0))\r output=\"\"\r try:\r open_file=open(sysfs_path, \"r+\")\r open_file.seek(write_offset)\r open_file.write(input)\r open_file.close()\r except IOError as e:\r print(\"Error: unable to open file: %s\" % str(e))\r return False, output\r return True, output\r \r def _ipmi_set(self, index, config, input):\r arg=config['argument'][index].format(input)\r return self.run_command(config['command'].format(arg))\r \r def _hex_ver_decode(self, hver, num_of_bits, num_of_points):\r ver_list=[]\r c_bit=0\r bin_val=bin(int(hver, 16))[2:].zfill(num_of_bits)\r bit_split=num_of_bits /(num_of_points +1)\r for x in range(0, num_of_points+1):\r split_bin=bin_val[c_bit:c_bit+bit_split]\r ver_list.append(str(int(split_bin, 2)))\r c_bit +=bit_split\r return '.'.join(ver_list)\r \r def _get_class(self, config):\r \"\"\"\r Retreives value of expected attribute\r Returns:\r A value of the attribute of object\r \"\"\"\r path=config['host_path'] if self.is_host() else config['pmon_path']\r module=imp.load_source(config['class'], path)\r class_=getattr(module, config['class'])\r return class_\r \r def get_reg(self, path, reg_addr):\r cmd=\"echo{1} >{0}; cat{0}\".format(path, reg_addr)\r status, output=self.run_command(cmd)\r return output if status else None\r \r def set_reg(self, path, reg_addr, value):\r cmd=\"echo{0}{1} >{2}\".format(reg_addr, value, path)\r status, output=self.run_command(cmd)\r return output if status else None\r \r def read_txt_file(self, path):\r try:\r with open(path, 'r') as f:\r output=f.readline()\r return output.strip('\\n')\r except Exception:\r pass\r return ''\r \r def read_one_line_file(self, file_path):\r try:\r with open(file_path, 'r') as fd:\r data=fd.readline()\r return data.strip()\r except IOError:\r pass\r return ''\r \r def write_txt_file(self, file_path, value):\r try:\r with open(file_path, 'w') as fd:\r fd.write(str(value))\r except Exception:\r return False\r return True\r \r def is_host(self):\r return os.system(self.HOST_CHK_CMD)==0\r \r def load_json_file(self, path):\r \"\"\"\r Retrieves the json object from json file path\r \r Returns:\r A json object\r \"\"\"\r with open(path, 'r') as f:\r json_data=yaml.safe_load(f)\r \r return json_data\r \r def get_config_path(self, config_name):\r \"\"\"\r Retrieves the path to platform api config directory\r \r Args:\r config_name: A string containing the name of config file.\r \r Returns:\r A string containing the path to json file\r \"\"\"\r return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\r \r def get_output(self, index, config, default):\r \"\"\"\r Retrieves the output for each function base on config\r \r Args:\r index: An integer containing the index of device.\r config: A dict object containing the configuration of specified function.\r default: A string containing the default output of specified function.\r \r Returns:\r A string containing the output of specified function in config\r \"\"\"\r output_source=config.get('output_source')\r \r if output_source==self.OUTPUT_SOURCE_IPMI:\r output=self._ipmi_get(index, config)\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_VALUE:\r output=config[\"value\"]\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_CLASS:\r output=self._get_class(config)\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_LIST:\r output=config[\"value_list\"][index]\r \r elif output_source==self.OUTPUT_SOURCE_SYSFS:\r output=self._sysfs_read(index, config)\r \r elif output_source==self.OUTPUT_SOURCE_FUNC:\r func_conf=self._main_conf[config['function'][index]]\r output=self.get_output(index, func_conf, default)\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\r path=config.get('path')\r output=self.read_txt_file(path)\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\r path=config.get('path')\r hex_ver=self.read_txt_file(path)\r output=self._hex_ver_decode(\r hex_ver, config['num_of_bits'], config['num_of_points'])\r \r elif output_source==self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\r path=config.get('path')\r addr=config.get('reg_addr')\r hex_ver=self.get_reg(path, addr)\r output=self._hex_ver_decode(\r hex_ver, config['num_of_bits'], config['num_of_points'])\r \r else:\r output=default\r \r return self._clean_output(index, output, config) or default\r \r def set_output(self, index, input, config):\r \"\"\"\r Sets the output of specified function on config\r \r Args:\r config: A dict object containing the configuration of specified function.\r index: An integer containing the index of device.\r input: A string containing the input of specified function.\r \r Returns:\r bool: True if set function is successfully, False if not\r \"\"\"\r cleaned_input=self._clean_input(input, config)\r if not cleaned_input:\r return False\r \r set_method=config.get('set_method')\r if set_method==self.SET_METHOD_IPMI:\r output=self._ipmi_set(index, config, cleaned_input)[0]\r elif set_method==self.OUTPUT_SOURCE_SYSFS:\r output=self._sysfs_write(index, config, cleaned_input)[0]\r else:\r output=False\r \r return output\r \r def get_event(self, timeout, config, sfp_list):\r \"\"\"\r Returns a nested dictionary containing all devices which have\r experienced a change at chassis level\r \r \"\"\"\r event_class=self._get_class(config)\r return event_class(sfp_list).get_event(timeout)\r ", "sourceWithComments": "import os\r\nimport imp\r\nimport yaml\r\nimport subprocess\r\n\r\nfrom sonic_py_common import device_info\r\n\r\n\r\nclass Common:\r\n\r\n    DEVICE_PATH = '/usr/share/sonic/device/'\r\n    PMON_PLATFORM_PATH = '/usr/share/sonic/platform/'\r\n    CONFIG_DIR = 'sonic_platform_config'\r\n\r\n    OUTPUT_SOURCE_IPMI = 'ipmitool'\r\n    OUTPUT_SOURCE_GIVEN_LIST = 'value_list'\r\n    OUTPUT_SOURCE_GIVEN_VALUE = 'value'\r\n    OUTPUT_SOURCE_GIVEN_CLASS = 'class'\r\n    OUTPUT_SOURCE_SYSFS = 'sysfs_value'\r\n    OUTPUT_SOURCE_FUNC = 'function'\r\n    OUTPUT_SOURCE_GIVEN_TXT_FILE = 'txt_file'\r\n    OUTPUT_SOURCE_GIVEN_VER_HEX_FILE = 'hex_version_file'\r\n    OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR = 'hex_version_getreg'\r\n\r\n    SET_METHOD_IPMI = 'ipmitool'\r\n    NULL_VAL = 'N/A'\r\n    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\r\n    REF_KEY = '$ref:'\r\n\r\n    def __init__(self, conf=None):\r\n        self._main_conf = conf\r\n        self.platform = None\r\n        self.hwsku = None\r\n\r\n    def get_platform(self):\r\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku(\r\n        ) if not self.platform else (self.platform, self.hwsku)\r\n        return self.platform\r\n\r\n    def get_hwsku(self):\r\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku(\r\n        ) if not self.hwsku else (self.platform, self.hwsku)\r\n        return self.hwsku\r\n\r\n    def run_command(self, command):\r\n        status = False\r\n        output = \"\"\r\n        try:\r\n            p = subprocess.Popen(\r\n                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n            raw_data, err = p.communicate()\r\n            if p.returncode == 0:\r\n                status, output = True, raw_data.strip()\r\n        except Exception:\r\n            pass\r\n        return status, output\r\n\r\n    def _clean_input(self, input, config):\r\n        cleaned_input = input\r\n\r\n        ai = config.get('avaliable_input')\r\n        if ai and input not in ai:\r\n            return None\r\n\r\n        input_translator = config.get('input_translator')\r\n        if type(input_translator) is dict:\r\n            cleaned_input = input_translator.get(input)\r\n\r\n        elif type(input_translator) is str:\r\n            cleaned_input = eval(input_translator.format(input))\r\n\r\n        return cleaned_input\r\n\r\n    def _clean_output(self, index, output, config):\r\n        output_translator = config.get('output_translator')\r\n\r\n        if type(output_translator) is dict:\r\n            output = output_translator.get(output)\r\n        elif type(output_translator) is str:\r\n            output = eval(output_translator.format(output))\r\n        elif type(output_translator) is list:\r\n            output = eval(output_translator[index].format(output))\r\n\r\n        return output\r\n\r\n    def _ipmi_get(self, index, config):\r\n        argument = config.get('argument')\r\n        cmd = config['command'].format(\r\n            config['argument'][index]) if argument else config['command']\r\n        status, output = self.run_command(cmd)\r\n        return output if status else None\r\n\r\n    def _sysfs_read(self, index, config):\r\n        sysfs_path = config.get('sysfs_path')\r\n        argument = config.get('argument', '')\r\n\r\n        if self.REF_KEY in argument:\r\n            argument = self._main_conf[argument.split(\":\")[1]]\r\n\r\n        if type(argument) is list:\r\n            sysfs_path = sysfs_path.format(argument[index])\r\n\r\n        content = \"\"\r\n        try:\r\n            content = open(sysfs_path)\r\n            content = content.readline().rstrip()\r\n        except IOError as e:\r\n            print(\"Error: unable to open file: %s\" % str(e))\r\n            return False\r\n\r\n        return content\r\n\r\n    def _sysfs_write(self, index, config, input):\r\n        sysfs_path = config.get('sysfs_path')\r\n        argument = config.get('argument', '')\r\n\r\n        if self.REF_KEY in argument:\r\n            argument = self._main_conf[argument.split(\":\")[1]]\r\n\r\n        if type(argument) is list:\r\n            sysfs_path = sysfs_path.format(argument[index])\r\n\r\n        write_offset = int(config.get('write_offset', 0))\r\n        output = \"\"\r\n        try:\r\n            open_file = open(sysfs_path, \"r+\")\r\n            open_file.seek(write_offset)\r\n            open_file.write(input)\r\n            open_file.close()\r\n        except IOError as e:\r\n            print(\"Error: unable to open file: %s\" % str(e))\r\n            return False, output\r\n        return True, output\r\n\r\n    def _ipmi_set(self, index, config, input):\r\n        arg = config['argument'][index].format(input)\r\n        return self.run_command(config['command'].format(arg))\r\n\r\n    def _hex_ver_decode(self, hver, num_of_bits, num_of_points):\r\n        ver_list = []\r\n        c_bit = 0\r\n        bin_val = bin(int(hver, 16))[2:].zfill(num_of_bits)\r\n        bit_split = num_of_bits / (num_of_points + 1)\r\n        for x in range(0, num_of_points+1):\r\n            split_bin = bin_val[c_bit:c_bit+bit_split]\r\n            ver_list.append(str(int(split_bin, 2)))\r\n            c_bit += bit_split\r\n        return '.'.join(ver_list)\r\n\r\n    def _get_class(self, config):\r\n        \"\"\"\r\n        Retreives value of expected attribute\r\n        Returns:\r\n            A value of the attribute of object\r\n        \"\"\"\r\n        path = config['host_path'] if self.is_host() else config['pmon_path']\r\n        module = imp.load_source(config['class'], path)\r\n        class_ = getattr(module, config['class'])\r\n        return class_\r\n\r\n    def get_reg(self, path, reg_addr):\r\n        cmd = \"echo {1} > {0}; cat {0}\".format(path, reg_addr)\r\n        status, output = self.run_command(cmd)\r\n        return output if status else None\r\n\r\n    def set_reg(self, path, reg_addr, value):\r\n        cmd = \"echo {0} {1} > {2}\".format(reg_addr, value, path)\r\n        status, output = self.run_command(cmd)\r\n        return output if status else None\r\n\r\n    def read_txt_file(self, path):\r\n        try:\r\n            with open(path, 'r') as f:\r\n                output = f.readline()\r\n            return output.strip('\\n')\r\n        except Exception:\r\n            pass\r\n        return ''\r\n\r\n    def read_one_line_file(self, file_path):\r\n        try:\r\n            with open(file_path, 'r') as fd:\r\n                data = fd.readline()\r\n                return data.strip()\r\n        except IOError:\r\n            pass\r\n        return ''\r\n\r\n    def write_txt_file(self, file_path, value):\r\n        try:\r\n            with open(file_path, 'w') as fd:\r\n                fd.write(str(value))\r\n        except Exception:\r\n            return False\r\n        return True\r\n\r\n    def is_host(self):\r\n        return os.system(self.HOST_CHK_CMD) == 0\r\n\r\n    def load_json_file(self, path):\r\n        \"\"\"\r\n        Retrieves the json object from json file path\r\n\r\n        Returns:\r\n            A json object\r\n        \"\"\"\r\n        with open(path, 'r') as f:\r\n            json_data = yaml.safe_load(f)\r\n\r\n        return json_data\r\n\r\n    def get_config_path(self, config_name):\r\n        \"\"\"\r\n        Retrieves the path to platform api config directory\r\n\r\n        Args:\r\n            config_name: A string containing the name of config file.\r\n\r\n        Returns:\r\n            A string containing the path to json file\r\n        \"\"\"\r\n        return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\r\n\r\n    def get_output(self, index, config, default):\r\n        \"\"\"\r\n        Retrieves the output for each function base on config\r\n\r\n        Args:\r\n            index: An integer containing the index of device.\r\n            config: A dict object containing the configuration of specified function.\r\n            default: A string containing the default output of specified function.\r\n\r\n        Returns:\r\n            A string containing the output of specified function in config\r\n        \"\"\"\r\n        output_source = config.get('output_source')\r\n\r\n        if output_source == self.OUTPUT_SOURCE_IPMI:\r\n            output = self._ipmi_get(index, config)\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VALUE:\r\n            output = config[\"value\"]\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_CLASS:\r\n            output = self._get_class(config)\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_LIST:\r\n            output = config[\"value_list\"][index]\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_SYSFS:\r\n            output = self._sysfs_read(index, config)\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_FUNC:\r\n            func_conf = self._main_conf[config['function'][index]]\r\n            output = self.get_output(index, func_conf, default)\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\r\n            path = config.get('path')\r\n            output = self.read_txt_file(path)\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\r\n            path = config.get('path')\r\n            hex_ver = self.read_txt_file(path)\r\n            output = self._hex_ver_decode(\r\n                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n\r\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\r\n            path = config.get('path')\r\n            addr = config.get('reg_addr')\r\n            hex_ver = self.get_reg(path, addr)\r\n            output = self._hex_ver_decode(\r\n                hex_ver, config['num_of_bits'], config['num_of_points'])\r\n\r\n        else:\r\n            output = default\r\n\r\n        return self._clean_output(index, output, config) or default\r\n\r\n    def set_output(self, index, input, config):\r\n        \"\"\"\r\n        Sets the output of specified function on config\r\n\r\n        Args:\r\n            config: A dict object containing the configuration of specified function.\r\n            index: An integer containing the index of device.\r\n            input: A string containing the input of specified function.\r\n\r\n        Returns:\r\n            bool: True if set function is successfully, False if not\r\n        \"\"\"\r\n        cleaned_input = self._clean_input(input, config)\r\n        if not cleaned_input:\r\n            return False\r\n\r\n        set_method = config.get('set_method')\r\n        if set_method == self.SET_METHOD_IPMI:\r\n            output = self._ipmi_set(index, config, cleaned_input)[0]\r\n        elif set_method == self.OUTPUT_SOURCE_SYSFS:\r\n            output = self._sysfs_write(index, config, cleaned_input)[0]\r\n        else:\r\n            output = False\r\n\r\n        return output\r\n\r\n    def get_event(self, timeout, config, sfp_list):\r\n        \"\"\"\r\n        Returns a nested dictionary containing all devices which have\r\n        experienced a change at chassis level\r\n\r\n        \"\"\"\r\n        event_class = self._get_class(config)\r\n        return event_class(sfp_list).get_event(timeout)\r\n"}, "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py": {"changes": [{"diff": "\n try:\n     import os.path\n     import shutil\n-    import shlex\n     import subprocess\n     from sonic_platform_base.component_base import ComponentBase\n except ImportError as e:\n", "add": 0, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py", "badparts": ["    import shlex"], "goodparts": []}, {"diff": "\n     def __run_command(self, command):\n         # Run bash command and print output to stdout\n         try:\n-            process = subprocess.Popen(\n-                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n+            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n             while True:\n                 output = process.stdout.readline()\n                 if output == '' and process.poll() is not None:\n", "add": 1, "remove": 2, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py", "badparts": ["            process = subprocess.Popen(", "                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)"], "goodparts": ["            process = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)"]}, {"diff": "\n \n     def get_register_value(self, register):\n         # Retrieves the cpld register value\n-        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n-        p = subprocess.Popen(\n-            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-        raw_data, err = p.communicate()\n-        if err is not '':\n-            return None\n+        with open(GETREG_PATH, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(GETREG_PATH, 'r') as file:\n+            raw_data = file.readline()\n         return raw_data.strip()\n \n     def __get_cpld_version(self):\n", "add": 4, "remove": 6, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py", "badparts": ["        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)", "        p = subprocess.Popen(", "            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "        raw_data, err = p.communicate()", "        if err is not '':", "            return None"], "goodparts": ["        with open(GETREG_PATH, 'w') as file:", "            file.write(register + '\\n')", "        with open(GETREG_PATH, 'r') as file:", "            raw_data = file.readline()"]}, {"diff": "\n         cpld_version = dict()\n         with open(SMC_CPLD_PATH, 'r') as fd:\n             smc_cpld_version = fd.read()\n-        smc_cpld_version = 'None' if smc_cpld_version is 'None' else \"{}.{}\".format(\n+        smc_cpld_version = 'None' if smc_cpld_version == 'None' else \"{}.{}\".format(\n             int(smc_cpld_version[2], 16), int(smc_cpld_version[3], 16))\n \n         mmc_cpld_version = self.get_register_value(MMC_CPLD_ADDR)\n-        mmc_cpld_version = 'None' if mmc_cpld_version is 'None' else \"{}.{}\".format(\n+        mmc_cpld_version = 'None' if mmc_cpld_version == 'None' else \"{}.{}\".format(\n             int(mmc_cpld_version[2], 16), int(mmc_cpld_version[3], 16))\n \n         cpld_version[\"SMC_CPLD\"] = smc_cpld_version\n", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py", "badparts": ["        smc_cpld_version = 'None' if smc_cpld_version is 'None' else \"{}.{}\".format(", "        mmc_cpld_version = 'None' if mmc_cpld_version is 'None' else \"{}.{}\".format("], "goodparts": ["        smc_cpld_version = 'None' if smc_cpld_version == 'None' else \"{}.{}\".format(", "        mmc_cpld_version = 'None' if mmc_cpld_version == 'None' else \"{}.{}\".format("]}, {"diff": "\n             ext = \".vme\" if ext == \"\" else ext\n             new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n             shutil.copy(image_path, new_image_path)\n-            install_command = \"ispvm %s\" % new_image_path\n+            install_command = [\"ispvm\", str(new_image_path)]\n         # elif self.name == \"BIOS\":\n         #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n         return self.__run_command(install_comman", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/component.py", "badparts": ["            install_command = \"ispvm %s\" % new_image_path"], "goodparts": ["            install_command = [\"ispvm\", str(new_image_path)]"]}], "source": "\n try: import os.path import shutil import shlex import subprocess from sonic_platform_base.component_base import ComponentBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") MMC_CPLD_ADDR='0x100' BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" CONFIG_DB_PATH=\"/etc/sonic/config_db.json\" SMC_CPLD_PATH=\"/sys/devices/platform/e1031.smc/version\" GETREG_PATH=\"/sys/devices/platform/e1031.smc/getreg\" COMPONENT_NAME_LIST=[\"SMC_CPLD\", \"MMC_CPLD\", \"BIOS\"] COMPONENT_DES_LIST=[\"System Management Controller\", \"Module Management CPLD\", \"Basic Input/Output System\"] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index): ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() def __run_command(self, command): try: process=subprocess.Popen( shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE) while True: output=process.stdout.readline() if output=='' and process.poll() is not None: break rc=process.poll() if rc !=0: return False except Exception: return False return True def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def get_register_value(self, register): cmd=\"echo{1} >{0}; cat{0}\".format(GETREG_PATH, register) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err is not '': return None return raw_data.strip() def __get_cpld_version(self): cpld_version=dict() with open(SMC_CPLD_PATH, 'r') as fd: smc_cpld_version=fd.read() smc_cpld_version='None' if smc_cpld_version is 'None' else \"{}.{}\".format( int(smc_cpld_version[2], 16), int(smc_cpld_version[3], 16)) mmc_cpld_version=self.get_register_value(MMC_CPLD_ADDR) mmc_cpld_version='None' if mmc_cpld_version is 'None' else \"{}.{}\".format( int(mmc_cpld_version[2], 16), int(mmc_cpld_version[3], 16)) cpld_version[\"SMC_CPLD\"]=smc_cpld_version cpld_version[\"MMC_CPLD\"]=mmc_cpld_version return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_NAME_LIST[self.index] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_DES_LIST[self.index] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def get_available_firmware_version(self, image_path): \"\"\" Retrieves the available firmware version of the component Note: the firmware version will be read from image Args: image_path: A string, path to firmware image Returns: A string containing the available firmware version of the component \"\"\" return \"N/A\" def get_firmware_update_notification(self, image_path): \"\"\" Retrieves a notification on what should be done in order to complete the component firmware update Args: image_path: A string, path to firmware image Returns: A string containing the component firmware update notification if required. By default 'None' value will be used, which indicates that no actions are required \"\"\" return \"None\" def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" if not os.path.isfile(image_path): return False if \"CPLD\" in self.name: img_name=os.path.basename(image_path) root, ext=os.path.splitext(img_name) ext=\".vme\" if ext==\"\" else ext new_image_path=os.path.join(\"/tmp\",(root.lower() +ext)) shutil.copy(image_path, new_image_path) install_command=\"ispvm %s\" % new_image_path return self.__run_command(install_command) def update_firmware(self, image_path): \"\"\" Updates firmware of the component This API performs firmware update: it assumes firmware installation and loading in a single call. In case platform component requires some extra steps(apart from calling Low Level Utility) to load the installed firmware(e.g, reboot, power cycle, etc.) -this will be done automatically by API Args: image_path: A string, path to firmware image Raises: RuntimeError: update failed \"\"\" return False def get_presence(self): \"\"\" Retrieves the presence of the FAN Returns: bool: True if FAN is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return 'N/A' def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return 'N/A' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is'0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\n\ntry:\n    import os.path\n    import shutil\n    import shlex\n    import subprocess\n    from sonic_platform_base.component_base import ComponentBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nMMC_CPLD_ADDR = '0x100'\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCONFIG_DB_PATH = \"/etc/sonic/config_db.json\"\nSMC_CPLD_PATH = \"/sys/devices/platform/e1031.smc/version\"\nGETREG_PATH = \"/sys/devices/platform/e1031.smc/getreg\"\nCOMPONENT_NAME_LIST = [\"SMC_CPLD\", \"MMC_CPLD\", \"BIOS\"]\nCOMPONENT_DES_LIST = [\"System Management Controller\",\n                      \"Module Management CPLD\", \"Basic Input/Output System\"]\n\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index):\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n\n    def __run_command(self, command):\n        # Run bash command and print output to stdout\n        try:\n            process = subprocess.Popen(\n                shlex.split(command), universal_newlines=True, stdout=subprocess.PIPE)\n            while True:\n                output = process.stdout.readline()\n                if output == '' and process.poll() is not None:\n                    break\n            rc = process.poll()\n            if rc != 0:\n                return False\n        except Exception:\n            return False\n        return True\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def get_register_value(self, register):\n        # Retrieves the cpld register value\n        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n        p = subprocess.Popen(\n            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        raw_data, err = p.communicate()\n        if err is not '':\n            return None\n        return raw_data.strip()\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        with open(SMC_CPLD_PATH, 'r') as fd:\n            smc_cpld_version = fd.read()\n        smc_cpld_version = 'None' if smc_cpld_version is 'None' else \"{}.{}\".format(\n            int(smc_cpld_version[2], 16), int(smc_cpld_version[3], 16))\n\n        mmc_cpld_version = self.get_register_value(MMC_CPLD_ADDR)\n        mmc_cpld_version = 'None' if mmc_cpld_version is 'None' else \"{}.{}\".format(\n            int(mmc_cpld_version[2], 16), int(mmc_cpld_version[3], 16))\n\n        cpld_version[\"SMC_CPLD\"] = smc_cpld_version\n        cpld_version[\"MMC_CPLD\"] = mmc_cpld_version\n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_NAME_LIST[self.index]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_DES_LIST[self.index]\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def get_available_firmware_version(self, image_path):\n        \"\"\"\n        Retrieves the available firmware version of the component\n        Note: the firmware version will be read from image\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A string containing the available firmware version of the component\n        \"\"\"\n        return \"N/A\"\n\n    def get_firmware_update_notification(self, image_path):\n        \"\"\"\n        Retrieves a notification on what should be done in order to complete\n        the component firmware update\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A string containing the component firmware update notification if required.\n            By default 'None' value will be used, which indicates that no actions are required\n        \"\"\"\n        return \"None\"\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        if not os.path.isfile(image_path):\n            return False\n\n        if \"CPLD\" in self.name:\n            img_name = os.path.basename(image_path)\n            root, ext = os.path.splitext(img_name)\n            ext = \".vme\" if ext == \"\" else ext\n            new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n            shutil.copy(image_path, new_image_path)\n            install_command = \"ispvm %s\" % new_image_path\n        # elif self.name == \"BIOS\":\n        #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n        return self.__run_command(install_command)\n\n    def update_firmware(self, image_path):\n        \"\"\"\n        Updates firmware of the component\n        This API performs firmware update: it assumes firmware installation and loading in a single call.\n        In case platform component requires some extra steps (apart from calling Low Level Utility)\n        to load the installed firmware (e.g, reboot, power cycle, etc.) - this will be done automatically by API\n        Args:\n            image_path: A string, path to firmware image\n        Raises:\n            RuntimeError: update failed\n        \"\"\"\n        return False\n\n    ##############################################################\n    ###################### Device methods ########################\n    ##############################################################\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the FAN\n        Returns:\n            bool: True if FAN is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of\n        entPhysicalContainedIn is'0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device\n            or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py": {"changes": [{"diff": "\n         thermal_overload_position = Common().read_txt_file(\r\n             thermal_overload_position_path)\r\n \r\n-        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\r\n-            thermal_overload_position)\r\n+        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', thermal_overload_position]\r\n         Common().run_command(cm", "add": 1, "remove": 2, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_actions.py", "badparts": ["        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\r", "            thermal_overload_position)\r"], "goodparts": ["        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', thermal_overload_position]\r"]}], "source": "\nfrom sonic_platform_base.sonic_thermal_control.thermal_action_base import ThermalPolicyActionBase\r from sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object\r from.thermal_infos import ChassisInfo\r from.common import Common\r \r \r @thermal_json_object('thermal_control.control')\r class ControlThermalAlgoAction(ThermalPolicyActionBase):\r \"\"\"\r Action to control the thermal control algorithm\r \"\"\"\r JSON_FIELD_STATUS='status'\r \r def __init__(self):\r self.status=True\r \r def load_from_json(self, json_obj):\r \"\"\"\r Construct ControlThermalAlgoAction via JSON. JSON example:\r {\r \"type\": \"thermal_control.control\"\r \"status\": \"true\"\r }\r :param json_obj: A JSON object representing a ControlThermalAlgoAction action.\r :return:\r \"\"\"\r if ControlThermalAlgoAction.JSON_FIELD_STATUS in json_obj:\r status_str=json_obj[ControlThermalAlgoAction.JSON_FIELD_STATUS].lower(\r )\r if status_str=='true':\r self.status=True\r elif status_str=='false':\r self.status=False\r else:\r raise ValueError('Invalid{} field value, please specify true of false'.\r format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\r else:\r raise ValueError('ControlThermalAlgoAction '\r 'missing mandatory field{} in JSON policy file'.\r format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\r \r def execute(self, thermal_info_dict):\r \"\"\"\r Disable thermal control algorithm\r :param thermal_info_dict: A dictionary stores all thermal information.\r :return:\r \"\"\"\r if ChassisInfo.INFO_NAME in thermal_info_dict:\r chassis_info_obj=thermal_info_dict[ChassisInfo.INFO_NAME]\r chassis=chassis_info_obj.get_chassis()\r thermal_manager=chassis.get_thermal_manager()\r if self.status:\r thermal_manager.start_thermal_control_algorithm()\r else:\r thermal_manager.stop_thermal_control_algorithm()\r \r \r @thermal_json_object('switch.power_cycling')\r class SwitchPolicyAction(ThermalPolicyActionBase):\r \"\"\"\r Base class for thermal action. Once all thermal conditions in a thermal policy are matched,\r all predefined thermal action will be executed.\r \"\"\"\r \r def execute(self, thermal_info_dict):\r \"\"\"\r Take action when thermal condition matches. For example, power cycle the switch.\r :param thermal_info_dict: A dictionary stores all thermal information.\r :return:\r \"\"\"\r thermal_overload_position_path='/tmp/thermal_overload_position'\r thermal_overload_position=Common().read_txt_file(\r thermal_overload_position_path)\r \r cmd='bash /usr/share/sonic/platform/thermal_overload_control.sh{}'.format(\r thermal_overload_position)\r Common().run_command(cmd)\r ", "sourceWithComments": "from sonic_platform_base.sonic_thermal_control.thermal_action_base import ThermalPolicyActionBase\r\nfrom sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object\r\nfrom .thermal_infos import ChassisInfo\r\nfrom .common import Common\r\n\r\n\r\n@thermal_json_object('thermal_control.control')\r\nclass ControlThermalAlgoAction(ThermalPolicyActionBase):\r\n    \"\"\"\r\n    Action to control the thermal control algorithm\r\n    \"\"\"\r\n    # JSON field definition\r\n    JSON_FIELD_STATUS = 'status'\r\n\r\n    def __init__(self):\r\n        self.status = True\r\n\r\n    def load_from_json(self, json_obj):\r\n        \"\"\"\r\n        Construct ControlThermalAlgoAction via JSON. JSON example:\r\n            {\r\n                \"type\": \"thermal_control.control\"\r\n                \"status\": \"true\"\r\n            }\r\n        :param json_obj: A JSON object representing a ControlThermalAlgoAction action.\r\n        :return:\r\n        \"\"\"\r\n        if ControlThermalAlgoAction.JSON_FIELD_STATUS in json_obj:\r\n            status_str = json_obj[ControlThermalAlgoAction.JSON_FIELD_STATUS].lower(\r\n            )\r\n            if status_str == 'true':\r\n                self.status = True\r\n            elif status_str == 'false':\r\n                self.status = False\r\n            else:\r\n                raise ValueError('Invalid {} field value, please specify true of false'.\r\n                                 format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\r\n        else:\r\n            raise ValueError('ControlThermalAlgoAction '\r\n                             'missing mandatory field {} in JSON policy file'.\r\n                             format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\r\n\r\n    def execute(self, thermal_info_dict):\r\n        \"\"\"\r\n        Disable thermal control algorithm\r\n        :param thermal_info_dict: A dictionary stores all thermal information.\r\n        :return:\r\n        \"\"\"\r\n        if ChassisInfo.INFO_NAME in thermal_info_dict:\r\n            chassis_info_obj = thermal_info_dict[ChassisInfo.INFO_NAME]\r\n            chassis = chassis_info_obj.get_chassis()\r\n            thermal_manager = chassis.get_thermal_manager()\r\n            if self.status:\r\n                thermal_manager.start_thermal_control_algorithm()\r\n            else:\r\n                thermal_manager.stop_thermal_control_algorithm()\r\n\r\n\r\n@thermal_json_object('switch.power_cycling')\r\nclass SwitchPolicyAction(ThermalPolicyActionBase):\r\n    \"\"\"\r\n    Base class for thermal action. Once all thermal conditions in a thermal policy are matched,\r\n    all predefined thermal action will be executed.\r\n    \"\"\"\r\n\r\n    def execute(self, thermal_info_dict):\r\n        \"\"\"\r\n        Take action when thermal condition matches. For example, power cycle the switch.\r\n        :param thermal_info_dict: A dictionary stores all thermal information.\r\n        :return:\r\n        \"\"\"\r\n        thermal_overload_position_path = '/tmp/thermal_overload_position'\r\n        thermal_overload_position = Common().read_txt_file(\r\n            thermal_overload_position_path)\r\n\r\n        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\r\n            thermal_overload_position)\r\n        Common().run_command(cmd)\r\n"}, "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py": {"changes": [{"diff": "\n \n \n class ThermalManager(ThermalManagerBase):\n-    FSC_ALGORITHM_CMD = ' supervisorctl {} fancontrol'\n+    FSC_ALGORITHM_CMD = ['supervisorctl', '', 'fancontrol']\n \n     @classmethod\n     def start_thermal_control_algorithm(cls):\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py", "badparts": ["    FSC_ALGORITHM_CMD = ' supervisorctl {} fancontrol'"], "goodparts": ["    FSC_ALGORITHM_CMD = ['supervisorctl', '', 'fancontrol']"]}, {"diff": "\n         Returns:\n             bool: True if set success, False if fail.\n         \"\"\"\n-        cmd = 'start' if enable else 'stop'\n-        return Common().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n+        cls.FSC_ALGORITHM_CMD[1] = 'start' if enable else 'stop'\n+        return Common().run_command(cls.FSC_ALGORITHM_", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_e1031-r0/sonic_platform/thermal_manager.py", "badparts": ["        cmd = 'start' if enable else 'stop'", "        return Common().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))"], "goodparts": ["        cls.FSC_ALGORITHM_CMD[1] = 'start' if enable else 'stop'", "        return Common().run_command(cls.FSC_ALGORITHM_"]}], "source": "\nfrom sonic_platform_base.sonic_thermal_control.thermal_manager_base import ThermalManagerBase from.common import Common from.thermal_actions import * from.thermal_conditions import * from.thermal_infos import * class ThermalManager(ThermalManagerBase): FSC_ALGORITHM_CMD=' supervisorctl{} fancontrol' @classmethod def start_thermal_control_algorithm(cls): \"\"\" Start vendor specific thermal control algorithm. The default behavior of this function is a no-op. :return: \"\"\" return cls._enable_fancontrol_service(True) @classmethod def stop_thermal_control_algorithm(cls): \"\"\" Stop thermal control algorithm Returns: bool: True if set success, False if fail. \"\"\" return cls._enable_fancontrol_service(False) @classmethod def deinitialize(cls): \"\"\" Destroy thermal manager, including any vendor specific cleanup. The default behavior of this function is a no-op. :return: \"\"\" return cls._enable_fancontrol_service(True) @classmethod def _enable_fancontrol_service(cls, enable): \"\"\" Control thermal by fcs algorithm Args: enable: Bool, indicate enable the algorithm or not Returns: bool: True if set success, False if fail. \"\"\" cmd='start' if enable else 'stop' return Common().run_command(cls.FSC_ALGORITHM_CMD.format(cmd)) ", "sourceWithComments": "from sonic_platform_base.sonic_thermal_control.thermal_manager_base import ThermalManagerBase\nfrom .common import Common\nfrom .thermal_actions import *\nfrom .thermal_conditions import *\nfrom .thermal_infos import *\n\n\nclass ThermalManager(ThermalManagerBase):\n    FSC_ALGORITHM_CMD = ' supervisorctl {} fancontrol'\n\n    @classmethod\n    def start_thermal_control_algorithm(cls):\n        \"\"\"\n        Start vendor specific thermal control algorithm. The default behavior of this function is a no-op.\n        :return:\n        \"\"\"\n        return cls._enable_fancontrol_service(True)\n\n    @classmethod\n    def stop_thermal_control_algorithm(cls):\n        \"\"\"\n        Stop thermal control algorithm\n        Returns:\n            bool: True if set success, False if fail.\n        \"\"\"\n        return cls._enable_fancontrol_service(False)\n\n    @classmethod\n    def deinitialize(cls):\n        \"\"\"\n        Destroy thermal manager, including any vendor specific cleanup. The default behavior of this function\n        is a no-op.\n        :return:\n        \"\"\"\n        return cls._enable_fancontrol_service(True)\n\n    @classmethod\n    def _enable_fancontrol_service(cls, enable):\n        \"\"\"\n        Control thermal by fcs algorithm\n        Args:\n            enable: Bool, indicate enable the algorithm or not\n        Returns:\n            bool: True if set success, False if fail.\n        \"\"\"\n        cmd = 'start' if enable else 'stop'\n        return Common().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n"}, "/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import os.path\n-import subprocess\n \n try:\n     from sonic_psu.psu_base import Ps", "add": 0, "remove": 2, "filename": "/device/celestica/x86_64-cel_midstone-r0/plugins/psuutil.py", "badparts": ["import subprocess"], "goodparts": []}], "source": "\n import os.path import subprocess try: from sonic_psu.psu_base import PsuBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class PsuUtil(PsuBase): \"\"\"Platform-specific PSUutil class\"\"\" def __init__(self): PsuBase.__init__(self) def get_num_psus(self): \"\"\" Retrieves the number of PSUs available on the device :return: An integer, the number of PSUs available on the device \"\"\" return 2 def get_psu_status(self, index): \"\"\" Retrieves the oprational status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is operating properly, False if PSU is faulty \"\"\" if index is None: return False status=1 return status==1 def get_psu_presence(self, index): \"\"\" Retrieves the presence status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is plugged, False if not \"\"\" if index is None: return False status=1 return status==1 ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Module contains an implementation of SONiC PSU Base API and\n# provides the PSUs status which are available in the platform\n#\n#############################################################################\n\nimport os.path\nimport subprocess\n\ntry:\n    from sonic_psu.psu_base import PsuBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass PsuUtil(PsuBase):\n    \"\"\"Platform-specific PSUutil class\"\"\"\n\n    def __init__(self):\n        PsuBase.__init__(self)\n\n    def get_num_psus(self):\n        \"\"\"\n        Retrieves the number of PSUs available on the device\n\n        :return: An integer, the number of PSUs available on the device\n        \"\"\"\n        return 2\n\n    def get_psu_status(self, index):\n        \"\"\"\n        Retrieves the oprational status of power supply unit (PSU) defined\n                by 1-based index <index>\n\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is operating properly, False if PSU is faulty\n        \"\"\"\n        if index is None:\n            return False\n\n        status = 1\n        return status == 1\n\n    def get_psu_presence(self, index):\n        \"\"\"\n        Retrieves the presence status of power supply unit (PSU) defined\n                by 1-based index <index>\n\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is plugged, False if not\n        \"\"\"\n        if index is None:\n            return False\n\n        status = 1\n        return status == 1\n"}, "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py": {"changes": [{"diff": "\n REBOOT_CAUSE_FILE = \"reboot-cause.txt\"\n PREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\n GETREG_PATH = \"/sys/devices/platform/dx010_cpld/getreg\"\n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n STATUS_LED_PATH = \"/sys/devices/platform/leds_dx010/leds/dx010:green:stat/brightnes", "add": 0, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/chassis.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": []}], "source": "\n try: import sys from sonic_platform_base.chassis_base import ChassisBase from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper from sonic_py_common import device_info from.event import SfpEvent from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") NUM_FAN_TRAY=5 NUM_PSU=2 NUM_THERMAL=5 NUM_SFP=32 NUM_COMPONENT=5 RESET_REGISTER=\"0x103\" HOST_REBOOT_CAUSE_PATH=\"/host/reboot-cause/\" REBOOT_CAUSE_FILE=\"reboot-cause.txt\" PREV_REBOOT_CAUSE_FILE=\"previous-reboot-cause.txt\" GETREG_PATH=\"/sys/devices/platform/dx010_cpld/getreg\" HOST_CHK_CMD=\"docker > /dev/null 2>&1\" STATUS_LED_PATH=\"/sys/devices/platform/leds_dx010/leds/dx010:green:stat/brightness\" class Chassis(ChassisBase): \"\"\"Platform-specific Chassis class\"\"\" def __init__(self): ChassisBase.__init__(self) self._api_helper=APIHelper() self.sfp_module_initialized=False self.__initialize_eeprom() self.is_host=self._api_helper.is_host() self.__initialize_fan() self.__initialize_psu() self.__initialize_thermals() self.__initialize_components() def __initialize_sfp(self): sfputil_helper=SfpUtilHelper() port_config_file_path=device_info.get_path_to_port_config_file() sfputil_helper.read_porttab_mappings(port_config_file_path, 0) from sonic_platform.sfp import Sfp for index in range(0, NUM_SFP): sfp=Sfp(index, sfputil_helper.logical[index]) self._sfp_list.append(sfp) self.sfp_module_initialized=True def __initialize_psu(self): from sonic_platform.psu import Psu for index in range(0, NUM_PSU): psu=Psu(index) self._psu_list.append(psu) def __initialize_fan(self): from sonic_platform.fan_drawer import FanDrawer for i in range(NUM_FAN_TRAY): fandrawer=FanDrawer(i) self._fan_drawer_list.append(fandrawer) self._fan_list.extend(fandrawer._fan_list) def __initialize_thermals(self): from sonic_platform.thermal import Thermal airflow=self.__get_air_flow() for index in range(0, NUM_THERMAL): thermal=Thermal(index, airflow) self._thermal_list.append(thermal) def __initialize_eeprom(self): from sonic_platform.eeprom import Tlv self._eeprom=Tlv() def __initialize_components(self): from sonic_platform.component import Component for index in range(0, NUM_COMPONENT): component=Component(index) self._component_list.append(component) def __get_air_flow(self): air_flow_path='/usr/share/sonic/device/{}/fan_airflow'.format( self._api_helper.platform) \\ if self.is_host else '/usr/share/sonic/platform/fan_airflow' air_flow=self._api_helper.read_one_line_file(air_flow_path) return air_flow or 'B2F' def get_base_mac(self): \"\"\" Retrieves the base MAC address for the chassis Returns: A string containing the MAC address in the format 'XX:XX:XX:XX:XX:XX' \"\"\" return self._eeprom.get_mac() def get_system_eeprom_info(self): \"\"\" Retrieves the full content of system EEPROM information for the chassis Returns: A dictionary where keys are the type code defined in OCP ONIE TlvInfo EEPROM format and values are their corresponding values. \"\"\" return self._eeprom.get_eeprom() def get_reboot_cause(self): \"\"\" Retrieves the cause of the previous reboot Returns: A tuple(string, string) where the first element is a string containing the cause of the previous reboot. This string must be one of the predefined strings in this class. If the first string is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used to pass a description of the reboot cause. REBOOT_CAUSE_POWER_LOSS=\"Power Loss\" REBOOT_CAUSE_THERMAL_OVERLOAD_CPU=\"Thermal Overload: CPU\" REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC=\"Thermal Overload: ASIC\" REBOOT_CAUSE_THERMAL_OVERLOAD_OTHER=\"Thermal Overload: Other\" REBOOT_CAUSE_INSUFFICIENT_FAN_SPEED=\"Insufficient Fan Speed\" REBOOT_CAUSE_WATCHDOG=\"Watchdog\" REBOOT_CAUSE_HARDWARE_OTHER=\"Hardware -Other\" REBOOT_CAUSE_NON_HARDWARE=\"Non-Hardware\" \"\"\" reboot_cause_path=(HOST_REBOOT_CAUSE_PATH +REBOOT_CAUSE_FILE) sw_reboot_cause=self._api_helper.read_txt_file( reboot_cause_path) or \"Unknown\" hw_reboot_cause=self._api_helper.get_cpld_reg_value( GETREG_PATH, RESET_REGISTER) prev_reboot_cause={ '0x11':(self.REBOOT_CAUSE_POWER_LOSS, 'Power on reset'), '0x22':(self.REBOOT_CAUSE_HARDWARE_OTHER, 'CPLD_WD_RESET'), '0x33':(self.REBOOT_CAUSE_HARDWARE_OTHER, 'Power cycle reset triggered by CPU'), '0x44':(self.REBOOT_CAUSE_HARDWARE_OTHER, 'Power cycle reset triggered by reset button'), '0x55':(self.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU, ''), '0x66':(self.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC, ''), '0x77':(self.REBOOT_CAUSE_WATCHDOG, '') }.get(hw_reboot_cause,(self.REBOOT_CAUSE_HARDWARE_OTHER, 'Unknown reason')) if sw_reboot_cause !='Unknown' and hw_reboot_cause=='0x11': prev_reboot_cause=( self.REBOOT_CAUSE_NON_HARDWARE, sw_reboot_cause) return prev_reboot_cause def get_change_event(self, timeout=0): \"\"\" Returns a nested dictionary containing all devices which have experienced a change at chassis level Args: timeout: Timeout in milliseconds(optional). If timeout==0, this method will block until a change is detected. Returns: (bool, dict): -True if call successful, False if not; -A nested dictionary where key is a device type, value is a dictionary with key:value pairs in the format of {'device_id':'device_event'}, where device_id is the device ID for this device and device_event, status='1' represents device inserted, status='0' represents device removed. Ex.{'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}} indicates that fan 0 has been removed, fan 2 has been inserted and sfp 11 has been removed. \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() sfp_event=SfpEvent(self._sfp_list).get_sfp_event(timeout) if sfp_event: return True,{'sfp': sfp_event} return False,{'sfp':{}} def get_num_sfps(self): \"\"\" Retrieves the number of sfps available on this chassis Returns: An integer, the number of sfps available on this chassis \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() return len(self._sfp_list) def get_all_sfps(self): \"\"\" Retrieves all sfps available on this chassis Returns: A list of objects derived from SfpBase representing all sfps available on this chassis \"\"\" if not self.sfp_module_initialized: self.__initialize_sfp() return self._sfp_list def get_sfp(self, index): \"\"\" Retrieves sfp represented by(1-based) index <index> Args: index: An integer, the index(1-based) of the sfp to retrieve. The index should be the sequence of a physical port in a chassis, starting from 1. For example, 1 for Ethernet0, 2 for Ethernet4 and so on. Returns: An object dervied from SfpBase representing the specified sfp \"\"\" sfp=None if not self.sfp_module_initialized: self.__initialize_sfp() try: sfp=self._sfp_list[index -1] except IndexError: sys.stderr.write(\"SFP index{} out of range(1-{})\\n\".format( index, len(self._sfp_list))) return sfp def get_watchdog(self): \"\"\" Retreives hardware watchdog device on this chassis Returns: An object derived from WatchdogBase representing the hardware watchdog device \"\"\" if self._watchdog is None: from sonic_platform.watchdog import Watchdog self._watchdog=Watchdog() return self._watchdog def get_thermal_manager(self): from.thermal_manager import ThermalManager return ThermalManager def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return self._api_helper.hwsku def get_presence(self): \"\"\" Retrieves the presence of the Chassis Returns: bool: True if Chassis is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return self._eeprom.get_pn() def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return self._eeprom.get_serial() def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False def set_status_led(self, color): \"\"\" Sets the state of the PSU status LED Args: color: A string representing the color with which to set the PSU status LED Note: Only support green and off Returns: bool: True if status LED state is set successfully, False if not \"\"\" set_status_str={ self.STATUS_LED_COLOR_GREEN: '1', self.STATUS_LED_COLOR_OFF: '0' }.get(color, None) if not set_status_str: return False return self._api_helper.write_txt_file(STATUS_LED_PATH, set_status_str) def get_status_led(self): \"\"\" Gets the state of the PSU status LED Returns: A string, one of the predefined STATUS_LED_COLOR_* strings above \"\"\" status=self._api_helper.read_txt_file(STATUS_LED_PATH) status_str={ '255': self.STATUS_LED_COLOR_GREEN, '0': self.STATUS_LED_COLOR_OFF }.get(status, None) return status_str ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the Chassis information which are available in the platform\n#\n#############################################################################\n\ntry:\n    import sys\n    from sonic_platform_base.chassis_base import ChassisBase\n    from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper\n    from sonic_py_common import device_info\n    from .event import SfpEvent\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nNUM_FAN_TRAY = 5\nNUM_PSU = 2\nNUM_THERMAL = 5\nNUM_SFP = 32\nNUM_COMPONENT = 5\nRESET_REGISTER = \"0x103\"\nHOST_REBOOT_CAUSE_PATH = \"/host/reboot-cause/\"\nREBOOT_CAUSE_FILE = \"reboot-cause.txt\"\nPREV_REBOOT_CAUSE_FILE = \"previous-reboot-cause.txt\"\nGETREG_PATH = \"/sys/devices/platform/dx010_cpld/getreg\"\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nSTATUS_LED_PATH = \"/sys/devices/platform/leds_dx010/leds/dx010:green:stat/brightness\"\n\n\nclass Chassis(ChassisBase):\n    \"\"\"Platform-specific Chassis class\"\"\"\n\n    def __init__(self):\n        ChassisBase.__init__(self)\n        self._api_helper = APIHelper()\n        self.sfp_module_initialized = False\n        self.__initialize_eeprom()\n        self.is_host = self._api_helper.is_host()\n\n        self.__initialize_fan()\n        self.__initialize_psu()\n        self.__initialize_thermals()\n        self.__initialize_components()\n\n    def __initialize_sfp(self):\n        sfputil_helper = SfpUtilHelper()\n        port_config_file_path = device_info.get_path_to_port_config_file()\n        sfputil_helper.read_porttab_mappings(port_config_file_path, 0)\n\n        from sonic_platform.sfp import Sfp\n        for index in range(0, NUM_SFP):\n            sfp = Sfp(index, sfputil_helper.logical[index])\n            self._sfp_list.append(sfp)\n        self.sfp_module_initialized = True\n\n    def __initialize_psu(self):\n        from sonic_platform.psu import Psu\n        for index in range(0, NUM_PSU):\n            psu = Psu(index)\n            self._psu_list.append(psu)\n\n    def __initialize_fan(self):\n        from sonic_platform.fan_drawer import FanDrawer\n        for i in range(NUM_FAN_TRAY):\n            fandrawer = FanDrawer(i)\n            self._fan_drawer_list.append(fandrawer)\n            self._fan_list.extend(fandrawer._fan_list)\n\n    def __initialize_thermals(self):\n        from sonic_platform.thermal import Thermal\n        airflow = self.__get_air_flow()\n        for index in range(0, NUM_THERMAL):\n            thermal = Thermal(index, airflow)\n            self._thermal_list.append(thermal)\n\n    def __initialize_eeprom(self):\n        from sonic_platform.eeprom import Tlv\n        self._eeprom = Tlv()\n\n    def __initialize_components(self):\n        from sonic_platform.component import Component\n        for index in range(0, NUM_COMPONENT):\n            component = Component(index)\n            self._component_list.append(component)\n\n    def __get_air_flow(self):\n        air_flow_path = '/usr/share/sonic/device/{}/fan_airflow'.format(\n            self._api_helper.platform) \\\n            if self.is_host else '/usr/share/sonic/platform/fan_airflow'\n        air_flow = self._api_helper.read_one_line_file(air_flow_path)\n        return air_flow or 'B2F'\n\n    def get_base_mac(self):\n        \"\"\"\n        Retrieves the base MAC address for the chassis\n        Returns:\n            A string containing the MAC address in the format\n            'XX:XX:XX:XX:XX:XX'\n        \"\"\"\n        return self._eeprom.get_mac()\n\n    def get_system_eeprom_info(self):\n        \"\"\"\n        Retrieves the full content of system EEPROM information for the chassis\n        Returns:\n            A dictionary where keys are the type code defined in\n            OCP ONIE TlvInfo EEPROM format and values are their corresponding\n            values.\n        \"\"\"\n        return self._eeprom.get_eeprom()\n\n    def get_reboot_cause(self):\n        \"\"\"\n        Retrieves the cause of the previous reboot\n        Returns:\n            A tuple (string, string) where the first element is a string\n            containing the cause of the previous reboot. This string must be\n            one of the predefined strings in this class. If the first string\n            is \"REBOOT_CAUSE_HARDWARE_OTHER\", the second string can be used\n            to pass a description of the reboot cause.\n\n            REBOOT_CAUSE_POWER_LOSS = \"Power Loss\"\n            REBOOT_CAUSE_THERMAL_OVERLOAD_CPU = \"Thermal Overload: CPU\"\n            REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC = \"Thermal Overload: ASIC\"\n            REBOOT_CAUSE_THERMAL_OVERLOAD_OTHER = \"Thermal Overload: Other\"\n            REBOOT_CAUSE_INSUFFICIENT_FAN_SPEED = \"Insufficient Fan Speed\"\n            REBOOT_CAUSE_WATCHDOG = \"Watchdog\"\n            REBOOT_CAUSE_HARDWARE_OTHER = \"Hardware - Other\"\n            REBOOT_CAUSE_NON_HARDWARE = \"Non-Hardware\"\n\n        \"\"\"\n        reboot_cause_path = (HOST_REBOOT_CAUSE_PATH + REBOOT_CAUSE_FILE)\n        sw_reboot_cause = self._api_helper.read_txt_file(\n            reboot_cause_path) or \"Unknown\"\n        hw_reboot_cause = self._api_helper.get_cpld_reg_value(\n            GETREG_PATH, RESET_REGISTER)\n\n        prev_reboot_cause = {\n            '0x11': (self.REBOOT_CAUSE_POWER_LOSS, 'Power on reset'),\n            '0x22': (self.REBOOT_CAUSE_HARDWARE_OTHER, 'CPLD_WD_RESET'),\n            '0x33': (self.REBOOT_CAUSE_HARDWARE_OTHER, 'Power cycle reset triggered by CPU'),\n            '0x44': (self.REBOOT_CAUSE_HARDWARE_OTHER, 'Power cycle reset triggered by reset button'),\n            '0x55': (self.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU, ''),\n            '0x66': (self.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC, ''),\n            '0x77': (self.REBOOT_CAUSE_WATCHDOG, '')\n        }.get(hw_reboot_cause, (self.REBOOT_CAUSE_HARDWARE_OTHER, 'Unknown reason'))\n\n        if sw_reboot_cause != 'Unknown' and hw_reboot_cause == '0x11':\n            prev_reboot_cause = (\n                self.REBOOT_CAUSE_NON_HARDWARE, sw_reboot_cause)\n\n        return prev_reboot_cause\n\n    def get_change_event(self, timeout=0):\n        \"\"\"\n        Returns a nested dictionary containing all devices which have\n        experienced a change at chassis level\n        Args:\n            timeout: Timeout in milliseconds (optional). If timeout == 0,\n                this method will block until a change is detected.\n        Returns:\n            (bool, dict):\n                - True if call successful, False if not;\n                - A nested dictionary where key is a device type,\n                  value is a dictionary with key:value pairs in the format of\n                  {'device_id':'device_event'},\n                  where device_id is the device ID for this device and\n                        device_event,\n                             status='1' represents device inserted,\n                             status='0' represents device removed.\n                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}\n                      indicates that fan 0 has been removed, fan 2\n                      has been inserted and sfp 11 has been removed.\n        \"\"\"\n        # SFP event\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        sfp_event = SfpEvent(self._sfp_list).get_sfp_event(timeout)\n        if sfp_event:\n            return True, {'sfp': sfp_event}\n\n        return False, {'sfp': {}}\n\n    ##############################################################\n    ######################## SFP methods #########################\n    ##############################################################\n\n    def get_num_sfps(self):\n        \"\"\"\n        Retrieves the number of sfps available on this chassis\n        Returns:\n            An integer, the number of sfps available on this chassis\n        \"\"\"\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return len(self._sfp_list)\n\n    def get_all_sfps(self):\n        \"\"\"\n        Retrieves all sfps available on this chassis\n        Returns:\n            A list of objects derived from SfpBase representing all sfps\n            available on this chassis\n        \"\"\"\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        return self._sfp_list\n\n    def get_sfp(self, index):\n        \"\"\"\n        Retrieves sfp represented by (1-based) index <index>\n        Args:\n            index: An integer, the index (1-based) of the sfp to retrieve.\n            The index should be the sequence of a physical port in a chassis,\n            starting from 1.\n            For example, 1 for Ethernet0, 2 for Ethernet4 and so on.\n        Returns:\n            An object dervied from SfpBase representing the specified sfp\n        \"\"\"\n        sfp = None\n        if not self.sfp_module_initialized:\n            self.__initialize_sfp()\n\n        try:\n            # The index will start from 1\n            sfp = self._sfp_list[index - 1]\n        except IndexError:\n            sys.stderr.write(\"SFP index {} out of range (1-{})\\n\".format(\n                             index, len(self._sfp_list)))\n        return sfp\n\n    ##############################################################\n    ####################### Other methods ########################\n    ##############################################################\n\n    def get_watchdog(self):\n        \"\"\"\n        Retreives hardware watchdog device on this chassis\n        Returns:\n            An object derived from WatchdogBase representing the hardware\n            watchdog device\n        \"\"\"\n        if self._watchdog is None:\n            from sonic_platform.watchdog import Watchdog\n            self._watchdog = Watchdog()\n\n        return self._watchdog\n\n    def get_thermal_manager(self):\n        from .thermal_manager import ThermalManager\n        return ThermalManager\n\n    ##############################################################\n    ###################### Device methods ########################\n    ##############################################################\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return self._api_helper.hwsku\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the Chassis\n        Returns:\n            bool: True if Chassis is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return self._eeprom.get_pn()\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return self._eeprom.get_serial()\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the PSU status LED\n        Args:\n            color: A string representing the color with which to set the PSU status LED\n                   Note: Only support green and off\n        Returns:\n            bool: True if status LED state is set successfully, False if not\n        \"\"\"\n\n        set_status_str = {\n            self.STATUS_LED_COLOR_GREEN: '1',\n            self.STATUS_LED_COLOR_OFF: '0'\n        }.get(color, None)\n\n        if not set_status_str:\n            return False\n\n        return self._api_helper.write_txt_file(STATUS_LED_PATH, set_status_str)\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the PSU status LED\n        Returns:\n            A string, one of the predefined STATUS_LED_COLOR_* strings above\n        \"\"\"\n        status = self._api_helper.read_txt_file(STATUS_LED_PATH)\n        status_str = {\n            '255': self.STATUS_LED_COLOR_GREEN,\n            '0': self.STATUS_LED_COLOR_OFF\n        }.get(status, None)\n\n        return status_str\n"}, "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py": {"changes": [{"diff": "\n \n import os.path\n import shutil\n-import subprocess\n \n try:\n     from sonic_platform_base.component_base import ComponentBase\n", "add": 0, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py", "badparts": ["import subprocess"], "goodparts": []}, {"diff": "\n \n     def get_register_value(self, register):\n         # Retrieves the cpld register value\n-        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n-        p = subprocess.Popen(\n-            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-        raw_data, err = p.communicate()\n-        if err is not '':\n-            return None\n+        with open(GETREG_PATH, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(GETREG_PATH, 'r') as file:\n+            raw_data = file.readline()\n         return raw_data.strip()\n \n     def __get_cpld_version(self):\n", "add": 4, "remove": 6, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py", "badparts": ["        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)", "        p = subprocess.Popen(", "            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "        raw_data, err = p.communicate()", "        if err is not '':", "            return None"], "goodparts": ["        with open(GETREG_PATH, 'w') as file:", "            file.write(register + '\\n')", "        with open(GETREG_PATH, 'r') as file:", "            raw_data = file.readline()"]}, {"diff": "\n             ext = \".vme\" if ext == \"\" else ext\n             new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n             shutil.copy(image_path, new_image_path)\n-            install_command = \"ispvm %s\" % new_image_path\n+            install_command = [\"ispvm\", str(new_image_path)]\n         # elif self.name == \"BIOS\":\n         #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n \n-        return self.__run_command(install_command)\n+        return self._api_helper.run_command(install_command)\n \n \n     def update_firmware(self, image", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/component.py", "badparts": ["            install_command = \"ispvm %s\" % new_image_path", "        return self.__run_command(install_command)"], "goodparts": ["            install_command = [\"ispvm\", str(new_image_path)]", "        return self._api_helper.run_command(install_command)"]}], "source": "\n import os.path import shutil import subprocess try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") CPLD_ADDR_MAPPING={ \"CPLD1\": \"0x100\", \"CPLD2\": \"0x200\", \"CPLD3\": \"0x280\", \"CPLD4\": \"0x300\", \"CPLD5\": \"0x380\" } GETREG_PATH=\"/sys/devices/platform/dx010_cpld/getreg\" BIOS_VERSION_PATH=\"/sys/class/dmi/id/bios_version\" COMPONENT_NAME_LIST=[\"CPLD1\", \"CPLD2\", \"CPLD3\", \"CPLD4\", \"BIOS\"] COMPONENT_DES_LIST=[\"Used for managing the CPU\", \"Used for managing QSFP+ports(1-10)\", \"Used for managing QSFP+ports(11-20)\", \"Used for managing QSFP+ports(22-32)\", \"Basic Input/Output System\"] class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index): ComponentBase.__init__(self) self.index=component_index self._api_helper=APIHelper() self.name=self.get_name() def __get_bios_version(self): try: with open(BIOS_VERSION_PATH, 'r') as fd: bios_version=fd.read() return bios_version.strip() except Exception as e: return None def get_register_value(self, register): cmd=\"echo{1} >{0}; cat{0}\".format(GETREG_PATH, register) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err is not '': return None return raw_data.strip() def __get_cpld_version(self): cpld_version=dict() for cpld_name in CPLD_ADDR_MAPPING: try: cpld_addr=CPLD_ADDR_MAPPING[cpld_name] cpld_version_raw=self.get_register_value(cpld_addr) cpld_version_str=\"{}.{}\".format(int(cpld_version_raw[2], 16), int( cpld_version_raw[3], 16)) if cpld_version_raw is not None else 'None' cpld_version[cpld_name]=cpld_version_str except Exception as e: cpld_version[cpld_name]='None' return cpld_version def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_NAME_LIST[self.index] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_DES_LIST[self.index] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version=None if self.name==\"BIOS\": fw_version=self.__get_bios_version() elif \"CPLD\" in self.name: cpld_version=self.__get_cpld_version() fw_version=cpld_version.get(self.name) return fw_version def get_available_firmware_version(self, image_path): \"\"\" Retrieves the available firmware version of the component Note: the firmware version will be read from image Args: image_path: A string, path to firmware image Returns: A string containing the available firmware version of the component \"\"\" return \"N/A\" def get_firmware_update_notification(self, image_path): \"\"\" Retrieves a notification on what should be done in order to complete the component firmware update Args: image_path: A string, path to firmware image Returns: A string containing the component firmware update notification if required. By default 'None' value will be used, which indicates that no actions are required \"\"\" return \"None\" def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" if not os.path.isfile(image_path): return False if \"CPLD\" in self.name: img_name=os.path.basename(image_path) root, ext=os.path.splitext(img_name) ext=\".vme\" if ext==\"\" else ext new_image_path=os.path.join(\"/tmp\",(root.lower() +ext)) shutil.copy(image_path, new_image_path) install_command=\"ispvm %s\" % new_image_path return self.__run_command(install_command) def update_firmware(self, image_path): \"\"\" Updates firmware of the component This API performs firmware update: it assumes firmware installation and loading in a single call. In case platform component requires some extra steps(apart from calling Low Level Utility) to load the installed firmware(e.g, reboot, power cycle, etc.) -this will be done automatically by API Args: image_path: A string, path to firmware image Raises: RuntimeError: update failed \"\"\" return False def get_presence(self): \"\"\" Retrieves the presence of the FAN Returns: bool: True if FAN is present, False if not \"\"\" return True def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" return 'N/A' def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" return 'N/A' def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" return True def get_position_in_parent(self): \"\"\" Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position for some reason, or if the associated value of entPhysicalContainedIn is'0', then the value '-1' is returned Returns: integer: The 1-based relative physical position in parent device or -1 if cannot determine the position \"\"\" return -1 def is_replaceable(self): \"\"\" Indicate whether this device is replaceable. Returns: bool: True if it is replaceable. \"\"\" return False ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport os.path\nimport shutil\nimport subprocess\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCPLD_ADDR_MAPPING = {\n    \"CPLD1\": \"0x100\",\n    \"CPLD2\": \"0x200\",\n    \"CPLD3\": \"0x280\",\n    \"CPLD4\": \"0x300\",\n    \"CPLD5\": \"0x380\"\n}\nGETREG_PATH = \"/sys/devices/platform/dx010_cpld/getreg\"\nBIOS_VERSION_PATH = \"/sys/class/dmi/id/bios_version\"\nCOMPONENT_NAME_LIST = [\"CPLD1\", \"CPLD2\", \"CPLD3\", \"CPLD4\", \"BIOS\"]\nCOMPONENT_DES_LIST = [\"Used for managing the CPU\",\n                      \"Used for managing QSFP+ ports (1-10)\", \"Used for managing QSFP+ ports (11-20)\", \"Used for managing QSFP+ ports (22-32)\", \"Basic Input/Output System\"]\n\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index):\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self._api_helper = APIHelper()\n        self.name = self.get_name()\n\n    def __get_bios_version(self):\n        # Retrieves the BIOS firmware version\n        try:\n            with open(BIOS_VERSION_PATH, 'r') as fd:\n                bios_version = fd.read()\n                return bios_version.strip()\n        except Exception as e:\n            return None\n\n    def get_register_value(self, register):\n        # Retrieves the cpld register value\n        cmd = \"echo {1} > {0}; cat {0}\".format(GETREG_PATH, register)\n        p = subprocess.Popen(\n            cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        raw_data, err = p.communicate()\n        if err is not '':\n            return None\n        return raw_data.strip()\n\n    def __get_cpld_version(self):\n        # Retrieves the CPLD firmware version\n        cpld_version = dict()\n        for cpld_name in CPLD_ADDR_MAPPING:\n            try:\n                cpld_addr = CPLD_ADDR_MAPPING[cpld_name]\n                cpld_version_raw = self.get_register_value(cpld_addr)\n                cpld_version_str = \"{}.{}\".format(int(cpld_version_raw[2], 16), int(\n                    cpld_version_raw[3], 16)) if cpld_version_raw is not None else 'None'\n                cpld_version[cpld_name] = cpld_version_str\n            except Exception as e:\n                cpld_version[cpld_name] = 'None'\n        return cpld_version\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_NAME_LIST[self.index]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_DES_LIST[self.index]\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = None\n\n        if self.name == \"BIOS\":\n            fw_version = self.__get_bios_version()\n        elif \"CPLD\" in self.name:\n            cpld_version = self.__get_cpld_version()\n            fw_version = cpld_version.get(self.name)\n\n        return fw_version\n\n    def get_available_firmware_version(self, image_path):\n        \"\"\"\n        Retrieves the available firmware version of the component\n        Note: the firmware version will be read from image\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A string containing the available firmware version of the component\n        \"\"\"\n        return \"N/A\"\n\n    def get_firmware_update_notification(self, image_path):\n        \"\"\"\n        Retrieves a notification on what should be done in order to complete\n        the component firmware update\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A string containing the component firmware update notification if required.\n            By default 'None' value will be used, which indicates that no actions are required\n        \"\"\"\n        return \"None\"\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        if not os.path.isfile(image_path):\n            return False\n\n        if \"CPLD\" in self.name:\n            img_name = os.path.basename(image_path)\n            root, ext = os.path.splitext(img_name)\n            ext = \".vme\" if ext == \"\" else ext\n            new_image_path = os.path.join(\"/tmp\", (root.lower() + ext))\n            shutil.copy(image_path, new_image_path)\n            install_command = \"ispvm %s\" % new_image_path\n        # elif self.name == \"BIOS\":\n        #     install_command = \"afulnx_64 %s /p /b /n /x /r\" % image_path\n\n        return self.__run_command(install_command)\n\n\n    def update_firmware(self, image_path):\n        \"\"\"\n        Updates firmware of the component\n        This API performs firmware update: it assumes firmware installation and loading in a single call.\n        In case platform component requires some extra steps (apart from calling Low Level Utility)\n        to load the installed firmware (e.g, reboot, power cycle, etc.) - this will be done automatically by API\n        Args:\n            image_path: A string, path to firmware image\n        Raises:\n            RuntimeError: update failed\n        \"\"\"\n        return False\n\n\n    ##############################################################\n    ###################### Device methods ########################\n    ##############################################################\n\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the FAN\n        Returns:\n            bool: True if FAN is present, False if not\n        \"\"\"\n        return True\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        return 'N/A'\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        return True\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves 1-based relative physical position in parent device.\n        If the agent cannot determine the parent-relative position\n        for some reason, or if the associated value of\n        entPhysicalContainedIn is'0', then the value '-1' is returned\n        Returns:\n            integer: The 1-based relative physical position in parent device\n            or -1 if cannot determine the position\n        \"\"\"\n        return -1\n\n    def is_replaceable(self):\n        \"\"\"\n        Indicate whether this device is replaceable.\n        Returns:\n            bool: True if it is replaceable.\n        \"\"\"\n        return False\n"}, "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n \n from sonic_py_common import device_info\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 5, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        try:", "            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)", "        except FileNotFoundError:", "            return False", "        return True"]}, {"diff": "\n         result = \"\"\n         try:\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = raw_data.strip()\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py", "badparts": ["                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"], "goodparts": ["                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_interactive_command(self, cmd):\n-        try:\n-            os.system(cmd)\n-        except:\n-            return False\n-        return True\n-\n     def read_txt_file(self, file_path):\n         try:\n             with open(file_path, 'r') as fd:\n", "add": 0, "remove": 7, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py", "badparts": ["    def run_interactive_command(self, cmd):", "        try:", "            os.system(cmd)", "        except:", "            return False", "        return True"], "goodparts": []}, {"diff": "\n         return True\n \n     def get_cpld_reg_value(self, getreg_path, register):\n-        cmd = \"echo {1} > {0}; cat {0}\".format(getreg_path, register)\n-        status, result = self.run_command(cmd)\n-        return result if status else None\n+        with open(getreg_path, 'w') as file:\n+            file.write(register + '\\n')\n+        with open(getreg_path, 'r') as file:\n+            result = file.readline()\n+        return result\n \n-    def ipmi_raw(self, netfn, cmd):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status, result\n-\n-    def ipmi_fru_id(self, id, key=None):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status, result\n-\n-    def ipmi_set_ss_thres(self, id, threshold_key, value):\n-        status = True\n-        result = \"\"\n-        try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(\n-                str(id), str(threshold_key), str(value))\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n-                status = False\n-        except:\n-            status = False\n-        return status", "add": 5, "remove": 53, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/helper.py", "badparts": ["        cmd = \"echo {1} > {0}; cat {0}\".format(getreg_path, register)", "        status, result = self.run_command(cmd)", "        return result if status else None", "    def ipmi_raw(self, netfn, cmd):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "            p = subprocess.Popen(", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except:", "            status = False", "        return status, result", "    def ipmi_fru_id(self, id, key=None):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except:", "            status = False", "        return status, result", "    def ipmi_set_ss_thres(self, id, threshold_key, value):", "        status = True", "        result = \"\"", "        try:", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(", "                str(id), str(threshold_key), str(value))", "            p = subprocess.Popen(", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "                status = False", "        except:", "            status = False", "        return status"], "goodparts": ["        with open(getreg_path, 'w') as file:", "            file.write(register + '\\n')", "        with open(getreg_path, 'r') as file:", "            result = file.readline()", "        return result"]}], "source": "\nimport os import struct import subprocess from mmap import * from sonic_py_common import device_info HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def read_one_line_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.readline() return data.strip() except IOError: pass return None def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except Exception: return False return True def get_cpld_reg_value(self, getreg_path, register): cmd=\"echo{1} >{0}; cat{0}\".format(getreg_path, register) status, result=self.run_command(cmd) return result if status else None def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format( str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\n\nfrom sonic_py_common import device_info\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def read_one_line_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.readline()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except Exception:\n            return False\n        return True\n\n    def get_cpld_reg_value(self, getreg_path, register):\n        cmd = \"echo {1} > {0}; cat {0}\".format(getreg_path, register)\n        status, result = self.run_command(cmd)\n        return result if status else None\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(\n                str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n"}, "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py": {"changes": [{"diff": "\n         thermal_overload_position = APIHelper().read_one_line_file(\n             thermal_overload_position_path)\n \n-        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\n-            thermal_overload_position)\n+        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', str(thermal_overload_position)]\n         APIHelper().run_com", "add": 1, "remove": 2, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_actions.py", "badparts": ["        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(", "            thermal_overload_position)"], "goodparts": ["        cmd = ['bash', '/usr/share/sonic/platform/thermal_overload_control.sh', str(thermal_overload_position)]"]}], "source": "\n\nfrom sonic_platform_base.sonic_thermal_control.thermal_action_base import ThermalPolicyActionBase from sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object from.thermal_infos import ChassisInfo from.helper import APIHelper @thermal_json_object('thermal_control.control') class ControlThermalAlgoAction(ThermalPolicyActionBase): \"\"\" Action to control the thermal control algorithm \"\"\" JSON_FIELD_STATUS='status' def __init__(self): self.status=True def load_from_json(self, json_obj): \"\"\" Construct ControlThermalAlgoAction via JSON. JSON example: { \"type\": \"thermal_control.control\" \"status\": \"true\" } :param json_obj: A JSON object representing a ControlThermalAlgoAction action. :return: \"\"\" if ControlThermalAlgoAction.JSON_FIELD_STATUS in json_obj: status_str=json_obj[ControlThermalAlgoAction.JSON_FIELD_STATUS].lower() if status_str=='true': self.status=True elif status_str=='false': self.status=False else: raise ValueError('Invalid{} field value, please specify true of false'. format(ControlThermalAlgoAction.JSON_FIELD_STATUS)) else: raise ValueError('ControlThermalAlgoAction ' 'missing mandatory field{} in JSON policy file'. format(ControlThermalAlgoAction.JSON_FIELD_STATUS)) def execute(self, thermal_info_dict): \"\"\" Disable thermal control algorithm :param thermal_info_dict: A dictionary stores all thermal information. :return: \"\"\" if ChassisInfo.INFO_NAME in thermal_info_dict: chassis_info_obj=thermal_info_dict[ChassisInfo.INFO_NAME] chassis=chassis_info_obj.get_chassis() thermal_manager=chassis.get_thermal_manager() if self.status: thermal_manager.start_thermal_control_algorithm() else: thermal_manager.stop_thermal_control_algorithm() @thermal_json_object('switch.power_cycling') class SwitchPolicyAction(ThermalPolicyActionBase): \"\"\" Base class for thermal action. Once all thermal conditions in a thermal policy are matched, all predefined thermal action will be executed. \"\"\" def execute(self, thermal_info_dict): \"\"\" Take action when thermal condition matches. For example, power cycle the switch. :param thermal_info_dict: A dictionary stores all thermal information. :return: \"\"\" thermal_overload_position_path='/tmp/thermal_overload_position' thermal_overload_position=APIHelper().read_one_line_file( thermal_overload_position_path) cmd='bash /usr/share/sonic/platform/thermal_overload_control.sh{}'.format( thermal_overload_position) APIHelper().run_command(cmd) ", "sourceWithComments": "\nfrom sonic_platform_base.sonic_thermal_control.thermal_action_base import ThermalPolicyActionBase\nfrom sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object\nfrom .thermal_infos import ChassisInfo\nfrom .helper import APIHelper\n\n\n@thermal_json_object('thermal_control.control')\nclass ControlThermalAlgoAction(ThermalPolicyActionBase):\n    \"\"\"\n    Action to control the thermal control algorithm\n    \"\"\"\n    # JSON field definition\n    JSON_FIELD_STATUS = 'status'\n\n    def __init__(self):\n        self.status = True\n\n    def load_from_json(self, json_obj):\n        \"\"\"\n        Construct ControlThermalAlgoAction via JSON. JSON example:\n            {\n                \"type\": \"thermal_control.control\"\n                \"status\": \"true\"\n            }\n        :param json_obj: A JSON object representing a ControlThermalAlgoAction action.\n        :return:\n        \"\"\"\n        if ControlThermalAlgoAction.JSON_FIELD_STATUS in json_obj:\n            status_str = json_obj[ControlThermalAlgoAction.JSON_FIELD_STATUS].lower()\n            if status_str == 'true':\n                self.status = True\n            elif status_str == 'false':\n                self.status = False\n            else:\n                raise ValueError('Invalid {} field value, please specify true of false'.\n                                 format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\n        else:\n            raise ValueError('ControlThermalAlgoAction '\n                             'missing mandatory field {} in JSON policy file'.\n                             format(ControlThermalAlgoAction.JSON_FIELD_STATUS))\n\n    def execute(self, thermal_info_dict):\n        \"\"\"\n        Disable thermal control algorithm\n        :param thermal_info_dict: A dictionary stores all thermal information.\n        :return:\n        \"\"\"\n        if ChassisInfo.INFO_NAME in thermal_info_dict:\n            chassis_info_obj = thermal_info_dict[ChassisInfo.INFO_NAME]\n            chassis = chassis_info_obj.get_chassis()\n            thermal_manager = chassis.get_thermal_manager()\n            if self.status:\n                thermal_manager.start_thermal_control_algorithm()\n            else:\n                thermal_manager.stop_thermal_control_algorithm()\n\n\n@thermal_json_object('switch.power_cycling')\nclass SwitchPolicyAction(ThermalPolicyActionBase):\n    \"\"\"\n    Base class for thermal action. Once all thermal conditions in a thermal policy are matched,\n    all predefined thermal action will be executed.\n    \"\"\"\n\n    def execute(self, thermal_info_dict):\n        \"\"\"\n        Take action when thermal condition matches. For example, power cycle the switch.\n        :param thermal_info_dict: A dictionary stores all thermal information.\n        :return:\n        \"\"\"\n        thermal_overload_position_path = '/tmp/thermal_overload_position'\n        thermal_overload_position = APIHelper().read_one_line_file(\n            thermal_overload_position_path)\n\n        cmd = 'bash /usr/share/sonic/platform/thermal_overload_control.sh {}'.format(\n            thermal_overload_position)\n        APIHelper().run_command(cmd)\n"}, "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py": {"changes": [{"diff": "\n from .thermal_infos import *\n \n class ThermalManager(ThermalManagerBase):\n-    FSC_ALGORITHM_CMD = 'service fancontrol {}'\n+    FSC_ALGORITHM_CMD = ['service', 'fancontrol', '']\n \n     @classmethod\n     def start_thermal_control_algorithm(cls):\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py", "badparts": ["    FSC_ALGORITHM_CMD = 'service fancontrol {}'"], "goodparts": ["    FSC_ALGORITHM_CMD = ['service', 'fancontrol', '']"]}, {"diff": "\n         Returns:\n             bool: True if set success, False if fail.\n         \"\"\"\n-        cmd = 'start' if enable else 'stop'\n-        return APIHelper().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n+        cls.FSC_ALGORITHM_CMD[2] = 'start' if enable else 'stop'\n+        return APIHelper().run_command(cls.FSC_ALGO", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_seastone-r0/sonic_platform/thermal_manager.py", "badparts": ["        cmd = 'start' if enable else 'stop'", "        return APIHelper().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))"], "goodparts": ["        cls.FSC_ALGORITHM_CMD[2] = 'start' if enable else 'stop'", "        return APIHelper().run_command(cls.FSC_ALGO"]}], "source": "\nfrom sonic_platform_base.sonic_thermal_control.thermal_manager_base import ThermalManagerBase from.helper import APIHelper from.thermal_actions import * from.thermal_conditions import * from.thermal_infos import * class ThermalManager(ThermalManagerBase): FSC_ALGORITHM_CMD='service fancontrol{}' @classmethod def start_thermal_control_algorithm(cls): \"\"\" Start vendor specific thermal control algorithm. The default behavior of this function is a no-op. :return: \"\"\" return cls._enable_fancontrol_service(True) @classmethod def stop_thermal_control_algorithm(cls): \"\"\" Stop thermal control algorithm Returns: bool: True if set success, False if fail. \"\"\" return cls._enable_fancontrol_service(False) @classmethod def deinitialize(cls): \"\"\" Destroy thermal manager, including any vendor specific cleanup. The default behavior of this function is a no-op. :return: \"\"\" return cls._enable_fancontrol_service(True) @classmethod def _enable_fancontrol_service(cls, enable): \"\"\" Control thermal by fcs algorithm Args: enable: Bool, indicate enable the algorithm or not Returns: bool: True if set success, False if fail. \"\"\" cmd='start' if enable else 'stop' return APIHelper().run_command(cls.FSC_ALGORITHM_CMD.format(cmd)) ", "sourceWithComments": "from sonic_platform_base.sonic_thermal_control.thermal_manager_base import ThermalManagerBase\nfrom .helper import APIHelper\nfrom .thermal_actions import *\nfrom .thermal_conditions import *\nfrom .thermal_infos import *\n\nclass ThermalManager(ThermalManagerBase):\n    FSC_ALGORITHM_CMD = 'service fancontrol {}'\n\n    @classmethod\n    def start_thermal_control_algorithm(cls):\n        \"\"\"\n        Start vendor specific thermal control algorithm. The default behavior of this function is a no-op.\n        :return:\n        \"\"\"\n        return cls._enable_fancontrol_service(True)\n\n    @classmethod\n    def stop_thermal_control_algorithm(cls):\n        \"\"\"\n        Stop thermal control algorithm\n        Returns:\n            bool: True if set success, False if fail.\n        \"\"\"\n        return cls._enable_fancontrol_service(False)\n\n    @classmethod\n    def deinitialize(cls):\n        \"\"\"\n        Destroy thermal manager, including any vendor specific cleanup. The default behavior of this function\n        is a no-op.\n        :return:\n        \"\"\"\n        return cls._enable_fancontrol_service(True)\n\n    @classmethod\n    def _enable_fancontrol_service(cls, enable):\n        \"\"\"\n        Control thermal by fcs algorithm\n        Args:\n            enable: Bool, indicate enable the algorithm or not\n        Returns:\n            bool: True if set success, False if fail.\n        \"\"\"\n        cmd = 'start' if enable else 'stop'\n        return APIHelper().run_command(cls.FSC_ALGORITHM_CMD.format(cmd))\n"}, "/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py": {"changes": [{"diff": "\n-import os.path\n-import subprocess\n import sys\n import re\n \n try:\n     from sonic_psu.psu_base import PsuBase\n+    from sonic_py_common.general import getstatusoutput_noshell_pipe\n except ImportError as e:\n     raise ImportError(str(e) + \"- required module not found\")\n \n", "add": 1, "remove": 2, "filename": "/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py", "badparts": ["import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell_pipe"]}, {"diff": "\n     \"\"\"Platform-specific PSUutil class\"\"\"\n \n     def __init__(self):\n-        self.ipmi_sensor = \"ipmitool sensor\"\n+        self.ipmi_sensor = [\"ipmitool\", \"sensor\"]\n         PsuBase.__init__(self)\n \n-    def run_command(self, command):\n-        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n-        (out, err) = proc.communicate()\n-\n-        if proc.returncode != 0:\n-            sys.exit(proc.returncode)\n-\n+    def run_command(self, cmd1, cmd2):\n+        exitcode, out = getstatusoutput_noshell_pipe(cmd1, cmd2)\n+        i = 0\n+        while i < 2:\n+            if exitcode[i] != 0:\n+                sys.exit(exitcode[i])\n+            i += 1\n         return out\n \n     def find_value(self, grep_string):\n", "add": 8, "remove": 8, "filename": "/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py", "badparts": ["        self.ipmi_sensor = \"ipmitool sensor\"", "    def run_command(self, command):", "        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)", "        (out, err) = proc.communicate()", "        if proc.returncode != 0:", "            sys.exit(proc.returncode)"], "goodparts": ["        self.ipmi_sensor = [\"ipmitool\", \"sensor\"]", "    def run_command(self, cmd1, cmd2):", "        exitcode, out = getstatusoutput_noshell_pipe(cmd1, cmd2)", "        i = 0", "        while i < 2:", "            if exitcode[i] != 0:", "                sys.exit(exitcode[i])", "            i += 1"]}, {"diff": "\n             return False\n \n         grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n-        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n+        grep_cmd = [\"grep\", grep_key]\n+        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)\n         status_byte = self.find_value(grep_string)\n \n         if status_byte is None:\n", "add": 2, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py", "badparts": ["        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)"], "goodparts": ["        grep_cmd = [\"grep\", grep_key]", "        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)"]}, {"diff": "\n             return False\n \n         grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n-        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n+        grep_cmd = [\"grep\", grep_key]\n+        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)\n         status_byte = self.find_value(grep_string)\n \n         if status_by", "add": 2, "remove": 1, "filename": "/device/celestica/x86_64-cel_seastone_2-r0/plugins/psuutil.py", "badparts": ["        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)"], "goodparts": ["        grep_cmd = [\"grep\", grep_key]", "        grep_string = self.run_command(self.ipmi_sensor, grep_cmd)"]}], "source": "\nimport os.path import subprocess import sys import re try: from sonic_psu.psu_base import PsuBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class PsuUtil(PsuBase): \"\"\"Platform-specific PSUutil class\"\"\" def __init__(self): self.ipmi_sensor=\"ipmitool sensor\" PsuBase.__init__(self) def run_command(self, command): proc=subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE) (out, err)=proc.communicate() if proc.returncode !=0: sys.exit(proc.returncode) return out def find_value(self, grep_string): result=re.search(\".+\\|(0x\\d{2})\\d{2}\\|.+\", grep_string) if result: return result.group(1) else: return result def get_num_psus(self): \"\"\" Retrieves the number of PSUs available on the device :return: An integer, the number of PSUs available on the device \"\"\" return 2 def get_psu_status(self, index): \"\"\" Retrieves the oprational status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is operating properly, False if PSU is faulty \"\"\" if index is None: return False grep_key=\"PSUL_Status\" if index==1 else \"PSUR_Status\" grep_string=self.run_command(self.ipmi_sensor +' | grep ' +grep_key) status_byte=self.find_value(grep_string) if status_byte is None: return False failure_detected=(int(status_byte, 16) >> 1) & 1 input_lost=(int(status_byte, 16) >> 3) & 1 if failure_detected or input_lost: return False else: return True def get_psu_presence(self, index): \"\"\" Retrieves the presence status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is plugged, False if not \"\"\" if index is None: return False grep_key=\"PSUL_Status\" if index==1 else \"PSUR_Status\" grep_string=self.run_command(self.ipmi_sensor +' | grep ' +grep_key) status_byte=self.find_value(grep_string) if status_byte is None: return False presence=(int(status_byte, 16) >> 0) & 1 if presence: return True else: return False ", "sourceWithComments": "import os.path\nimport subprocess\nimport sys\nimport re\n\ntry:\n    from sonic_psu.psu_base import PsuBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass PsuUtil(PsuBase):\n    \"\"\"Platform-specific PSUutil class\"\"\"\n\n    def __init__(self):\n        self.ipmi_sensor = \"ipmitool sensor\"\n        PsuBase.__init__(self)\n\n    def run_command(self, command):\n        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n        (out, err) = proc.communicate()\n\n        if proc.returncode != 0:\n            sys.exit(proc.returncode)\n\n        return out\n\n    def find_value(self, grep_string):\n        result = re.search(\".+\\| (0x\\d{2})\\d{2}\\|.+\", grep_string)\n        if result:\n            return result.group(1)\n        else:\n            return result\n\n    def get_num_psus(self):\n        \"\"\"\n        Retrieves the number of PSUs available on the device\n        :return: An integer, the number of PSUs available on the device\n        \"\"\"\n        return 2\n\n    def get_psu_status(self, index):\n        \"\"\"\n        Retrieves the oprational status of power supply unit (PSU) defined\n                by 1-based index <index>\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is operating properly, False if PSU is faulty\n        \"\"\"\n        if index is None:\n            return False\n\n        grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n        status_byte = self.find_value(grep_string)\n\n        if status_byte is None:\n            return False\n\n        failure_detected = (int(status_byte, 16) >> 1) & 1\n        input_lost = (int(status_byte, 16) >> 3) & 1\n        if failure_detected or input_lost:\n            return False\n        else:\n            return True\n\n    def get_psu_presence(self, index):\n        \"\"\"\n        Retrieves the presence status of power supply unit (PSU) defined\n                by 1-based index <index>\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is plugged, False if not\n        \"\"\"\n        if index is None:\n            return False\n\n        grep_key = \"PSUL_Status\" if index == 1 else \"PSUR_Status\"\n        grep_string = self.run_command(self.ipmi_sensor + ' | grep ' + grep_key)\n        status_byte = self.find_value(grep_string)\n\n        if status_byte is None:\n            return False\n\n        presence = (int(status_byte, 16) >> 0) & 1\n        if presence:\n            return True\n        else:\n            return False\n"}, "/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py": {"changes": [{"diff": "\n     \"\"\"Platform-specific PSUutil class\"\"\"\n \n     def __init__(self):\n-        self.ipmi_raw = \"docker exec -ti pmon ipmitool raw 0x4 0x2d\"\n+        self.ipmi_raw = [\"docker\", \"exec\", \"-ti\", \"pmon\", \"ipmitool\", \"raw\", \"0x4\", \"0x2d\", \"\"]\n         self.psu1_id = \"0x2f\"\n         self.psu2_id = \"0x39\"\n         PsuBase.__init__(self)\n \n     def run_command(self, command):\n-        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n+        proc = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)\n         (out, err) = proc.communicate()\n \n         if proc.returncode != 0:\n", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py", "badparts": ["        self.ipmi_raw = \"docker exec -ti pmon ipmitool raw 0x4 0x2d\"", "        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)"], "goodparts": ["        self.ipmi_raw = [\"docker\", \"exec\", \"-ti\", \"pmon\", \"ipmitool\", \"raw\", \"0x4\", \"0x2d\", \"\"]", "        proc = subprocess.Popen(command, universal_newlines=True, stdout=subprocess.PIPE)"]}, {"diff": "\n             return False\n \n         psu_id = self.psu1_id if index == 1 else self.psu2_id\n-        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n+        self.ipmi_raw[8] = psu_id\n+        res_string = self.run_command(self.ipmi_raw)\n         status_byte = self.find_value(res_string)\n \n         if status_byte is None:\n", "add": 2, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py", "badparts": ["        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)"], "goodparts": ["        self.ipmi_raw[8] = psu_id", "        res_string = self.run_command(self.ipmi_raw)"]}, {"diff": "\n             return False\n \n         psu_id = self.psu1_id if index == 1 else self.psu2_id\n-        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n+        self.ipmi_raw[8] = psu_id\n+        res_string = self.run_command(self.ipmi_raw)\n         status_byte = self.find_value(res_string)\n \n         if status_b", "add": 2, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/plugins/psuutil.py", "badparts": ["        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)"], "goodparts": ["        self.ipmi_raw[8] = psu_id", "        res_string = self.run_command(self.ipmi_raw)"]}], "source": "\nimport os.path import subprocess import sys import re try: from sonic_psu.psu_base import PsuBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class PsuUtil(PsuBase): \"\"\"Platform-specific PSUutil class\"\"\" def __init__(self): self.ipmi_raw=\"docker exec -ti pmon ipmitool raw 0x4 0x2d\" self.psu1_id=\"0x2f\" self.psu2_id=\"0x39\" PsuBase.__init__(self) def run_command(self, command): proc=subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE) (out, err)=proc.communicate() if proc.returncode !=0: sys.exit(proc.returncode) return out def find_value(self, in_string): result=re.search(\"^.+([0-9a-f]{2}).+$\", in_string) if result: return result.group(1) else: return result def get_num_psus(self): \"\"\" Retrieves the number of PSUs available on the device :return: An integer, the number of PSUs available on the device \"\"\" return 2 def get_psu_status(self, index): \"\"\" Retrieves the oprational status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is operating properly, False if PSU is faulty \"\"\" if index is None: return False psu_id=self.psu1_id if index==1 else self.psu2_id res_string=self.run_command(self.ipmi_raw +' ' +psu_id) status_byte=self.find_value(res_string) if status_byte is None: return False failure_detected=(int(status_byte, 16) >> 1) & 1 input_lost=(int(status_byte, 16) >> 3) & 1 if failure_detected or input_lost: return False else: return True def get_psu_presence(self, index): \"\"\" Retrieves the presence status of power supply unit(PSU) defined by 1-based index <index> :param index: An integer, 1-based index of the PSU of which to query status :return: Boolean, True if PSU is plugged, False if not \"\"\" if index is None: return False psu_id=self.psu1_id if index==1 else self.psu2_id res_string=self.run_command(self.ipmi_raw +' ' +psu_id) status_byte=self.find_value(res_string) if status_byte is None: return False presence=(int(status_byte, 16) >> 0) & 1 if presence: return True else: return False ", "sourceWithComments": "import os.path\nimport subprocess\nimport sys\nimport re\n\ntry:\n    from sonic_psu.psu_base import PsuBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass PsuUtil(PsuBase):\n    \"\"\"Platform-specific PSUutil class\"\"\"\n\n    def __init__(self):\n        self.ipmi_raw = \"docker exec -ti pmon ipmitool raw 0x4 0x2d\"\n        self.psu1_id = \"0x2f\"\n        self.psu2_id = \"0x39\"\n        PsuBase.__init__(self)\n\n    def run_command(self, command):\n        proc = subprocess.Popen(command, shell=True, universal_newlines=True, stdout=subprocess.PIPE)\n        (out, err) = proc.communicate()\n\n        if proc.returncode != 0:\n            sys.exit(proc.returncode)\n\n        return out\n\n    def find_value(self, in_string):\n        result = re.search(\"^.+ ([0-9a-f]{2}) .+$\", in_string)\n        if result:\n            return result.group(1)\n        else:\n            return result\n\n    def get_num_psus(self):\n        \"\"\"\n        Retrieves the number of PSUs available on the device\n        :return: An integer, the number of PSUs available on the device\n        \"\"\"\n        return 2\n\n    def get_psu_status(self, index):\n        \"\"\"\n        Retrieves the oprational status of power supply unit (PSU) defined\n                by 1-based index <index>\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is operating properly, False if PSU is faulty\n        \"\"\"\n        if index is None:\n            return False\n\n        psu_id = self.psu1_id if index == 1 else self.psu2_id\n        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n        status_byte = self.find_value(res_string)\n\n        if status_byte is None:\n            return False\n\n        failure_detected = (int(status_byte, 16) >> 1) & 1\n        input_lost = (int(status_byte, 16) >> 3) & 1\n        if failure_detected or input_lost:\n            return False\n        else:\n            return True\n\n    def get_psu_presence(self, index):\n        \"\"\"\n        Retrieves the presence status of power supply unit (PSU) defined\n                by 1-based index <index>\n        :param index: An integer, 1-based index of the PSU of which to query status\n        :return: Boolean, True if PSU is plugged, False if not\n        \"\"\"\n        if index is None:\n            return False\n\n        psu_id = self.psu1_id if index == 1 else self.psu2_id\n        res_string = self.run_command(self.ipmi_raw + ' ' + psu_id)\n        status_byte = self.find_value(res_string)\n\n        if status_byte is None:\n            return False\n\n        presence = (int(status_byte, 16) >> 0) & 1\n        if presence:\n            return True\n        else:\n            return False\n"}, "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py": {"changes": [{"diff": "\n #\n #############################################################################\n \n-import json\n import os.path\n \n try:\n", "add": 0, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py", "badparts": ["import json"], "goodparts": []}, {"diff": "\n SW_CPLD_VER_PATH = \"/sys/module/switch_cpld/version\"\n BASE_CPLD_VER_PATH = \"/sys/module/baseboard_lpc/version\"\n-CPLD_UPGRADE_OPT = 4\n BIOS_VER_PATH = \"/sys/class/dmi/id/bios_version\"\n-BIOS__UPGRADE_OPT = 2\n-BMC_VER_CMD = \"ipmitool mc info | grep 'Firmware Revision'\"\n-BMC_UPGRADE_OPT = 1\n-CFUFLASH_FW_UPGRADE_CMD = \"CFUFLASH -cd -d {} -mse 3 {}\"\n+BMC_VER_CMD1 = [\"ipmitool\", \"mc\", \"info\"]\n+BMC_VER_CMD2 = [\"grep\", \"Firmware Revision\"]\n+CFUFLASH_FW_UPGRADE_CMD = [\"CFUFLASH\", \"-cd\", \"-d\", \"\", \"-mse\", \"3\", \"\"]\n MEM_PCI_RESOURCE = \"/sys/bus/pci/devices/0000:09:00.0/resource0\"\n FPGA_VER_MEM_OFFSET = 0\n+UPGRADE_OPT = {\n+    'BMC': '1',\n+    'BIOS': '2',\n+    'SWITCH_CPLD': '4',\n+    'BASE_CPLD': '4'\n+}\n \n \n class Component(ComponentBase):\n", "add": 9, "remove": 5, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py", "badparts": ["CPLD_UPGRADE_OPT = 4", "BIOS__UPGRADE_OPT = 2", "BMC_VER_CMD = \"ipmitool mc info | grep 'Firmware Revision'\"", "BMC_UPGRADE_OPT = 1", "CFUFLASH_FW_UPGRADE_CMD = \"CFUFLASH -cd -d {} -mse 3 {}\""], "goodparts": ["BMC_VER_CMD1 = [\"ipmitool\", \"mc\", \"info\"]", "BMC_VER_CMD2 = [\"grep\", \"Firmware Revision\"]", "CFUFLASH_FW_UPGRADE_CMD = [\"CFUFLASH\", \"-cd\", \"-d\", \"\", \"-mse\", \"3\", \"\"]", "UPGRADE_OPT = {", "    'BMC': '1',", "    'BIOS': '2',", "    'SWITCH_CPLD': '4',", "    'BASE_CPLD': '4'", "}"]}, {"diff": "\n \n     def __get_bmc_ver(self):\n         bmc_ver = \"Unknown\"\n-        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD)\n+        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD1, BMC_VER_CMD2)\n         if status:\n             bmc_ver_data = raw_bmc_data.split(\":\")\n             bmc_ver = bmc_ver_data[-1].strip() if len(\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py", "badparts": ["        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD)"], "goodparts": ["        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD1, BMC_VER_CMD2)"]}, {"diff": "\n         Returns:\n             A boolean, True if install successfully, False if not\n         \"\"\"\n-        install_command = {\n-            \"BMC\": CFUFLASH_FW_UPGRADE_CMD.format(BMC_UPGRADE_OPT, image_path),\n-            \"BIOS\": CFUFLASH_FW_UPGRADE_CMD.format(BIOS__UPGRADE_OPT, image_path),\n-            \"SWITCH_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path),\n-            \"BASE_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path)\n-        }.get(self.name, None)\n-\n-        if not os.path.isfile(image_path) or install_command is None:\n+        CFUFLASH_FW_UPGRADE_CMD[3] = UPGRADE_OPT.get(self.name)\n+        CFUFLASH_FW_UPGRADE_CMD[6] = image_path\n+\n+        if not os.path.isfile(image_path):\n             return False\n \n         # print(install_command)\n-        status = self._api_helper.run_interactive_command(install_command)\n+        status = self._api_helper.run_interactive_command(CFUFLASH_FW_UPGRADE_CMD)\n         ", "add": 5, "remove": 9, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/component.py", "badparts": ["        install_command = {", "            \"BMC\": CFUFLASH_FW_UPGRADE_CMD.format(BMC_UPGRADE_OPT, image_path),", "            \"BIOS\": CFUFLASH_FW_UPGRADE_CMD.format(BIOS__UPGRADE_OPT, image_path),", "            \"SWITCH_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path),", "            \"BASE_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path)", "        }.get(self.name, None)", "        if not os.path.isfile(image_path) or install_command is None:", "        status = self._api_helper.run_interactive_command(install_command)"], "goodparts": ["        CFUFLASH_FW_UPGRADE_CMD[3] = UPGRADE_OPT.get(self.name)", "        CFUFLASH_FW_UPGRADE_CMD[6] = image_path", "        if not os.path.isfile(image_path):", "        status = self._api_helper.run_interactive_command(CFUFLASH_FW_UPGRADE_CMD)"]}], "source": "\n import json import os.path try: from sonic_platform_base.component_base import ComponentBase from.helper import APIHelper except ImportError as e: raise ImportError(str(e) +\"-required module not found\") COMPONENT_LIST=[ (\"BIOS\", \"Basic Input/Output System\"), (\"BMC\", \"Baseboard Management Controller\"), (\"SWITCH_CPLD\", \"Switch board CPLD\"), (\"BASE_CPLD\", \"Base board CPLD\"), (\"FPGA\", \"Field-programmable gate array\") ] SW_CPLD_VER_PATH=\"/sys/module/switch_cpld/version\" BASE_CPLD_VER_PATH=\"/sys/module/baseboard_lpc/version\" CPLD_UPGRADE_OPT=4 BIOS_VER_PATH=\"/sys/class/dmi/id/bios_version\" BIOS__UPGRADE_OPT=2 BMC_VER_CMD=\"ipmitool mc info | grep 'Firmware Revision'\" BMC_UPGRADE_OPT=1 CFUFLASH_FW_UPGRADE_CMD=\"CFUFLASH -cd -d{} -mse 3{}\" MEM_PCI_RESOURCE=\"/sys/bus/pci/devices/0000:09:00.0/resource0\" FPGA_VER_MEM_OFFSET=0 class Component(ComponentBase): \"\"\"Platform-specific Component class\"\"\" DEVICE_TYPE=\"component\" def __init__(self, component_index): ComponentBase.__init__(self) self.index=component_index self.name=self.get_name() self._api_helper=APIHelper() def __get_bmc_ver(self): bmc_ver=\"Unknown\" status, raw_bmc_data=self._api_helper.run_command(BMC_VER_CMD) if status: bmc_ver_data=raw_bmc_data.split(\":\") bmc_ver=bmc_ver_data[-1].strip() if len( bmc_ver_data) > 1 else bmc_ver return bmc_ver def __get_fpga_ver(self): fpga_ver=\"Unknown\" status, reg_val=self._api_helper.pci_get_value( MEM_PCI_RESOURCE, FPGA_VER_MEM_OFFSET) if status: major=reg_val[0] >> 16 minor=int(bin(reg_val[0])[16:32], 2) fpga_ver='{}.{}'.format(major, minor) return fpga_ver def get_name(self): \"\"\" Retrieves the name of the component Returns: A string containing the name of the component \"\"\" return COMPONENT_LIST[self.index][0] def get_description(self): \"\"\" Retrieves the description of the component Returns: A string containing the description of the component \"\"\" return COMPONENT_LIST[self.index][1] def get_firmware_version(self): \"\"\" Retrieves the firmware version of module Returns: string: The firmware versions of the module \"\"\" fw_version={ \"BIOS\": self._api_helper.read_txt_file(BIOS_VER_PATH), \"BMC\": self.__get_bmc_ver(), \"FPGA\": self.__get_fpga_ver(), \"SWITCH_CPLD\": self._api_helper.read_txt_file(SW_CPLD_VER_PATH), \"BASE_CPLD\": self._api_helper.read_txt_file(BASE_CPLD_VER_PATH), }.get(self.name, \"Unknown\") return fw_version def install_firmware(self, image_path): \"\"\" Install firmware to module Args: image_path: A string, path to firmware image Returns: A boolean, True if install successfully, False if not \"\"\" install_command={ \"BMC\": CFUFLASH_FW_UPGRADE_CMD.format(BMC_UPGRADE_OPT, image_path), \"BIOS\": CFUFLASH_FW_UPGRADE_CMD.format(BIOS__UPGRADE_OPT, image_path), \"SWITCH_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path), \"BASE_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path) }.get(self.name, None) if not os.path.isfile(image_path) or install_command is None: return False status=self._api_helper.run_interactive_command(install_command) return status ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Component contains an implementation of SONiC Platform Base API and\n# provides the components firmware management function\n#\n#############################################################################\n\nimport json\nimport os.path\n\ntry:\n    from sonic_platform_base.component_base import ComponentBase\n    from .helper import APIHelper\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nCOMPONENT_LIST = [\n    (\"BIOS\",        \"Basic Input/Output System\"),\n    (\"BMC\",         \"Baseboard Management Controller\"),\n    (\"SWITCH_CPLD\", \"Switch board CPLD\"),\n    (\"BASE_CPLD\",   \"Base board CPLD\"),\n    (\"FPGA\",        \"Field-programmable gate array\")\n]\nSW_CPLD_VER_PATH = \"/sys/module/switch_cpld/version\"\nBASE_CPLD_VER_PATH = \"/sys/module/baseboard_lpc/version\"\nCPLD_UPGRADE_OPT = 4\nBIOS_VER_PATH = \"/sys/class/dmi/id/bios_version\"\nBIOS__UPGRADE_OPT = 2\nBMC_VER_CMD = \"ipmitool mc info | grep 'Firmware Revision'\"\nBMC_UPGRADE_OPT = 1\nCFUFLASH_FW_UPGRADE_CMD = \"CFUFLASH -cd -d {} -mse 3 {}\"\nMEM_PCI_RESOURCE = \"/sys/bus/pci/devices/0000:09:00.0/resource0\"\nFPGA_VER_MEM_OFFSET = 0\n\n\nclass Component(ComponentBase):\n    \"\"\"Platform-specific Component class\"\"\"\n\n    DEVICE_TYPE = \"component\"\n\n    def __init__(self, component_index):\n        ComponentBase.__init__(self)\n        self.index = component_index\n        self.name = self.get_name()\n        self._api_helper = APIHelper()\n\n    def __get_bmc_ver(self):\n        bmc_ver = \"Unknown\"\n        status, raw_bmc_data = self._api_helper.run_command(BMC_VER_CMD)\n        if status:\n            bmc_ver_data = raw_bmc_data.split(\":\")\n            bmc_ver = bmc_ver_data[-1].strip() if len(\n                bmc_ver_data) > 1 else bmc_ver\n        return bmc_ver\n\n    def __get_fpga_ver(self):\n        fpga_ver = \"Unknown\"\n        status, reg_val = self._api_helper.pci_get_value(\n            MEM_PCI_RESOURCE, FPGA_VER_MEM_OFFSET)\n        if status:\n            major = reg_val[0] >> 16\n            minor = int(bin(reg_val[0])[16:32], 2)\n            fpga_ver = '{}.{}'.format(major, minor)\n        return fpga_ver\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the component\n         Returns:\n            A string containing the name of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][0]\n\n    def get_description(self):\n        \"\"\"\n        Retrieves the description of the component\n            Returns:\n            A string containing the description of the component\n        \"\"\"\n        return COMPONENT_LIST[self.index][1]\n\n    def get_firmware_version(self):\n        \"\"\"\n        Retrieves the firmware version of module\n        Returns:\n            string: The firmware versions of the module\n        \"\"\"\n        fw_version = {\n            \"BIOS\": self._api_helper.read_txt_file(BIOS_VER_PATH),\n            \"BMC\": self.__get_bmc_ver(),\n            \"FPGA\": self.__get_fpga_ver(),\n            \"SWITCH_CPLD\": self._api_helper.read_txt_file(SW_CPLD_VER_PATH),\n            \"BASE_CPLD\": self._api_helper.read_txt_file(BASE_CPLD_VER_PATH),\n        }.get(self.name, \"Unknown\")\n\n        return fw_version\n\n    def install_firmware(self, image_path):\n        \"\"\"\n        Install firmware to module\n        Args:\n            image_path: A string, path to firmware image\n        Returns:\n            A boolean, True if install successfully, False if not\n        \"\"\"\n        install_command = {\n            \"BMC\": CFUFLASH_FW_UPGRADE_CMD.format(BMC_UPGRADE_OPT, image_path),\n            \"BIOS\": CFUFLASH_FW_UPGRADE_CMD.format(BIOS__UPGRADE_OPT, image_path),\n            \"SWITCH_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path),\n            \"BASE_CPLD\": CFUFLASH_FW_UPGRADE_CMD.format(CPLD_UPGRADE_OPT, image_path)\n        }.get(self.name, None)\n\n        if not os.path.isfile(image_path) or install_command is None:\n            return False\n\n        # print(install_command)\n        status = self._api_helper.run_interactive_command(install_command)\n        return status\n"}, "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py": {"changes": [{"diff": "\n import struct\n import subprocess\n from mmap import *\n+from sonic_py_common.general import check_output_pipe\n \n-HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+HOST_CHK_CMD = [\"docker\"]\n EMPTY_STRING = \"\"\n \n \n", "add": 2, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py", "badparts": ["HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["from sonic_py_common.general import check_output_pipe", "HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n         pass\n \n     def is_host(self):\n-        return os.system(HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def pci_get_value(self, resource, offset):\n         status = True\n", "add": 5, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py", "badparts": ["        return os.system(HOST_CHK_CMD) == 0"], "goodparts": ["        try:", "            subprocess.call(HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)", "        except FileNotFoundError:", "            return False", "        return True"]}, {"diff": "\n             status = False\n         return status, result\n \n-    def run_command(self, cmd):\n+    def run_command(self, cmd1_args, cmd2_args):\n         status = True\n         result = \"\"\n         try:\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-        except:\n+            result = check_output_pipe(cmd1_args, cmd2_args)\n+        except subprocess.CalledProcessError:\n             status = False\n         return status, result\n \n     def run_interactive_command(self, cmd):\n         try:\n-            os.system(cmd)\n+            subprocess.call(cmd)\n         except:\n             return False\n         return True\n", "add": 4, "remove": 8, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py", "badparts": ["    def run_command(self, cmd):", "            p = subprocess.Popen(", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "        except:", "            os.system(cmd)"], "goodparts": ["    def run_command(self, cmd1_args, cmd2_args):", "            result = check_output_pipe(cmd1_args, cmd2_args)", "        except subprocess.CalledProcessError:", "            subprocess.call(cmd)"]}, {"diff": "\n         status = True\n         result = \"\"\n         try:\n-            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n+            cmd = [\"ipmitool\", \"raw\", str(netfn), str(cmd)]\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = raw_data.strip()\n", "add": 2, "remove": 2, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py", "badparts": ["            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"], "goodparts": ["            cmd = [\"ipmitool\", \"raw\", str(netfn), str(cmd)]", "                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"]}, {"diff": "\n     def ipmi_fru_id(self, id, key=None):\n         status = True\n         result = \"\"\n-        try:\n-            cmd = \"ipmitool fru print {}\".format(str(\n-                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n-\n-            p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-            raw_data, err = p.communicate()\n-            if err == '':\n-                result = raw_data.strip()\n-            else:\n+        cmd1_args = [\"ipmitool\", \"fru\", \"print\", str(id)]\n+        if not key:\n+            try:\n+                p = subprocess.Popen(\n+                    cmd1_args, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                raw_data, err = p.communicate()\n+                if err == '':\n+                    result = raw_data.strip()\n+                else:\n+                    status = False\n+            except:\n                 status = False\n-        except:\n-            status = False\n+        else:\n+            cmd2_args = [\"grep\", str(key)]\n+            status, result = self.run_command(cmd1_args, cmd2_args)\n         return status, result\n \n     def ipmi_set_ss_thres(self, id, threshold_key, value):\n         status = True\n         result = \"\"\n         try:\n-            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n+            cmd = [\"ipmitool\", \"sensor\", \"thresh\", str(id), str(threshold_key), str(value)]\n             p = subprocess.Popen(\n-                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n             raw_data, err = p.communicate()\n             if err == '':\n                 result = ra", "add": 16, "remove": 14, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/helper.py", "badparts": ["        try:", "            cmd = \"ipmitool fru print {}\".format(str(", "                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))", "            p = subprocess.Popen(", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "            raw_data, err = p.communicate()", "            if err == '':", "                result = raw_data.strip()", "            else:", "        except:", "            status = False", "            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))", "                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"], "goodparts": ["        cmd1_args = [\"ipmitool\", \"fru\", \"print\", str(id)]", "        if not key:", "            try:", "                p = subprocess.Popen(", "                    cmd1_args, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "                raw_data, err = p.communicate()", "                if err == '':", "                    result = raw_data.strip()", "                else:", "                    status = False", "            except:", "        else:", "            cmd2_args = [\"grep\", str(key)]", "            status, result = self.run_command(cmd1_args, cmd2_args)", "            cmd = [\"ipmitool\", \"sensor\", \"thresh\", str(id), str(threshold_key), str(value)]", "                cmd, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)"]}], "source": "\nimport os import struct import subprocess from mmap import * HOST_CHK_CMD=\"docker > /dev/null 2>&1\" EMPTY_STRING=\"\" class APIHelper(): def __init__(self): pass def is_host(self): return os.system(HOST_CHK_CMD)==0 def pci_get_value(self, resource, offset): status=True result=\"\" try: fd=os.open(resource, os.O_RDWR) mm=mmap(fd, 0) mm.seek(int(offset)) read_data_stream=mm.read(4) result=struct.unpack('I', read_data_stream) except: status=False return status, result def run_command(self, cmd): status=True result=\"\" try: p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() except: status=False return status, result def run_interactive_command(self, cmd): try: os.system(cmd) except: return False return True def read_txt_file(self, file_path): try: with open(file_path, 'r') as fd: data=fd.read() return data.strip() except IOError: pass return None def ipmi_raw(self, netfn, cmd): status=True result=\"\" try: cmd=\"ipmitool raw{}{}\".format(str(netfn), str(cmd)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result def ipmi_fru_id(self, id, key=None): status=True result=\"\" try: cmd=\"ipmitool fru print{}\".format(str( id)) if not key else \"ipmitool fru print{0} | grep '{1}' \".format(str(id), str(key)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result def ipmi_set_ss_thres(self, id, threshold_key, value): status=True result=\"\" try: cmd=\"ipmitool sensor thresh '{}'{}{}\".format(str(id), str(threshold_key), str(value)) p=subprocess.Popen( cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': result=raw_data.strip() else: status=False except: status=False return status, result ", "sourceWithComments": "import os\nimport struct\nimport subprocess\nfrom mmap import *\n\nHOST_CHK_CMD = \"docker > /dev/null 2>&1\"\nEMPTY_STRING = \"\"\n\n\nclass APIHelper():\n\n    def __init__(self):\n        pass\n\n    def is_host(self):\n        return os.system(HOST_CHK_CMD) == 0\n\n    def pci_get_value(self, resource, offset):\n        status = True\n        result = \"\"\n        try:\n            fd = os.open(resource, os.O_RDWR)\n            mm = mmap(fd, 0)\n            mm.seek(int(offset))\n            read_data_stream = mm.read(4)\n            result = struct.unpack('I', read_data_stream)\n        except:\n            status = False\n        return status, result\n\n    def run_command(self, cmd):\n        status = True\n        result = \"\"\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n        except:\n            status = False\n        return status, result\n\n    def run_interactive_command(self, cmd):\n        try:\n            os.system(cmd)\n        except:\n            return False\n        return True\n\n    def read_txt_file(self, file_path):\n        try:\n            with open(file_path, 'r') as fd:\n                data = fd.read()\n                return data.strip()\n        except IOError:\n            pass\n        return None\n\n    def ipmi_raw(self, netfn, cmd):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool raw {} {}\".format(str(netfn), str(cmd))\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n\n    def ipmi_fru_id(self, id, key=None):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool fru print {}\".format(str(\n                id)) if not key else \"ipmitool fru print {0} | grep '{1}' \".format(str(id), str(key))\n\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n\n    def ipmi_set_ss_thres(self, id, threshold_key, value):\n        status = True\n        result = \"\"\n        try:\n            cmd = \"ipmitool sensor thresh '{}' {} {}\".format(str(id), str(threshold_key), str(value))\n            p = subprocess.Popen(\n                cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                result = raw_data.strip()\n            else:\n                status = False\n        except:\n            status = False\n        return status, result\n"}, "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py": {"changes": [{"diff": "\n PSU_LED_GREEN_CMD = \"0x01\"\n PSU_LED_AMBER_CMD = \"0x02\"\n \n-PSU1_VOUT_SS_ID = \"0x36\"\n-PSU1_COUT_SS_ID = \"0x37\"\n-PSU1_POUT_SS_ID = \"0x38\"\n-PSU1_STATUS_REG = \"0x39\"\n-\n-PSU2_VOUT_SS_ID = \"0x40\"\n-PSU2_COUT_SS_ID = \"0x41\"\n-PSU2_POUT_SS_ID = \"0x42\"\n-PSU2_STATUS_REG = \"0x2f\"\n-\n PSU1_FRU_ID = 3\n \n SS_READ_OFFSET = 0\n \n+PSU_VOUT_SS_ID = [\"0x36\", \"0x40\"]\n+PSU_COUT_SS_ID = [\"0x37\", \"0x41\"]\n+PSU_POUT_SS_ID = [\"0x38\", \"0x42\"]\n+PSU_STATUS_REG = [\"0x39\", \"0x2f\"]\n+\n \n class Psu(PsuBase):\n     \"\"\"Platform-specific Psu class\"\"\"\n", "add": 5, "remove": 10, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["PSU1_VOUT_SS_ID = \"0x36\"", "PSU1_COUT_SS_ID = \"0x37\"", "PSU1_POUT_SS_ID = \"0x38\"", "PSU1_STATUS_REG = \"0x39\"", "PSU2_VOUT_SS_ID = \"0x40\"", "PSU2_COUT_SS_ID = \"0x41\"", "PSU2_POUT_SS_ID = \"0x42\"", "PSU2_STATUS_REG = \"0x2f\""], "goodparts": ["PSU_VOUT_SS_ID = [\"0x36\", \"0x40\"]", "PSU_COUT_SS_ID = [\"0x37\", \"0x41\"]", "PSU_POUT_SS_ID = [\"0x38\", \"0x42\"]", "PSU_STATUS_REG = [\"0x39\", \"0x2f\"]"]}, {"diff": "\n             e.g. 12.1\n         \"\"\"\n         psu_voltage = 0.0\n-        psu_vout_key = globals()['PSU{}_VOUT_SS_ID'.format(self.index+1)]\n+        psu_vout_key = PSU_VOUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_vout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["        psu_vout_key = globals()['PSU{}_VOUT_SS_ID'.format(self.index+1)]"], "goodparts": ["        psu_vout_key = PSU_VOUT_SS_ID[self.index]"]}, {"diff": "\n             A float number, the electric current in amperes, e.g 15.4\n         \"\"\"\n         psu_current = 0.0\n-        psu_cout_key = globals()['PSU{}_COUT_SS_ID'.format(self.index+1)]\n+        psu_cout_key = PSU_COUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_cout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["        psu_cout_key = globals()['PSU{}_COUT_SS_ID'.format(self.index+1)]"], "goodparts": ["        psu_cout_key = PSU_COUT_SS_ID[self.index]"]}, {"diff": "\n             A float number, the power in watts, e.g. 302.6\n         \"\"\"\n         psu_power = 0.0\n-        psu_pout_key = globals()['PSU{}_POUT_SS_ID'.format(self.index+1)]\n+        psu_pout_key = PSU_POUT_SS_ID[self.index]\n         status, raw_ss_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pout_key))\n         ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["        psu_pout_key = globals()['PSU{}_POUT_SS_ID'.format(self.index+1)]"], "goodparts": ["        psu_pout_key = PSU_POUT_SS_ID[self.index]"]}, {"diff": "\n             bool: True if PSU is present, False if not\n         \"\"\"\n         psu_presence = False\n-        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n+        psu_pstatus_key = PSU_STATUS_REG[self.index]\n         status, raw_status_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n         status_byte = self.find_value(raw_status_read)\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]"], "goodparts": ["        psu_pstatus_key = PSU_STATUS_REG[self.index]"]}, {"diff": "\n             A boolean value, True if device is operating properly, False if not\n         \"\"\"\n         psu_status = False\n-        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n+        psu_pstatus_key = PSU_STATUS_REG[self.index]\n         status, raw_status_read = self._api_helper.ipmi_raw(\n             IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n         status_byte = self.find_value(r", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/psu.py", "badparts": ["        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]"], "goodparts": ["        psu_pstatus_key = PSU_STATUS_REG[self.index]"]}], "source": "\n import os import re import math import sonic_platform try: from sonic_platform_base.psu_base import PsuBase from.helper import APIHelper from sonic_platform.fan import Fan except ImportError as e: raise ImportError(str(e) +\"-required module not found\") PSU_NAME_LIST=[\"PSU-1\", \"PSU-2\"] PSU_NUM_FAN=[1, 1] IPMI_SENSOR_NETFN=\"0x04\" IPMI_OEM_NETFN=\"0x3A\" IPMI_SS_READ_CMD=\"0x2D{}\" IPMI_SET_PSU_LED_CMD=\"0x07 0x02{}\" IPMI_GET_PSU_LED_CMD=\"0x08 0x02\" IPMI_FRU_MODEL_KEY=\"Board Part Number\" IPMI_FRU_SERIAL_KEY=\"Board Serial\" PSU_LED_OFF_CMD=\"0x00\" PSU_LED_GREEN_CMD=\"0x01\" PSU_LED_AMBER_CMD=\"0x02\" PSU1_VOUT_SS_ID=\"0x36\" PSU1_COUT_SS_ID=\"0x37\" PSU1_POUT_SS_ID=\"0x38\" PSU1_STATUS_REG=\"0x39\" PSU2_VOUT_SS_ID=\"0x40\" PSU2_COUT_SS_ID=\"0x41\" PSU2_POUT_SS_ID=\"0x42\" PSU2_STATUS_REG=\"0x2f\" PSU1_FRU_ID=3 SS_READ_OFFSET=0 class Psu(PsuBase): \"\"\"Platform-specific Psu class\"\"\" def __init__(self, psu_index): PsuBase.__init__(self) self.index=psu_index for fan_index in range(0, PSU_NUM_FAN[self.index]): fan=Fan(fan_index, 0, is_psu_fan=True, psu_index=self.index) self._fan_list.append(fan) self._api_helper=APIHelper() def find_value(self, in_string): result=re.search(\"^.+([0-9a-f]{2}).+$\", in_string) return result.group(1) if result else result def get_voltage(self): \"\"\" Retrieves current PSU voltage output Returns: A float number, the output voltage in volts, e.g. 12.1 \"\"\" psu_voltage=0.0 psu_vout_key=globals()['PSU{}_VOUT_SS_ID'.format(self.index+1)] status, raw_ss_read=self._api_helper.ipmi_raw( IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_vout_key)) ss_read=raw_ss_read.split()[SS_READ_OFFSET] psu_voltage=int(ss_read, 16) * math.pow(10, -1) return psu_voltage def get_current(self): \"\"\" Retrieves present electric current supplied by PSU Returns: A float number, the electric current in amperes, e.g 15.4 \"\"\" psu_current=0.0 psu_cout_key=globals()['PSU{}_COUT_SS_ID'.format(self.index+1)] status, raw_ss_read=self._api_helper.ipmi_raw( IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_cout_key)) ss_read=raw_ss_read.split()[SS_READ_OFFSET] psu_current=int(ss_read, 16) * 5 * math.pow(10, -1) return psu_current def get_power(self): \"\"\" Retrieves current energy supplied by PSU Returns: A float number, the power in watts, e.g. 302.6 \"\"\" psu_power=0.0 psu_pout_key=globals()['PSU{}_POUT_SS_ID'.format(self.index+1)] status, raw_ss_read=self._api_helper.ipmi_raw( IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pout_key)) ss_read=raw_ss_read.split()[SS_READ_OFFSET] psu_power=int(ss_read, 16) * 6 return psu_power def get_powergood_status(self): \"\"\" Retrieves the powergood status of PSU Returns: A boolean, True if PSU has stablized its output voltages and passed all its internal self-tests, False if not. \"\"\" return self.get_status() def set_status_led(self, color): \"\"\" Sets the state of the PSU status LED Args: color: A string representing the color with which to set the PSU status LED Note: Only support green and off Returns: bool: True if status LED state is set successfully, False if not Note Set manual ipmitool raw 0x3a 0x09 0x2 0x0 \"\"\" led_cmd={ self.STATUS_LED_COLOR_GREEN: PSU_LED_GREEN_CMD, self.STATUS_LED_COLOR_AMBER: PSU_LED_AMBER_CMD, self.STATUS_LED_COLOR_OFF: PSU_LED_OFF_CMD }.get(color) status, set_led=self._api_helper.ipmi_raw( IPMI_OEM_NETFN, IPMI_SET_PSU_LED_CMD.format(led_cmd)) set_status_led=False if not status else True return set_status_led def get_status_led(self): \"\"\" Gets the state of the PSU status LED Returns: A string, one of the predefined STATUS_LED_COLOR_* strings above \"\"\" status, hx_color=self._api_helper.ipmi_raw( IPMI_OEM_NETFN, IPMI_GET_PSU_LED_CMD) status_led={ \"00\": self.STATUS_LED_COLOR_OFF, \"01\": self.STATUS_LED_COLOR_GREEN, \"02\": self.STATUS_LED_COLOR_AMBER, }.get(hx_color, self.STATUS_LED_COLOR_OFF) return status_led def get_name(self): \"\"\" Retrieves the name of the device Returns: string: The name of the device \"\"\" return PSU_NAME_LIST[self.index] def get_presence(self): \"\"\" Retrieves the presence of the PSU Returns: bool: True if PSU is present, False if not \"\"\" psu_presence=False psu_pstatus_key=globals()['PSU{}_STATUS_REG'.format(self.index+1)] status, raw_status_read=self._api_helper.ipmi_raw( IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key)) status_byte=self.find_value(raw_status_read) if status: presence_int=(int(status_byte, 16) >> 0) & 1 psu_presence=True if presence_int else False return psu_presence def get_model(self): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" model=\"Unknown\" ipmi_fru_idx=self.index +PSU1_FRU_ID status, raw_model=self._api_helper.ipmi_fru_id( ipmi_fru_idx, IPMI_FRU_MODEL_KEY) fru_pn_list=raw_model.split() if len(fru_pn_list) > 4: model=fru_pn_list[4] return model def get_serial(self): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" serial=\"Unknown\" ipmi_fru_idx=self.index +PSU1_FRU_ID status, raw_model=self._api_helper.ipmi_fru_id( ipmi_fru_idx, IPMI_FRU_SERIAL_KEY) fru_sr_list=raw_model.split() if len(fru_sr_list) > 3: serial=fru_sr_list[3] return serial def get_status(self): \"\"\" Retrieves the operational status of the device Returns: A boolean value, True if device is operating properly, False if not \"\"\" psu_status=False psu_pstatus_key=globals()['PSU{}_STATUS_REG'.format(self.index+1)] status, raw_status_read=self._api_helper.ipmi_raw( IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key)) status_byte=self.find_value(raw_status_read) if status: failure_detected=(int(status_byte, 16) >> 1) & 1 input_lost=(int(status_byte, 16) >> 3) & 1 psu_status=False if(input_lost or failure_detected) else True return psu_status ", "sourceWithComments": "#############################################################################\n# Celestica\n#\n# Module contains an implementation of SONiC Platform Base API and\n# provides the PSUs status which are available in the platform\n#\n#############################################################################\n\nimport os\nimport re\nimport math\nimport sonic_platform\n\ntry:\n    from sonic_platform_base.psu_base import PsuBase\n    from .helper import APIHelper\n    from sonic_platform.fan import Fan\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\nPSU_NAME_LIST = [\"PSU-1\", \"PSU-2\"]\nPSU_NUM_FAN = [1, 1]\n\nIPMI_SENSOR_NETFN = \"0x04\"\nIPMI_OEM_NETFN = \"0x3A\"\nIPMI_SS_READ_CMD = \"0x2D {}\"\nIPMI_SET_PSU_LED_CMD = \"0x07 0x02 {}\"\nIPMI_GET_PSU_LED_CMD = \"0x08 0x02\"\nIPMI_FRU_MODEL_KEY = \"Board Part Number\"\nIPMI_FRU_SERIAL_KEY = \"Board Serial\"\n\nPSU_LED_OFF_CMD = \"0x00\"\nPSU_LED_GREEN_CMD = \"0x01\"\nPSU_LED_AMBER_CMD = \"0x02\"\n\nPSU1_VOUT_SS_ID = \"0x36\"\nPSU1_COUT_SS_ID = \"0x37\"\nPSU1_POUT_SS_ID = \"0x38\"\nPSU1_STATUS_REG = \"0x39\"\n\nPSU2_VOUT_SS_ID = \"0x40\"\nPSU2_COUT_SS_ID = \"0x41\"\nPSU2_POUT_SS_ID = \"0x42\"\nPSU2_STATUS_REG = \"0x2f\"\n\nPSU1_FRU_ID = 3\n\nSS_READ_OFFSET = 0\n\n\nclass Psu(PsuBase):\n    \"\"\"Platform-specific Psu class\"\"\"\n\n    def __init__(self, psu_index):\n        PsuBase.__init__(self)\n        self.index = psu_index\n        for fan_index in range(0, PSU_NUM_FAN[self.index]):\n            fan = Fan(fan_index, 0, is_psu_fan=True, psu_index=self.index)\n            self._fan_list.append(fan)\n        self._api_helper = APIHelper()\n\n    def find_value(self, in_string):\n        result = re.search(\"^.+ ([0-9a-f]{2}) .+$\", in_string)\n        return result.group(1) if result else result\n\n    def get_voltage(self):\n        \"\"\"\n        Retrieves current PSU voltage output\n        Returns:\n            A float number, the output voltage in volts,\n            e.g. 12.1\n        \"\"\"\n        psu_voltage = 0.0\n        psu_vout_key = globals()['PSU{}_VOUT_SS_ID'.format(self.index+1)]\n        status, raw_ss_read = self._api_helper.ipmi_raw(\n            IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_vout_key))\n        ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n        # Formula: Rx1x10^-1\n        psu_voltage = int(ss_read, 16) * math.pow(10, -1)\n\n        return psu_voltage\n\n    def get_current(self):\n        \"\"\"\n        Retrieves present electric current supplied by PSU\n        Returns:\n            A float number, the electric current in amperes, e.g 15.4\n        \"\"\"\n        psu_current = 0.0\n        psu_cout_key = globals()['PSU{}_COUT_SS_ID'.format(self.index+1)]\n        status, raw_ss_read = self._api_helper.ipmi_raw(\n            IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_cout_key))\n        ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n        # Formula: Rx5x10^-1\n        psu_current = int(ss_read, 16) * 5 * math.pow(10, -1)\n\n        return psu_current\n\n    def get_power(self):\n        \"\"\"\n        Retrieves current energy supplied by PSU\n        Returns:\n            A float number, the power in watts, e.g. 302.6\n        \"\"\"\n        psu_power = 0.0\n        psu_pout_key = globals()['PSU{}_POUT_SS_ID'.format(self.index+1)]\n        status, raw_ss_read = self._api_helper.ipmi_raw(\n            IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pout_key))\n        ss_read = raw_ss_read.split()[SS_READ_OFFSET]\n        # Formula: Rx6x10^0\n        psu_power = int(ss_read, 16) * 6\n        return psu_power\n\n    def get_powergood_status(self):\n        \"\"\"\n        Retrieves the powergood status of PSU\n        Returns:\n            A boolean, True if PSU has stablized its output voltages and passed all\n            its internal self-tests, False if not.\n        \"\"\"\n        return self.get_status()\n\n    def set_status_led(self, color):\n        \"\"\"\n        Sets the state of the PSU status LED\n        Args:\n            color: A string representing the color with which to set the PSU status LED\n                   Note: Only support green and off\n        Returns:\n            bool: True if status LED state is set successfully, False if not\n        Note\n            Set manual\n            ipmitool raw 0x3a 0x09 0x2 0x0\n        \"\"\"\n        led_cmd = {\n            self.STATUS_LED_COLOR_GREEN: PSU_LED_GREEN_CMD,\n            self.STATUS_LED_COLOR_AMBER: PSU_LED_AMBER_CMD,\n            self.STATUS_LED_COLOR_OFF: PSU_LED_OFF_CMD\n        }.get(color)\n\n        status, set_led = self._api_helper.ipmi_raw(\n            IPMI_OEM_NETFN, IPMI_SET_PSU_LED_CMD.format(led_cmd))\n        set_status_led = False if not status else True\n\n        return set_status_led\n\n    def get_status_led(self):\n        \"\"\"\n        Gets the state of the PSU status LED\n        Returns:\n            A string, one of the predefined STATUS_LED_COLOR_* strings above\n        \"\"\"\n        status, hx_color = self._api_helper.ipmi_raw(\n            IPMI_OEM_NETFN, IPMI_GET_PSU_LED_CMD)\n\n        status_led = {\n            \"00\": self.STATUS_LED_COLOR_OFF,\n            \"01\": self.STATUS_LED_COLOR_GREEN,\n            \"02\": self.STATUS_LED_COLOR_AMBER,\n        }.get(hx_color, self.STATUS_LED_COLOR_OFF)\n\n        return status_led\n\n    def get_name(self):\n        \"\"\"\n        Retrieves the name of the device\n            Returns:\n            string: The name of the device\n        \"\"\"\n        return PSU_NAME_LIST[self.index]\n\n    def get_presence(self):\n        \"\"\"\n        Retrieves the presence of the PSU\n        Returns:\n            bool: True if PSU is present, False if not\n        \"\"\"\n        psu_presence = False\n        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n        status, raw_status_read = self._api_helper.ipmi_raw(\n            IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n        status_byte = self.find_value(raw_status_read)\n\n        if status:\n            presence_int = (int(status_byte, 16) >> 0) & 1\n            psu_presence = True if presence_int else False\n\n        return psu_presence\n\n    def get_model(self):\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        model = \"Unknown\"\n        ipmi_fru_idx = self.index + PSU1_FRU_ID\n        status, raw_model = self._api_helper.ipmi_fru_id(\n            ipmi_fru_idx, IPMI_FRU_MODEL_KEY)\n\n        fru_pn_list = raw_model.split()\n        if len(fru_pn_list) > 4:\n            model = fru_pn_list[4]\n\n        return model\n\n    def get_serial(self):\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        serial = \"Unknown\"\n        ipmi_fru_idx = self.index + PSU1_FRU_ID\n        status, raw_model = self._api_helper.ipmi_fru_id(\n            ipmi_fru_idx, IPMI_FRU_SERIAL_KEY)\n\n        fru_sr_list = raw_model.split()\n        if len(fru_sr_list) > 3:\n            serial = fru_sr_list[3]\n\n        return serial\n\n    def get_status(self):\n        \"\"\"\n        Retrieves the operational status of the device\n        Returns:\n            A boolean value, True if device is operating properly, False if not\n        \"\"\"\n        psu_status = False\n        psu_pstatus_key = globals()['PSU{}_STATUS_REG'.format(self.index+1)]\n        status, raw_status_read = self._api_helper.ipmi_raw(\n            IPMI_SENSOR_NETFN, IPMI_SS_READ_CMD.format(psu_pstatus_key))\n        status_byte = self.find_value(raw_status_read)\n\n        if status:\n            failure_detected = (int(status_byte, 16) >> 1) & 1\n            input_lost = (int(status_byte, 16) >> 3) & 1\n            psu_status = False if (input_lost or failure_detected) else True\n\n        return psu_status\n"}, "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py": {"changes": [{"diff": "\n     # Path to QSFP sysfs\n     PLATFORM_ROOT_PATH = \"/usr/share/sonic/device\"\n     PMON_HWSKU_PATH = \"/usr/share/sonic/hwsku\"\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n \n     PLATFORM = \"x86_64-cel_silverstone-r0\"\n     HWSKU = \"Silverstone\"\n", "add": 1, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n             return 'N/A'\n \n     def __is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def __get_path_to_port_config_file(self):\n         platform_path = \"/\".join([self.PLATFORM_ROOT_PATH,", "add": 5, "remove": 1, "filename": "/device/celestica/x86_64-cel_silverstone-r0/sonic_platform/sfp.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        try:", "            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)", "        except FileNotFoundError:", "            return False", "        return True"]}]}, "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py": {"changes": [{"diff": "\n #\r\n #############################################################################\r\n \r\n-import os.path\r\n import subprocess\r\n-import time\r\n-import os\r\n \r\n try:\r\n     from sonic_platform_base.component_base import ComponentBase\r\n+    from sonic_py_common.general import getstatusoutput_noshell_pipe\r\n     #from helper import APIHelper\r\n except ImportError as e:\r\n     raise ImportError(str(e) + \"- required module not found\")\r\n \r\n-SWCPLD_VERSION_PATH = \"i2cget -y -f 2 0x32 0\"\r\n-BIOS_VERSION_PATH = \"dmidecode -t bios | grep Version\"\r\n+SWCPLD_VERSION_PATH = [\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0\"]\r\n+BIOS_VERSION_PATH_CMD1 = [\"dmidecode\", \"-t\", \"bios\"]\r\n+BIOS_VERSION_PATH_CMD2 = [\"grep\", \"Version\"]\r\n COMPONENT_NAME_LIST = [\"SWCPLD\", \"Main_BIOS\", \"Backup_BIOS\"]\r\n COMPONENT_DES_LIST = [\"Use for boot control and BIOS switch\",\r\n                       \"Main basic Input/Output System\",\r\n", "add": 4, "remove": 5, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py", "badparts": ["import time\r", "SWCPLD_VERSION_PATH = \"i2cget -y -f 2 0x32 0\"\r", "BIOS_VERSION_PATH = \"dmidecode -t bios | grep Version\"\r"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell_pipe\r", "SWCPLD_VERSION_PATH = [\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0\"]\r", "BIOS_VERSION_PATH_CMD1 = [\"dmidecode\", \"-t\", \"bios\"]\r", "BIOS_VERSION_PATH_CMD2 = [\"grep\", \"Version\"]\r"]}, {"diff": "\n         self.name = self.get_name()\r\n \r\n     def run_command(self,cmd):\r\n-        responses = os.popen(cmd).read()\r\n+        responses = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()\r\n         return responses\r\n \r\n     def __get_bios_version(self):\r\n         # Retrieves the BIOS firmware version\r\n-        result = self.run_command(\"i2cget -y -f 2 0x32 0x19\")\r\n+        result = self.run_command([\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0x19\"])\r\n         if result.strip() == \"0x01\":\r\n             if self.name == \"Main_BIOS\":\r\n-                version = self.run_command(BIOS_VERSION_PATH)\r\n+                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r\n                 bios_version = version.strip().split(\" \")[1]\r\n                 return str(bios_version)\r\n             elif self.name == \"Backup_BIOS\":\r\n", "add": 3, "remove": 3, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py", "badparts": ["        responses = os.popen(cmd).read()\r", "        result = self.run_command(\"i2cget -y -f 2 0x32 0x19\")\r", "                version = self.run_command(BIOS_VERSION_PATH)\r"], "goodparts": ["        responses = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()\r", "        result = self.run_command([\"i2cget\", \"-y\", \"-f\", \"2\", \"0x32\", \"0x19\"])\r", "                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r"]}, {"diff": "\n                 \r\n         elif result.strip() == \"0x03\":\r\n             if self.name == \"Backup_BIOS\":\r\n-                version = self.run_command(BIOS_VERSION_PATH)\r\n+                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r\n                 bios_version = version.strip().split(\" \")[1]\r\n                 return str(bios_version)\r\n             elif self.name", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/component.py", "badparts": ["                version = self.run_command(BIOS_VERSION_PATH)\r"], "goodparts": ["                _, version = getstatusoutput_noshell_pipe(BIOS_VERSION_PATH_CMD1, BIOS_VERSION_PATH_CMD2)\r"]}], "source": "\n\n\r \r import os.path\r import subprocess\r import time\r import os\r \r try:\r from sonic_platform_base.component_base import ComponentBase\r except ImportError as e:\r raise ImportError(str(e) +\"-required module not found\")\r \r SWCPLD_VERSION_PATH=\"i2cget -y -f 2 0x32 0\"\r BIOS_VERSION_PATH=\"dmidecode -t bios | grep Version\"\r COMPONENT_NAME_LIST=[\"SWCPLD\", \"Main_BIOS\", \"Backup_BIOS\"]\r COMPONENT_DES_LIST=[\"Use for boot control and BIOS switch\",\r \"Main basic Input/Output System\",\r \"Backup basic Input/Output System\"]\r \r \r class Component(ComponentBase):\r \"\"\"Platform-specific Component class\"\"\"\r \r DEVICE_TYPE=\"component\"\r \r def __init__(self, component_index):\r ComponentBase.__init__(self)\r self.index=component_index\r self.name=self.get_name()\r \r def run_command(self,cmd):\r responses=os.popen(cmd).read()\r return responses\r \r def __get_bios_version(self):\r result=self.run_command(\"i2cget -y -f 2 0x32 0x19\")\r if result.strip()==\"0x01\":\r if self.name==\"Main_BIOS\":\r version=self.run_command(BIOS_VERSION_PATH)\r bios_version=version.strip().split(\" \")[1]\r return str(bios_version)\r elif self.name==\"Backup_BIOS\":\r bios_version=\"na\"\r return bios_version\r \r elif result.strip()==\"0x03\":\r if self.name==\"Backup_BIOS\":\r version=self.run_command(BIOS_VERSION_PATH)\r bios_version=version.strip().split(\" \")[1]\r return str(bios_version)\r elif self.name==\"Main_BIOS\":\r bios_version=\"na\"\r return bios_version\r \r def __get_cpld_version(self):\r if self.name==\"SWCPLD\":\r ver=self.run_command(SWCPLD_VERSION_PATH)\r print(\"ver is %s\" % ver)\r ver=ver.strip().split(\"x\")[1]\r print(\"ver2 is %s\" % ver)\r version=int(ver.strip()) / 10\r return str(version)\r \r \r def get_name(self):\r \"\"\"\r Retrieves the name of the component\r Returns:\r A string containing the name of the component\r \"\"\"\r return COMPONENT_NAME_LIST[self.index]\r \r def get_description(self):\r \"\"\"\r Retrieves the description of the component\r Returns:\r A string containing the description of the component\r \"\"\"\r return COMPONENT_DES_LIST[self.index]\r \r def get_firmware_version(self):\r \"\"\"\r Retrieves the firmware version of module\r Returns:\r string: The firmware versions of the module\r \"\"\"\r fw_version=None\r \r if \"BIOS\" in self.name:\r fw_version=self.__get_bios_version()\r elif \"CPLD\" in self.name:\r fw_version=self.__get_cpld_version()\r \r return fw_version\r \r def install_firmware(self, image_path):\r \"\"\"\r Install firmware to module\r Args:\r image_path: A string, path to firmware image\r Returns:\r A boolean, True if install successfully, False if not\r \"\"\"\r return False\r \r def update_firmware(self, image_path):\r return False\r \r def get_available_firmware_version(self, image_path):\r return 'N/A'\r \r def get_firmware_update_notification(self, image_path):\r return \"None\"\r \r def get_model(self):\r return 'N/A'\r \r def get_position_in_parent(self):\r return -1\r \r def get_presence(self):\r return True\r \r def get_serial(self):\r return 'N/A'\r \r def get_status(self):\r return True\r \r def is_replaceable(self):\r return False\r ", "sourceWithComments": "#!/usr/bin/env python\r\n\r\n#############################################################################\r\n# Celestica\r\n#\r\n# Component contains an implementation of SONiC Platform Base API and\r\n# provides the components firmware management function\r\n#\r\n#############################################################################\r\n\r\nimport os.path\r\nimport subprocess\r\nimport time\r\nimport os\r\n\r\ntry:\r\n    from sonic_platform_base.component_base import ComponentBase\r\n    #from helper import APIHelper\r\nexcept ImportError as e:\r\n    raise ImportError(str(e) + \"- required module not found\")\r\n\r\nSWCPLD_VERSION_PATH = \"i2cget -y -f 2 0x32 0\"\r\nBIOS_VERSION_PATH = \"dmidecode -t bios | grep Version\"\r\nCOMPONENT_NAME_LIST = [\"SWCPLD\", \"Main_BIOS\", \"Backup_BIOS\"]\r\nCOMPONENT_DES_LIST = [\"Use for boot control and BIOS switch\",\r\n                      \"Main basic Input/Output System\",\r\n                      \"Backup basic Input/Output System\"]\r\n\r\n\r\nclass Component(ComponentBase):\r\n    \"\"\"Platform-specific Component class\"\"\"\r\n\r\n    DEVICE_TYPE = \"component\"\r\n\r\n    def __init__(self, component_index):\r\n        ComponentBase.__init__(self)\r\n        self.index = component_index\r\n        #self._api_helper = APIHelper()\r\n        self.name = self.get_name()\r\n\r\n    def run_command(self,cmd):\r\n        responses = os.popen(cmd).read()\r\n        return responses\r\n\r\n    def __get_bios_version(self):\r\n        # Retrieves the BIOS firmware version\r\n        result = self.run_command(\"i2cget -y -f 2 0x32 0x19\")\r\n        if result.strip() == \"0x01\":\r\n            if self.name == \"Main_BIOS\":\r\n                version = self.run_command(BIOS_VERSION_PATH)\r\n                bios_version = version.strip().split(\" \")[1]\r\n                return str(bios_version)\r\n            elif self.name == \"Backup_BIOS\":\r\n                bios_version = \"na\"\r\n                return bios_version\r\n                \r\n        elif result.strip() == \"0x03\":\r\n            if self.name == \"Backup_BIOS\":\r\n                version = self.run_command(BIOS_VERSION_PATH)\r\n                bios_version = version.strip().split(\" \")[1]\r\n                return str(bios_version)\r\n            elif self.name == \"Main_BIOS\":\r\n                bios_version = \"na\"\r\n                return bios_version\r\n\r\n    def __get_cpld_version(self):\r\n        if self.name == \"SWCPLD\":\r\n            ver = self.run_command(SWCPLD_VERSION_PATH)\r\n            print(\"ver is %s\" % ver)\r\n            ver = ver.strip().split(\"x\")[1]\r\n            print(\"ver2 is %s\" % ver)\r\n            version = int(ver.strip()) / 10\r\n            return str(version)\r\n\r\n                \r\n    def get_name(self):\r\n        \"\"\"\r\n        Retrieves the name of the component\r\n         Returns:\r\n            A string containing the name of the component\r\n        \"\"\"\r\n        return COMPONENT_NAME_LIST[self.index]\r\n\r\n    def get_description(self):\r\n        \"\"\"\r\n        Retrieves the description of the component\r\n            Returns:\r\n            A string containing the description of the component\r\n        \"\"\"\r\n        return COMPONENT_DES_LIST[self.index]\r\n\r\n    def get_firmware_version(self):\r\n        \"\"\"\r\n        Retrieves the firmware version of module\r\n        Returns:\r\n            string: The firmware versions of the module\r\n        \"\"\"\r\n        fw_version = None\r\n        \r\n        if \"BIOS\" in self.name:\r\n            fw_version = self.__get_bios_version()\r\n        elif \"CPLD\" in self.name:\r\n            fw_version = self.__get_cpld_version()\r\n            \r\n        return fw_version\r\n\r\n    def install_firmware(self, image_path):\r\n        \"\"\"\r\n        Install firmware to module\r\n        Args:\r\n            image_path: A string, path to firmware image\r\n        Returns:\r\n            A boolean, True if install successfully, False if not\r\n        \"\"\"\r\n        return False\r\n\r\n    def update_firmware(self, image_path):\r\n        return False\r\n\r\n    def get_available_firmware_version(self, image_path):\r\n        return 'N/A'\r\n\r\n    def get_firmware_update_notification(self, image_path):\r\n        return \"None\"\r\n\r\n    def get_model(self):\r\n        return 'N/A'\r\n\r\n    def get_position_in_parent(self):\r\n        return -1\r\n\r\n    def get_presence(self):\r\n        return True\r\n \r\n    def get_serial(self):\r\n        return 'N/A'\r\n\r\n    def get_status(self):\r\n        return True\r\n\r\n    def is_replaceable(self):\r\n        return False\r\n"}, "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py": {"changes": [{"diff": "\n         \"\"\"\n         if self.is_psu_fan:\n             cmd_num = \"58\" if self.fans_psu_index == 1 else \"59\"\n-            cmd = \"i2cget -y -f 4 0x%s 0x80\" % cmd_num\n-            res = os.popen(cmd).read()\n+            cmd = [\"i2cget\", \"-y\", \"-f\", \"4\", \"\", \"0x80\"]\n+            cmd[4] = \"0x\" + cmd_num\n+            res = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()\n             # F2B \n             if res.strip() == \"0x01\":\n                 dir", "add": 3, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/pddf/sonic_platform/fan.py", "badparts": ["            cmd = \"i2cget -y -f 4 0x%s 0x80\" % cmd_num", "            res = os.popen(cmd).read()"], "goodparts": ["            cmd = [\"i2cget\", \"-y\", \"-f\", \"4\", \"\", \"0x80\"]", "            cmd[4] = \"0x\" + cmd_num", "            res = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True).stdout.read()"]}], "source": "\ntry: from sonic_platform_pddf_base.pddf_fan import PddfFan import os except ImportError as e: raise ImportError(str(e) +\"-required module not found\") FAN_DIRECTION_FILE_PATH=\"/var/fan_direction\" class Fan(PddfFan): \"\"\"PDDF Platform-Specific Fan class\"\"\" def __init__(self, tray_idx, fan_idx=0, pddf_data=None, pddf_plugin_data=None, is_psu_fan=False, psu_index=0): PddfFan.__init__(self, tray_idx, fan_idx, pddf_data, pddf_plugin_data, is_psu_fan, psu_index) def get_speed_tolerance(self): \"\"\" Retrieves the speed tolerance of the fan Returns: An integer, the percentage of variance from target speed which is considered tolerable \"\"\" return 20 def get_presence(self): return True def get_direction(self): \"\"\" Retrieves the direction of fan Returns: A string, either FAN_DIRECTION_INTAKE or FAN_DIRECTION_EXHAUST depending on fan direction \"\"\" if self.is_psu_fan: cmd_num=\"58\" if self.fans_psu_index==1 else \"59\" cmd=\"i2cget -y -f 4 0x%s 0x80\" % cmd_num res=os.popen(cmd).read() if res.strip()==\"0x01\": direction=\"EXHAUST\" else: direction=\"INTAKE\" else: direction=\"INTAKE\" with open(FAN_DIRECTION_FILE_PATH, \"r\") as f: fan_direction=f.read() if fan_direction.strip()==\"FB\": direction=\"EXHAUST\" return direction def get_status(self): speed=self.get_speed_rpm() status=True if(speed !=0) else False return status def get_target_speed(self): \"\"\" Retrieves the target(expected) speed of the fan Returns: An integer, the percentage of full fan speed, in the range 0(off) to 100(full speed) \"\"\" target_speed=0 if self.is_psu_fan: target_speed=\"N/A\" else: idx=(self.fantray_index -1) * 1 +self.fan_index attr=\"fan\" +str(idx) +\"_pwm\" pwm_path=\"/sys/devices/pci0000:00/0000:00:12.0/i2c-0/i2c-2/2-0066/\" +attr pwm=0 with open(pwm_path, \"r\") as f: pwm=f.read() percentage=int(pwm.strip()) speed_percentage=int(round(percentage / 255 * 100)) target_speed=speed_percentage return target_speed def set_status_led(self, color): color_dict={\"green\": \"STATUS_LED_COLOR_GREEN\", \"red\": \"STATUS_LED_COLOR_AMBER\"} color=color_dict.get(color, \"off\") index=str(self.fantray_index -1) led_device_name=\"FANTRAY{}\".format(self.fantray_index) +\"_LED\" result, msg=self.pddf_obj.is_supported_sysled_state(led_device_name, color) if result is False: return False device_name=self.pddf_obj.data[led_device_name]['dev_info']['device_name'] self.pddf_obj.create_attr('device_name', device_name, self.pddf_obj.get_led_path()) self.pddf_obj.create_attr('index', index, self.pddf_obj.get_led_path()) self.pddf_obj.create_attr('color', color, self.pddf_obj.get_led_cur_state_path()) self.pddf_obj.create_attr('dev_ops', 'set_status', self.pddf_obj.get_led_path()) return True @staticmethod def get_model(): \"\"\" Retrieves the model number(or part number) of the device Returns: string: Model/part number of device \"\"\" model=\"Unknown\" return model @staticmethod def get_serial(): \"\"\" Retrieves the serial number of the device Returns: string: Serial number of device \"\"\" serial=\"Unknown\" return serial def get_position_in_parent(self): \"\"\" Retrieves the fan/psu fan index number \"\"\" return self.fantray_index if not self.is_psu_fan else self.fans_psu_index +4 \t\t @staticmethod def is_replaceable(): \"\"\" Retrieves whether the device is replaceable \"\"\" return False ", "sourceWithComments": "try:\n    from sonic_platform_pddf_base.pddf_fan import PddfFan\n    import os\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n# ------------------------------------------------------------------\n# HISTORY:\n#    5/1/2022 (A.D.)\n#    add function:set_status_led,\n#    Solve the problem that when a fan is pulled out, the Fan LED on the front panel is still green Issue-#11525\n# ------------------------------------------------------------------\nFAN_DIRECTION_FILE_PATH = \"/var/fan_direction\"\n\n\nclass Fan(PddfFan):\n    \"\"\"PDDF Platform-Specific Fan class\"\"\"\n\n    def __init__(self, tray_idx, fan_idx=0, pddf_data=None, pddf_plugin_data=None, is_psu_fan=False, psu_index=0):\n        # idx is 0-based\n        PddfFan.__init__(self, tray_idx, fan_idx, pddf_data, pddf_plugin_data, is_psu_fan, psu_index)\n\n\n    def get_speed_tolerance(self):\n        \"\"\"\n        Retrieves the speed tolerance of the fan\n\n        Returns:\n            An integer, the percentage of variance from target speed which is\n                 considered tolerable\n        \"\"\"\n        # Fix the speed vairance to 10 percent. If it changes based on platforms, overwrite\n        # this value in derived pddf fan class\n        return 20\n    \n    \n    def get_presence(self):\n        #Overwirte the PDDF Common since the FANs on Belgite are all Fixed and present\n        return True \n\n    def get_direction(self):\n        \"\"\"\n        Retrieves the direction of fan\n\n        Returns:\n            A string, either FAN_DIRECTION_INTAKE or FAN_DIRECTION_EXHAUST\n            depending on fan direction\n        \"\"\"\n        if self.is_psu_fan:\n            cmd_num = \"58\" if self.fans_psu_index == 1 else \"59\"\n            cmd = \"i2cget -y -f 4 0x%s 0x80\" % cmd_num\n            res = os.popen(cmd).read()\n            # F2B \n            if res.strip() == \"0x01\":\n                direction = \"EXHAUST\"\n            else:\n                direction = \"INTAKE\"\n        else:\n            direction = \"INTAKE\"\n            with open(FAN_DIRECTION_FILE_PATH, \"r\") as f:\n                fan_direction = f.read()\n                if fan_direction.strip() == \"FB\":\n                    direction = \"EXHAUST\"\n        return direction\n    \n\n    def get_status(self):\n        speed = self.get_speed_rpm()\n        status = True if (speed != 0) else False\n        return status\n\n    def get_target_speed(self):\n        \"\"\"\n        Retrieves the target (expected) speed of the fan\n\n        Returns:\n            An integer, the percentage of full fan speed, in the range 0 (off)\n                 to 100 (full speed)\n        \"\"\"\n        target_speed = 0\n        if self.is_psu_fan:\n            # Target speed not usually supported for PSU fans\n            target_speed = \"N/A\"\n        else:\n            idx = (self.fantray_index - 1) * 1 + self.fan_index\n            attr = \"fan\" + str(idx) + \"_pwm\"\n            pwm_path = \"/sys/devices/pci0000:00/0000:00:12.0/i2c-0/i2c-2/2-0066/\" + attr\n            pwm = 0\n            with open(pwm_path, \"r\") as f:\n                pwm = f.read()\n\n            percentage = int(pwm.strip())\n            speed_percentage = int(round(percentage / 255 * 100))\n            target_speed = speed_percentage\n\n        return target_speed\n\n    def set_status_led(self, color):\n        color_dict = {\"green\": \"STATUS_LED_COLOR_GREEN\",\n                      \"red\": \"STATUS_LED_COLOR_AMBER\"}\n        color = color_dict.get(color, \"off\")\n        index = str(self.fantray_index - 1)\n        led_device_name = \"FANTRAY{}\".format(self.fantray_index) + \"_LED\"\n\n        result, msg = self.pddf_obj.is_supported_sysled_state(led_device_name, color)\n        if result is False:\n            return False\n        device_name = self.pddf_obj.data[led_device_name]['dev_info']['device_name']\n        self.pddf_obj.create_attr('device_name', device_name, self.pddf_obj.get_led_path())\n        self.pddf_obj.create_attr('index', index, self.pddf_obj.get_led_path())\n        self.pddf_obj.create_attr('color', color, self.pddf_obj.get_led_cur_state_path())\n\n        self.pddf_obj.create_attr('dev_ops', 'set_status', self.pddf_obj.get_led_path())\n        return True\n\n    @staticmethod\n    def get_model():\n        \"\"\"\n        Retrieves the model number (or part number) of the device\n        Returns:\n            string: Model/part number of device\n        \"\"\"\n        model = \"Unknown\"\n        return model\n\n    @staticmethod\n    def get_serial():\n        \"\"\"\n        Retrieves the serial number of the device\n        Returns:\n            string: Serial number of device\n        \"\"\"\n        serial = \"Unknown\"\n        return serial\n\n    def get_position_in_parent(self):\n        \"\"\"\n        Retrieves the fan/psu fan index number\n        \"\"\"\n        return self.fantray_index if not self.is_psu_fan else self.fans_psu_index + 4\n\t\t\n    @staticmethod\n    def is_replaceable():\n        \"\"\"\n        Retrieves whether the device is replaceable\n        \"\"\"\n        return False\n"}, "/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py": {"changes": [{"diff": "\n try:\n     import sys\n     import getopt\n-    import subprocess\n     import logging\n     import logging.config\n     import time  # this is only being used as part of the example\n     import signal\n     import math\n     from sonic_platform import platform\n+    from sonic_py_common.general import getstatusoutput_noshell\n except ImportError as e:\n     raise ImportError('%s - required module not found' % str(e))\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py", "badparts": ["    import subprocess"], "goodparts": ["    from sonic_py_common.general import getstatusoutput_noshell"]}, {"diff": "\n         else:\n             logging.debug('INFO: FAIL. set_fan_duty_cycle (%d)' % DUTY_MAX)\n         # Enable the CPLD Heartbeat back\n-        status, output = subprocess.getstatusoutput('i2cset -f -y 75 0x40 0x22 0x00')\n+        status, output = getstatusoutput_noshell([\"i2cset\", \"-f\", \"-y\", \"75\", \"0x40\", \"0x22\", \"0x00\"])\n         if status == 0:\n             logging.debug('INFO: CPLD Heartbeat check is enabled back')\n     sys.exit(0)\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py", "badparts": ["        status, output = subprocess.getstatusoutput('i2cset -f -y 75 0x40 0x22 0x00')"], "goodparts": ["        status, output = getstatusoutput_noshell([\"i2cset\", \"-f\", \"-y\", \"75\", \"0x40\", \"0x22\", \"0x00\"])"]}, {"diff": "\n     signal.signal(signal.SIGINT, handler)\n     signal.signal(signal.SIGTERM, handler)\n     # Disaable the CPLD Heartbeat check to control Fan speed from CPU via ADT7470\n-    subprocess.getstatusoutput('i2cset -f -y 2 0x32 0x30 0x01')\n+    getstatusoutput_noshell(['i2cset', '-f', '-y', '2', '0x32', '0x30', '0x01'])\n \n     monitor = cel_belgite_monitor(log", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/belgite/utils/belgite_pddf_monitor.py", "badparts": ["    subprocess.getstatusoutput('i2cset -f -y 2 0x32 0x30 0x01')"], "goodparts": ["    getstatusoutput_noshell(['i2cset', '-f', '-y', '2', '0x32', '0x30', '0x01'])"]}], "source": "\n try: import sys import getopt import subprocess import logging import logging.config import time import signal import math from sonic_platform import platform except ImportError as e: raise ImportError('%s -required module not found' % str(e)) FUNCTION_NAME='cel_belgite_monitor' DUTY_MAX=100 FAN_NUMBER=3 SENSOR_NUMBER=4 CPU_CORE_TEMP=r\"/sys/devices/platform/coretemp.0/hwmon/hwmon1/temp1_input\" class cel_belgite_monitor(object): \"\"\" Make a class we can use to capture stdout and sterr in the log \"\"\" _ori_temp=0 _new_perc=DUTY_MAX / 2 syslog=logging.getLogger(\"[\" +FUNCTION_NAME +\"]\") init_fan_temperature=[0, 0, 0, 0] def __init__(self, log_file, log_level): \"\"\"Needs a logger and a logger level.\"\"\" formatter=logging.Formatter('%(name)s %(message)s') sys_handler=logging.handlers.SysLogHandler(address='/dev/log') sys_handler.setFormatter(formatter) sys_handler.ident='common' self.syslog.setLevel(logging.WARNING) self.syslog.addHandler(sys_handler) self.platform_chassis_obj=platform.Platform().get_chassis() logging.basicConfig( filename=log_file, filemode='w', level=log_level, format='[%(asctime)s]{%(pathname)s:%(lineno)d} %(levelname)s -%(message)s', datefmt='%H:%M:%S' ) if log_level==logging.DEBUG: console=logging.StreamHandler() console.setLevel(log_level) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) logging.debug('SET. logfile:%s / loglevel:%d' %(log_file, log_level)) def get_all_temperature(self): \"\"\" return: all temperature \"\"\" all_temperature_list=list() for sensor_index in range(SENSOR_NUMBER): temp=self.platform_chassis_obj.get_thermal(sensor_index).get_temperature() if temp is None or str(temp).strip()==\"\": return False temp=temp*1000 all_temperature_list.append(temp) u4_temperature=all_temperature_list[0] u7_temperature=all_temperature_list[1] cpu_temperature=70000 try: with open(CPU_CORE_TEMP, \"r\") as f: cpu_temperature=float(f.read().strip()) except Exception as E: logging.debug('Error: %s' % E) u60_temperature=all_temperature_list[3] return[u4_temperature, u7_temperature, cpu_temperature, u60_temperature] def get_fan_speed_by_temperature(self, temp_list): fan1_direction=self.platform_chassis_obj.get_fan(0).get_direction() logging.debug('INFO: fan direction: %s' % str(fan1_direction)) all_temp=self.get_all_temperature() logging.debug('INFO: all_temp: %s' % str(all_temp)) a=1 if fan1_direction.lower()==\"intake\" else 0 sensor_temp=all_temp[a] cup_temp=all_temp[2] u60_temp=all_temp[3] logging.debug('sensor_temp:%d cup_temp:%d u60_temp:%d' %(sensor_temp, cup_temp, u60_temp)) update_temp_sensor, update_temp_cpu, update_temp_u60=True, True, True if all_temp[a] -temp_list[a] < 0: update_temp_sensor=False if cup_temp -temp_list[2] < 0: update_temp_cpu=False if u60_temp -temp_list[3] < 0: update_temp_u60=False if not update_temp_sensor: b=math.trunc(1400/13) if sensor_temp <=32000: sensor_temp_speed=40 elif sensor_temp >=45000: sensor_temp_speed=100 else: sensor_temp_speed=int(math.trunc(60 / 13) * math.trunc(sensor_temp / 1000) -b) else: b=math.trunc(1580 / 13) if sensor_temp <=35000: sensor_temp_speed=40 elif sensor_temp >=48000: sensor_temp_speed=100 else: sensor_temp_speed=int(math.trunc(60/13) * math.trunc(sensor_temp/1000) -b) if not update_temp_cpu: b=228 if cup_temp <=67000: cpu_temp_speed=40 elif cup_temp >=82000: cpu_temp_speed=100 else: cpu_temp_speed=int(4 *(cup_temp / 1000) -b) else: b=240 if cup_temp <=70000: cpu_temp_speed=40 elif cup_temp >=85000: cpu_temp_speed=100 else: cpu_temp_speed=int(4 *(cup_temp / 1000) -b) if not update_temp_u60: b=168 if u60_temp <=52000: u60_temp_speed=40 elif u60_temp >=67000: u60_temp_speed=100 else: u60_temp_speed=int(4 *(u60_temp / 1000) -b) else: b=180 if u60_temp <=55000: u60_temp_speed=40 elif u60_temp >=70000: u60_temp_speed=100 else: u60_temp_speed=int(4 *(u60_temp / 1000) -b) return max([sensor_temp_speed, cpu_temp_speed, u60_temp_speed]) def manage_fans(self): fan_presence_list=[True, True, True] for fan_index in range(FAN_NUMBER): if not self.platform_chassis_obj.get_fan(fan_index).get_presence() or not \\ self.platform_chassis_obj.get_fan(fan_index).get_status(): fan_presence_list[fan_index]=False logging.debug('self.platform_chassis_obj.get_fan(fan_index).get_presence():%s' % str(self.platform_chassis_obj.get_fan(fan_index).get_presence())) logging.debug('self.platform_chassis_obj.get_fan(fan_index).get_status():%s' % str(self.platform_chassis_obj.get_fan(fan_index).get_status())) else: fan_presence_list[fan_index]=True fans_inserted_num=FAN_NUMBER -fan_presence_list.count(False) if fans_inserted_num==0: self.syslog.critical(\"No fans inserted. Severe overheating hazard. \" \"Please insert Fans immediately or power off the device\\n\") elif fans_inserted_num in[1, 2]: self._new_perc=DUTY_MAX else: self._new_perc=self.get_fan_speed_by_temperature(self.init_fan_temperature) logging.debug('INFO: 3 fans inserted: self._new_perc: %s' % str(self._new_perc)) self.init_fan_temperature=self.get_all_temperature() for i in range(FAN_NUMBER): aa=self.platform_chassis_obj.get_fan(i).get_speed() logging.debug(\"INFO: Get before setting fan speed: %s\" % aa) if self._new_perc < 40: self._new_perc=40 if self._new_perc > 100: self._new_perc=100 set_stat=self.platform_chassis_obj.get_fan(i).set_speed(self._new_perc) if set_stat is True: logging.debug('INFO: PASS. set_fan%d_duty_cycle(%d)' %(i, self._new_perc)) else: logging.debug('INFO: FAIL. set_fan%d_duty_cycle(%d)' %(i, self._new_perc)) def handler(signum, frame): platform_chassis=platform.Platform().get_chassis() for _ in range(FAN_NUMBER): set_stat=platform_chassis.get_fan(_).set_speed(DUTY_MAX) if set_stat is True: logging.debug('INFO:Cause signal %d, set fan speed max.' % signum) else: logging.debug('INFO: FAIL. set_fan_duty_cycle(%d)' % DUTY_MAX) status, output=subprocess.getstatusoutput('i2cset -f -y 75 0x40 0x22 0x00') if status==0: logging.debug('INFO: CPLD Heartbeat check is enabled back') sys.exit(0) def main(argv): global test_temp log_file='/home/admin/%s.log' % FUNCTION_NAME log_level=logging.INFO if len(sys.argv) !=1: try: opts, args=getopt.getopt(argv, 'hdlt:',['lfile=']) except getopt.GetoptError: print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 for opt, arg in opts: if opt=='-h': print('Usage: %s[-d][-l <log_file>]' % sys.argv[0]) return 0 elif opt in('-d', '--debug'): log_level=logging.DEBUG elif opt in('-l', '--lfile'): log_file=arg if sys.argv[1]=='-t': if len(sys.argv) !=6: print(\"temp test, need input 4 temp\") return 0 signal.signal(signal.SIGINT, handler) signal.signal(signal.SIGTERM, handler) subprocess.getstatusoutput('i2cset -f -y 2 0x32 0x30 0x01') monitor=cel_belgite_monitor(log_file, log_level) while True: monitor.manage_fans() time.sleep(10) if __name__=='__main__': main(sys.argv[1:]) ", "sourceWithComments": "#!/usr/bin/env python3\n#\n# Copyright (C) Celestica Technology Corporation\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# ------------------------------------------------------------------\n# HISTORY:\n#    9/16/2021 (A.D.)\n# ------------------------------------------------------------------\n\ntry:\n    import sys\n    import getopt\n    import subprocess\n    import logging\n    import logging.config\n    import time  # this is only being used as part of the example\n    import signal\n    import math\n    from sonic_platform import platform\nexcept ImportError as e:\n    raise ImportError('%s - required module not found' % str(e))\n\n# Deafults\nFUNCTION_NAME = 'cel_belgite_monitor'\nDUTY_MAX = 100\nFAN_NUMBER = 3\nSENSOR_NUMBER = 4\nCPU_CORE_TEMP = r\"/sys/devices/platform/coretemp.0/hwmon/hwmon1/temp1_input\"\n\n\nclass cel_belgite_monitor(object):\n    \"\"\"\n    Make a class we can use to capture stdout and sterr in the log\n    \"\"\"\n    # static temp var\n    _ori_temp = 0\n    _new_perc = DUTY_MAX / 2\n    syslog = logging.getLogger(\"[\" + FUNCTION_NAME + \"]\")\n    init_fan_temperature = [0, 0, 0, 0]\n\n    def __init__(self, log_file, log_level):\n        \"\"\"Needs a logger and a logger level.\"\"\"\n        formatter = logging.Formatter('%(name)s %(message)s')\n        sys_handler = logging.handlers.SysLogHandler(address='/dev/log')\n        sys_handler.setFormatter(formatter)\n        sys_handler.ident = 'common'\n        self.syslog.setLevel(logging.WARNING)\n        self.syslog.addHandler(sys_handler)\n        self.platform_chassis_obj = platform.Platform().get_chassis()\n        # set up logging to file\n        logging.basicConfig(\n            filename=log_file,\n            filemode='w',\n            level=log_level,\n            format='[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',\n            datefmt='%H:%M:%S'\n        )\n\n        # set up logging to console\n        if log_level == logging.DEBUG:\n            console = logging.StreamHandler()\n            console.setLevel(log_level)\n            formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n            console.setFormatter(formatter)\n            logging.getLogger('').addHandler(console)\n        logging.debug('SET. logfile:%s / loglevel:%d' % (log_file, log_level))\n\n    def get_all_temperature(self):\n        \"\"\"\n        return: all temperature\n        \"\"\"\n        all_temperature_list = list()\n        for sensor_index in range(SENSOR_NUMBER):\n            temp = self.platform_chassis_obj.get_thermal(sensor_index).get_temperature()\n            if temp is None or str(temp).strip() == \"\":\n                return False\n            temp = temp*1000\n            all_temperature_list.append(temp)\n        u4_temperature = all_temperature_list[0]\n        u7_temperature = all_temperature_list[1]\n        # default CPU temperature 70\n        cpu_temperature = 70000\n        try:\n            with open(CPU_CORE_TEMP, \"r\") as f:\n                cpu_temperature = float(f.read().strip())\n        except Exception as E:\n            logging.debug('Error: %s' % E)\n        u60_temperature = all_temperature_list[3]   \n        return [u4_temperature, u7_temperature, cpu_temperature, u60_temperature]\n\n    def get_fan_speed_by_temperature(self, temp_list):\n        fan1_direction = self.platform_chassis_obj.get_fan(0).get_direction()\n        logging.debug('INFO: fan direction: %s' % str(fan1_direction))\n        all_temp = self.get_all_temperature()\n        logging.debug('INFO: all_temp: %s' % str(all_temp))\n        # B2F=intake: U7 temperature\uff0c F2B-EXHAUST: U4 temperature\n        a = 1 if fan1_direction.lower() == \"intake\" else 0\n        sensor_temp = all_temp[a]\n        cup_temp = all_temp[2]\n        u60_temp = all_temp[3]\n        logging.debug('sensor_temp:%d cup_temp:%d u60_temp:%d' % (sensor_temp, cup_temp, u60_temp))\n        update_temp_sensor, update_temp_cpu, update_temp_u60 = True, True, True\n        if all_temp[a] - temp_list[a] < 0:\n            update_temp_sensor = False\n        if cup_temp - temp_list[2] < 0:\n            update_temp_cpu = False\n        if u60_temp - temp_list[3] < 0:\n            update_temp_u60 = False\n\n        # U4 U7\n        if not update_temp_sensor:  # temperature down\n            b = math.trunc(1400/13)\n            if sensor_temp <= 32000:\n                sensor_temp_speed = 40\n            elif sensor_temp >= 45000:\n                sensor_temp_speed = 100\n            else:\n                sensor_temp_speed = int(math.trunc(60 / 13) * math.trunc(sensor_temp / 1000) - b)\n        else:   # temperature up\n            b = math.trunc(1580 / 13)\n            if sensor_temp <= 35000:\n                sensor_temp_speed = 40\n            elif sensor_temp >= 48000:\n                sensor_temp_speed = 100\n            else:\n                sensor_temp_speed = int(math.trunc(60/13) * math.trunc(sensor_temp/1000) - b)\n\n        # CPU\n        if not update_temp_cpu:  # temperature down\n            b = 228\n            if cup_temp <= 67000:\n                cpu_temp_speed = 40\n            elif cup_temp >= 82000:\n                cpu_temp_speed = 100\n            else:\n                cpu_temp_speed = int(4 * (cup_temp / 1000) - b)\n        else:   # temperature up\n            b = 240\n            if cup_temp <= 70000:\n                cpu_temp_speed = 40\n            elif cup_temp >= 85000:\n                cpu_temp_speed = 100\n            else:\n                cpu_temp_speed = int(4 * (cup_temp / 1000) - b)\n\n        # U60\n        if not update_temp_u60:  # temperature down\n            b = 168\n            if u60_temp <= 52000:\n                u60_temp_speed = 40\n            elif u60_temp >= 67000:\n                u60_temp_speed = 100\n            else:\n                u60_temp_speed = int(4 * (u60_temp / 1000) - b)\n        else:   # temperature up\n            b = 180\n            if u60_temp <= 55000:\n                u60_temp_speed = 40\n            elif u60_temp >= 70000:\n                u60_temp_speed = 100\n            else:\n                u60_temp_speed = int(4 * (u60_temp / 1000) - b)\n        return max([sensor_temp_speed, cpu_temp_speed, u60_temp_speed])\n\n    def manage_fans(self):\n        fan_presence_list = [True, True, True]  # whether fan is absent or not \n        for fan_index in range(FAN_NUMBER):\n            if not self.platform_chassis_obj.get_fan(fan_index).get_presence() or not \\\n                    self.platform_chassis_obj.get_fan(fan_index).get_status():\n                fan_presence_list[fan_index] = False\n                logging.debug('self.platform_chassis_obj.get_fan(fan_index).get_presence():%s'\n                              % str(self.platform_chassis_obj.get_fan(fan_index).get_presence()))\n                logging.debug('self.platform_chassis_obj.get_fan(fan_index).get_status():%s'\n                              % str(self.platform_chassis_obj.get_fan(fan_index).get_status()))\n            else:\n                fan_presence_list[fan_index] = True\n\n        fans_inserted_num = FAN_NUMBER - fan_presence_list.count(False)\n        if fans_inserted_num == 0:  # all fans broken, power off \n            self.syslog.critical(\"No fans inserted. Severe overheating hazard. \"\n                                 \"Please insert Fans immediately or power off the device\\n\")\n\n            # power off \n        elif fans_inserted_num in [1, 2]:   # 1 or 2 present, full speed \n            self._new_perc = DUTY_MAX\n        else:   # 3 fans normal, manage the fans follow thermal policy \n            self._new_perc = self.get_fan_speed_by_temperature(self.init_fan_temperature)\n            logging.debug('INFO: 3 fans inserted: self._new_perc: %s' % str(self._new_perc))\n            self.init_fan_temperature = self.get_all_temperature()\n\n        for i in range(FAN_NUMBER):\n            aa = self.platform_chassis_obj.get_fan(i).get_speed()\n            logging.debug(\"INFO: Get before setting fan speed: %s\" % aa)\n            if self._new_perc < 40:\n                self._new_perc = 40\n            if self._new_perc > 100:\n                self._new_perc = 100\n            set_stat = self.platform_chassis_obj.get_fan(i).set_speed(self._new_perc)\n            if set_stat is True:\n                logging.debug('INFO: PASS. set_fan%d_duty_cycle (%d)' % (i, self._new_perc))\n            else:\n                logging.debug('INFO: FAIL. set_fan%d_duty_cycle (%d)' % (i, self._new_perc))\n\n\ndef handler(signum, frame):\n    platform_chassis = platform.Platform().get_chassis()\n    for _ in range(FAN_NUMBER):\n        set_stat = platform_chassis.get_fan(_).set_speed(DUTY_MAX)\n        if set_stat is True:\n            logging.debug('INFO:Cause signal %d, set fan speed max.' % signum)\n        else:\n            logging.debug('INFO: FAIL. set_fan_duty_cycle (%d)' % DUTY_MAX)\n        # Enable the CPLD Heartbeat back\n        status, output = subprocess.getstatusoutput('i2cset -f -y 75 0x40 0x22 0x00')\n        if status == 0:\n            logging.debug('INFO: CPLD Heartbeat check is enabled back')\n    sys.exit(0)\n\n\ndef main(argv):\n    global test_temp\n\n    log_file = '/home/admin/%s.log' % FUNCTION_NAME\n    log_level = logging.INFO\n    if len(sys.argv) != 1:\n        try:\n            opts, args = getopt.getopt(argv, 'hdlt:', ['lfile='])\n        except getopt.GetoptError:\n            print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n            return 0\n        for opt, arg in opts:\n            if opt == '-h':\n                print('Usage: %s [-d] [-l <log_file>]' % sys.argv[0])\n                return 0\n            elif opt in ('-d', '--debug'):\n                log_level = logging.DEBUG\n            elif opt in ('-l', '--lfile'):\n                log_file = arg\n\n        if sys.argv[1] == '-t':\n            if len(sys.argv) != 6:\n                print(\"temp test, need input 4 temp\")\n                return 0\n\n    signal.signal(signal.SIGINT, handler)\n    signal.signal(signal.SIGTERM, handler)\n    # Disaable the CPLD Heartbeat check to control Fan speed from CPU via ADT7470\n    subprocess.getstatusoutput('i2cset -f -y 2 0x32 0x30 0x01')\n\n    monitor = cel_belgite_monitor(log_file, log_level)\n\n    # Loop forever, doing something useful hopefully:\n    while True:\n        monitor.manage_fans()\n        time.sleep(10)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n"}, "/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py": {"changes": [{"diff": "\n \n     SET_METHOD_IPMI = 'ipmitool'\n     NULL_VAL = 'N/A'\n-    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n+    HOST_CHK_CMD = [\"docker\"]\n     REF_KEY = '$ref:'\n \n     def __init__(self, conf=None):\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py", "badparts": ["    HOST_CHK_CMD = \"docker > /dev/null 2>&1\""], "goodparts": ["    HOST_CHK_CMD = [\"docker\"]"]}, {"diff": "\n             cleaned_input = input_translator.get(input)\n \n         elif type(input_translator) is str:\n-            cleaned_input = eval(input_translator.format(input))\n+            cleaned_input = ast.literal_eval(input_translator.format(input))\n \n         return cleaned_input\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py", "badparts": ["            cleaned_input = eval(input_translator.format(input))"], "goodparts": ["            cleaned_input = ast.literal_eval(input_translator.format(input))"]}, {"diff": "\n         if type(output_translator) is dict:\n             output = output_translator.get(output)\n         elif type(output_translator) is str:\n-            output = eval(output_translator.format(output))\n+            output = ast.literal_eval(output_translator.format(output))\n         elif type(output_translator) is list:\n-            output = eval(output_translator[index].format(output))\n+            output = ast.literal_eval(output_translator[index].format(output))\n \n         return output\n \n", "add": 2, "remove": 2, "filename": "/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py", "badparts": ["            output = eval(output_translator.format(output))", "            output = eval(output_translator[index].format(output))"], "goodparts": ["            output = ast.literal_eval(output_translator.format(output))", "            output = ast.literal_eval(output_translator[index].format(output))"]}, {"diff": "\n         return True\n \n     def is_host(self):\n-        return os.system(self.HOST_CHK_CMD) == 0\n+        try:\n+            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+        except FileNotFoundError:\n+            return False\n+        return True\n \n     def load_json_file(self,", "add": 5, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/services/platform_api/sonic_platform/common.py", "badparts": ["        return os.system(self.HOST_CHK_CMD) == 0"], "goodparts": ["        try:", "            subprocess.call(self.HOST_CHK_CMD, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)", "        except FileNotFoundError:", "            return False", "        return True"]}], "source": "\nimport os import imp import yaml import subprocess from sonic_py_common import device_info class Common: DEVICE_PATH='/usr/share/sonic/device/' PMON_PLATFORM_PATH='/usr/share/sonic/platform/' CONFIG_DIR='sonic_platform_config' OUTPUT_SOURCE_IPMI='ipmitool' OUTPUT_SOURCE_GIVEN_LIST='value_list' OUTPUT_SOURCE_GIVEN_VALUE='value' OUTPUT_SOURCE_GIVEN_CLASS='class' OUTPUT_SOURCE_SYSFS='sysfs_value' OUTPUT_SOURCE_FUNC='function' OUTPUT_SOURCE_GIVEN_TXT_FILE='txt_file' OUTPUT_SOURCE_GIVEN_VER_HEX_FILE='hex_version_file' OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR='hex_version_getreg' SET_METHOD_IPMI='ipmitool' NULL_VAL='N/A' HOST_CHK_CMD=\"docker > /dev/null 2>&1\" REF_KEY='$ref:' def __init__(self, conf=None): self._main_conf=conf (self.platform, self.hwsku)=device_info.get_platform_and_hwsku() def _run_command(self, command): status=False output=\"\" try: p=subprocess.Popen( command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) raw_data, err=p.communicate() if err=='': status, output=True, raw_data.strip() except Exception: pass return status, output def _clean_input(self, input, config): cleaned_input=input ai=config.get('avaliable_input') if ai and input not in ai: return None input_translator=config.get('input_translator') if type(input_translator) is dict: cleaned_input=input_translator.get(input) elif type(input_translator) is str: cleaned_input=eval(input_translator.format(input)) return cleaned_input def _clean_output(self, index, output, config): output_translator=config.get('output_translator') if type(output_translator) is dict: output=output_translator.get(output) elif type(output_translator) is str: output=eval(output_translator.format(output)) elif type(output_translator) is list: output=eval(output_translator[index].format(output)) return output def _ipmi_get(self, index, config): argument=config.get('argument') cmd=config['command'].format( config['argument'][index]) if argument else config['command'] status, output=self._run_command(cmd) return output if status else None def _sysfs_read(self, index, config): sysfs_path=config.get('sysfs_path') argument=config.get('argument', '') if self.REF_KEY in argument: argument=self._main_conf[argument.split(\":\")[1]] if type(argument) is list: sysfs_path=sysfs_path.format(argument[index]) content=\"\" try: content=open(sysfs_path) content=content.readline().rstrip() except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False return content def _sysfs_write(self, index, config, input): sysfs_path=config.get('sysfs_path') argument=config.get('argument', '') if self.REF_KEY in argument: argument=self._main_conf[argument.split(\":\")[1]] if type(argument) is list: sysfs_path=sysfs_path.format(argument[index]) write_offset=int(config.get('write_offset', 0)) output=\"\" try: open_file=open(sysfs_path, \"r+\") open_file.seek(write_offset) open_file.write(input) open_file.close() except IOError as e: print(\"Error: unable to open file: %s\" % str(e)) return False, output return True, output def _ipmi_set(self, index, config, input): arg=config['argument'][index].format(input) return self._run_command(config['command'].format(arg)) def _hex_ver_decode(self, hver, num_of_bits, num_of_points): ver_list=[] c_bit=0 bin_val=bin(int(hver, 16))[2:].zfill(num_of_bits) bit_split=num_of_bits /(num_of_points +1) for x in range(0, num_of_points+1): split_bin=bin_val[c_bit:c_bit+bit_split] ver_list.append(str(int(split_bin, 2))) c_bit +=bit_split return '.'.join(ver_list) def _get_class(self, config): \"\"\" Retreives value of expected attribute Returns: A value of the attribute of object \"\"\" path=config['host_path'] if self.is_host() else config['pmon_path'] module=imp.load_source(config['class'], path) class_=getattr(module, config['class']) return class_ def get_reg(self, path, reg_addr): cmd=\"echo{1} >{0}; cat{0}\".format(path, reg_addr) status, output=self._run_command(cmd) return output if status else None def read_txt_file(self, path): with open(path, 'r') as f: output=f.readline() return output.strip('\\n') def write_txt_file(self, file_path, value): try: with open(file_path, 'w') as fd: fd.write(str(value)) except Exception: return False return True def is_host(self): return os.system(self.HOST_CHK_CMD)==0 def load_json_file(self, path): \"\"\" Retrieves the json object from json file path Returns: A json object \"\"\" with open(path, 'r') as f: json_data=yaml.safe_load(f) return json_data def get_config_path(self, config_name): \"\"\" Retrieves the path to platform api config directory Args: config_name: A string containing the name of config file. Returns: A string containing the path to json file \"\"\" return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name) def get_output(self, index, config, default): \"\"\" Retrieves the output for each function base on config Args: index: An integer containing the index of device. config: A dict object containing the configuration of specified function. default: A string containing the default output of specified function. Returns: A string containing the output of specified function in config \"\"\" output_source=config.get('output_source') if output_source==self.OUTPUT_SOURCE_IPMI: output=self._ipmi_get(index, config) elif output_source==self.OUTPUT_SOURCE_GIVEN_VALUE: output=config[\"value\"] elif output_source==self.OUTPUT_SOURCE_GIVEN_CLASS: output=self._get_class(config) elif output_source==self.OUTPUT_SOURCE_GIVEN_LIST: output=config[\"value_list\"][index] elif output_source==self.OUTPUT_SOURCE_SYSFS: output=self._sysfs_read(index, config) elif output_source==self.OUTPUT_SOURCE_FUNC: func_conf=self._main_conf[config['function'][index]] output=self.get_output(index, func_conf, default) elif output_source==self.OUTPUT_SOURCE_GIVEN_TXT_FILE: path=config.get('path') output=self.read_txt_file(path) elif output_source==self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE: path=config.get('path') hex_ver=self.read_txt_file(path) output=self._hex_ver_decode( hex_ver, config['num_of_bits'], config['num_of_points']) elif output_source==self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR: path=config.get('path') addr=config.get('reg_addr') hex_ver=self.get_reg(path, addr) output=self._hex_ver_decode( hex_ver, config['num_of_bits'], config['num_of_points']) else: output=default return self._clean_output(index, output, config) or default def set_output(self, index, input, config): \"\"\" Sets the output of specified function on config Args: config: A dict object containing the configuration of specified function. index: An integer containing the index of device. input: A string containing the input of specified function. Returns: bool: True if set function is successfully, False if not \"\"\" cleaned_input=self._clean_input(input, config) if not cleaned_input: return False set_method=config.get('set_method') if set_method==self.SET_METHOD_IPMI: output=self._ipmi_set(index, config, cleaned_input)[0] elif set_method==self.OUTPUT_SOURCE_SYSFS: output=self._sysfs_write(index, config, cleaned_input)[0] else: output=False return output def get_event(self, timeout, config, sfp_list): \"\"\" Returns a nested dictionary containing all devices which have experienced a change at chassis level \"\"\" event_class=self._get_class(config) return event_class(sfp_list).get_event(timeout) ", "sourceWithComments": "import os\nimport imp\nimport yaml\nimport subprocess\n\nfrom sonic_py_common import device_info\n\n\nclass Common:\n\n    DEVICE_PATH = '/usr/share/sonic/device/'\n    PMON_PLATFORM_PATH = '/usr/share/sonic/platform/'\n    CONFIG_DIR = 'sonic_platform_config'\n\n    OUTPUT_SOURCE_IPMI = 'ipmitool'\n    OUTPUT_SOURCE_GIVEN_LIST = 'value_list'\n    OUTPUT_SOURCE_GIVEN_VALUE = 'value'\n    OUTPUT_SOURCE_GIVEN_CLASS = 'class'\n    OUTPUT_SOURCE_SYSFS = 'sysfs_value'\n    OUTPUT_SOURCE_FUNC = 'function'\n    OUTPUT_SOURCE_GIVEN_TXT_FILE = 'txt_file'\n    OUTPUT_SOURCE_GIVEN_VER_HEX_FILE = 'hex_version_file'\n    OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR = 'hex_version_getreg'\n\n    SET_METHOD_IPMI = 'ipmitool'\n    NULL_VAL = 'N/A'\n    HOST_CHK_CMD = \"docker > /dev/null 2>&1\"\n    REF_KEY = '$ref:'\n\n    def __init__(self, conf=None):\n        self._main_conf = conf\n        (self.platform, self.hwsku) = device_info.get_platform_and_hwsku()\n\n    def _run_command(self, command):\n        status = False\n        output = \"\"\n        try:\n            p = subprocess.Popen(\n                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            raw_data, err = p.communicate()\n            if err == '':\n                status, output = True, raw_data.strip()\n        except Exception:\n            pass\n        return status, output\n\n    def _clean_input(self, input, config):\n        cleaned_input = input\n\n        ai = config.get('avaliable_input')\n        if ai and input not in ai:\n            return None\n\n        input_translator = config.get('input_translator')\n        if type(input_translator) is dict:\n            cleaned_input = input_translator.get(input)\n\n        elif type(input_translator) is str:\n            cleaned_input = eval(input_translator.format(input))\n\n        return cleaned_input\n\n    def _clean_output(self, index, output, config):\n        output_translator = config.get('output_translator')\n\n        if type(output_translator) is dict:\n            output = output_translator.get(output)\n        elif type(output_translator) is str:\n            output = eval(output_translator.format(output))\n        elif type(output_translator) is list:\n            output = eval(output_translator[index].format(output))\n\n        return output\n\n    def _ipmi_get(self, index, config):\n        argument = config.get('argument')\n        cmd = config['command'].format(\n            config['argument'][index]) if argument else config['command']\n        status, output = self._run_command(cmd)\n        return output if status else None\n\n    def _sysfs_read(self, index, config):\n        sysfs_path = config.get('sysfs_path')\n        argument = config.get('argument', '')\n\n        if self.REF_KEY in argument:\n            argument = self._main_conf[argument.split(\":\")[1]]\n\n        if type(argument) is list:\n            sysfs_path = sysfs_path.format(argument[index])\n\n        content = \"\"\n        try:\n            content = open(sysfs_path)\n            content = content.readline().rstrip()\n        except IOError as e:\n            print(\"Error: unable to open file: %s\" % str(e))\n            return False\n\n        return content\n\n    def _sysfs_write(self, index, config, input):\n        sysfs_path = config.get('sysfs_path')\n        argument = config.get('argument', '')\n\n        if self.REF_KEY in argument:\n            argument = self._main_conf[argument.split(\":\")[1]]\n\n        if type(argument) is list:\n            sysfs_path = sysfs_path.format(argument[index])\n\n        write_offset = int(config.get('write_offset', 0))\n        output = \"\"\n        try:\n            open_file = open(sysfs_path, \"r+\")\n            open_file.seek(write_offset)\n            open_file.write(input)\n            open_file.close()\n        except IOError as e:\n            print(\"Error: unable to open file: %s\" % str(e))\n            return False, output\n        return True, output\n\n    def _ipmi_set(self, index, config, input):\n        arg = config['argument'][index].format(input)\n        return self._run_command(config['command'].format(arg))\n\n    def _hex_ver_decode(self, hver, num_of_bits, num_of_points):\n        ver_list = []\n        c_bit = 0\n        bin_val = bin(int(hver, 16))[2:].zfill(num_of_bits)\n        bit_split = num_of_bits / (num_of_points + 1)\n        for x in range(0, num_of_points+1):\n            split_bin = bin_val[c_bit:c_bit+bit_split]\n            ver_list.append(str(int(split_bin, 2)))\n            c_bit += bit_split\n        return '.'.join(ver_list)\n\n    def _get_class(self, config):\n        \"\"\"\n        Retreives value of expected attribute\n        Returns:\n            A value of the attribute of object\n        \"\"\"\n        path = config['host_path'] if self.is_host() else config['pmon_path']\n        module = imp.load_source(config['class'], path)\n        class_ = getattr(module, config['class'])\n        return class_\n\n    def get_reg(self, path, reg_addr):\n        cmd = \"echo {1} > {0}; cat {0}\".format(path, reg_addr)\n        status, output = self._run_command(cmd)\n        return output if status else None\n\n    def read_txt_file(self, path):\n        with open(path, 'r') as f:\n            output = f.readline()\n        return output.strip('\\n')\n\n    def write_txt_file(self, file_path, value):\n        try:\n            with open(file_path, 'w') as fd:\n                fd.write(str(value))\n        except Exception:\n            return False\n        return True\n\n    def is_host(self):\n        return os.system(self.HOST_CHK_CMD) == 0\n\n    def load_json_file(self, path):\n        \"\"\"\n        Retrieves the json object from json file path\n\n        Returns:\n            A json object\n        \"\"\"\n        with open(path, 'r') as f:\n            json_data = yaml.safe_load(f)\n\n        return json_data\n\n    def get_config_path(self, config_name):\n        \"\"\"\n        Retrieves the path to platform api config directory\n\n        Args:\n            config_name: A string containing the name of config file.\n\n        Returns:\n            A string containing the path to json file\n        \"\"\"\n        return os.path.join(self.DEVICE_PATH, self.platform, self.CONFIG_DIR, config_name) if self.is_host() else os.path.join(self.PMON_PLATFORM_PATH, self.CONFIG_DIR, config_name)\n\n    def get_output(self, index, config, default):\n        \"\"\"\n        Retrieves the output for each function base on config\n\n        Args:\n            index: An integer containing the index of device.\n            config: A dict object containing the configuration of specified function.\n            default: A string containing the default output of specified function.\n\n        Returns:\n            A string containing the output of specified function in config\n        \"\"\"\n        output_source = config.get('output_source')\n\n        if output_source == self.OUTPUT_SOURCE_IPMI:\n            output = self._ipmi_get(index, config)\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VALUE:\n            output = config[\"value\"]\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_CLASS:\n            output = self._get_class(config)\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_LIST:\n            output = config[\"value_list\"][index]\n\n        elif output_source == self.OUTPUT_SOURCE_SYSFS:\n            output = self._sysfs_read(index, config)\n\n        elif output_source == self.OUTPUT_SOURCE_FUNC:\n            func_conf = self._main_conf[config['function'][index]]\n            output = self.get_output(index, func_conf, default)\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_TXT_FILE:\n            path = config.get('path')\n            output = self.read_txt_file(path)\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_FILE:\n            path = config.get('path')\n            hex_ver = self.read_txt_file(path)\n            output = self._hex_ver_decode(\n                hex_ver, config['num_of_bits'], config['num_of_points'])\n\n        elif output_source == self.OUTPUT_SOURCE_GIVEN_VER_HEX_ADDR:\n            path = config.get('path')\n            addr = config.get('reg_addr')\n            hex_ver = self.get_reg(path, addr)\n            output = self._hex_ver_decode(\n                hex_ver, config['num_of_bits'], config['num_of_points'])\n\n        else:\n            output = default\n\n        return self._clean_output(index, output, config) or default\n\n    def set_output(self, index, input, config):\n        \"\"\"\n        Sets the output of specified function on config\n\n        Args:\n            config: A dict object containing the configuration of specified function.\n            index: An integer containing the index of device.\n            input: A string containing the input of specified function.\n\n        Returns:\n            bool: True if set function is successfully, False if not\n        \"\"\"\n        cleaned_input = self._clean_input(input, config)\n        if not cleaned_input:\n            return False\n\n        set_method = config.get('set_method')\n        if set_method == self.SET_METHOD_IPMI:\n            output = self._ipmi_set(index, config, cleaned_input)[0]\n        elif set_method == self.OUTPUT_SOURCE_SYSFS:\n            output = self._sysfs_write(index, config, cleaned_input)[0]\n        else:\n            output = False\n\n        return output\n\n    def get_event(self, timeout, config, sfp_list):\n        \"\"\"\n        Returns a nested dictionary containing all devices which have\n        experienced a change at chassis level\n\n        \"\"\"\n        event_class = self._get_class(config)\n        return event_class(sfp_list).get_event(timeout)\n"}, "/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py": {"changes": [{"diff": "\n import logging\n import subprocess\n \n-IPMI_SDR_CMD = \"ipmitool sdr elist\"\n+IPMI_SDR_CMD = [\"ipmitool\", \"sdr\", \"elist\"]\n MAX_NUM_FANS = 7\n MAX_NUM_PSUS = 2\n \n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py", "badparts": ["IPMI_SDR_CMD = \"ipmitool sdr elist\""], "goodparts": ["IPMI_SDR_CMD = [\"ipmitool\", \"sdr\", \"elist\"]"]}, {"diff": "\n     '''\n     sensor_dump = ''\n     try:\n-        sensor_dump = subprocess.check_output(cmd, shell=True)\n+        sensor_dump = subprocess.check_output(cmd)\n     except subprocess.CalledProcessError as e:\n         logging.error('Error! Failed to execute: {}'.format(cmd))\n         sys.exit(1)\n", "add": 1, "remove": 1, "filename": "/platform/broadcom/sonic-platform-modules-cel/silverstone/scripts/platform_sensors.py", "badparts": ["        sensor_dump = subprocess.check_output(cmd, shell=True)"], "goodparts": ["        sensor_dump = subprocess.check_output(cmd)"]}], "source": "\n import sys import logging import subprocess IPMI_SDR_CMD=\"ipmitool sdr elist\" MAX_NUM_FANS=7 MAX_NUM_PSUS=2 def ipmi_sensor_dump(cmd): ''' Execute ipmitool command return dump output exit if any error occur. ''' sensor_dump='' try: sensor_dump=subprocess.check_output(cmd, shell=True) except subprocess.CalledProcessError as e: logging.error('Error! Failed to execute:{}'.format(cmd)) sys.exit(1) return sensor_dump def get_reading_by_name(sensor_name, sdr_elist_dump): ''' Search for the match sensor name, return sensor reading value and unit, return object epmtry string if search not match. The output of sensor dump: TEMP_FAN_U52 | 00h | ok | 7.1 | 31 degrees C TEMP_FAN_U17 | 01h | ok | 7.1 | 27 degrees C TEMP_SW_U52 | 02h | ok | 7.1 | 30 degrees C Fan2_Status | 07h | ok | 29.2 | Present Fan2_Front | 0Eh | ok | 29.2 | 12000 RPM Fan2_Rear | 46h | ok | 29.2 | 14700 RPM PSU2_Status | 39h | ok | 10.2 | Presence detected PSU2_Fan | 3Dh | ok | 10.2 | 16000 RPM PSU2_VIn | 3Ah | ok | 10.2 | 234.30 Volts PSU2_CIn | 3Bh | ok | 10.2 | 0.80 Amps ''' found='' for line in sdr_elist_dump.split(\"\\n\"): if sensor_name in line: found=line.strip() break if not found: logging.error('Cannot find sensor name:' +sensor_name) else: try: found=found.split('|')[4] except IndexError: logging.error('Cannot get sensor data of:' +sensor_name) logging.basicConfig(level=logging.DEBUG) return found def read_temperature_sensors(ipmi_sdr_elist): sensor_list=[ ('TEMP_FAN_U52', 'Fan Tray Middle Temp'), ('TEMP_FAN_U17', 'Fan Tray Right Temp'), ('TEMP_SW_U52', 'Switchboard Left Inlet Temp'), ('TEMP_SW_U16', 'Switchboard Right Inlet Temp'), ('TEMP_BB_U3', 'Baseboard Temp'), ('TEMP_CPU', 'CPU Internal Temp'), ('TEMP_SW_Internal', 'ASIC Internal Temp'), ('SW_U04_Temp', 'IR3595 Chip Left Temp'), ('SW_U14_Temp', 'IR3595 Chip Right Temp'), ('SW_U4403_Temp', 'IR3584 Chip Temp'), ] output='' sensor_format='{0:{width}}{1}\\n' max_name_width=max(len(sensor[1]) for sensor in sensor_list) output +=\"Temperature Sensors\\n\" output +=\"Adapter: IPMI adapter\\n\" for sensor in sensor_list: reading=get_reading_by_name(sensor[0],ipmi_sdr_elist) output +=sensor_format.format('{}:'.format(sensor[1]), reading, width=str(max_name_width+1)) output +='\\n' return output def read_fan_sensors(num_fans, ipmi_sdr_elist): sensor_list=[ ('Fan{}_Status', 'Status'), ('Fan{}_Front', 'Fan{} front'), ('Fan{}_Rear', 'Fan{} rear'), ] output='' sensor_format='{0:{width}}{1}\\n' max_name_width=max(len(sensor[1]) for sensor in sensor_list) output +=\"Fan Trays\\n\" output +=\"Adapter: IPMI adapter\\n\" for fan_num in range(1, num_fans+1): for sensor in sensor_list: ipmi_sensor_name=sensor[0].format(fan_num) display_sensor_name=sensor[1].format(fan_num) reading=get_reading_by_name(ipmi_sensor_name, ipmi_sdr_elist) output +=sensor_format.format('{}:'.format(display_sensor_name), reading, width=str(max_name_width+1)) output +='\\n' return output def read_psu_sensors(num_psus, ipmi_sdr_elist): sensor_list=[ ('PSU{}_Status', 'PSU{} Status'), ('PSU{}_Fan', 'PSU{} Fan'), ('PSU{}_VIn', 'PSU{} Input Voltag'), ('PSU{}_CIn', 'PSU{} Input Current'), ('PSU{}_PIn', 'PSU{} Input Power'), ('PSU{}_Temp1', 'PSU{} Temp1'), ('PSU{}_Temp2', 'PSU{} Temp2'), ('PSU{}_VOut', 'PSU{} Output Voltag'), ('PSU{}_COut', 'PSU{} Output Current'), ('PSU{}_POut', 'PSU{} Output Power'), ] output='' sensor_format='{0:{width}}{1}\\n' max_name_width=max(len(sensor[1]) for sensor in sensor_list) output +=\"PSU\\n\" output +=\"Adapter: IPMI adapter\\n\" for psu_num in range(1, num_psus+1): for sensor in sensor_list: ipmi_sensor_name=sensor[0].format(psu_num) display_sensor_name=sensor[1].format(psu_num) reading=get_reading_by_name(ipmi_sensor_name, ipmi_sdr_elist) output +=sensor_format.format('{}:'.format(display_sensor_name), reading, width=str(max_name_width+1)) output +='\\n' return output def main(): output_string='' ipmi_sdr_elist=ipmi_sensor_dump(IPMI_SDR_CMD) output_string +=read_temperature_sensors(ipmi_sdr_elist) output_string +=read_psu_sensors(MAX_NUM_PSUS, ipmi_sdr_elist) output_string +=read_fan_sensors(MAX_NUM_FANS, ipmi_sdr_elist) print(output_string) if __name__=='__main__': main() ", "sourceWithComments": "#!/usr/bin/python\n#\n# Silverstone platform sensors. This script get the sensor data from BMC \n# using ipmitool and display them in lm-sensor alike format.\n#\n# The following data is support:\n#  1. Temperature sensors\n#  2. PSUs\n#  3. Fan trays\n\nimport sys\nimport logging\nimport subprocess\n\nIPMI_SDR_CMD = \"ipmitool sdr elist\"\nMAX_NUM_FANS = 7\nMAX_NUM_PSUS = 2\n\n\ndef ipmi_sensor_dump(cmd):\n    ''' Execute ipmitool command return dump output\n        exit if any error occur.\n    '''\n    sensor_dump = ''\n    try:\n        sensor_dump = subprocess.check_output(cmd, shell=True)\n    except subprocess.CalledProcessError as e:\n        logging.error('Error! Failed to execute: {}'.format(cmd))\n        sys.exit(1)\n    return sensor_dump\n\ndef get_reading_by_name(sensor_name, sdr_elist_dump):\n    '''\n        Search for the match sensor name, return sensor\n        reading value and unit, return object epmtry string \n        if search not match.\n\n        The output of sensor dump:\n        TEMP_FAN_U52     | 00h | ok  |  7.1 | 31 degrees C\n        TEMP_FAN_U17     | 01h | ok  |  7.1 | 27 degrees C\n        TEMP_SW_U52      | 02h | ok  |  7.1 | 30 degrees C\n        Fan2_Status      | 07h | ok  | 29.2 | Present\n        Fan2_Front       | 0Eh | ok  | 29.2 | 12000 RPM\n        Fan2_Rear        | 46h | ok  | 29.2 | 14700 RPM\n        PSU2_Status      | 39h | ok  | 10.2 | Presence detected\n        PSU2_Fan         | 3Dh | ok  | 10.2 | 16000 RPM\n        PSU2_VIn         | 3Ah | ok  | 10.2 | 234.30 Volts\n        PSU2_CIn         | 3Bh | ok  | 10.2 | 0.80 Amps\n    '''\n    found = ''\n\n    for line in sdr_elist_dump.split(\"\\n\"):\n        if sensor_name in line:\n            found = line.strip()\n            break\n\n    if not found:\n        logging.error('Cannot find sensor name:' + sensor_name)\n\n    else:\n        try:\n            found = found.split('|')[4]\n        except IndexError:\n            logging.error('Cannot get sensor data of:' + sensor_name)\n\n    logging.basicConfig(level=logging.DEBUG)\n    return found\n\n\ndef read_temperature_sensors(ipmi_sdr_elist):\n\n    sensor_list = [\n        ('TEMP_FAN_U52',        'Fan Tray Middle Temp'),\n        ('TEMP_FAN_U17',        'Fan Tray Right Temp'),\n        ('TEMP_SW_U52',         'Switchboard Left Inlet Temp'),\n        ('TEMP_SW_U16',         'Switchboard Right Inlet Temp'),\n        ('TEMP_BB_U3',          'Baseboard Temp'),\n        ('TEMP_CPU',            'CPU Internal Temp'),\n        ('TEMP_SW_Internal',    'ASIC Internal Temp'),\n        ('SW_U04_Temp',         'IR3595 Chip Left Temp'),\n        ('SW_U14_Temp',         'IR3595 Chip Right Temp'),\n        ('SW_U4403_Temp',       'IR3584 Chip Temp'),\n    ]\n\n    output = ''\n    sensor_format = '{0:{width}}{1}\\n'\n    # Find max length of sensor calling name\n    max_name_width = max(len(sensor[1]) for sensor in sensor_list)\n\n    output += \"Temperature Sensors\\n\"\n    output += \"Adapter: IPMI adapter\\n\"\n    for sensor in sensor_list:\n        reading = get_reading_by_name(sensor[0],ipmi_sdr_elist)\n        output += sensor_format.format('{}:'.format(sensor[1]),\n                                       reading,\n                                       width=str(max_name_width+1))\n    output += '\\n'\n    return output\n\n\ndef read_fan_sensors(num_fans, ipmi_sdr_elist):\n\n    sensor_list = [\n        ('Fan{}_Status',    'Status'),\n        ('Fan{}_Front',     'Fan {} front'),\n        ('Fan{}_Rear',      'Fan {} rear'),\n    ]\n\n    output = ''\n    sensor_format = '{0:{width}}{1}\\n'\n    # Find max length of sensor calling name\n    max_name_width = max(len(sensor[1]) for sensor in sensor_list)\n\n    output += \"Fan Trays\\n\"\n    output += \"Adapter: IPMI adapter\\n\"\n    for fan_num in range(1, num_fans+1):\n        for sensor in sensor_list:\n            ipmi_sensor_name = sensor[0].format(fan_num)\n            display_sensor_name = sensor[1].format(fan_num)\n            reading = get_reading_by_name(ipmi_sensor_name, ipmi_sdr_elist)\n            output += sensor_format.format('{}:'.format(display_sensor_name),\n                                           reading,\n                                           width=str(max_name_width+1))\n    output += '\\n'\n    return output\n\n\ndef read_psu_sensors(num_psus, ipmi_sdr_elist):\n\n    sensor_list = [\n        ('PSU{}_Status',    'PSU {} Status'),\n        ('PSU{}_Fan',       'PSU {} Fan'),\n        ('PSU{}_VIn',       'PSU {} Input Voltag'),\n        ('PSU{}_CIn',       'PSU {} Input Current'),\n        ('PSU{}_PIn',       'PSU {} Input Power'),\n        ('PSU{}_Temp1',     'PSU {} Temp1'),\n        ('PSU{}_Temp2',     'PSU {} Temp2'),\n        ('PSU{}_VOut',      'PSU {} Output Voltag'),\n        ('PSU{}_COut',      'PSU {} Output Current'),\n        ('PSU{}_POut',      'PSU {} Output Power'),\n    ]\n\n    output = ''\n    sensor_format = '{0:{width}}{1}\\n'\n    # Find max length of sensor calling name\n    max_name_width = max(len(sensor[1]) for sensor in sensor_list)\n\n    output += \"PSU\\n\"\n    output += \"Adapter: IPMI adapter\\n\"\n    for psu_num in range(1, num_psus+1):\n        for sensor in sensor_list:\n            ipmi_sensor_name = sensor[0].format(psu_num)\n            display_sensor_name = sensor[1].format(psu_num)\n            reading = get_reading_by_name(ipmi_sensor_name, ipmi_sdr_elist)\n            output += sensor_format.format('{}:'.format(display_sensor_name),\n                                           reading,\n                                           width=str(max_name_width+1))\n    output += '\\n'\n    return output\n\n\ndef main():\n    output_string = ''\n\n    ipmi_sdr_elist = ipmi_sensor_dump(IPMI_SDR_CMD)\n    output_string += read_temperature_sensors(ipmi_sdr_elist)\n    output_string += read_psu_sensors(MAX_NUM_PSUS, ipmi_sdr_elist)\n    output_string += read_fan_sensors(MAX_NUM_FANS, ipmi_sdr_elist)\n    print(output_string)\n\n\nif __name__ == '__main__':\n    main()\n"}}, "msg": "[device/celestica] Mitigation for command injection vulnerability (#11740)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\nDependency: [PR (#12065)](https://github.com/sonic-net/sonic-buildimage/pull/12065) needs to merge first.\r\n#### Why I did it\r\n1. `eval()` - not secure against maliciously constructed input, can be dangerous if used to evaluate dynamic content. This may be a code injection vulnerability.\r\n2. `subprocess()` - when using with `shell=True` is dangerous. Using subprocess function without a static string can lead to command injection.\r\n3. `os` - not secure against maliciously constructed input and dangerous if used to evaluate dynamic content.\r\n4. `is` operator - string comparison should not be used with reference equality.\r\n5. `globals()` - extremely dangerous because it may allow an attacker to execute arbitrary code on the system\r\n#### How I did it\r\n1. `eval()` - use `literal_eval()`\r\n2. `subprocess()` - use `shell=False` instead. use an array string. Ref: [https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation](https://semgrep.dev/docs/cheat-sheets/python-command-injection/#mitigation)\r\n3. `os` - use with `subprocess`\r\n4. `is` - replace by `==` operator for value equality\r\n5. `globals()` - avoid the use of globals()"}}, "https://github.com/lmchale/linux": {"983e20cfdcb6e08b3560071a147169f3a1be4391": {"url": "https://api.github.com/repos/lmchale/linux/commits/983e20cfdcb6e08b3560071a147169f3a1be4391", "html_url": "https://github.com/lmchale/linux/commit/983e20cfdcb6e08b3560071a147169f3a1be4391", "sha": "983e20cfdcb6e08b3560071a147169f3a1be4391", "keyword": "command injection change", "diff": "diff --git a/Documentation/sphinx/kernel_feat.py b/Documentation/sphinx/kernel_feat.py\nindex b9df61eb45013..03ace5f01b5c0 100644\n--- a/Documentation/sphinx/kernel_feat.py\n+++ b/Documentation/sphinx/kernel_feat.py\n@@ -109,7 +109,7 @@ def run(self):\n             else:\n                 out_lines += line + \"\\n\"\n \n-        nodeList = self.nestedParse(out_lines, fname)\n+        nodeList = self.nestedParse(out_lines, self.arguments[0])\n         return nodeList\n \n     def nestedParse(self, lines, fname):\n", "message": "", "files": {"/Documentation/sphinx/kernel_feat.py": {"changes": [{"diff": "\n             else:\n                 out_lines += line + \"\\n\"\n \n-        nodeList = self.nestedParse(out_lines, fname)\n+        nodeList = self.nestedParse(out_lines, self.arguments[0])\n         return nodeList\n \n     def nestedParse(self, lines, fname):\n", "add": 1, "remove": 1, "filename": "/Documentation/sphinx/kernel_feat.py", "badparts": ["        nodeList = self.nestedParse(out_lines, fname)"], "goodparts": ["        nodeList = self.nestedParse(out_lines, self.arguments[0])"]}], "source": "\n u\"\"\" kernel-feat ~~~~~~~~~~~ Implementation of the ``kernel-feat`` reST-directive. :copyright: Copyright(C) 2016 Markus Heiser :copyright: Copyright(C) 2016-2019 Mauro Carvalho Chehab :maintained-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org> :license: GPL Version 2, June 1991 see Linux/COPYING for details. The ``kernel-feat``(:py:class:`KernelFeat`) directive calls the scripts/get_feat.pl script to parse the Kernel ABI files. Overview of directive's argument and options. .. code-block:: rst .. kernel-feat:: <ABI directory location> :debug: The argument ``<ABI directory location>`` is required. It contains the location of the ABI files to be parsed. ``debug`` Inserts a code-block with the *raw* reST. Sometimes it is helpful to see what reST is generated. \"\"\" import codecs import os import re import subprocess import sys from docutils import nodes, statemachine from docutils.statemachine import ViewList from docutils.parsers.rst import directives, Directive from docutils.utils.error_reporting import ErrorString from sphinx.util.docutils import switch_source_input __version__ ='1.0' def setup(app): app.add_directive(\"kernel-feat\", KernelFeat) return dict( version=__version__ , parallel_read_safe=True , parallel_write_safe=True ) class KernelFeat(Directive): u\"\"\"KernelFeat(``kernel-feat``) directive\"\"\" required_arguments=1 optional_arguments=2 has_content=False final_argument_whitespace=True option_spec={ \"debug\" : directives.flag } def warn(self, message, **replace): replace[\"fname\"] =self.state.document.current_source replace[\"line_no\"]=replace.get(\"line_no\", self.lineno) message=(\"%(fname)s:%(line_no)s:[kernel-feat WARN]: \" +message) % replace self.state.document.settings.env.app.warn(message, prefix=\"\") def run(self): doc=self.state.document if not doc.settings.file_insertion_enabled: raise self.warning(\"docutils: file insertion disabled\") env=doc.settings.env srctree=os.path.abspath(os.environ[\"srctree\"]) args=[ os.path.join(srctree, 'scripts/get_feat.pl'), 'rest', '--enable-fname', '--dir', os.path.join(srctree, 'Documentation', self.arguments[0]), ] if len(self.arguments) > 1: args.extend(['--arch', self.arguments[1]]) lines=subprocess.check_output(args, cwd=os.path.dirname(doc.current_source)).decode('utf-8') line_regex=re.compile(r\"^\\.\\. FILE(\\S+)$\") out_lines=\"\" for line in lines.split(\"\\n\"): match=line_regex.search(line) if match: fname=match.group(1) env.note_dependency(os.path.abspath(fname)) else: out_lines +=line +\"\\n\" nodeList=self.nestedParse(out_lines, fname) return nodeList def nestedParse(self, lines, fname): content=ViewList() node =nodes.section() if \"debug\" in self.options: code_block=\"\\n\\n.. code-block:: rst\\n :linenos:\\n\" for l in lines.split(\"\\n\"): code_block +=\"\\n \" +l lines=code_block +\"\\n\\n\" for c, l in enumerate(lines.split(\"\\n\")): content.append(l, fname, c) buf =self.state.memo.title_styles, self.state.memo.section_level, self.state.memo.reporter with switch_source_input(self.state, content): self.state.nested_parse(content, 0, node, match_titles=1) return node.children ", "sourceWithComments": "# coding=utf-8\n# SPDX-License-Identifier: GPL-2.0\n#\nu\"\"\"\n    kernel-feat\n    ~~~~~~~~~~~\n\n    Implementation of the ``kernel-feat`` reST-directive.\n\n    :copyright:  Copyright (C) 2016  Markus Heiser\n    :copyright:  Copyright (C) 2016-2019  Mauro Carvalho Chehab\n    :maintained-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>\n    :license:    GPL Version 2, June 1991 see Linux/COPYING for details.\n\n    The ``kernel-feat`` (:py:class:`KernelFeat`) directive calls the\n    scripts/get_feat.pl script to parse the Kernel ABI files.\n\n    Overview of directive's argument and options.\n\n    .. code-block:: rst\n\n        .. kernel-feat:: <ABI directory location>\n            :debug:\n\n    The argument ``<ABI directory location>`` is required. It contains the\n    location of the ABI files to be parsed.\n\n    ``debug``\n      Inserts a code-block with the *raw* reST. Sometimes it is helpful to see\n      what reST is generated.\n\n\"\"\"\n\nimport codecs\nimport os\nimport re\nimport subprocess\nimport sys\n\nfrom docutils import nodes, statemachine\nfrom docutils.statemachine import ViewList\nfrom docutils.parsers.rst import directives, Directive\nfrom docutils.utils.error_reporting import ErrorString\nfrom sphinx.util.docutils import switch_source_input\n\n__version__  = '1.0'\n\ndef setup(app):\n\n    app.add_directive(\"kernel-feat\", KernelFeat)\n    return dict(\n        version = __version__\n        , parallel_read_safe = True\n        , parallel_write_safe = True\n    )\n\nclass KernelFeat(Directive):\n\n    u\"\"\"KernelFeat (``kernel-feat``) directive\"\"\"\n\n    required_arguments = 1\n    optional_arguments = 2\n    has_content = False\n    final_argument_whitespace = True\n\n    option_spec = {\n        \"debug\"     : directives.flag\n    }\n\n    def warn(self, message, **replace):\n        replace[\"fname\"]   = self.state.document.current_source\n        replace[\"line_no\"] = replace.get(\"line_no\", self.lineno)\n        message = (\"%(fname)s:%(line_no)s: [kernel-feat WARN] : \" + message) % replace\n        self.state.document.settings.env.app.warn(message, prefix=\"\")\n\n    def run(self):\n        doc = self.state.document\n        if not doc.settings.file_insertion_enabled:\n            raise self.warning(\"docutils: file insertion disabled\")\n\n        env = doc.settings.env\n\n        srctree = os.path.abspath(os.environ[\"srctree\"])\n\n        args = [\n            os.path.join(srctree, 'scripts/get_feat.pl'),\n            'rest',\n            '--enable-fname',\n            '--dir',\n            os.path.join(srctree, 'Documentation', self.arguments[0]),\n        ]\n\n        if len(self.arguments) > 1:\n            args.extend(['--arch', self.arguments[1]])\n\n        lines = subprocess.check_output(args, cwd=os.path.dirname(doc.current_source)).decode('utf-8')\n\n        line_regex = re.compile(r\"^\\.\\. FILE (\\S+)$\")\n\n        out_lines = \"\"\n\n        for line in lines.split(\"\\n\"):\n            match = line_regex.search(line)\n            if match:\n                fname = match.group(1)\n\n                # Add the file to Sphinx build dependencies\n                env.note_dependency(os.path.abspath(fname))\n            else:\n                out_lines += line + \"\\n\"\n\n        nodeList = self.nestedParse(out_lines, fname)\n        return nodeList\n\n    def nestedParse(self, lines, fname):\n        content = ViewList()\n        node    = nodes.section()\n\n        if \"debug\" in self.options:\n            code_block = \"\\n\\n.. code-block:: rst\\n    :linenos:\\n\"\n            for l in lines.split(\"\\n\"):\n                code_block += \"\\n    \" + l\n            lines = code_block + \"\\n\\n\"\n\n        for c, l in enumerate(lines.split(\"\\n\")):\n            content.append(l, fname, c)\n\n        buf  = self.state.memo.title_styles, self.state.memo.section_level, self.state.memo.reporter\n\n        with switch_source_input(self.state, content):\n            self.state.nested_parse(content, 0, node, match_titles=1)\n\n        return node.children\n"}}, "msg": "docs: kernel_feat.py: fix build error for missing files\n\nIf the directory passed to the '.. kernel-feat::' directive does not\nexist or the get_feat.pl script does not find any files to extract\nfeatures from, Sphinx will report the following error:\n\n    Sphinx parallel build error:\n    UnboundLocalError: local variable 'fname' referenced before assignment\n    make[2]: *** [Documentation/Makefile:102: htmldocs] Error 2\n\nThis is due to how I changed the script in c48a7c44a1d0 (\"docs:\nkernel_feat.py: fix potential command injection\"). Before that, the\nfilename passed along to self.nestedParse() in this case was weirdly\njust the whole get_feat.pl invocation.\n\nWe can fix it by doing what kernel_abi.py does -- just pass\nself.arguments[0] as 'fname'.\n\nFixes: c48a7c44a1d0 (\"docs: kernel_feat.py: fix potential command injection\")\nCc: Justin Forbes <jforbes@fedoraproject.org>\nCc: Salvatore Bonaccorso <carnil@debian.org>\nCc: Jani Nikula <jani.nikula@intel.com>\nCc: Mauro Carvalho Chehab <mchehab@kernel.org>\nCc: stable@vger.kernel.org\nSigned-off-by: Vegard Nossum <vegard.nossum@oracle.com>\nLink: https://lore.kernel.org/r/20240205175133.774271-2-vegard.nossum@oracle.com\nSigned-off-by: Jonathan Corbet <corbet@lwn.net>"}}, "https://github.com/googleprodkernel/linux-perf": {"983e20cfdcb6e08b3560071a147169f3a1be4391": {"url": "https://api.github.com/repos/googleprodkernel/linux-perf/commits/983e20cfdcb6e08b3560071a147169f3a1be4391", "html_url": "https://github.com/googleprodkernel/linux-perf/commit/983e20cfdcb6e08b3560071a147169f3a1be4391", "sha": "983e20cfdcb6e08b3560071a147169f3a1be4391", "keyword": "command injection change", "diff": "diff --git a/Documentation/sphinx/kernel_feat.py b/Documentation/sphinx/kernel_feat.py\nindex b9df61eb4501..03ace5f01b5c 100644\n--- a/Documentation/sphinx/kernel_feat.py\n+++ b/Documentation/sphinx/kernel_feat.py\n@@ -109,7 +109,7 @@ def run(self):\n             else:\n                 out_lines += line + \"\\n\"\n \n-        nodeList = self.nestedParse(out_lines, fname)\n+        nodeList = self.nestedParse(out_lines, self.arguments[0])\n         return nodeList\n \n     def nestedParse(self, lines, fname):\n", "message": "", "files": {"/Documentation/sphinx/kernel_feat.py": {"changes": [{"diff": "\n             else:\n                 out_lines += line + \"\\n\"\n \n-        nodeList = self.nestedParse(out_lines, fname)\n+        nodeList = self.nestedParse(out_lines, self.arguments[0])\n         return nodeList\n \n     def nestedParse(self, lines, fname):\n", "add": 1, "remove": 1, "filename": "/Documentation/sphinx/kernel_feat.py", "badparts": ["        nodeList = self.nestedParse(out_lines, fname)"], "goodparts": ["        nodeList = self.nestedParse(out_lines, self.arguments[0])"]}], "source": "\n u\"\"\" kernel-feat ~~~~~~~~~~~ Implementation of the ``kernel-feat`` reST-directive. :copyright: Copyright(C) 2016 Markus Heiser :copyright: Copyright(C) 2016-2019 Mauro Carvalho Chehab :maintained-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org> :license: GPL Version 2, June 1991 see Linux/COPYING for details. The ``kernel-feat``(:py:class:`KernelFeat`) directive calls the scripts/get_feat.pl script to parse the Kernel ABI files. Overview of directive's argument and options. .. code-block:: rst .. kernel-feat:: <ABI directory location> :debug: The argument ``<ABI directory location>`` is required. It contains the location of the ABI files to be parsed. ``debug`` Inserts a code-block with the *raw* reST. Sometimes it is helpful to see what reST is generated. \"\"\" import codecs import os import re import subprocess import sys from docutils import nodes, statemachine from docutils.statemachine import ViewList from docutils.parsers.rst import directives, Directive from docutils.utils.error_reporting import ErrorString from sphinx.util.docutils import switch_source_input __version__ ='1.0' def setup(app): app.add_directive(\"kernel-feat\", KernelFeat) return dict( version=__version__ , parallel_read_safe=True , parallel_write_safe=True ) class KernelFeat(Directive): u\"\"\"KernelFeat(``kernel-feat``) directive\"\"\" required_arguments=1 optional_arguments=2 has_content=False final_argument_whitespace=True option_spec={ \"debug\" : directives.flag } def warn(self, message, **replace): replace[\"fname\"] =self.state.document.current_source replace[\"line_no\"]=replace.get(\"line_no\", self.lineno) message=(\"%(fname)s:%(line_no)s:[kernel-feat WARN]: \" +message) % replace self.state.document.settings.env.app.warn(message, prefix=\"\") def run(self): doc=self.state.document if not doc.settings.file_insertion_enabled: raise self.warning(\"docutils: file insertion disabled\") env=doc.settings.env srctree=os.path.abspath(os.environ[\"srctree\"]) args=[ os.path.join(srctree, 'scripts/get_feat.pl'), 'rest', '--enable-fname', '--dir', os.path.join(srctree, 'Documentation', self.arguments[0]), ] if len(self.arguments) > 1: args.extend(['--arch', self.arguments[1]]) lines=subprocess.check_output(args, cwd=os.path.dirname(doc.current_source)).decode('utf-8') line_regex=re.compile(r\"^\\.\\. FILE(\\S+)$\") out_lines=\"\" for line in lines.split(\"\\n\"): match=line_regex.search(line) if match: fname=match.group(1) env.note_dependency(os.path.abspath(fname)) else: out_lines +=line +\"\\n\" nodeList=self.nestedParse(out_lines, fname) return nodeList def nestedParse(self, lines, fname): content=ViewList() node =nodes.section() if \"debug\" in self.options: code_block=\"\\n\\n.. code-block:: rst\\n :linenos:\\n\" for l in lines.split(\"\\n\"): code_block +=\"\\n \" +l lines=code_block +\"\\n\\n\" for c, l in enumerate(lines.split(\"\\n\")): content.append(l, fname, c) buf =self.state.memo.title_styles, self.state.memo.section_level, self.state.memo.reporter with switch_source_input(self.state, content): self.state.nested_parse(content, 0, node, match_titles=1) return node.children ", "sourceWithComments": "# coding=utf-8\n# SPDX-License-Identifier: GPL-2.0\n#\nu\"\"\"\n    kernel-feat\n    ~~~~~~~~~~~\n\n    Implementation of the ``kernel-feat`` reST-directive.\n\n    :copyright:  Copyright (C) 2016  Markus Heiser\n    :copyright:  Copyright (C) 2016-2019  Mauro Carvalho Chehab\n    :maintained-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>\n    :license:    GPL Version 2, June 1991 see Linux/COPYING for details.\n\n    The ``kernel-feat`` (:py:class:`KernelFeat`) directive calls the\n    scripts/get_feat.pl script to parse the Kernel ABI files.\n\n    Overview of directive's argument and options.\n\n    .. code-block:: rst\n\n        .. kernel-feat:: <ABI directory location>\n            :debug:\n\n    The argument ``<ABI directory location>`` is required. It contains the\n    location of the ABI files to be parsed.\n\n    ``debug``\n      Inserts a code-block with the *raw* reST. Sometimes it is helpful to see\n      what reST is generated.\n\n\"\"\"\n\nimport codecs\nimport os\nimport re\nimport subprocess\nimport sys\n\nfrom docutils import nodes, statemachine\nfrom docutils.statemachine import ViewList\nfrom docutils.parsers.rst import directives, Directive\nfrom docutils.utils.error_reporting import ErrorString\nfrom sphinx.util.docutils import switch_source_input\n\n__version__  = '1.0'\n\ndef setup(app):\n\n    app.add_directive(\"kernel-feat\", KernelFeat)\n    return dict(\n        version = __version__\n        , parallel_read_safe = True\n        , parallel_write_safe = True\n    )\n\nclass KernelFeat(Directive):\n\n    u\"\"\"KernelFeat (``kernel-feat``) directive\"\"\"\n\n    required_arguments = 1\n    optional_arguments = 2\n    has_content = False\n    final_argument_whitespace = True\n\n    option_spec = {\n        \"debug\"     : directives.flag\n    }\n\n    def warn(self, message, **replace):\n        replace[\"fname\"]   = self.state.document.current_source\n        replace[\"line_no\"] = replace.get(\"line_no\", self.lineno)\n        message = (\"%(fname)s:%(line_no)s: [kernel-feat WARN] : \" + message) % replace\n        self.state.document.settings.env.app.warn(message, prefix=\"\")\n\n    def run(self):\n        doc = self.state.document\n        if not doc.settings.file_insertion_enabled:\n            raise self.warning(\"docutils: file insertion disabled\")\n\n        env = doc.settings.env\n\n        srctree = os.path.abspath(os.environ[\"srctree\"])\n\n        args = [\n            os.path.join(srctree, 'scripts/get_feat.pl'),\n            'rest',\n            '--enable-fname',\n            '--dir',\n            os.path.join(srctree, 'Documentation', self.arguments[0]),\n        ]\n\n        if len(self.arguments) > 1:\n            args.extend(['--arch', self.arguments[1]])\n\n        lines = subprocess.check_output(args, cwd=os.path.dirname(doc.current_source)).decode('utf-8')\n\n        line_regex = re.compile(r\"^\\.\\. FILE (\\S+)$\")\n\n        out_lines = \"\"\n\n        for line in lines.split(\"\\n\"):\n            match = line_regex.search(line)\n            if match:\n                fname = match.group(1)\n\n                # Add the file to Sphinx build dependencies\n                env.note_dependency(os.path.abspath(fname))\n            else:\n                out_lines += line + \"\\n\"\n\n        nodeList = self.nestedParse(out_lines, fname)\n        return nodeList\n\n    def nestedParse(self, lines, fname):\n        content = ViewList()\n        node    = nodes.section()\n\n        if \"debug\" in self.options:\n            code_block = \"\\n\\n.. code-block:: rst\\n    :linenos:\\n\"\n            for l in lines.split(\"\\n\"):\n                code_block += \"\\n    \" + l\n            lines = code_block + \"\\n\\n\"\n\n        for c, l in enumerate(lines.split(\"\\n\")):\n            content.append(l, fname, c)\n\n        buf  = self.state.memo.title_styles, self.state.memo.section_level, self.state.memo.reporter\n\n        with switch_source_input(self.state, content):\n            self.state.nested_parse(content, 0, node, match_titles=1)\n\n        return node.children\n"}}, "msg": "docs: kernel_feat.py: fix build error for missing files\n\nIf the directory passed to the '.. kernel-feat::' directive does not\nexist or the get_feat.pl script does not find any files to extract\nfeatures from, Sphinx will report the following error:\n\n    Sphinx parallel build error:\n    UnboundLocalError: local variable 'fname' referenced before assignment\n    make[2]: *** [Documentation/Makefile:102: htmldocs] Error 2\n\nThis is due to how I changed the script in c48a7c44a1d0 (\"docs:\nkernel_feat.py: fix potential command injection\"). Before that, the\nfilename passed along to self.nestedParse() in this case was weirdly\njust the whole get_feat.pl invocation.\n\nWe can fix it by doing what kernel_abi.py does -- just pass\nself.arguments[0] as 'fname'.\n\nFixes: c48a7c44a1d0 (\"docs: kernel_feat.py: fix potential command injection\")\nCc: Justin Forbes <jforbes@fedoraproject.org>\nCc: Salvatore Bonaccorso <carnil@debian.org>\nCc: Jani Nikula <jani.nikula@intel.com>\nCc: Mauro Carvalho Chehab <mchehab@kernel.org>\nCc: stable@vger.kernel.org\nSigned-off-by: Vegard Nossum <vegard.nossum@oracle.com>\nLink: https://lore.kernel.org/r/20240205175133.774271-2-vegard.nossum@oracle.com\nSigned-off-by: Jonathan Corbet <corbet@lwn.net>"}}, "https://github.com/openSUSE/kernel": {"983e20cfdcb6e08b3560071a147169f3a1be4391": {"url": "https://api.github.com/repos/openSUSE/kernel/commits/983e20cfdcb6e08b3560071a147169f3a1be4391", "html_url": "https://github.com/openSUSE/kernel/commit/983e20cfdcb6e08b3560071a147169f3a1be4391", "sha": "983e20cfdcb6e08b3560071a147169f3a1be4391", "keyword": "command injection change", "diff": "diff --git a/Documentation/sphinx/kernel_feat.py b/Documentation/sphinx/kernel_feat.py\nindex b9df61eb45013..03ace5f01b5c0 100644\n--- a/Documentation/sphinx/kernel_feat.py\n+++ b/Documentation/sphinx/kernel_feat.py\n@@ -109,7 +109,7 @@ def run(self):\n             else:\n                 out_lines += line + \"\\n\"\n \n-        nodeList = self.nestedParse(out_lines, fname)\n+        nodeList = self.nestedParse(out_lines, self.arguments[0])\n         return nodeList\n \n     def nestedParse(self, lines, fname):\n", "message": "", "files": {"/Documentation/sphinx/kernel_feat.py": {"changes": [{"diff": "\n             else:\n                 out_lines += line + \"\\n\"\n \n-        nodeList = self.nestedParse(out_lines, fname)\n+        nodeList = self.nestedParse(out_lines, self.arguments[0])\n         return nodeList\n \n     def nestedParse(self, lines, fname):\n", "add": 1, "remove": 1, "filename": "/Documentation/sphinx/kernel_feat.py", "badparts": ["        nodeList = self.nestedParse(out_lines, fname)"], "goodparts": ["        nodeList = self.nestedParse(out_lines, self.arguments[0])"]}], "source": "\n u\"\"\" kernel-feat ~~~~~~~~~~~ Implementation of the ``kernel-feat`` reST-directive. :copyright: Copyright(C) 2016 Markus Heiser :copyright: Copyright(C) 2016-2019 Mauro Carvalho Chehab :maintained-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org> :license: GPL Version 2, June 1991 see Linux/COPYING for details. The ``kernel-feat``(:py:class:`KernelFeat`) directive calls the scripts/get_feat.pl script to parse the Kernel ABI files. Overview of directive's argument and options. .. code-block:: rst .. kernel-feat:: <ABI directory location> :debug: The argument ``<ABI directory location>`` is required. It contains the location of the ABI files to be parsed. ``debug`` Inserts a code-block with the *raw* reST. Sometimes it is helpful to see what reST is generated. \"\"\" import codecs import os import re import subprocess import sys from docutils import nodes, statemachine from docutils.statemachine import ViewList from docutils.parsers.rst import directives, Directive from docutils.utils.error_reporting import ErrorString from sphinx.util.docutils import switch_source_input __version__ ='1.0' def setup(app): app.add_directive(\"kernel-feat\", KernelFeat) return dict( version=__version__ , parallel_read_safe=True , parallel_write_safe=True ) class KernelFeat(Directive): u\"\"\"KernelFeat(``kernel-feat``) directive\"\"\" required_arguments=1 optional_arguments=2 has_content=False final_argument_whitespace=True option_spec={ \"debug\" : directives.flag } def warn(self, message, **replace): replace[\"fname\"] =self.state.document.current_source replace[\"line_no\"]=replace.get(\"line_no\", self.lineno) message=(\"%(fname)s:%(line_no)s:[kernel-feat WARN]: \" +message) % replace self.state.document.settings.env.app.warn(message, prefix=\"\") def run(self): doc=self.state.document if not doc.settings.file_insertion_enabled: raise self.warning(\"docutils: file insertion disabled\") env=doc.settings.env srctree=os.path.abspath(os.environ[\"srctree\"]) args=[ os.path.join(srctree, 'scripts/get_feat.pl'), 'rest', '--enable-fname', '--dir', os.path.join(srctree, 'Documentation', self.arguments[0]), ] if len(self.arguments) > 1: args.extend(['--arch', self.arguments[1]]) lines=subprocess.check_output(args, cwd=os.path.dirname(doc.current_source)).decode('utf-8') line_regex=re.compile(r\"^\\.\\. FILE(\\S+)$\") out_lines=\"\" for line in lines.split(\"\\n\"): match=line_regex.search(line) if match: fname=match.group(1) env.note_dependency(os.path.abspath(fname)) else: out_lines +=line +\"\\n\" nodeList=self.nestedParse(out_lines, fname) return nodeList def nestedParse(self, lines, fname): content=ViewList() node =nodes.section() if \"debug\" in self.options: code_block=\"\\n\\n.. code-block:: rst\\n :linenos:\\n\" for l in lines.split(\"\\n\"): code_block +=\"\\n \" +l lines=code_block +\"\\n\\n\" for c, l in enumerate(lines.split(\"\\n\")): content.append(l, fname, c) buf =self.state.memo.title_styles, self.state.memo.section_level, self.state.memo.reporter with switch_source_input(self.state, content): self.state.nested_parse(content, 0, node, match_titles=1) return node.children ", "sourceWithComments": "# coding=utf-8\n# SPDX-License-Identifier: GPL-2.0\n#\nu\"\"\"\n    kernel-feat\n    ~~~~~~~~~~~\n\n    Implementation of the ``kernel-feat`` reST-directive.\n\n    :copyright:  Copyright (C) 2016  Markus Heiser\n    :copyright:  Copyright (C) 2016-2019  Mauro Carvalho Chehab\n    :maintained-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>\n    :license:    GPL Version 2, June 1991 see Linux/COPYING for details.\n\n    The ``kernel-feat`` (:py:class:`KernelFeat`) directive calls the\n    scripts/get_feat.pl script to parse the Kernel ABI files.\n\n    Overview of directive's argument and options.\n\n    .. code-block:: rst\n\n        .. kernel-feat:: <ABI directory location>\n            :debug:\n\n    The argument ``<ABI directory location>`` is required. It contains the\n    location of the ABI files to be parsed.\n\n    ``debug``\n      Inserts a code-block with the *raw* reST. Sometimes it is helpful to see\n      what reST is generated.\n\n\"\"\"\n\nimport codecs\nimport os\nimport re\nimport subprocess\nimport sys\n\nfrom docutils import nodes, statemachine\nfrom docutils.statemachine import ViewList\nfrom docutils.parsers.rst import directives, Directive\nfrom docutils.utils.error_reporting import ErrorString\nfrom sphinx.util.docutils import switch_source_input\n\n__version__  = '1.0'\n\ndef setup(app):\n\n    app.add_directive(\"kernel-feat\", KernelFeat)\n    return dict(\n        version = __version__\n        , parallel_read_safe = True\n        , parallel_write_safe = True\n    )\n\nclass KernelFeat(Directive):\n\n    u\"\"\"KernelFeat (``kernel-feat``) directive\"\"\"\n\n    required_arguments = 1\n    optional_arguments = 2\n    has_content = False\n    final_argument_whitespace = True\n\n    option_spec = {\n        \"debug\"     : directives.flag\n    }\n\n    def warn(self, message, **replace):\n        replace[\"fname\"]   = self.state.document.current_source\n        replace[\"line_no\"] = replace.get(\"line_no\", self.lineno)\n        message = (\"%(fname)s:%(line_no)s: [kernel-feat WARN] : \" + message) % replace\n        self.state.document.settings.env.app.warn(message, prefix=\"\")\n\n    def run(self):\n        doc = self.state.document\n        if not doc.settings.file_insertion_enabled:\n            raise self.warning(\"docutils: file insertion disabled\")\n\n        env = doc.settings.env\n\n        srctree = os.path.abspath(os.environ[\"srctree\"])\n\n        args = [\n            os.path.join(srctree, 'scripts/get_feat.pl'),\n            'rest',\n            '--enable-fname',\n            '--dir',\n            os.path.join(srctree, 'Documentation', self.arguments[0]),\n        ]\n\n        if len(self.arguments) > 1:\n            args.extend(['--arch', self.arguments[1]])\n\n        lines = subprocess.check_output(args, cwd=os.path.dirname(doc.current_source)).decode('utf-8')\n\n        line_regex = re.compile(r\"^\\.\\. FILE (\\S+)$\")\n\n        out_lines = \"\"\n\n        for line in lines.split(\"\\n\"):\n            match = line_regex.search(line)\n            if match:\n                fname = match.group(1)\n\n                # Add the file to Sphinx build dependencies\n                env.note_dependency(os.path.abspath(fname))\n            else:\n                out_lines += line + \"\\n\"\n\n        nodeList = self.nestedParse(out_lines, fname)\n        return nodeList\n\n    def nestedParse(self, lines, fname):\n        content = ViewList()\n        node    = nodes.section()\n\n        if \"debug\" in self.options:\n            code_block = \"\\n\\n.. code-block:: rst\\n    :linenos:\\n\"\n            for l in lines.split(\"\\n\"):\n                code_block += \"\\n    \" + l\n            lines = code_block + \"\\n\\n\"\n\n        for c, l in enumerate(lines.split(\"\\n\")):\n            content.append(l, fname, c)\n\n        buf  = self.state.memo.title_styles, self.state.memo.section_level, self.state.memo.reporter\n\n        with switch_source_input(self.state, content):\n            self.state.nested_parse(content, 0, node, match_titles=1)\n\n        return node.children\n"}}, "msg": "docs: kernel_feat.py: fix build error for missing files\n\nIf the directory passed to the '.. kernel-feat::' directive does not\nexist or the get_feat.pl script does not find any files to extract\nfeatures from, Sphinx will report the following error:\n\n    Sphinx parallel build error:\n    UnboundLocalError: local variable 'fname' referenced before assignment\n    make[2]: *** [Documentation/Makefile:102: htmldocs] Error 2\n\nThis is due to how I changed the script in c48a7c44a1d0 (\"docs:\nkernel_feat.py: fix potential command injection\"). Before that, the\nfilename passed along to self.nestedParse() in this case was weirdly\njust the whole get_feat.pl invocation.\n\nWe can fix it by doing what kernel_abi.py does -- just pass\nself.arguments[0] as 'fname'.\n\nFixes: c48a7c44a1d0 (\"docs: kernel_feat.py: fix potential command injection\")\nCc: Justin Forbes <jforbes@fedoraproject.org>\nCc: Salvatore Bonaccorso <carnil@debian.org>\nCc: Jani Nikula <jani.nikula@intel.com>\nCc: Mauro Carvalho Chehab <mchehab@kernel.org>\nCc: stable@vger.kernel.org\nSigned-off-by: Vegard Nossum <vegard.nossum@oracle.com>\nLink: https://lore.kernel.org/r/20240205175133.774271-2-vegard.nossum@oracle.com\nSigned-off-by: Jonathan Corbet <corbet@lwn.net>"}}, "https://github.com/tdavenvidia/linux-nvidia-6.5": {"17354d52ab647899dca3ef3255a5c8b214e4654d": {"url": "https://api.github.com/repos/tdavenvidia/linux-nvidia-6.5/commits/17354d52ab647899dca3ef3255a5c8b214e4654d", "html_url": "https://github.com/tdavenvidia/linux-nvidia-6.5/commit/17354d52ab647899dca3ef3255a5c8b214e4654d", "sha": "17354d52ab647899dca3ef3255a5c8b214e4654d", "keyword": "command injection fix", "diff": "diff --git a/Documentation/sphinx/kernel_feat.py b/Documentation/sphinx/kernel_feat.py\nindex b5fa2f0542a5d..16e68bfb5ed6e 100644\n--- a/Documentation/sphinx/kernel_feat.py\n+++ b/Documentation/sphinx/kernel_feat.py\n@@ -118,7 +118,7 @@ def run(self):\n             else:\n                 out_lines += line + \"\\n\"\n \n-        nodeList = self.nestedParse(out_lines, fname)\n+        nodeList = self.nestedParse(out_lines, self.arguments[0])\n         return nodeList\n \n     def runCmd(self, cmd, **kwargs):\n", "message": "", "files": {"/Documentation/sphinx/kernel_feat.py": {"changes": [{"diff": "\n             else:\n                 out_lines += line + \"\\n\"\n \n-        nodeList = self.nestedParse(out_lines, fname)\n+        nodeList = self.nestedParse(out_lines, self.arguments[0])\n         return nodeList\n \n     def runCmd(self, cmd, **kwargs):\n", "add": 1, "remove": 1, "filename": "/Documentation/sphinx/kernel_feat.py", "badparts": ["        nodeList = self.nestedParse(out_lines, fname)"], "goodparts": ["        nodeList = self.nestedParse(out_lines, self.arguments[0])"]}], "source": "\n u\"\"\" kernel-feat ~~~~~~~~~~~ Implementation of the ``kernel-feat`` reST-directive. :copyright: Copyright(C) 2016 Markus Heiser :copyright: Copyright(C) 2016-2019 Mauro Carvalho Chehab :maintained-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org> :license: GPL Version 2, June 1991 see Linux/COPYING for details. The ``kernel-feat``(:py:class:`KernelFeat`) directive calls the scripts/get_feat.pl script to parse the Kernel ABI files. Overview of directive's argument and options. .. code-block:: rst .. kernel-feat:: <ABI directory location> :debug: The argument ``<ABI directory location>`` is required. It contains the location of the ABI files to be parsed. ``debug`` Inserts a code-block with the *raw* reST. Sometimes it is helpful to see what reST is generated. \"\"\" import codecs import os import re import subprocess import sys from os import path from docutils import nodes, statemachine from docutils.statemachine import ViewList from docutils.parsers.rst import directives, Directive from docutils.utils.error_reporting import ErrorString from sphinx.util.docutils import switch_source_input __version__ ='1.0' def setup(app): app.add_directive(\"kernel-feat\", KernelFeat) return dict( version=__version__ , parallel_read_safe=True , parallel_write_safe=True ) class KernelFeat(Directive): u\"\"\"KernelFeat(``kernel-feat``) directive\"\"\" required_arguments=1 optional_arguments=2 has_content=False final_argument_whitespace=True option_spec={ \"debug\" : directives.flag } def warn(self, message, **replace): replace[\"fname\"] =self.state.document.current_source replace[\"line_no\"]=replace.get(\"line_no\", self.lineno) message=(\"%(fname)s:%(line_no)s:[kernel-feat WARN]: \" +message) % replace self.state.document.settings.env.app.warn(message, prefix=\"\") def run(self): doc=self.state.document if not doc.settings.file_insertion_enabled: raise self.warning(\"docutils: file insertion disabled\") env=doc.settings.env cwd=path.dirname(doc.current_source) cmd=\"get_feat.pl rest --enable-fname --dir \" cmd +=self.arguments[0] if len(self.arguments) > 1: cmd +=\" --arch \" +self.arguments[1] srctree=path.abspath(os.environ[\"srctree\"]) fname=cmd path_env=os.pathsep.join([ srctree +os.sep +\"scripts\", os.environ[\"PATH\"] ]) shell_env=os.environ.copy() shell_env[\"PATH\"] =path_env shell_env[\"srctree\"]=srctree lines=self.runCmd(cmd, shell=True, cwd=cwd, env=shell_env) line_regex=re.compile(r\"^\\.\\. FILE(\\S+)$\") out_lines=\"\" for line in lines.split(\"\\n\"): match=line_regex.search(line) if match: fname=match.group(1) env.note_dependency(os.path.abspath(fname)) else: out_lines +=line +\"\\n\" nodeList=self.nestedParse(out_lines, fname) return nodeList def runCmd(self, cmd, **kwargs): u\"\"\"Run command ``cmd`` and return its stdout as unicode.\"\"\" try: proc=subprocess.Popen( cmd , stdout=subprocess.PIPE , stderr=subprocess.PIPE , **kwargs ) out, err=proc.communicate() out, err=codecs.decode(out, 'utf-8'), codecs.decode(err, 'utf-8') if proc.returncode !=0: raise self.severe( u\"command '%s' failed with return code %d\" %(cmd, proc.returncode) ) except OSError as exc: raise self.severe(u\"problems with '%s' directive: %s.\" %(self.name, ErrorString(exc))) return out def nestedParse(self, lines, fname): content=ViewList() node =nodes.section() if \"debug\" in self.options: code_block=\"\\n\\n.. code-block:: rst\\n :linenos:\\n\" for l in lines.split(\"\\n\"): code_block +=\"\\n \" +l lines=code_block +\"\\n\\n\" for c, l in enumerate(lines.split(\"\\n\")): content.append(l, fname, c) buf =self.state.memo.title_styles, self.state.memo.section_level, self.state.memo.reporter with switch_source_input(self.state, content): self.state.nested_parse(content, 0, node, match_titles=1) return node.children ", "sourceWithComments": "# coding=utf-8\n# SPDX-License-Identifier: GPL-2.0\n#\nu\"\"\"\n    kernel-feat\n    ~~~~~~~~~~~\n\n    Implementation of the ``kernel-feat`` reST-directive.\n\n    :copyright:  Copyright (C) 2016  Markus Heiser\n    :copyright:  Copyright (C) 2016-2019  Mauro Carvalho Chehab\n    :maintained-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>\n    :license:    GPL Version 2, June 1991 see Linux/COPYING for details.\n\n    The ``kernel-feat`` (:py:class:`KernelFeat`) directive calls the\n    scripts/get_feat.pl script to parse the Kernel ABI files.\n\n    Overview of directive's argument and options.\n\n    .. code-block:: rst\n\n        .. kernel-feat:: <ABI directory location>\n            :debug:\n\n    The argument ``<ABI directory location>`` is required. It contains the\n    location of the ABI files to be parsed.\n\n    ``debug``\n      Inserts a code-block with the *raw* reST. Sometimes it is helpful to see\n      what reST is generated.\n\n\"\"\"\n\nimport codecs\nimport os\nimport re\nimport subprocess\nimport sys\n\nfrom os import path\n\nfrom docutils import nodes, statemachine\nfrom docutils.statemachine import ViewList\nfrom docutils.parsers.rst import directives, Directive\nfrom docutils.utils.error_reporting import ErrorString\nfrom sphinx.util.docutils import switch_source_input\n\n__version__  = '1.0'\n\ndef setup(app):\n\n    app.add_directive(\"kernel-feat\", KernelFeat)\n    return dict(\n        version = __version__\n        , parallel_read_safe = True\n        , parallel_write_safe = True\n    )\n\nclass KernelFeat(Directive):\n\n    u\"\"\"KernelFeat (``kernel-feat``) directive\"\"\"\n\n    required_arguments = 1\n    optional_arguments = 2\n    has_content = False\n    final_argument_whitespace = True\n\n    option_spec = {\n        \"debug\"     : directives.flag\n    }\n\n    def warn(self, message, **replace):\n        replace[\"fname\"]   = self.state.document.current_source\n        replace[\"line_no\"] = replace.get(\"line_no\", self.lineno)\n        message = (\"%(fname)s:%(line_no)s: [kernel-feat WARN] : \" + message) % replace\n        self.state.document.settings.env.app.warn(message, prefix=\"\")\n\n    def run(self):\n\n        doc = self.state.document\n        if not doc.settings.file_insertion_enabled:\n            raise self.warning(\"docutils: file insertion disabled\")\n\n        env = doc.settings.env\n        cwd = path.dirname(doc.current_source)\n        cmd = \"get_feat.pl rest --enable-fname --dir \"\n        cmd += self.arguments[0]\n\n        if len(self.arguments) > 1:\n            cmd += \" --arch \" + self.arguments[1]\n\n        srctree = path.abspath(os.environ[\"srctree\"])\n\n        fname = cmd\n\n        # extend PATH with $(srctree)/scripts\n        path_env = os.pathsep.join([\n            srctree + os.sep + \"scripts\",\n            os.environ[\"PATH\"]\n        ])\n        shell_env = os.environ.copy()\n        shell_env[\"PATH\"]    = path_env\n        shell_env[\"srctree\"] = srctree\n\n        lines = self.runCmd(cmd, shell=True, cwd=cwd, env=shell_env)\n\n        line_regex = re.compile(r\"^\\.\\. FILE (\\S+)$\")\n\n        out_lines = \"\"\n\n        for line in lines.split(\"\\n\"):\n            match = line_regex.search(line)\n            if match:\n                fname = match.group(1)\n\n                # Add the file to Sphinx build dependencies\n                env.note_dependency(os.path.abspath(fname))\n            else:\n                out_lines += line + \"\\n\"\n\n        nodeList = self.nestedParse(out_lines, fname)\n        return nodeList\n\n    def runCmd(self, cmd, **kwargs):\n        u\"\"\"Run command ``cmd`` and return its stdout as unicode.\"\"\"\n\n        try:\n            proc = subprocess.Popen(\n                cmd\n                , stdout = subprocess.PIPE\n                , stderr = subprocess.PIPE\n                , **kwargs\n            )\n            out, err = proc.communicate()\n\n            out, err = codecs.decode(out, 'utf-8'), codecs.decode(err, 'utf-8')\n\n            if proc.returncode != 0:\n                raise self.severe(\n                    u\"command '%s' failed with return code %d\"\n                    % (cmd, proc.returncode)\n                )\n        except OSError as exc:\n            raise self.severe(u\"problems with '%s' directive: %s.\"\n                              % (self.name, ErrorString(exc)))\n        return out\n\n    def nestedParse(self, lines, fname):\n        content = ViewList()\n        node    = nodes.section()\n\n        if \"debug\" in self.options:\n            code_block = \"\\n\\n.. code-block:: rst\\n    :linenos:\\n\"\n            for l in lines.split(\"\\n\"):\n                code_block += \"\\n    \" + l\n            lines = code_block + \"\\n\\n\"\n\n        for c, l in enumerate(lines.split(\"\\n\")):\n            content.append(l, fname, c)\n\n        buf  = self.state.memo.title_styles, self.state.memo.section_level, self.state.memo.reporter\n\n        with switch_source_input(self.state, content):\n            self.state.nested_parse(content, 0, node, match_titles=1)\n\n        return node.children\n"}}, "msg": "docs: kernel_feat.py: fix build error for missing files\n\nBugLink: https://bugs.launchpad.net/bugs/2061814\n\ncommit c23de7ceae59e4ca5894c3ecf4f785c50c0fa428 upstream.\n\nIf the directory passed to the '.. kernel-feat::' directive does not\nexist or the get_feat.pl script does not find any files to extract\nfeatures from, Sphinx will report the following error:\n\n    Sphinx parallel build error:\n    UnboundLocalError: local variable 'fname' referenced before assignment\n    make[2]: *** [Documentation/Makefile:102: htmldocs] Error 2\n\nThis is due to how I changed the script in c48a7c44a1d0 (\"docs:\nkernel_feat.py: fix potential command injection\"). Before that, the\nfilename passed along to self.nestedParse() in this case was weirdly\njust the whole get_feat.pl invocation.\n\nWe can fix it by doing what kernel_abi.py does -- just pass\nself.arguments[0] as 'fname'.\n\nFixes: c48a7c44a1d0 (\"docs: kernel_feat.py: fix potential command injection\")\nCc: Justin Forbes <jforbes@fedoraproject.org>\nCc: Salvatore Bonaccorso <carnil@debian.org>\nCc: Jani Nikula <jani.nikula@intel.com>\nCc: Mauro Carvalho Chehab <mchehab@kernel.org>\nCc: stable@vger.kernel.org\nSigned-off-by: Vegard Nossum <vegard.nossum@oracle.com>\nLink: https://lore.kernel.org/r/20240205175133.774271-2-vegard.nossum@oracle.com\nSigned-off-by: Jonathan Corbet <corbet@lwn.net>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nSigned-off-by: Portia Stephens <portia.stephens@canonical.com>\nSigned-off-by: Roxana Nicolescu <roxana.nicolescu@canonical.com>"}}, "https://github.com/tuxedocomputers/linux": {"17354d52ab647899dca3ef3255a5c8b214e4654d": {"url": "https://api.github.com/repos/tuxedocomputers/linux/commits/17354d52ab647899dca3ef3255a5c8b214e4654d", "html_url": "https://github.com/tuxedocomputers/linux/commit/17354d52ab647899dca3ef3255a5c8b214e4654d", "sha": "17354d52ab647899dca3ef3255a5c8b214e4654d", "keyword": "command injection fix", "diff": "diff --git a/Documentation/sphinx/kernel_feat.py b/Documentation/sphinx/kernel_feat.py\nindex b5fa2f0542a5d..16e68bfb5ed6e 100644\n--- a/Documentation/sphinx/kernel_feat.py\n+++ b/Documentation/sphinx/kernel_feat.py\n@@ -118,7 +118,7 @@ def run(self):\n             else:\n                 out_lines += line + \"\\n\"\n \n-        nodeList = self.nestedParse(out_lines, fname)\n+        nodeList = self.nestedParse(out_lines, self.arguments[0])\n         return nodeList\n \n     def runCmd(self, cmd, **kwargs):\n", "message": "", "files": {"/Documentation/sphinx/kernel_feat.py": {"changes": [{"diff": "\n             else:\n                 out_lines += line + \"\\n\"\n \n-        nodeList = self.nestedParse(out_lines, fname)\n+        nodeList = self.nestedParse(out_lines, self.arguments[0])\n         return nodeList\n \n     def runCmd(self, cmd, **kwargs):\n", "add": 1, "remove": 1, "filename": "/Documentation/sphinx/kernel_feat.py", "badparts": ["        nodeList = self.nestedParse(out_lines, fname)"], "goodparts": ["        nodeList = self.nestedParse(out_lines, self.arguments[0])"]}], "source": "\n u\"\"\" kernel-feat ~~~~~~~~~~~ Implementation of the ``kernel-feat`` reST-directive. :copyright: Copyright(C) 2016 Markus Heiser :copyright: Copyright(C) 2016-2019 Mauro Carvalho Chehab :maintained-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org> :license: GPL Version 2, June 1991 see Linux/COPYING for details. The ``kernel-feat``(:py:class:`KernelFeat`) directive calls the scripts/get_feat.pl script to parse the Kernel ABI files. Overview of directive's argument and options. .. code-block:: rst .. kernel-feat:: <ABI directory location> :debug: The argument ``<ABI directory location>`` is required. It contains the location of the ABI files to be parsed. ``debug`` Inserts a code-block with the *raw* reST. Sometimes it is helpful to see what reST is generated. \"\"\" import codecs import os import re import subprocess import sys from os import path from docutils import nodes, statemachine from docutils.statemachine import ViewList from docutils.parsers.rst import directives, Directive from docutils.utils.error_reporting import ErrorString from sphinx.util.docutils import switch_source_input __version__ ='1.0' def setup(app): app.add_directive(\"kernel-feat\", KernelFeat) return dict( version=__version__ , parallel_read_safe=True , parallel_write_safe=True ) class KernelFeat(Directive): u\"\"\"KernelFeat(``kernel-feat``) directive\"\"\" required_arguments=1 optional_arguments=2 has_content=False final_argument_whitespace=True option_spec={ \"debug\" : directives.flag } def warn(self, message, **replace): replace[\"fname\"] =self.state.document.current_source replace[\"line_no\"]=replace.get(\"line_no\", self.lineno) message=(\"%(fname)s:%(line_no)s:[kernel-feat WARN]: \" +message) % replace self.state.document.settings.env.app.warn(message, prefix=\"\") def run(self): doc=self.state.document if not doc.settings.file_insertion_enabled: raise self.warning(\"docutils: file insertion disabled\") env=doc.settings.env cwd=path.dirname(doc.current_source) cmd=\"get_feat.pl rest --enable-fname --dir \" cmd +=self.arguments[0] if len(self.arguments) > 1: cmd +=\" --arch \" +self.arguments[1] srctree=path.abspath(os.environ[\"srctree\"]) fname=cmd path_env=os.pathsep.join([ srctree +os.sep +\"scripts\", os.environ[\"PATH\"] ]) shell_env=os.environ.copy() shell_env[\"PATH\"] =path_env shell_env[\"srctree\"]=srctree lines=self.runCmd(cmd, shell=True, cwd=cwd, env=shell_env) line_regex=re.compile(r\"^\\.\\. FILE(\\S+)$\") out_lines=\"\" for line in lines.split(\"\\n\"): match=line_regex.search(line) if match: fname=match.group(1) env.note_dependency(os.path.abspath(fname)) else: out_lines +=line +\"\\n\" nodeList=self.nestedParse(out_lines, fname) return nodeList def runCmd(self, cmd, **kwargs): u\"\"\"Run command ``cmd`` and return its stdout as unicode.\"\"\" try: proc=subprocess.Popen( cmd , stdout=subprocess.PIPE , stderr=subprocess.PIPE , **kwargs ) out, err=proc.communicate() out, err=codecs.decode(out, 'utf-8'), codecs.decode(err, 'utf-8') if proc.returncode !=0: raise self.severe( u\"command '%s' failed with return code %d\" %(cmd, proc.returncode) ) except OSError as exc: raise self.severe(u\"problems with '%s' directive: %s.\" %(self.name, ErrorString(exc))) return out def nestedParse(self, lines, fname): content=ViewList() node =nodes.section() if \"debug\" in self.options: code_block=\"\\n\\n.. code-block:: rst\\n :linenos:\\n\" for l in lines.split(\"\\n\"): code_block +=\"\\n \" +l lines=code_block +\"\\n\\n\" for c, l in enumerate(lines.split(\"\\n\")): content.append(l, fname, c) buf =self.state.memo.title_styles, self.state.memo.section_level, self.state.memo.reporter with switch_source_input(self.state, content): self.state.nested_parse(content, 0, node, match_titles=1) return node.children ", "sourceWithComments": "# coding=utf-8\n# SPDX-License-Identifier: GPL-2.0\n#\nu\"\"\"\n    kernel-feat\n    ~~~~~~~~~~~\n\n    Implementation of the ``kernel-feat`` reST-directive.\n\n    :copyright:  Copyright (C) 2016  Markus Heiser\n    :copyright:  Copyright (C) 2016-2019  Mauro Carvalho Chehab\n    :maintained-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>\n    :license:    GPL Version 2, June 1991 see Linux/COPYING for details.\n\n    The ``kernel-feat`` (:py:class:`KernelFeat`) directive calls the\n    scripts/get_feat.pl script to parse the Kernel ABI files.\n\n    Overview of directive's argument and options.\n\n    .. code-block:: rst\n\n        .. kernel-feat:: <ABI directory location>\n            :debug:\n\n    The argument ``<ABI directory location>`` is required. It contains the\n    location of the ABI files to be parsed.\n\n    ``debug``\n      Inserts a code-block with the *raw* reST. Sometimes it is helpful to see\n      what reST is generated.\n\n\"\"\"\n\nimport codecs\nimport os\nimport re\nimport subprocess\nimport sys\n\nfrom os import path\n\nfrom docutils import nodes, statemachine\nfrom docutils.statemachine import ViewList\nfrom docutils.parsers.rst import directives, Directive\nfrom docutils.utils.error_reporting import ErrorString\nfrom sphinx.util.docutils import switch_source_input\n\n__version__  = '1.0'\n\ndef setup(app):\n\n    app.add_directive(\"kernel-feat\", KernelFeat)\n    return dict(\n        version = __version__\n        , parallel_read_safe = True\n        , parallel_write_safe = True\n    )\n\nclass KernelFeat(Directive):\n\n    u\"\"\"KernelFeat (``kernel-feat``) directive\"\"\"\n\n    required_arguments = 1\n    optional_arguments = 2\n    has_content = False\n    final_argument_whitespace = True\n\n    option_spec = {\n        \"debug\"     : directives.flag\n    }\n\n    def warn(self, message, **replace):\n        replace[\"fname\"]   = self.state.document.current_source\n        replace[\"line_no\"] = replace.get(\"line_no\", self.lineno)\n        message = (\"%(fname)s:%(line_no)s: [kernel-feat WARN] : \" + message) % replace\n        self.state.document.settings.env.app.warn(message, prefix=\"\")\n\n    def run(self):\n\n        doc = self.state.document\n        if not doc.settings.file_insertion_enabled:\n            raise self.warning(\"docutils: file insertion disabled\")\n\n        env = doc.settings.env\n        cwd = path.dirname(doc.current_source)\n        cmd = \"get_feat.pl rest --enable-fname --dir \"\n        cmd += self.arguments[0]\n\n        if len(self.arguments) > 1:\n            cmd += \" --arch \" + self.arguments[1]\n\n        srctree = path.abspath(os.environ[\"srctree\"])\n\n        fname = cmd\n\n        # extend PATH with $(srctree)/scripts\n        path_env = os.pathsep.join([\n            srctree + os.sep + \"scripts\",\n            os.environ[\"PATH\"]\n        ])\n        shell_env = os.environ.copy()\n        shell_env[\"PATH\"]    = path_env\n        shell_env[\"srctree\"] = srctree\n\n        lines = self.runCmd(cmd, shell=True, cwd=cwd, env=shell_env)\n\n        line_regex = re.compile(r\"^\\.\\. FILE (\\S+)$\")\n\n        out_lines = \"\"\n\n        for line in lines.split(\"\\n\"):\n            match = line_regex.search(line)\n            if match:\n                fname = match.group(1)\n\n                # Add the file to Sphinx build dependencies\n                env.note_dependency(os.path.abspath(fname))\n            else:\n                out_lines += line + \"\\n\"\n\n        nodeList = self.nestedParse(out_lines, fname)\n        return nodeList\n\n    def runCmd(self, cmd, **kwargs):\n        u\"\"\"Run command ``cmd`` and return its stdout as unicode.\"\"\"\n\n        try:\n            proc = subprocess.Popen(\n                cmd\n                , stdout = subprocess.PIPE\n                , stderr = subprocess.PIPE\n                , **kwargs\n            )\n            out, err = proc.communicate()\n\n            out, err = codecs.decode(out, 'utf-8'), codecs.decode(err, 'utf-8')\n\n            if proc.returncode != 0:\n                raise self.severe(\n                    u\"command '%s' failed with return code %d\"\n                    % (cmd, proc.returncode)\n                )\n        except OSError as exc:\n            raise self.severe(u\"problems with '%s' directive: %s.\"\n                              % (self.name, ErrorString(exc)))\n        return out\n\n    def nestedParse(self, lines, fname):\n        content = ViewList()\n        node    = nodes.section()\n\n        if \"debug\" in self.options:\n            code_block = \"\\n\\n.. code-block:: rst\\n    :linenos:\\n\"\n            for l in lines.split(\"\\n\"):\n                code_block += \"\\n    \" + l\n            lines = code_block + \"\\n\\n\"\n\n        for c, l in enumerate(lines.split(\"\\n\")):\n            content.append(l, fname, c)\n\n        buf  = self.state.memo.title_styles, self.state.memo.section_level, self.state.memo.reporter\n\n        with switch_source_input(self.state, content):\n            self.state.nested_parse(content, 0, node, match_titles=1)\n\n        return node.children\n"}}, "msg": "docs: kernel_feat.py: fix build error for missing files\n\nBugLink: https://bugs.launchpad.net/bugs/2061814\n\ncommit c23de7ceae59e4ca5894c3ecf4f785c50c0fa428 upstream.\n\nIf the directory passed to the '.. kernel-feat::' directive does not\nexist or the get_feat.pl script does not find any files to extract\nfeatures from, Sphinx will report the following error:\n\n    Sphinx parallel build error:\n    UnboundLocalError: local variable 'fname' referenced before assignment\n    make[2]: *** [Documentation/Makefile:102: htmldocs] Error 2\n\nThis is due to how I changed the script in c48a7c44a1d0 (\"docs:\nkernel_feat.py: fix potential command injection\"). Before that, the\nfilename passed along to self.nestedParse() in this case was weirdly\njust the whole get_feat.pl invocation.\n\nWe can fix it by doing what kernel_abi.py does -- just pass\nself.arguments[0] as 'fname'.\n\nFixes: c48a7c44a1d0 (\"docs: kernel_feat.py: fix potential command injection\")\nCc: Justin Forbes <jforbes@fedoraproject.org>\nCc: Salvatore Bonaccorso <carnil@debian.org>\nCc: Jani Nikula <jani.nikula@intel.com>\nCc: Mauro Carvalho Chehab <mchehab@kernel.org>\nCc: stable@vger.kernel.org\nSigned-off-by: Vegard Nossum <vegard.nossum@oracle.com>\nLink: https://lore.kernel.org/r/20240205175133.774271-2-vegard.nossum@oracle.com\nSigned-off-by: Jonathan Corbet <corbet@lwn.net>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nSigned-off-by: Portia Stephens <portia.stephens@canonical.com>\nSigned-off-by: Roxana Nicolescu <roxana.nicolescu@canonical.com>"}}, "https://github.com/Special-K-s-Flightsim-Bots/DCSServerBot": {"981caaeace5b9e2ca4ab61421e3ab3e9a25d06ca": {"url": "https://api.github.com/repos/Special-K-s-Flightsim-Bots/DCSServerBot/commits/981caaeace5b9e2ca4ab61421e3ab3e9a25d06ca", "html_url": "https://github.com/Special-K-s-Flightsim-Bots/DCSServerBot/commit/981caaeace5b9e2ca4ab61421e3ab3e9a25d06ca", "sha": "981caaeace5b9e2ca4ab61421e3ab3e9a25d06ca", "keyword": "command injection change", "diff": "diff --git a/core/listener.py b/core/listener.py\nindex e7a59d0ca..edbb8d8f8 100644\n--- a/core/listener.py\n+++ b/core/listener.py\n@@ -1,21 +1,23 @@\n from __future__ import annotations\n import inspect\n from dataclasses import MISSING\n-from typing import TypeVar, TYPE_CHECKING, Any, Type, Optional\n+from typing import TypeVar, TYPE_CHECKING, Any, Type, Optional, Iterable, Callable\n \n if TYPE_CHECKING:\n     from core import Plugin, Server, Player\n     from services import DCSServerBot\n \n __all__ = [\n+    \"Event\",\n     \"event\",\n+    \"ChatCommand\",\n     \"chat_command\",\n     \"EventListener\",\n     \"TEventListener\"\n ]\n \n \n-def event(name: str = MISSING, cls: Type[Event] = MISSING, **attrs) -> Any:\n+def event(name: str = MISSING, cls: Type[Event] = MISSING, **attrs) -> Callable[[Any], Event]:\n     if cls is MISSING:\n         cls = Event\n \n@@ -36,7 +38,7 @@ async def __call__(self, listener: EventListener, server: Server, data: dict) ->\n         await self.callback(listener, server, data)\n \n \n-def chat_command(name: str = MISSING, cls: Type[ChatCommand] = MISSING, **attrs) -> Any:\n+def chat_command(name: str = MISSING, cls: Type[ChatCommand] = MISSING, **attrs) -> Callable[[Any], ChatCommand]:\n     if cls is MISSING:\n         cls = ChatCommand\n \n@@ -50,12 +52,13 @@ def decorator(func):\n \n class ChatCommand:\n     def __init__(self, func, **kwargs):\n-        self.name: str = kwargs.get('name') or func.__name__\n+        self.name: str = kwargs.get('name', func.__name__)\n         self.help: str = inspect.cleandoc(kwargs.get('help', ''))\n         self.roles: list[str] = kwargs.get('roles', [])\n         self.usage: str = kwargs.get('usage')\n         self.aliases: list[str] = kwargs.get('aliases', [])\n         self.callback = func\n+        self.enabled = kwargs.get('enabled', True)\n \n     async def __call__(self, listener: EventListener, server: Server, player: Player, params: list[str]) -> None:\n         await self.callback(listener, server, player, params)\n@@ -114,11 +117,11 @@ def __init__(self, plugin: Plugin):\n         self.prefix = self.node.config.get('chat_command_prefix', '-')\n \n     @property\n-    def events(self) -> Any:\n+    def events(self) -> Iterable[Event]:\n         return self.__events__.values()\n \n     @property\n-    def chat_commands(self) -> Any:\n+    def chat_commands(self) -> Iterable[ChatCommand]:\n         return self.__chat_commands__.values()\n \n     def has_event(self, name: str) -> bool:\n@@ -135,17 +138,20 @@ def get_config(self, server: Optional[Server] = None, *, plugin_name: Optional[s\n         return self.plugin.get_config(server, plugin_name=plugin_name, use_cache=use_cache)\n \n     @event(name=\"onChatCommand\")\n-    async def onChatCommand(self, server: Server, data: dict) -> None:\n+    async def _onChatCommand(self, server: Server, data: dict) -> None:\n         player: Player = server.get_player(id=data['from'], active=True)\n         command = self.__all_commands__.get(data['subcommand'])\n-        if not command or not player:\n-            return\n-        if command.roles and not player.has_discord_roles(command.roles):\n+        if not command or not player or not self.can_run(command, server, player):\n             return\n         await command(self, server, player, data.get('params'))\n \n     async def shutdown(self) -> None:\n         ...\n \n+    def can_run(self, command: ChatCommand, server: Server, player: Player) -> bool:\n+        if not command.enabled or (command.roles and not player.has_discord_roles(command.roles)):\n+            return False\n+        return True\n+\n \n TEventListener = TypeVar(\"TEventListener\", bound=EventListener)\ndiff --git a/core/utils/helper.py b/core/utils/helper.py\nindex 19a8ef557..0a18cee5b 100644\n--- a/core/utils/helper.py\n+++ b/core/utils/helper.py\n@@ -38,6 +38,7 @@\n     \"is_match_daystate\",\n     \"str_to_class\",\n     \"format_string\",\n+    \"sanitize_string\",\n     \"convert_time\",\n     \"format_time\",\n     \"get_utc_offset\",\n@@ -147,6 +148,16 @@ def format_field(self, value, spec):\n     return string_\n \n \n+def sanitize_string(s: str) -> str:\n+    # Replace single and double quotes, semicolons and backslashes\n+    s = re.sub(r\"[\\\"';\\\\]\", \"\", s)\n+\n+    # Replace comment sequences\n+    s = re.sub(r\"--|/\\*|\\*/\", \"\", s)\n+\n+    return s\n+\n+\n SECONDS_IN_DAY = 86400\n SECONDS_IN_HOUR = 3600\n SECONDS_IN_MINUTE = 60\ndiff --git a/locale/de/LC_MESSAGES/gamemaster.mo b/locale/de/LC_MESSAGES/gamemaster.mo\nindex 35b9dce8f..e4700dd75 100644\nBinary files a/locale/de/LC_MESSAGES/gamemaster.mo and b/locale/de/LC_MESSAGES/gamemaster.mo differ\ndiff --git a/locale/de/LC_MESSAGES/gamemaster.po b/locale/de/LC_MESSAGES/gamemaster.po\nindex a4e920568..035e50bfa 100644\n--- a/locale/de/LC_MESSAGES/gamemaster.po\n+++ b/locale/de/LC_MESSAGES/gamemaster.po\n@@ -203,9 +203,6 @@ msgstr \"{num} LUA files wurden hochgeladen. Du kannst jedes davon nun mit {comma\n msgid \"join a coalition\"\n msgstr \"Trete einer Koalition bei\"\n \n-msgid \"Coalitions are not enabled on this server.\"\n-msgstr \"Koalitionen sind auf diesem Server nicht aktiv.\"\n-\n msgid \"Usage: {}join <blue|red>\"\n msgstr \"Aufruf: {}join <blue|red>\"\n \ndiff --git a/locale/de/LC_MESSAGES/punishment.mo b/locale/de/LC_MESSAGES/punishment.mo\nindex 75623dc94..333462d6e 100644\nBinary files a/locale/de/LC_MESSAGES/punishment.mo and b/locale/de/LC_MESSAGES/punishment.mo differ\ndiff --git a/locale/de/LC_MESSAGES/punishment.po b/locale/de/LC_MESSAGES/punishment.po\nindex ec8374d9b..979a97168 100644\n--- a/locale/de/LC_MESSAGES/punishment.po\n+++ b/locale/de/LC_MESSAGES/punishment.po\n@@ -137,9 +137,6 @@ msgstr \"{victim}, Du bist Opfer eines {event}-Events durch den Spieler {offender\n msgid \"forgive another user for their infraction\"\n msgstr \"Vergebe einem anderen Benutzer f\u00fcr seine Verfehlung\"\n \n-msgid \"{prefix}forgive is not enabled on this server.\"\n-msgstr \"{prefix}forgive ist auf diesem Server nicht aktiviert.\"\n-\n msgid \"There is nothing to forgive (maybe too late?)\"\n msgstr \"Es gibt nichts zu vergeben (ggf. zu sp\u00e4t?)\"\n \ndiff --git a/locale/es/LC_MESSAGES/gamemaster.mo b/locale/es/LC_MESSAGES/gamemaster.mo\nindex 43c288994..3c3cf0773 100644\nBinary files a/locale/es/LC_MESSAGES/gamemaster.mo and b/locale/es/LC_MESSAGES/gamemaster.mo differ\ndiff --git a/locale/es/LC_MESSAGES/gamemaster.po b/locale/es/LC_MESSAGES/gamemaster.po\nindex c72989a25..b0572323f 100644\n--- a/locale/es/LC_MESSAGES/gamemaster.po\n+++ b/locale/es/LC_MESSAGES/gamemaster.po\n@@ -203,9 +203,6 @@ msgstr \"{num} ficheros LUA cargados. puede ejecutar cualquiera de ellos con {com\n msgid \"join a coalition\"\n msgstr \"Unirse a una coalici\u00f3n\"\n \n-msgid \"Coalitions are not enabled on this server.\"\n-msgstr \"No est\u00e1n habilitadas las coaliciones en \u00e9ste servidor.\"\n-\n msgid \"Usage: {}join <blue|red>\"\n msgstr \"Uso: {}join <blue|red>\"\n \ndiff --git a/locale/es/LC_MESSAGES/punishment.mo b/locale/es/LC_MESSAGES/punishment.mo\nindex a62128050..3dab8028c 100644\nBinary files a/locale/es/LC_MESSAGES/punishment.mo and b/locale/es/LC_MESSAGES/punishment.mo differ\ndiff --git a/locale/es/LC_MESSAGES/punishment.po b/locale/es/LC_MESSAGES/punishment.po\nindex 6426b1973..92d703a3b 100644\n--- a/locale/es/LC_MESSAGES/punishment.po\n+++ b/locale/es/LC_MESSAGES/punishment.po\n@@ -137,9 +137,6 @@ msgstr \"{victim}, has sido v\u00edctima de {event} por el jugador {offender}\\n\"\n msgid \"forgive another user for their infraction\"\n msgstr \"perdona a otro usuario por su infracci\u00f3n\"\n \n-msgid \"{prefix}forgive is not enabled on this server.\"\n-msgstr \"{prefix}forgive no est\u00e1 habilitado en este servidor.\"\n-\n msgid \"There is nothing to forgive (maybe too late?)\"\n msgstr \"No hay nada que perdonar (\u00bfquiz\u00e1s demasiado tarde?)\"\n \ndiff --git a/locale/ru/LC_MESSAGES/gamemaster.mo b/locale/ru/LC_MESSAGES/gamemaster.mo\nindex ec4f4f670..70dac5b74 100644\nBinary files a/locale/ru/LC_MESSAGES/gamemaster.mo and b/locale/ru/LC_MESSAGES/gamemaster.mo differ\ndiff --git a/locale/ru/LC_MESSAGES/gamemaster.po b/locale/ru/LC_MESSAGES/gamemaster.po\nindex 58c1491a6..83c5e41c7 100644\n--- a/locale/ru/LC_MESSAGES/gamemaster.po\n+++ b/locale/ru/LC_MESSAGES/gamemaster.po\n@@ -208,9 +208,6 @@ msgstr \"{num} lua \u0444\u0430\u0439\u043b\u043e\u0432 \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043d\u043e. \u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0432\u044b\u043f\u043e\u043b\n msgid \"join a coalition\"\n msgstr \"\u043f\u0440\u0438\u0441\u043e\u0435\u0434\u0438\u043d\u0438\u0442\u044c\u0441\u044f \u043a \u043a\u043e\u0430\u043b\u0438\u0446\u0438\u0438\"\n \n-msgid \"Coalitions are not enabled on this server.\"\n-msgstr \"\u041a\u043e\u0430\u043b\u0438\u0446\u0438\u0438 \u043d\u0435 \u0432\u043a\u043b\u044e\u0447\u0435\u043d\u044b \u0434\u043b\u044f \u0434\u0430\u043d\u043d\u043e\u0433\u043e \u0441\u0435\u0440\u0432\u0435\u0440\u0430.\"\n-\n msgid \"Usage: {}join <blue|red>\"\n msgstr \"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435: {}join <blue|red>\"\n \ndiff --git a/locale/ru/LC_MESSAGES/punishment.mo b/locale/ru/LC_MESSAGES/punishment.mo\nindex 88ab8b5db..59e314328 100644\nBinary files a/locale/ru/LC_MESSAGES/punishment.mo and b/locale/ru/LC_MESSAGES/punishment.mo differ\ndiff --git a/locale/ru/LC_MESSAGES/punishment.po b/locale/ru/LC_MESSAGES/punishment.po\nindex 8a4f6dfe0..2bdc0c723 100644\n--- a/locale/ru/LC_MESSAGES/punishment.po\n+++ b/locale/ru/LC_MESSAGES/punishment.po\n@@ -137,9 +137,6 @@ msgstr \"{victim}, \u0432\u044b \u0441\u0442\u0430\u043b\u0438 \u0436\u0435\u0440\u0442\u0432\u043e\u0439 {event} \u0438\u0433\u0440\u043e\u043a\u0430 {offender}\n msgid \"forgive another user for their infraction\"\n msgstr \"\u041f\u0440\u043e\u0449\u0430\u0435\u0442 \u0434\u0440\u0443\u0433\u043e\u0433\u043e \u0438\u0433\u0440\u043e\u043a\u0430 \u0437\u0430 \u0438\u0445 \u043d\u0430\u0440\u0443\u0448\u0435\u043d\u0438\u044f\"\n \n-msgid \"{prefix}forgive is not enabled on this server.\"\n-msgstr \"{prefix}forgive \u043d\u0435 \u0432\u043a\u043b\u044e\u0447\u0435\u043d \u0434\u043b\u044f \u044d\u0442\u043e\u0433\u043e \u0441\u0435\u0440\u0432\u0435\u0440\u0430.\"\n-\n msgid \"There is nothing to forgive (maybe too late?)\"\n msgstr \"\u041d\u0435\u0447\u0435\u0433\u043e \u043f\u0440\u043e\u0449\u0430\u0442\u044c (\u043c\u043e\u0436\u0435\u0442 \u0443\u0436\u0435 \u043f\u043e\u0437\u0434\u043d\u043e?)\"\n \ndiff --git a/plugins/gamemaster/listener.py b/plugins/gamemaster/listener.py\nindex 0ec3dc84c..c021f9f55 100644\n--- a/plugins/gamemaster/listener.py\n+++ b/plugins/gamemaster/listener.py\n@@ -6,7 +6,7 @@\n import psycopg\n \n from core import EventListener, Side, Coalition, Channel, utils, event, chat_command, CloudRotatingFileHandler, \\\n-    get_translation\n+    get_translation, ChatCommand\n from datetime import datetime\n from typing import Optional, TYPE_CHECKING\n \n@@ -22,6 +22,12 @@ def __init__(self, plugin: Plugin):\n         super().__init__(plugin)\n         self.chat_log = dict()\n \n+    def can_run(self, command: ChatCommand, server: Server, player: Player) -> bool:\n+        if (command.name in ['join', 'leave', 'red', 'blue', 'coalition', 'password'] and\n+                not self.get_coalition(server, player)):\n+            return False\n+        return super().can_run(command, server, player)\n+\n     @event(name=\"registerDCSServer\")\n     async def registerDCSServer(self, server: Server, _: dict) -> None:\n         if not server.locals.get('chat_log') or server.name in self.chat_log:\n@@ -175,9 +181,6 @@ async def resetCampaign(self, server: Server, _: dict) -> None:\n         await self.campaign('start', servers=[server], name=name)\n \n     async def _join(self, server: Server, player: Player, params: list[str]):\n-        if not server.locals.get('coalitions'):\n-            player.sendChatMessage(_(\"Coalitions are not enabled on this server.\"))\n-            return\n         coalition = params[0] if params else ''\n         if coalition.casefold() not in ['blue', 'red']:\n             player.sendChatMessage(_(\"Usage: {}join <blue|red>\").format(self.prefix))\n@@ -322,8 +325,6 @@ async def _coalition(self, server: Server, player: Player):\n \n     @chat_command(name=\"coalition\", help=_(\"displays your current coalition\"))\n     async def coalition(self, server: Server, player: Player, params: list[str]):\n-        if not server.locals.get('coalitions'):\n-            player.sendChatMessage(_(\"Coalitions are not enabled on this server.\"))\n         # noinspection PyAsyncCall\n         asyncio.create_task(self._coalition(server, player))\n \n@@ -341,8 +342,6 @@ async def _password(self, server: Server, player: Player):\n \n     @chat_command(name=\"password\", aliases=[\"passwd\"], help=_(\"displays the coalition password\"))\n     async def password(self, server: Server, player: Player, params: list[str]):\n-        if not server.locals.get('coalitions'):\n-            player.sendChatMessage(_(\"Coalitions are not enabled on this server.\"))\n         # noinspection PyAsyncCall\n         asyncio.create_task(self._password(server, player))\n \ndiff --git a/plugins/help/listener.py b/plugins/help/listener.py\nindex 84bd3306b..8a105b650 100644\n--- a/plugins/help/listener.py\n+++ b/plugins/help/listener.py\n@@ -17,13 +17,13 @@ async def onPlayerStart(self, server: Server, data: dict) -> None:\n             player.sendChatMessage(f\"Use \\\"{self.prefix}help\\\" for commands.\")\n \n     @chat_command(name=\"help\", help=\"The help command\")\n-    async def help(self, _: Server, player: Player, __: list[str]):\n+    async def help(self, server: Server, player: Player, params: list[str]):\n         messages = [\n             f'You can use the following commands:\\n'\n         ]\n         for listener in self.bot.eventListeners:\n             for command in listener.chat_commands:\n-                if command.roles and not player.has_discord_roles(command.roles):\n+                if not listener.can_run(command, server, player):\n                     continue\n                 cmd = f\"{self.prefix}{command.name}\"\n                 if command.usage:\ndiff --git a/plugins/punishment/listener.py b/plugins/punishment/listener.py\nindex 7a2ba8510..55a12710a 100644\n--- a/plugins/punishment/listener.py\n+++ b/plugins/punishment/listener.py\n@@ -1,6 +1,6 @@\n import asyncio\n \n-from core import EventListener, Plugin, Server, Player, Status, event, chat_command, utils, get_translation\n+from core import EventListener, Plugin, Server, Player, Status, event, chat_command, utils, get_translation, ChatCommand\n from plugins.competitive.commands import Competitive\n from typing import Optional\n \n@@ -13,6 +13,11 @@ def __init__(self, plugin: Plugin):\n         super().__init__(plugin)\n         self.lock = asyncio.Lock()\n \n+    def can_run(self, command: ChatCommand, server: Server, player: Player) -> bool:\n+        if command.name == 'forgive':\n+            return self.plugin.get_config(server).get('forgive') is not None\n+        return super().can_run(command, server, player)\n+\n     @event(name=\"onMissionLoadEnd\")\n     async def onMissionLoadEnd(self, server: Server, _: dict) -> None:\n         # make sure the config cache is re-read on mission changes\n@@ -161,10 +166,6 @@ async def onPlayerStart(self, server: Server, data: dict) -> None:\n     @chat_command(name=\"forgive\", help=_(\"forgive another user for their infraction\"))\n     async def forgive(self, server: Server, target: Player, params: list[str]):\n         config = self.plugin.get_config(server)\n-        if 'forgive' not in config:\n-            target.sendChatMessage(_('{prefix}forgive is not enabled on this server.').format(prefix=self.prefix))\n-            return\n-\n         forgive = config.get('forgive', 30)\n         async with self.lock:\n             async with self.apool.connection() as conn:\ndiff --git a/plugins/userstats/filter.py b/plugins/userstats/filter.py\nindex 446749b74..14797203e 100644\n--- a/plugins/userstats/filter.py\n+++ b/plugins/userstats/filter.py\n@@ -65,7 +65,7 @@ def filter(self, bot: DCSServerBot) -> str:\n             period = self.period[7:]\n         else:\n             period = self.period\n-        if period in [None, 'all']:\n+        if period not in PeriodFilter.list(bot) or period in [None, 'all']:\n             return '1 = 1'\n         elif period == 'yesterday':\n             return \"DATE_TRUNC('day', s.hop_on) = current_date - 1\"\n@@ -105,6 +105,7 @@ def filter(self, bot: DCSServerBot) -> str:\n             period = self.period[9:]\n         else:\n             period = self.period\n+        period = utils.sanitize_string(period)\n         return f\"tsrange(s.hop_on, s.hop_off) && (SELECT tsrange(start, stop) FROM campaigns \" \\\n                f\"WHERE name ILIKE '{period}') AND m.server_name in (SELECT server_name FROM campaigns_servers)\"\n \n@@ -128,7 +129,8 @@ def supports(bot: DCSServerBot, period: str) -> bool:\n         return period and period.lower().startswith('mission:')\n \n     def filter(self, bot: DCSServerBot) -> str:\n-        return f\"m.mission_name ILIKE '%%{self.period[8:].strip()}%%'\"\n+        name = utils.sanitize_string(self.period[8:].strip())\n+        return f\"m.mission_name ILIKE '%%{name}%%'\"\n \n     def format(self, bot: DCSServerBot) -> str:\n         return f'Missions containing \"{self.period[8:].strip().title()}\"\\n'\n@@ -146,7 +148,8 @@ def supports(bot: DCSServerBot, period: str) -> bool:\n         return period and period.startswith('mission_id:')\n \n     def filter(self, bot: DCSServerBot) -> str:\n-        return f\"m.id = {self.period[11:].strip()}\"\n+        mission_id = utils.sanitize_string(self.period[11:].strip())\n+        return f\"m.id = {mission_id}\"\n \n     def format(self, bot: DCSServerBot) -> str:\n         return f'Mission '\n@@ -192,11 +195,12 @@ def supports(bot: DCSServerBot, period: str) -> bool:\n         return period and period.lower().startswith('squadron:')\n \n     def filter(self, bot: DCSServerBot) -> str:\n+        name = utils.sanitize_string(self.period[9:].strip())\n         return f\"\"\"\n             s.player_ucid IN (\n                 SELECT player_ucid \n                 FROM squadron_members sm, squadrons ss \n-                WHERE ss.id = sm.squadron_id AND ss.name = '{self.period[9:].strip()}'\n+                WHERE ss.id = sm.squadron_id AND ss.name = '{name}'\n             )\n         \"\"\"\n \n@@ -209,7 +213,7 @@ class MissionStatisticsFilter(PeriodFilter):\n     def filter(self, bot: DCSServerBot) -> str:\n         if self.period in [None, 'all']:\n             return '1 = 1'\n-        else:\n+        elif self.period in self.list(bot):\n             return f\"DATE(time) > (DATE((now() AT TIME ZONE 'utc')) - interval '1 {self.period}')\"\n \n \ndiff --git a/plugins/voting/listener.py b/plugins/voting/listener.py\nindex d5a9ea191..6ec011618 100644\n--- a/plugins/voting/listener.py\n+++ b/plugins/voting/listener.py\n@@ -1,6 +1,6 @@\n import asyncio\n \n-from core import EventListener, chat_command, Server, Player, utils, Coalition, Plugin, event\n+from core import EventListener, chat_command, Server, Player, utils, Coalition, Plugin, event, ChatCommand\n from functools import partial\n from itertools import islice\n from typing import Optional\n@@ -132,8 +132,12 @@ async def end_vote(self):\n \n \n class VotingListener(EventListener):\n-    def __init__(self, plugin: Plugin):\n-        super().__init__(plugin)\n+\n+    def can_run(self, command: ChatCommand, server: Server, player: Player) -> bool:\n+        config = self.get_config(server=server)\n+        if not config:\n+            return False\n+        return super().can_run(command, server, player)\n \n     def check_role(self, player: Player, roles: Optional[list[str]] = None) -> bool:\n         if not roles:\n@@ -219,8 +223,6 @@ async def vote(self, server: Server, player: Player, params: list[str]):\n         global all_votes\n \n         config = self.get_config(server=server)\n-        if not config:\n-            return\n         if server.name in all_votes:\n             if len(params) == 1 and params[0] == 'cancel':\n                 if utils.check_roles(['DCS Admin'], player.member):\n", "message": "", "files": {"/core/listener.py": {"changes": [{"diff": "\n from __future__ import annotations\n import inspect\n from dataclasses import MISSING\n-from typing import TypeVar, TYPE_CHECKING, Any, Type, Optional\n+from typing import TypeVar, TYPE_CHECKING, Any, Type, Optional, Iterable, Callable\n \n if TYPE_CHECKING:\n     from core import Plugin, Server, Player\n     from services import DCSServerBot\n \n __all__ = [\n+    \"Event\",\n     \"event\",\n+    \"ChatCommand\",\n     \"chat_command\",\n     \"EventListener\",\n     \"TEventListener\"\n ]\n \n \n-def event(name: str = MISSING, cls: Type[Event] = MISSING, **attrs) -> Any:\n+def event(name: str = MISSING, cls: Type[Event] = MISSING, **attrs) -> Callable[[Any], Event]:\n     if cls is MISSING:\n         cls = Event\n \n", "add": 4, "remove": 2, "filename": "/core/listener.py", "badparts": ["from typing import TypeVar, TYPE_CHECKING, Any, Type, Optional", "def event(name: str = MISSING, cls: Type[Event] = MISSING, **attrs) -> Any:"], "goodparts": ["from typing import TypeVar, TYPE_CHECKING, Any, Type, Optional, Iterable, Callable", "    \"Event\",", "    \"ChatCommand\",", "def event(name: str = MISSING, cls: Type[Event] = MISSING, **attrs) -> Callable[[Any], Event]:"]}, {"diff": "\n         await self.callback(listener, server, data)\n \n \n-def chat_command(name: str = MISSING, cls: Type[ChatCommand] = MISSING, **attrs) -> Any:\n+def chat_command(name: str = MISSING, cls: Type[ChatCommand] = MISSING, **attrs) -> Callable[[Any], ChatCommand]:\n     if cls is MISSING:\n         cls = ChatCommand\n \n", "add": 1, "remove": 1, "filename": "/core/listener.py", "badparts": ["def chat_command(name: str = MISSING, cls: Type[ChatCommand] = MISSING, **attrs) -> Any:"], "goodparts": ["def chat_command(name: str = MISSING, cls: Type[ChatCommand] = MISSING, **attrs) -> Callable[[Any], ChatCommand]:"]}, {"diff": "\n         self.prefix = self.node.config.get('chat_command_prefix', '-')\n \n     @property\n-    def events(self) -> Any:\n+    def events(self) -> Iterable[Event]:\n         return self.__events__.values()\n \n     @property\n-    def chat_commands(self) -> Any:\n+    def chat_commands(self) -> Iterable[ChatCommand]:\n         return self.__chat_commands__.values()\n \n     def has_event(self, name: str) -> bool:\n", "add": 2, "remove": 2, "filename": "/core/listener.py", "badparts": ["    def events(self) -> Any:", "    def chat_commands(self) -> Any:"], "goodparts": ["    def events(self) -> Iterable[Event]:", "    def chat_commands(self) -> Iterable[ChatCommand]:"]}, {"diff": "\n         return self.plugin.get_config(server, plugin_name=plugin_name, use_cache=use_cache)\n \n     @event(name=\"onChatCommand\")\n-    async def onChatCommand(self, server: Server, data: dict) -> None:\n+    async def _onChatCommand(self, server: Server, data: dict) -> None:\n         player: Player = server.get_player(id=data['from'], active=True)\n         command = self.__all_commands__.get(data['subcommand'])\n-        if not command or not player:\n-            return\n-        if command.roles and not player.has_discord_roles(command.roles):\n+        if not command or not player or not self.can_run(command, server, player):\n             return\n         await command(self, server, player, data.get('params'))\n \n     async def shutdown(self) -> None:\n         ...\n \n+    def can_run(self, command: ChatCommand, server: Server, player: Player) -> bool:\n+        if not command.enabled or (command.roles and not player.has_discord_roles(command.roles)):\n+            return False\n+        return True\n+\n \n TEventListener = TypeVar(\"TEventListener\", bound=EventListener)", "add": 7, "remove": 4, "filename": "/core/listener.py", "badparts": ["    async def onChatCommand(self, server: Server, data: dict) -> None:", "        if not command or not player:", "            return", "        if command.roles and not player.has_discord_roles(command.roles):"], "goodparts": ["    async def _onChatCommand(self, server: Server, data: dict) -> None:", "        if not command or not player or not self.can_run(command, server, player):", "    def can_run(self, command: ChatCommand, server: Server, player: Player) -> bool:", "        if not command.enabled or (command.roles and not player.has_discord_roles(command.roles)):", "            return False", "        return True"]}], "source": "\nfrom __future__ import annotations import inspect from dataclasses import MISSING from typing import TypeVar, TYPE_CHECKING, Any, Type, Optional if TYPE_CHECKING: from core import Plugin, Server, Player from services import DCSServerBot __all__=[ \"event\", \"chat_command\", \"EventListener\", \"TEventListener\" ] def event(name: str=MISSING, cls: Type[Event]=MISSING, **attrs) -> Any: if cls is MISSING: cls=Event def decorator(func): if isinstance(func, Event): raise TypeError('Callback is already an Event') return cls(func, name=name, **attrs) return decorator class Event: def __init__(self, func, **kwargs): self.name: str=kwargs.get('name') or func.__name__ self.callback=func async def __call__(self, listener: EventListener, server: Server, data: dict) -> None: await self.callback(listener, server, data) def chat_command(name: str=MISSING, cls: Type[ChatCommand]=MISSING, **attrs) -> Any: if cls is MISSING: cls=ChatCommand def decorator(func): if isinstance(func, ChatCommand): raise TypeError('Callback is already a ChatCommand') return cls(func, name=name, **attrs) return decorator class ChatCommand: def __init__(self, func, **kwargs): self.name: str=kwargs.get('name') or func.__name__ self.help: str=inspect.cleandoc(kwargs.get('help', '')) self.roles: list[str]=kwargs.get('roles',[]) self.usage: str=kwargs.get('usage') self.aliases: list[str]=kwargs.get('aliases',[]) self.callback=func async def __call__(self, listener: EventListener, server: Server, player: Player, params: list[str]) -> None: await self.callback(listener, server, player, params) class EventListenerMeta(type): __events__: dict[str, Event] __chat_commands__: dict[str, ChatCommand] def __new__(cls, *args: Any, **kwargs: Any): name, bases, attrs=args events={} chat_commands={} new_cls=super().__new__(cls, name, bases, attrs, **kwargs) for base in reversed(new_cls.__mro__): for elem, value in base.__dict__.items(): if elem in events: del events[elem] if elem in chat_commands: del chat_commands[elem] if isinstance(value, Event): events[value.name]=value elif isinstance(value, ChatCommand): chat_commands[value.name]=value new_cls.__events__=events new_cls.__chat_commands__=chat_commands return new_cls class EventListener(metaclass=EventListenerMeta): __events__: dict[str, Event] __chat_commands__: dict[str, ChatCommand] __all_commands__: dict[str, ChatCommand] def __new__(cls, plugin: Plugin): self=super().__new__(cls) self.__events__=cls.__events__ self.__chat_commands__=cls.__chat_commands__ self.__all_commands__={} for key, value in self.__chat_commands__.items(): self.__all_commands__[key]=value for alias in value.aliases: self.__all_commands__[alias]=value return self def __init__(self, plugin: Plugin): self.plugin: Plugin=plugin self.plugin_name=type(self).__module__.split('.')[-2] self.bot: DCSServerBot=plugin.bot self.node=plugin.node self.log=plugin.log self.pool=plugin.pool self.apool=plugin.apool self.locals: dict=plugin.locals self.loop=plugin.loop self.prefix=self.node.config.get('chat_command_prefix', '-') @property def events(self) -> Any: return self.__events__.values() @property def chat_commands(self) -> Any: return self.__chat_commands__.values() def has_event(self, name: str) -> bool: return name in self.__events__ async def processEvent(self, name: str, server: Server, data: dict) -> None: try: await self.__events__[name](self, server, data) except Exception as ex: self.log.exception(ex) def get_config(self, server: Optional[Server]=None, *, plugin_name: Optional[str]=None, use_cache: Optional[bool]=True) -> dict: return self.plugin.get_config(server, plugin_name=plugin_name, use_cache=use_cache) @event(name=\"onChatCommand\") async def onChatCommand(self, server: Server, data: dict) -> None: player: Player=server.get_player(id=data['from'], active=True) command=self.__all_commands__.get(data['subcommand']) if not command or not player: return if command.roles and not player.has_discord_roles(command.roles): return await command(self, server, player, data.get('params')) async def shutdown(self) -> None: ... TEventListener=TypeVar(\"TEventListener\", bound=EventListener) ", "sourceWithComments": "from __future__ import annotations\nimport inspect\nfrom dataclasses import MISSING\nfrom typing import TypeVar, TYPE_CHECKING, Any, Type, Optional\n\nif TYPE_CHECKING:\n    from core import Plugin, Server, Player\n    from services import DCSServerBot\n\n__all__ = [\n    \"event\",\n    \"chat_command\",\n    \"EventListener\",\n    \"TEventListener\"\n]\n\n\ndef event(name: str = MISSING, cls: Type[Event] = MISSING, **attrs) -> Any:\n    if cls is MISSING:\n        cls = Event\n\n    def decorator(func):\n        if isinstance(func, Event):\n            raise TypeError('Callback is already an Event')\n        return cls(func, name=name, **attrs)\n\n    return decorator\n\n\nclass Event:\n    def __init__(self, func, **kwargs):\n        self.name: str = kwargs.get('name') or func.__name__\n        self.callback = func\n\n    async def __call__(self, listener: EventListener, server: Server, data: dict) -> None:\n        await self.callback(listener, server, data)\n\n\ndef chat_command(name: str = MISSING, cls: Type[ChatCommand] = MISSING, **attrs) -> Any:\n    if cls is MISSING:\n        cls = ChatCommand\n\n    def decorator(func):\n        if isinstance(func, ChatCommand):\n            raise TypeError('Callback is already a ChatCommand')\n        return cls(func, name=name, **attrs)\n\n    return decorator\n\n\nclass ChatCommand:\n    def __init__(self, func, **kwargs):\n        self.name: str = kwargs.get('name') or func.__name__\n        self.help: str = inspect.cleandoc(kwargs.get('help', ''))\n        self.roles: list[str] = kwargs.get('roles', [])\n        self.usage: str = kwargs.get('usage')\n        self.aliases: list[str] = kwargs.get('aliases', [])\n        self.callback = func\n\n    async def __call__(self, listener: EventListener, server: Server, player: Player, params: list[str]) -> None:\n        await self.callback(listener, server, player, params)\n\n\nclass EventListenerMeta(type):\n    __events__: dict[str, Event]\n    __chat_commands__: dict[str, ChatCommand]\n\n    def __new__(cls, *args: Any, **kwargs: Any):\n        name, bases, attrs = args\n        events = {}\n        chat_commands = {}\n        new_cls = super().__new__(cls, name, bases, attrs, **kwargs)\n        for base in reversed(new_cls.__mro__):\n            for elem, value in base.__dict__.items():\n                if elem in events:\n                    del events[elem]\n                if elem in chat_commands:\n                    del chat_commands[elem]\n                if isinstance(value, Event):\n                    events[value.name] = value\n                elif isinstance(value, ChatCommand):\n                    chat_commands[value.name] = value\n        new_cls.__events__ = events\n        new_cls.__chat_commands__ = chat_commands\n        return new_cls\n\n\nclass EventListener(metaclass=EventListenerMeta):\n    __events__: dict[str, Event]\n    __chat_commands__: dict[str, ChatCommand]\n    __all_commands__: dict[str, ChatCommand]\n\n    def __new__(cls, plugin: Plugin):\n        self = super().__new__(cls)\n        self.__events__ = cls.__events__\n        self.__chat_commands__ = cls.__chat_commands__\n        self.__all_commands__ = {}\n        for key, value in self.__chat_commands__.items():\n            self.__all_commands__[key] = value\n            for alias in value.aliases:\n                self.__all_commands__[alias] = value\n        return self\n\n    def __init__(self, plugin: Plugin):\n        self.plugin: Plugin = plugin\n        self.plugin_name = type(self).__module__.split('.')[-2]\n        self.bot: DCSServerBot = plugin.bot\n        self.node = plugin.node\n        self.log = plugin.log\n        self.pool = plugin.pool\n        self.apool = plugin.apool\n        self.locals: dict = plugin.locals\n        self.loop = plugin.loop\n        self.prefix = self.node.config.get('chat_command_prefix', '-')\n\n    @property\n    def events(self) -> Any:\n        return self.__events__.values()\n\n    @property\n    def chat_commands(self) -> Any:\n        return self.__chat_commands__.values()\n\n    def has_event(self, name: str) -> bool:\n        return name in self.__events__\n\n    async def processEvent(self, name: str, server: Server, data: dict) -> None:\n        try:\n            await self.__events__[name](self, server, data)\n        except Exception as ex:\n            self.log.exception(ex)\n\n    def get_config(self, server: Optional[Server] = None, *, plugin_name: Optional[str] = None,\n                   use_cache: Optional[bool] = True) -> dict:\n        return self.plugin.get_config(server, plugin_name=plugin_name, use_cache=use_cache)\n\n    @event(name=\"onChatCommand\")\n    async def onChatCommand(self, server: Server, data: dict) -> None:\n        player: Player = server.get_player(id=data['from'], active=True)\n        command = self.__all_commands__.get(data['subcommand'])\n        if not command or not player:\n            return\n        if command.roles and not player.has_discord_roles(command.roles):\n            return\n        await command(self, server, player, data.get('params'))\n\n    async def shutdown(self) -> None:\n        ...\n\n\nTEventListener = TypeVar(\"TEventListener\", bound=EventListener)\n"}}, "msg": "CHANGES:\n- In-game help will only display commands that can be used.\n\nBUGFIX:\n- more checks for possible injections"}}}